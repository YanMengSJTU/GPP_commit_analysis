diff --git a/.travis.yml b/.travis.yml
index bb8adf60b..82e19aef9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,7 +6,7 @@ before_script:
   - travis/before_script.sh
 
 script: 
-  - mvn test -Ptest-output
+  - mvn test javadoc:javadoc -Ptest-output
   - find $HOME/.m2 -name "_remote.repositories" | xargs rm
   - find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
   
diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 000000000..f5dd1d233
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,26 @@
+## From 2.2 to 2.3
+
+* New `isFilterInsecureCipherSuites` config to disable unsecure and weak ciphers filtering performed internally in Netty.
+
+## From 2.1 to 2.2
+
+* New [Typesafe config](https://github.com/lightbend/config) extra module
+* new `enableWebSocketCompression` config to enable per-message and per-frame WebSocket compression extension
+
+## From 2.0 to 2.1
+
+* AHC 2.1 targets Netty 4.1.
+* `org.asynchttpclient.HttpResponseHeaders` was [dropped](https://github.com/AsyncHttpClient/async-http-client/commit/f4786f3ac7699f8f8664e7c7db0b7097585a0786) in favor of `io.netty.handler.codec.http.HttpHeaders`.
+* `org.asynchttpclient.cookie.Cookie` was [dropped](https://github.com/AsyncHttpClient/async-http-client/commit/a6d659ea0cc11fa5131304d8a04a7ba89c7a66af) in favor of `io.netty.handler.codec.http.cookie.Cookie` as AHC's cookie parsers were contributed to Netty.
+* AHC now has a RFC6265 `CookieStore` that is enabled by default. Implementation can be changed in `AsyncHttpClientConfig`.
+* `AsyncHttpClient` now exposes stats with `getClientStats`.
+* `AsyncHandlerExtensions` was [dropped](https://github.com/AsyncHttpClient/async-http-client/commit/1972c9b9984d6d9f9faca6edd4f2159013205aea) in favor of default methods in `AsyncHandler`.
+* `WebSocket` and `WebSocketListener` methods were renamed to mention frames
+* `AsyncHttpClientConfig` various changes:
+  * new `getCookieStore` now lets you configure a CookieStore (enabled by default)
+  * new `isAggregateWebSocketFrameFragments` now lets you disable WebSocket fragmented frames aggregation
+  * new `isUseLaxCookieEncoder` lets you loosen cookie chars validation
+  * `isAcceptAnyCertificate` was dropped, as it didn't do what its name stated
+  * new `isUseInsecureTrustManager` lets you use a permissive TrustManager, that would typically let you accept self-signed certificates
+  * new `isDisableHttpsEndpointIdentificationAlgorithm` disables setting `HTTPS` algorithm on the SSLEngines, typically disables SNI and HTTPS hostname verification
+  * new `isAggregateWebSocketFrameFragments` lets you disable fragmented WebSocket frames aggregation
diff --git a/MIGRATION.md b/MIGRATION.md
deleted file mode 100644
index 05c976a07..000000000
--- a/MIGRATION.md
+++ /dev/null
@@ -1,51 +0,0 @@
-Migration Guide
----------------
-
-## From 1.8 to 1.9
-
-AsyncHttpClient v1.9 is a preview of v2, so it comes with some breaking changes.
-
-* Target JDK7, drop support for JDK5 and JDK6
-* Rename many AsyncHttpClientConfig parameters:
-  * `maxTotalConnections` becomes `maxConnections`
-  * `maxConnectionPerHost` becomes `maxConnectionsPerHost`
-  * `connectionTimeOutInMs` becomes `connectTimeout`
-  * `webSocketIdleTimeoutInMs` becomes `webSocketTimeout`
-  * `idleConnectionInPoolTimeoutInMs` becomes `pooledConnectionIdleTimeout`
-  * `idleConnectionTimeoutInMs` becomes `readTimeout`
-  * `requestTimeoutInMs` becomes `requestTimeout`
-  * `maxConnectionLifeTimeInMs` becomes `connectionTTL`
-  * `redirectEnabled` becomes `followRedirect`
-  * `allowPoolingConnection` becomes `allowPoolingConnections`
-  * `allowSslConnectionPool` becomes `allowPoolingSslConnections`
-  * `connectionTimeout` becomes `connectTimeout`
-  * `compressionEnabled` becomes `compressionEnforced`. Default false, so AHC only honors user defined Accept-Encoding.
-  * `requestCompressionLevel` was dropped, as it wasn't working
-  * `SSLEngineFactory` was moved to Netty config as only Netty honors it
-  * `useRawUrl` becomes `disableUrlEncodingForBoundedRequests`, as it's only honored by bound requests
-  * `getAllowPoolingConnection` becomes `isAllowPoolingConnection`
-* Drop `PerRequestConfig`. `requestTimeOut` and `proxy` can now be directly set on the request.
-* Drop `java.net.URI` in favor of own `com.ning.http.client.uri.Uri`. You can use `toJavaNetURI` to convert.
-* Drop `Proxy.getURI` in favor of `getUrl`
-* Drop deprecated methods: `Request` and `RequestBuilderBase`'s `getReqType` in favor of `getMethod`, `Request.getLength` in favor of `getContentLength`
-* Drop deprecated `RealmBuilder.getDomain` in favor of `getNtlmDomain`
-* Rename `xxxParameter` (add, set, get...) into `xxxFormParam`
-* Rename `xxxQueryParameter` (add, set, get...) into `xxxQueryParam`
-* Merge `boolean Request.isRedirectEnabled` and `boolean isRedirectOverrideSet` are merged into `Boolean isRedirectEnabled`
-* Remove url parameter from `SignatureCalculator.calculateAndAddSignature`, as it can be fetched on the request parameter
-* Rename `com.ning.http.client.websocket` package into `com.ning.http.client.ws`
-* WebSocket Listeners now have to implement proper interfaces to be notified or fragment events: `WebSocketByteFragmentListener` and `WebSocketTextFragmentListener`
-* Rename WebSocket's `sendTextMessage` into `sendMessage` and `streamText` into `stream`
-* Rename NettyAsyncHttpProviderConfig's `handshakeTimeoutInMillis` into `handshakeTimeout`
-* Netty provider now creates SslEngines instances with proper hoststring and port.
-* Parts, Realm and ProxyServer now take a java.nio.Charset instead of a String charset name
-* New AsyncHandlerExtensions methods:
-  * `onOpenConnection`,
-  * `onConnectionOpen`,
-  * `onPoolConnection`,
-  * `onConnectionPooled`,
-  * `onSendRequest`,
-  * `onDnsResolved`,
-  * `onSslHandshakeCompleted`
-* Rename FluentCaseInsensitiveStringsMap and FluentStringsMap `replace` into `replaceWith` to not conflict with new JDK8 Map methods
-* execute no longer throws Exceptions, all of them are notified to the handler/future
diff --git a/README.md b/README.md
index e2cfa63a6..6685707ca 100644
--- a/README.md
+++ b/README.md
@@ -1,20 +1,15 @@
-Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter) [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client)
----------------------------------------------------
+# Async Http Client [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/)
 
-[Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/)
+Follow [@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on Twitter.
 
-[Getting](https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/) [started](https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/), and use [WebSockets](http://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/)
+The AsyncHttpClient (AHC) library allows Java applications to easily execute HTTP requests and asynchronously process HTTP responses.
+The library also supports the WebSocket Protocol.
 
-The Async Http Client library's purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
-The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
-
-It's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
-
-Latest `version`: [![Maven](https://img.shields.io/maven-central/v/org.asynchttpclient/async-http-client.svg)](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.asynchttpclient%22%20AND%20a%3A%22async-http-client%22)
+It's built on top of [Netty](https://github.com/netty/netty). It's currently compiled on Java 8 but runs on Java 9 too.
 
 ## Installation
 
-First, in order to add it to your Maven project, simply download from Maven central or add this dependency:
+Binaries are deployed on Maven central:
 
 ```xml
 <dependency>
@@ -24,177 +19,221 @@ First, in order to add it to your Maven project, simply download from Maven cent
 </dependency>
 ```
 
-## Usage
+## Version
 
-Then in your code you can simply do
+AHC doesn't use SEMVER, and won't.
 
-```java
-import org.asynchttpclient.*;
-import java.util.concurrent.Future;
+* MAJOR = huge refactoring
+* MINOR = new features and minor API changes, upgrading should require 1 hour of work to adapt sources
+* FIX = no API change, just bug fixes, only those are source and binary compatible with same minor version
 
-AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
-Future<Response> f = asyncHttpClient.prepareGet("http://www.example.com/").execute();
-Response r = f.get();
-```
+Check CHANGES.md for migration path between versions.
+
+## Basics
 
-Note that in this case all the content must be read fully in memory, even if you used `getResponseBodyAsStream()` method on returned `Response` object.
+Feel free to check the [Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/) or the code for more information.
 
-You can also accomplish asynchronous (non-blocking) operation without using a Future if you want to receive and process the response in your handler:
+### Dsl
+
+Import the Dsl helpers to use convenient methods to bootstrap components:
 
 ```java
-import org.asynchttpclient.*;
-import java.util.concurrent.Future;
-
-AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
-asyncHttpClient.prepareGet("http://www.example.com/").execute(new AsyncCompletionHandler<Response>(){
-    
-    @Override
-    public Response onCompleted(Response response) throws Exception{
-        // Do something with the Response
-        // ...
-        return response;
-    }
-    
-    @Override
-    public void onThrowable(Throwable t){
-        // Something wrong happened.
-    }
-});
+import static org.asynchttpclient.Dsl.*;
 ```
 
-(this will also fully read `Response` in memory before calling `onCompleted`)
+### Client
 
-Alternatively you may use continuations (through Java 8 class `CompletableFuture<T>`) to accomplish asynchronous (non-blocking) solution. The equivalent continuation approach to the previous example is:
+```java
+import static org.asynchttpclient.Dsl.*;
+
+AsyncHttpClient asyncHttpClient = asyncHttpClient();
+```
+
+AsyncHttpClient instances must be closed (call the `close` method) once you're done with them, typically when shutting down your application.
+If you don't, you'll experience threads hanging and resource leaks.
+
+AsyncHttpClient instances are intended to be global resources that share the same lifecycle as the application.
+Typically, AHC will usually underperform if you create a new client for each request, as it will create new threads and connection pools for each.
+It's possible to create shared resources (EventLoop and Timer) beforehand and pass them to multiple client instances in the config. You'll then be responsible for closing those shared resources.
+
+## Configuration
+
+Finally, you can also configure the AsyncHttpClient instance via its AsyncHttpClientConfig object:
 
 ```java
 import static org.asynchttpclient.Dsl.*;
 
+AsyncHttpClient c = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", 38080)));
+```
+
+## HTTP
+
+### Sending Requests
+
+### Basics
+
+AHC provides 2 APIs for defining requests: bound and unbound.
+`AsyncHttpClient` and Dls` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
+
+```java
 import org.asynchttpclient.*;
-import java.util.concurrent.CompletableFuture;
 
-AsyncHttpClient asyncHttpClient = asyncHttpClient();
-CompletableFuture<Response> promise = asyncHttpClient
-            .prepareGet("http://www.example.com/")
-            .execute()
-            .toCompletableFuture()
-            .exceptionally(t -> { /* Something wrong happened... */  } )
-            .thenApply(resp -> { /*  Do something with the Response */ return resp; });
-promise.join(); // wait for completion
+// bound
+Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+
+// unbound
+Request request = get("http://www.example.com/").build();
+Future<Response> whenResponse = asyncHttpClient.execute(request);
 ```
 
-You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
+#### Setting Request Body
+
+Use the `setBody` method to add a body to the request.
+
+This body can be of type:
+* `java.io.File`
+* `byte[]`
+* `List<byte[]>`
+* `String`
+* `java.nio.ByteBuffer`
+* `java.io.InputStream`
+* `Publisher<io.netty.bufferByteBuf>`
+* `org.asynchttpclient.request.body.generator.BodyGenerator`
+
+`BodyGenerator` is a generic abstraction that let you create request bodies on the fly.
+Have a look at `FeedableBodyGenerator` if you're looking for a way to pass requests chunks on the fly. 
+
+#### Multipart
+
+Use the `addBodyPart` method to add a multipart part to the request.
+
+This part can be of type:
+* `ByteArrayPart`
+* `FilePart`
+* `InputStreamPart`
+* `StringPart`
+
+### Dealing with Responses
 
-You can also mix Future with AsyncHandler to only retrieve part of the asynchronous response
+#### Blocking on the Future
+
+`execute` methods return a `java.util.concurrent.Future`. You can simply block the calling thread to get the response.
 
 ```java
-import org.asynchttpclient.*;
-import java.util.concurrent.Future;
-
-AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
-Future<Integer> f = asyncHttpClient.prepareGet("http://www.example.com/").execute(
-   new AsyncCompletionHandler<Integer>(){
-    
-    @Override
-    public Integer onCompleted(Response response) throws Exception{
-        // Do something with the Response
-        return response.getStatusCode();
-    }
-    
-    @Override
-    public void onThrowable(Throwable t){
-        // Something wrong happened.
-    }
-});
+Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+Response response = whenResponse.get();
+```
+
+This is useful for debugging but you'll most likely hurt performance or create bugs when running such code on production.
+The point of using a non blocking client is to *NOT BLOCK* the calling thread!
+
+### Setting callbacks on the ListenableFuture
 
-int statusCode = f.get();
+`execute` methods actually return a `org.asynchttpclient.ListenableFuture` similar to Guava's.
+You can configure listeners to be notified of the Future's completion. 
+
+```java
+ListenableFuture<Response> whenResponse = ???;
+Runnable callback = () -> {
+	try  {
+		Response response = whenResponse.get();
+		System.out.println(response);
+	} catch (InterruptedException | ExecutionException e) {
+		e.printStackTrace();
+	}
+};
+java.util.concurrent.Executor executor = ???;
+whenResponse.addListener(() -> ???, executor);
 ```
 
-which is something you want to do for large responses: this way you can process content as soon as it becomes available, piece by piece, without having to buffer it all in memory.
+If the `executor` parameter is null, callback will be executed in the IO thread.
+You *MUST NEVER PERFORM BLOCKING* operations in there, typically sending another request and block on a future.
+
+#### Using custom AsyncHandlers
+
+`execute` methods can take an `org.asynchttpclient.AsyncHandler` to be notified on the different events, such as receiving the status, the headers and body chunks.
+When you don't specify one, AHC will use a `org.asynchttpclient.AsyncCompletionHandler`;
+
+`AsyncHandler` methods can let you abort processing early (return `AsyncHandler.State.ABORT`) and can let you return a computation result from `onCompleted` that will be used as the Future's result.
+See `AsyncCompletionHandler` implementation as an example.
 
- You have full control on the Response life cycle, so you can decide at any moment to stop processing what the server is sending back:
+The below sample just capture the response status and skips processing the response body chunks.
+
+Note that returning `ABORT` closes the underlying connection.
 
 ```java
 import static org.asynchttpclient.Dsl.*;
-
 import org.asynchttpclient.*;
-import java.util.concurrent.Future;
-
-AsyncHttpClient c = asyncHttpClient();
-Future<String> f = c.prepareGet("http://www.example.com/").execute(new AsyncHandler<String>() {
-    private ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-
-    @Override
-    public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
-        int statusCode = status.getStatusCode();
-        // The Status have been read
-        // If you don't want to read the headers,body or stop processing the response
-        if (statusCode >= 500) {
-            return STATE.ABORT;
-        }
-    }
-
-    @Override
-    public STATE onHeadersReceived(HttpResponseHeaders h) throws Exception {
-        Headers headers = h.getHeaders();
-         // The headers have been read
-         // If you don't want to read the body, or stop processing the response
-         return STATE.ABORT;
-    }
-
-    @Override
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-         bytes.write(bodyPart.getBodyPartBytes());
-         return STATE.CONTINUE;
-    }
-
-    @Override
-    public String onCompleted() throws Exception {
-         // Will be invoked once the response has been fully read or a ResponseComplete exception
-         // has been thrown.
-         // NOTE: should probably use Content-Encoding from headers
-         return bytes.toString("UTF-8");
-    }
-
-    @Override
-    public void onThrowable(Throwable t) {
-    }
+import io.netty.handler.codec.http.HttpHeaders;
+
+Future<Integer> whenStatusCode = asyncHttpClient.prepareGet("http://www.example.com/")
+.execute(new AsyncHandler<Integer>() {
+	private Integer status;
+	@Override
+	public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+		status = responseStatus.getStatusCode();
+		return State.ABORT;
+	}
+	@Override
+	public State onHeadersReceived(HttpHeaders headers) throws Exception {
+		return State.ABORT;
+	}
+	@Override
+	public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+		return State.ABORT;
+	}
+	@Override
+	public Integer onCompleted() throws Exception {
+		return status;
+	}
+	@Override
+	public void onThrowable(Throwable t) {
+	}
 });
 
-String bodyResponse = f.get();
+Integer statusCode = whenStatusCode.get();
 ```
 
-## Configuration
+#### Using Continuations
 
-Finally, you can also configure the AsyncHttpClient via its AsyncHttpClientConfig object:
+`ListenableFuture` has a `toCompletableFuture` method that returns a `CompletableFuture`.
+Beware that canceling this `CompletableFuture` won't properly cancel the ongoing request.
+There's a very good chance we'll return a `CompletionStage` instead in the next release.
 
 ```java
-AsyncHttpClientConfig cf = new DefaultAsyncHttpClientConfig.Builder()
-    .setProxyServer(new ProxyServer.Builder("127.0.0.1", 38080)).build();
-
-AsyncHttpClient c = new DefaultAsyncHttpClient(cf);
+CompletableFuture<Response> whenResponse = asyncHttpClient
+            .prepareGet("http://www.example.com/")
+            .execute()
+            .toCompletableFuture()
+            .exceptionally(t -> { /* Something wrong happened... */  } )
+            .thenApply(response -> { /*  Do something with the Response */ return resp; });
+whenResponse.join(); // wait for completion
 ```
 
+You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
+
 ## WebSocket
 
-Async Http Client also supports WebSocket by simply doing:
+Async Http Client also supports WebSocket.
+You need to pass a `WebSocketUpgradeHandler` where you would register a `WebSocketListener`.
 
 ```java
-WebSocket websocket = c.prepareGet(getTargetUrl())
+WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
       .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(
-          new WebSocketTextListener() {
-
-          @Override
-          public void onMessage(String message) {
-          }
+          new WebSocketListener() {
 
           @Override
           public void onOpen(WebSocket websocket) {
-              websocket.sendTextMessage("...").sendMessage("...");
+              websocket.sendTextFrame("...").sendTextFrame("...");
           }
 
           @Override
           public void onClose(WebSocket websocket) {
-              latch.countDown();
+          }
+          
+    		  @Override
+          public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          	System.out.println(payload);
           }
 
           @Override
@@ -203,6 +242,43 @@ WebSocket websocket = c.prepareGet(getTargetUrl())
       }).build()).get();
 ```
 
+## Reactive Streams
+
+AsyncHttpClient has built-in support for reactive streams.
+
+You can pass a request body as a `Publisher<ByteBuf>` or a `ReactiveStreamsBodyGenerator`.
+
+You can also pass a `StreamedAsyncHandler<T>` whose `onStream` method will be notified with a `Publisher<HttpResponseBodyPart>`.
+
+See tests in package `org.asynchttpclient.reactivestreams` for examples.
+
+## WebDAV
+
+AsyncHttpClient has build in support for the WebDAV protocol.
+The API can be used the same way normal HTTP request are made:
+
+```java
+Request mkcolRequest = new RequestBuilder("MKCOL").setUrl("http://host:port/folder1").build();
+Response response = c.executeRequest(mkcolRequest).get();
+```
+or
+
+```java
+Request propFindRequest = new RequestBuilder("PROPFIND").setUrl("http://host:port").build();
+Response response = c.executeRequest(propFindRequest, new AsyncHandler() {
+  // ...
+}).get();
+```
+
+## More
+
+You can find more information on Jean-François Arcand's blog.  Jean-François is the original author of this library.
+Code is sometimes not up-to-date but gives a pretty good idea of advanced features.
+
+* https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/
+* https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/
+* https://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/
+
 ## User Group
 
 Keep up to date on the library development by joining the Asynchronous HTTP Client discussion group
@@ -213,12 +289,10 @@ Keep up to date on the library development by joining the Asynchronous HTTP Clie
 
 Of course, Pull Requests are welcome.
 
-Here a the few rules we'd like you to respect if you do so:
+Here are the few rules we'd like you to respect if you do so:
 
 * Only edit the code related to the suggested change, so DON'T automatically format the classes you've edited.
-* Respect the formatting rules:
-  * Indent with 4 spaces
-* Your PR can contain multiple commits when submitting, but once it's been reviewed, we'll ask you to squash them into a single one
+* Use IntelliJ default formatting rules.
 * Regarding licensing:
   * You must be the original author of the code you suggest.
   * You must give the copyright to "the AsyncHttpClient Project"
diff --git a/client/pom.xml b/client/pom.xml
index ee1eb829f..771f5df15 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -1,64 +1,82 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<parent>
-		<groupId>org.asynchttpclient</groupId>
-		<artifactId>async-http-client-project</artifactId>
-		<version>2.1.0-SNAPSHOT</version>
-	</parent>
-	<modelVersion>4.0.0</modelVersion>
-	<artifactId>async-http-client</artifactId>
-	<name>Asynchronous Http Client</name>
-	<description>The Async Http Client (AHC) classes.</description>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-project</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client</artifactId>
+  <name>Asynchronous Http Client</name>
+  <description>The Async Http Client (AHC) classes.</description>
 
-	<build>
-		<plugins>
-			<plugin>
-				<artifactId>maven-jar-plugin</artifactId>
-				<executions>
-					<execution>
-						<goals>
-							<goal>test-jar</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-	</build>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>test-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 
-	<dependencies>
-		<dependency>
-			<groupId>org.asynchttpclient</groupId>
-			<artifactId>async-http-client-netty-utils</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>io.netty</groupId>
-			<artifactId>netty-codec-http</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>io.netty</groupId>
-			<artifactId>netty-handler</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>io.netty</groupId>
-			<artifactId>netty-transport-native-epoll</artifactId>
-			<classifier>linux-x86_64</classifier>
-		</dependency>
-		<dependency>
-			<groupId>io.netty</groupId>
-			<artifactId>netty-resolver-dns</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>org.reactivestreams</groupId>
-			<artifactId>reactive-streams</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>com.typesafe.netty</groupId>
-			<artifactId>netty-reactive-streams</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>io.reactivex.rxjava2</groupId>
-			<artifactId>rxjava</artifactId>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
+  <dependencies>
+    <dependency>
+      <groupId>org.asynchttpclient</groupId>
+      <artifactId>async-http-client-netty-utils</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-http</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-socks</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler-proxy</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport-native-epoll</artifactId>
+      <classifier>linux-x86_64</classifier>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-resolver-dns</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.reactivestreams</groupId>
+      <artifactId>reactive-streams</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.typesafe.netty</groupId>
+      <artifactId>netty-reactive-streams</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex.rxjava2</groupId>
+      <artifactId>rxjava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.reactivestreams</groupId>
+      <artifactId>reactive-streams-examples</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.kerby</groupId>
+      <artifactId>kerb-simplekdc</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index 5cb8530f8..d1f30c1ac 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -17,96 +17,105 @@
 package org.asynchttpclient;
 
 import io.netty.handler.codec.http.HttpHeaders;
-
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)} convenience method which gets called when the {@link Response} processing is finished. This class also
- * implement the {@link ProgressAsyncHandler} callback, all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
+ * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)}
+ * convenience method which gets called when the {@link Response} processing is
+ * finished. This class also implements the {@link ProgressAsyncHandler}
+ * callback, all doing nothing except returning
+ * {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
  *
- * @param <T> Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+ * @param <T> Type of the value that will be returned by the associated
+ *            {@link java.util.concurrent.Future}
  */
-public abstract class AsyncCompletionHandler<T> implements AsyncHandler<T>, ProgressAsyncHandler<T> {
+public abstract class AsyncCompletionHandler<T> implements ProgressAsyncHandler<T> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
-    private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
+  private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
+  private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-        builder.accumulate(content);
-        return State.CONTINUE;
-    }
+  @Override
+  public State onStatusReceived(HttpResponseStatus status) throws Exception {
+    builder.reset();
+    builder.accumulate(status);
+    return State.CONTINUE;
+  }
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus status) throws Exception {
-        builder.reset();
-        builder.accumulate(status);
-        return State.CONTINUE;
-    }
+  @Override
+  public State onHeadersReceived(HttpHeaders headers) throws Exception {
+    builder.accumulate(headers);
+    return State.CONTINUE;
+  }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-        builder.accumulate(headers);
-        return State.CONTINUE;
-    }
+  @Override
+  public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+    builder.accumulate(content);
+    return State.CONTINUE;
+  }
 
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        builder.accumulate(headers);
-        return State.CONTINUE;
-    }
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+    builder.accumulate(headers);
+    return State.CONTINUE;
+  }
 
-    @Override
-    public final T onCompleted() throws Exception {
-        return onCompleted(builder.build());
-    }
+  @Override
+  public final T onCompleted() throws Exception {
+    return onCompleted(builder.build());
+  }
 
-    @Override
-    public void onThrowable(Throwable t) {
-        LOGGER.debug(t.getMessage(), t);
-    }
+  @Override
+  public void onThrowable(Throwable t) {
+    LOGGER.debug(t.getMessage(), t);
+  }
 
-    /**
-     * Invoked once the HTTP response processing is finished.
-     *
-     * @param response The {@link Response}
-     * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
-     * @throws Exception if something wrong happens
-     */
-    abstract public T onCompleted(Response response) throws Exception;
+  /**
+   * Invoked once the HTTP response processing is finished.
+   *
+   * @param response The {@link Response}
+   * @return T Value that will be returned by the associated
+   * {@link java.util.concurrent.Future}
+   * @throws Exception if something wrong happens
+   */
+  abstract public T onCompleted(Response response) throws Exception;
 
-    /**
-     * Invoked when the HTTP headers have been fully written on the I/O socket.
-     *
-     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    @Override
-    public State onHeadersWritten() {
-        return State.CONTINUE;
-    }
+  /**
+   * Invoked when the HTTP headers have been fully written on the I/O socket.
+   *
+   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
+   * or ABORT the current processing.
+   */
+  @Override
+  public State onHeadersWritten() {
+    return State.CONTINUE;
+  }
 
-    /**
-     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.InputStream} has been fully written on the I/O socket.
-     *
-     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    @Override
-    public State onContentWritten() {
-        return State.CONTINUE;
-    }
+  /**
+   * Invoked when the content (a {@link java.io.File}, {@link String} or
+   * {@link java.io.InputStream} has been fully written on the I/O socket.
+   *
+   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
+   * or ABORT the current processing.
+   */
+  @Override
+  public State onContentWritten() {
+    return State.CONTINUE;
+  }
 
-    /**
-     * Invoked when the I/O operation associated with the {@link Request} body as been progressed.
-     *
-     * @param amount The amount of bytes to transfer
-     * @param current The amount of bytes transferred
-     * @param total The total number of bytes transferred
-     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    @Override
-    public State onContentWriteProgress(long amount, long current, long total) {
-        return State.CONTINUE;
-    }
+  /**
+   * Invoked when the I/O operation associated with the {@link Request} body as
+   * been progressed.
+   *
+   * @param amount  The amount of bytes to transfer
+   * @param current The amount of bytes transferred
+   * @param total   The total number of bytes transferred
+   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
+   * or ABORT the current processing.
+   */
+  @Override
+  public State onContentWriteProgress(long amount, long current, long total) {
+    return State.CONTINUE;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index 15301c2bb..c631e412e 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -21,11 +21,11 @@
  * Simple {@link AsyncHandler} of type {@link Response}
  */
 public class AsyncCompletionHandlerBase extends AsyncCompletionHandler<Response> {
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-        return response;
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public Response onCompleted(Response response) throws Exception {
+    return response;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHandler.java b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
index 0bade6f47..6733c9471 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -15,7 +15,13 @@
  */
 package org.asynchttpclient;
 
+import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+import javax.net.ssl.SSLSession;
+import java.net.InetSocketAddress;
+import java.util.List;
 
 
 /**
@@ -24,17 +30,17 @@
  * <br>
  * Callback methods get invoked in the following order:
  * <ol>
- *  <li>{@link #onStatusReceived(HttpResponseStatus)},</li>
- *  <li>{@link #onHeadersReceived(HttpHeaders)},</li>
- *  <li>{@link #onBodyPartReceived(HttpResponseBodyPart)}, which could be invoked multiple times,</li>
- *  <li>{@link #onTrailingHeadersReceived(HttpHeaders)}, which is only invoked if trailing HTTP headers are received</li>
- *  <li>{@link #onCompleted()}, once the response has been fully read.</li>
+ * <li>{@link #onStatusReceived(HttpResponseStatus)},</li>
+ * <li>{@link #onHeadersReceived(HttpHeaders)},</li>
+ * <li>{@link #onBodyPartReceived(HttpResponseBodyPart)}, which could be invoked multiple times,</li>
+ * <li>{@link #onTrailingHeadersReceived(HttpHeaders)}, which is only invoked if trailing HTTP headers are received</li>
+ * <li>{@link #onCompleted()}, once the response has been fully read.</li>
  * </ol>
  * <br>
  * Returning a {@link AsyncHandler.State#ABORT} from any of those callback methods will interrupt asynchronous response
- * processing, after that only {@link #onCompleted()} is going to be called.
+ * processing. After that, only {@link #onCompleted()} is going to be called.
  * <br>
- * AsyncHandler aren't thread safe, hence you should avoid re-using the same instance when doing concurrent requests.
+ * AsyncHandlers aren't thread safe. Hence, you should avoid re-using the same instance when doing concurrent requests.
  * As an example, the following may produce unexpected results:
  * <blockquote><pre>
  *   AsyncHandler ah = new AsyncHandler() {....};
@@ -43,80 +49,205 @@
  *   client.prepareGet("http://...").execute(ah);
  * </pre></blockquote>
  * It is recommended to create a new instance instead.
- * 
- * Do NOT perform any blocking operation in there, typically trying to send another request and call get() on its future.
+ * <p>
+ * Do NOT perform any blocking operations in any of these methods. A typical example would be trying to send another
+ * request and calling get() on its future.
  * There's a chance you might end up in a dead lock.
- * If you really to perform blocking operation, executed it in a different dedicated thread pool.
+ * If you really need to perform a blocking operation, execute it in a different dedicated thread pool.
  *
  * @param <T> Type of object returned by the {@link java.util.concurrent.Future#get}
  */
 public interface AsyncHandler<T> {
 
-    enum State {
+  /**
+   * Invoked as soon as the HTTP status line has been received
+   *
+   * @param responseStatus the status code and test of the response
+   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+   * @throws Exception if something wrong happens
+   */
+  State onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
 
-        /**
-         * Stop the processing.
-         */
-        ABORT,
-        /**
-         * Continue the processing
-         */
-        CONTINUE
-    }
+  /**
+   * Invoked as soon as the HTTP headers have been received.
+   *
+   * @param headers the HTTP headers.
+   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+   * @throws Exception if something wrong happens
+   */
+  State onHeadersReceived(HttpHeaders headers) throws Exception;
 
-    /**
-     * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
-     * produced by implementation of onXXXReceived method invocation.
-     *
-     * @param t a {@link Throwable}
-     */
-    void onThrowable(Throwable t);
+  /**
+   * Invoked as soon as some response body part are received. Could be invoked many times.
+   * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
+   *
+   * @param bodyPart response's body part.
+   * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
+   * @throws Exception if something wrong happens
+   */
+  State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
 
-    /**
-     * Invoked as soon as some response body part are received. Could be invoked many times.
-     * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
-     *
-     * @param bodyPart response's body part.
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
-     * @throws Exception if something wrong happens
-     */
-    State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
+  /**
+   * Invoked when trailing headers have been received.
+   *
+   * @param headers the trailing HTTP headers.
+   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+   * @throws Exception if something wrong happens
+   */
+  default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+    return State.CONTINUE;
+  }
 
-    /**
-     * Invoked as soon as the HTTP status line has been received
-     *
-     * @param responseStatus the status code and test of the response
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-     * @throws Exception if something wrong happens
-     */
-    State onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
+  /**
+   * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
+   * produced by implementation of onXXXReceived method invocation.
+   *
+   * @param t a {@link Throwable}
+   */
+  void onThrowable(Throwable t);
+
+  /**
+   * Invoked once the HTTP response processing is finished.
+   * <br>
+   * Gets always invoked as last callback method.
+   *
+   * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
+   * @throws Exception if something wrong happens
+   */
+  T onCompleted() throws Exception;
+
+  /**
+   * Notify the callback before hostname resolution
+   *
+   * @param name the name to be resolved
+   */
+  default void onHostnameResolutionAttempt(String name) {
+  }
+
+  // ////////// DNS /////////////////
+
+  /**
+   * Notify the callback after hostname resolution was successful.
+   *
+   * @param name      the name to be resolved
+   * @param addresses the resolved addresses
+   */
+  default void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+  }
+
+  /**
+   * Notify the callback after hostname resolution failed.
+   *
+   * @param name  the name to be resolved
+   * @param cause the failure cause
+   */
+  default void onHostnameResolutionFailure(String name, Throwable cause) {
+  }
+
+  // ////////////// TCP CONNECT ////////
+
+  /**
+   * Notify the callback when trying to open a new connection.
+   * <p>
+   * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
+   *
+   * @param remoteAddress the address we try to connect to
+   */
+  default void onTcpConnectAttempt(InetSocketAddress remoteAddress) {
+  }
+
+  /**
+   * Notify the callback after a successful connect
+   *
+   * @param remoteAddress the address we try to connect to
+   * @param connection    the connection
+   */
+  default void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+  }
+
+  /**
+   * Notify the callback after a failed connect.
+   * <p>
+   * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
+   *
+   * @param remoteAddress the address we try to connect to
+   * @param cause         the cause of the failure
+   */
+  default void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+  }
+
+  // ////////////// TLS ///////////////
+
+  /**
+   * Notify the callback before TLS handshake
+   */
+  default void onTlsHandshakeAttempt() {
+  }
+
+  /**
+   * Notify the callback after the TLS was successful
+   */
+  default void onTlsHandshakeSuccess(SSLSession sslSession) {
+  }
+
+  /**
+   * Notify the callback after the TLS failed
+   *
+   * @param cause the cause of the failure
+   */
+  default void onTlsHandshakeFailure(Throwable cause) {
+  }
+
+  // /////////// POOLING /////////////
+
+  /**
+   * Notify the callback when trying to fetch a connection from the pool.
+   */
+  default void onConnectionPoolAttempt() {
+  }
+
+  /**
+   * Notify the callback when a new connection was successfully fetched from the pool.
+   *
+   * @param connection the connection
+   */
+  default void onConnectionPooled(Channel connection) {
+  }
+
+  /**
+   * Notify the callback when trying to offer a connection to the pool.
+   *
+   * @param connection the connection
+   */
+  default void onConnectionOffer(Channel connection) {
+  }
+
+  // //////////// SENDING //////////////
+
+  /**
+   * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
+   * retry, it will be notified multiple times.
+   *
+   * @param request the real request object as passed to the provider
+   */
+  default void onRequestSend(NettyRequest request) {
+  }
+
+  /**
+   * Notify the callback every time a request is being retried.
+   */
+  default void onRetry() {
+  }
+
+  enum State {
 
     /**
-     * Invoked as soon as the HTTP headers have been received.
-     *
-     * @param headers the HTTP headers.
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-     * @throws Exception if something wrong happens
-     */
-    State onHeadersReceived(HttpHeaders headers) throws Exception;
-    
-    /**
-     * Invoked when trailing headers have been received. 
-     * @param headers the trailing HTTP headers.
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-     * @throws Exception if something wrong happens
+     * Stop the processing.
      */
-    default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        return State.CONTINUE;
-    }
-
+    ABORT,
     /**
-     * Invoked once the HTTP response processing is finished.
-     * <br>
-     * Gets always invoked as last callback method.
-     *
-     * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
-     * @throws Exception if something wrong happens
+     * Continue the processing
      */
-    T onCompleted() throws Exception;
+    CONTINUE
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index 7d1c0c650..2ab335f3f 100755
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -21,94 +21,94 @@
 import java.util.function.Predicate;
 
 /**
- * This class support asynchronous and synchronous HTTP request.
+ * This class support asynchronous and synchronous HTTP requests.
  * <br>
- * To execute synchronous HTTP request, you just need to do
+ * To execute a synchronous HTTP request, you just need to do
  * <blockquote><pre>
  *    AsyncHttpClient c = new AsyncHttpClient();
  *    Future&lt;Response&gt; f = c.prepareGet(TARGET_URL).execute();
  * </pre></blockquote>
  * <br>
- * The code above will block until the response is fully received. To execute asynchronous HTTP request, you
+ * The code above will block until the response is fully received. To execute an asynchronous HTTP request, you
  * create an {@link AsyncHandler} or its abstract implementation, {@link AsyncCompletionHandler}
  * <br>
  * <blockquote><pre>
  *       AsyncHttpClient c = new AsyncHttpClient();
  *       Future&lt;Response&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncCompletionHandler&lt;Response&gt;() &#123;
- * 
+ *
  *          &#64;Override
  *          public Response onCompleted(Response response) throws IOException &#123;
  *               // Do something
  *              return response;
  *          &#125;
- * 
+ *
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
  *      &#125;);
  *      Response response = f.get();
- * 
- *      // We are just interested to retrieve the status code.
+ *
+ *      // We are just interested in retrieving the status code.
  *     Future&lt;Integer&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncCompletionHandler&lt;Integer&gt;() &#123;
- * 
+ *
  *          &#64;Override
  *          public Integer onCompleted(Response response) throws IOException &#123;
  *               // Do something
  *              return response.getStatusCode();
  *          &#125;
- * 
+ *
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
  *      &#125;);
  *      Integer statusCode = f.get();
  * </pre></blockquote>
- * The {@link AsyncCompletionHandler#onCompleted(Response)} will be invoked once the http response has been fully read, which include
- * the http headers and the response body. Note that the entire response will be buffered in memory.
+ * The {@link AsyncCompletionHandler#onCompleted(Response)} method will be invoked once the http response has been fully read.
+ * The {@link Response} object includes the http headers and the response body. Note that the entire response will be buffered in memory.
  * <br>
- * You can also have more control about the how the response is asynchronously processed by using a {@link AsyncHandler}
+ * You can also have more control about the how the response is asynchronously processed by using an {@link AsyncHandler}
  * <blockquote><pre>
  *      AsyncHttpClient c = new AsyncHttpClient();
  *      Future&lt;String&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncHandler&lt;String&gt;() &#123;
  *          private StringBuilder builder = new StringBuilder();
- * 
+ *
  *          &#64;Override
  *          public STATE onStatusReceived(HttpResponseStatus s) throws Exception &#123;
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
  *          }
- * 
+ *
  *          &#64;Override
  *          public STATE onHeadersReceived(HttpResponseHeaders bodyPart) throws Exception &#123;
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
- * 
+ *
  *          }
  *          &#64;Override
- * 
+ *
  *          public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception &#123;
  *               builder.append(new String(bodyPart));
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
  *          &#125;
- * 
+ *
  *          &#64;Override
  *          public String onCompleted() throws Exception &#123;
  *               // Will be invoked once the response has been fully read or a ResponseComplete exception
  *               // has been thrown.
  *               return builder.toString();
  *          &#125;
- * 
+ *
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
  *      &#125;);
- * 
+ *
  *      String bodyResponse = f.get();
  * </pre></blockquote>
- * You can asynchronously process the response status,headers and body and decide when to
- * stop the processing the response by returning a new {@link AsyncHandler.State#ABORT} at any moment.
- * 
+ * You can asynchronously process the response status, headers and body and decide when to
+ * stop processing the response by returning a new {@link AsyncHandler.State#ABORT} at any moment.
+ *
  * This class can also be used without the need of {@link AsyncHandler}.
  * <br>
  * <blockquote><pre>
@@ -116,7 +116,7 @@
  *      Future&lt;Response&gt; f = c.prepareGet(TARGET_URL).execute();
  *      Response r = f.get();
  * </pre></blockquote>
- * 
+ *
  * Finally, you can configure the AsyncHttpClient using an {@link DefaultAsyncHttpClientConfig} instance.
  * <br>
  * <blockquote><pre>
@@ -125,166 +125,178 @@
  *      Response r = f.get();
  * </pre></blockquote>
  * <br>
- * An instance of this class will cache every HTTP 1.1 connections and close them when the {@link DefaultAsyncHttpClientConfig#getReadTimeout()}
- * expires. This object can hold many persistent connections to different host.
+ * An instance of this class will cache every HTTP 1.1 connection and close them when the {@link DefaultAsyncHttpClientConfig#getReadTimeout()}
+ * expires. This object can hold many persistent connections to different hosts.
  */
 public interface AsyncHttpClient extends Closeable {
 
-    /**
-     * Return true if closed
-     *
-     * @return true if closed
-     */
-    boolean isClosed();
+  /**
+   * Return true if closed
+   *
+   * @return true if closed
+   */
+  boolean isClosed();
+
+  /**
+   * Set default signature calculator to use for requests built by this client instance
+   *
+   * @param signatureCalculator a signature calculator
+   * @return {@link RequestBuilder}
+   */
+  AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator);
+
+  /**
+   * Prepare an HTTP client request.
+   *
+   * @param method HTTP request method type. MUST BE in upper case
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepare(String method, String url);
+
+
+  /**
+   * Prepare an HTTP client GET request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareGet(String url);
+
+  /**
+   * Prepare an HTTP client CONNECT request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareConnect(String url);
 
-    /**
-     * Set default signature calculator to use for requests build by this client instance
-     * @param signatureCalculator a signature calculator
-     * @return {@link RequestBuilder}
-     */
-    AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator);
+  /**
+   * Prepare an HTTP client OPTIONS request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareOptions(String url);
 
-    /**
-     * Prepare an HTTP client GET request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareGet(String url);
+  /**
+   * Prepare an HTTP client HEAD request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareHead(String url);
 
-    /**
-     * Prepare an HTTP client CONNECT request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareConnect(String url);
+  /**
+   * Prepare an HTTP client POST request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder preparePost(String url);
 
-    /**
-     * Prepare an HTTP client OPTIONS request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareOptions(String url);
+  /**
+   * Prepare an HTTP client PUT request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder preparePut(String url);
 
-    /**
-     * Prepare an HTTP client HEAD request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareHead(String url);
+  /**
+   * Prepare an HTTP client DELETE request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareDelete(String url);
 
-    /**
-     * Prepare an HTTP client POST request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder preparePost(String url);
+  /**
+   * Prepare an HTTP client PATCH request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder preparePatch(String url);
 
-    /**
-     * Prepare an HTTP client PUT request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder preparePut(String url);
+  /**
+   * Prepare an HTTP client TRACE request.
+   *
+   * @param url A well formed URL.
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareTrace(String url);
 
-    /**
-     * Prepare an HTTP client DELETE request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareDelete(String url);
+  /**
+   * Construct a {@link RequestBuilder} using a {@link Request}
+   *
+   * @param request a {@link Request}
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareRequest(Request request);
 
-    /**
-     * Prepare an HTTP client PATCH request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder preparePatch(String url);
+  /**
+   * Construct a {@link RequestBuilder} using a {@link RequestBuilder}
+   *
+   * @param requestBuilder a {@link RequestBuilder}
+   * @return {@link RequestBuilder}
+   */
+  BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder);
 
-    /**
-     * Prepare an HTTP client TRACE request.
-     *
-     * @param url A well formed URL.
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareTrace(String url);
+  /**
+   * Execute an HTTP request.
+   *
+   * @param request {@link Request}
+   * @param handler an instance of {@link AsyncHandler}
+   * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+   * @return a {@link Future} of type T
+   */
+  <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
 
-    /**
-     * Construct a {@link RequestBuilder} using a {@link Request}
-     *
-     * @param request a {@link Request}
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareRequest(Request request);
-    
-    /**
-     * Construct a {@link RequestBuilder} using a {@link RequestBuilder}
-     *
-     * @param requestBuilder a {@link RequestBuilder}
-     * @return {@link RequestBuilder}
-     */
-    BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder);
+  /**
+   * Execute an HTTP request.
+   *
+   * @param requestBuilder {@link RequestBuilder}
+   * @param handler        an instance of {@link AsyncHandler}
+   * @param <T>            Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+   * @return a {@link Future} of type T
+   */
+  <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler);
 
-    /**
-     * Execute an HTTP request.
-     *
-     * @param request {@link Request}
-     * @param handler an instance of {@link AsyncHandler}
-     * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-     * @return a {@link Future} of type T
-     */
-    <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
-    
-    /**
-     * Execute an HTTP request.
-     *
-     * @param requestBuilder {@link RequestBuilder}
-     * @param handler an instance of {@link AsyncHandler}
-     * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-     * @return a {@link Future} of type T
-     */
-    <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler);
+  /**
+   * Execute an HTTP request.
+   *
+   * @param request {@link Request}
+   * @return a {@link Future} of type Response
+   */
+  ListenableFuture<Response> executeRequest(Request request);
 
-    /**
-     * Execute an HTTP request.
-     *
-     * @param request {@link Request}
-     * @return a {@link Future} of type Response
-     */
-    ListenableFuture<Response> executeRequest(Request request);
-    
-    /**
-     * Execute an HTTP request.
-     *
-     * @param requestBuilder {@link RequestBuilder}
-     * @return a {@link Future} of type Response
-     */
-    ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder);
+  /**
+   * Execute an HTTP request.
+   *
+   * @param requestBuilder {@link RequestBuilder}
+   * @return a {@link Future} of type Response
+   */
+  ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder);
 
-    /***
-     * Return details about pooled connections.
-     *
-     * @return a {@link ClientStats}
-     */
-    ClientStats getClientStats();
+  /***
+   * Return details about pooled connections.
+   *
+   * @return a {@link ClientStats}
+   */
+  ClientStats getClientStats();
 
-    /**
-     * Flush ChannelPool partitions based on a predicate
-     * 
-     * @param predicate the predicate
-     */
-    void flushChannelPoolPartitions(Predicate<Object> predicate);
+  /**
+   * Flush ChannelPool partitions based on a predicate
+   *
+   * @param predicate the predicate
+   */
+  void flushChannelPoolPartitions(Predicate<Object> predicate);
 
-    /**
-     * Return the config associated to this client.
-     * @return the config associated to this client.
-     */
-    AsyncHttpClientConfig getConfig();
+  /**
+   * Return the config associated to this client.
+   *
+   * @return the config associated to this client.
+   */
+  AsyncHttpClientConfig getConfig();
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index d1395bc00..862aa2ce9 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -20,310 +20,330 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.Timer;
-
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ThreadFactory;
-
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.KeepAliveStrategy;
+import org.asynchttpclient.cookie.CookieStore;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
 import org.asynchttpclient.netty.EagerResponseBodyPart;
 import org.asynchttpclient.netty.LazyResponseBodyPart;
+import org.asynchttpclient.netty.channel.ConnectionSemaphoreFactory;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 
-public interface AsyncHttpClientConfig {
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
 
-    /**
-     * @return the version of AHC
-     */
-    String getAhcVersion();
-
-    /**
-     * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
-     *
-     * @return the name.
-     */
-    String getThreadPoolName();
-
-    /**
-     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
-     *
-     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
-     */
-    int getMaxConnections();
-
-    /**
-     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
-     *
-     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
-     */
-    int getMaxConnectionsPerHost();
-
-    /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
-     *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
-     */
-    int getConnectTimeout();
-
-    /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
-     *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
-     */
-    int getReadTimeout();
-
-    /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
-     *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
-     */
-    int getPooledConnectionIdleTimeout();
-
-    /**
-     * @return the period in millis to clean the pool of dead and idle connections.
-     */
-    int getConnectionPoolCleanerPeriod();
-
-    /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
-     *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
-     */
-    int getRequestTimeout();
-
-    /**
-     * Is HTTP redirect enabled
-     *
-     * @return true if enabled.
-     */
-    boolean isFollowRedirect();
-
-    /**
-     * Get the maximum number of HTTP redirect
-     *
-     * @return the maximum number of HTTP redirect
-     */
-    int getMaxRedirects();
-
-    /**
-     * Is the {@link ChannelPool} support enabled.
-     *
-     * @return true if keep-alive is enabled
-     */
-    boolean isKeepAlive();
-
-    /**
-     * Return the USER_AGENT header value
-     *
-     * @return the USER_AGENT header value
-     */
-    String getUserAgent();
-
-    /**
-     * Is HTTP compression enforced.
-     *
-     * @return true if compression is enforced
-     */
-    boolean isCompressionEnforced();
-
-    /**
-     * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
-     *
-     * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
-     *         provided, this method will return <code>null</code>
-     */
-    ThreadFactory getThreadFactory();
-
-    /**
-     * An instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
-     *
-     * @return instance of {@link ProxyServer}
-     */
-    ProxyServerSelector getProxyServerSelector();
-
-    /**
-     * Return an instance of {@link SslContext} used for SSL connection.
-     *
-     * @return an instance of {@link SslContext} used for SSL connection.
-     */
-    SslContext getSslContext();
-
-    /**
-     * Return the current {@link Realm}
-     *
-     * @return the current {@link Realm}
-     */
-    Realm getRealm();
-
-    /**
-     * Return the list of {@link RequestFilter}
-     *
-     * @return Unmodifiable list of {@link ResponseFilter}
-     */
-    List<RequestFilter> getRequestFilters();
-
-    /**
-     * Return the list of {@link ResponseFilter}
-     *
-     * @return Unmodifiable list of {@link ResponseFilter}
-     */
-    List<ResponseFilter> getResponseFilters();
-
-    /**
-     * Return the list of {@link java.io.IOException}
-     *
-     * @return Unmodifiable list of {@link java.io.IOException}
-     */
-    List<IOExceptionFilter> getIoExceptionFilters();
-
-    /**
-     * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
-     *
-     * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
-     */
-    int getMaxRequestRetry();
+public interface AsyncHttpClientConfig {
 
-    /**
-     * @return the disableUrlEncodingForBoundRequests
-     */
-    boolean isDisableUrlEncodingForBoundRequests();
+  /**
+   * @return the version of AHC
+   */
+  String getAhcVersion();
+
+  /**
+   * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
+   *
+   * @return the name.
+   */
+  String getThreadPoolName();
+
+  /**
+   * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
+   *
+   * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
+   */
+  int getMaxConnections();
+
+  /**
+   * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
+   *
+   * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
+   */
+  int getMaxConnectionsPerHost();
+
+  /**
+   * Return the maximum duration in milliseconds an {@link AsyncHttpClient} can wait to acquire a free channel
+   *
+   * @return Return the maximum duration in milliseconds an {@link AsyncHttpClient} can wait to acquire a free channel
+   */
+  int getAcquireFreeChannelTimeout();
+
+
+  /**
+   * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+   *
+   * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+   */
+  int getConnectTimeout();
+
+  /**
+   * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+   *
+   * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+   */
+  int getReadTimeout();
+
+  /**
+   * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
+   *
+   * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
+   */
+  int getPooledConnectionIdleTimeout();
+
+  /**
+   * @return the period in millis to clean the pool of dead and idle connections.
+   */
+  int getConnectionPoolCleanerPeriod();
+
+  /**
+   * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
+   *
+   * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
+   */
+  int getRequestTimeout();
+
+  /**
+   * Is HTTP redirect enabled
+   *
+   * @return true if enabled.
+   */
+  boolean isFollowRedirect();
+
+  /**
+   * Get the maximum number of HTTP redirect
+   *
+   * @return the maximum number of HTTP redirect
+   */
+  int getMaxRedirects();
+
+  /**
+   * Is the {@link ChannelPool} support enabled.
+   *
+   * @return true if keep-alive is enabled
+   */
+  boolean isKeepAlive();
+
+  /**
+   * Return the USER_AGENT header value
+   *
+   * @return the USER_AGENT header value
+   */
+  String getUserAgent();
+
+  /**
+   * Is HTTP compression enforced.
+   *
+   * @return true if compression is enforced
+   */
+  boolean isCompressionEnforced();
+
+  /**
+   * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
+   *
+   * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
+   * provided, this method will return <code>null</code>
+   */
+  ThreadFactory getThreadFactory();
+
+  /**
+   * An instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
+   *
+   * @return instance of {@link ProxyServer}
+   */
+  ProxyServerSelector getProxyServerSelector();
+
+  /**
+   * Return an instance of {@link SslContext} used for SSL connection.
+   *
+   * @return an instance of {@link SslContext} used for SSL connection.
+   */
+  SslContext getSslContext();
+
+  /**
+   * Return the current {@link Realm}
+   *
+   * @return the current {@link Realm}
+   */
+  Realm getRealm();
+
+  /**
+   * Return the list of {@link RequestFilter}
+   *
+   * @return Unmodifiable list of {@link RequestFilter}
+   */
+  List<RequestFilter> getRequestFilters();
+
+  /**
+   * Return the list of {@link ResponseFilter}
+   *
+   * @return Unmodifiable list of {@link ResponseFilter}
+   */
+  List<ResponseFilter> getResponseFilters();
+
+  /**
+   * Return the list of {@link java.io.IOException}
+   *
+   * @return Unmodifiable list of {@link java.io.IOException}
+   */
+  List<IOExceptionFilter> getIoExceptionFilters();
+
+  /**
+   * Return cookie store that is used to store and retrieve cookies
+   *
+   * @return {@link CookieStore} object
+   */
+  CookieStore getCookieStore();
+
+  /**
+   * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+   *
+   * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+   */
+  int getMaxRequestRetry();
+
+  /**
+   * @return the disableUrlEncodingForBoundRequests
+   */
+  boolean isDisableUrlEncodingForBoundRequests();
 
-    /**
-     * @return true if AHC is to use a LAX cookie encoder, eg accept illegal chars in cookie value
-     */
-    boolean isUseLaxCookieEncoder();
+  /**
+   * @return true if AHC is to use a LAX cookie encoder, eg accept illegal chars in cookie value
+   */
+  boolean isUseLaxCookieEncoder();
 
-    /**
-     * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
-     * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
-     *
-     * @return <code>true</code> if strict 302 handling is to be used, otherwise <code>false</code>.
-     */
-    boolean isStrict302Handling();
+  /**
+   * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
+   * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
+   *
+   * @return <code>true</code> if strict 302 handling is to be used, otherwise <code>false</code>.
+   */
+  boolean isStrict302Handling();
 
-    /**
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
-     */
-    int getConnectionTtl();
+  /**
+   * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+   */
+  int getConnectionTtl();
 
-    boolean isUseOpenSsl();
+  boolean isUseOpenSsl();
 
-    boolean isUseInsecureTrustManager();
+  boolean isUseInsecureTrustManager();
 
-    /**
-     * @return true to disable all HTTPS behaviors AT ONCE, such as hostname verification and SNI
-     */
-    boolean isDisableHttpsEndpointIdentificationAlgorithm();
+  /**
+   * @return true to disable all HTTPS behaviors AT ONCE, such as hostname verification and SNI
+   */
+  boolean isDisableHttpsEndpointIdentificationAlgorithm();
 
-    /**
-     * @return the array of enabled protocols
-     */
-    String[] getEnabledProtocols();
+  /**
+   * @return the array of enabled protocols
+   */
+  String[] getEnabledProtocols();
 
-    /**
-     * @return the array of enabled cipher suites
-     */
-    String[] getEnabledCipherSuites();
+  /**
+   * @return the array of enabled cipher suites
+   */
+  String[] getEnabledCipherSuites();
 
-    /**
-     * @return the size of the SSL session cache, 0 means using the default value
-     */
-    int getSslSessionCacheSize();
+  /**
+   * @return if insecured cipher suites must be filtered out (only used when not explicitly passing enabled cipher suites)
+   */
+  boolean isFilterInsecureCipherSuites();
 
-    /**
-     * @return the SSL session timeout in seconds, 0 means using the default value
-     */
-    int getSslSessionTimeout();
+  /**
+   * @return the size of the SSL session cache, 0 means using the default value
+   */
+  int getSslSessionCacheSize();
 
-    int getHttpClientCodecMaxInitialLineLength();
+  /**
+   * @return the SSL session timeout in seconds, 0 means using the default value
+   */
+  int getSslSessionTimeout();
 
-    int getHttpClientCodecMaxHeaderSize();
+  int getHttpClientCodecMaxInitialLineLength();
 
-    int getHttpClientCodecMaxChunkSize();
+  int getHttpClientCodecMaxHeaderSize();
 
-    int getHttpClientCodecInitialBufferSize();
+  int getHttpClientCodecMaxChunkSize();
 
-    boolean isDisableZeroCopy();
+  int getHttpClientCodecInitialBufferSize();
 
-    int getHandshakeTimeout();
+  boolean isDisableZeroCopy();
 
-    SslEngineFactory getSslEngineFactory();
+  int getHandshakeTimeout();
 
-    int getChunkedFileChunkSize();
+  SslEngineFactory getSslEngineFactory();
 
-    int getWebSocketMaxBufferSize();
+  int getChunkedFileChunkSize();
 
-    int getWebSocketMaxFrameSize();
+  int getWebSocketMaxBufferSize();
 
-    boolean isKeepEncodingHeader();
+  int getWebSocketMaxFrameSize();
 
-    int getShutdownQuietPeriod();
+  boolean isKeepEncodingHeader();
 
-    int getShutdownTimeout();
+  int getShutdownQuietPeriod();
 
-    Map<ChannelOption<Object>, Object> getChannelOptions();
+  int getShutdownTimeout();
 
-    EventLoopGroup getEventLoopGroup();
+  Map<ChannelOption<Object>, Object> getChannelOptions();
 
-    boolean isUseNativeTransport();
+  EventLoopGroup getEventLoopGroup();
 
-    AdditionalChannelInitializer getHttpAdditionalChannelInitializer();
+  boolean isUseNativeTransport();
 
-    AdditionalChannelInitializer getWsAdditionalChannelInitializer();
+  Consumer<Channel> getHttpAdditionalChannelInitializer();
 
-    ResponseBodyPartFactory getResponseBodyPartFactory();
+  Consumer<Channel> getWsAdditionalChannelInitializer();
 
-    ChannelPool getChannelPool();
+  ResponseBodyPartFactory getResponseBodyPartFactory();
 
-    Timer getNettyTimer();
+  ChannelPool getChannelPool();
 
-    KeepAliveStrategy getKeepAliveStrategy();
+  ConnectionSemaphoreFactory getConnectionSemaphoreFactory();
 
-    boolean isValidateResponseHeaders();
+  Timer getNettyTimer();
 
-    boolean isAggregateWebSocketFrameFragments();
+  KeepAliveStrategy getKeepAliveStrategy();
 
-    boolean isTcpNoDelay();
+  boolean isValidateResponseHeaders();
 
-    boolean isSoReuseAddress();
+  boolean isAggregateWebSocketFrameFragments();
 
-    int getSoLinger();
+  boolean isEnableWebSocketCompression();
 
-    int getSoSndBuf();
+  boolean isTcpNoDelay();
 
-    int getSoRcvBuf();
+  boolean isSoReuseAddress();
 
-    ByteBufAllocator getAllocator();
+  int getSoLinger();
 
-    int getIoThreadsCount();
+  int getSoSndBuf();
 
-    interface AdditionalChannelInitializer {
+  int getSoRcvBuf();
 
-        void initChannel(Channel channel) throws Exception;
-    }
+  ByteBufAllocator getAllocator();
 
-    enum ResponseBodyPartFactory {
+  int getIoThreadsCount();
 
-        EAGER {
-            @Override
-            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new EagerResponseBodyPart(buf, last);
-            }
-        },
+  enum ResponseBodyPartFactory {
 
-        LAZY {
+    EAGER {
+      @Override
+      public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+        return new EagerResponseBodyPart(buf, last);
+      }
+    },
 
-            @Override
-            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new LazyResponseBodyPart(buf, last);
-            }
-        };
+    LAZY {
+      @Override
+      public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+        return new LazyResponseBodyPart(buf, last);
+      }
+    };
 
-        public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
-    }
+    public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
index b2570056f..1fcc3ed8b 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
@@ -17,13 +17,13 @@
 
 public class AsyncHttpClientState {
 
-    private final AtomicBoolean closed;
-    
-    public AsyncHttpClientState(AtomicBoolean closed) {
-        this.closed = closed;
-    }
-    
-    public boolean isClosed() {
-        return closed.get();
-    }
+  private final AtomicBoolean closed;
+
+  AsyncHttpClientState(AtomicBoolean closed) {
+    this.closed = closed;
+  }
+
+  public boolean isClosed() {
+    return closed.get();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
index e4ad98879..d82d9b02a 100644
--- a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -14,28 +14,28 @@
 
 public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
 
-    private final AsyncHttpClient client;
+  private final AsyncHttpClient client;
 
-    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
-        super(method, isDisableUrlEncoding, validateHeaders);
-        this.client = client;
-    }
+  public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
+    super(method, isDisableUrlEncoding, validateHeaders);
+    this.client = client;
+  }
 
-    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
-        super(method, isDisableUrlEncoding);
-        this.client = client;
-    }
+  public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
+    super(method, isDisableUrlEncoding);
+    this.client = client;
+  }
 
-    public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
-        super(prototype);
-        this.client = client;
-    }
+  public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
+    super(prototype);
+    this.client = client;
+  }
 
-    public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) {
-        return client.executeRequest(build(), handler);
-    }
+  public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) {
+    return client.executeRequest(build(), handler);
+  }
 
-    public ListenableFuture<Response> execute() {
-        return client.executeRequest(build(), new AsyncCompletionHandlerBase());
-    }
+  public ListenableFuture<Response> execute() {
+    return client.executeRequest(build(), new AsyncCompletionHandlerBase());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ClientStats.java b/client/src/main/java/org/asynchttpclient/ClientStats.java
index d6e4efa4a..9f44604c2 100644
--- a/client/src/main/java/org/asynchttpclient/ClientStats.java
+++ b/client/src/main/java/org/asynchttpclient/ClientStats.java
@@ -22,71 +22,71 @@
  */
 public class ClientStats {
 
-    private final Map<String, HostStats> statsPerHost;
+  private final Map<String, HostStats> statsPerHost;
 
-    public ClientStats(Map<String, HostStats> statsPerHost) {
-        this.statsPerHost = Collections.unmodifiableMap(statsPerHost);
-    }
+  public ClientStats(Map<String, HostStats> statsPerHost) {
+    this.statsPerHost = Collections.unmodifiableMap(statsPerHost);
+  }
 
-    /**
-     * @return A map from hostname to statistics on that host's connections.
-     * The returned map is unmodifiable.
-     */
-    public Map<String, HostStats> getStatsPerHost() {
-        return statsPerHost;
-    }
+  /**
+   * @return A map from hostname to statistics on that host's connections.
+   * The returned map is unmodifiable.
+   */
+  public Map<String, HostStats> getStatsPerHost() {
+    return statsPerHost;
+  }
 
-    /**
-     * @return The sum of {@link #getTotalActiveConnectionCount()} and {@link #getTotalIdleConnectionCount()},
-     * a long representing the total number of connections in the connection pool.
-     */
-    public long getTotalConnectionCount() {
-        return statsPerHost
-                .values()
-                .stream()
-                .mapToLong(HostStats::getHostConnectionCount)
-                .sum();
-    }
+  /**
+   * @return The sum of {@link #getTotalActiveConnectionCount()} and {@link #getTotalIdleConnectionCount()},
+   * a long representing the total number of connections in the connection pool.
+   */
+  public long getTotalConnectionCount() {
+    return statsPerHost
+            .values()
+            .stream()
+            .mapToLong(HostStats::getHostConnectionCount)
+            .sum();
+  }
 
-    /**
-     * @return A long representing the number of active connections in the connection pool.
-     */
-    public long getTotalActiveConnectionCount() {
-        return statsPerHost
-                .values()
-                .stream()
-                .mapToLong(HostStats::getHostActiveConnectionCount)
-                .sum();
-    }
+  /**
+   * @return A long representing the number of active connections in the connection pool.
+   */
+  public long getTotalActiveConnectionCount() {
+    return statsPerHost
+            .values()
+            .stream()
+            .mapToLong(HostStats::getHostActiveConnectionCount)
+            .sum();
+  }
 
-    /**
-     * @return A long representing the number of idle connections in the connection pool.
-     */
-    public long getTotalIdleConnectionCount() {
-        return statsPerHost
-                .values()
-                .stream()
-                .mapToLong(HostStats::getHostIdleConnectionCount)
-                .sum();
-    }
+  /**
+   * @return A long representing the number of idle connections in the connection pool.
+   */
+  public long getTotalIdleConnectionCount() {
+    return statsPerHost
+            .values()
+            .stream()
+            .mapToLong(HostStats::getHostIdleConnectionCount)
+            .sum();
+  }
 
-    @Override
-    public String toString() {
-        return "There are " + getTotalConnectionCount() +
-                " total connections, " + getTotalActiveConnectionCount() +
-                " are active and " + getTotalIdleConnectionCount() + " are idle.";
-    }
+  @Override
+  public String toString() {
+    return "There are " + getTotalConnectionCount() +
+            " total connections, " + getTotalActiveConnectionCount() +
+            " are active and " + getTotalIdleConnectionCount() + " are idle.";
+  }
 
-    @Override
-    public boolean equals(final Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        final ClientStats that = (ClientStats) o;
-        return Objects.equals(statsPerHost, that.statsPerHost);
-    }
+  @Override
+  public boolean equals(final Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    final ClientStats that = (ClientStats) o;
+    return Objects.equals(statsPerHost, that.statsPerHost);
+  }
 
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(statsPerHost);
-    }
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(statsPerHost);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 7d4ffdddb..8d2c3f7ab 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -16,11 +16,11 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Predicate;
-
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.codec.http.cookie.Cookie;
+import io.netty.util.HashedWheelTimer;
+import io.netty.util.Timer;
+import io.netty.util.concurrent.DefaultThreadFactory;
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
@@ -31,250 +31,275 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.HashedWheelTimer;
-import io.netty.util.Timer;
+import java.util.List;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Predicate;
+
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 
 /**
  * Default and threadsafe implementation of {@link AsyncHttpClient}.
  */
 public class DefaultAsyncHttpClient implements AsyncHttpClient {
 
-    private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
-    private final AsyncHttpClientConfig config;
-    private final AtomicBoolean closed = new AtomicBoolean(false);
-    private final ChannelManager channelManager;
-    private final NettyRequestSender requestSender;
-    private final boolean allowStopNettyTimer;
-    private final Timer nettyTimer;
-
-    /**
-     * Default signature calculator to use for all requests constructed by this
-     * client instance.
-     */
-    protected SignatureCalculator signatureCalculator;
-
-    /**
-     * Create a new HTTP Asynchronous Client using the default
-     * {@link DefaultAsyncHttpClientConfig} configuration. The default
-     * {@link AsyncHttpClient} that will be used will be based on the classpath
-     * configuration.
-     *
-     * If none of those providers are found, then the engine will throw an
-     * IllegalStateException.
-     */
-    public DefaultAsyncHttpClient() {
-        this(new DefaultAsyncHttpClientConfig.Builder().build());
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using the specified
-     * {@link DefaultAsyncHttpClientConfig} configuration. This configuration
-     * will be passed to the default {@link AsyncHttpClient} that will be
-     * selected based on the classpath configuration.
-     *
-     * @param config a {@link DefaultAsyncHttpClientConfig}
-     */
-    public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
-
-        this.config = config;
-
-        allowStopNettyTimer = config.getNettyTimer() == null;
-        nettyTimer = allowStopNettyTimer ? newNettyTimer() : config.getNettyTimer();
-
-        channelManager = new ChannelManager(config, nettyTimer);
-        requestSender = new NettyRequestSender(config, channelManager, nettyTimer, new AsyncHttpClientState(closed));
-        channelManager.configureBootstraps(requestSender);
-    }
-
-    private Timer newNettyTimer() {
-        HashedWheelTimer timer = new HashedWheelTimer();
-        timer.start();
-        return timer;
-    }
-
-    @Override
-    public void close() {
-        if (closed.compareAndSet(false, true)) {
-            try {
-                channelManager.close();
-            } catch (Throwable t) {
-                LOGGER.warn("Unexpected error on ChannelManager close", t);
-            }
-            if (allowStopNettyTimer) {
-                try {
-                    nettyTimer.stop();
-                } catch (Throwable t) {
-                    LOGGER.warn("Unexpected error on HashedWheelTimer close", t);
-                }
-            }
-        }
-    }
-
-    @Override
-    public boolean isClosed() {
-        return closed.get();
-    }
-
-    @Override
-    public DefaultAsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        this.signatureCalculator = signatureCalculator;
-        return this;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareGet(String url) {
-        return requestBuilder("GET", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareConnect(String url) {
-        return requestBuilder("CONNECT", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareOptions(String url) {
-        return requestBuilder("OPTIONS", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareHead(String url) {
-        return requestBuilder("HEAD", url);
-    }
-
-    @Override
-    public BoundRequestBuilder preparePost(String url) {
-        return requestBuilder("POST", url);
-    }
-
-    @Override
-    public BoundRequestBuilder preparePut(String url) {
-        return requestBuilder("PUT", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareDelete(String url) {
-        return requestBuilder("DELETE", url);
-    }
-
-    @Override
-    public BoundRequestBuilder preparePatch(String url) {
-        return requestBuilder("PATCH", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareTrace(String url) {
-        return requestBuilder("TRACE", url);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return requestBuilder(request);
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-        return prepareRequest(requestBuilder.build());
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-
-        if (config.getRequestFilters().isEmpty()) {
-            return execute(request, handler);
-
-        } else {
-            FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
-            try {
-                fc = preProcessRequest(fc);
-            } catch (Exception e) {
-                handler.onThrowable(e);
-                return new ListenableFuture.CompletedFailure<>("preProcessRequest failed", e);
-            }
-
-            return execute(fc.getRequest(), fc.getAsyncHandler());
-        }
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-        return executeRequest(requestBuilder.build(), handler);
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(Request request) {
-        return executeRequest(request, new AsyncCompletionHandlerBase());
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-        return executeRequest(requestBuilder.build());
-    }
-
-    private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
+  private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
+  private final AsyncHttpClientConfig config;
+  private final boolean noRequestFilters;
+  private final AtomicBoolean closed = new AtomicBoolean(false);
+  private final ChannelManager channelManager;
+  private final NettyRequestSender requestSender;
+  private final boolean allowStopNettyTimer;
+  private final Timer nettyTimer;
+
+  /**
+   * Default signature calculator to use for all requests constructed by this
+   * client instance.
+   */
+  private SignatureCalculator signatureCalculator;
+
+  /**
+   * Create a new HTTP Asynchronous Client using the default
+   * {@link DefaultAsyncHttpClientConfig} configuration. The default
+   * {@link AsyncHttpClient} that will be used will be based on the classpath
+   * configuration.
+   * <p>
+   * If none of those providers are found, then the engine will throw an
+   * IllegalStateException.
+   */
+  public DefaultAsyncHttpClient() {
+    this(new DefaultAsyncHttpClientConfig.Builder().build());
+  }
+
+  /**
+   * Create a new HTTP Asynchronous Client using the specified
+   * {@link DefaultAsyncHttpClientConfig} configuration. This configuration
+   * will be passed to the default {@link AsyncHttpClient} that will be
+   * selected based on the classpath configuration.
+   *
+   * @param config a {@link DefaultAsyncHttpClientConfig}
+   */
+  public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
+
+    this.config = config;
+    this.noRequestFilters = config.getRequestFilters().isEmpty();
+    allowStopNettyTimer = config.getNettyTimer() == null;
+    nettyTimer = allowStopNettyTimer ? newNettyTimer(config) : config.getNettyTimer();
+
+    channelManager = new ChannelManager(config, nettyTimer);
+    requestSender = new NettyRequestSender(config, channelManager, nettyTimer, new AsyncHttpClientState(closed));
+    channelManager.configureBootstraps(requestSender);
+  }
+
+  private Timer newNettyTimer(AsyncHttpClientConfig config) {
+    ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName() + "-timer");
+
+    HashedWheelTimer timer = new HashedWheelTimer(threadFactory);
+    timer.start();
+    return timer;
+  }
+
+  @Override
+  public void close() {
+    if (closed.compareAndSet(false, true)) {
+      try {
+        channelManager.close();
+      } catch (Throwable t) {
+        LOGGER.warn("Unexpected error on ChannelManager close", t);
+      }
+      if (allowStopNettyTimer) {
         try {
-            return requestSender.sendRequest(request, asyncHandler, null, false);
-        } catch (Exception e) {
-            asyncHandler.onThrowable(e);
-            return new ListenableFuture.CompletedFailure<>(e);
+          nettyTimer.stop();
+        } catch (Throwable t) {
+          LOGGER.warn("Unexpected error on HashedWheelTimer close", t);
         }
+      }
     }
-
-    /**
-     * Configure and execute the associated {@link RequestFilter}. This class
-     * may decorate the {@link Request} and {@link AsyncHandler}
-     *
-     * @param fc {@link FilterContext}
-     * @return {@link FilterContext}
-     */
-    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
-        for (RequestFilter asyncFilter : config.getRequestFilters()) {
-            fc = asyncFilter.filter(fc);
-            assertNotNull(fc, "filterContext");
+  }
+
+  @Override
+  public boolean isClosed() {
+    return closed.get();
+  }
+
+  @Override
+  public DefaultAsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+    this.signatureCalculator = signatureCalculator;
+    return this;
+  }
+
+  @Override
+  public BoundRequestBuilder prepare(String method, String url) {
+    return requestBuilder(method, url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareGet(String url) {
+    return requestBuilder("GET", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareConnect(String url) {
+    return requestBuilder("CONNECT", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareOptions(String url) {
+    return requestBuilder("OPTIONS", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareHead(String url) {
+    return requestBuilder("HEAD", url);
+  }
+
+  @Override
+  public BoundRequestBuilder preparePost(String url) {
+    return requestBuilder("POST", url);
+  }
+
+  @Override
+  public BoundRequestBuilder preparePut(String url) {
+    return requestBuilder("PUT", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareDelete(String url) {
+    return requestBuilder("DELETE", url);
+  }
+
+  @Override
+  public BoundRequestBuilder preparePatch(String url) {
+    return requestBuilder("PATCH", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareTrace(String url) {
+    return requestBuilder("TRACE", url);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(Request request) {
+    return requestBuilder(request);
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+    return prepareRequest(requestBuilder.build());
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+    if (config.getCookieStore() != null) {
+      try {
+        List<Cookie> cookies = config.getCookieStore().get(request.getUri());
+        if (!cookies.isEmpty()) {
+          RequestBuilder requestBuilder = new RequestBuilder(request);
+          for (Cookie cookie : cookies) {
+            requestBuilder.addOrReplaceCookie(cookie);
+          }
+          request = requestBuilder.build();
         }
-
-        Request request = fc.getRequest();
-        if (fc.getAsyncHandler() instanceof ResumableAsyncHandler) {
-            request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
-        }
-
-        if (request.getRangeOffset() != 0) {
-            RequestBuilder builder = new RequestBuilder(request);
-            builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
-            request = builder.build();
-        }
-        fc = new FilterContext.FilterContextBuilder<>(fc).request(request).build();
-        return fc;
+      } catch (Exception e) {
+        handler.onThrowable(e);
+        return new ListenableFuture.CompletedFailure<>("Failed to set cookies of request", e);
+      }
     }
 
-    public ChannelPool getChannelPool() {
-        return channelManager.getChannelPool();
+    if (noRequestFilters) {
+      return execute(request, handler);
+    } else {
+      FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
+      try {
+        fc = preProcessRequest(fc);
+      } catch (Exception e) {
+        handler.onThrowable(e);
+        return new ListenableFuture.CompletedFailure<>("preProcessRequest failed", e);
+      }
+
+      return execute(fc.getRequest(), fc.getAsyncHandler());
     }
-
-    public EventLoopGroup getEventLoopGroup() {
-        return channelManager.getEventLoopGroup();
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+    return executeRequest(requestBuilder.build(), handler);
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(Request request) {
+    return executeRequest(request, new AsyncCompletionHandlerBase());
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+    return executeRequest(requestBuilder.build());
+  }
+
+  private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
+    try {
+      return requestSender.sendRequest(request, asyncHandler, null);
+    } catch (Exception e) {
+      asyncHandler.onThrowable(e);
+      return new ListenableFuture.CompletedFailure<>(e);
     }
-
-    @Override
-    public ClientStats getClientStats() {
-        return channelManager.getClientStats();
-    }
-    
-    @Override
-    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-        getChannelPool().flushPartitions(predicate);
-    }
-
-    protected BoundRequestBuilder requestBuilder(String method, String url) {
-        return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
+  }
+
+  /**
+   * Configure and execute the associated {@link RequestFilter}. This class
+   * may decorate the {@link Request} and {@link AsyncHandler}
+   *
+   * @param fc {@link FilterContext}
+   * @return {@link FilterContext}
+   */
+  private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
+    for (RequestFilter asyncFilter : config.getRequestFilters()) {
+      fc = asyncFilter.filter(fc);
+      assertNotNull(fc, "filterContext");
     }
 
-    protected BoundRequestBuilder requestBuilder(Request prototype) {
-        return new BoundRequestBuilder(this, prototype).setSignatureCalculator(signatureCalculator);
+    Request request = fc.getRequest();
+    if (fc.getAsyncHandler() instanceof ResumableAsyncHandler) {
+      request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
     }
 
-    @Override
-    public AsyncHttpClientConfig getConfig() {
-        return this.config;
+    if (request.getRangeOffset() != 0) {
+      RequestBuilder builder = new RequestBuilder(request);
+      builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
+      request = builder.build();
     }
+    fc = new FilterContext.FilterContextBuilder<>(fc).request(request).build();
+    return fc;
+  }
+
+  public ChannelPool getChannelPool() {
+    return channelManager.getChannelPool();
+  }
+
+  public EventLoopGroup getEventLoopGroup() {
+    return channelManager.getEventLoopGroup();
+  }
+
+  @Override
+  public ClientStats getClientStats() {
+    return channelManager.getClientStats();
+  }
+
+  @Override
+  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+    getChannelPool().flushPartitions(predicate);
+  }
+
+  protected BoundRequestBuilder requestBuilder(String method, String url) {
+    return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
+  }
+
+  protected BoundRequestBuilder requestBuilder(Request prototype) {
+    return new BoundRequestBuilder(this, prototype).setSignatureCalculator(signatureCalculator);
+  }
+
+  @Override
+  public AsyncHttpClientConfig getConfig() {
+    return this.config;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 2010c4594..d26612fb6 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -15,1207 +15,1299 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
 import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.Timer;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.concurrent.ThreadFactory;
-
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
 import org.asynchttpclient.channel.KeepAliveStrategy;
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.cookie.CookieStore;
+import org.asynchttpclient.cookie.ThreadSafeCookieStore;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.netty.channel.ConnectionSemaphoreFactory;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
+import java.util.*;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
+
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
+
 /**
  * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this object default behavior by doing: <br>
  * -Dorg.asynchttpclient.nameOfTheProperty
- * 
+ *
  * @see AsyncHttpClientConfig for documentation
  */
 public class DefaultAsyncHttpClientConfig implements AsyncHttpClientConfig {
 
-    private static final String AHC_VERSION;
-
-    static {
-        try (InputStream is = DefaultAsyncHttpClientConfig.class.getResourceAsStream("/ahc-version.properties")) {
-            Properties prop = new Properties();
-            prop.load(is);
-            AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
-        } catch (IOException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
+  // http
+  private final boolean followRedirect;
+  private final int maxRedirects;
+  private final boolean strict302Handling;
+  private final boolean compressionEnforced;
+  private final String userAgent;
+  private final Realm realm;
+  private final int maxRequestRetry;
+  private final boolean disableUrlEncodingForBoundRequests;
+  private final boolean useLaxCookieEncoder;
+  private final boolean disableZeroCopy;
+  private final boolean keepEncodingHeader;
+  private final ProxyServerSelector proxyServerSelector;
+  private final boolean validateResponseHeaders;
+
+  // websockets
+  private final boolean aggregateWebSocketFrameFragments;
+  private final boolean enablewebSocketCompression;
+  private final int webSocketMaxBufferSize;
+  private final int webSocketMaxFrameSize;
+
+  // timeouts
+  private final int connectTimeout;
+  private final int requestTimeout;
+  private final int readTimeout;
+  private final int shutdownQuietPeriod;
+  private final int shutdownTimeout;
+
+  // keep-alive
+  private final boolean keepAlive;
+  private final int pooledConnectionIdleTimeout;
+  private final int connectionPoolCleanerPeriod;
+  private final int connectionTtl;
+  private final int maxConnections;
+  private final int maxConnectionsPerHost;
+  private final int acquireFreeChannelTimeout;
+  private final ChannelPool channelPool;
+  private final ConnectionSemaphoreFactory connectionSemaphoreFactory;
+  private final KeepAliveStrategy keepAliveStrategy;
+
+  // ssl
+  private final boolean useOpenSsl;
+  private final boolean useInsecureTrustManager;
+  private final boolean disableHttpsEndpointIdentificationAlgorithm;
+  private final int handshakeTimeout;
+  private final String[] enabledProtocols;
+  private final String[] enabledCipherSuites;
+  private final boolean filterInsecureCipherSuites;
+  private final int sslSessionCacheSize;
+  private final int sslSessionTimeout;
+  private final SslContext sslContext;
+  private final SslEngineFactory sslEngineFactory;
+
+  // filters
+  private final List<RequestFilter> requestFilters;
+  private final List<ResponseFilter> responseFilters;
+  private final List<IOExceptionFilter> ioExceptionFilters;
+
+  // cookie store
+  private final CookieStore cookieStore;
+
+  // internals
+  private final String threadPoolName;
+  private final int httpClientCodecMaxInitialLineLength;
+  private final int httpClientCodecMaxHeaderSize;
+  private final int httpClientCodecMaxChunkSize;
+  private final int httpClientCodecInitialBufferSize;
+  private final int chunkedFileChunkSize;
+  private final Map<ChannelOption<Object>, Object> channelOptions;
+  private final EventLoopGroup eventLoopGroup;
+  private final boolean useNativeTransport;
+  private final ByteBufAllocator allocator;
+  private final boolean tcpNoDelay;
+  private final boolean soReuseAddress;
+  private final int soLinger;
+  private final int soSndBuf;
+  private final int soRcvBuf;
+  private final Timer nettyTimer;
+  private final ThreadFactory threadFactory;
+  private final Consumer<Channel> httpAdditionalChannelInitializer;
+  private final Consumer<Channel> wsAdditionalChannelInitializer;
+  private final ResponseBodyPartFactory responseBodyPartFactory;
+  private final int ioThreadsCount;
+
+  private DefaultAsyncHttpClientConfig(// http
+                                       boolean followRedirect,
+                                       int maxRedirects,
+                                       boolean strict302Handling,
+                                       boolean compressionEnforced,
+                                       String userAgent,
+                                       Realm realm,
+                                       int maxRequestRetry,
+                                       boolean disableUrlEncodingForBoundRequests,
+                                       boolean useLaxCookieEncoder,
+                                       boolean disableZeroCopy,
+                                       boolean keepEncodingHeader,
+                                       ProxyServerSelector proxyServerSelector,
+                                       boolean validateResponseHeaders,
+                                       boolean aggregateWebSocketFrameFragments,
+                                       boolean enablewebSocketCompression,
+
+                                       // timeouts
+                                       int connectTimeout,
+                                       int requestTimeout,
+                                       int readTimeout,
+                                       int shutdownQuietPeriod,
+                                       int shutdownTimeout,
+
+                                       // keep-alive
+                                       boolean keepAlive,
+                                       int pooledConnectionIdleTimeout,
+                                       int connectionPoolCleanerPeriod,
+                                       int connectionTtl,
+                                       int maxConnections,
+                                       int maxConnectionsPerHost,
+                                       int acquireFreeChannelTimeout,
+                                       ChannelPool channelPool,
+                                       ConnectionSemaphoreFactory connectionSemaphoreFactory,
+                                       KeepAliveStrategy keepAliveStrategy,
+
+                                       // ssl
+                                       boolean useOpenSsl,
+                                       boolean useInsecureTrustManager,
+                                       boolean disableHttpsEndpointIdentificationAlgorithm,
+                                       int handshakeTimeout,
+                                       String[] enabledProtocols,
+                                       String[] enabledCipherSuites,
+                                       boolean filterInsecureCipherSuites,
+                                       int sslSessionCacheSize,
+                                       int sslSessionTimeout,
+                                       SslContext sslContext,
+                                       SslEngineFactory sslEngineFactory,
+
+                                       // filters
+                                       List<RequestFilter> requestFilters,
+                                       List<ResponseFilter> responseFilters,
+                                       List<IOExceptionFilter> ioExceptionFilters,
+
+                                       // cookie store
+                                       CookieStore cookieStore,
+
+                                       // tuning
+                                       boolean tcpNoDelay,
+                                       boolean soReuseAddress,
+                                       int soLinger,
+                                       int soSndBuf,
+                                       int soRcvBuf,
+
+                                       // internals
+                                       String threadPoolName,
+                                       int httpClientCodecMaxInitialLineLength,
+                                       int httpClientCodecMaxHeaderSize,
+                                       int httpClientCodecMaxChunkSize,
+                                       int httpClientCodecInitialBufferSize,
+                                       int chunkedFileChunkSize,
+                                       int webSocketMaxBufferSize,
+                                       int webSocketMaxFrameSize,
+                                       Map<ChannelOption<Object>, Object> channelOptions,
+                                       EventLoopGroup eventLoopGroup,
+                                       boolean useNativeTransport,
+                                       ByteBufAllocator allocator,
+                                       Timer nettyTimer,
+                                       ThreadFactory threadFactory,
+                                       Consumer<Channel> httpAdditionalChannelInitializer,
+                                       Consumer<Channel> wsAdditionalChannelInitializer,
+                                       ResponseBodyPartFactory responseBodyPartFactory,
+                                       int ioThreadsCount) {
 
     // http
-    private final boolean followRedirect;
-    private final int maxRedirects;
-    private final boolean strict302Handling;
-    private final boolean compressionEnforced;
-    private final String userAgent;
-    private final Realm realm;
-    private final int maxRequestRetry;
-    private final boolean disableUrlEncodingForBoundRequests;
-    private final boolean useLaxCookieEncoder;
-    private final boolean disableZeroCopy;
-    private final boolean keepEncodingHeader;
-    private final ProxyServerSelector proxyServerSelector;
-    private final boolean validateResponseHeaders;
-    private final boolean aggregateWebSocketFrameFragments;
+    this.followRedirect = followRedirect;
+    this.maxRedirects = maxRedirects;
+    this.strict302Handling = strict302Handling;
+    this.compressionEnforced = compressionEnforced;
+    this.userAgent = userAgent;
+    this.realm = realm;
+    this.maxRequestRetry = maxRequestRetry;
+    this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+    this.useLaxCookieEncoder = useLaxCookieEncoder;
+    this.disableZeroCopy = disableZeroCopy;
+    this.keepEncodingHeader = keepEncodingHeader;
+    this.proxyServerSelector = proxyServerSelector;
+    this.validateResponseHeaders = validateResponseHeaders;
+
+    // websocket
+    this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
+    this.enablewebSocketCompression = enablewebSocketCompression;
+    this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+    this.webSocketMaxFrameSize = webSocketMaxFrameSize;
 
     // timeouts
-    private final int connectTimeout;
-    private final int requestTimeout;
-    private final int readTimeout;
-    private final int shutdownQuietPeriod;
-    private final int shutdownTimeout;
+    this.connectTimeout = connectTimeout;
+    this.requestTimeout = requestTimeout;
+    this.readTimeout = readTimeout;
+    this.shutdownQuietPeriod = shutdownQuietPeriod;
+    this.shutdownTimeout = shutdownTimeout;
 
     // keep-alive
-    private final boolean keepAlive;
-    private final int pooledConnectionIdleTimeout;
-    private final int connectionPoolCleanerPeriod;
-    private final int connectionTtl;
-    private final int maxConnections;
-    private final int maxConnectionsPerHost;
-    private final ChannelPool channelPool;
-    private final KeepAliveStrategy keepAliveStrategy;
+    this.keepAlive = keepAlive;
+    this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+    this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
+    this.connectionTtl = connectionTtl;
+    this.maxConnections = maxConnections;
+    this.maxConnectionsPerHost = maxConnectionsPerHost;
+    this.acquireFreeChannelTimeout = acquireFreeChannelTimeout;
+    this.channelPool = channelPool;
+    this.connectionSemaphoreFactory = connectionSemaphoreFactory;
+    this.keepAliveStrategy = keepAliveStrategy;
 
     // ssl
-    private final boolean useOpenSsl;
-    private final boolean useInsecureTrustManager;
-    private final boolean disableHttpsEndpointIdentificationAlgorithm;
-    private final int handshakeTimeout;
-    private final String[] enabledProtocols;
-    private final String[] enabledCipherSuites;
-    private final int sslSessionCacheSize;
-    private final int sslSessionTimeout;
-    private final SslContext sslContext;
-    private final SslEngineFactory sslEngineFactory;
+    this.useOpenSsl = useOpenSsl;
+    this.useInsecureTrustManager = useInsecureTrustManager;
+    this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
+    this.handshakeTimeout = handshakeTimeout;
+    this.enabledProtocols = enabledProtocols;
+    this.enabledCipherSuites = enabledCipherSuites;
+    this.filterInsecureCipherSuites = filterInsecureCipherSuites;
+    this.sslSessionCacheSize = sslSessionCacheSize;
+    this.sslSessionTimeout = sslSessionTimeout;
+    this.sslContext = sslContext;
+    this.sslEngineFactory = sslEngineFactory;
+
+    // filters
+    this.requestFilters = requestFilters;
+    this.responseFilters = responseFilters;
+    this.ioExceptionFilters = ioExceptionFilters;
+
+    // cookie store
+    this.cookieStore = cookieStore;
+
+    // tuning
+    this.tcpNoDelay = tcpNoDelay;
+    this.soReuseAddress = soReuseAddress;
+    this.soLinger = soLinger;
+    this.soSndBuf = soSndBuf;
+    this.soRcvBuf = soRcvBuf;
+
+    // internals
+    this.threadPoolName = threadPoolName;
+    this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+    this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+    this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+    this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
+    this.chunkedFileChunkSize = chunkedFileChunkSize;
+    this.channelOptions = channelOptions;
+    this.eventLoopGroup = eventLoopGroup;
+    this.useNativeTransport = useNativeTransport;
+    this.allocator = allocator;
+    this.nettyTimer = nettyTimer;
+    this.threadFactory = threadFactory;
+    this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+    this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+    this.responseBodyPartFactory = responseBodyPartFactory;
+    this.ioThreadsCount = ioThreadsCount;
+  }
+
+  @Override
+  public String getAhcVersion() {
+    return AsyncHttpClientConfigDefaults.AHC_VERSION;
+  }
+
+  // http
+  @Override
+  public boolean isFollowRedirect() {
+    return followRedirect;
+  }
+
+  @Override
+  public int getMaxRedirects() {
+    return maxRedirects;
+  }
+
+  @Override
+  public boolean isStrict302Handling() {
+    return strict302Handling;
+  }
+
+  @Override
+  public boolean isCompressionEnforced() {
+    return compressionEnforced;
+  }
+
+  @Override
+  public String getUserAgent() {
+    return userAgent;
+  }
+
+  @Override
+  public Realm getRealm() {
+    return realm;
+  }
+
+  @Override
+  public int getMaxRequestRetry() {
+    return maxRequestRetry;
+  }
+
+  @Override
+  public boolean isDisableUrlEncodingForBoundRequests() {
+    return disableUrlEncodingForBoundRequests;
+  }
+
+  @Override
+  public boolean isUseLaxCookieEncoder() {
+    return useLaxCookieEncoder;
+  }
+
+  @Override
+  public boolean isDisableZeroCopy() {
+    return disableZeroCopy;
+  }
+
+  @Override
+  public boolean isKeepEncodingHeader() {
+    return keepEncodingHeader;
+  }
+
+  @Override
+  public ProxyServerSelector getProxyServerSelector() {
+    return proxyServerSelector;
+  }
+
+  // websocket
+  @Override
+  public boolean isAggregateWebSocketFrameFragments() {
+    return aggregateWebSocketFrameFragments;
+  }
+
+  @Override
+  public boolean isEnableWebSocketCompression() {
+    return enablewebSocketCompression;
+  }
+
+  @Override
+  public int getWebSocketMaxBufferSize() {
+    return webSocketMaxBufferSize;
+  }
+
+  @Override
+  public int getWebSocketMaxFrameSize() {
+    return webSocketMaxFrameSize;
+  }
+
+  // timeouts
+  @Override
+  public int getConnectTimeout() {
+    return connectTimeout;
+  }
+
+  @Override
+  public int getRequestTimeout() {
+    return requestTimeout;
+  }
+
+  @Override
+  public int getReadTimeout() {
+    return readTimeout;
+  }
+
+  @Override
+  public int getShutdownQuietPeriod() {
+    return shutdownQuietPeriod;
+  }
+
+  @Override
+  public int getShutdownTimeout() {
+    return shutdownTimeout;
+  }
+
+  // keep-alive
+  @Override
+  public boolean isKeepAlive() {
+    return keepAlive;
+  }
+
+  @Override
+  public int getPooledConnectionIdleTimeout() {
+    return pooledConnectionIdleTimeout;
+  }
+
+  @Override
+  public int getConnectionPoolCleanerPeriod() {
+    return connectionPoolCleanerPeriod;
+  }
+
+  @Override
+  public int getConnectionTtl() {
+    return connectionTtl;
+  }
+
+  @Override
+  public int getMaxConnections() {
+    return maxConnections;
+  }
+
+  @Override
+  public int getMaxConnectionsPerHost() {
+    return maxConnectionsPerHost;
+  }
+
+  @Override
+  public int getAcquireFreeChannelTimeout() { return acquireFreeChannelTimeout; }
+
+  @Override
+  public ChannelPool getChannelPool() {
+    return channelPool;
+  }
+
+  @Override
+  public ConnectionSemaphoreFactory getConnectionSemaphoreFactory() {
+    return connectionSemaphoreFactory;
+  }
+
+  @Override
+  public KeepAliveStrategy getKeepAliveStrategy() {
+    return keepAliveStrategy;
+  }
+
+  @Override
+  public boolean isValidateResponseHeaders() {
+    return validateResponseHeaders;
+  }
+
+  // ssl
+  @Override
+  public boolean isUseOpenSsl() {
+    return useOpenSsl;
+  }
+
+  @Override
+  public boolean isUseInsecureTrustManager() {
+    return useInsecureTrustManager;
+  }
+
+  @Override
+  public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
+    return disableHttpsEndpointIdentificationAlgorithm;
+  }
+
+  @Override
+  public int getHandshakeTimeout() {
+    return handshakeTimeout;
+  }
+
+  @Override
+  public String[] getEnabledProtocols() {
+    return enabledProtocols;
+  }
+
+  @Override
+  public String[] getEnabledCipherSuites() {
+    return enabledCipherSuites;
+  }
+
+  @Override
+  public boolean isFilterInsecureCipherSuites() {
+    return filterInsecureCipherSuites;
+  }
+
+  @Override
+  public int getSslSessionCacheSize() {
+    return sslSessionCacheSize;
+  }
+
+  @Override
+  public int getSslSessionTimeout() {
+    return sslSessionTimeout;
+  }
+
+  @Override
+  public SslContext getSslContext() {
+    return sslContext;
+  }
+
+  @Override
+  public SslEngineFactory getSslEngineFactory() {
+    return sslEngineFactory;
+  }
+
+  // filters
+  @Override
+  public List<RequestFilter> getRequestFilters() {
+    return requestFilters;
+  }
+
+  @Override
+  public List<ResponseFilter> getResponseFilters() {
+    return responseFilters;
+  }
+
+  @Override
+  public List<IOExceptionFilter> getIoExceptionFilters() {
+    return ioExceptionFilters;
+  }
+
+  // cookie store
+  @Override
+  public CookieStore getCookieStore() {
+    return cookieStore;
+  }
+
+  // tuning
+  @Override
+  public boolean isTcpNoDelay() {
+    return tcpNoDelay;
+  }
+
+  @Override
+  public boolean isSoReuseAddress() {
+    return soReuseAddress;
+  }
+
+  @Override
+  public int getSoLinger() {
+    return soLinger;
+  }
+
+  @Override
+  public int getSoSndBuf() {
+    return soSndBuf;
+  }
+
+  @Override
+  public int getSoRcvBuf() {
+    return soRcvBuf;
+  }
+
+  // internals
+  @Override
+  public String getThreadPoolName() {
+    return threadPoolName;
+  }
+
+  @Override
+  public int getHttpClientCodecMaxInitialLineLength() {
+    return httpClientCodecMaxInitialLineLength;
+  }
+
+  @Override
+  public int getHttpClientCodecMaxHeaderSize() {
+    return httpClientCodecMaxHeaderSize;
+  }
+
+  @Override
+  public int getHttpClientCodecMaxChunkSize() {
+    return httpClientCodecMaxChunkSize;
+  }
+
+  @Override
+  public int getHttpClientCodecInitialBufferSize() {
+    return httpClientCodecInitialBufferSize;
+  }
+
+  @Override
+  public int getChunkedFileChunkSize() {
+    return chunkedFileChunkSize;
+  }
+
+  @Override
+  public Map<ChannelOption<Object>, Object> getChannelOptions() {
+    return channelOptions;
+  }
+
+  @Override
+  public EventLoopGroup getEventLoopGroup() {
+    return eventLoopGroup;
+  }
+
+  @Override
+  public boolean isUseNativeTransport() {
+    return useNativeTransport;
+  }
+
+  @Override
+  public ByteBufAllocator getAllocator() {
+    return allocator;
+  }
+
+  @Override
+  public Timer getNettyTimer() {
+    return nettyTimer;
+  }
+
+  @Override
+  public ThreadFactory getThreadFactory() {
+    return threadFactory;
+  }
+
+  @Override
+  public Consumer<Channel> getHttpAdditionalChannelInitializer() {
+    return httpAdditionalChannelInitializer;
+  }
+
+  @Override
+  public Consumer<Channel> getWsAdditionalChannelInitializer() {
+    return wsAdditionalChannelInitializer;
+  }
+
+  @Override
+  public ResponseBodyPartFactory getResponseBodyPartFactory() {
+    return responseBodyPartFactory;
+  }
+
+  @Override
+  public int getIoThreadsCount() {
+    return ioThreadsCount;
+  }
+
+  /**
+   * Builder for an {@link AsyncHttpClient}
+   */
+  public static class Builder {
 
     // filters
-    private final List<RequestFilter> requestFilters;
-    private final List<ResponseFilter> responseFilters;
-    private final List<IOExceptionFilter> ioExceptionFilters;
+    private final List<RequestFilter> requestFilters = new LinkedList<>();
+    private final List<ResponseFilter> responseFilters = new LinkedList<>();
+    private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
+    // http
+    private boolean followRedirect = defaultFollowRedirect();
+    private int maxRedirects = defaultMaxRedirects();
+    private boolean strict302Handling = defaultStrict302Handling();
+    private boolean compressionEnforced = defaultCompressionEnforced();
+    private String userAgent = defaultUserAgent();
+    private Realm realm;
+    private int maxRequestRetry = defaultMaxRequestRetry();
+    private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
+    private boolean useLaxCookieEncoder = defaultUseLaxCookieEncoder();
+    private boolean disableZeroCopy = defaultDisableZeroCopy();
+    private boolean keepEncodingHeader = defaultKeepEncodingHeader();
+    private ProxyServerSelector proxyServerSelector;
+    private boolean useProxySelector = defaultUseProxySelector();
+    private boolean useProxyProperties = defaultUseProxyProperties();
+    private boolean validateResponseHeaders = defaultValidateResponseHeaders();
+
+    // websocket
+    private boolean aggregateWebSocketFrameFragments = defaultAggregateWebSocketFrameFragments();
+    private boolean enablewebSocketCompression = defaultEnableWebSocketCompression();
+    private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
+    private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
+
+    // timeouts
+    private int connectTimeout = defaultConnectTimeout();
+    private int requestTimeout = defaultRequestTimeout();
+    private int readTimeout = defaultReadTimeout();
+    private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
+    private int shutdownTimeout = defaultShutdownTimeout();
+
+    // keep-alive
+    private boolean keepAlive = defaultKeepAlive();
+    private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+    private int connectionPoolCleanerPeriod = defaultConnectionPoolCleanerPeriod();
+    private int connectionTtl = defaultConnectionTtl();
+    private int maxConnections = defaultMaxConnections();
+    private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
+    private int acquireFreeChannelTimeout = defaultAcquireFreeChannelTimeout();
+    private ChannelPool channelPool;
+    private ConnectionSemaphoreFactory connectionSemaphoreFactory;
+    private KeepAliveStrategy keepAliveStrategy = new DefaultKeepAliveStrategy();
+
+    // ssl
+    private boolean useOpenSsl = defaultUseOpenSsl();
+    private boolean useInsecureTrustManager = defaultUseInsecureTrustManager();
+    private boolean disableHttpsEndpointIdentificationAlgorithm = defaultDisableHttpsEndpointIdentificationAlgorithm();
+    private int handshakeTimeout = defaultHandshakeTimeout();
+    private String[] enabledProtocols = defaultEnabledProtocols();
+    private String[] enabledCipherSuites = defaultEnabledCipherSuites();
+    private boolean filterInsecureCipherSuites = defaultFilterInsecureCipherSuites();
+    private int sslSessionCacheSize = defaultSslSessionCacheSize();
+    private int sslSessionTimeout = defaultSslSessionTimeout();
+    private SslContext sslContext;
+    private SslEngineFactory sslEngineFactory;
+
+    // cookie store
+    private CookieStore cookieStore = new ThreadSafeCookieStore();
+
+    // tuning
+    private boolean tcpNoDelay = defaultTcpNoDelay();
+    private boolean soReuseAddress = defaultSoReuseAddress();
+    private int soLinger = defaultSoLinger();
+    private int soSndBuf = defaultSoSndBuf();
+    private int soRcvBuf = defaultSoRcvBuf();
 
     // internals
-    private final String threadPoolName;
-    private final int httpClientCodecMaxInitialLineLength;
-    private final int httpClientCodecMaxHeaderSize;
-    private final int httpClientCodecMaxChunkSize;
-    private final int httpClientCodecInitialBufferSize;
-    private final int chunkedFileChunkSize;
-    private final int webSocketMaxBufferSize;
-    private final int webSocketMaxFrameSize;
-    private final Map<ChannelOption<Object>, Object> channelOptions;
-    private final EventLoopGroup eventLoopGroup;
-    private final boolean useNativeTransport;
-    private final ByteBufAllocator allocator;
-    private final boolean tcpNoDelay;
-    private final boolean soReuseAddress;
-    private final int soLinger;
-    private final int soSndBuf;
-    private final int soRcvBuf;
-    private final Timer nettyTimer;
-    private final ThreadFactory threadFactory;
-    private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
-    private final AdditionalChannelInitializer wsAdditionalChannelInitializer;
-    private final ResponseBodyPartFactory responseBodyPartFactory;
-    private final int ioThreadsCount;
-
-    private DefaultAsyncHttpClientConfig(//
-            // http
-            boolean followRedirect,//
-            int maxRedirects,//
-            boolean strict302Handling,//
-            boolean compressionEnforced,//
-            String userAgent,//
-            Realm realm,//
-            int maxRequestRetry,//
-            boolean disableUrlEncodingForBoundRequests,//
-            boolean useLaxCookieEncoder,//
-            boolean disableZeroCopy,//
-            boolean keepEncodingHeader,//
-            ProxyServerSelector proxyServerSelector,//
-            boolean validateResponseHeaders,//
-            boolean aggregateWebSocketFrameFragments,
-
-            // timeouts
-            int connectTimeout,//
-            int requestTimeout,//
-            int readTimeout,//
-            int shutdownQuietPeriod,//
-            int shutdownTimeout,//
-
-            // keep-alive
-            boolean keepAlive,//
-            int pooledConnectionIdleTimeout,//
-            int connectionPoolCleanerPeriod,//
-            int connectionTtl,//
-            int maxConnections,//
-            int maxConnectionsPerHost,//
-            ChannelPool channelPool,//
-            KeepAliveStrategy keepAliveStrategy,//
-
-            // ssl
-            boolean useOpenSsl,//
-            boolean useInsecureTrustManager,//
-            boolean disableHttpsEndpointIdentificationAlgorithm,//
-            int handshakeTimeout,//
-            String[] enabledProtocols,//
-            String[] enabledCipherSuites,//
-            int sslSessionCacheSize,//
-            int sslSessionTimeout,//
-            SslContext sslContext,//
-            SslEngineFactory sslEngineFactory,//
-
-            // filters
-            List<RequestFilter> requestFilters,//
-            List<ResponseFilter> responseFilters,//
-            List<IOExceptionFilter> ioExceptionFilters,//
-
-            // tuning
-            boolean tcpNoDelay,//
-            boolean soReuseAddress,//
-            int soLinger, //
-            int soSndBuf, //
-            int soRcvBuf, //
-
-            // internals
-            String threadPoolName,//
-            int httpClientCodecMaxInitialLineLength,//
-            int httpClientCodecMaxHeaderSize,//
-            int httpClientCodecMaxChunkSize,//
-            int httpClientCodecInitialBufferSize,//
-            int chunkedFileChunkSize,//
-            int webSocketMaxBufferSize,//
-            int webSocketMaxFrameSize,//
-            Map<ChannelOption<Object>, Object> channelOptions,//
-            EventLoopGroup eventLoopGroup,//
-            boolean useNativeTransport,//
-            ByteBufAllocator allocator,//
-            Timer nettyTimer,//
-            ThreadFactory threadFactory,//
-            AdditionalChannelInitializer httpAdditionalChannelInitializer,//
-            AdditionalChannelInitializer wsAdditionalChannelInitializer,//
-            ResponseBodyPartFactory responseBodyPartFactory,//
-            int ioThreadsCount) {
-
-        // http
-        this.followRedirect = followRedirect;
-        this.maxRedirects = maxRedirects;
-        this.strict302Handling = strict302Handling;
-        this.compressionEnforced = compressionEnforced;
-        this.userAgent = userAgent;
-        this.realm = realm;
-        this.maxRequestRetry = maxRequestRetry;
-        this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
-        this.useLaxCookieEncoder = useLaxCookieEncoder;
-        this.disableZeroCopy = disableZeroCopy;
-        this.keepEncodingHeader = keepEncodingHeader;
-        this.proxyServerSelector = proxyServerSelector;
-        this.validateResponseHeaders = validateResponseHeaders;
-        this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
-
-        // timeouts
-        this.connectTimeout = connectTimeout;
-        this.requestTimeout = requestTimeout;
-        this.readTimeout = readTimeout;
-        this.shutdownQuietPeriod = shutdownQuietPeriod;
-        this.shutdownTimeout = shutdownTimeout;
-
-        // keep-alive
-        this.keepAlive = keepAlive;
-        this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
-        this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
-        this.connectionTtl = connectionTtl;
-        this.maxConnections = maxConnections;
-        this.maxConnectionsPerHost = maxConnectionsPerHost;
-        this.channelPool = channelPool;
-        this.keepAliveStrategy = keepAliveStrategy;
-
-        // ssl
-        this.useOpenSsl = useOpenSsl;
-        this.useInsecureTrustManager = useInsecureTrustManager;
-        this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
-        this.handshakeTimeout = handshakeTimeout;
-        this.enabledProtocols = enabledProtocols;
-        this.enabledCipherSuites = enabledCipherSuites;
-        this.sslSessionCacheSize = sslSessionCacheSize;
-        this.sslSessionTimeout = sslSessionTimeout;
-        this.sslContext = sslContext;
-        this.sslEngineFactory = sslEngineFactory;
-
-        // filters
-        this.requestFilters = requestFilters;
-        this.responseFilters = responseFilters;
-        this.ioExceptionFilters = ioExceptionFilters;
-
-        // tuning
-        this.tcpNoDelay = tcpNoDelay;
-        this.soReuseAddress = soReuseAddress;
-        this.soLinger = soLinger;
-        this.soSndBuf = soSndBuf;
-        this.soRcvBuf = soRcvBuf;
-
-        // internals
-        this.threadPoolName = threadPoolName;
-        this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
-        this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
-        this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-        this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
-        this.chunkedFileChunkSize = chunkedFileChunkSize;
-        this.webSocketMaxBufferSize = webSocketMaxBufferSize;
-        this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-        this.channelOptions = channelOptions;
-        this.eventLoopGroup = eventLoopGroup;
-        this.useNativeTransport = useNativeTransport;
-        this.allocator = allocator;
-        this.nettyTimer = nettyTimer;
-        this.threadFactory = threadFactory;
-        this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
-        this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
-        this.responseBodyPartFactory = responseBodyPartFactory;
-        this.ioThreadsCount = ioThreadsCount;
-    }
-
-    @Override
-    public String getAhcVersion() {
-        return AHC_VERSION;
+    private String threadPoolName = defaultThreadPoolName();
+    private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
+    private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
+    private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
+    private int httpClientCodecInitialBufferSize = defaultHttpClientCodecInitialBufferSize();
+    private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
+    private boolean useNativeTransport = defaultUseNativeTransport();
+    private ByteBufAllocator allocator;
+    private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
+    private EventLoopGroup eventLoopGroup;
+    private Timer nettyTimer;
+    private ThreadFactory threadFactory;
+    private Consumer<Channel> httpAdditionalChannelInitializer;
+    private Consumer<Channel> wsAdditionalChannelInitializer;
+    private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
+    private int ioThreadsCount = defaultIoThreadsCount();
+
+    public Builder() {
+    }
+
+    public Builder(AsyncHttpClientConfig config) {
+      // http
+      followRedirect = config.isFollowRedirect();
+      maxRedirects = config.getMaxRedirects();
+      strict302Handling = config.isStrict302Handling();
+      compressionEnforced = config.isCompressionEnforced();
+      userAgent = config.getUserAgent();
+      realm = config.getRealm();
+      maxRequestRetry = config.getMaxRequestRetry();
+      disableUrlEncodingForBoundRequests = config.isDisableUrlEncodingForBoundRequests();
+      useLaxCookieEncoder = config.isUseLaxCookieEncoder();
+      disableZeroCopy = config.isDisableZeroCopy();
+      keepEncodingHeader = config.isKeepEncodingHeader();
+      proxyServerSelector = config.getProxyServerSelector();
+
+      // websocket
+      aggregateWebSocketFrameFragments = config.isAggregateWebSocketFrameFragments();
+      enablewebSocketCompression = config.isEnableWebSocketCompression();
+      webSocketMaxBufferSize = config.getWebSocketMaxBufferSize();
+      webSocketMaxFrameSize = config.getWebSocketMaxFrameSize();
+
+      // timeouts
+      connectTimeout = config.getConnectTimeout();
+      requestTimeout = config.getRequestTimeout();
+      readTimeout = config.getReadTimeout();
+      shutdownQuietPeriod = config.getShutdownQuietPeriod();
+      shutdownTimeout = config.getShutdownTimeout();
+
+      // keep-alive
+      keepAlive = config.isKeepAlive();
+      pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
+      connectionTtl = config.getConnectionTtl();
+      maxConnections = config.getMaxConnections();
+      maxConnectionsPerHost = config.getMaxConnectionsPerHost();
+      channelPool = config.getChannelPool();
+      connectionSemaphoreFactory = config.getConnectionSemaphoreFactory();
+      keepAliveStrategy = config.getKeepAliveStrategy();
+
+      // ssl
+      useInsecureTrustManager = config.isUseInsecureTrustManager();
+      handshakeTimeout = config.getHandshakeTimeout();
+      enabledProtocols = config.getEnabledProtocols();
+      enabledCipherSuites = config.getEnabledCipherSuites();
+      filterInsecureCipherSuites = config.isFilterInsecureCipherSuites();
+      sslSessionCacheSize = config.getSslSessionCacheSize();
+      sslSessionTimeout = config.getSslSessionTimeout();
+      sslContext = config.getSslContext();
+      sslEngineFactory = config.getSslEngineFactory();
+
+      // filters
+      requestFilters.addAll(config.getRequestFilters());
+      responseFilters.addAll(config.getResponseFilters());
+      ioExceptionFilters.addAll(config.getIoExceptionFilters());
+
+      // tuning
+      tcpNoDelay = config.isTcpNoDelay();
+      soReuseAddress = config.isSoReuseAddress();
+      soLinger = config.getSoLinger();
+      soSndBuf = config.getSoSndBuf();
+      soRcvBuf = config.getSoRcvBuf();
+
+      // internals
+      threadPoolName = config.getThreadPoolName();
+      httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
+      httpClientCodecMaxHeaderSize = config.getHttpClientCodecMaxHeaderSize();
+      httpClientCodecMaxChunkSize = config.getHttpClientCodecMaxChunkSize();
+      chunkedFileChunkSize = config.getChunkedFileChunkSize();
+      channelOptions.putAll(config.getChannelOptions());
+      eventLoopGroup = config.getEventLoopGroup();
+      useNativeTransport = config.isUseNativeTransport();
+      allocator = config.getAllocator();
+      nettyTimer = config.getNettyTimer();
+      threadFactory = config.getThreadFactory();
+      httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
+      wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
+      responseBodyPartFactory = config.getResponseBodyPartFactory();
+      ioThreadsCount = config.getIoThreadsCount();
     }
 
     // http
-    @Override
-    public boolean isFollowRedirect() {
-        return followRedirect;
+    public Builder setFollowRedirect(boolean followRedirect) {
+      this.followRedirect = followRedirect;
+      return this;
     }
 
-    @Override
-    public int getMaxRedirects() {
-        return maxRedirects;
+    public Builder setMaxRedirects(int maxRedirects) {
+      this.maxRedirects = maxRedirects;
+      return this;
     }
 
-    @Override
-    public boolean isStrict302Handling() {
-        return strict302Handling;
+    public Builder setStrict302Handling(final boolean strict302Handling) {
+      this.strict302Handling = strict302Handling;
+      return this;
     }
 
-    @Override
-    public boolean isCompressionEnforced() {
-        return compressionEnforced;
+    public Builder setCompressionEnforced(boolean compressionEnforced) {
+      this.compressionEnforced = compressionEnforced;
+      return this;
     }
 
-    @Override
-    public String getUserAgent() {
-        return userAgent;
+    public Builder setUserAgent(String userAgent) {
+      this.userAgent = userAgent;
+      return this;
     }
 
-    @Override
-    public Realm getRealm() {
-        return realm;
+    public Builder setRealm(Realm realm) {
+      this.realm = realm;
+      return this;
     }
 
-    @Override
-    public int getMaxRequestRetry() {
-        return maxRequestRetry;
+    public Builder setRealm(Realm.Builder realmBuilder) {
+      this.realm = realmBuilder.build();
+      return this;
     }
 
-    @Override
-    public boolean isDisableUrlEncodingForBoundRequests() {
-        return disableUrlEncodingForBoundRequests;
+    public Builder setMaxRequestRetry(int maxRequestRetry) {
+      this.maxRequestRetry = maxRequestRetry;
+      return this;
     }
 
-    @Override
-    public boolean isUseLaxCookieEncoder() {
-        return useLaxCookieEncoder;
+    public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
+      this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+      return this;
     }
 
-    @Override
-    public boolean isDisableZeroCopy() {
-        return disableZeroCopy;
+    public Builder setUseLaxCookieEncoder(boolean useLaxCookieEncoder) {
+      this.useLaxCookieEncoder = useLaxCookieEncoder;
+      return this;
     }
 
-    @Override
-    public boolean isKeepEncodingHeader() {
-        return keepEncodingHeader;
+    public Builder setDisableZeroCopy(boolean disableZeroCopy) {
+      this.disableZeroCopy = disableZeroCopy;
+      return this;
     }
 
-    @Override
-    public ProxyServerSelector getProxyServerSelector() {
-        return proxyServerSelector;
+    public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
+      this.keepEncodingHeader = keepEncodingHeader;
+      return this;
     }
 
-    // timeouts
+    public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
+      this.proxyServerSelector = proxyServerSelector;
+      return this;
+    }
+
+    public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
+      this.validateResponseHeaders = validateResponseHeaders;
+      return this;
+    }
 
-    @Override
-    public int getConnectTimeout() {
-        return connectTimeout;
+    public Builder setProxyServer(ProxyServer proxyServer) {
+      this.proxyServerSelector = uri -> proxyServer;
+      return this;
     }
 
-    @Override
-    public int getRequestTimeout() {
-        return requestTimeout;
+    public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+      return setProxyServer(proxyServerBuilder.build());
     }
 
-    @Override
-    public int getReadTimeout() {
-        return readTimeout;
+    public Builder setUseProxySelector(boolean useProxySelector) {
+      this.useProxySelector = useProxySelector;
+      return this;
     }
 
-    @Override
-    public int getShutdownQuietPeriod() {
-        return shutdownQuietPeriod;
+    public Builder setUseProxyProperties(boolean useProxyProperties) {
+      this.useProxyProperties = useProxyProperties;
+      return this;
     }
 
-    @Override
-    public int getShutdownTimeout() {
-        return shutdownTimeout;
+    // websocket
+    public Builder setAggregateWebSocketFrameFragments(boolean aggregateWebSocketFrameFragments) {
+      this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
+      return this;
+    }
+
+    public Builder setEnablewebSocketCompression(boolean enablewebSocketCompression) {
+      this.enablewebSocketCompression = enablewebSocketCompression;
+      return this;
+    }
+
+    public Builder setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
+      this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+      return this;
+    }
+
+    public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
+      this.webSocketMaxFrameSize = webSocketMaxFrameSize;
+      return this;
+    }
+
+    // timeouts
+    public Builder setConnectTimeout(int connectTimeout) {
+      this.connectTimeout = connectTimeout;
+      return this;
+    }
+
+    public Builder setRequestTimeout(int requestTimeout) {
+      this.requestTimeout = requestTimeout;
+      return this;
+    }
+
+    public Builder setReadTimeout(int readTimeout) {
+      this.readTimeout = readTimeout;
+      return this;
+    }
+
+    public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
+      this.shutdownQuietPeriod = shutdownQuietPeriod;
+      return this;
+    }
+
+    public Builder setShutdownTimeout(int shutdownTimeout) {
+      this.shutdownTimeout = shutdownTimeout;
+      return this;
     }
 
     // keep-alive
-    @Override
-    public boolean isKeepAlive() {
-        return keepAlive;
+    public Builder setKeepAlive(boolean keepAlive) {
+      this.keepAlive = keepAlive;
+      return this;
     }
 
-    @Override
-    public int getPooledConnectionIdleTimeout() {
-        return pooledConnectionIdleTimeout;
+    public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+      this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+      return this;
     }
 
-    @Override
-    public int getConnectionPoolCleanerPeriod() {
-        return connectionPoolCleanerPeriod;
+    public Builder setConnectionPoolCleanerPeriod(int connectionPoolCleanerPeriod) {
+      this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
+      return this;
     }
 
-    @Override
-    public int getConnectionTtl() {
-        return connectionTtl;
+    public Builder setConnectionTtl(int connectionTtl) {
+      this.connectionTtl = connectionTtl;
+      return this;
     }
 
-    @Override
-    public int getMaxConnections() {
-        return maxConnections;
+    public Builder setMaxConnections(int maxConnections) {
+      this.maxConnections = maxConnections;
+      return this;
     }
 
-    @Override
-    public int getMaxConnectionsPerHost() {
-        return maxConnectionsPerHost;
+    public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
+      this.maxConnectionsPerHost = maxConnectionsPerHost;
+      return this;
     }
 
-    @Override
-    public ChannelPool getChannelPool() {
-        return channelPool;
+    /**
+     * Sets the maximum duration in milliseconds to acquire a free channel to send a request
+     * @param acquireFreeChannelTimeout maximum duration in milliseconds to acquire a free channel to send a request
+     * @return the same builder instance
+     */
+    public Builder setAcquireFreeChannelTimeout(int acquireFreeChannelTimeout) {
+      this.acquireFreeChannelTimeout = acquireFreeChannelTimeout;
+      return this;
     }
 
-    @Override
-    public KeepAliveStrategy getKeepAliveStrategy() {
-        return keepAliveStrategy;
+    public Builder setChannelPool(ChannelPool channelPool) {
+      this.channelPool = channelPool;
+      return this;
     }
 
-    @Override
-    public boolean isValidateResponseHeaders() {
-        return validateResponseHeaders;
+    public Builder setConnectionSemaphoreFactory(ConnectionSemaphoreFactory connectionSemaphoreFactory) {
+      this.connectionSemaphoreFactory = connectionSemaphoreFactory;
+      return this;
     }
 
-    @Override
-    public boolean isAggregateWebSocketFrameFragments() {
-        return aggregateWebSocketFrameFragments;
+    public Builder setKeepAliveStrategy(KeepAliveStrategy keepAliveStrategy) {
+      this.keepAliveStrategy = keepAliveStrategy;
+      return this;
     }
 
     // ssl
-    @Override
-    public boolean isUseOpenSsl() {
-        return useOpenSsl;
+    public Builder setUseOpenSsl(boolean useOpenSsl) {
+      this.useOpenSsl = useOpenSsl;
+      return this;
+    }
+
+    public Builder setUseInsecureTrustManager(boolean useInsecureTrustManager) {
+      this.useInsecureTrustManager = useInsecureTrustManager;
+      return this;
     }
 
-    @Override
-    public boolean isUseInsecureTrustManager() {
-        return useInsecureTrustManager;
+    public Builder setDisableHttpsEndpointIdentificationAlgorithm(boolean disableHttpsEndpointIdentificationAlgorithm) {
+      this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
+      return this;
     }
 
-    @Override
-    public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
-        return disableHttpsEndpointIdentificationAlgorithm;
+    public Builder setHandshakeTimeout(int handshakeTimeout) {
+      this.handshakeTimeout = handshakeTimeout;
+      return this;
     }
 
-    @Override
-    public int getHandshakeTimeout() {
-        return handshakeTimeout;
+    public Builder setEnabledProtocols(String[] enabledProtocols) {
+      this.enabledProtocols = enabledProtocols;
+      return this;
     }
 
-    @Override
-    public String[] getEnabledProtocols() {
-        return enabledProtocols;
+    public Builder setEnabledCipherSuites(String[] enabledCipherSuites) {
+      this.enabledCipherSuites = enabledCipherSuites;
+      return this;
     }
 
-    @Override
-    public String[] getEnabledCipherSuites() {
-        return enabledCipherSuites;
+    public Builder setFilterInsecureCipherSuites(boolean filterInsecureCipherSuites) {
+      this.filterInsecureCipherSuites = filterInsecureCipherSuites;
+      return this;
     }
 
-    @Override
-    public int getSslSessionCacheSize() {
-        return sslSessionCacheSize;
+    public Builder setSslSessionCacheSize(Integer sslSessionCacheSize) {
+      this.sslSessionCacheSize = sslSessionCacheSize;
+      return this;
     }
 
-    @Override
-    public int getSslSessionTimeout() {
-        return sslSessionTimeout;
+    public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
+      this.sslSessionTimeout = sslSessionTimeout;
+      return this;
     }
 
-    @Override
-    public SslContext getSslContext() {
-        return sslContext;
+    public Builder setSslContext(final SslContext sslContext) {
+      this.sslContext = sslContext;
+      return this;
     }
 
-    @Override
-    public SslEngineFactory getSslEngineFactory() {
-        return sslEngineFactory;
+    public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+      this.sslEngineFactory = sslEngineFactory;
+      return this;
     }
 
     // filters
-    @Override
-    public List<RequestFilter> getRequestFilters() {
-        return requestFilters;
+    public Builder addRequestFilter(RequestFilter requestFilter) {
+      requestFilters.add(requestFilter);
+      return this;
     }
 
-    @Override
-    public List<ResponseFilter> getResponseFilters() {
-        return responseFilters;
+    public Builder removeRequestFilter(RequestFilter requestFilter) {
+      requestFilters.remove(requestFilter);
+      return this;
     }
 
-    @Override
-    public List<IOExceptionFilter> getIoExceptionFilters() {
-        return ioExceptionFilters;
+    public Builder addResponseFilter(ResponseFilter responseFilter) {
+      responseFilters.add(responseFilter);
+      return this;
     }
 
-    // tuning
-    @Override
-    public boolean isTcpNoDelay() {
-        return tcpNoDelay;
+    public Builder removeResponseFilter(ResponseFilter responseFilter) {
+      responseFilters.remove(responseFilter);
+      return this;
     }
 
-    @Override
-    public boolean isSoReuseAddress() {
-        return soReuseAddress;
+    public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+      ioExceptionFilters.add(ioExceptionFilter);
+      return this;
     }
 
-    @Override
-    public int getSoLinger() {
-        return soLinger;
+    public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+      ioExceptionFilters.remove(ioExceptionFilter);
+      return this;
     }
 
-    @Override
-    public int getSoSndBuf() {
-        return soSndBuf;
+    // cookie store
+    public Builder setCookieStore(CookieStore cookieStore) {
+      this.cookieStore = cookieStore;
+      return this;
     }
 
-    @Override
-    public int getSoRcvBuf() {
-        return soRcvBuf;
+    // tuning
+    public Builder setTcpNoDelay(boolean tcpNoDelay) {
+      this.tcpNoDelay = tcpNoDelay;
+      return this;
     }
 
-    // internals
-    @Override
-    public String getThreadPoolName() {
-        return threadPoolName;
+    public Builder setSoReuseAddress(boolean soReuseAddress) {
+      this.soReuseAddress = soReuseAddress;
+      return this;
     }
 
-    @Override
-    public int getHttpClientCodecMaxInitialLineLength() {
-        return httpClientCodecMaxInitialLineLength;
+    public Builder setSoLinger(int soLinger) {
+      this.soLinger = soLinger;
+      return this;
     }
 
-    @Override
-    public int getHttpClientCodecMaxHeaderSize() {
-        return httpClientCodecMaxHeaderSize;
+    public Builder setSoSndBuf(int soSndBuf) {
+      this.soSndBuf = soSndBuf;
+      return this;
     }
 
-    @Override
-    public int getHttpClientCodecMaxChunkSize() {
-        return httpClientCodecMaxChunkSize;
+    public Builder setSoRcvBuf(int soRcvBuf) {
+      this.soRcvBuf = soRcvBuf;
+      return this;
     }
 
-    @Override
-    public int getHttpClientCodecInitialBufferSize() {
-        return httpClientCodecInitialBufferSize;
+    // internals
+    public Builder setThreadPoolName(String threadPoolName) {
+      this.threadPoolName = threadPoolName;
+      return this;
     }
 
-    @Override
-    public int getChunkedFileChunkSize() {
-        return chunkedFileChunkSize;
+    public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
+      this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+      return this;
     }
 
-    @Override
-    public int getWebSocketMaxBufferSize() {
-        return webSocketMaxBufferSize;
+    public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
+      this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+      return this;
     }
 
-    @Override
-    public int getWebSocketMaxFrameSize() {
-        return webSocketMaxFrameSize;
+    public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
+      this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+      return this;
     }
 
-    @Override
-    public Map<ChannelOption<Object>, Object> getChannelOptions() {
-        return channelOptions;
+    public Builder setHttpClientCodecInitialBufferSize(int httpClientCodecInitialBufferSize) {
+      this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
+      return this;
     }
 
-    @Override
-    public EventLoopGroup getEventLoopGroup() {
-        return eventLoopGroup;
+    public Builder setChunkedFileChunkSize(int chunkedFileChunkSize) {
+      this.chunkedFileChunkSize = chunkedFileChunkSize;
+      return this;
     }
 
-    @Override
-    public boolean isUseNativeTransport() {
-        return useNativeTransport;
+    @SuppressWarnings("unchecked")
+    public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
+      channelOptions.put((ChannelOption<Object>) name, value);
+      return this;
     }
 
-    @Override
-    public ByteBufAllocator getAllocator() {
-        return allocator;
+    public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+      this.eventLoopGroup = eventLoopGroup;
+      return this;
     }
 
-    @Override
-    public Timer getNettyTimer() {
-        return nettyTimer;
+    public Builder setUseNativeTransport(boolean useNativeTransport) {
+      this.useNativeTransport = useNativeTransport;
+      return this;
     }
 
-    @Override
-    public ThreadFactory getThreadFactory() {
-        return threadFactory;
+    public Builder setAllocator(ByteBufAllocator allocator) {
+      this.allocator = allocator;
+      return this;
     }
 
-    @Override
-    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
-        return httpAdditionalChannelInitializer;
+    public Builder setNettyTimer(Timer nettyTimer) {
+      this.nettyTimer = nettyTimer;
+      return this;
     }
 
-    @Override
-    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
-        return wsAdditionalChannelInitializer;
+    public Builder setThreadFactory(ThreadFactory threadFactory) {
+      this.threadFactory = threadFactory;
+      return this;
     }
 
-    @Override
-    public ResponseBodyPartFactory getResponseBodyPartFactory() {
-        return responseBodyPartFactory;
+    public Builder setHttpAdditionalChannelInitializer(Consumer<Channel> httpAdditionalChannelInitializer) {
+      this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+      return this;
     }
 
-    @Override
-    public int getIoThreadsCount() {
-        return ioThreadsCount;
+    public Builder setWsAdditionalChannelInitializer(Consumer<Channel> wsAdditionalChannelInitializer) {
+      this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+      return this;
     }
 
-    /**
-     * Builder for an {@link AsyncHttpClient}
-     */
-    public static class Builder {
-
-        // http
-        private boolean followRedirect = defaultFollowRedirect();
-        private int maxRedirects = defaultMaxRedirects();
-        private boolean strict302Handling = defaultStrict302Handling();
-        private boolean compressionEnforced = defaultCompressionEnforced();
-        private String userAgent = defaultUserAgent();
-        private Realm realm;
-        private int maxRequestRetry = defaultMaxRequestRetry();
-        private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
-        private boolean useLaxCookieEncoder = defaultUseLaxCookieEncoder();
-        private boolean disableZeroCopy = defaultDisableZeroCopy();
-        private boolean keepEncodingHeader = defaultKeepEncodingHeader();
-        private ProxyServerSelector proxyServerSelector;
-        private boolean useProxySelector = defaultUseProxySelector();
-        private boolean useProxyProperties = defaultUseProxyProperties();
-        private boolean validateResponseHeaders = defaultValidateResponseHeaders();
-        private boolean aggregateWebSocketFrameFragments = defaultAggregateWebSocketFrameFragments();
-
-        // timeouts
-        private int connectTimeout = defaultConnectTimeout();
-        private int requestTimeout = defaultRequestTimeout();
-        private int readTimeout = defaultReadTimeout();
-        private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
-        private int shutdownTimeout = defaultShutdownTimeout();
-
-        // keep-alive
-        private boolean keepAlive = defaultKeepAlive();
-        private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
-        private int connectionPoolCleanerPeriod = defaultConnectionPoolCleanerPeriod();
-        private int connectionTtl = defaultConnectionTtl();
-        private int maxConnections = defaultMaxConnections();
-        private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
-        private ChannelPool channelPool;
-        private KeepAliveStrategy keepAliveStrategy = new DefaultKeepAliveStrategy();
-
-        // ssl
-        private boolean useOpenSsl = defaultUseOpenSsl();
-        private boolean useInsecureTrustManager = defaultUseInsecureTrustManager();
-        private boolean disableHttpsEndpointIdentificationAlgorithm = defaultDisableHttpsEndpointIdentificationAlgorithm();
-        private int handshakeTimeout = defaultHandshakeTimeout();
-        private String[] enabledProtocols = defaultEnabledProtocols();
-        private String[] enabledCipherSuites = defaultEnabledCipherSuites();
-        private int sslSessionCacheSize = defaultSslSessionCacheSize();
-        private int sslSessionTimeout = defaultSslSessionTimeout();
-        private SslContext sslContext;
-        private SslEngineFactory sslEngineFactory;
-
-        // filters
-        private final List<RequestFilter> requestFilters = new LinkedList<>();
-        private final List<ResponseFilter> responseFilters = new LinkedList<>();
-        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
-
-        // tuning
-        private boolean tcpNoDelay = defaultTcpNoDelay();
-        private boolean soReuseAddress = defaultSoReuseAddress();
-        private int soLinger = defaultSoLinger();
-        private int soSndBuf = defaultSoSndBuf();
-        private int soRcvBuf = defaultSoRcvBuf();
-
-        // internals
-        private String threadPoolName = defaultThreadPoolName();
-        private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
-        private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
-        private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
-        private int httpClientCodecInitialBufferSize = defaultHttpClientCodecInitialBufferSize();
-        private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
-        private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
-        private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
-        private boolean useNativeTransport = defaultUseNativeTransport();
-        private ByteBufAllocator allocator;
-        private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
-        private EventLoopGroup eventLoopGroup;
-        private Timer nettyTimer;
-        private ThreadFactory threadFactory;
-        private AdditionalChannelInitializer httpAdditionalChannelInitializer;
-        private AdditionalChannelInitializer wsAdditionalChannelInitializer;
-        private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
-        private int ioThreadsCount = defaultIoThreadsCount();
-
-        public Builder() {
-        }
-
-        public Builder(AsyncHttpClientConfig config) {
-            // http
-            followRedirect = config.isFollowRedirect();
-            maxRedirects = config.getMaxRedirects();
-            strict302Handling = config.isStrict302Handling();
-            compressionEnforced = config.isCompressionEnforced();
-            userAgent = config.getUserAgent();
-            realm = config.getRealm();
-            maxRequestRetry = config.getMaxRequestRetry();
-            disableUrlEncodingForBoundRequests = config.isDisableUrlEncodingForBoundRequests();
-            disableZeroCopy = config.isDisableZeroCopy();
-            keepEncodingHeader = config.isKeepEncodingHeader();
-            proxyServerSelector = config.getProxyServerSelector();
-
-            // timeouts
-            connectTimeout = config.getConnectTimeout();
-            requestTimeout = config.getRequestTimeout();
-            readTimeout = config.getReadTimeout();
-            shutdownQuietPeriod = config.getShutdownQuietPeriod();
-            shutdownTimeout = config.getShutdownTimeout();
-
-            // keep-alive
-            keepAlive = config.isKeepAlive();
-            pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
-            connectionTtl = config.getConnectionTtl();
-            maxConnections = config.getMaxConnections();
-            maxConnectionsPerHost = config.getMaxConnectionsPerHost();
-            channelPool = config.getChannelPool();
-            keepAliveStrategy = config.getKeepAliveStrategy();
-
-            // ssl
-            useInsecureTrustManager = config.isUseInsecureTrustManager();
-            handshakeTimeout = config.getHandshakeTimeout();
-            enabledProtocols = config.getEnabledProtocols();
-            enabledCipherSuites = config.getEnabledCipherSuites();
-            sslSessionCacheSize = config.getSslSessionCacheSize();
-            sslSessionTimeout = config.getSslSessionTimeout();
-            sslContext = config.getSslContext();
-            sslEngineFactory = config.getSslEngineFactory();
-
-            // filters
-            requestFilters.addAll(config.getRequestFilters());
-            responseFilters.addAll(config.getResponseFilters());
-            ioExceptionFilters.addAll(config.getIoExceptionFilters());
-
-            // tuning
-            tcpNoDelay = config.isTcpNoDelay();
-            soReuseAddress = config.isSoReuseAddress();
-            soLinger = config.getSoLinger();
-            soSndBuf = config.getSoSndBuf();
-            soRcvBuf = config.getSoRcvBuf();
-
-            // internals
-            threadPoolName = config.getThreadPoolName();
-            httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
-            httpClientCodecMaxHeaderSize = config.getHttpClientCodecMaxHeaderSize();
-            httpClientCodecMaxChunkSize = config.getHttpClientCodecMaxChunkSize();
-            chunkedFileChunkSize = config.getChunkedFileChunkSize();
-            webSocketMaxBufferSize = config.getWebSocketMaxBufferSize();
-            webSocketMaxFrameSize = config.getWebSocketMaxFrameSize();
-            channelOptions.putAll(config.getChannelOptions());
-            eventLoopGroup = config.getEventLoopGroup();
-            useNativeTransport = config.isUseNativeTransport();
-            allocator = config.getAllocator();
-            nettyTimer = config.getNettyTimer();
-            threadFactory = config.getThreadFactory();
-            httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
-            wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
-            responseBodyPartFactory = config.getResponseBodyPartFactory();
-            ioThreadsCount = config.getIoThreadsCount();
-        }
-
-        // http
-        public Builder setFollowRedirect(boolean followRedirect) {
-            this.followRedirect = followRedirect;
-            return this;
-        }
-
-        public Builder setMaxRedirects(int maxRedirects) {
-            this.maxRedirects = maxRedirects;
-            return this;
-        }
-
-        public Builder setStrict302Handling(final boolean strict302Handling) {
-            this.strict302Handling = strict302Handling;
-            return this;
-        }
-
-        public Builder setCompressionEnforced(boolean compressionEnforced) {
-            this.compressionEnforced = compressionEnforced;
-            return this;
-        }
-
-        public Builder setUserAgent(String userAgent) {
-            this.userAgent = userAgent;
-            return this;
-        }
-
-        public Builder setRealm(Realm realm) {
-            this.realm = realm;
-            return this;
-        }
-
-        public Builder setRealm(Realm.Builder realmBuilder) {
-            this.realm = realmBuilder.build();
-            return this;
-        }
-
-        public Builder setMaxRequestRetry(int maxRequestRetry) {
-            this.maxRequestRetry = maxRequestRetry;
-            return this;
-        }
-
-        public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
-            this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
-            return this;
-        }
-
-        public Builder setUseLaxCookieEncoder(boolean useLaxCookieEncoder) {
-            this.useLaxCookieEncoder = useLaxCookieEncoder;
-            return this;
-        }
-
-        public Builder setDisableZeroCopy(boolean disableZeroCopy) {
-            this.disableZeroCopy = disableZeroCopy;
-            return this;
-        }
-
-        public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
-            this.keepEncodingHeader = keepEncodingHeader;
-            return this;
-        }
-
-        public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
-            this.proxyServerSelector = proxyServerSelector;
-            return this;
-        }
-
-        public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
-            this.validateResponseHeaders = validateResponseHeaders;
-            return this;
-        }
-
-        public Builder setAggregateWebSocketFrameFragments(boolean aggregateWebSocketFrameFragments) {
-            this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
-            return this;
-        }
-
-        public Builder setProxyServer(ProxyServer proxyServer) {
-            this.proxyServerSelector = uri -> proxyServer;
-            return this;
-        }
-
-        public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-            return setProxyServer(proxyServerBuilder.build());
-        }
-
-        public Builder setUseProxySelector(boolean useProxySelector) {
-            this.useProxySelector = useProxySelector;
-            return this;
-        }
-
-        public Builder setUseProxyProperties(boolean useProxyProperties) {
-            this.useProxyProperties = useProxyProperties;
-            return this;
-        }
-
-        // timeouts
-        public Builder setConnectTimeout(int connectTimeout) {
-            this.connectTimeout = connectTimeout;
-            return this;
-        }
-
-        public Builder setRequestTimeout(int requestTimeout) {
-            this.requestTimeout = requestTimeout;
-            return this;
-        }
-
-        public Builder setReadTimeout(int readTimeout) {
-            this.readTimeout = readTimeout;
-            return this;
-        }
-
-        public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
-            this.shutdownQuietPeriod = shutdownQuietPeriod;
-            return this;
-        }
-
-        public Builder setShutdownTimeout(int shutdownTimeout) {
-            this.shutdownTimeout = shutdownTimeout;
-            return this;
-        }
-
-        // keep-alive
-        public Builder setKeepAlive(boolean keepAlive) {
-            this.keepAlive = keepAlive;
-            return this;
-        }
-
-        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
-            this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
-            return this;
-        }
-
-        public Builder setConnectionTtl(int connectionTtl) {
-            this.connectionTtl = connectionTtl;
-            return this;
-        }
-
-        public Builder setMaxConnections(int maxConnections) {
-            this.maxConnections = maxConnections;
-            return this;
-        }
-
-        public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
-            this.maxConnectionsPerHost = maxConnectionsPerHost;
-            return this;
-        }
-
-        public Builder setChannelPool(ChannelPool channelPool) {
-            this.channelPool = channelPool;
-            return this;
-        }
-
-        public Builder setKeepAliveStrategy(KeepAliveStrategy keepAliveStrategy) {
-            this.keepAliveStrategy = keepAliveStrategy;
-            return this;
-        }
-
-        // ssl
-        public Builder setUseOpenSsl(boolean useOpenSsl) {
-            this.useOpenSsl = useOpenSsl;
-            return this;
-        }
-
-        public Builder setUseInsecureTrustManager(boolean useInsecureTrustManager) {
-            this.useInsecureTrustManager = useInsecureTrustManager;
-            return this;
-        }
-
-        public Builder setDisableHttpsEndpointIdentificationAlgorithm(boolean disableHttpsEndpointIdentificationAlgorithm) {
-            this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
-            return this;
-        }
-
-        public Builder setHandshakeTimeout(int handshakeTimeout) {
-            this.handshakeTimeout = handshakeTimeout;
-            return this;
-        }
-
-        public Builder setEnabledProtocols(String[] enabledProtocols) {
-            this.enabledProtocols = enabledProtocols;
-            return this;
-        }
-
-        public Builder setEnabledCipherSuites(String[] enabledCipherSuites) {
-            this.enabledCipherSuites = enabledCipherSuites;
-            return this;
-        }
-
-        public Builder setSslSessionCacheSize(Integer sslSessionCacheSize) {
-            this.sslSessionCacheSize = sslSessionCacheSize;
-            return this;
-        }
-
-        public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
-            this.sslSessionTimeout = sslSessionTimeout;
-            return this;
-        }
-
-        public Builder setSslContext(final SslContext sslContext) {
-            this.sslContext = sslContext;
-            return this;
-        }
-
-        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
-            this.sslEngineFactory = sslEngineFactory;
-            return this;
-        }
-
-        // filters
-        public Builder addRequestFilter(RequestFilter requestFilter) {
-            requestFilters.add(requestFilter);
-            return this;
-        }
-
-        public Builder removeRequestFilter(RequestFilter requestFilter) {
-            requestFilters.remove(requestFilter);
-            return this;
-        }
-
-        public Builder addResponseFilter(ResponseFilter responseFilter) {
-            responseFilters.add(responseFilter);
-            return this;
-        }
-
-        public Builder removeResponseFilter(ResponseFilter responseFilter) {
-            responseFilters.remove(responseFilter);
-            return this;
-        }
-
-        public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-            ioExceptionFilters.add(ioExceptionFilter);
-            return this;
-        }
-
-        public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-            ioExceptionFilters.remove(ioExceptionFilter);
-            return this;
-        }
-
-        // tuning
-        public Builder setTcpNoDelay(boolean tcpNoDelay) {
-            this.tcpNoDelay = tcpNoDelay;
-            return this;
-        }
-
-        public Builder setSoReuseAddress(boolean soReuseAddress) {
-            this.soReuseAddress = soReuseAddress;
-            return this;
-        }
-
-        public Builder setSoLinger(int soLinger) {
-            this.soLinger = soLinger;
-            return this;
-        }
-
-        public Builder setSoSndBuf(int soSndBuf) {
-            this.soSndBuf = soSndBuf;
-            return this;
-        }
-
-        public Builder setSoRcvBuf(int soRcvBuf) {
-            this.soRcvBuf = soRcvBuf;
-            return this;
-        }
-
-        // internals
-        public Builder setThreadPoolName(String threadPoolName) {
-            this.threadPoolName = threadPoolName;
-            return this;
-        }
-
-        public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
-            this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
-            return this;
-        }
-
-        public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
-            this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
-            return this;
-        }
-
-        public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
-            this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-            return this;
-        }
-
-        public Builder setHttpClientCodecInitialBufferSize(int httpClientCodecInitialBufferSize) {
-            this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
-            return this;
-        }
-
-        public Builder setChunkedFileChunkSize(int chunkedFileChunkSize) {
-            this.chunkedFileChunkSize = chunkedFileChunkSize;
-            return this;
-        }
-
-        public Builder setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
-            this.webSocketMaxBufferSize = webSocketMaxBufferSize;
-            return this;
-        }
-
-        public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
-            this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-            return this;
-        }
-
-        @SuppressWarnings("unchecked")
-        public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
-            channelOptions.put((ChannelOption<Object>) name, value);
-            return this;
-        }
-
-        public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
-            this.eventLoopGroup = eventLoopGroup;
-            return this;
-        }
-
-        public Builder setUseNativeTransport(boolean useNativeTransport) {
-            this.useNativeTransport = useNativeTransport;
-            return this;
-        }
-
-        public Builder setAllocator(ByteBufAllocator allocator) {
-            this.allocator = allocator;
-            return this;
-        }
-
-        public Builder setNettyTimer(Timer nettyTimer) {
-            this.nettyTimer = nettyTimer;
-            return this;
-        }
-
-        public Builder setThreadFactory(ThreadFactory threadFactory) {
-            this.threadFactory = threadFactory;
-            return this;
-        }
-
-        public Builder setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
-            this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
-            return this;
-        }
-
-        public Builder setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
-            this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
-            return this;
-        }
-
-        public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
-            this.responseBodyPartFactory = responseBodyPartFactory;
-            return this;
-        }
-
-        public Builder setIoThreadsCount(int ioThreadsCount) {
-            this.ioThreadsCount = ioThreadsCount;
-            return this;
-        }
-
-        private ProxyServerSelector resolveProxyServerSelector() {
-            if (proxyServerSelector != null)
-                return proxyServerSelector;
-
-            if (useProxySelector)
-                return ProxyUtils.getJdkDefaultProxyServerSelector();
-
-            if (useProxyProperties)
-                return ProxyUtils.createProxyServerSelector(System.getProperties());
-
-            return ProxyServerSelector.NO_PROXY_SELECTOR;
-        }
-
-        public DefaultAsyncHttpClientConfig build() {
-
-            return new DefaultAsyncHttpClientConfig(//
-                    followRedirect, //
-                    maxRedirects, //
-                    strict302Handling, //
-                    compressionEnforced, //
-                    userAgent, //
-                    realm, //
-                    maxRequestRetry, //
-                    disableUrlEncodingForBoundRequests, //
-                    useLaxCookieEncoder, //
-                    disableZeroCopy, //
-                    keepEncodingHeader, //
-                    resolveProxyServerSelector(), //
-                    validateResponseHeaders, //
-                    aggregateWebSocketFrameFragments, //
-                    connectTimeout, //
-                    requestTimeout, //
-                    readTimeout, //
-                    shutdownQuietPeriod, //
-                    shutdownTimeout, //
-                    keepAlive, //
-                    pooledConnectionIdleTimeout, //
-                    connectionPoolCleanerPeriod, //
-                    connectionTtl, //
-                    maxConnections, //
-                    maxConnectionsPerHost, //
-                    channelPool, //
-                    keepAliveStrategy, //
-                    useOpenSsl, //
-                    useInsecureTrustManager, //
-                    disableHttpsEndpointIdentificationAlgorithm, //
-                    handshakeTimeout, //
-                    enabledProtocols, //
-                    enabledCipherSuites, //
-                    sslSessionCacheSize, //
-                    sslSessionTimeout, //
-                    sslContext, //
-                    sslEngineFactory, //
-                    requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters), //
-                    responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),//
-                    ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),//
-                    tcpNoDelay, //
-                    soReuseAddress, //
-                    soLinger, //
-                    soSndBuf, //
-                    soRcvBuf, //
-                    threadPoolName, //
-                    httpClientCodecMaxInitialLineLength, //
-                    httpClientCodecMaxHeaderSize, //
-                    httpClientCodecMaxChunkSize, //
-                    httpClientCodecInitialBufferSize, //
-                    chunkedFileChunkSize, //
-                    webSocketMaxBufferSize, //
-                    webSocketMaxFrameSize, //
-                    channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
-                    eventLoopGroup, //
-                    useNativeTransport, //
-                    allocator, //
-                    nettyTimer, //
-                    threadFactory, //
-                    httpAdditionalChannelInitializer, //
-                    wsAdditionalChannelInitializer, //
-                    responseBodyPartFactory, //
-                    ioThreadsCount);
-        }
+    public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
+      this.responseBodyPartFactory = responseBodyPartFactory;
+      return this;
+    }
+
+    public Builder setIoThreadsCount(int ioThreadsCount) {
+      this.ioThreadsCount = ioThreadsCount;
+      return this;
     }
+
+    private ProxyServerSelector resolveProxyServerSelector() {
+      if (proxyServerSelector != null)
+        return proxyServerSelector;
+
+      if (useProxySelector)
+        return ProxyUtils.getJdkDefaultProxyServerSelector();
+
+      if (useProxyProperties)
+        return ProxyUtils.createProxyServerSelector(System.getProperties());
+
+      return ProxyServerSelector.NO_PROXY_SELECTOR;
+    }
+
+    public DefaultAsyncHttpClientConfig build() {
+
+      return new DefaultAsyncHttpClientConfig(
+              followRedirect,
+              maxRedirects,
+              strict302Handling,
+              compressionEnforced,
+              userAgent,
+              realm,
+              maxRequestRetry,
+              disableUrlEncodingForBoundRequests,
+              useLaxCookieEncoder,
+              disableZeroCopy,
+              keepEncodingHeader,
+              resolveProxyServerSelector(),
+              validateResponseHeaders,
+              aggregateWebSocketFrameFragments,
+              enablewebSocketCompression,
+              connectTimeout,
+              requestTimeout,
+              readTimeout,
+              shutdownQuietPeriod,
+              shutdownTimeout,
+              keepAlive,
+              pooledConnectionIdleTimeout,
+              connectionPoolCleanerPeriod,
+              connectionTtl,
+              maxConnections,
+              maxConnectionsPerHost,
+              acquireFreeChannelTimeout,
+              channelPool,
+              connectionSemaphoreFactory,
+              keepAliveStrategy,
+              useOpenSsl,
+              useInsecureTrustManager,
+              disableHttpsEndpointIdentificationAlgorithm,
+              handshakeTimeout,
+              enabledProtocols,
+              enabledCipherSuites,
+              filterInsecureCipherSuites,
+              sslSessionCacheSize,
+              sslSessionTimeout,
+              sslContext,
+              sslEngineFactory,
+              requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters),
+              responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),
+              ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),
+              cookieStore,
+              tcpNoDelay,
+              soReuseAddress,
+              soLinger,
+              soSndBuf,
+              soRcvBuf,
+              threadPoolName,
+              httpClientCodecMaxInitialLineLength,
+              httpClientCodecMaxHeaderSize,
+              httpClientCodecMaxChunkSize,
+              httpClientCodecInitialBufferSize,
+              chunkedFileChunkSize,
+              webSocketMaxBufferSize,
+              webSocketMaxFrameSize,
+              channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),
+              eventLoopGroup,
+              useNativeTransport,
+              allocator,
+              nettyTimer,
+              threadFactory,
+              httpAdditionalChannelInitializer,
+              wsAdditionalChannelInitializer,
+              responseBodyPartFactory,
+              ioThreadsCount);
+    }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultRequest.java b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
index bbc854090..4cabb4179 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultRequest.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
@@ -13,10 +13,14 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.resolver.NameResolver;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.File;
 import java.io.InputStream;
@@ -28,267 +32,263 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.channel.ChannelPoolPartitioning;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 public class DefaultRequest implements Request {
 
-    private final String method;
-    private final Uri uri;
-    private final InetAddress address;
-    private final InetAddress localAddress;
-    private final HttpHeaders headers;
-    private final List<Cookie> cookies;
-    private final byte[] byteData;
-    private final List<byte[]> compositeByteData;
-    private final String stringData;
-    private final ByteBuffer byteBufferData;
-    private final InputStream streamData;
-    private final BodyGenerator bodyGenerator;
-    private final List<Param> formParams;
-    private final List<Part> bodyParts;
-    private final String virtualHost;
-    public final ProxyServer proxyServer;
-    private final Realm realm;
-    private final File file;
-    private final Boolean followRedirect;
-    private final int requestTimeout;
-    private final int readTimeout;
-    private final long rangeOffset;
-    private final Charset charset;
-    private final ChannelPoolPartitioning channelPoolPartitioning;
-    private final NameResolver<InetAddress> nameResolver;
-    // lazily loaded
-    private List<Param> queryParams;
-
-    public DefaultRequest(String method,//
-            Uri uri,//
-            InetAddress address,//
-            InetAddress localAddress,//
-            HttpHeaders headers,//
-            List<Cookie> cookies,//
-            byte[] byteData,//
-            List<byte[]> compositeByteData,//
-            String stringData,//
-            ByteBuffer byteBufferData,//
-            InputStream streamData,//
-            BodyGenerator bodyGenerator,//
-            List<Param> formParams,//
-            List<Part> bodyParts,//
-            String virtualHost,//
-            ProxyServer proxyServer,//
-            Realm realm,//
-            File file,//
-            Boolean followRedirect,//
-            int requestTimeout,//
-            int readTimeout,//
-            long rangeOffset,//
-            Charset charset,//
-            ChannelPoolPartitioning channelPoolPartitioning,//
-            NameResolver<InetAddress> nameResolver) {
-        this.method = method;
-        this.uri = uri;
-        this.address = address;
-        this.localAddress = localAddress;
-        this.headers = headers;
-        this.cookies = cookies;
-        this.byteData = byteData;
-        this.compositeByteData = compositeByteData;
-        this.stringData = stringData;
-        this.byteBufferData = byteBufferData;
-        this.streamData = streamData;
-        this.bodyGenerator = bodyGenerator;
-        this.formParams = formParams;
-        this.bodyParts = bodyParts;
-        this.virtualHost = virtualHost;
-        this.proxyServer = proxyServer;
-        this.realm = realm;
-        this.file = file;
-        this.followRedirect = followRedirect;
-        this.requestTimeout = requestTimeout;
-        this.readTimeout = readTimeout;
-        this.rangeOffset = rangeOffset;
-        this.charset = charset;
-        this.channelPoolPartitioning = channelPoolPartitioning;
-        this.nameResolver = nameResolver;
-    }
-
-    @Override
-    public String getUrl() {
-        return uri.toUrl();
-    }
-    
-    @Override
-    public String getMethod() {
-        return method;
-    }
-
-    @Override
-    public Uri getUri() {
-        return uri;
-    }
-
-    @Override
-    public InetAddress getAddress() {
-        return address;
-    }
-
-    @Override
-    public InetAddress getLocalAddress() {
-        return localAddress;
-    }
-
-    @Override
-    public HttpHeaders getHeaders() {
-        return headers;
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-        return cookies;
-    }
-
-    @Override
-    public byte[] getByteData() {
-        return byteData;
-    }
-
-    @Override
-    public List<byte[]> getCompositeByteData() {
-        return compositeByteData;
-    }
-
-    @Override
-    public String getStringData() {
-        return stringData;
-    }
-
-    @Override
-    public ByteBuffer getByteBufferData() {
-        return byteBufferData;
-    }
-
-    @Override
-    public InputStream getStreamData() {
-        return streamData;
-    }
-
-    @Override
-    public BodyGenerator getBodyGenerator() {
-        return bodyGenerator;
-    }
-
-    @Override
-    public List<Param> getFormParams() {
-        return formParams;
-    }
-
-    @Override
-    public List<Part> getBodyParts() {
-        return bodyParts;
-    }
-
-    @Override
-    public String getVirtualHost() {
-        return virtualHost;
-    }
-
-    @Override
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-
-    @Override
-    public Realm getRealm() {
-        return realm;
-    }
-
-    @Override
-    public File getFile() {
-        return file;
-    }
-
-    @Override
-    public Boolean getFollowRedirect() {
-        return followRedirect;
-    }
-
-    @Override
-    public int getRequestTimeout() {
-        return requestTimeout;
-    }
-
-    @Override
-    public int getReadTimeout() {
-        return readTimeout;
-    }
-
-    @Override
-    public long getRangeOffset() {
-        return rangeOffset;
-    }
-
-    @Override
-    public Charset getCharset() {
-        return charset;
-    }
-
-    @Override
-    public ChannelPoolPartitioning getChannelPoolPartitioning() {
-        return channelPoolPartitioning;
-    }
-
-    @Override
-    public NameResolver<InetAddress> getNameResolver() {
-        return nameResolver;
-    }
-
-    @Override
-    public List<Param> getQueryParams() {
-        if (queryParams == null)
-            // lazy load
-            if (isNonEmpty(uri.getQuery())) {
-                queryParams = new ArrayList<>(1);
-                for (String queryStringParam : uri.getQuery().split("&")) {
-                    int pos = queryStringParam.indexOf('=');
-                    if (pos <= 0)
-                        queryParams.add(new Param(queryStringParam, null));
-                    else
-                        queryParams.add(new Param(queryStringParam.substring(0, pos), queryStringParam.substring(pos + 1)));
-                }
-            } else
-                queryParams = Collections.emptyList();
-        return queryParams;
+  public final ProxyServer proxyServer;
+  private final String method;
+  private final Uri uri;
+  private final InetAddress address;
+  private final InetAddress localAddress;
+  private final HttpHeaders headers;
+  private final List<Cookie> cookies;
+  private final byte[] byteData;
+  private final List<byte[]> compositeByteData;
+  private final String stringData;
+  private final ByteBuffer byteBufferData;
+  private final InputStream streamData;
+  private final BodyGenerator bodyGenerator;
+  private final List<Param> formParams;
+  private final List<Part> bodyParts;
+  private final String virtualHost;
+  private final Realm realm;
+  private final File file;
+  private final Boolean followRedirect;
+  private final int requestTimeout;
+  private final int readTimeout;
+  private final long rangeOffset;
+  private final Charset charset;
+  private final ChannelPoolPartitioning channelPoolPartitioning;
+  private final NameResolver<InetAddress> nameResolver;
+  // lazily loaded
+  private List<Param> queryParams;
+
+  public DefaultRequest(String method,
+                        Uri uri,
+                        InetAddress address,
+                        InetAddress localAddress,
+                        HttpHeaders headers,
+                        List<Cookie> cookies,
+                        byte[] byteData,
+                        List<byte[]> compositeByteData,
+                        String stringData,
+                        ByteBuffer byteBufferData,
+                        InputStream streamData,
+                        BodyGenerator bodyGenerator,
+                        List<Param> formParams,
+                        List<Part> bodyParts,
+                        String virtualHost,
+                        ProxyServer proxyServer,
+                        Realm realm,
+                        File file,
+                        Boolean followRedirect,
+                        int requestTimeout,
+                        int readTimeout,
+                        long rangeOffset,
+                        Charset charset,
+                        ChannelPoolPartitioning channelPoolPartitioning,
+                        NameResolver<InetAddress> nameResolver) {
+    this.method = method;
+    this.uri = uri;
+    this.address = address;
+    this.localAddress = localAddress;
+    this.headers = headers;
+    this.cookies = cookies;
+    this.byteData = byteData;
+    this.compositeByteData = compositeByteData;
+    this.stringData = stringData;
+    this.byteBufferData = byteBufferData;
+    this.streamData = streamData;
+    this.bodyGenerator = bodyGenerator;
+    this.formParams = formParams;
+    this.bodyParts = bodyParts;
+    this.virtualHost = virtualHost;
+    this.proxyServer = proxyServer;
+    this.realm = realm;
+    this.file = file;
+    this.followRedirect = followRedirect;
+    this.requestTimeout = requestTimeout;
+    this.readTimeout = readTimeout;
+    this.rangeOffset = rangeOffset;
+    this.charset = charset;
+    this.channelPoolPartitioning = channelPoolPartitioning;
+    this.nameResolver = nameResolver;
+  }
+
+  @Override
+  public String getUrl() {
+    return uri.toUrl();
+  }
+
+  @Override
+  public String getMethod() {
+    return method;
+  }
+
+  @Override
+  public Uri getUri() {
+    return uri;
+  }
+
+  @Override
+  public InetAddress getAddress() {
+    return address;
+  }
+
+  @Override
+  public InetAddress getLocalAddress() {
+    return localAddress;
+  }
+
+  @Override
+  public HttpHeaders getHeaders() {
+    return headers;
+  }
+
+  @Override
+  public List<Cookie> getCookies() {
+    return cookies;
+  }
+
+  @Override
+  public byte[] getByteData() {
+    return byteData;
+  }
+
+  @Override
+  public List<byte[]> getCompositeByteData() {
+    return compositeByteData;
+  }
+
+  @Override
+  public String getStringData() {
+    return stringData;
+  }
+
+  @Override
+  public ByteBuffer getByteBufferData() {
+    return byteBufferData;
+  }
+
+  @Override
+  public InputStream getStreamData() {
+    return streamData;
+  }
+
+  @Override
+  public BodyGenerator getBodyGenerator() {
+    return bodyGenerator;
+  }
+
+  @Override
+  public List<Param> getFormParams() {
+    return formParams;
+  }
+
+  @Override
+  public List<Part> getBodyParts() {
+    return bodyParts;
+  }
+
+  @Override
+  public String getVirtualHost() {
+    return virtualHost;
+  }
+
+  @Override
+  public ProxyServer getProxyServer() {
+    return proxyServer;
+  }
+
+  @Override
+  public Realm getRealm() {
+    return realm;
+  }
+
+  @Override
+  public File getFile() {
+    return file;
+  }
+
+  @Override
+  public Boolean getFollowRedirect() {
+    return followRedirect;
+  }
+
+  @Override
+  public int getRequestTimeout() {
+    return requestTimeout;
+  }
+
+  @Override
+  public int getReadTimeout() {
+    return readTimeout;
+  }
+
+  @Override
+  public long getRangeOffset() {
+    return rangeOffset;
+  }
+
+  @Override
+  public Charset getCharset() {
+    return charset;
+  }
+
+  @Override
+  public ChannelPoolPartitioning getChannelPoolPartitioning() {
+    return channelPoolPartitioning;
+  }
+
+  @Override
+  public NameResolver<InetAddress> getNameResolver() {
+    return nameResolver;
+  }
+
+  @Override
+  public List<Param> getQueryParams() {
+    if (queryParams == null)
+      // lazy load
+      if (isNonEmpty(uri.getQuery())) {
+        queryParams = new ArrayList<>(1);
+        for (String queryStringParam : uri.getQuery().split("&")) {
+          int pos = queryStringParam.indexOf('=');
+          if (pos <= 0)
+            queryParams.add(new Param(queryStringParam, null));
+          else
+            queryParams.add(new Param(queryStringParam.substring(0, pos), queryStringParam.substring(pos + 1)));
+        }
+      } else
+        queryParams = Collections.emptyList();
+    return queryParams;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder(getUrl());
+
+    sb.append("\t");
+    sb.append(method);
+    sb.append("\theaders:");
+    if (!headers.isEmpty()) {
+      for (Map.Entry<String, String> header : headers) {
+        sb.append("\t");
+        sb.append(header.getKey());
+        sb.append(":");
+        sb.append(header.getValue());
+      }
     }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder(getUrl());
-
+    if (isNonEmpty(formParams)) {
+      sb.append("\tformParams:");
+      for (Param param : formParams) {
         sb.append("\t");
-        sb.append(method);
-        sb.append("\theaders:");
-        if (!headers.isEmpty()) {
-            for (Map.Entry<String, String> header : headers) {
-                sb.append("\t");
-                sb.append(header.getKey());
-                sb.append(":");
-                sb.append(header.getValue());
-            }
-        }
-        if (isNonEmpty(formParams)) {
-            sb.append("\tformParams:");
-            for (Param param : formParams) {
-                sb.append("\t");
-                sb.append(param.getName());
-                sb.append(":");
-                sb.append(param.getValue());
-            }
-        }
-
-        return sb.toString();
+        sb.append(param.getName());
+        sb.append(":");
+        sb.append(param.getValue());
+      }
     }
+
+    return sb.toString();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 4d3d9b4b1..cdb30ed16 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -13,109 +13,113 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.util.HttpConstants.Methods.*;
-
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.proxy.ProxyServer;
 
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+
 public final class Dsl {
 
-    // /////////// Client ////////////////
-    public static AsyncHttpClient asyncHttpClient() {
-        return new DefaultAsyncHttpClient();
-    }
-
-    public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {
-        return new DefaultAsyncHttpClient(configBuilder.build());
-    }
-
-    public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
-        return new DefaultAsyncHttpClient(config);
-    }
-
-    // /////////// Request ////////////////
-    public static RequestBuilder get(String url) {
-        return request(GET, url);
-    }
-
-    public static RequestBuilder put(String url) {
-        return request(PUT, url);
-    }
-
-    public static RequestBuilder post(String url) {
-        return request(POST, url);
-    }
-
-    public static RequestBuilder delete(String url) {
-        return request(DELETE, url);
-    }
-
-    public static RequestBuilder head(String url) {
-        return request(HEAD, url);
-    }
-
-    public static RequestBuilder options(String url) {
-        return request(OPTIONS, url);
-    }
-
-    public static RequestBuilder patch(String url) {
-        return request(PATCH, url);
-    }
-
-    public static RequestBuilder trace(String url) {
-        return request(TRACE, url);
-    }
-
-    public static RequestBuilder request(String method, String url) {
-        return new RequestBuilder(method).setUrl(url);
-    }
-
-    // /////////// ProxyServer ////////////////
-    public static ProxyServer.Builder proxyServer(String host, int port) {
-        return new ProxyServer.Builder(host, port);
-    }
-
-    // /////////// Config ////////////////
-    public static DefaultAsyncHttpClientConfig.Builder config() {
-        return new DefaultAsyncHttpClientConfig.Builder();
-    }
-
-    // /////////// Realm ////////////////
-    public static Realm.Builder realm(Realm prototype) {
-        return new Realm.Builder(prototype.getPrincipal(), prototype.getPassword())//
-                .setRealmName(prototype.getRealmName())//
-                .setAlgorithm(prototype.getAlgorithm())//
-                .setNc(prototype.getNc())//
-                .setNonce(prototype.getNonce())//
-                .setCharset(prototype.getCharset())//
-                .setOpaque(prototype.getOpaque())//
-                .setQop(prototype.getQop())//
-                .setScheme(prototype.getScheme())//
-                .setUri(prototype.getUri())//
-                .setUsePreemptiveAuth(prototype.isUsePreemptiveAuth())//
-                .setNtlmDomain(prototype.getNtlmDomain())//
-                .setNtlmHost(prototype.getNtlmHost())//
-                .setUseAbsoluteURI(prototype.isUseAbsoluteURI())//
-                .setOmitQuery(prototype.isOmitQuery());
-    }
-
-    public static Realm.Builder realm(AuthScheme scheme, String principal, String password) {
-        return new Realm.Builder(principal, password)//
-                .setScheme(scheme);
-    }
-
-    public static Realm.Builder basicAuthRealm(String principal, String password) {
-        return realm(AuthScheme.BASIC, principal, password);
-    }
-
-    public static Realm.Builder digestAuthRealm(String principal, String password) {
-        return realm(AuthScheme.DIGEST, principal, password);
-    }
-
-    public static Realm.Builder ntlmAuthRealm(String principal, String password) {
-        return realm(AuthScheme.NTLM, principal, password);
-    }
-
-    private Dsl() {
-    }
+  private Dsl() {
+  }
+
+  // /////////// Client ////////////////
+  public static AsyncHttpClient asyncHttpClient() {
+    return new DefaultAsyncHttpClient();
+  }
+
+  public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {
+    return new DefaultAsyncHttpClient(configBuilder.build());
+  }
+
+  public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
+    return new DefaultAsyncHttpClient(config);
+  }
+
+  // /////////// Request ////////////////
+  public static RequestBuilder get(String url) {
+    return request(GET, url);
+  }
+
+  public static RequestBuilder put(String url) {
+    return request(PUT, url);
+  }
+
+  public static RequestBuilder post(String url) {
+    return request(POST, url);
+  }
+
+  public static RequestBuilder delete(String url) {
+    return request(DELETE, url);
+  }
+
+  public static RequestBuilder head(String url) {
+    return request(HEAD, url);
+  }
+
+  public static RequestBuilder options(String url) {
+    return request(OPTIONS, url);
+  }
+
+  public static RequestBuilder patch(String url) {
+    return request(PATCH, url);
+  }
+
+  public static RequestBuilder trace(String url) {
+    return request(TRACE, url);
+  }
+
+  public static RequestBuilder request(String method, String url) {
+    return new RequestBuilder(method).setUrl(url);
+  }
+
+  // /////////// ProxyServer ////////////////
+  public static ProxyServer.Builder proxyServer(String host, int port) {
+    return new ProxyServer.Builder(host, port);
+  }
+
+  // /////////// Config ////////////////
+  public static DefaultAsyncHttpClientConfig.Builder config() {
+    return new DefaultAsyncHttpClientConfig.Builder();
+  }
+
+  // /////////// Realm ////////////////
+  public static Realm.Builder realm(Realm prototype) {
+    return new Realm.Builder(prototype.getPrincipal(), prototype.getPassword())
+            .setRealmName(prototype.getRealmName())
+            .setAlgorithm(prototype.getAlgorithm())
+            .setNc(prototype.getNc())
+            .setNonce(prototype.getNonce())
+            .setCharset(prototype.getCharset())
+            .setOpaque(prototype.getOpaque())
+            .setQop(prototype.getQop())
+            .setScheme(prototype.getScheme())
+            .setUri(prototype.getUri())
+            .setUsePreemptiveAuth(prototype.isUsePreemptiveAuth())
+            .setNtlmDomain(prototype.getNtlmDomain())
+            .setNtlmHost(prototype.getNtlmHost())
+            .setUseAbsoluteURI(prototype.isUseAbsoluteURI())
+            .setOmitQuery(prototype.isOmitQuery())
+            .setServicePrincipalName(prototype.getServicePrincipalName())
+            .setUseCanonicalHostname(prototype.isUseCanonicalHostname())
+            .setCustomLoginConfig(prototype.getCustomLoginConfig())
+            .setLoginContextName(prototype.getLoginContextName());
+  }
+
+  public static Realm.Builder realm(AuthScheme scheme, String principal, String password) {
+    return new Realm.Builder(principal, password)
+            .setScheme(scheme);
+  }
+
+  public static Realm.Builder basicAuthRealm(String principal, String password) {
+    return realm(AuthScheme.BASIC, principal, password);
+  }
+
+  public static Realm.Builder digestAuthRealm(String principal, String password) {
+    return realm(AuthScheme.DIGEST, principal, password);
+  }
+
+  public static Realm.Builder ntlmAuthRealm(String principal, String password) {
+    return realm(AuthScheme.NTLM, principal, password);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HostStats.java b/client/src/main/java/org/asynchttpclient/HostStats.java
index 87d927882..b5fea52f6 100644
--- a/client/src/main/java/org/asynchttpclient/HostStats.java
+++ b/client/src/main/java/org/asynchttpclient/HostStats.java
@@ -20,55 +20,55 @@
  */
 public class HostStats {
 
-    private final long activeConnectionCount;
-    private final long idleConnectionCount;
+  private final long activeConnectionCount;
+  private final long idleConnectionCount;
 
-    public HostStats(long activeConnectionCount,
-                     long idleConnectionCount) {
-        this.activeConnectionCount = activeConnectionCount;
-        this.idleConnectionCount = idleConnectionCount;
-    }
+  public HostStats(long activeConnectionCount,
+                   long idleConnectionCount) {
+    this.activeConnectionCount = activeConnectionCount;
+    this.idleConnectionCount = idleConnectionCount;
+  }
 
-    /**
-     * @return The sum of {@link #getHostActiveConnectionCount()} and {@link #getHostIdleConnectionCount()},
-     * a long representing the total number of connections to this host.
-     */
-    public long getHostConnectionCount() {
-        return activeConnectionCount + idleConnectionCount;
-    }
+  /**
+   * @return The sum of {@link #getHostActiveConnectionCount()} and {@link #getHostIdleConnectionCount()},
+   * a long representing the total number of connections to this host.
+   */
+  public long getHostConnectionCount() {
+    return activeConnectionCount + idleConnectionCount;
+  }
 
-    /**
-     * @return A long representing the number of active connections to the host.
-     */
-    public long getHostActiveConnectionCount() {
-        return activeConnectionCount;
-    }
+  /**
+   * @return A long representing the number of active connections to the host.
+   */
+  public long getHostActiveConnectionCount() {
+    return activeConnectionCount;
+  }
 
-    /**
-     * @return A long representing the number of idle connections in the connection pool.
-     */
-    public long getHostIdleConnectionCount() {
-        return idleConnectionCount;
-    }
+  /**
+   * @return A long representing the number of idle connections in the connection pool.
+   */
+  public long getHostIdleConnectionCount() {
+    return idleConnectionCount;
+  }
 
-    @Override
-    public String toString() {
-        return "There are " + getHostConnectionCount() +
-                " total connections, " + getHostActiveConnectionCount() +
-                " are active and " + getHostIdleConnectionCount() + " are idle.";
-    }
+  @Override
+  public String toString() {
+    return "There are " + getHostConnectionCount() +
+            " total connections, " + getHostActiveConnectionCount() +
+            " are active and " + getHostIdleConnectionCount() + " are idle.";
+  }
 
-    @Override
-    public boolean equals(final Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        final HostStats hostStats = (HostStats) o;
-        return activeConnectionCount == hostStats.activeConnectionCount &&
-                idleConnectionCount == hostStats.idleConnectionCount;
-    }
+  @Override
+  public boolean equals(final Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    final HostStats hostStats = (HostStats) o;
+    return activeConnectionCount == hostStats.activeConnectionCount &&
+            idleConnectionCount == hostStats.idleConnectionCount;
+  }
 
-    @Override
-    public int hashCode() {
-        return Objects.hash(activeConnectionCount, idleConnectionCount);
-    }
+  @Override
+  public int hashCode() {
+    return Objects.hash(activeConnectionCount, idleConnectionCount);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 38da320f6..053aa28ff 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -22,32 +22,32 @@
  */
 public abstract class HttpResponseBodyPart {
 
-    private final boolean last;
-
-    public HttpResponseBodyPart(boolean last) {
-        this.last = last;
-    }
-
-    /**
-     * @return length of this part in bytes
-     */
-    public abstract int length();
-
-    /**
-     * @return  the response body's part bytes received.
-     */
-    public abstract byte[] getBodyPartBytes();
-
-    /**
-     * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
-     * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
-     */
-    public abstract ByteBuffer getBodyByteBuffer();
-
-    /**
-     * @return true if this is the last part.
-     */
-    public boolean isLast() {
-        return last;
-    }
+  private final boolean last;
+
+  public HttpResponseBodyPart(boolean last) {
+    this.last = last;
+  }
+
+  /**
+   * @return length of this part in bytes
+   */
+  public abstract int length();
+
+  /**
+   * @return the response body's part bytes received.
+   */
+  public abstract byte[] getBodyPartBytes();
+
+  /**
+   * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
+   * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
+   */
+  public abstract ByteBuffer getBodyByteBuffer();
+
+  /**
+   * @return true if this is the last part.
+   */
+  public boolean isLast() {
+    return last;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index d0ef51439..7cdd41465 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -16,93 +16,93 @@
  */
 package org.asynchttpclient;
 
-import java.net.SocketAddress;
-
 import org.asynchttpclient.uri.Uri;
 
+import java.net.SocketAddress;
+
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
 public abstract class HttpResponseStatus {
 
-    private final Uri uri;
+  private final Uri uri;
 
-    public HttpResponseStatus(Uri uri) {
-        this.uri = uri;
-    }
+  public HttpResponseStatus(Uri uri) {
+    this.uri = uri;
+  }
 
-    /**
-     * Return the request {@link Uri}
-     * 
-     * @return the request {@link Uri}
-     */
-    public final Uri getUri() {
-        return uri;
-    }
+  /**
+   * Return the request {@link Uri}
+   *
+   * @return the request {@link Uri}
+   */
+  public Uri getUri() {
+    return uri;
+  }
 
-    /**
-     * Return the response status code
-     * 
-     * @return the response status code
-     */
-    public abstract int getStatusCode();
+  /**
+   * Return the response status code
+   *
+   * @return the response status code
+   */
+  public abstract int getStatusCode();
 
-    /**
-     * Return the response status text
-     * 
-     * @return the response status text
-     */
-    public abstract String getStatusText();
+  /**
+   * Return the response status text
+   *
+   * @return the response status text
+   */
+  public abstract String getStatusText();
 
-    /**
-     * Protocol name from status line.
-     * 
-     * @return Protocol name.
-     */
-    public abstract String getProtocolName();
+  /**
+   * Protocol name from status line.
+   *
+   * @return Protocol name.
+   */
+  public abstract String getProtocolName();
 
-    /**
-     * Protocol major version.
-     * 
-     * @return Major version.
-     */
-    public abstract int getProtocolMajorVersion();
+  /**
+   * Protocol major version.
+   *
+   * @return Major version.
+   */
+  public abstract int getProtocolMajorVersion();
 
-    /**
-     * Protocol minor version.
-     * 
-     * @return Minor version.
-     */
-    public abstract int getProtocolMinorVersion();
+  /**
+   * Protocol minor version.
+   *
+   * @return Minor version.
+   */
+  public abstract int getProtocolMinorVersion();
 
-    /**
-     * Full protocol name + version
-     * 
-     * @return protocol name + version
-     */
-    public abstract String getProtocolText();
+  /**
+   * Full protocol name + version
+   *
+   * @return protocol name + version
+   */
+  public abstract String getProtocolText();
 
-    /**
-     * Get remote address client initiated request to.
-     * 
-     * @return remote address client initiated request to, may be {@code null}
-     *         if asynchronous provider is unable to provide the remote address
-     */
-    public abstract SocketAddress getRemoteAddress();
+  /**
+   * Get remote address client initiated request to.
+   *
+   * @return remote address client initiated request to, may be {@code null}
+   * if asynchronous provider is unable to provide the remote address
+   */
+  public abstract SocketAddress getRemoteAddress();
 
-    /**
-     * Get local address client initiated request from.
-     * 
-     * @return local address client initiated request from, may be {@code null}
-     *         if asynchronous provider is unable to provide the local address
-     */
-    public abstract SocketAddress getLocalAddress();
+  /**
+   * Get local address client initiated request from.
+   *
+   * @return local address client initiated request from, may be {@code null}
+   * if asynchronous provider is unable to provide the local address
+   */
+  public abstract SocketAddress getLocalAddress();
 
-    /**
-     * Code followed by text.
-     */
-    @Override
-    public String toString() {
-        return getStatusCode() + " " + getStatusText();
-    }
+  /**
+   * Code followed by text.
+   */
+  @Override
+  public String toString() {
+    return getStatusCode() + " " + getStatusText();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ListenableFuture.java b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
index 46a0a261e..d63ebc52c 100755
--- a/client/src/main/java/org/asynchttpclient/ListenableFuture.java
+++ b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -30,12 +30,7 @@
  */
 package org.asynchttpclient;
 
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
+import java.util.concurrent.*;
 
 /**
  * Extended {@link Future}
@@ -44,109 +39,109 @@
  */
 public interface ListenableFuture<V> extends Future<V> {
 
-    /**
-     * Terminate and if there is no exception, mark this Future as done and release the internal lock.
-     */
-    void done();
-
-    /**
-     * Abort the current processing, and propagate the {@link Throwable} to the {@link AsyncHandler} or {@link Future}
-     *
-     * @param t the exception
-     */
-    void abort(Throwable t);
-
-    /**
-     * Touch the current instance to prevent external service to times out.
-     */
-    void touch();
-
-    /**
-     * Adds a listener and executor to the ListenableFuture.
-     * The listener will be {@linkplain java.util.concurrent.Executor#execute(Runnable) passed
-     * to the executor} for execution when the {@code Future}'s computation is
-     * {@linkplain Future#isDone() complete}.
-     * <br>
-     * Executor can be <code>null</code>, in that case executor will be executed
-     * in the thread where completion happens.
-     * <br>
-     * There is no guaranteed ordering of execution of listeners, they may get
-     * called in the order they were added and they may get called out of order,
-     * but any listener added through this method is guaranteed to be called once
-     * the computation is complete.
-     *
-     * @param listener the listener to run when the computation is complete.
-     * @param exec     the executor to run the listener in.
-     * @return this Future
-     */
-    ListenableFuture<V> addListener(Runnable listener, Executor exec);
-
-    CompletableFuture<V> toCompletableFuture();
-    
-    class CompletedFailure<T> implements ListenableFuture<T>{
-
-        private final ExecutionException e;
-
-        public CompletedFailure(Throwable t) {
-            e = new ExecutionException(t);
-        }
-
-        public CompletedFailure(String message, Throwable t) {
-            e = new ExecutionException(message, t);
-        }
-
-        @Override
-        public boolean cancel(boolean mayInterruptIfRunning) {
-            return true;
-        }
-
-        @Override
-        public boolean isCancelled() {
-            return false;
-        }
-
-        @Override
-        public boolean isDone() {
-            return true;
-        }
-
-        @Override
-        public T get() throws InterruptedException, ExecutionException {
-            throw e;
-        }
-
-        @Override
-        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-            throw e;
-        }
-
-        @Override
-        public void done() {
-        }
-
-        @Override
-        public void abort(Throwable t) {
-        }
-
-        @Override
-        public void touch() {
-        }
-
-        @Override
-        public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
-            if (exec != null) {
-                exec.execute(listener);
-            } else {
-                listener.run();
-            }
-            return this;
-        }
-        
-        @Override
-        public CompletableFuture<T> toCompletableFuture() {
-            CompletableFuture<T> future = new CompletableFuture<>();
-            future.completeExceptionally(e);
-            return future;
-        }
+  /**
+   * Terminate and if there is no exception, mark this Future as done and release the internal lock.
+   */
+  void done();
+
+  /**
+   * Abort the current processing, and propagate the {@link Throwable} to the {@link AsyncHandler} or {@link Future}
+   *
+   * @param t the exception
+   */
+  void abort(Throwable t);
+
+  /**
+   * Touch the current instance to prevent external service to times out.
+   */
+  void touch();
+
+  /**
+   * Adds a listener and executor to the ListenableFuture.
+   * The listener will be {@linkplain java.util.concurrent.Executor#execute(Runnable) passed
+   * to the executor} for execution when the {@code Future}'s computation is
+   * {@linkplain Future#isDone() complete}.
+   * <br>
+   * Executor can be <code>null</code>, in that case executor will be executed
+   * in the thread where completion happens.
+   * <br>
+   * There is no guaranteed ordering of execution of listeners, they may get
+   * called in the order they were added and they may get called out of order,
+   * but any listener added through this method is guaranteed to be called once
+   * the computation is complete.
+   *
+   * @param listener the listener to run when the computation is complete.
+   * @param exec     the executor to run the listener in.
+   * @return this Future
+   */
+  ListenableFuture<V> addListener(Runnable listener, Executor exec);
+
+  CompletableFuture<V> toCompletableFuture();
+
+  class CompletedFailure<T> implements ListenableFuture<T> {
+
+    private final ExecutionException e;
+
+    public CompletedFailure(Throwable t) {
+      e = new ExecutionException(t);
     }
+
+    public CompletedFailure(String message, Throwable t) {
+      e = new ExecutionException(message, t);
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      return true;
+    }
+
+    @Override
+    public boolean isCancelled() {
+      return false;
+    }
+
+    @Override
+    public boolean isDone() {
+      return true;
+    }
+
+    @Override
+    public T get() throws ExecutionException {
+      throw e;
+    }
+
+    @Override
+    public T get(long timeout, TimeUnit unit) throws ExecutionException {
+      throw e;
+    }
+
+    @Override
+    public void done() {
+    }
+
+    @Override
+    public void abort(Throwable t) {
+    }
+
+    @Override
+    public void touch() {
+    }
+
+    @Override
+    public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
+      if (exec != null) {
+        exec.execute(listener);
+      } else {
+        listener.run();
+      }
+      return this;
+    }
+
+    @Override
+    public CompletableFuture<T> toCompletableFuture() {
+      CompletableFuture<T> future = new CompletableFuture<>();
+      future.completeExceptionally(e);
+      return future;
+    }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Param.java b/client/src/main/java/org/asynchttpclient/Param.java
index e3ee12ce6..858c1158e 100644
--- a/client/src/main/java/org/asynchttpclient/Param.java
+++ b/client/src/main/java/org/asynchttpclient/Param.java
@@ -18,62 +18,66 @@
 
 /**
  * A pair of (name, value) String
+ *
  * @author slandelle
  */
 public class Param {
-    
-    public static List<Param> map2ParamList(Map<String, List<String>> map) {
-        if (map == null)
-            return null;
 
-        List<Param> params = new ArrayList<>(map.size());
-        for (Map.Entry<String, List<String>> entries : map.entrySet()) {
-            String name = entries.getKey();
-            for (String value : entries.getValue())
-                params.add(new Param(name, value));
-        }
-        return params;
-    }
+  private final String name;
+  private final String value;
 
-    private final String name;
-    private final String value;
-    public Param(String name, String value) {
-        this.name = name;
-        this.value = value;
-    }
-    public String getName() {
-        return name;
-    }
-    public String getValue() {
-        return value;
-    }
+  public Param(String name, String value) {
+    this.name = name;
+    this.value = value;
+  }
 
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((name == null) ? 0 : name.hashCode());
-        result = prime * result + ((value == null) ? 0 : value.hashCode());
-        return result;
-    }
+  public static List<Param> map2ParamList(Map<String, List<String>> map) {
+    if (map == null)
+      return null;
 
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (!(obj instanceof Param))
-            return false;
-        Param other = (Param) obj;
-        if (name == null) {
-            if (other.name != null)
-                return false;
-        } else if (!name.equals(other.name))
-            return false;
-        if (value == null) {
-            if (other.value != null)
-                return false;
-        } else if (!value.equals(other.value))
-            return false;
-        return true;
+    List<Param> params = new ArrayList<>(map.size());
+    for (Map.Entry<String, List<String>> entries : map.entrySet()) {
+      String name = entries.getKey();
+      for (String value : entries.getValue())
+        params.add(new Param(name, value));
     }
+    return params;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public String getValue() {
+    return value;
+  }
+
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((name == null) ? 0 : name.hashCode());
+    result = prime * result + ((value == null) ? 0 : value.hashCode());
+    return result;
+  }
+
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (obj == null)
+      return false;
+    if (!(obj instanceof Param))
+      return false;
+    Param other = (Param) obj;
+    if (name == null) {
+      if (other.name != null)
+        return false;
+    } else if (!name.equals(other.name))
+      return false;
+    if (value == null) {
+      if (other.value != null)
+        return false;
+    } else if (!value.equals(other.value))
+      return false;
+    return true;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 442922165..c6324fd0b 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -16,20 +16,22 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledMd5MessageDigest;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.StringUtils.*;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.StringBuilderPool;
+import org.asynchttpclient.util.StringUtils;
 
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
+import java.util.Map;
 import java.util.concurrent.ThreadLocalRandom;
 
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.util.StringBuilderPool;
-import org.asynchttpclient.util.StringUtils;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MessageDigestUtils.pooledMd5MessageDigest;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.StringUtils.appendBase16;
+import static org.asynchttpclient.util.StringUtils.toHexString;
 
 /**
  * This class is required when authentication is needed. The class support
@@ -37,470 +39,554 @@
  */
 public class Realm {
 
-	private static final String DEFAULT_NC = "00000001";
-	// MD5("")
-	private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
-
-	private final String principal;
-	private final String password;
-	private final AuthScheme scheme;
-	private final String realmName;
-	private final String nonce;
-	private final String algorithm;
-	private final String response;
-	private final String opaque;
-	private final String qop;
-	private final String nc;
-	private final String cnonce;
-	private final Uri uri;
-	private final boolean usePreemptiveAuth;
-	private final Charset charset;
-	private final String ntlmHost;
-	private final String ntlmDomain;
-	private final boolean useAbsoluteURI;
-	private final boolean omitQuery;
-
-	public enum AuthScheme {
-		BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
-	}
-
-	private Realm(AuthScheme scheme, //
-			String principal, //
-			String password, //
-			String realmName, //
-			String nonce, //
-			String algorithm, //
-			String response, //
-			String opaque, //
-			String qop, //
-			String nc, //
-			String cnonce, //
-			Uri uri, //
-			boolean usePreemptiveAuth, //
-			Charset charset, //
-			String ntlmDomain, //
-			String ntlmHost, //
-			boolean useAbsoluteURI, //
-			boolean omitQuery) {
-
-		this.scheme = assertNotNull(scheme, "scheme");
-		this.principal = assertNotNull(principal, "principal");
-		this.password = assertNotNull(password, "password");
-		this.realmName = realmName;
-		this.nonce = nonce;
-		this.algorithm = algorithm;
-		this.response = response;
-		this.opaque = opaque;
-		this.qop = qop;
-		this.nc = nc;
-		this.cnonce = cnonce;
-		this.uri = uri;
-		this.usePreemptiveAuth = usePreemptiveAuth;
-		this.charset = charset;
-		this.ntlmDomain = ntlmDomain;
-		this.ntlmHost = ntlmHost;
-		this.useAbsoluteURI = useAbsoluteURI;
-		this.omitQuery = omitQuery;
-	}
-
-	public String getPrincipal() {
-		return principal;
-	}
-
-	public String getPassword() {
-		return password;
-	}
-
-	public AuthScheme getScheme() {
-		return scheme;
-	}
-
-	public String getRealmName() {
-		return realmName;
-	}
-
-	public String getNonce() {
-		return nonce;
-	}
-
-	public String getAlgorithm() {
-		return algorithm;
-	}
-
-	public String getResponse() {
-		return response;
-	}
-
-	public String getOpaque() {
-		return opaque;
-	}
-
-	public String getQop() {
-		return qop;
-	}
-
-	public String getNc() {
-		return nc;
-	}
-
-	public String getCnonce() {
-		return cnonce;
-	}
-
-	public Uri getUri() {
-		return uri;
-	}
-
-	public Charset getCharset() {
-		return charset;
-	}
-
-	/**
-	 * Return true is preemptive authentication is enabled
-	 * 
-	 * @return true is preemptive authentication is enabled
-	 */
-	public boolean isUsePreemptiveAuth() {
-		return usePreemptiveAuth;
-	}
-
-	/**
-	 * Return the NTLM domain to use. This value should map the JDK
-	 * 
-	 * @return the NTLM domain
-	 */
-	public String getNtlmDomain() {
-		return ntlmDomain;
-	}
-
-	/**
-	 * Return the NTLM host.
-	 * 
-	 * @return the NTLM host
-	 */
-	public String getNtlmHost() {
-		return ntlmHost;
-	}
-
-	public boolean isUseAbsoluteURI() {
-		return useAbsoluteURI;
-	}
-
-	public boolean isOmitQuery() {
-		return omitQuery;
-	}
-
-	@Override
-	public String toString() {
-		return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\''
-				+ ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm + '\'' + ", response='" + response + '\''
-				+ ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
-				+ ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
-	}
-
-	/**
-	 * A builder for {@link Realm}
-	 */
-	public static class Builder {
-
-		private final String principal;
-		private final String password;
-		private AuthScheme scheme;
-		private String realmName;
-		private String nonce;
-		private String algorithm;
-		private String response;
-		private String opaque;
-		private String qop;
-		private String nc = DEFAULT_NC;
-		private String cnonce;
-		private Uri uri;
-		private String methodName = "GET";
-		private boolean usePreemptive;
-		private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
-		private Charset charset = UTF_8;
-		private String ntlmHost = "localhost";
-		private boolean useAbsoluteURI = false;
-		private boolean omitQuery;
-
-		public Builder(String principal, String password) {
-			this.principal = principal;
-			this.password = password;
-		}
-
-		public Builder setNtlmDomain(String ntlmDomain) {
-			this.ntlmDomain = ntlmDomain;
-			return this;
-		}
-
-		public Builder setNtlmHost(String host) {
-			this.ntlmHost = host;
-			return this;
-		}
-
-		public Builder setScheme(AuthScheme scheme) {
-			this.scheme = scheme;
-			return this;
-		}
-
-		public Builder setRealmName(String realmName) {
-			this.realmName = realmName;
-			return this;
-		}
-
-		public Builder setNonce(String nonce) {
-			this.nonce = nonce;
-			return this;
-		}
-
-		public Builder setAlgorithm(String algorithm) {
-			this.algorithm = algorithm;
-			return this;
-		}
-
-		public Builder setResponse(String response) {
-			this.response = response;
-			return this;
-		}
-
-		public Builder setOpaque(String opaque) {
-			this.opaque = opaque;
-			return this;
-		}
-
-		public Builder setQop(String qop) {
-			if (isNonEmpty(qop)) {
-				this.qop = qop;
-			}
-			return this;
-		}
-
-		public Builder setNc(String nc) {
-			this.nc = nc;
-			return this;
-		}
-
-		public Builder setUri(Uri uri) {
-			this.uri = uri;
-			return this;
-		}
-
-		public Builder setMethodName(String methodName) {
-			this.methodName = methodName;
-			return this;
-		}
-
-		public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
-			this.usePreemptive = usePreemptiveAuth;
-			return this;
-		}
-
-		public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
-			this.useAbsoluteURI = useAbsoluteURI;
-			return this;
-		}
-
-		public Builder setOmitQuery(boolean omitQuery) {
-			this.omitQuery = omitQuery;
-			return this;
-		}
-
-		public Builder setCharset(Charset charset) {
-			this.charset = charset;
-			return this;
-		}
-
-		private String parseRawQop(String rawQop) {
-			String[] rawServerSupportedQops = rawQop.split(",");
-			String[] serverSupportedQops = new String[rawServerSupportedQops.length];
-			for (int i = 0; i < rawServerSupportedQops.length; i++) {
-				serverSupportedQops[i] = rawServerSupportedQops[i].trim();
-			}
-
-			// prefer auth over auth-int
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth"))
-					return rawServerSupportedQop;
-			}
-
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth-int"))
-					return rawServerSupportedQop;
-			}
-
-			return null;
-		}
-
-		public Builder parseWWWAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-
-			// FIXME qop is different with proxy?
-			String rawQop = match(headerLine, "qop");
-			if (rawQop != null) {
-				setQop(parseRawQop(rawQop));
-			}
-
-			return this;
-		}
-
-		public Builder parseProxyAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-			// FIXME qop is different with proxy?
-			setQop(match(headerLine, "qop"));
-
-			return this;
-		}
-
-		private void newCnonce(MessageDigest md) {
-			byte[] b = new byte[8];
-			ThreadLocalRandom.current().nextBytes(b);
-			b = md.digest(b);
-			cnonce = toHexString(b);
-		}
-
-		/**
-		 * TODO: A Pattern/Matcher may be better.
-		 */
-		private String match(String headerLine, String token) {
-			if (headerLine == null) {
-				return null;
-			}
-
-			int match = headerLine.indexOf(token);
-			if (match <= 0)
-				return null;
-
-			// = to skip
-			match += token.length() + 1;
-			int trailingComa = headerLine.indexOf(",", match);
-			String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
-			value = value.length() > 0 && value.charAt(value.length() - 1) == '"'
-					? value.substring(0, value.length() - 1)
-					: value;
-			return value.charAt(0) == '"' ? value.substring(1) : value;
-		}
-
-		private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
-			md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
-			sb.setLength(0);
-			return md.digest();
-		}
-
-		private byte[] ha1(StringBuilder sb, MessageDigest md) {
-			// if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":"
-			// passwd
-			// if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":"
-			// passwd ) ":" nonce-value ":" cnonce-value
-
-			sb.append(principal).append(':').append(realmName).append(':').append(password);
-			byte[] core = md5FromRecycledStringBuilder(sb, md);
-
-			if (algorithm == null || algorithm.equals("MD5")) {
-				// A1 = username ":" realm-value ":" passwd
-				return core;
-			} else if ("MD5-sess".equals(algorithm)) {
-				// A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
-				appendBase16(sb, core);
-				sb.append(':').append(nonce).append(':').append(cnonce);
-				return md5FromRecycledStringBuilder(sb, md);
-			}
-
-			throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
-		}
-
-		private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
-
-			// if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
-			// if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
-			sb.append(methodName).append(':').append(digestUri);
-			if ("auth-int".equals(qop)) {
-				// when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
-				// but we don't have the request body here
-				// we would need a new API
-				sb.append(':').append(EMPTY_ENTITY_MD5);
-
-			} else if (qop != null && !qop.equals("auth")) {
-				throw new UnsupportedOperationException("Digest qop not supported: " + qop);
-			}
-
-			return md5FromRecycledStringBuilder(sb, md);
-		}
-
-		private void appendMiddlePart(StringBuilder sb) {
-			// request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
-			sb.append(':').append(nonce).append(':');
-			if ("auth".equals(qop) || "auth-int".equals(qop)) {
-				sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
-			}
-		}
-
-		private void newResponse(MessageDigest md) {
-			// when using preemptive auth, the request uri is missing
-			if (uri != null) {
-				// BEWARE: compute first as it uses the cached StringBuilder
-				String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
-
-				StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-
-				// WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
-				byte[] ha1 = ha1(sb, md);
-				byte[] ha2 = ha2(sb, digestUri, md);
-
-				appendBase16(sb, ha1);
-				appendMiddlePart(sb);
-				appendBase16(sb, ha2);
-
-				byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
-				response = toHexString(responseDigest);
-			}
-		}
-
-		/**
-		 * Build a {@link Realm}
-		 * 
-		 * @return a {@link Realm}
-		 */
-		public Realm build() {
-
-			// Avoid generating
-			if (isNonEmpty(nonce)) {
-				MessageDigest md = pooledMd5MessageDigest();
-				newCnonce(md);
-				newResponse(md);
-			}
-
-			return new Realm(scheme, //
-					principal, //
-					password, //
-					realmName, //
-					nonce, //
-					algorithm, //
-					response, //
-					opaque, //
-					qop, //
-					nc, //
-					cnonce, //
-					uri, //
-					usePreemptive, //
-					charset, //
-					ntlmDomain, //
-					ntlmHost, //
-					useAbsoluteURI, //
-					omitQuery);
-		}
-	}
+  private static final String DEFAULT_NC = "00000001";
+  // MD5("")
+  private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
+
+  private final String principal;
+  private final String password;
+  private final AuthScheme scheme;
+  private final String realmName;
+  private final String nonce;
+  private final String algorithm;
+  private final String response;
+  private final String opaque;
+  private final String qop;
+  private final String nc;
+  private final String cnonce;
+  private final Uri uri;
+  private final boolean usePreemptiveAuth;
+  private final Charset charset;
+  private final String ntlmHost;
+  private final String ntlmDomain;
+  private final boolean useAbsoluteURI;
+  private final boolean omitQuery;
+  private final Map<String, String> customLoginConfig;
+  private final String servicePrincipalName;
+  private final boolean useCanonicalHostname;
+  private final String loginContextName;
+
+  private Realm(AuthScheme scheme,
+                String principal,
+                String password,
+                String realmName,
+                String nonce,
+                String algorithm,
+                String response,
+                String opaque,
+                String qop,
+                String nc,
+                String cnonce,
+                Uri uri,
+                boolean usePreemptiveAuth,
+                Charset charset,
+                String ntlmDomain,
+                String ntlmHost,
+                boolean useAbsoluteURI,
+                boolean omitQuery,
+                String servicePrincipalName,
+                boolean useCanonicalHostname,
+                Map<String, String> customLoginConfig,
+                String loginContextName) {
+
+    this.scheme = assertNotNull(scheme, "scheme");
+    this.principal = principal;
+    this.password = password;
+    this.realmName = realmName;
+    this.nonce = nonce;
+    this.algorithm = algorithm;
+    this.response = response;
+    this.opaque = opaque;
+    this.qop = qop;
+    this.nc = nc;
+    this.cnonce = cnonce;
+    this.uri = uri;
+    this.usePreemptiveAuth = usePreemptiveAuth;
+    this.charset = charset;
+    this.ntlmDomain = ntlmDomain;
+    this.ntlmHost = ntlmHost;
+    this.useAbsoluteURI = useAbsoluteURI;
+    this.omitQuery = omitQuery;
+    this.servicePrincipalName = servicePrincipalName;
+    this.useCanonicalHostname = useCanonicalHostname;
+    this.customLoginConfig = customLoginConfig;
+    this.loginContextName = loginContextName;
+  }
+
+  public String getPrincipal() {
+    return principal;
+  }
+
+  public String getPassword() {
+    return password;
+  }
+
+  public AuthScheme getScheme() {
+    return scheme;
+  }
+
+  public String getRealmName() {
+    return realmName;
+  }
+
+  public String getNonce() {
+    return nonce;
+  }
+
+  public String getAlgorithm() {
+    return algorithm;
+  }
+
+  public String getResponse() {
+    return response;
+  }
+
+  public String getOpaque() {
+    return opaque;
+  }
+
+  public String getQop() {
+    return qop;
+  }
+
+  public String getNc() {
+    return nc;
+  }
+
+  public String getCnonce() {
+    return cnonce;
+  }
+
+  public Uri getUri() {
+    return uri;
+  }
+
+  public Charset getCharset() {
+    return charset;
+  }
+
+  /**
+   * Return true is preemptive authentication is enabled
+   *
+   * @return true is preemptive authentication is enabled
+   */
+  public boolean isUsePreemptiveAuth() {
+    return usePreemptiveAuth;
+  }
+
+  /**
+   * Return the NTLM domain to use. This value should map the JDK
+   *
+   * @return the NTLM domain
+   */
+  public String getNtlmDomain() {
+    return ntlmDomain;
+  }
+
+  /**
+   * Return the NTLM host.
+   *
+   * @return the NTLM host
+   */
+  public String getNtlmHost() {
+    return ntlmHost;
+  }
+
+  public boolean isUseAbsoluteURI() {
+    return useAbsoluteURI;
+  }
+
+  public boolean isOmitQuery() {
+    return omitQuery;
+  }
+
+  public Map<String, String> getCustomLoginConfig() {
+    return customLoginConfig;
+  }
+
+  public String getServicePrincipalName() {
+    return servicePrincipalName;
+  }
+
+  public boolean isUseCanonicalHostname() {
+    return useCanonicalHostname;
+  }
+
+  public String getLoginContextName() {
+    return loginContextName;
+  }
+
+  @Override
+  public String toString() {
+    return "Realm{" +
+        "principal='" + principal + '\'' +
+        ", password='" + password + '\'' +
+        ", scheme=" + scheme +
+        ", realmName='" + realmName + '\'' +
+        ", nonce='" + nonce + '\'' +
+        ", algorithm='" + algorithm + '\'' +
+        ", response='" + response + '\'' +
+        ", opaque='" + opaque + '\'' +
+        ", qop='" + qop + '\'' +
+        ", nc='" + nc + '\'' +
+        ", cnonce='" + cnonce + '\'' +
+        ", uri=" + uri +
+        ", usePreemptiveAuth=" + usePreemptiveAuth +
+        ", charset=" + charset +
+        ", ntlmHost='" + ntlmHost + '\'' +
+        ", ntlmDomain='" + ntlmDomain + '\'' +
+        ", useAbsoluteURI=" + useAbsoluteURI +
+        ", omitQuery=" + omitQuery +
+        ", customLoginConfig=" + customLoginConfig +
+        ", servicePrincipalName='" + servicePrincipalName + '\'' +
+        ", useCanonicalHostname=" + useCanonicalHostname +
+        ", loginContextName='" + loginContextName + '\'' +
+        '}';
+  }
+
+  public enum AuthScheme {
+    BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
+  }
+
+  /**
+   * A builder for {@link Realm}
+   */
+  public static class Builder {
+
+    private final String principal;
+    private final String password;
+    private AuthScheme scheme;
+    private String realmName;
+    private String nonce;
+    private String algorithm;
+    private String response;
+    private String opaque;
+    private String qop;
+    private String nc = DEFAULT_NC;
+    private String cnonce;
+    private Uri uri;
+    private String methodName = "GET";
+    private boolean usePreemptive;
+    private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
+    private Charset charset = UTF_8;
+    private String ntlmHost = "localhost";
+    private boolean useAbsoluteURI = false;
+    private boolean omitQuery;
+    /**
+     * Kerberos/Spnego properties
+     */
+    private Map<String, String> customLoginConfig;
+    private String servicePrincipalName;
+    private boolean useCanonicalHostname;
+    private String loginContextName;
+
+    public Builder() {
+      this.principal = null;
+      this.password = null;
+    }
+
+    public Builder(String principal, String password) {
+      this.principal = principal;
+      this.password = password;
+    }
+
+    public Builder setNtlmDomain(String ntlmDomain) {
+      this.ntlmDomain = ntlmDomain;
+      return this;
+    }
+
+    public Builder setNtlmHost(String host) {
+      this.ntlmHost = host;
+      return this;
+    }
+
+    public Builder setScheme(AuthScheme scheme) {
+      this.scheme = scheme;
+      return this;
+    }
+
+    public Builder setRealmName(String realmName) {
+      this.realmName = realmName;
+      return this;
+    }
+
+    public Builder setNonce(String nonce) {
+      this.nonce = nonce;
+      return this;
+    }
+
+    public Builder setAlgorithm(String algorithm) {
+      this.algorithm = algorithm;
+      return this;
+    }
+
+    public Builder setResponse(String response) {
+      this.response = response;
+      return this;
+    }
+
+    public Builder setOpaque(String opaque) {
+      this.opaque = opaque;
+      return this;
+    }
+
+    public Builder setQop(String qop) {
+      if (isNonEmpty(qop)) {
+        this.qop = qop;
+      }
+      return this;
+    }
+
+    public Builder setNc(String nc) {
+      this.nc = nc;
+      return this;
+    }
+
+    public Builder setUri(Uri uri) {
+      this.uri = uri;
+      return this;
+    }
+
+    public Builder setMethodName(String methodName) {
+      this.methodName = methodName;
+      return this;
+    }
+
+    public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
+      this.usePreemptive = usePreemptiveAuth;
+      return this;
+    }
+
+    public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
+      this.useAbsoluteURI = useAbsoluteURI;
+      return this;
+    }
+
+    public Builder setOmitQuery(boolean omitQuery) {
+      this.omitQuery = omitQuery;
+      return this;
+    }
+
+    public Builder setCharset(Charset charset) {
+      this.charset = charset;
+      return this;
+    }
+
+    public Builder setCustomLoginConfig(Map<String, String> customLoginConfig) {
+      this.customLoginConfig = customLoginConfig;
+      return this;
+    }
+
+    public Builder setServicePrincipalName(String servicePrincipalName) {
+      this.servicePrincipalName = servicePrincipalName;
+      return this;
+    }
+
+    public Builder setUseCanonicalHostname(boolean useCanonicalHostname) {
+      this.useCanonicalHostname = useCanonicalHostname;
+      return this;
+    }
+
+    public Builder setLoginContextName(String loginContextName) {
+      this.loginContextName = loginContextName;
+      return this;
+    }
+
+    private String parseRawQop(String rawQop) {
+      String[] rawServerSupportedQops = rawQop.split(",");
+      String[] serverSupportedQops = new String[rawServerSupportedQops.length];
+      for (int i = 0; i < rawServerSupportedQops.length; i++) {
+        serverSupportedQops[i] = rawServerSupportedQops[i].trim();
+      }
+
+      // prefer auth over auth-int
+      for (String rawServerSupportedQop : serverSupportedQops) {
+        if (rawServerSupportedQop.equals("auth"))
+          return rawServerSupportedQop;
+      }
+
+      for (String rawServerSupportedQop : serverSupportedQops) {
+        if (rawServerSupportedQop.equals("auth-int"))
+          return rawServerSupportedQop;
+      }
+
+      return null;
+    }
+
+    public Builder parseWWWAuthenticateHeader(String headerLine) {
+      setRealmName(match(headerLine, "realm"))
+              .setNonce(match(headerLine, "nonce"))
+              .setOpaque(match(headerLine, "opaque"))
+              .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+      String algorithm = match(headerLine, "algorithm");
+      if (isNonEmpty(algorithm)) {
+        setAlgorithm(algorithm);
+      }
+
+      // FIXME qop is different with proxy?
+      String rawQop = match(headerLine, "qop");
+      if (rawQop != null) {
+        setQop(parseRawQop(rawQop));
+      }
+
+      return this;
+    }
+
+    public Builder parseProxyAuthenticateHeader(String headerLine) {
+      setRealmName(match(headerLine, "realm"))
+              .setNonce(match(headerLine, "nonce"))
+              .setOpaque(match(headerLine, "opaque"))
+              .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+      String algorithm = match(headerLine, "algorithm");
+      if (isNonEmpty(algorithm)) {
+        setAlgorithm(algorithm);
+      }
+      // FIXME qop is different with proxy?
+      setQop(match(headerLine, "qop"));
+
+      return this;
+    }
+
+    private void newCnonce(MessageDigest md) {
+      byte[] b = new byte[8];
+      ThreadLocalRandom.current().nextBytes(b);
+      b = md.digest(b);
+      cnonce = toHexString(b);
+    }
+
+    /**
+     * TODO: A Pattern/Matcher may be better.
+     */
+    private String match(String headerLine, String token) {
+      if (headerLine == null) {
+        return null;
+      }
+
+      int match = headerLine.indexOf(token);
+      if (match <= 0)
+        return null;
+
+      // = to skip
+      match += token.length() + 1;
+      int trailingComa = headerLine.indexOf(",", match);
+      String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
+      value = value.length() > 0 && value.charAt(value.length() - 1) == '"'
+              ? value.substring(0, value.length() - 1)
+              : value;
+      return value.charAt(0) == '"' ? value.substring(1) : value;
+    }
+
+    private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
+      md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
+      sb.setLength(0);
+      return md.digest();
+    }
+
+    private byte[] ha1(StringBuilder sb, MessageDigest md) {
+      // if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":"
+      // passwd
+      // if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":"
+      // passwd ) ":" nonce-value ":" cnonce-value
+
+      sb.append(principal).append(':').append(realmName).append(':').append(password);
+      byte[] core = md5FromRecycledStringBuilder(sb, md);
+
+      if (algorithm == null || algorithm.equals("MD5")) {
+        // A1 = username ":" realm-value ":" passwd
+        return core;
+      } else if ("MD5-sess".equals(algorithm)) {
+        // A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
+        appendBase16(sb, core);
+        sb.append(':').append(nonce).append(':').append(cnonce);
+        return md5FromRecycledStringBuilder(sb, md);
+      }
+
+      throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+    }
+
+    private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
+
+      // if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
+      // if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
+      sb.append(methodName).append(':').append(digestUri);
+      if ("auth-int".equals(qop)) {
+        // when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
+        // but we don't have the request body here
+        // we would need a new API
+        sb.append(':').append(EMPTY_ENTITY_MD5);
+
+      } else if (qop != null && !qop.equals("auth")) {
+        throw new UnsupportedOperationException("Digest qop not supported: " + qop);
+      }
+
+      return md5FromRecycledStringBuilder(sb, md);
+    }
+
+    private void appendMiddlePart(StringBuilder sb) {
+      // request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
+      sb.append(':').append(nonce).append(':');
+      if ("auth".equals(qop) || "auth-int".equals(qop)) {
+        sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
+      }
+    }
+
+    private void newResponse(MessageDigest md) {
+      // when using preemptive auth, the request uri is missing
+      if (uri != null) {
+        // BEWARE: compute first as it uses the cached StringBuilder
+        String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
+
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+
+        // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
+        byte[] ha1 = ha1(sb, md);
+        byte[] ha2 = ha2(sb, digestUri, md);
+
+        appendBase16(sb, ha1);
+        appendMiddlePart(sb);
+        appendBase16(sb, ha2);
+
+        byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
+        response = toHexString(responseDigest);
+      }
+    }
+
+    /**
+     * Build a {@link Realm}
+     *
+     * @return a {@link Realm}
+     */
+    public Realm build() {
+
+      // Avoid generating
+      if (isNonEmpty(nonce)) {
+        MessageDigest md = pooledMd5MessageDigest();
+        newCnonce(md);
+        newResponse(md);
+      }
+
+      return new Realm(scheme,
+              principal,
+              password,
+              realmName,
+              nonce,
+              algorithm,
+              response,
+              opaque,
+              qop,
+              nc,
+              cnonce,
+              uri,
+              usePreemptive,
+              charset,
+              ntlmDomain,
+              ntlmHost,
+              useAbsoluteURI,
+              omitQuery,
+              servicePrincipalName,
+              useCanonicalHostname,
+              customLoginConfig,
+              loginContextName);
+    }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Request.java b/client/src/main/java/org/asynchttpclient/Request.java
index 9aab60469..0bcf3ae71 100644
--- a/client/src/main/java/org/asynchttpclient/Request.java
+++ b/client/src/main/java/org/asynchttpclient/Request.java
@@ -19,6 +19,11 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.resolver.NameResolver;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.File;
 import java.io.InputStream;
@@ -27,12 +32,6 @@
 import java.nio.charset.Charset;
 import java.util.List;
 
-import org.asynchttpclient.channel.ChannelPoolPartitioning;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
-
 /**
  * The Request class can be used to construct HTTP request:
  * <blockquote><pre>
@@ -47,139 +46,138 @@
  */
 public interface Request {
 
-    /**
-     * @return the request's HTTP method (GET, POST, etc.)
-     */
-    String getMethod();
-
-    /**
-     * 
-     * @return the uri
-     */
-    Uri getUri();
-
-    /**
-     * @return the url (the uri's String form)
-     */
-    String getUrl();
-
-    /**
-     * @return the InetAddress to be used to bypass uri's hostname resolution
-     */
-    InetAddress getAddress();
-
-    /**
-     * @return the local address to bind from
-     */
-    InetAddress getLocalAddress();
-
-    /**
-     * @return the HTTP headers
-     */
-    HttpHeaders getHeaders();
-
-    /**
-     * @return the HTTP cookies
-     */
-    List<Cookie> getCookies();
-
-    /**
-     * @return the request's body byte array (only non null if it was set this way)
-     */
-    byte[] getByteData();
-
-    /**
-     * @return the request's body array of byte arrays (only non null if it was set this way)
-     */
-    List<byte[]> getCompositeByteData();
-    
-    /**
-     * @return the request's body string (only non null if it was set this way)
-     */
-    String getStringData();
-
-    /**
-     * @return the request's body ByteBuffer (only non null if it was set this way)
-     */
-    ByteBuffer getByteBufferData();
-
-    /**
-     * @return the request's body InputStream (only non null if it was set this way)
-     */
-    InputStream getStreamData();
-
-    /**
-     * @return the request's body BodyGenerator (only non null if it was set this way)
-     */
-    BodyGenerator getBodyGenerator();
-
-    /**
-     * @return the request's form parameters
-     */
-    List<Param> getFormParams();
-
-    /**
-     * @return the multipart parts
-     */
-    List<Part> getBodyParts();
-
-    /**
-     * @return the virtual host to connect to
-     */
-    String getVirtualHost();
-
-    /**
-     * @return the query params resolved from the url/uri
-     */
-    List<Param> getQueryParams();
-
-    /**
-     * @return the proxy server to be used to perform this request (overrides the one defined in config)
-     */
-    ProxyServer getProxyServer();
-
-    /**
-     * @return the realm to be used to perform this request (overrides the one defined in config)
-     */
-    Realm getRealm();
-
-    /**
-     * @return the file to be uploaded
-     */
-    File getFile();
-
-    /**
-     * @return if this request is to follow redirects. Non null values means "override config value".
-     */
-    Boolean getFollowRedirect();
-
-    /**
-     * @return the request timeout. Non zero values means "override config value".
-     */
-    int getRequestTimeout();
-
-    /**
-     * @return the read timeout. Non zero values means "override config value".
-     */
-    int getReadTimeout();
-
-    /**
-     * @return the range header value, or 0 is not set.
-     */
-    long getRangeOffset();
-
-    /**
-     * @return the charset value used when decoding the request's body.
-     */
-    Charset getCharset();
-
-    /**
-     * @return the strategy to compute ChannelPool's keys
-     */
-    ChannelPoolPartitioning getChannelPoolPartitioning();
-
-    /**
-     * @return the NameResolver to be used to resolve hostnams's IP
-     */
-    NameResolver<InetAddress> getNameResolver();
+  /**
+   * @return the request's HTTP method (GET, POST, etc.)
+   */
+  String getMethod();
+
+  /**
+   * @return the uri
+   */
+  Uri getUri();
+
+  /**
+   * @return the url (the uri's String form)
+   */
+  String getUrl();
+
+  /**
+   * @return the InetAddress to be used to bypass uri's hostname resolution
+   */
+  InetAddress getAddress();
+
+  /**
+   * @return the local address to bind from
+   */
+  InetAddress getLocalAddress();
+
+  /**
+   * @return the HTTP headers
+   */
+  HttpHeaders getHeaders();
+
+  /**
+   * @return the HTTP cookies
+   */
+  List<Cookie> getCookies();
+
+  /**
+   * @return the request's body byte array (only non null if it was set this way)
+   */
+  byte[] getByteData();
+
+  /**
+   * @return the request's body array of byte arrays (only non null if it was set this way)
+   */
+  List<byte[]> getCompositeByteData();
+
+  /**
+   * @return the request's body string (only non null if it was set this way)
+   */
+  String getStringData();
+
+  /**
+   * @return the request's body ByteBuffer (only non null if it was set this way)
+   */
+  ByteBuffer getByteBufferData();
+
+  /**
+   * @return the request's body InputStream (only non null if it was set this way)
+   */
+  InputStream getStreamData();
+
+  /**
+   * @return the request's body BodyGenerator (only non null if it was set this way)
+   */
+  BodyGenerator getBodyGenerator();
+
+  /**
+   * @return the request's form parameters
+   */
+  List<Param> getFormParams();
+
+  /**
+   * @return the multipart parts
+   */
+  List<Part> getBodyParts();
+
+  /**
+   * @return the virtual host to connect to
+   */
+  String getVirtualHost();
+
+  /**
+   * @return the query params resolved from the url/uri
+   */
+  List<Param> getQueryParams();
+
+  /**
+   * @return the proxy server to be used to perform this request (overrides the one defined in config)
+   */
+  ProxyServer getProxyServer();
+
+  /**
+   * @return the realm to be used to perform this request (overrides the one defined in config)
+   */
+  Realm getRealm();
+
+  /**
+   * @return the file to be uploaded
+   */
+  File getFile();
+
+  /**
+   * @return if this request is to follow redirects. Non null values means "override config value".
+   */
+  Boolean getFollowRedirect();
+
+  /**
+   * @return the request timeout. Non zero values means "override config value".
+   */
+  int getRequestTimeout();
+
+  /**
+   * @return the read timeout. Non zero values means "override config value".
+   */
+  int getReadTimeout();
+
+  /**
+   * @return the range header value, or 0 is not set.
+   */
+  long getRangeOffset();
+
+  /**
+   * @return the charset value used when decoding the request's body.
+   */
+  Charset getCharset();
+
+  /**
+   * @return the strategy to compute ChannelPool's keys
+   */
+  ChannelPoolPartitioning getChannelPoolPartitioning();
+
+  /**
+   * @return the NameResolver to be used to resolve hostnams's IP
+   */
+  NameResolver<InetAddress> getNameResolver();
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilder.java b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
index 47b7e2da3..4b0d485ba 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -18,32 +18,32 @@
 import static org.asynchttpclient.util.HttpConstants.Methods.GET;
 
 /**
- * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds, so modifying the builder will modify the
+ * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware that it holds a reference to the Request instance it builds, so modifying the builder will modify the
  * request even after it has been built.
  */
 public class RequestBuilder extends RequestBuilderBase<RequestBuilder> {
 
-    public RequestBuilder() {
-        this(GET);
-    }
+  public RequestBuilder() {
+    this(GET);
+  }
 
-    public RequestBuilder(String method) {
-        this(method, false);
-    }
+  public RequestBuilder(String method) {
+    this(method, false);
+  }
 
-    public RequestBuilder(String method, boolean disableUrlEncoding) {
-        super(method, disableUrlEncoding);
-    }
+  public RequestBuilder(String method, boolean disableUrlEncoding) {
+    super(method, disableUrlEncoding);
+  }
 
-    public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
-        super(method, disableUrlEncoding, validateHeaders);
-    }
+  public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+    super(method, disableUrlEncoding, validateHeaders);
+  }
 
-    public RequestBuilder(Request prototype) {
-        super(prototype);
-    }
+  public RequestBuilder(Request prototype) {
+    super(prototype);
+  }
 
-    public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
-        super(prototype, disableUrlEncoding, validateHeaders);
-    }
+  public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+    super(prototype, disableUrlEncoding, validateHeaders);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index b012bc177..35c814577 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -15,9 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -25,18 +22,6 @@
 import io.netty.resolver.DefaultNameResolver;
 import io.netty.resolver.NameResolver;
 import io.netty.util.concurrent.ImmediateEventExecutor;
-
-import java.io.File;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -48,610 +33,615 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.File;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.*;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
 /**
  * Builder for {@link Request}
- * 
+ *
  * @param <T> the builder type
  */
 public abstract class RequestBuilderBase<T extends RequestBuilderBase<T>> {
 
-    public static NameResolver<InetAddress> DEFAULT_NAME_RESOLVER = new DefaultNameResolver(ImmediateEventExecutor.INSTANCE);
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(RequestBuilderBase.class);
-
-    private static final Uri DEFAULT_REQUEST_URL = Uri.create("http://localhost");
-
-    // builder only fields
-    protected UriEncoder uriEncoder;
-    protected List<Param> queryParams;
-    protected SignatureCalculator signatureCalculator;
-
-    // request fields
-    protected String method;
-    protected Uri uri;
-    protected InetAddress address;
-    protected InetAddress localAddress;
-    protected HttpHeaders headers;
-    protected ArrayList<Cookie> cookies;
-    protected byte[] byteData;
-    protected List<byte[]> compositeByteData;
-    protected String stringData;
-    protected ByteBuffer byteBufferData;
-    protected InputStream streamData;
-    protected BodyGenerator bodyGenerator;
-    protected List<Param> formParams;
-    protected List<Part> bodyParts;
-    protected String virtualHost;
-    protected ProxyServer proxyServer;
-    protected Realm realm;
-    protected File file;
-    protected Boolean followRedirect;
-    protected int requestTimeout;
-    protected int readTimeout;
-    protected long rangeOffset;
-    protected Charset charset;
-    protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
-    protected NameResolver<InetAddress> nameResolver = DEFAULT_NAME_RESOLVER;
-
-    protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
-        this(method, disableUrlEncoding, true);
-    }
-
-    protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
-        this.method = method;
-        this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
-        this.headers = new DefaultHttpHeaders(validateHeaders);
-    }
-
-    protected RequestBuilderBase(Request prototype) {
-        this(prototype, false, false);
-    }
-
-    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
-        this.method = prototype.getMethod();
-        this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
-        this.uri = prototype.getUri();
-        this.address = prototype.getAddress();
-        this.localAddress = prototype.getLocalAddress();
-        this.headers = new DefaultHttpHeaders(validateHeaders);
-        this.headers.add(prototype.getHeaders());
-        if (isNonEmpty(prototype.getCookies())) {
-            this.cookies = new ArrayList<>(prototype.getCookies());
-        }
-        this.byteData = prototype.getByteData();
-        this.compositeByteData = prototype.getCompositeByteData();
-        this.stringData = prototype.getStringData();
-        this.byteBufferData = prototype.getByteBufferData();
-        this.streamData = prototype.getStreamData();
-        this.bodyGenerator = prototype.getBodyGenerator();
-        if (isNonEmpty(prototype.getFormParams())) {
-            this.formParams = new ArrayList<>(prototype.getFormParams());
-        }
-        if (isNonEmpty(prototype.getBodyParts())) {
-            this.bodyParts = new ArrayList<>(prototype.getBodyParts());
-        }
-        this.virtualHost = prototype.getVirtualHost();
-        this.proxyServer = prototype.getProxyServer();
-        this.realm = prototype.getRealm();
-        this.file = prototype.getFile();
-        this.followRedirect = prototype.getFollowRedirect();
-        this.requestTimeout = prototype.getRequestTimeout();
-        this.rangeOffset = prototype.getRangeOffset();
-        this.charset = prototype.getCharset();
-        this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
-        this.nameResolver = prototype.getNameResolver();
-    }
-
-    @SuppressWarnings("unchecked")
-    private T asDerivedType() {
-        return (T) this;
-    }
-
-    public T setUrl(String url) {
-        return setUri(Uri.create(url));
-    }
-
-    public T setUri(Uri uri) {
-        this.uri = uri;
-        return asDerivedType();
-    }
-
-    public T setAddress(InetAddress address) {
-        this.address = address;
-        return asDerivedType();
-    }
-
-    public T setLocalAddress(InetAddress address) {
-        this.localAddress = address;
-        return asDerivedType();
-    }
-
-    public T setVirtualHost(String virtualHost) {
-        this.virtualHost = virtualHost;
-        return asDerivedType();
-    }
-
-    /**
-     * Remove all added headers
-     *
-     * @return {@code this}
-     */
-    public T clearHeaders() {
-        this.headers.clear();
-        return asDerivedType();
-    }
-
-    /**
-     * @param name header name
-     * @param value header value to set
-     * @return {@code this}
-     * @see #setHeader(CharSequence, Object)
-     */
-    public T setHeader(CharSequence name, String value) {
-        return setHeader(name, (Object) value);
-    }
-
-    /**
-     * Set uni-value header for the request
-     *
-     * @param name header name
-     * @param value header value to set
-     * @return {@code this}
-     */
-    public T setHeader(CharSequence name, Object value) {
-        this.headers.set(name, value);
-        return asDerivedType();
-    }
-
-    /**
-     * Set multi-values header for the request
-     *
-     * @param name header name
-     * @param values {@code Iterable} with multiple header values to set
-     * @return {@code this}
-     */
-    public T setHeader(CharSequence name, Iterable<?> values) {
-        this.headers.set(name, values);
-        return asDerivedType();
-    }
-
-    /**
-     * @param name header name
-     * @param value header value to add
-     * @return {@code this}
-     * @see #addHeader(CharSequence, Object)
-     */
-    public T addHeader(CharSequence name, String value) {
-        return addHeader(name, (Object) value);
-    }
-
-    /**
-     * Add a header value for the request. If a header with {@code name} was setup for this request already -
-     * call will add one more header value and convert it to multi-value header
-     *
-     * @param name header name
-     * @param value header value to add
-     * @return {@code this}
-     */
-    public T addHeader(CharSequence name, Object value) {
-        if (value == null) {
-            LOGGER.warn("Value was null, set to \"\"");
-            value = "";
-        }
-
-        this.headers.add(name, value);
-        return asDerivedType();
-    }
-
-    /**
-     * Add header values for the request. If a header with {@code name} was setup for this request already -
-     * call will add more header values and convert it to multi-value header
-     *
-     * @param name header name
-     * @param values {@code Iterable} with multiple header values to add
-     * @return {@code}
-     */
-    public T addHeader(CharSequence name, Iterable<?> values) {
-        this.headers.add(name, values);
-        return asDerivedType();
-    }
-
-    public T setHeaders(HttpHeaders headers) {
-        if (headers == null)
-            this.headers.clear();
-        else
-            this.headers = headers;
-        return asDerivedType();
-    }
-
-    /**
-     * Set request headers using a map {@code headers} of pair (Header name, Header values)
-     * This method could be used to setup multi-valued headers
-     *
-     * @param headers map of header names as the map keys and header values {@link Iterable} as the map values
-     * @return {@code this}
-     */
-    public T setHeaders(Map<CharSequence, ? extends Iterable<?>> headers) {
-        clearHeaders();
-        if (headers != null) {
-            headers.forEach((name, values) -> this.headers.add(name, values));
-        }
-        return asDerivedType();
-    }
-
-    /**
-     * Set single-value request headers using a map {@code headers} of pairs (Header name, Header value).
-     * To set headers with multiple values use {@link #setHeaders(Map)}
-     *
-     * @param headers map of header names as the map keys and header values as the map values
-     * @return {@code this}
-     */
-    public T setSingleHeaders(Map<CharSequence, ?> headers) {
-        clearHeaders();
-        if (headers != null) {
-            headers.forEach((name, value) -> this.headers.add(name, value));
-        }
-        return asDerivedType();
-    }
-
-    private void lazyInitCookies() {
-        if (this.cookies == null)
-            this.cookies = new ArrayList<>(3);
-    }
-
-    public T setCookies(Collection<Cookie> cookies) {
-        this.cookies = new ArrayList<>(cookies);
-        return asDerivedType();
-    }
-
-    public T addCookie(Cookie cookie) {
-        lazyInitCookies();
-        this.cookies.add(cookie);
-        return asDerivedType();
-    }
-
-    public T addOrReplaceCookie(Cookie cookie) {
-        String cookieKey = cookie.name();
-        boolean replace = false;
-        int index = 0;
-        lazyInitCookies();
-        for (Cookie c : this.cookies) {
-            if (c.name().equals(cookieKey)) {
-                replace = true;
-                break;
-            }
-
-            index++;
-        }
-        if (replace)
-            this.cookies.set(index, cookie);
-        else
-            this.cookies.add(cookie);
-        return asDerivedType();
-    }
-
-    public void resetCookies() {
-        if (this.cookies != null)
-            this.cookies.clear();
-    }
-
-    public void resetQuery() {
-        queryParams = null;
-        if (this.uri != null)
-            this.uri = this.uri.withNewQuery(null);
-    }
-
-    public void resetFormParams() {
-        this.formParams = null;
-    }
-
-    public void resetNonMultipartData() {
-        this.byteData = null;
-        this.compositeByteData = null;
-        this.byteBufferData = null;
-        this.stringData = null;
-        this.streamData = null;
-        this.bodyGenerator = null;
-    }
-
-    public void resetMultipartData() {
-        this.bodyParts = null;
-    }
-
-    public T setBody(File file) {
-        this.file = file;
-        return asDerivedType();
-    }
-
-    private void resetBody() {
-        resetFormParams();
-        resetNonMultipartData();
-        resetMultipartData();
-    }
-
-    public T setBody(byte[] data) {
-        resetBody();
-        this.byteData = data;
-        return asDerivedType();
-    }
-
-    public T setBody(List<byte[]> data) {
-        resetBody();
-        this.compositeByteData = data;
-        return asDerivedType();
-    }
-
-    public T setBody(String data) {
-        resetBody();
-        this.stringData = data;
-        return asDerivedType();
-    }
-
-    public T setBody(ByteBuffer data) {
-        resetBody();
-        this.byteBufferData = data;
-        return asDerivedType();
-    }
-
-    public T setBody(InputStream stream) {
-        resetBody();
-        this.streamData = stream;
-        return asDerivedType();
-    }
-
-    public T setBody(Publisher<ByteBuf> publisher) {
-        return setBody(publisher, -1L);
-    }
-
-    public T setBody(Publisher<ByteBuf> publisher, long contentLength) {
-        return setBody(new ReactiveStreamsBodyGenerator(publisher, contentLength));
-    }
-
-    public T setBody(BodyGenerator bodyGenerator) {
-        this.bodyGenerator = bodyGenerator;
-        return asDerivedType();
-    }
-
-    public T addQueryParam(String name, String value) {
-        if (queryParams == null)
-            queryParams = new ArrayList<>(1);
-        queryParams.add(new Param(name, value));
-        return asDerivedType();
-    }
-
-    public T addQueryParams(List<Param> params) {
-        if (queryParams == null)
-            queryParams = params;
-        else
-            queryParams.addAll(params);
-        return asDerivedType();
-    }
-
-    public T setQueryParams(Map<String, List<String>> map) {
-        return setQueryParams(Param.map2ParamList(map));
-    }
-
-    public T setQueryParams(List<Param> params) {
-        // reset existing query
-        if (this.uri != null && isNonEmpty(this.uri.getQuery()))
-            this.uri = this.uri.withNewQuery(null);
-        queryParams = params;
-        return asDerivedType();
-    }
-
-    public T addFormParam(String name, String value) {
-        resetNonMultipartData();
-        resetMultipartData();
-        if (this.formParams == null)
-            this.formParams = new ArrayList<>(1);
-        this.formParams.add(new Param(name, value));
-        return asDerivedType();
-    }
-
-    public T setFormParams(Map<String, List<String>> map) {
-        return setFormParams(Param.map2ParamList(map));
-    }
-
-    public T setFormParams(List<Param> params) {
-        resetNonMultipartData();
-        resetMultipartData();
-        this.formParams = params;
-        return asDerivedType();
-    }
-
-    public T addBodyPart(Part bodyPart) {
-        resetFormParams();
-        resetNonMultipartData();
-        if (this.bodyParts == null)
-            this.bodyParts = new ArrayList<>();
-        this.bodyParts.add(bodyPart);
-        return asDerivedType();
-    }
-
-    public T setBodyParts(List<Part> bodyParts) {
-        this.bodyParts = new ArrayList<>(bodyParts);
-        return asDerivedType();
-    }
-
-    public T setProxyServer(ProxyServer proxyServer) {
-        this.proxyServer = proxyServer;
-        return asDerivedType();
-    }
-
-    public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-        this.proxyServer = proxyServerBuilder.build();
-        return asDerivedType();
-    }
-
-    public T setRealm(Realm.Builder realm) {
-        this.realm = realm.build();
-        return asDerivedType();
-    }
-
-    public T setRealm(Realm realm) {
-        this.realm = realm;
-        return asDerivedType();
-    }
-
-    public T setFollowRedirect(boolean followRedirect) {
-        this.followRedirect = followRedirect;
-        return asDerivedType();
-    }
-
-    public T setRequestTimeout(int requestTimeout) {
-        this.requestTimeout = requestTimeout;
-        return asDerivedType();
-    }
-
-    public T setReadTimeout(int readTimeout) {
-        this.readTimeout = readTimeout;
-        return asDerivedType();
-    }
-
-    public T setRangeOffset(long rangeOffset) {
-        this.rangeOffset = rangeOffset;
-        return asDerivedType();
-    }
-
-    public T setMethod(String method) {
-        this.method = method;
-        return asDerivedType();
-    }
-
-    public T setCharset(Charset charset) {
-        this.charset = charset;
-        return asDerivedType();
-    }
-
-    public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
-        this.channelPoolPartitioning = channelPoolPartitioning;
-        return asDerivedType();
-    }
-
-    public T setNameResolver(NameResolver<InetAddress> nameResolver) {
-        this.nameResolver = nameResolver;
-        return asDerivedType();
-    }
-
-    public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        this.signatureCalculator = signatureCalculator;
-        return asDerivedType();
-    }
-
-    private RequestBuilderBase<?> executeSignatureCalculator() {
-        if (signatureCalculator == null)
-            return this;
-
-        // build a first version of the request, without signatureCalculator in play
-        RequestBuilder rb = new RequestBuilder(this.method);
-        // make copy of mutable collections so we don't risk affecting
-        // original RequestBuilder
-        // call setFormParams first as it resets other fields
-        if (this.formParams != null)
-            rb.setFormParams(this.formParams);
-        if (this.headers != null)
-            rb.headers.add(this.headers);
-        if (this.cookies != null)
-            rb.setCookies(this.cookies);
-        if (this.bodyParts != null)
-            rb.setBodyParts(this.bodyParts);
-
-        // copy all other fields
-        // but rb.signatureCalculator, that's the whole point here
-        rb.uriEncoder = this.uriEncoder;
-        rb.queryParams = this.queryParams;
-        rb.uri = this.uri;
-        rb.address = this.address;
-        rb.localAddress = this.localAddress;
-        rb.byteData = this.byteData;
-        rb.compositeByteData = this.compositeByteData;
-        rb.stringData = this.stringData;
-        rb.byteBufferData = this.byteBufferData;
-        rb.streamData = this.streamData;
-        rb.bodyGenerator = this.bodyGenerator;
-        rb.virtualHost = this.virtualHost;
-        rb.proxyServer = this.proxyServer;
-        rb.realm = this.realm;
-        rb.file = this.file;
-        rb.followRedirect = this.followRedirect;
-        rb.requestTimeout = this.requestTimeout;
-        rb.rangeOffset = this.rangeOffset;
-        rb.charset = this.charset;
-        rb.channelPoolPartitioning = this.channelPoolPartitioning;
-        rb.nameResolver = this.nameResolver;
-        Request unsignedRequest = rb.build();
-        signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
-        return rb;
-    }
-
-    private Charset computeCharset() {
-        if (this.charset == null) {
-            try {
-                final String contentType = this.headers.get(CONTENT_TYPE);
-                if (contentType != null) {
-                    final Charset charset = parseCharset(contentType);
-                    if (charset != null) {
-                        // ensure that if charset is provided with the
-                        // Content-Type header,
-                        // we propagate that down to the charset of the Request
-                        // object
-                        return charset;
-                    }
-                }
-            } catch (Throwable e) {
-                // NoOp -- we can't fix the Content-Type or charset from here
-            }
-        }
-        return this.charset;
-    }
-
-    private Uri computeUri() {
-
-        Uri tempUri = this.uri;
-        if (tempUri == null) {
-            LOGGER.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
-            tempUri = DEFAULT_REQUEST_URL;
-        } else {
-            validateSupportedScheme(tempUri);
-        }
-
-        return uriEncoder.encode(tempUri, queryParams);
-    }
-
-    public Request build() {
-        RequestBuilderBase<?> rb = executeSignatureCalculator();
-        Uri finalUri = rb.computeUri();
-        Charset finalCharset = rb.computeCharset();
-
-        // make copies of mutable internal collections
-        List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
-        List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
-        List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
-
-        return new DefaultRequest(rb.method,//
-                finalUri,//
-                rb.address,//
-                rb.localAddress,//
-                rb.headers,//
-                cookiesCopy,//
-                rb.byteData,//
-                rb.compositeByteData,//
-                rb.stringData,//
-                rb.byteBufferData,//
-                rb.streamData,//
-                rb.bodyGenerator,//
-                formParamsCopy,//
-                bodyPartsCopy,//
-                rb.virtualHost,//
-                rb.proxyServer,//
-                rb.realm,//
-                rb.file,//
-                rb.followRedirect,//
-                rb.requestTimeout,//
-                rb.readTimeout,//
-                rb.rangeOffset,//
-                finalCharset,//
-                rb.channelPoolPartitioning,//
-                rb.nameResolver);
-    }
+  private final static Logger LOGGER = LoggerFactory.getLogger(RequestBuilderBase.class);
+  private static final Uri DEFAULT_REQUEST_URL = Uri.create("http://localhost");
+  public static NameResolver<InetAddress> DEFAULT_NAME_RESOLVER = new DefaultNameResolver(ImmediateEventExecutor.INSTANCE);
+  // builder only fields
+  protected UriEncoder uriEncoder;
+  protected List<Param> queryParams;
+  protected SignatureCalculator signatureCalculator;
+
+  // request fields
+  protected String method;
+  protected Uri uri;
+  protected InetAddress address;
+  protected InetAddress localAddress;
+  protected HttpHeaders headers;
+  protected ArrayList<Cookie> cookies;
+  protected byte[] byteData;
+  protected List<byte[]> compositeByteData;
+  protected String stringData;
+  protected ByteBuffer byteBufferData;
+  protected InputStream streamData;
+  protected BodyGenerator bodyGenerator;
+  protected List<Param> formParams;
+  protected List<Part> bodyParts;
+  protected String virtualHost;
+  protected ProxyServer proxyServer;
+  protected Realm realm;
+  protected File file;
+  protected Boolean followRedirect;
+  protected int requestTimeout;
+  protected int readTimeout;
+  protected long rangeOffset;
+  protected Charset charset;
+  protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
+  protected NameResolver<InetAddress> nameResolver = DEFAULT_NAME_RESOLVER;
+
+  protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
+    this(method, disableUrlEncoding, true);
+  }
+
+  protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+    this.method = method;
+    this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+    this.headers = new DefaultHttpHeaders(validateHeaders);
+  }
+
+  protected RequestBuilderBase(Request prototype) {
+    this(prototype, false, false);
+  }
+
+  protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+    this.method = prototype.getMethod();
+    this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+    this.uri = prototype.getUri();
+    this.address = prototype.getAddress();
+    this.localAddress = prototype.getLocalAddress();
+    this.headers = new DefaultHttpHeaders(validateHeaders);
+    this.headers.add(prototype.getHeaders());
+    if (isNonEmpty(prototype.getCookies())) {
+      this.cookies = new ArrayList<>(prototype.getCookies());
+    }
+    this.byteData = prototype.getByteData();
+    this.compositeByteData = prototype.getCompositeByteData();
+    this.stringData = prototype.getStringData();
+    this.byteBufferData = prototype.getByteBufferData();
+    this.streamData = prototype.getStreamData();
+    this.bodyGenerator = prototype.getBodyGenerator();
+    if (isNonEmpty(prototype.getFormParams())) {
+      this.formParams = new ArrayList<>(prototype.getFormParams());
+    }
+    if (isNonEmpty(prototype.getBodyParts())) {
+      this.bodyParts = new ArrayList<>(prototype.getBodyParts());
+    }
+    this.virtualHost = prototype.getVirtualHost();
+    this.proxyServer = prototype.getProxyServer();
+    this.realm = prototype.getRealm();
+    this.file = prototype.getFile();
+    this.followRedirect = prototype.getFollowRedirect();
+    this.requestTimeout = prototype.getRequestTimeout();
+    this.readTimeout = prototype.getReadTimeout();
+    this.rangeOffset = prototype.getRangeOffset();
+    this.charset = prototype.getCharset();
+    this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
+    this.nameResolver = prototype.getNameResolver();
+  }
+
+  @SuppressWarnings("unchecked")
+  private T asDerivedType() {
+    return (T) this;
+  }
+
+  public T setUrl(String url) {
+    return setUri(Uri.create(url));
+  }
+
+  public T setUri(Uri uri) {
+    this.uri = uri;
+    return asDerivedType();
+  }
+
+  public T setAddress(InetAddress address) {
+    this.address = address;
+    return asDerivedType();
+  }
+
+  public T setLocalAddress(InetAddress address) {
+    this.localAddress = address;
+    return asDerivedType();
+  }
+
+  public T setVirtualHost(String virtualHost) {
+    this.virtualHost = virtualHost;
+    return asDerivedType();
+  }
+
+  /**
+   * Remove all added headers
+   *
+   * @return {@code this}
+   */
+  public T clearHeaders() {
+    this.headers.clear();
+    return asDerivedType();
+  }
+
+  /**
+   * @param name  header name
+   * @param value header value to set
+   * @return {@code this}
+   * @see #setHeader(CharSequence, Object)
+   */
+  public T setHeader(CharSequence name, String value) {
+    return setHeader(name, (Object) value);
+  }
+
+  /**
+   * Set uni-value header for the request
+   *
+   * @param name  header name
+   * @param value header value to set
+   * @return {@code this}
+   */
+  public T setHeader(CharSequence name, Object value) {
+    this.headers.set(name, value);
+    return asDerivedType();
+  }
+
+  /**
+   * Set multi-values header for the request
+   *
+   * @param name   header name
+   * @param values {@code Iterable} with multiple header values to set
+   * @return {@code this}
+   */
+  public T setHeader(CharSequence name, Iterable<?> values) {
+    this.headers.set(name, values);
+    return asDerivedType();
+  }
+
+  /**
+   * @param name  header name
+   * @param value header value to add
+   * @return {@code this}
+   * @see #addHeader(CharSequence, Object)
+   */
+  public T addHeader(CharSequence name, String value) {
+    return addHeader(name, (Object) value);
+  }
+
+  /**
+   * Add a header value for the request. If a header with {@code name} was setup for this request already -
+   * call will add one more header value and convert it to multi-value header
+   *
+   * @param name  header name
+   * @param value header value to add
+   * @return {@code this}
+   */
+  public T addHeader(CharSequence name, Object value) {
+    if (value == null) {
+      LOGGER.warn("Value was null, set to \"\"");
+      value = "";
+    }
+
+    this.headers.add(name, value);
+    return asDerivedType();
+  }
+
+  /**
+   * Add header values for the request. If a header with {@code name} was setup for this request already -
+   * call will add more header values and convert it to multi-value header
+   *
+   * @param name   header name
+   * @param values {@code Iterable} with multiple header values to add
+   * @return {@code}
+   */
+  public T addHeader(CharSequence name, Iterable<?> values) {
+    this.headers.add(name, values);
+    return asDerivedType();
+  }
+
+  public T setHeaders(HttpHeaders headers) {
+    if (headers == null)
+      this.headers.clear();
+    else
+      this.headers = headers;
+    return asDerivedType();
+  }
+
+  /**
+   * Set request headers using a map {@code headers} of pair (Header name, Header values)
+   * This method could be used to setup multi-valued headers
+   *
+   * @param headers map of header names as the map keys and header values {@link Iterable} as the map values
+   * @return {@code this}
+   */
+  public T setHeaders(Map<? extends CharSequence, ? extends Iterable<?>> headers) {
+    clearHeaders();
+    if (headers != null) {
+      headers.forEach((name, values) -> this.headers.add(name, values));
+    }
+    return asDerivedType();
+  }
+
+  /**
+   * Set single-value request headers using a map {@code headers} of pairs (Header name, Header value).
+   * To set headers with multiple values use {@link #setHeaders(Map)}
+   *
+   * @param headers map of header names as the map keys and header values as the map values
+   * @return {@code this}
+   */
+  public T setSingleHeaders(Map<? extends CharSequence, ?> headers) {
+    clearHeaders();
+    if (headers != null) {
+      headers.forEach((name, value) -> this.headers.add(name, value));
+    }
+    return asDerivedType();
+  }
+
+  private void lazyInitCookies() {
+    if (this.cookies == null)
+      this.cookies = new ArrayList<>(3);
+  }
+
+  public T setCookies(Collection<Cookie> cookies) {
+    this.cookies = new ArrayList<>(cookies);
+    return asDerivedType();
+  }
+
+  public T addCookie(Cookie cookie) {
+    lazyInitCookies();
+    this.cookies.add(cookie);
+    return asDerivedType();
+  }
+
+  /**
+   * Add/replace a cookie based on its name
+   * @param cookie the new cookie
+   * @return this
+   */
+  public T addOrReplaceCookie(Cookie cookie) {
+    String cookieKey = cookie.name();
+    boolean replace = false;
+    int index = 0;
+    lazyInitCookies();
+    for (Cookie c : this.cookies) {
+      if (c.name().equals(cookieKey)) {
+        replace = true;
+        break;
+      }
+
+      index++;
+    }
+    if (replace)
+      this.cookies.set(index, cookie);
+    else
+      this.cookies.add(cookie);
+    return asDerivedType();
+  }
+
+  public void resetCookies() {
+    if (this.cookies != null)
+      this.cookies.clear();
+  }
+
+  public void resetQuery() {
+    queryParams = null;
+    if (this.uri != null)
+      this.uri = this.uri.withNewQuery(null);
+  }
+
+  public void resetFormParams() {
+    this.formParams = null;
+  }
+
+  public void resetNonMultipartData() {
+    this.byteData = null;
+    this.compositeByteData = null;
+    this.byteBufferData = null;
+    this.stringData = null;
+    this.streamData = null;
+    this.bodyGenerator = null;
+  }
+
+  public void resetMultipartData() {
+    this.bodyParts = null;
+  }
+
+  public T setBody(File file) {
+    this.file = file;
+    return asDerivedType();
+  }
+
+  private void resetBody() {
+    resetFormParams();
+    resetNonMultipartData();
+    resetMultipartData();
+  }
+
+  public T setBody(byte[] data) {
+    resetBody();
+    this.byteData = data;
+    return asDerivedType();
+  }
+
+  public T setBody(List<byte[]> data) {
+    resetBody();
+    this.compositeByteData = data;
+    return asDerivedType();
+  }
+
+  public T setBody(String data) {
+    resetBody();
+    this.stringData = data;
+    return asDerivedType();
+  }
+
+  public T setBody(ByteBuffer data) {
+    resetBody();
+    this.byteBufferData = data;
+    return asDerivedType();
+  }
+
+  public T setBody(InputStream stream) {
+    resetBody();
+    this.streamData = stream;
+    return asDerivedType();
+  }
+
+  public T setBody(Publisher<ByteBuf> publisher) {
+    return setBody(publisher, -1L);
+  }
+
+  public T setBody(Publisher<ByteBuf> publisher, long contentLength) {
+    return setBody(new ReactiveStreamsBodyGenerator(publisher, contentLength));
+  }
+
+  public T setBody(BodyGenerator bodyGenerator) {
+    this.bodyGenerator = bodyGenerator;
+    return asDerivedType();
+  }
+
+  public T addQueryParam(String name, String value) {
+    if (queryParams == null)
+      queryParams = new ArrayList<>(1);
+    queryParams.add(new Param(name, value));
+    return asDerivedType();
+  }
+
+  public T addQueryParams(List<Param> params) {
+    if (queryParams == null)
+      queryParams = params;
+    else
+      queryParams.addAll(params);
+    return asDerivedType();
+  }
+
+  public T setQueryParams(Map<String, List<String>> map) {
+    return setQueryParams(Param.map2ParamList(map));
+  }
+
+  public T setQueryParams(List<Param> params) {
+    // reset existing query
+    if (this.uri != null && isNonEmpty(this.uri.getQuery()))
+      this.uri = this.uri.withNewQuery(null);
+    queryParams = params;
+    return asDerivedType();
+  }
+
+  public T addFormParam(String name, String value) {
+    resetNonMultipartData();
+    resetMultipartData();
+    if (this.formParams == null)
+      this.formParams = new ArrayList<>(1);
+    this.formParams.add(new Param(name, value));
+    return asDerivedType();
+  }
+
+  public T setFormParams(Map<String, List<String>> map) {
+    return setFormParams(Param.map2ParamList(map));
+  }
+
+  public T setFormParams(List<Param> params) {
+    resetNonMultipartData();
+    resetMultipartData();
+    this.formParams = params;
+    return asDerivedType();
+  }
+
+  public T addBodyPart(Part bodyPart) {
+    resetFormParams();
+    resetNonMultipartData();
+    if (this.bodyParts == null)
+      this.bodyParts = new ArrayList<>();
+    this.bodyParts.add(bodyPart);
+    return asDerivedType();
+  }
+
+  public T setBodyParts(List<Part> bodyParts) {
+    this.bodyParts = new ArrayList<>(bodyParts);
+    return asDerivedType();
+  }
+
+  public T setProxyServer(ProxyServer proxyServer) {
+    this.proxyServer = proxyServer;
+    return asDerivedType();
+  }
+
+  public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+    this.proxyServer = proxyServerBuilder.build();
+    return asDerivedType();
+  }
+
+  public T setRealm(Realm.Builder realm) {
+    this.realm = realm.build();
+    return asDerivedType();
+  }
+
+  public T setRealm(Realm realm) {
+    this.realm = realm;
+    return asDerivedType();
+  }
+
+  public T setFollowRedirect(boolean followRedirect) {
+    this.followRedirect = followRedirect;
+    return asDerivedType();
+  }
+
+  public T setRequestTimeout(int requestTimeout) {
+    this.requestTimeout = requestTimeout;
+    return asDerivedType();
+  }
+
+  public T setReadTimeout(int readTimeout) {
+    this.readTimeout = readTimeout;
+    return asDerivedType();
+  }
+
+  public T setRangeOffset(long rangeOffset) {
+    this.rangeOffset = rangeOffset;
+    return asDerivedType();
+  }
+
+  public T setMethod(String method) {
+    this.method = method;
+    return asDerivedType();
+  }
+
+  public T setCharset(Charset charset) {
+    this.charset = charset;
+    return asDerivedType();
+  }
+
+  public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
+    this.channelPoolPartitioning = channelPoolPartitioning;
+    return asDerivedType();
+  }
+
+  public T setNameResolver(NameResolver<InetAddress> nameResolver) {
+    this.nameResolver = nameResolver;
+    return asDerivedType();
+  }
+
+  public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
+    this.signatureCalculator = signatureCalculator;
+    return asDerivedType();
+  }
+
+  private RequestBuilderBase<?> executeSignatureCalculator() {
+    if (signatureCalculator == null)
+      return this;
+
+    // build a first version of the request, without signatureCalculator in play
+    RequestBuilder rb = new RequestBuilder(this.method);
+    // make copy of mutable collections so we don't risk affecting
+    // original RequestBuilder
+    // call setFormParams first as it resets other fields
+    if (this.formParams != null)
+      rb.setFormParams(this.formParams);
+    if (this.headers != null)
+      rb.headers.add(this.headers);
+    if (this.cookies != null)
+      rb.setCookies(this.cookies);
+    if (this.bodyParts != null)
+      rb.setBodyParts(this.bodyParts);
+
+    // copy all other fields
+    // but rb.signatureCalculator, that's the whole point here
+    rb.uriEncoder = this.uriEncoder;
+    rb.queryParams = this.queryParams;
+    rb.uri = this.uri;
+    rb.address = this.address;
+    rb.localAddress = this.localAddress;
+    rb.byteData = this.byteData;
+    rb.compositeByteData = this.compositeByteData;
+    rb.stringData = this.stringData;
+    rb.byteBufferData = this.byteBufferData;
+    rb.streamData = this.streamData;
+    rb.bodyGenerator = this.bodyGenerator;
+    rb.virtualHost = this.virtualHost;
+    rb.proxyServer = this.proxyServer;
+    rb.realm = this.realm;
+    rb.file = this.file;
+    rb.followRedirect = this.followRedirect;
+    rb.requestTimeout = this.requestTimeout;
+    rb.rangeOffset = this.rangeOffset;
+    rb.charset = this.charset;
+    rb.channelPoolPartitioning = this.channelPoolPartitioning;
+    rb.nameResolver = this.nameResolver;
+    Request unsignedRequest = rb.build();
+    signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
+    return rb;
+  }
+
+  private void updateCharset() {
+    String contentTypeHeader = headers.get(CONTENT_TYPE);
+    Charset contentTypeCharset = extractContentTypeCharsetAttribute(contentTypeHeader);
+    charset = withDefault(contentTypeCharset, withDefault(charset, UTF_8));
+    if (contentTypeHeader != null && contentTypeHeader.regionMatches(true, 0, "text/", 0, 5) && contentTypeCharset == null) {
+      // add explicit charset to content-type header
+      headers.set(CONTENT_TYPE, contentTypeHeader + "; charset=" + charset.name());
+    }
+  }
+
+  private Uri computeUri() {
+
+    Uri tempUri = this.uri;
+    if (tempUri == null) {
+      LOGGER.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
+      tempUri = DEFAULT_REQUEST_URL;
+    } else {
+      Uri.validateSupportedScheme(tempUri);
+    }
+
+    return uriEncoder.encode(tempUri, queryParams);
+  }
+
+  public Request build() {
+    updateCharset();
+    RequestBuilderBase<?> rb = executeSignatureCalculator();
+    Uri finalUri = rb.computeUri();
+
+    // make copies of mutable internal collections
+    List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
+    List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
+    List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
+
+    return new DefaultRequest(rb.method,
+            finalUri,
+            rb.address,
+            rb.localAddress,
+            rb.headers,
+            cookiesCopy,
+            rb.byteData,
+            rb.compositeByteData,
+            rb.stringData,
+            rb.byteBufferData,
+            rb.streamData,
+            rb.bodyGenerator,
+            formParamsCopy,
+            bodyPartsCopy,
+            rb.virtualHost,
+            rb.proxyServer,
+            rb.realm,
+            rb.file,
+            rb.followRedirect,
+            rb.requestTimeout,
+            rb.readTimeout,
+            rb.rangeOffset,
+            rb.charset,
+            rb.channelPoolPartitioning,
+            rb.nameResolver);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Response.java b/client/src/main/java/org/asynchttpclient/Response.java
index ba97ae73e..99f033e99 100644
--- a/client/src/main/java/org/asynchttpclient/Response.java
+++ b/client/src/main/java/org/asynchttpclient/Response.java
@@ -18,6 +18,8 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.netty.NettyResponse;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.InputStream;
 import java.net.SocketAddress;
@@ -26,190 +28,188 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.asynchttpclient.netty.NettyResponse;
-import org.asynchttpclient.uri.Uri;
-
 /**
  * Represents the asynchronous HTTP response callback for an {@link AsyncCompletionHandler}
  */
 public interface Response {
-    /**
-     * Returns the status code for the request.
-     * 
-     * @return The status code
-     */
-    int getStatusCode();
-
-    /**
-     * Returns the status text for the request.
-     * 
-     * @return The status text
-     */
-    String getStatusText();
-
-    /**
-     * Return the entire response body as a byte[].
-     * 
-     * @return the entire response body as a byte[].
-     */
-    byte[] getResponseBodyAsBytes();
-
-    /**
-     * Return the entire response body as a ByteBuffer.
-     * 
-     * @return the entire response body as a ByteBuffer.
-     */
-    ByteBuffer getResponseBodyAsByteBuffer();
-
-    /**
-     * Returns an input stream for the response body. Note that you should not try to get this more than once, and that you should not close the stream.
-     * 
-     * @return The input stream
-     */
-    InputStream getResponseBodyAsStream();
-
-    /**
-     * Return the entire response body as a String.
-     * 
-     * @param charset the charset to use when decoding the stream
-     * @return the entire response body as a String.
-     */
-    String getResponseBody(Charset charset);
-
-    /**
-     * Return the entire response body as a String.
-     * 
-     * @return the entire response body as a String.
-     */
-    String getResponseBody();
-
-    /**
-     * Return the request {@link Uri}. Note that if the request got redirected, the value of the {@link Uri} will be the last valid redirect url.
-     * 
-     * @return the request {@link Uri}.
-     */
-    Uri getUri();
-
-    /**
-     * Return the content-type header value.
-     * 
-     * @return the content-type header value.
-     */
-    String getContentType();
-
-    /**
-     * @param name the header name
-     * @return the first response header value
-     */
-    String getHeader(CharSequence name);
-
-    /**
-     * Return a {@link List} of the response header value.
-     * 
-     * @param name the header name
-     * @return the response header value
-     */
-    List<String> getHeaders(CharSequence name);
-
-    HttpHeaders getHeaders();
-
-    /**
-     * Return true if the response redirects to another object.
-     * 
-     * @return True if the response redirects to another object.
-     */
-    boolean isRedirected();
-
-    /**
-     * Subclasses SHOULD implement toString() in a way that identifies the response for logging.
-     * 
-     * @return the textual representation
-     */
-    String toString();
-
-    /**
-     * @return the list of {@link Cookie}.
-     */
-    List<Cookie> getCookies();
-
-    /**
-     * Return true if the response's status has been computed by an {@link AsyncHandler}
-     * 
-     * @return true if the response's status has been computed by an {@link AsyncHandler}
-     */
-    boolean hasResponseStatus();
+  /**
+   * Returns the status code for the request.
+   *
+   * @return The status code
+   */
+  int getStatusCode();
+
+  /**
+   * Returns the status text for the request.
+   *
+   * @return The status text
+   */
+  String getStatusText();
+
+  /**
+   * Return the entire response body as a byte[].
+   *
+   * @return the entire response body as a byte[].
+   */
+  byte[] getResponseBodyAsBytes();
+
+  /**
+   * Return the entire response body as a ByteBuffer.
+   *
+   * @return the entire response body as a ByteBuffer.
+   */
+  ByteBuffer getResponseBodyAsByteBuffer();
+
+  /**
+   * Returns an input stream for the response body. Note that you should not try to get this more than once, and that you should not close the stream.
+   *
+   * @return The input stream
+   */
+  InputStream getResponseBodyAsStream();
+
+  /**
+   * Return the entire response body as a String.
+   *
+   * @param charset the charset to use when decoding the stream
+   * @return the entire response body as a String.
+   */
+  String getResponseBody(Charset charset);
+
+  /**
+   * Return the entire response body as a String.
+   *
+   * @return the entire response body as a String.
+   */
+  String getResponseBody();
+
+  /**
+   * Return the request {@link Uri}. Note that if the request got redirected, the value of the {@link Uri} will be the last valid redirect url.
+   *
+   * @return the request {@link Uri}.
+   */
+  Uri getUri();
+
+  /**
+   * Return the content-type header value.
+   *
+   * @return the content-type header value.
+   */
+  String getContentType();
+
+  /**
+   * @param name the header name
+   * @return the first response header value
+   */
+  String getHeader(CharSequence name);
+
+  /**
+   * Return a {@link List} of the response header value.
+   *
+   * @param name the header name
+   * @return the response header value
+   */
+  List<String> getHeaders(CharSequence name);
+
+  HttpHeaders getHeaders();
+
+  /**
+   * Return true if the response redirects to another object.
+   *
+   * @return True if the response redirects to another object.
+   */
+  boolean isRedirected();
+
+  /**
+   * Subclasses SHOULD implement toString() in a way that identifies the response for logging.
+   *
+   * @return the textual representation
+   */
+  String toString();
+
+  /**
+   * @return the list of {@link Cookie}.
+   */
+  List<Cookie> getCookies();
+
+  /**
+   * Return true if the response's status has been computed by an {@link AsyncHandler}
+   *
+   * @return true if the response's status has been computed by an {@link AsyncHandler}
+   */
+  boolean hasResponseStatus();
+
+  /**
+   * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
+   * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
+   *
+   * @return true if the response's headers has been computed by an {@link AsyncHandler}
+   */
+  boolean hasResponseHeaders();
+
+  /**
+   * Return true if the response's body has been computed by an {@link AsyncHandler}.
+   * It will return false if:
+   * <ul>
+   *   <li>either the {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} returned {@link AsyncHandler.State#ABORT}</li>
+   *   <li>or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}</li>
+   *   <li>response body was empty</li>
+   * </ul>
+   *
+   * @return true if the response's body has been computed by an {@link AsyncHandler} to new empty bytes
+   */
+  boolean hasResponseBody();
+
+  /**
+   * Get the remote address that the client initiated the request to.
+   *
+   * @return The remote address that the client initiated the request to. May be {@code null} if asynchronous provider is unable to provide the remote address
+   */
+  SocketAddress getRemoteAddress();
+
+  /**
+   * Get the local address that the client initiated the request from.
+   *
+   * @return The local address that the client initiated the request from. May be {@code null} if asynchronous provider is unable to provide the local address
+   */
+  SocketAddress getLocalAddress();
+
+  class ResponseBuilder {
+    private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>(1);
+    private HttpResponseStatus status;
+    private HttpHeaders headers;
+
+    public void accumulate(HttpResponseStatus status) {
+      this.status = status;
+    }
 
-    /**
-     * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
-     * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
-     * 
-     * @return true if the response's headers has been computed by an {@link AsyncHandler}
-     */
-    boolean hasResponseHeaders();
+    public void accumulate(HttpHeaders headers) {
+      this.headers = this.headers == null ? headers : this.headers.add(headers);
+    }
 
     /**
-     * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
-     * or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
-     * 
-     * @return true if the response's body has been computed by an {@link AsyncHandler}
+     * @param bodyPart a body part (possibly empty, but will be filtered out)
      */
-    boolean hasResponseBody();
+    public void accumulate(HttpResponseBodyPart bodyPart) {
+      if (bodyPart.length() > 0)
+        bodyParts.add(bodyPart);
+    }
 
     /**
-     * Get remote address client initiated request to.
-     * 
-     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
+     * Build a {@link Response} instance
+     *
+     * @return a {@link Response} instance
      */
-    SocketAddress getRemoteAddress();
+    public Response build() {
+      return status == null ? null : new NettyResponse(status, headers, bodyParts);
+    }
 
     /**
-     * Get local address client initiated request from.
-     * 
-     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
+     * Reset the internal state of this builder.
      */
-    SocketAddress getLocalAddress();
-
-    class ResponseBuilder {
-        private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>(1);
-        private HttpResponseStatus status;
-        private HttpHeaders headers;
-
-        public ResponseBuilder accumulate(HttpResponseStatus status) {
-            this.status = status;
-            return this;
-        }
-
-        public ResponseBuilder accumulate(HttpHeaders headers) {
-            this.headers = this.headers == null ? headers : this.headers.add(headers);
-            return this;
-        }
-
-        /**
-         * @param bodyPart a body part (possibly empty, but will be filtered out)
-         * @return this
-         */
-        public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
-            if (bodyPart.length() > 0)
-                bodyParts.add(bodyPart);
-            return this;
-        }
-
-        /**
-         * Build a {@link Response} instance
-         * 
-         * @return a {@link Response} instance
-         */
-        public Response build() {
-            return status == null ? null : new NettyResponse(status, headers, bodyParts);
-        }
-
-        /**
-         * Reset the internal state of this builder.
-         */
-        public void reset() {
-            bodyParts.clear();
-            status = null;
-            headers = null;
-        }
+    public void reset() {
+      bodyParts.clear();
+      status = null;
+      headers = null;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/SignatureCalculator.java b/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
index f406c70de..fbec1037e 100644
--- a/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
@@ -16,7 +16,6 @@
 package org.asynchttpclient;
 
 
-
 /**
  * Interface that allows injecting signature calculator into
  * {@link RequestBuilder} so that signature calculation and inclusion can
@@ -25,18 +24,18 @@
  * @since 1.1
  */
 public interface SignatureCalculator {
-    /**
-     * Method called when {@link RequestBuilder#build} method is called.
-     * Should first calculate signature information and then modify request
-     * (using passed {@link RequestBuilder}) to add signature (usually as
-     * an HTTP header).
-     *
-     * @param requestBuilder builder that can be used to modify request, usually
-     *                       by adding header that includes calculated signature. Be sure NOT to
-     *                       call {@link RequestBuilder#build} since this will cause infinite recursion
-     * @param request        Request that is being built; needed to access content to
-     *                       be signed
-     */
-    void calculateAndAddSignature(Request request,
-                                  RequestBuilderBase<?> requestBuilder);
+  /**
+   * Method called when {@link RequestBuilder#build} method is called.
+   * Should first calculate signature information and then modify request
+   * (using passed {@link RequestBuilder}) to add signature (usually as
+   * an HTTP header).
+   *
+   * @param requestBuilder builder that can be used to modify request, usually
+   *                       by adding header that includes calculated signature. Be sure NOT to
+   *                       call {@link RequestBuilder#build} since this will cause infinite recursion
+   * @param request        Request that is being built; needed to access content to
+   *                       be signed
+   */
+  void calculateAndAddSignature(Request request,
+                                RequestBuilderBase<?> requestBuilder);
 }
diff --git a/client/src/main/java/org/asynchttpclient/SslEngineFactory.java b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
index d756aa83d..7fb25dd84 100644
--- a/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
@@ -18,25 +18,25 @@
 
 public interface SslEngineFactory {
 
-    /**
-     * Creates new {@link SSLEngine}.
-     *
-     * @param config the client config
-     * @param peerHost the peer hostname
-     * @param peerPort the peer port
-     * @return new engine
-     */
-    SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort);
+  /**
+   * Creates a new {@link SSLEngine}.
+   *
+   * @param config   the client config
+   * @param peerHost the peer hostname
+   * @param peerPort the peer port
+   * @return new engine
+   */
+  SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort);
 
-    /**
-     * Perform any necessary one-time configuration. This will be called just once before {@code newSslEngine} is called
-     * for the first time.
-     *
-     * @param config the client config
-     * @throws SSLException if initialization fails. If an exception is thrown, the instance will not be used as client
-     *                      creation will fail.
-     */
-    default void init(AsyncHttpClientConfig config) throws SSLException {
-        // no op
-    }
+  /**
+   * Perform any necessary one-time configuration. This will be called just once before {@code newSslEngine} is called
+   * for the first time.
+   *
+   * @param config the client config
+   * @throws SSLException if initialization fails. If an exception is thrown, the instance will not be used as client
+   *                      creation will fail.
+   */
+  default void init(AsyncHttpClientConfig config) throws SSLException {
+    // no op
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
index 91de4de84..97331fbdf 100755
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
@@ -13,62 +13,62 @@
  */
 package org.asynchttpclient.channel;
 
+import io.netty.channel.Channel;
+
 import java.util.Map;
 import java.util.function.Predicate;
 
-import io.netty.channel.Channel;
-
 public interface ChannelPool {
 
-    /**
-     * Add a channel to the pool
-     * 
-     * @param channel an I/O channel
-     * @param partitionKey a key used to retrieve the cached channel
-     * @return true if added.
-     */
-    boolean offer(Channel channel, Object partitionKey);
+  /**
+   * Add a channel to the pool
+   *
+   * @param channel      an I/O channel
+   * @param partitionKey a key used to retrieve the cached channel
+   * @return true if added.
+   */
+  boolean offer(Channel channel, Object partitionKey);
 
-    /**
-     * Remove the channel associated with the uri.
-     * 
-     * @param partitionKey the partition used when invoking offer
-     * @return the channel associated with the uri
-     */
-    Channel poll(Object partitionKey);
+  /**
+   * Remove the channel associated with the uri.
+   *
+   * @param partitionKey the partition used when invoking offer
+   * @return the channel associated with the uri
+   */
+  Channel poll(Object partitionKey);
 
-    /**
-     * Remove all channels from the cache. A channel might have been associated
-     * with several uri.
-     * 
-     * @param channel a channel
-     * @return the true if the channel has been removed
-     */
-    boolean removeAll(Channel channel);
+  /**
+   * Remove all channels from the cache. A channel might have been associated
+   * with several uri.
+   *
+   * @param channel a channel
+   * @return the true if the channel has been removed
+   */
+  boolean removeAll(Channel channel);
 
-    /**
-     * Return true if a channel can be cached. A implementation can decide based
-     * on some rules to allow caching Calling this method is equivalent of
-     * checking the returned value of {@link ChannelPool#offer(Channel, Object)}
-     * 
-     * @return true if a channel can be cached.
-     */
-    boolean isOpen();
+  /**
+   * Return true if a channel can be cached. A implementation can decide based
+   * on some rules to allow caching Calling this method is equivalent of
+   * checking the returned value of {@link ChannelPool#offer(Channel, Object)}
+   *
+   * @return true if a channel can be cached.
+   */
+  boolean isOpen();
 
-    /**
-     * Destroy all channels that has been cached by this instance.
-     */
-    void destroy();
+  /**
+   * Destroy all channels that has been cached by this instance.
+   */
+  void destroy();
 
-    /**
-     * Flush partitions based on a predicate
-     * 
-     * @param predicate the predicate
-     */
-    void flushPartitions(Predicate<Object> predicate);
+  /**
+   * Flush partitions based on a predicate
+   *
+   * @param predicate the predicate
+   */
+  void flushPartitions(Predicate<Object> predicate);
 
-    /**
-     * @return The number of idle channels per host.
-     */
-    Map<String, Long> getIdleChannelCountPerHost();
+  /**
+   * @return The number of idle channels per host.
+   */
+  Map<String, Long> getIdleChannelCountPerHost();
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
index 4cce3c636..fb00ba480 100644
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
@@ -13,87 +13,91 @@
 package org.asynchttpclient.channel;
 
 import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.proxy.ProxyType;
 import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.HttpUtils;
 
 public interface ChannelPoolPartitioning {
 
-    class ProxyPartitionKey {
-        private final String proxyHost;
-        private final int proxyPort;
-        private final boolean secured;
-        private final String targetHostBaseUrl;
+  Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
 
-        public ProxyPartitionKey(String proxyHost, int proxyPort, boolean secured, String targetHostBaseUrl) {
-            this.proxyHost = proxyHost;
-            this.proxyPort = proxyPort;
-            this.secured = secured;
-            this.targetHostBaseUrl = targetHostBaseUrl;
-        }
+  enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
 
-        @Override
-        public int hashCode() {
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((proxyHost == null) ? 0 : proxyHost.hashCode());
-            result = prime * result + proxyPort;
-            result = prime * result + (secured ? 1231 : 1237);
-            result = prime * result + ((targetHostBaseUrl == null) ? 0 : targetHostBaseUrl.hashCode());
-            return result;
-        }
+    INSTANCE;
 
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            ProxyPartitionKey other = (ProxyPartitionKey) obj;
-            if (proxyHost == null) {
-                if (other.proxyHost != null)
-                    return false;
-            } else if (!proxyHost.equals(other.proxyHost))
-                return false;
-            if (proxyPort != other.proxyPort)
-                return false;
-            if (secured != other.secured)
-                return false;
-            if (targetHostBaseUrl == null) {
-                if (other.targetHostBaseUrl != null)
-                    return false;
-            } else if (!targetHostBaseUrl.equals(other.targetHostBaseUrl))
-                return false;
-            return true;
+    public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer) {
+      String targetHostBaseUrl = uri.getBaseUrl();
+      if (proxyServer == null) {
+        if (virtualHost == null) {
+          return targetHostBaseUrl;
+        } else {
+          return new CompositePartitionKey(
+                  targetHostBaseUrl,
+                  virtualHost,
+                  null,
+                  0,
+                  null);
         }
+      } else {
+        return new CompositePartitionKey(
+                targetHostBaseUrl,
+                virtualHost,
+                proxyServer.getHost(),
+                uri.isSecured() && proxyServer.getProxyType() == ProxyType.HTTP ?
+                        proxyServer.getSecuredPort() :
+                        proxyServer.getPort(),
+                proxyServer.getProxyType());
+      }
+    }
+  }
 
-        @Override
-        public String toString() {
-            return new StringBuilder()//
-                    .append("ProxyPartitionKey(proxyHost=").append(proxyHost)//
-                    .append(", proxyPort=").append(proxyPort)//
-                    .append(", secured=").append(secured)//
-                    .append(", targetHostBaseUrl=").append(targetHostBaseUrl)//
-                    .toString();
-        }
+  class CompositePartitionKey {
+    private final String targetHostBaseUrl;
+    private final String virtualHost;
+    private final String proxyHost;
+    private final int proxyPort;
+    private final ProxyType proxyType;
+
+    CompositePartitionKey(String targetHostBaseUrl, String virtualHost, String proxyHost, int proxyPort, ProxyType proxyType) {
+      this.targetHostBaseUrl = targetHostBaseUrl;
+      this.virtualHost = virtualHost;
+      this.proxyHost = proxyHost;
+      this.proxyPort = proxyPort;
+      this.proxyType = proxyType;
     }
 
-    Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
 
-    enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
+      CompositePartitionKey that = (CompositePartitionKey) o;
 
-        INSTANCE;
+      if (proxyPort != that.proxyPort) return false;
+      if (targetHostBaseUrl != null ? !targetHostBaseUrl.equals(that.targetHostBaseUrl) : that.targetHostBaseUrl != null)
+        return false;
+      if (virtualHost != null ? !virtualHost.equals(that.virtualHost) : that.virtualHost != null) return false;
+      if (proxyHost != null ? !proxyHost.equals(that.proxyHost) : that.proxyHost != null) return false;
+      return proxyType == that.proxyType;
+    }
 
-        public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer) {
-            String targetHostBaseUrl = virtualHost != null ? virtualHost : HttpUtils.getBaseUrl(uri);
-            if (proxyServer != null) {
-                return uri.isSecured() ? //
-                new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getSecuredPort(), true, targetHostBaseUrl)
-                        : new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getPort(), false, targetHostBaseUrl);
-            } else {
-                return targetHostBaseUrl;
-            }
-        }
+    @Override
+    public int hashCode() {
+      int result = targetHostBaseUrl != null ? targetHostBaseUrl.hashCode() : 0;
+      result = 31 * result + (virtualHost != null ? virtualHost.hashCode() : 0);
+      result = 31 * result + (proxyHost != null ? proxyHost.hashCode() : 0);
+      result = 31 * result + proxyPort;
+      result = 31 * result + (proxyType != null ? proxyType.hashCode() : 0);
+      return result;
+    }
+
+    @Override
+    public String toString() {
+      return "CompositePartitionKey(" +
+              "targetHostBaseUrl=" + targetHostBaseUrl +
+              ", virtualHost=" + virtualHost +
+              ", proxyHost=" + proxyHost +
+              ", proxyPort=" + proxyPort +
+              ", proxyType=" + proxyType;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
index a1fb0fd42..b9fb306cf 100644
--- a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
@@ -1,25 +1,25 @@
 package org.asynchttpclient.channel;
 
-import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
-
 import org.asynchttpclient.Request;
 
+import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
+
 /**
  * Connection strategy implementing standard HTTP 1.0/1.1 behavior.
  */
 public class DefaultKeepAliveStrategy implements KeepAliveStrategy {
 
-    /**
-     * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
-     */
-    @Override
-    public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
-        return HttpUtil.isKeepAlive(response)//
-                && HttpUtil.isKeepAlive(request)
-                // support non standard Proxy-Connection
-                && !response.headers().contains("Proxy-Connection", CLOSE, true);
-    }
+  /**
+   * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
+   */
+  @Override
+  public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
+    return HttpUtil.isKeepAlive(response)
+            && HttpUtil.isKeepAlive(request)
+            // support non standard Proxy-Connection
+            && !response.headers().contains("Proxy-Connection", CLOSE, true);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
index db24724e4..4d619f222 100644
--- a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
@@ -15,18 +15,17 @@
 
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
-
 import org.asynchttpclient.Request;
 
 public interface KeepAliveStrategy {
 
-    /**
-     * Determines whether the connection should be kept alive after this HTTP message exchange.
-     * 
-     * @param ahcRequest the Request, as built by AHC
-     * @param nettyRequest the HTTP request sent to Netty
-     * @param nettyResponse the HTTP response received from Netty
-     * @return true if the connection should be kept alive, false if it should be closed.
-     */
-    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
+  /**
+   * Determines whether the connection should be kept alive after this HTTP message exchange.
+   *
+   * @param ahcRequest    the Request, as built by AHC
+   * @param nettyRequest  the HTTP request sent to Netty
+   * @param nettyResponse the HTTP response received from Netty
+   * @return true if the connection should be kept alive, false if it should be closed.
+   */
+  boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
index 281f3f127..eb6a6abf2 100644
--- a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
@@ -21,38 +21,38 @@
 
 public enum NoopChannelPool implements ChannelPool {
 
-    INSTANCE;
-
-    @Override
-    public boolean offer(Channel channel, Object partitionKey) {
-        return false;
-    }
-
-    @Override
-    public Channel poll(Object partitionKey) {
-        return null;
-    }
-
-    @Override
-    public boolean removeAll(Channel channel) {
-        return false;
-    }
-
-    @Override
-    public boolean isOpen() {
-        return true;
-    }
-
-    @Override
-    public void destroy() {
-    }
-
-    @Override
-    public void flushPartitions(Predicate<Object> predicate) {
-    }
-
-    @Override
-    public Map<String, Long> getIdleChannelCountPerHost() {
-        return Collections.emptyMap();
-    }
+  INSTANCE;
+
+  @Override
+  public boolean offer(Channel channel, Object partitionKey) {
+    return false;
+  }
+
+  @Override
+  public Channel poll(Object partitionKey) {
+    return null;
+  }
+
+  @Override
+  public boolean removeAll(Channel channel) {
+    return false;
+  }
+
+  @Override
+  public boolean isOpen() {
+    return true;
+  }
+
+  @Override
+  public void destroy() {
+  }
+
+  @Override
+  public void flushPartitions(Predicate<Object> predicate) {
+  }
+
+  @Override
+  public Map<String, Long> getIdleChannelCountPerHost() {
+    return Collections.emptyMap();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index df1c4cfb8..fa073bc82 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -12,202 +12,281 @@
  */
 package org.asynchttpclient.config;
 
-public final class AsyncHttpClientConfigDefaults {
-
-    private AsyncHttpClientConfigDefaults() {
-    }
-
-    public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
-
-    public static String defaultThreadPoolName() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "threadPoolName");
-    }
-
-    public static int defaultMaxConnections() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnections");
-    }
-
-    public static int defaultMaxConnectionsPerHost() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnectionsPerHost");
-    }
-
-    public static int defaultConnectTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectTimeout");
-    }
-
-    public static int defaultPooledConnectionIdleTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "pooledConnectionIdleTimeout");
-    }
-
-    public static int defaultConnectionPoolCleanerPeriod() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionPoolCleanerPeriod");
-    }
-
-    public static int defaultReadTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "readTimeout");
-    }
-
-    public static int defaultRequestTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "requestTimeout");
-    }
-
-    public static int defaultConnectionTtl() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionTtl");
-    }
-
-    public static boolean defaultFollowRedirect() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "followRedirect");
-    }
-
-    public static int defaultMaxRedirects() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRedirects");
-    }
-
-    public static boolean defaultCompressionEnforced() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "compressionEnforced");
-    }
-
-    public static String defaultUserAgent() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "userAgent");
-    }
-
-    public static String[] defaultEnabledProtocols() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledProtocols");
-    }
-
-    public static String[] defaultEnabledCipherSuites() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledCipherSuites");
-    }
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
 
-    public static boolean defaultUseProxySelector() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxySelector");
-    }
+public final class AsyncHttpClientConfigDefaults {
 
-    public static boolean defaultUseProxyProperties() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties");
-    }
+  public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
+  public static final String THREAD_POOL_NAME_CONFIG = "threadPoolName";
+  public static final String MAX_CONNECTIONS_CONFIG = "maxConnections";
+  public static final String MAX_CONNECTIONS_PER_HOST_CONFIG = "maxConnectionsPerHost";
+  public static final String ACQUIRE_FREE_CHANNEL_TIMEOUT = "acquireFreeChannelTimeout";
+  public static final String CONNECTION_TIMEOUT_CONFIG = "connectTimeout";
+  public static final String POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG = "pooledConnectionIdleTimeout";
+  public static final String CONNECTION_POOL_CLEANER_PERIOD_CONFIG = "connectionPoolCleanerPeriod";
+  public static final String READ_TIMEOUT_CONFIG = "readTimeout";
+  public static final String REQUEST_TIMEOUT_CONFIG = "requestTimeout";
+  public static final String CONNECTION_TTL_CONFIG = "connectionTtl";
+  public static final String FOLLOW_REDIRECT_CONFIG = "followRedirect";
+  public static final String MAX_REDIRECTS_CONFIG = "maxRedirects";
+  public static final String COMPRESSION_ENFORCED_CONFIG = "compressionEnforced";
+  public static final String USER_AGENT_CONFIG = "userAgent";
+  public static final String ENABLED_PROTOCOLS_CONFIG = "enabledProtocols";
+  public static final String ENABLED_CIPHER_SUITES_CONFIG = "enabledCipherSuites";
+  public static final String FILTER_INSECURE_CIPHER_SUITES_CONFIG = "filterInsecureCipherSuites";
+  public static final String USE_PROXY_SELECTOR_CONFIG = "useProxySelector";
+  public static final String USE_PROXY_PROPERTIES_CONFIG = "useProxyProperties";
+  public static final String VALIDATE_RESPONSE_HEADERS_CONFIG = "validateResponseHeaders";
+  public static final String AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG = "aggregateWebSocketFrameFragments";
+  public static final String ENABLE_WEBSOCKET_COMPRESSION_CONFIG = "enableWebSocketCompression";
+  public static final String STRICT_302_HANDLING_CONFIG = "strict302Handling";
+  public static final String KEEP_ALIVE_CONFIG = "keepAlive";
+  public static final String MAX_REQUEST_RETRY_CONFIG = "maxRequestRetry";
+  public static final String DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG = "disableUrlEncodingForBoundRequests";
+  public static final String USE_LAX_COOKIE_ENCODER_CONFIG = "useLaxCookieEncoder";
+  public static final String USE_OPEN_SSL_CONFIG = "useOpenSsl";
+  public static final String USE_INSECURE_TRUST_MANAGER_CONFIG = "useInsecureTrustManager";
+  public static final String DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG = "disableHttpsEndpointIdentificationAlgorithm";
+  public static final String SSL_SESSION_CACHE_SIZE_CONFIG = "sslSessionCacheSize";
+  public static final String SSL_SESSION_TIMEOUT_CONFIG = "sslSessionTimeout";
+  public static final String TCP_NO_DELAY_CONFIG = "tcpNoDelay";
+  public static final String SO_REUSE_ADDRESS_CONFIG = "soReuseAddress";
+  public static final String SO_LINGER_CONFIG = "soLinger";
+  public static final String SO_SND_BUF_CONFIG = "soSndBuf";
+  public static final String SO_RCV_BUF_CONFIG = "soRcvBuf";
+  public static final String HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG = "httpClientCodecMaxInitialLineLength";
+  public static final String HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG = "httpClientCodecMaxHeaderSize";
+  public static final String HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG = "httpClientCodecMaxChunkSize";
+  public static final String HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG = "httpClientCodecInitialBufferSize";
+  public static final String DISABLE_ZERO_COPY_CONFIG = "disableZeroCopy";
+  public static final String HANDSHAKE_TIMEOUT_CONFIG = "handshakeTimeout";
+  public static final String CHUNKED_FILE_CHUNK_SIZE_CONFIG = "chunkedFileChunkSize";
+  public static final String WEBSOCKET_MAX_BUFFER_SIZE_CONFIG = "webSocketMaxBufferSize";
+  public static final String WEBSOCKET_MAX_FRAME_SIZE_CONFIG = "webSocketMaxFrameSize";
+  public static final String KEEP_ENCODING_HEADER_CONFIG = "keepEncodingHeader";
+  public static final String SHUTDOWN_QUIET_PERIOD_CONFIG = "shutdownQuietPeriod";
+  public static final String SHUTDOWN_TIMEOUT_CONFIG = "shutdownTimeout";
+  public static final String USE_NATIVE_TRANSPORT_CONFIG = "useNativeTransport";
+  public static final String IO_THREADS_COUNT_CONFIG = "ioThreadsCount";
+
+  public static final String AHC_VERSION;
+
+  static {
+    try (InputStream is = AsyncHttpClientConfigDefaults.class.getResourceAsStream("ahc-version.properties")) {
+      Properties prop = new Properties();
+      prop.load(is);
+      AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
+    } catch (IOException e) {
+      throw new ExceptionInInitializerError(e);
+    }
+  }
+
+  private AsyncHttpClientConfigDefaults() {
+  }
+
+  public static String defaultThreadPoolName() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + THREAD_POOL_NAME_CONFIG);
+  }
+
+  public static int defaultMaxConnections() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_CONNECTIONS_CONFIG);
+  }
+
+  public static int defaultMaxConnectionsPerHost() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_CONNECTIONS_PER_HOST_CONFIG);
+  }
+
+  public static int defaultAcquireFreeChannelTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + ACQUIRE_FREE_CHANNEL_TIMEOUT);
+  }
+
+  public static int defaultConnectTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_TIMEOUT_CONFIG);
+  }
+
+  public static int defaultPooledConnectionIdleTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG);
+  }
+
+  public static int defaultConnectionPoolCleanerPeriod() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_POOL_CLEANER_PERIOD_CONFIG);
+  }
+
+  public static int defaultReadTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + READ_TIMEOUT_CONFIG);
+  }
+
+  public static int defaultRequestTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + REQUEST_TIMEOUT_CONFIG);
+  }
+
+  public static int defaultConnectionTtl() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_TTL_CONFIG);
+  }
+
+  public static boolean defaultFollowRedirect() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + FOLLOW_REDIRECT_CONFIG);
+  }
+
+  public static int defaultMaxRedirects() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_REDIRECTS_CONFIG);
+  }
+
+  public static boolean defaultCompressionEnforced() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + COMPRESSION_ENFORCED_CONFIG);
+  }
+
+  public static String defaultUserAgent() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + USER_AGENT_CONFIG);
+  }
+
+  public static String[] defaultEnabledProtocols() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + ENABLED_PROTOCOLS_CONFIG);
+  }
+
+  public static String[] defaultEnabledCipherSuites() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + ENABLED_CIPHER_SUITES_CONFIG);
+  }
+
+  public static boolean defaultFilterInsecureCipherSuites() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + FILTER_INSECURE_CIPHER_SUITES_CONFIG);
+  }
+
+  public static boolean defaultUseProxySelector() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_PROXY_SELECTOR_CONFIG);
+  }
+
+  public static boolean defaultUseProxyProperties() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_PROXY_PROPERTIES_CONFIG);
+  }
+
+  public static boolean defaultValidateResponseHeaders() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + VALIDATE_RESPONSE_HEADERS_CONFIG);
+  }
 
-    public static boolean defaultValidateResponseHeaders() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "validateResponseHeaders");
-    }
+  public static boolean defaultAggregateWebSocketFrameFragments() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG);
+  }
 
-    public static boolean defaultAggregateWebSocketFrameFragments() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "aggregateWebSocketFrameFragments");
-    }
+  public static boolean defaultEnableWebSocketCompression() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + ENABLE_WEBSOCKET_COMPRESSION_CONFIG);
+  }
 
-    public static boolean defaultStrict302Handling() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
-    }
+  public static boolean defaultStrict302Handling() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + STRICT_302_HANDLING_CONFIG);
+  }
 
-    public static boolean defaultKeepAlive() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepAlive");
-    }
+  public static boolean defaultKeepAlive() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + KEEP_ALIVE_CONFIG);
+  }
 
-    public static int defaultMaxRequestRetry() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRequestRetry");
-    }
+  public static int defaultMaxRequestRetry() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_REQUEST_RETRY_CONFIG);
+  }
 
-    public static boolean defaultDisableUrlEncodingForBoundRequests() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableUrlEncodingForBoundRequests");
-    }
+  public static boolean defaultDisableUrlEncodingForBoundRequests() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG);
+  }
 
-    public static boolean defaultUseLaxCookieEncoder() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useLaxCookieEncoder");
-    }
+  public static boolean defaultUseLaxCookieEncoder() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_LAX_COOKIE_ENCODER_CONFIG);
+  }
 
-    public static boolean defaultUseOpenSsl() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useOpenSsl");
-    }
+  public static boolean defaultUseOpenSsl() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_OPEN_SSL_CONFIG);
+  }
 
-    public static boolean defaultUseInsecureTrustManager() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useInsecureTrustManager");
-    }
+  public static boolean defaultUseInsecureTrustManager() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_INSECURE_TRUST_MANAGER_CONFIG);
+  }
 
-    public static boolean defaultDisableHttpsEndpointIdentificationAlgorithm() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableHttpsEndpointIdentificationAlgorithm");
-    }
+  public static boolean defaultDisableHttpsEndpointIdentificationAlgorithm() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG);
+  }
 
-    public static int defaultSslSessionCacheSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionCacheSize");
-    }
+  public static int defaultSslSessionCacheSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SSL_SESSION_CACHE_SIZE_CONFIG);
+  }
 
-    public static int defaultSslSessionTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
-    }
+  public static int defaultSslSessionTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SSL_SESSION_TIMEOUT_CONFIG);
+  }
 
-    public static boolean defaultTcpNoDelay() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "tcpNoDelay");
-    }
+  public static boolean defaultTcpNoDelay() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + TCP_NO_DELAY_CONFIG);
+  }
 
-    public static boolean defaultSoReuseAddress() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "soReuseAddress");
-    }
+  public static boolean defaultSoReuseAddress() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + SO_REUSE_ADDRESS_CONFIG);
+  }
 
-    public static int defaultSoLinger() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soLinger");
-    }
+  public static int defaultSoLinger() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_LINGER_CONFIG);
+  }
 
-    public static int defaultSoSndBuf() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soSndBuf");
-    }
+  public static int defaultSoSndBuf() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_SND_BUF_CONFIG);
+  }
 
-    public static int defaultSoRcvBuf() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soRcvBuf");
-    }
+  public static int defaultSoRcvBuf() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_RCV_BUF_CONFIG);
+  }
 
-    public static int defaultHttpClientCodecMaxInitialLineLength() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxInitialLineLength");
-    }
+  public static int defaultHttpClientCodecMaxInitialLineLength() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG);
+  }
 
-    public static int defaultHttpClientCodecMaxHeaderSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxHeaderSize");
-    }
+  public static int defaultHttpClientCodecMaxHeaderSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG);
+  }
 
-    public static int defaultHttpClientCodecMaxChunkSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxChunkSize");
-    }
+  public static int defaultHttpClientCodecMaxChunkSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG);
+  }
 
-    public static int defaultHttpClientCodecInitialBufferSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecInitialBufferSize");
-    }
+  public static int defaultHttpClientCodecInitialBufferSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG);
+  }
 
-    public static boolean defaultDisableZeroCopy() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableZeroCopy");
-    }
+  public static boolean defaultDisableZeroCopy() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_ZERO_COPY_CONFIG);
+  }
 
-    public static int defaultHandshakeTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "handshakeTimeout");
-    }
+  public static int defaultHandshakeTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HANDSHAKE_TIMEOUT_CONFIG);
+  }
 
-    public static int defaultChunkedFileChunkSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "chunkedFileChunkSize");
-    }
+  public static int defaultChunkedFileChunkSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CHUNKED_FILE_CHUNK_SIZE_CONFIG);
+  }
 
-    public static int defaultWebSocketMaxBufferSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxBufferSize");
-    }
+  public static int defaultWebSocketMaxBufferSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + WEBSOCKET_MAX_BUFFER_SIZE_CONFIG);
+  }
 
-    public static int defaultWebSocketMaxFrameSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxFrameSize");
-    }
+  public static int defaultWebSocketMaxFrameSize() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + WEBSOCKET_MAX_FRAME_SIZE_CONFIG);
+  }
 
-    public static boolean defaultKeepEncodingHeader() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepEncodingHeader");
-    }
+  public static boolean defaultKeepEncodingHeader() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + KEEP_ENCODING_HEADER_CONFIG);
+  }
 
-    public static int defaultShutdownQuietPeriod() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "shutdownQuietPeriod");
-    }
+  public static int defaultShutdownQuietPeriod() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SHUTDOWN_QUIET_PERIOD_CONFIG);
+  }
 
-    public static int defaultShutdownTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "shutdownTimeout");
-    }
+  public static int defaultShutdownTimeout() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SHUTDOWN_TIMEOUT_CONFIG);
+  }
 
-    public static boolean defaultUseNativeTransport() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
-    }
+  public static boolean defaultUseNativeTransport() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_NATIVE_TRANSPORT_CONFIG);
+  }
 
-    public static int defaultIoThreadsCount() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "ioThreadsCount");
-    }
+  public static int defaultIoThreadsCount() {
+    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + IO_THREADS_COUNT_CONFIG);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index 80ebd712a..140119326 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -2,124 +2,91 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
 public class AsyncHttpClientConfigHelper {
 
-    private static volatile Config config;
+  private static volatile Config config;
 
-    public static Config getAsyncHttpClientConfig() {
-        if (config == null) {
-            config = new Config();
-        }
-
-        return config;
+  public static Config getAsyncHttpClientConfig() {
+    if (config == null) {
+      config = new Config();
     }
 
-    /**
-     * This method invalidates the property caches. So if a system property has been changed and the effect of this change is to be seen then call reloadProperties() and then
-     * getAsyncHttpClientConfig() to get the new property values.
-     */
-    public static void reloadProperties() {
-        if (config != null)
-            config.reload();
-    }
+    return config;
+  }
 
-    public static class Config {
+  /**
+   * This method invalidates the property caches. So if a system property has been changed and the effect of this change is to be seen then call reloadProperties() and then
+   * getAsyncHttpClientConfig() to get the new property values.
+   */
+  public static void reloadProperties() {
+    if (config != null)
+      config.reload();
+  }
 
-        public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
-        public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
+  public static class Config {
 
-        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
-        private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES, true);
-        private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
+    public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
+    public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
 
-        public void reload() {
-            customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
-            propsCache.clear();
-        }
+    private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
+    private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES, true);
+    private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
 
-        private Properties parsePropertiesFile(String file, boolean required) {
-            Properties props = new Properties();
-
-            List<ClassLoader> cls = new ArrayList<>();
-
-            ClassLoader cl = Thread.currentThread().getContextClassLoader();
-            if (cl != null) {
-                cls.add(cl);
-            }
-            cl = getClass().getClassLoader();
-            if (cl != null) {
-                cls.add(cl);
-            }
-            cl = ClassLoader.getSystemClassLoader();
-            if (cl != null) {
-                cls.add(cl);
-            }
-
-            InputStream is = null;
-            for (ClassLoader classLoader : cls) {
-                is = classLoader.getResourceAsStream(file);
-                if (is != null) {
-                    break;
-                }
-            }
-
-            if (is != null) {
-                try {
-                    props.load(is);
-                } catch (IOException e) {
-                    throw new IllegalArgumentException("Can't parse config file " + file, e);
-                }
-            } else if (required) {
-                throw new IllegalArgumentException("Can't locate config file " + file);
-            }
-
-            return props;
-        }
+    public void reload() {
+      customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
+      propsCache.clear();
+    }
 
-        public String getString(String key) {
-            return propsCache.computeIfAbsent(key, k -> {
-                String value = System.getProperty(k);
-                if (value == null)
-                    value = customProperties.getProperty(k);
-                if (value == null)
-                    value = defaultProperties.getProperty(k);
-                return value;
-            });
-        }
+    private Properties parsePropertiesFile(String file, boolean required) {
+      Properties props = new Properties();
 
-        public String[] getStringArray(String key) {
-            String s = getString(key);
-            s = s.trim();
-            if (s.isEmpty()) {
-                return null;
-            }
-            String[] rawArray = s.split(",");
-            String[] array = new String[rawArray.length];
-            for (int i = 0; i < rawArray.length; i++)
-                array[i] = rawArray[i].trim();
-            return array;
+      InputStream is = getClass().getResourceAsStream(file);
+      if (is != null) {
+        try {
+          props.load(is);
+        } catch (IOException e) {
+          throw new IllegalArgumentException("Can't parse config file " + file, e);
         }
+      } else if (required) {
+        throw new IllegalArgumentException("Can't locate config file " + file);
+      }
 
-        public int getInt(String key) {
-            return Integer.parseInt(getString(key));
-        }
+      return props;
+    }
 
-        public long getLong(String key) {
-            return Long.parseLong(getString(key));
-        }
+    public String getString(String key) {
+      return propsCache.computeIfAbsent(key, k -> {
+        String value = System.getProperty(k);
+        if (value == null)
+          value = customProperties.getProperty(k);
+        if (value == null)
+          value = defaultProperties.getProperty(k);
+        return value;
+      });
+    }
 
-        public Integer getInteger(String key) {
-            String s = getString(key);
-            return s != null ? Integer.valueOf(s) : null;
-        }
+    public String[] getStringArray(String key) {
+      String s = getString(key);
+      s = s.trim();
+      if (s.isEmpty()) {
+        return null;
+      }
+      String[] rawArray = s.split(",");
+      String[] array = new String[rawArray.length];
+      for (int i = 0; i < rawArray.length; i++)
+        array[i] = rawArray[i].trim();
+      return array;
+    }
 
-        public boolean getBoolean(String key) {
-            return Boolean.parseBoolean(getString(key));
-        }
+    public int getInt(String key) {
+      return Integer.parseInt(getString(key));
+    }
+
+    public boolean getBoolean(String key) {
+      return Boolean.parseBoolean(getString(key));
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java b/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java
new file mode 100644
index 000000000..0c5ad544e
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.cookie;
+
+import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
+
+import java.net.CookieManager;
+import java.util.List;
+import java.util.function.Predicate;
+
+/**
+ * This interface represents an abstract store for {@link Cookie} objects.
+ *
+ * <p>{@link CookieManager} will call {@code CookieStore.add} to save cookies
+ * for every incoming HTTP response, and call {@code CookieStore.get} to
+ * retrieve cookie for every outgoing HTTP request. A CookieStore
+ * is responsible for removing HttpCookie instances which have expired.
+ *
+ * @since 2.1
+ */
+public interface CookieStore {
+  /**
+   * Adds one {@link Cookie} to the store. This is called for every incoming HTTP response.
+   * If the given cookie has already expired it will not be added, but existing values will still be removed.
+   *
+   * <p>A cookie to store may or may not be associated with an URI. If it
+   * is not associated with an URI, the cookie's domain and path attribute
+   * will indicate where it comes from. If it is associated with an URI and
+   * its domain and path attribute are not specified, given URI will indicate
+   * where this cookie comes from.
+   *
+   * <p>If a cookie corresponding to the given URI already exists,
+   * then it is replaced with the new one.
+   *
+   * @param uri    the {@link Uri uri} this cookie associated with. if {@code null}, this cookie will not be associated with an URI
+   * @param cookie the {@link Cookie cookie} to be added
+   */
+  void add(Uri uri, Cookie cookie);
+
+  /**
+   * Retrieve cookies associated with given URI, or whose domain matches the given URI. Only cookies that
+   * have not expired are returned. This is called for every outgoing HTTP request.
+   *
+   * @param uri the {@link Uri uri} associated with the cookies to be returned
+   * @return an immutable list of Cookie, return empty list if no cookies match the given URI
+   */
+  List<Cookie> get(Uri uri);
+
+  /**
+   * Get all not-expired cookies in cookie store.
+   *
+   * @return an immutable list of http cookies;
+   * return empty list if there's no http cookie in store
+   */
+  List<Cookie> getAll();
+
+  /**
+   * Remove a cookie from store.
+   *
+   * @param predicate that indicates what cookies to remove
+   * @return {@code true} if this store contained the specified cookie
+   * @throws NullPointerException if {@code cookie} is {@code null}
+   */
+  boolean remove(Predicate<Cookie> predicate);
+
+  /**
+   * Remove all cookies in this cookie store.
+   *
+   * @return true if any cookies were purged.
+   */
+  boolean clear();
+}
diff --git a/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java b/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
new file mode 100644
index 000000000..277db387c
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.cookie;
+
+import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.Assertions;
+import org.asynchttpclient.util.MiscUtils;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+public final class ThreadSafeCookieStore implements CookieStore {
+
+  private Map<CookieKey, StoredCookie> cookieJar = new ConcurrentHashMap<>();
+
+  @Override
+  public void add(Uri uri, Cookie cookie) {
+    String thisRequestDomain = requestDomain(uri);
+    String thisRequestPath = requestPath(uri);
+
+    add(thisRequestDomain, thisRequestPath, cookie);
+  }
+
+  @Override
+  public List<Cookie> get(Uri uri) {
+    return get(requestDomain(uri), requestPath(uri), uri.isSecured());
+  }
+
+  @Override
+  public List<Cookie> getAll() {
+    final boolean[] removeExpired = {false};
+    List<Cookie> result = cookieJar
+            .entrySet()
+            .stream()
+            .filter(pair -> {
+              boolean hasCookieExpired = hasCookieExpired(pair.getValue().cookie, pair.getValue().createdAt);
+              if (hasCookieExpired && !removeExpired[0])
+                removeExpired[0] = true;
+              return !hasCookieExpired;
+            })
+            .map(pair -> pair.getValue().cookie)
+            .collect(Collectors.toList());
+
+    if (removeExpired[0])
+      removeExpired();
+
+    return result;
+  }
+
+  @Override
+  public boolean remove(Predicate<Cookie> predicate) {
+    return cookieJar.entrySet().removeIf(v -> predicate.test(v.getValue().cookie));
+  }
+
+  @Override
+  public boolean clear() {
+    boolean result = !cookieJar.isEmpty();
+    cookieJar.clear();
+    return result;
+  }
+
+  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+  private String requestDomain(Uri requestUri) {
+    return requestUri.getHost().toLowerCase();
+  }
+
+  private String requestPath(Uri requestUri) {
+    return requestUri.getPath().isEmpty() ? "/" : requestUri.getPath();
+  }
+
+  // rfc6265#section-5.2.3
+  // Let cookie-domain be the attribute-value without the leading %x2E (".") character.
+  private AbstractMap.SimpleEntry<String, Boolean> cookieDomain(String cookieDomain, String requestDomain) {
+    if (cookieDomain != null) {
+      String normalizedCookieDomain = cookieDomain.toLowerCase();
+      return new AbstractMap.SimpleEntry<>(
+              (!cookieDomain.isEmpty() && cookieDomain.charAt(0) == '.') ?
+                      normalizedCookieDomain.substring(1) :
+                      normalizedCookieDomain, false);
+    } else
+      return new AbstractMap.SimpleEntry<>(requestDomain, true);
+  }
+
+  // rfc6265#section-5.2.4
+  private String cookiePath(String rawCookiePath, String requestPath) {
+    if (MiscUtils.isNonEmpty(rawCookiePath) && rawCookiePath.charAt(0) == '/') {
+      return rawCookiePath;
+    } else {
+      // rfc6265#section-5.1.4
+      int indexOfLastSlash = requestPath.lastIndexOf('/');
+      if (!requestPath.isEmpty() && requestPath.charAt(0) == '/' && indexOfLastSlash > 0)
+        return requestPath.substring(0, indexOfLastSlash);
+      else
+        return "/";
+    }
+  }
+
+  private boolean hasCookieExpired(Cookie cookie, long whenCreated) {
+    // if not specify max-age, this cookie should be discarded when user agent is to be closed, but it is not expired.
+    if (cookie.maxAge() == Cookie.UNDEFINED_MAX_AGE)
+      return false;
+
+    if (cookie.maxAge() <= 0)
+      return true;
+
+    if (whenCreated > 0) {
+      long deltaSecond = (System.currentTimeMillis() - whenCreated) / 1000;
+      return deltaSecond > cookie.maxAge();
+    } else
+      return false;
+  }
+
+  // rfc6265#section-5.1.3
+  // check "The string is a host name (i.e., not an IP address)" ignored
+  private boolean domainsMatch(String cookieDomain, String requestDomain, boolean hostOnly) {
+    return (hostOnly && Objects.equals(requestDomain, cookieDomain)) ||
+            (Objects.equals(requestDomain, cookieDomain) || requestDomain.endsWith("." + cookieDomain));
+  }
+
+  // rfc6265#section-5.1.4
+  private boolean pathsMatch(String cookiePath, String requestPath) {
+    return Objects.equals(cookiePath, requestPath) ||
+            (requestPath.startsWith(cookiePath) && (cookiePath.charAt(cookiePath.length() - 1) == '/' || requestPath.charAt(cookiePath.length()) == '/'));
+  }
+
+  private void add(String requestDomain, String requestPath, Cookie cookie) {
+
+    AbstractMap.SimpleEntry<String, Boolean> pair = cookieDomain(cookie.domain(), requestDomain);
+    String keyDomain = pair.getKey();
+    boolean hostOnly = pair.getValue();
+    String keyPath = cookiePath(cookie.path(), requestPath);
+    CookieKey key = new CookieKey(cookie.name().toLowerCase(), keyDomain, keyPath);
+
+    if (hasCookieExpired(cookie, 0))
+      cookieJar.remove(key);
+    else
+      cookieJar.put(key, new StoredCookie(cookie, hostOnly, cookie.maxAge() != Cookie.UNDEFINED_MAX_AGE));
+  }
+
+  private List<Cookie> get(String domain, String path, boolean secure) {
+
+    final boolean[] removeExpired = {false};
+
+    List<Cookie> result = cookieJar.entrySet().stream().filter(pair -> {
+      CookieKey key = pair.getKey();
+      StoredCookie storedCookie = pair.getValue();
+      boolean hasCookieExpired = hasCookieExpired(storedCookie.cookie, storedCookie.createdAt);
+      if (hasCookieExpired && !removeExpired[0])
+        removeExpired[0] = true;
+      return !hasCookieExpired && domainsMatch(key.domain, domain, storedCookie.hostOnly) && pathsMatch(key.path, path) && (secure || !storedCookie.cookie.isSecure());
+    }).map(v -> v.getValue().cookie).collect(Collectors.toList());
+
+    if (removeExpired[0])
+      removeExpired();
+
+    return result;
+  }
+
+  private void removeExpired() {
+    cookieJar.entrySet().removeIf(v -> hasCookieExpired(v.getValue().cookie, v.getValue().createdAt));
+  }
+
+  private static class CookieKey implements Comparable<CookieKey> {
+    final String name;
+    final String domain;
+    final String path;
+
+    CookieKey(String name, String domain, String path) {
+      this.name = name;
+      this.domain = domain;
+      this.path = path;
+    }
+
+    @Override
+    public int compareTo(CookieKey o) {
+      Assertions.assertNotNull(o, "Parameter can't be null");
+      int result;
+      if ((result = this.name.compareTo(o.name)) == 0)
+        if ((result = this.domain.compareTo(o.domain)) == 0)
+          result = this.path.compareTo(o.path);
+
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof CookieKey && this.compareTo((CookieKey) obj) == 0;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = 17;
+      result = 31 * result + name.hashCode();
+      result = 31 * result + domain.hashCode();
+      result = 31 * result + path.hashCode();
+      return result;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("%s: %s; %s", name, domain, path);
+    }
+  }
+
+  private static class StoredCookie {
+    final Cookie cookie;
+    final boolean hostOnly;
+    final boolean persistent;
+    final long createdAt = System.currentTimeMillis();
+
+    StoredCookie(Cookie cookie, boolean hostOnly, boolean persistent) {
+      this.cookie = cookie;
+      this.hostOnly = hostOnly;
+      this.persistent = persistent;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("%s; hostOnly %s; persistent %s", cookie.toString(), hostOnly, persistent);
+    }
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
index e86dd2fa4..d56cac876 100644
--- a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-
 import java.io.IOException;
 
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
 @SuppressWarnings("serial")
 public final class ChannelClosedException extends IOException {
 
-    public static final ChannelClosedException INSTANCE = unknownStackTrace(new ChannelClosedException(), ChannelClosedException.class, "INSTANCE");
+  public static final ChannelClosedException INSTANCE = unknownStackTrace(new ChannelClosedException(), ChannelClosedException.class, "INSTANCE");
 
-    private ChannelClosedException() {
-        super("Channel closed");
-    }
+  private ChannelClosedException() {
+    super("Channel closed");
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
index 5e1dd2df7..3b8367089 100644
--- a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-
 import java.io.IOException;
 
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
 @SuppressWarnings("serial")
 public class PoolAlreadyClosedException extends IOException {
 
-    public static final PoolAlreadyClosedException INSTANCE = unknownStackTrace(new PoolAlreadyClosedException(), PoolAlreadyClosedException.class, "INSTANCE");
+  public static final PoolAlreadyClosedException INSTANCE = unknownStackTrace(new PoolAlreadyClosedException(), PoolAlreadyClosedException.class, "INSTANCE");
 
-    private PoolAlreadyClosedException() {
-        super("Pool is already closed");
-    }
+  private PoolAlreadyClosedException() {
+    super("Pool is already closed");
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
index eeba6ee2d..e1a778e5a 100644
--- a/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-
 import java.io.IOException;
 
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
 @SuppressWarnings("serial")
 public final class RemotelyClosedException extends IOException {
 
-    public static final RemotelyClosedException INSTANCE = unknownStackTrace(new RemotelyClosedException(), RemotelyClosedException.class, "INSTANCE");
+  public static final RemotelyClosedException INSTANCE = unknownStackTrace(new RemotelyClosedException(), RemotelyClosedException.class, "INSTANCE");
 
-    public RemotelyClosedException() {
-        super("Remotely closed");
-    }
+  private RemotelyClosedException() {
+    super("Remotely closed");
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
index 2685e3a95..6f3bc43e1 100644
--- a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
@@ -17,7 +17,7 @@
 @SuppressWarnings("serial")
 public class TooManyConnectionsException extends IOException {
 
-    public TooManyConnectionsException(int max) {
-        super("Too many connections: " + max);
-    }
+  public TooManyConnectionsException(int max) {
+    super("Too many connections: " + max);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
index a08a22ee3..2cec931b9 100644
--- a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
@@ -17,7 +17,7 @@
 @SuppressWarnings("serial")
 public class TooManyConnectionsPerHostException extends IOException {
 
-    public TooManyConnectionsPerHostException(int max) {
-        super("Too many connections: " + max);
-    }
+  public TooManyConnectionsPerHostException(int max) {
+    super("Too many connections: " + max);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
index 74d64e297..b3d3f4761 100644
--- a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
+++ b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -13,13 +13,12 @@
 package org.asynchttpclient.filter;
 
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.IOException;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Request;
 
+import java.io.IOException;
+
 /**
  * A {@link FilterContext} can be used to decorate {@link Request} and {@link AsyncHandler} from a list of {@link RequestFilter}.
  * {@link RequestFilter} gets executed before the HTTP request is made to the remote server. Once the response bytes are
@@ -31,124 +30,124 @@
  * that can be used to decide if the response processing should continue or not. You can stop the current response processing
  * and replay the request but creating a {@link FilterContext}. The {@link org.asynchttpclient.AsyncHttpClient}
  * will interrupt the processing and "replay" the associated {@link Request} instance.
- * 
+ *
  * @param <T> the handler result type
  */
 public class FilterContext<T> {
 
-    private final FilterContextBuilder<T> b;
+  private final FilterContextBuilder<T> b;
+
+  /**
+   * Create a new {@link FilterContext}
+   *
+   * @param b a {@link FilterContextBuilder}
+   */
+  private FilterContext(FilterContextBuilder<T> b) {
+    this.b = b;
+  }
+
+  /**
+   * @return the original or decorated {@link AsyncHandler}
+   */
+  public AsyncHandler<T> getAsyncHandler() {
+    return b.asyncHandler;
+  }
+
+  /**
+   * @return the original or decorated {@link Request}
+   */
+  public Request getRequest() {
+    return b.request;
+  }
+
+  /**
+   * @return the unprocessed response's {@link HttpResponseStatus}
+   */
+  public HttpResponseStatus getResponseStatus() {
+    return b.responseStatus;
+  }
+
+  /**
+   * @return the response {@link HttpHeaders}
+   */
+  public HttpHeaders getResponseHeaders() {
+    return b.headers;
+  }
+
+  /**
+   * @return true if the current response's processing needs to be interrupted and a new {@link Request} be executed.
+   */
+  public boolean replayRequest() {
+    return b.replayRequest;
+  }
+
+  /**
+   * @return the {@link IOException}
+   */
+  public IOException getIOException() {
+    return b.ioException;
+  }
+
+  public static class FilterContextBuilder<T> {
+    private AsyncHandler<T> asyncHandler = null;
+    private Request request = null;
+    private HttpResponseStatus responseStatus = null;
+    private boolean replayRequest = false;
+    private IOException ioException = null;
+    private HttpHeaders headers;
+
+    public FilterContextBuilder() {
+    }
 
-    /**
-     * Create a new {@link FilterContext}
-     *
-     * @param b a {@link FilterContextBuilder}
-     */
-    private FilterContext(FilterContextBuilder<T> b) {
-        this.b = b;
+    public FilterContextBuilder(FilterContext<T> clone) {
+      asyncHandler = clone.getAsyncHandler();
+      request = clone.getRequest();
+      responseStatus = clone.getResponseStatus();
+      replayRequest = clone.replayRequest();
+      ioException = clone.getIOException();
     }
 
-    /**
-     * @return the original or decorated {@link AsyncHandler}
-     */
     public AsyncHandler<T> getAsyncHandler() {
-        return b.asyncHandler;
+      return asyncHandler;
+    }
+
+    public FilterContextBuilder<T> asyncHandler(AsyncHandler<T> asyncHandler) {
+      this.asyncHandler = asyncHandler;
+      return this;
     }
 
-    /**
-     * @return the original or decorated {@link Request}
-     */
     public Request getRequest() {
-        return b.request;
+      return request;
+    }
+
+    public FilterContextBuilder<T> request(Request request) {
+      this.request = request;
+      return this;
     }
 
-    /**
-     * @return the unprocessed response's {@link HttpResponseStatus}
-     */
-    public HttpResponseStatus getResponseStatus() {
-        return b.responseStatus;
+    public FilterContextBuilder<T> responseStatus(HttpResponseStatus responseStatus) {
+      this.responseStatus = responseStatus;
+      return this;
     }
 
-    /**
-     * @return the response {@link HttpHeaders}
-     */
-    public HttpHeaders getResponseHeaders() {
-        return b.headers;
+    public FilterContextBuilder<T> responseHeaders(HttpHeaders headers) {
+      this.headers = headers;
+      return this;
     }
 
-    /**
-     * @return true if the current response's processing needs to be interrupted and a new {@link Request} be executed.
-     */
-    public boolean replayRequest() {
-        return b.replayRequest;
+    public FilterContextBuilder<T> replayRequest(boolean replayRequest) {
+      this.replayRequest = replayRequest;
+      return this;
     }
 
-    /**
-     * @return the {@link IOException}
-     */
-    public IOException getIOException() {
-        return b.ioException;
+    public FilterContextBuilder<T> ioException(IOException ioException) {
+      this.ioException = ioException;
+      return this;
     }
 
-    public static class FilterContextBuilder<T> {
-        private AsyncHandler<T> asyncHandler = null;
-        private Request request = null;
-        private HttpResponseStatus responseStatus = null;
-        private boolean replayRequest = false;
-        private IOException ioException = null;
-        private HttpHeaders headers;
-
-        public FilterContextBuilder() {
-        }
-
-        public FilterContextBuilder(FilterContext<T> clone) {
-            asyncHandler = clone.getAsyncHandler();
-            request = clone.getRequest();
-            responseStatus = clone.getResponseStatus();
-            replayRequest = clone.replayRequest();
-            ioException = clone.getIOException();
-        }
-
-        public AsyncHandler<T> getAsyncHandler() {
-            return asyncHandler;
-        }
-
-        public FilterContextBuilder<T> asyncHandler(AsyncHandler<T> asyncHandler) {
-            this.asyncHandler = asyncHandler;
-            return this;
-        }
-
-        public Request getRequest() {
-            return request;
-        }
-
-        public FilterContextBuilder<T> request(Request request) {
-            this.request = request;
-            return this;
-        }
-
-        public FilterContextBuilder<T> responseStatus(HttpResponseStatus responseStatus) {
-            this.responseStatus = responseStatus;
-            return this;
-        }
-
-        public FilterContextBuilder<T> responseHeaders(HttpHeaders headers) {
-            this.headers = headers;
-            return this;
-        }
-
-        public FilterContextBuilder<T> replayRequest(boolean replayRequest) {
-            this.replayRequest = replayRequest;
-            return this;
-        }
-
-        public FilterContextBuilder<T> ioException(IOException ioException) {
-            this.ioException = ioException;
-            return this;
-        }
-
-        public FilterContext<T> build() {
-            return new FilterContext<>(this);
-        }
+    public FilterContext<T> build() {
+      return new FilterContext<>(this);
     }
+  }
 
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/FilterException.java b/client/src/main/java/org/asynchttpclient/filter/FilterException.java
index a90cf8494..75d36573f 100644
--- a/client/src/main/java/org/asynchttpclient/filter/FilterException.java
+++ b/client/src/main/java/org/asynchttpclient/filter/FilterException.java
@@ -19,11 +19,11 @@
 @SuppressWarnings("serial")
 public class FilterException extends Exception {
 
-    public FilterException(final String message) {
-        super(message);
-    }
+  public FilterException(final String message) {
+    super(message);
+  }
 
-    public FilterException(final String message, final Throwable cause) {
-        super(message, cause);
-    }
+  public FilterException(final String message, final Throwable cause) {
+    super(message, cause);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java b/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
index 71f45b5b4..a8ed41dba 100644
--- a/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
@@ -17,14 +17,14 @@
  */
 public interface IOExceptionFilter {
 
-    /**
-     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link IOExceptionFilter#filter} and will
-     * use the returned {@link FilterContext} to replay the {@link org.asynchttpclient.Request} or abort the processing.
-     *
-     * @param ctx a {@link FilterContext}
-     * @param <T> the handler result type
-     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-     * @throws FilterException to interrupt the filter processing.
-     */
-    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+  /**
+   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link IOExceptionFilter#filter} and will
+   * use the returned {@link FilterContext} to replay the {@link org.asynchttpclient.Request} or abort the processing.
+   *
+   * @param ctx a {@link FilterContext}
+   * @param <T> the handler result type
+   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+   * @throws FilterException to interrupt the filter processing.
+   */
+  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java b/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
index 2f23cf718..60abb266b 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
@@ -1,61 +1,57 @@
 package org.asynchttpclient.filter;
 
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
+import org.asynchttpclient.AsyncHandler;
+
 import java.lang.reflect.Proxy;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.Semaphore;
 
-import org.asynchttpclient.AsyncHandler;
-
 /**
  * Wrapper for {@link AsyncHandler}s to release a permit on {@link AsyncHandler#onCompleted()}. This is done via a dynamic proxy to preserve all interfaces of the wrapped handler.
  */
 public class ReleasePermitOnComplete {
 
-    /**
-     * Wrap handler to release the permit of the semaphore on {@link AsyncHandler#onCompleted()}.
-     * 
-     * @param handler the handler to be wrapped
-     * @param available the Semaphore to be released when the wrapped handler is completed
-     * @param <T> the handler result type
-     * @return the wrapped handler
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> AsyncHandler<T> wrap(final AsyncHandler<T> handler, final Semaphore available) {
-        Class<?> handlerClass = handler.getClass();
-        ClassLoader classLoader = handlerClass.getClassLoader();
-        Class<?>[] interfaces = allInterfaces(handlerClass);
+  /**
+   * Wrap handler to release the permit of the semaphore on {@link AsyncHandler#onCompleted()}.
+   *
+   * @param handler   the handler to be wrapped
+   * @param available the Semaphore to be released when the wrapped handler is completed
+   * @param <T>       the handler result type
+   * @return the wrapped handler
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> AsyncHandler<T> wrap(final AsyncHandler<T> handler, final Semaphore available) {
+    Class<?> handlerClass = handler.getClass();
+    ClassLoader classLoader = handlerClass.getClassLoader();
+    Class<?>[] interfaces = allInterfaces(handlerClass);
 
-        return (AsyncHandler<T>) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() {
-            @Override
-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                try {
-                    return method.invoke(handler, args);
-                } finally {
-                    switch (method.getName()) {
-                    case "onCompleted":
-                    case "onThrowable":
-                        available.release();
-                    default:
-                    }
-                }
-            }
-        });
-    }
-
-    /**
-     * Extract all interfaces of a class.
-     * @param handlerClass the handler class
-     * @return all interfaces implemented by this class
-     */
-    static Class<?>[] allInterfaces(Class<?> handlerClass) {
-        Set<Class<?>> allInterfaces = new HashSet<>();
-        for (Class<?> clazz = handlerClass; clazz != null; clazz = clazz.getSuperclass()) {
-            Collections.addAll(allInterfaces, clazz.getInterfaces());
+    return (AsyncHandler<T>) Proxy.newProxyInstance(classLoader, interfaces, (proxy, method, args) -> {
+        try {
+          return method.invoke(handler, args);
+        } finally {
+          switch (method.getName()) {
+            case "onCompleted":
+            case "onThrowable":
+              available.release();
+            default:
+          }
         }
-        return allInterfaces.toArray(new Class[allInterfaces.size()]);
+    });
+  }
+
+  /**
+   * Extract all interfaces of a class.
+   *
+   * @param handlerClass the handler class
+   * @return all interfaces implemented by this class
+   */
+  private static Class<?>[] allInterfaces(Class<?> handlerClass) {
+    Set<Class<?>> allInterfaces = new HashSet<>();
+    for (Class<?> clazz = handlerClass; clazz != null; clazz = clazz.getSuperclass()) {
+      Collections.addAll(allInterfaces, clazz.getInterfaces());
     }
+    return allInterfaces.toArray(new Class[allInterfaces.size()]);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java b/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
index 823a662b6..ff609c585 100644
--- a/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
@@ -17,15 +17,15 @@
  */
 public interface RequestFilter {
 
-    /**
-     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link RequestFilter#filter} and will use the
-     * returned {@link FilterContext#getRequest()} and {@link FilterContext#getAsyncHandler()} to continue the request
-     * processing.
-     *
-     * @param ctx a {@link FilterContext}
-     * @param <T>  the handler result type
-     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-     * @throws FilterException to interrupt the filter processing.
-     */
-    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+  /**
+   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link RequestFilter#filter} and will use the
+   * returned {@link FilterContext#getRequest()} and {@link FilterContext#getAsyncHandler()} to continue the request
+   * processing.
+   *
+   * @param ctx a {@link FilterContext}
+   * @param <T> the handler result type
+   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+   * @throws FilterException to interrupt the filter processing.
+   */
+  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java b/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
index 404d9ee09..de508c2ad 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
@@ -19,16 +19,16 @@
  */
 public interface ResponseFilter {
 
-    /**
-     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link ResponseFilter#filter} and will use the
-     * returned {@link FilterContext#replayRequest()} and {@link FilterContext#getAsyncHandler()} to decide if the response
-     * processing can continue. If {@link FilterContext#replayRequest()} return true, a new request will be made
-     * using {@link FilterContext#getRequest()} and the current response processing will be ignored.
-     *
-     * @param ctx a {@link FilterContext}
-     * @param <T> the handler result type
-     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-     * @throws FilterException to interrupt the filter processing.
-     */
-    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+  /**
+   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link ResponseFilter#filter} and will use the
+   * returned {@link FilterContext#replayRequest()} and {@link FilterContext#getAsyncHandler()} to decide if the response
+   * processing can continue. If {@link FilterContext#replayRequest()} return true, a new request will be made
+   * using {@link FilterContext#getRequest()} and the current response processing will be ignored.
+   *
+   * @param ctx a {@link FilterContext}
+   * @param <T> the handler result type
+   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+   * @throws FilterException to interrupt the filter processing.
+   */
+  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java b/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
index 4eb280050..a74876971 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
@@ -23,43 +23,43 @@
  * waiting for the response to arrives before executing the next request.
  */
 public class ThrottleRequestFilter implements RequestFilter {
-    private static final Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
-    private final Semaphore available;
-    private final int maxWait;
+  private static final Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
+  private final Semaphore available;
+  private final int maxWait;
 
-    public ThrottleRequestFilter(int maxConnections) {
-        this(maxConnections, Integer.MAX_VALUE);
-    }
+  public ThrottleRequestFilter(int maxConnections) {
+    this(maxConnections, Integer.MAX_VALUE);
+  }
 
-    public ThrottleRequestFilter(int maxConnections, int maxWait) {
-        this(maxConnections, maxWait, false);
-    }
+  public ThrottleRequestFilter(int maxConnections, int maxWait) {
+    this(maxConnections, maxWait, false);
+  }
 
-    public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
-        this.maxWait = maxWait;
-        available = new Semaphore(maxConnections, fair);
-    }
+  public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
+    this.maxWait = maxWait;
+    available = new Semaphore(maxConnections, fair);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-        try {
-            if (logger.isDebugEnabled()) {
-                logger.debug("Current Throttling Status {}", available.availablePermits());
-            }
-            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
-                throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
-                      ctx.getRequest(), ctx.getAsyncHandler()));
-            }
-        } catch (InterruptedException e) {
-            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s",
-                  ctx.getRequest(), ctx.getAsyncHandler()));
-        }
-
-        return new FilterContext.FilterContextBuilder<>(ctx)
-              .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
-              .build();
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+    try {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Current Throttling Status {}", available.availablePermits());
+      }
+      if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
+        throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
+                ctx.getRequest(), ctx.getAsyncHandler()));
+      }
+    } catch (InterruptedException e) {
+      throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s",
+              ctx.getRequest(), ctx.getAsyncHandler()));
     }
+
+    return new FilterContext.FilterContextBuilder<>(ctx)
+            .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
+            .build();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
deleted file mode 100644
index 167b4003d..000000000
--- a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.handler;
-
-import io.netty.channel.Channel;
-
-import java.net.InetSocketAddress;
-import java.util.List;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.netty.request.NettyRequest;
-
-/**
- * This interface hosts new low level callback methods on {@link AsyncHandler}.
- * 
- */
-public interface AsyncHandlerExtensions {
-
-    // ////////// DNS /////////////////
-
-    /**
-     * Notify the callback before hostname resolution
-     * 
-     * @param name the name to be resolved
-     */
-    void onHostnameResolutionAttempt(String name);
-
-    /**
-     * Notify the callback after hostname resolution was successful.
-     * 
-     * @param name the name to be resolved
-     * @param addresses the resolved addresses
-     */
-    void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses);
-
-    /**
-     * Notify the callback after hostname resolution failed.
-     * 
-     * @param name the name to be resolved
-     * @param cause the failure cause
-     */
-    void onHostnameResolutionFailure(String name, Throwable cause);
-
-    // ////////////// TCP CONNECT ////////
-
-    /**
-     * Notify the callback when trying to open a new connection.
-     * 
-     * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
-     * 
-     * @param remoteAddress the address we try to connect to
-     */
-    void onTcpConnectAttempt(InetSocketAddress remoteAddress);
-
-    /**
-     * Notify the callback after a successful connect
-     * 
-     * @param remoteAddress the address we try to connect to
-     * @param connection the connection
-     */
-    void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection);
-
-    /**
-     * Notify the callback after a failed connect.
-     * 
-     * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
-     * 
-     * @param remoteAddress the address we try to connect to
-     * @param cause the cause of the failure
-     */
-    void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause);
-
-    // ////////////// TLS ///////////////
-
-    /**
-     * Notify the callback before TLS handshake
-     */
-    void onTlsHandshakeAttempt();
-
-    /**
-     * Notify the callback after the TLS was successful
-     */
-    void onTlsHandshakeSuccess();
-
-    /**
-     * Notify the callback after the TLS failed
-     * 
-     * @param cause the cause of the failure
-     */
-    void onTlsHandshakeFailure(Throwable cause);
-
-    // /////////// POOLING /////////////
-
-    /**
-     * Notify the callback when trying to fetch a connection from the pool.
-     */
-    void onConnectionPoolAttempt();
-
-    /**
-     * Notify the callback when a new connection was successfully fetched from the pool.
-     * 
-     * @param connection the connection
-     */
-    void onConnectionPooled(Channel connection);
-
-    /**
-     * Notify the callback when trying to offer a connection to the pool.
-     * 
-     * @param connection the connection
-     */
-    void onConnectionOffer(Channel connection);
-
-    // //////////// SENDING //////////////
-
-    /**
-     * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
-     * retry, it will be notified multiple times.
-     * 
-     * @param request the real request object as passed to the provider
-     */
-    void onRequestSend(NettyRequest request);
-
-    /**
-     * Notify the callback every time a request is being retried.
-     */
-    void onRetry();
-}
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
deleted file mode 100644
index 3d6f7d37f..000000000
--- a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.handler;
-
-import org.asynchttpclient.AsyncHandler;
-
-public final class AsyncHandlerExtensionsUtils {
-
-    public static AsyncHandlerExtensions toAsyncHandlerExtensions(AsyncHandler<?> asyncHandler) {
-        return asyncHandler instanceof AsyncHandlerExtensions ? (AsyncHandlerExtensions) asyncHandler : null;
-    }
-
-    private AsyncHandlerExtensionsUtils() {
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
index a203ed5f6..a4ac3d82c 100644
--- a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
@@ -12,8 +12,6 @@
  */
 package org.asynchttpclient.handler;
 
-import io.netty.handler.codec.http.HttpHeaders;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -23,6 +21,8 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 
+import io.netty.handler.codec.http.HttpHeaders;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
@@ -82,222 +82,217 @@
  */
 public class BodyDeferringAsyncHandler implements AsyncHandler<Response> {
 
-    private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
-
-    private final CountDownLatch headersArrived = new CountDownLatch(1);
-
-    private final OutputStream output;
-
-    private boolean responseSet;
-
-    private volatile Response response;
-
-    private volatile Throwable throwable;
-
-    private final Semaphore semaphore = new Semaphore(1);
-
-    public BodyDeferringAsyncHandler(final OutputStream os) {
-        this.output = os;
-        this.responseSet = false;
+  private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
+
+  private final CountDownLatch headersArrived = new CountDownLatch(1);
+
+  private final OutputStream output;
+  private final Semaphore semaphore = new Semaphore(1);
+  private boolean responseSet;
+  private volatile Response response;
+  private volatile Throwable throwable;
+
+  public BodyDeferringAsyncHandler(final OutputStream os) {
+    this.output = os;
+    this.responseSet = false;
+  }
+
+  @Override
+  public void onThrowable(Throwable t) {
+    this.throwable = t;
+    // Counting down to handle error cases too.
+    // In "premature exceptions" cases, the onBodyPartReceived() and
+    // onCompleted()
+    // methods will never be invoked, leaving caller of getResponse() method
+    // blocked forever.
+    try {
+      semaphore.acquire();
+    } catch (InterruptedException e) {
+      // Ignore
+    } finally {
+      headersArrived.countDown();
+      semaphore.release();
     }
 
-    @Override
-    public void onThrowable(Throwable t) {
-        this.throwable = t;
-        // Counting down to handle error cases too.
-        // In "premature exceptions" cases, the onBodyPartReceived() and
-        // onCompleted()
-        // methods will never be invoked, leaving caller of getResponse() method
-        // blocked forever.
-        try {
-            semaphore.acquire();
-        } catch (InterruptedException e) {
-            // Ignore
-        } finally {
-            headersArrived.countDown();
-            semaphore.release();
-        }
-
-        try {
-            closeOut();
-        } catch (IOException e) {
-            // ignore
-        }
+    try {
+      closeOut();
+    } catch (IOException e) {
+      // ignore
     }
-
-    @Override
-    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-        responseBuilder.reset();
-        responseBuilder.accumulate(responseStatus);
-        return State.CONTINUE;
+  }
+
+  @Override
+  public State onStatusReceived(HttpResponseStatus responseStatus) {
+    responseBuilder.reset();
+    responseBuilder.accumulate(responseStatus);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public State onHeadersReceived(HttpHeaders headers) {
+    responseBuilder.accumulate(headers);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) {
+    responseBuilder.accumulate(headers);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public void onRetry() {
+    throw new UnsupportedOperationException(this.getClass().getSimpleName() + " cannot retry a request.");
+  }
+
+  @Override
+  public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    // body arrived, flush headers
+    if (!responseSet) {
+      response = responseBuilder.build();
+      responseSet = true;
+      headersArrived.countDown();
     }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-        responseBuilder.accumulate(headers);
-        return State.CONTINUE;
-    }
-    
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        responseBuilder.accumulate(headers);
-        return State.CONTINUE;
+    output.write(bodyPart.getBodyPartBytes());
+    return State.CONTINUE;
+  }
+
+  protected void closeOut() throws IOException {
+    try {
+      output.flush();
+    } finally {
+      output.close();
     }
+  }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-        // body arrived, flush headers
-        if (!responseSet) {
-            response = responseBuilder.build();
-            responseSet = true;
-            headersArrived.countDown();
-        }
+  @Override
+  public Response onCompleted() throws IOException {
 
-        output.write(bodyPart.getBodyPartBytes());
-        return State.CONTINUE;
+    if (!responseSet) {
+      response = responseBuilder.build();
+      responseSet = true;
     }
 
-    protected void closeOut() throws IOException {
-        try {
-            output.flush();
-        } finally {
-            output.close();
-        }
+    // Counting down to handle error cases too.
+    // In "normal" cases, latch is already at 0 here
+    // But in other cases, for example when because of some error
+    // onBodyPartReceived() is never called, the caller
+    // of getResponse() would remain blocked infinitely.
+    // By contract, onCompleted() is always invoked, even in case of errors
+    headersArrived.countDown();
+
+    closeOut();
+
+    try {
+      semaphore.acquire();
+      if (throwable != null) {
+        throw new IOException(throwable);
+      } else {
+        // sending out current response
+        return responseBuilder.build();
+      }
+    } catch (InterruptedException e) {
+      return null;
+    } finally {
+      semaphore.release();
+    }
+  }
+
+  /**
+   * This method -- unlike Future&lt;Reponse&gt;.get() -- will block only as long,
+   * as headers arrive. This is useful for large transfers, to examine headers
+   * ASAP, and defer body streaming to it's fine destination and prevent
+   * unneeded bandwidth consumption. The response here will contain the very
+   * 1st response from server, so status code and headers, but it might be
+   * incomplete in case of broken servers sending trailing headers. In that
+   * case, the "usual" Future&lt;Response&gt;.get() method will return complete
+   * headers, but multiple invocations of getResponse() will always return the
+   * 1st cached, probably incomplete one. Note: the response returned by this
+   * method will contain everything <em>except</em> the response body itself,
+   * so invoking any method like Response.getResponseBodyXXX() will result in
+   * error! Also, please not that this method might return <code>null</code>
+   * in case of some errors.
+   *
+   * @return a {@link Response}
+   * @throws InterruptedException if the latch is interrupted
+   * @throws IOException          if the handler completed with an exception
+   */
+  public Response getResponse() throws InterruptedException, IOException {
+    // block here as long as headers arrive
+    headersArrived.await();
+
+    try {
+      semaphore.acquire();
+      if (throwable != null) {
+        throw new IOException(throwable.getMessage(), throwable);
+      } else {
+        return response;
+      }
+    } finally {
+      semaphore.release();
     }
+  }
 
-    @Override
-    public Response onCompleted() throws IOException {
+  // ==
 
-        if (!responseSet) {
-            response = responseBuilder.build();
-            responseSet = true;
-        }
+  /**
+   * A simple helper class that is used to perform automatic "join" for async
+   * download and the error checking of the Future of the request.
+   */
+  public static class BodyDeferringInputStream extends FilterInputStream {
+    private final Future<Response> future;
 
-        // Counting down to handle error cases too.
-        // In "normal" cases, latch is already at 0 here
-        // But in other cases, for example when because of some error
-        // onBodyPartReceived() is never called, the caller
-        // of getResponse() would remain blocked infinitely.
-        // By contract, onCompleted() is always invoked, even in case of errors
-        headersArrived.countDown();
+    private final BodyDeferringAsyncHandler bdah;
 
-        closeOut();
+    public BodyDeferringInputStream(final Future<Response> future, final BodyDeferringAsyncHandler bdah, final InputStream in) {
+      super(in);
+      this.future = future;
+      this.bdah = bdah;
+    }
 
-        try {
-            semaphore.acquire();
-            if (throwable != null) {
-                IOException ioe = new IOException(throwable.getMessage());
-                ioe.initCause(throwable);
-                throw ioe;
-            } else {
-                // sending out current response
-                return responseBuilder.build();
-            }
-        } catch (InterruptedException e) {
-            return null;
-        } finally {
-            semaphore.release();
-        }
+    /**
+     * Closes the input stream, and "joins" (wait for complete execution
+     * together with potential exception thrown) of the async request.
+     */
+    @Override
+    public void close() throws IOException {
+      // close
+      super.close();
+      // "join" async request
+      try {
+        getLastResponse();
+      } catch (ExecutionException e) {
+        throw new IOException(e.getMessage(), e.getCause());
+      } catch (InterruptedException e) {
+        throw new IOException(e.getMessage(), e);
+      }
     }
 
     /**
-     * This method -- unlike Future&lt;Reponse&gt;.get() -- will block only as long,
-     * as headers arrive. This is useful for large transfers, to examine headers
-     * ASAP, and defer body streaming to it's fine destination and prevent
-     * unneeded bandwidth consumption. The response here will contain the very
-     * 1st response from server, so status code and headers, but it might be
-     * incomplete in case of broken servers sending trailing headers. In that
-     * case, the "usual" Future&lt;Response&gt;.get() method will return complete
-     * headers, but multiple invocations of getResponse() will always return the
-     * 1st cached, probably incomplete one. Note: the response returned by this
-     * method will contain everything <em>except</em> the response body itself,
-     * so invoking any method like Response.getResponseBodyXXX() will result in
-     * error! Also, please not that this method might return <code>null</code>
-     * in case of some errors.
+     * Delegates to {@link BodyDeferringAsyncHandler#getResponse()}. Will
+     * blocks as long as headers arrives only. Might return
+     * <code>null</code>. See
+     * {@link BodyDeferringAsyncHandler#getResponse()} method for details.
      *
      * @return a {@link Response}
      * @throws InterruptedException if the latch is interrupted
-     * @throws IOException if the handler completed with an exception
+     * @throws IOException          if the handler completed with an exception
      */
-    public Response getResponse() throws InterruptedException, IOException {
-        // block here as long as headers arrive
-        headersArrived.await();
-
-        try {
-            semaphore.acquire();
-            if (throwable != null) {
-                throw new IOException(throwable.getMessage(), throwable);
-            } else {
-                return response;
-            }
-        } finally {
-            semaphore.release();
-        }
+    public Response getAsapResponse() throws InterruptedException, IOException {
+      return bdah.getResponse();
     }
 
-    // ==
-
     /**
-     * A simple helper class that is used to perform automatic "join" for async
-     * download and the error checking of the Future of the request.
+     * Delegates to <code>Future$lt;Response&gt;#get()</code> method. Will block
+     * as long as complete response arrives.
+     *
+     * @return a {@link Response}
+     * @throws ExecutionException   if the computation threw an exception
+     * @throws InterruptedException if the current thread was interrupted
      */
-    public static class BodyDeferringInputStream extends FilterInputStream {
-        private final Future<Response> future;
-
-        private final BodyDeferringAsyncHandler bdah;
-
-        public BodyDeferringInputStream(final Future<Response> future, final BodyDeferringAsyncHandler bdah, final InputStream in) {
-            super(in);
-            this.future = future;
-            this.bdah = bdah;
-        }
-
-        /**
-         * Closes the input stream, and "joins" (wait for complete execution
-         * together with potential exception thrown) of the async request.
-         */
-        @Override
-        public void close() throws IOException {
-            // close
-            super.close();
-            // "join" async request
-            try {
-                getLastResponse();
-            } catch (ExecutionException e) {
-                IOException ioe = new IOException(e.getMessage());
-                ioe.initCause(e.getCause());
-                throw ioe;
-            } catch (InterruptedException e) {
-                IOException ioe = new IOException(e.getMessage());
-                ioe.initCause(e);
-                throw ioe;
-            }
-        }
-
-        /**
-         * Delegates to {@link BodyDeferringAsyncHandler#getResponse()}. Will
-         * blocks as long as headers arrives only. Might return
-         * <code>null</code>. See
-         * {@link BodyDeferringAsyncHandler#getResponse()} method for details.
-         *
-         * @return a {@link Response}
-         * @throws InterruptedException if the latch is interrupted
-         * @throws IOException if the handler completed with an exception
-         */
-        public Response getAsapResponse() throws InterruptedException, IOException {
-            return bdah.getResponse();
-        }
-
-        /**
-         * Delegates to <code>Future$lt;Response&gt;#get()</code> method. Will block
-         * as long as complete response arrives.
-         *
-         * @return a {@link Response}
-         * @throws ExecutionException if the computation threw an exception
-         * @throws InterruptedException if the current thread was interrupted
-         */
-        public Response getLastResponse() throws InterruptedException, ExecutionException {
-            return future.get();
-        }
+    public Response getLastResponse() throws InterruptedException, ExecutionException {
+      return future.get();
     }
+  }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
deleted file mode 100644
index 6c173d4a3..000000000
--- a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.handler;
-
-import io.netty.channel.Channel;
-
-import java.net.InetSocketAddress;
-import java.util.List;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.netty.request.NettyRequest;
-
-public abstract class ExtendedAsyncHandler<T> implements AsyncHandler<T>, AsyncHandlerExtensions {
-
-    @Override
-    public void onHostnameResolutionAttempt(String name) {
-    }
-
-    @Override
-    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-    }
-
-    @Override
-    public void onHostnameResolutionFailure(String name, Throwable cause) {
-    }
-
-    @Override
-    public void onTcpConnectAttempt(InetSocketAddress address) {
-    }
-
-    @Override
-    public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
-    }
-
-    @Override
-    public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
-    }
-
-    @Override
-    public void onTlsHandshakeAttempt() {
-    }
-
-    @Override
-    public void onTlsHandshakeSuccess() {
-    }
-
-    @Override
-    public void onTlsHandshakeFailure(Throwable cause) {
-    }
-
-    @Override
-    public void onConnectionPoolAttempt() {
-    }
-
-    @Override
-    public void onConnectionPooled(Channel connection) {
-    }
-
-    @Override
-    public void onConnectionOffer(Channel connection) {
-    }
-
-    @Override
-    public void onRequestSend(NettyRequest request) {
-    }
-
-    @Override
-    public void onRetry() {
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
index e88882e2b..9deb452ef 100644
--- a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
+++ b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
@@ -17,9 +17,9 @@
  * Thrown when the {@link org.asynchttpclient.DefaultAsyncHttpClientConfig#getMaxRedirects()} has been reached.
  */
 public class MaxRedirectException extends Exception {
-    private static final long serialVersionUID = 1L;
+  private static final long serialVersionUID = 1L;
 
-    public MaxRedirectException(String msg) {
-        super(msg, null, true, false);
-    }
+  public MaxRedirectException(String msg) {
+    super(msg, null, true, false);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
index e46fcea10..556ce3006 100644
--- a/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
@@ -21,30 +21,30 @@
  */
 public interface ProgressAsyncHandler<T> extends AsyncHandler<T> {
 
-    /**
-     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
-     * written on the I/O socket.
-     *
-     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    State onHeadersWritten();
+  /**
+   * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
+   * written on the I/O socket.
+   *
+   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+   */
+  State onHeadersWritten();
 
-    /**
-     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
-     * written on the I/O socket.
-     *
-     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    State onContentWritten();
+  /**
+   * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
+   * written on the I/O socket.
+   *
+   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+   */
+  State onContentWritten();
 
-    /**
-     * Invoked when the I/O operation associated with the {@link Request} body wasn't fully written in a single I/O write
-     * operation. This method is never invoked if the write operation complete in a sinfle I/O write.
-     *
-     * @param amount  The amount of bytes to transfer.
-     * @param current The amount of bytes transferred
-     * @param total   The total number of bytes transferred
-     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-     */
-    State onContentWriteProgress(long amount, long current, long total);
+  /**
+   * Invoked when the I/O operation associated with the {@link Request} body wasn't fully written in a single I/O write
+   * operation. This method is never invoked if the write operation complete in a sinfle I/O write.
+   *
+   * @param amount  The amount of bytes to transfer.
+   * @param current The amount of bytes transferred
+   * @param total   The total number of bytes transferred
+   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+   */
+  State onContentWriteProgress(long amount, long current, long total);
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
index e05ff2ddf..2438cd0e7 100644
--- a/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
@@ -21,11 +21,11 @@
  */
 public interface StreamedAsyncHandler<T> extends AsyncHandler<T> {
 
-    /**
-     * Called when the body is received. May not be called if there's no body.
-     *
-     * @param publisher The publisher of response body parts.
-     * @return Whether to continue or abort.
-     */
-    State onStream(Publisher<HttpResponseBodyPart> publisher);
+  /**
+   * Called when the body is received. May not be called if there's no body.
+   *
+   * @param publisher The publisher of response body parts.
+   * @return Whether to continue or abort.
+   */
+  State onStream(Publisher<HttpResponseBodyPart> publisher);
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java b/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
index ae0eeb943..d3baff0ca 100644
--- a/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
@@ -13,192 +13,188 @@
 package org.asynchttpclient.handler;
 
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.concurrent.ConcurrentLinkedQueue;
-
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.concurrent.ConcurrentLinkedQueue;
+
 /**
  * A {@link org.asynchttpclient.AsyncHandler} that can be used to notify a set of {@link TransferListener}
  * <br>
  * <blockquote>
- * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * TransferCompletionHandler tl = new TransferCompletionHandler();
  * tl.addTransferListener(new TransferListener() {
- * 
+ *
  * public void onRequestHeadersSent(HttpHeaders headers) {
  * }
- * 
+ *
  * public void onResponseHeadersReceived(HttpHeaders headers) {
  * }
- * 
+ *
  * public void onBytesReceived(ByteBuffer buffer) {
  * }
- * 
+ *
  * public void onBytesSent(long amount, long current, long total) {
  * }
- * 
+ *
  * public void onRequestResponseCompleted() {
  * }
- * 
+ *
  * public void onThrowable(Throwable t) {
  * }
  * });
- * 
+ *
  * Response response = httpClient.prepareGet("http://...").execute(tl).get();
  * </pre>
- * 
  * </blockquote>
  */
 public class TransferCompletionHandler extends AsyncCompletionHandlerBase {
-    private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
-    private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<>();
-    private final boolean accumulateResponseBytes;
-    private HttpHeaders headers;
-
-    /**
-     * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
-     * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} will throw an IllegalStateException if called.
-     */
-    public TransferCompletionHandler() {
-        this(false);
-    }
-
-    /**
-     * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when {@link org.asynchttpclient.Response#getResponseBody()} get called. The
-     * default is false.
-     * 
-     * @param accumulateResponseBytes
-     *            true to accumulates bytes in memory.
-     */
-    public TransferCompletionHandler(boolean accumulateResponseBytes) {
-        this.accumulateResponseBytes = accumulateResponseBytes;
-    }
-
-    public TransferCompletionHandler addTransferListener(TransferListener t) {
-        listeners.offer(t);
-        return this;
-    }
-
-    public TransferCompletionHandler removeTransferListener(TransferListener t) {
-        listeners.remove(t);
-        return this;
-    }
-
-    public void headers(HttpHeaders headers) {
-        this.headers = headers;
-    }
-
-    @Override
-    public State onHeadersReceived(final HttpHeaders headers) throws Exception {
-        fireOnHeaderReceived(headers);
-        return super.onHeadersReceived(headers);
-    }
-    
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        fireOnHeaderReceived(headers);
-        return super.onHeadersReceived(headers);
-    }
-
-    @Override
-    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        State s = State.CONTINUE;
-        if (accumulateResponseBytes) {
-            s = super.onBodyPartReceived(content);
-        }
-        fireOnBytesReceived(content.getBodyPartBytes());
-        return s;
-    }
-
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-        fireOnEnd();
-        return response;
-    }
-
-    @Override
-    public State onHeadersWritten() {
-        if (headers != null) {
-            fireOnHeadersSent(headers);
-        }
-        return State.CONTINUE;
-    }
-
-    @Override
-    public State onContentWriteProgress(long amount, long current, long total) {
-        fireOnBytesSent(amount, current, total);
-        return State.CONTINUE;
-    }
-
-    @Override
-    public void onThrowable(Throwable t) {
-        fireOnThrowable(t);
-    }
-
-    private void fireOnHeadersSent(HttpHeaders headers) {
-        for (TransferListener l : listeners) {
-            try {
-                l.onRequestHeadersSent(headers);
-            } catch (Throwable t) {
-                l.onThrowable(t);
-            }
-        }
-    }
-
-    private void fireOnHeaderReceived(HttpHeaders headers) {
-        for (TransferListener l : listeners) {
-            try {
-                l.onResponseHeadersReceived(headers);
-            } catch (Throwable t) {
-                l.onThrowable(t);
-            }
-        }
-    }
-
-    private void fireOnEnd() {
-        for (TransferListener l : listeners) {
-            try {
-                l.onRequestResponseCompleted();
-            } catch (Throwable t) {
-                l.onThrowable(t);
-            }
-        }
-    }
-
-    private void fireOnBytesReceived(byte[] b) {
-        for (TransferListener l : listeners) {
-            try {
-                l.onBytesReceived(b);
-            } catch (Throwable t) {
-                l.onThrowable(t);
-            }
-        }
-    }
-
-    private void fireOnBytesSent(long amount, long current, long total) {
-        for (TransferListener l : listeners) {
-            try {
-                l.onBytesSent(amount, current, total);
-            } catch (Throwable t) {
-                l.onThrowable(t);
-            }
-        }
-    }
-
-    private void fireOnThrowable(Throwable t) {
-        for (TransferListener l : listeners) {
-            try {
-                l.onThrowable(t);
-            } catch (Throwable t2) {
-                logger.warn("onThrowable", t2);
-            }
-        }
-    }
+  private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
+  private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<>();
+  private final boolean accumulateResponseBytes;
+  private HttpHeaders headers;
+
+  /**
+   * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
+   * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} will throw an IllegalStateException if called.
+   */
+  public TransferCompletionHandler() {
+    this(false);
+  }
+
+  /**
+   * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when {@link org.asynchttpclient.Response#getResponseBody()} get called. The
+   * default is false.
+   *
+   * @param accumulateResponseBytes true to accumulates bytes in memory.
+   */
+  public TransferCompletionHandler(boolean accumulateResponseBytes) {
+    this.accumulateResponseBytes = accumulateResponseBytes;
+  }
+
+  public TransferCompletionHandler addTransferListener(TransferListener t) {
+    listeners.offer(t);
+    return this;
+  }
+
+  public TransferCompletionHandler removeTransferListener(TransferListener t) {
+    listeners.remove(t);
+    return this;
+  }
+
+  public void headers(HttpHeaders headers) {
+    this.headers = headers;
+  }
+
+  @Override
+  public State onHeadersReceived(final HttpHeaders headers) throws Exception {
+    fireOnHeaderReceived(headers);
+    return super.onHeadersReceived(headers);
+  }
+
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+    fireOnHeaderReceived(headers);
+    return super.onHeadersReceived(headers);
+  }
+
+  @Override
+  public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+    State s = State.CONTINUE;
+    if (accumulateResponseBytes) {
+      s = super.onBodyPartReceived(content);
+    }
+    fireOnBytesReceived(content.getBodyPartBytes());
+    return s;
+  }
+
+  @Override
+  public Response onCompleted(Response response) throws Exception {
+    fireOnEnd();
+    return response;
+  }
+
+  @Override
+  public State onHeadersWritten() {
+    if (headers != null) {
+      fireOnHeadersSent(headers);
+    }
+    return State.CONTINUE;
+  }
+
+  @Override
+  public State onContentWriteProgress(long amount, long current, long total) {
+    fireOnBytesSent(amount, current, total);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public void onThrowable(Throwable t) {
+    fireOnThrowable(t);
+  }
+
+  private void fireOnHeadersSent(HttpHeaders headers) {
+    for (TransferListener l : listeners) {
+      try {
+        l.onRequestHeadersSent(headers);
+      } catch (Throwable t) {
+        l.onThrowable(t);
+      }
+    }
+  }
+
+  private void fireOnHeaderReceived(HttpHeaders headers) {
+    for (TransferListener l : listeners) {
+      try {
+        l.onResponseHeadersReceived(headers);
+      } catch (Throwable t) {
+        l.onThrowable(t);
+      }
+    }
+  }
+
+  private void fireOnEnd() {
+    for (TransferListener l : listeners) {
+      try {
+        l.onRequestResponseCompleted();
+      } catch (Throwable t) {
+        l.onThrowable(t);
+      }
+    }
+  }
+
+  private void fireOnBytesReceived(byte[] b) {
+    for (TransferListener l : listeners) {
+      try {
+        l.onBytesReceived(b);
+      } catch (Throwable t) {
+        l.onThrowable(t);
+      }
+    }
+  }
+
+  private void fireOnBytesSent(long amount, long current, long total) {
+    for (TransferListener l : listeners) {
+      try {
+        l.onBytesSent(amount, current, total);
+      } catch (Throwable t) {
+        l.onThrowable(t);
+      }
+    }
+  }
+
+  private void fireOnThrowable(Throwable t) {
+    for (TransferListener l : listeners) {
+      try {
+        l.onThrowable(t);
+      } catch (Throwable t2) {
+        logger.warn("onThrowable", t2);
+      }
+    }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/TransferListener.java b/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
index f9b81fb80..b733d5d40 100644
--- a/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
@@ -19,46 +19,46 @@
  */
 public interface TransferListener {
 
-    /**
-     * Invoked when the request bytes are starting to get send.
-     * 
-     * @param headers the headers
-     */
-    void onRequestHeadersSent(HttpHeaders headers);
+  /**
+   * Invoked when the request bytes are starting to get send.
+   *
+   * @param headers the headers
+   */
+  void onRequestHeadersSent(HttpHeaders headers);
 
-    /**
-     * Invoked when the response bytes are starting to get received.
-     * 
-     * @param headers the headers
-     */
-    void onResponseHeadersReceived(HttpHeaders headers);
+  /**
+   * Invoked when the response bytes are starting to get received.
+   *
+   * @param headers the headers
+   */
+  void onResponseHeadersReceived(HttpHeaders headers);
 
-    /**
-     * Invoked every time response's chunk are received.
-     *
-     * @param bytes a {@link byte[]}
-     */
-    void onBytesReceived(byte[] bytes);
+  /**
+   * Invoked every time response's chunk are received.
+   *
+   * @param bytes a {@link byte[]}
+   */
+  void onBytesReceived(byte[] bytes);
 
-    /**
-     * Invoked every time request's chunk are sent.
-     *
-     * @param amount  The amount of bytes to transfer
-     * @param current The amount of bytes transferred
-     * @param total   The total number of bytes transferred
-     */
-    void onBytesSent(long amount, long current, long total);
+  /**
+   * Invoked every time request's chunk are sent.
+   *
+   * @param amount  The amount of bytes to transfer
+   * @param current The amount of bytes transferred
+   * @param total   The total number of bytes transferred
+   */
+  void onBytesSent(long amount, long current, long total);
 
-    /**
-     * Invoked when the response bytes are been fully received.
-     */
-    void onRequestResponseCompleted();
+  /**
+   * Invoked when the response bytes are been fully received.
+   */
+  void onRequestResponseCompleted();
 
-    /**
-     * Invoked when there is an unexpected issue.
-     *
-     * @param t a {@link Throwable}
-     */
-    void onThrowable(Throwable t);
+  /**
+   * Invoked when there is an unexpected issue.
+   *
+   * @param t a {@link Throwable}
+   */
+  void onThrowable(Throwable t);
 }
 
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java b/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
index 8540fc191..1eb99f11b 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
@@ -12,8 +12,8 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -23,100 +23,100 @@
 import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 /**
  * A {@link org.asynchttpclient.handler.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
  * to store the download index information.
  */
 public class PropertiesBasedResumableProcessor implements ResumableAsyncHandler.ResumableProcessor {
-    private final static Logger log = LoggerFactory.getLogger(PropertiesBasedResumableProcessor.class);
-    private final static File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc");
-    private final static String storeName = "ResumableAsyncHandler.properties";
-    private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<>();
+  private final static Logger log = LoggerFactory.getLogger(PropertiesBasedResumableProcessor.class);
+  private final static File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc");
+  private final static String storeName = "ResumableAsyncHandler.properties";
+  private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<>();
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void put(String url, long transferredBytes) {
-        properties.put(url, transferredBytes);
-    }
+  private static String append(Map.Entry<String, Long> e) {
+    return e.getKey() + '=' + e.getValue() + '\n';
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void remove(String uri) {
-        if (uri != null) {
-            properties.remove(uri);
-        }
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void put(String url, long transferredBytes) {
+    properties.put(url, transferredBytes);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void save(Map<String, Long> map) {
-        log.debug("Saving current download state {}", properties.toString());
-        OutputStream os = null;
-        try {
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void remove(String uri) {
+    if (uri != null) {
+      properties.remove(uri);
+    }
+  }
 
-            if (!TMP.exists() && !TMP.mkdirs()) {
-                throw new IllegalStateException("Unable to create directory: " + TMP.getAbsolutePath());
-            }
-            File f = new File(TMP, storeName);
-            if (!f.exists() && !f.createNewFile()) {
-                throw new IllegalStateException("Unable to create temp file: " + f.getAbsolutePath());
-            }
-            if (!f.canWrite()) {
-                throw new IllegalStateException();
-            }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void save(Map<String, Long> map) {
+    log.debug("Saving current download state {}", properties.toString());
+    OutputStream os = null;
+    try {
 
-            os = Files.newOutputStream(f.toPath());
-            for (Map.Entry<String, Long> e : properties.entrySet()) {
-                os.write(append(e).getBytes(UTF_8));
-            }
-            os.flush();
-        } catch (Throwable e) {
-            log.warn(e.getMessage(), e);
-        } finally {
-            closeSilently(os);
-        }
-    }
+      if (!TMP.exists() && !TMP.mkdirs()) {
+        throw new IllegalStateException("Unable to create directory: " + TMP.getAbsolutePath());
+      }
+      File f = new File(TMP, storeName);
+      if (!f.exists() && !f.createNewFile()) {
+        throw new IllegalStateException("Unable to create temp file: " + f.getAbsolutePath());
+      }
+      if (!f.canWrite()) {
+        throw new IllegalStateException();
+      }
 
-    private static String append(Map.Entry<String, Long> e) {
-        return new StringBuilder(e.getKey()).append('=').append(e.getValue()).append('\n').toString();
+      os = Files.newOutputStream(f.toPath());
+      for (Map.Entry<String, Long> e : properties.entrySet()) {
+        os.write(append(e).getBytes(UTF_8));
+      }
+      os.flush();
+    } catch (Throwable e) {
+      log.warn(e.getMessage(), e);
+    } finally {
+      closeSilently(os);
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Map<String, Long> load() {
-        Scanner scan = null;
-        try {
-            scan = new Scanner(new File(TMP, storeName), UTF_8.name());
-            scan.useDelimiter("[=\n]");
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public Map<String, Long> load() {
+    Scanner scan = null;
+    try {
+      scan = new Scanner(new File(TMP, storeName), UTF_8.name());
+      scan.useDelimiter("[=\n]");
 
-            String key;
-            String value;
-            while (scan.hasNext()) {
-                key = scan.next().trim();
-                value = scan.next().trim();
-                properties.put(key, Long.valueOf(value));
-            }
-            log.debug("Loading previous download state {}", properties.toString());
-        } catch (FileNotFoundException ex) {
-            log.debug("Missing {}", storeName);
-        } catch (Throwable ex) {
-            // Survive any exceptions
-            log.warn(ex.getMessage(), ex);
-        } finally {
-            if (scan != null)
-                scan.close();
-        }
-        return properties;
+      String key;
+      String value;
+      while (scan.hasNext()) {
+        key = scan.next().trim();
+        value = scan.next().trim();
+        properties.put(key, Long.valueOf(value));
+      }
+      log.debug("Loading previous download state {}", properties.toString());
+    } catch (FileNotFoundException ex) {
+      log.debug("Missing {}", storeName);
+    } catch (Throwable ex) {
+      // Survive any exceptions
+      log.warn(ex.getMessage(), ex);
+    } finally {
+      if (scan != null)
+        scan.close();
     }
+    return properties;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
index 1a5274fab..399638fbb 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
@@ -12,8 +12,12 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.*;
+import org.asynchttpclient.Response.ResponseBuilder;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -22,16 +26,8 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.Response.ResponseBuilder;
-import org.asynchttpclient.handler.TransferCompletionHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderNames.RANGE;
 
 /**
  * An {@link AsyncHandler} which support resumable download, e.g when used with an {@link ResumableIOExceptionFilter},
@@ -40,271 +36,271 @@
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <br>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
- * 
+ * <p>
  * Beware that it registers a shutdown hook, that will cause a ClassLoader leak when used in an appserver and only redeploying the application.
  */
 public class ResumableAsyncHandler implements AsyncHandler<Response> {
-    private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
-    private final AtomicLong byteTransferred;
-    private String url;
-    private final ResumableProcessor resumableProcessor;
-    private final AsyncHandler<Response> decoratedAsyncHandler;
-    private static Map<String, Long> resumableIndex;
-    private final static ResumableIndexThread resumeIndexThread = new ResumableIndexThread();
-    private ResponseBuilder responseBuilder = new ResponseBuilder();
-    private final boolean accumulateBody;
-    private ResumableListener resumableListener = new NULLResumableListener();
-
-    private ResumableAsyncHandler(long byteTransferred, ResumableProcessor resumableProcessor,
-            AsyncHandler<Response> decoratedAsyncHandler, boolean accumulateBody) {
-
-        this.byteTransferred = new AtomicLong(byteTransferred);
-
-        if (resumableProcessor == null) {
-            resumableProcessor = new NULLResumableHandler();
-        }
-        this.resumableProcessor = resumableProcessor;
-
-        resumableIndex = resumableProcessor.load();
-        resumeIndexThread.addResumableProcessor(resumableProcessor);
-
-        this.decoratedAsyncHandler = decoratedAsyncHandler;
-        this.accumulateBody = accumulateBody;
+  private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
+  private final static ResumableIndexThread resumeIndexThread = new ResumableIndexThread();
+  private static Map<String, Long> resumableIndex;
+  private final AtomicLong byteTransferred;
+  private final ResumableProcessor resumableProcessor;
+  private final AsyncHandler<Response> decoratedAsyncHandler;
+  private final boolean accumulateBody;
+  private String url;
+  private ResponseBuilder responseBuilder = new ResponseBuilder();
+  private ResumableListener resumableListener = new NULLResumableListener();
+
+  private ResumableAsyncHandler(long byteTransferred, ResumableProcessor resumableProcessor,
+                                AsyncHandler<Response> decoratedAsyncHandler, boolean accumulateBody) {
+
+    this.byteTransferred = new AtomicLong(byteTransferred);
+
+    if (resumableProcessor == null) {
+      resumableProcessor = new NULLResumableHandler();
     }
-
-    public ResumableAsyncHandler(long byteTransferred) {
-        this(byteTransferred, null, null, false);
+    this.resumableProcessor = resumableProcessor;
+
+    resumableIndex = resumableProcessor.load();
+    resumeIndexThread.addResumableProcessor(resumableProcessor);
+
+    this.decoratedAsyncHandler = decoratedAsyncHandler;
+    this.accumulateBody = accumulateBody;
+  }
+
+  public ResumableAsyncHandler(long byteTransferred) {
+    this(byteTransferred, null, null, false);
+  }
+
+  public ResumableAsyncHandler(boolean accumulateBody) {
+    this(0, null, null, accumulateBody);
+  }
+
+  public ResumableAsyncHandler() {
+    this(0, null, null, false);
+  }
+
+  public ResumableAsyncHandler(AsyncHandler<Response> decoratedAsyncHandler) {
+    this(0, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
+  }
+
+  public ResumableAsyncHandler(long byteTransferred, AsyncHandler<Response> decoratedAsyncHandler) {
+    this(byteTransferred, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
+  }
+
+  public ResumableAsyncHandler(ResumableProcessor resumableProcessor) {
+    this(0, resumableProcessor, null, false);
+  }
+
+  public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accumulateBody) {
+    this(0, resumableProcessor, null, accumulateBody);
+  }
+
+  @Override
+  public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+    responseBuilder.accumulate(status);
+    if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
+      url = status.getUri().toUrl();
+    } else {
+      return AsyncHandler.State.ABORT;
     }
 
-    public ResumableAsyncHandler(boolean accumulateBody) {
-        this(0, null, null, accumulateBody);
+    if (decoratedAsyncHandler != null) {
+      return decoratedAsyncHandler.onStatusReceived(status);
     }
 
-    public ResumableAsyncHandler() {
-        this(0, null, null, false);
-    }
+    return AsyncHandler.State.CONTINUE;
+  }
 
-    public ResumableAsyncHandler(AsyncHandler<Response> decoratedAsyncHandler) {
-        this(0, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
+  @Override
+  public void onThrowable(Throwable t) {
+    if (decoratedAsyncHandler != null) {
+      decoratedAsyncHandler.onThrowable(t);
+    } else {
+      logger.debug("", t);
     }
+  }
 
-    public ResumableAsyncHandler(long byteTransferred, AsyncHandler<Response> decoratedAsyncHandler) {
-        this(byteTransferred, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
-    }
-
-    public ResumableAsyncHandler(ResumableProcessor resumableProcessor) {
-        this(0, resumableProcessor, null, false);
-    }
+  @Override
+  public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
 
-    public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accumulateBody) {
-        this(0, resumableProcessor, null, accumulateBody);
+    if (accumulateBody) {
+      responseBuilder.accumulate(bodyPart);
     }
 
-    @Override
-    public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-        responseBuilder.accumulate(status);
-        if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
-            url = status.getUri().toUrl();
-        } else {
-            return AsyncHandler.State.ABORT;
-        }
-
-        if (decoratedAsyncHandler != null) {
-            return decoratedAsyncHandler.onStatusReceived(status);
-        }
-
-        return AsyncHandler.State.CONTINUE;
+    State state = State.CONTINUE;
+    try {
+      resumableListener.onBytesReceived(bodyPart.getBodyByteBuffer());
+    } catch (IOException ex) {
+      return AsyncHandler.State.ABORT;
     }
 
-    @Override
-    public void onThrowable(Throwable t) {
-        if (decoratedAsyncHandler != null) {
-            decoratedAsyncHandler.onThrowable(t);
-        } else {
-            logger.debug("", t);
-        }
+    if (decoratedAsyncHandler != null) {
+      state = decoratedAsyncHandler.onBodyPartReceived(bodyPart);
     }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    byteTransferred.addAndGet(bodyPart.getBodyPartBytes().length);
+    resumableProcessor.put(url, byteTransferred.get());
 
-        if (accumulateBody) {
-            responseBuilder.accumulate(bodyPart);
-        }
+    return state;
+  }
 
-        State state = State.CONTINUE;
-        try {
-            resumableListener.onBytesReceived(bodyPart.getBodyByteBuffer());
-        } catch (IOException ex) {
-            return AsyncHandler.State.ABORT;
-        }
+  @Override
+  public Response onCompleted() throws Exception {
+    resumableProcessor.remove(url);
+    resumableListener.onAllBytesReceived();
 
-        if (decoratedAsyncHandler != null) {
-            state = decoratedAsyncHandler.onBodyPartReceived(bodyPart);
-        }
-
-        byteTransferred.addAndGet(bodyPart.getBodyPartBytes().length);
-        resumableProcessor.put(url, byteTransferred.get());
-
-        return state;
+    if (decoratedAsyncHandler != null) {
+      decoratedAsyncHandler.onCompleted();
+    }
+    // Not sure
+    return responseBuilder.build();
+  }
+
+  @Override
+  public State onHeadersReceived(HttpHeaders headers) throws Exception {
+    responseBuilder.accumulate(headers);
+    String contentLengthHeader = headers.get(CONTENT_LENGTH);
+    if (contentLengthHeader != null) {
+      if (Long.parseLong(contentLengthHeader) == -1L) {
+        return AsyncHandler.State.ABORT;
+      }
     }
 
-    @Override
-    public Response onCompleted() throws Exception {
-        resumableProcessor.remove(url);
-        resumableListener.onAllBytesReceived();
-
-        if (decoratedAsyncHandler != null) {
-            decoratedAsyncHandler.onCompleted();
-        }
-        // Not sure
-        return responseBuilder.build();
+    if (decoratedAsyncHandler != null) {
+      return decoratedAsyncHandler.onHeadersReceived(headers);
+    }
+    return State.CONTINUE;
+  }
+
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) {
+    responseBuilder.accumulate(headers);
+    return State.CONTINUE;
+  }
+
+  /**
+   * Invoke this API if you want to set the Range header on your {@link Request} based on the last valid bytes
+   * position.
+   *
+   * @param request {@link Request}
+   * @return a {@link Request} with the Range header properly set.
+   */
+  public Request adjustRequestRange(Request request) {
+
+    Long ri = resumableIndex.get(request.getUrl());
+    if (ri != null) {
+      byteTransferred.set(ri);
     }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-        responseBuilder.accumulate(headers);
-        String contentLengthHeader = headers.get(CONTENT_LENGTH);
-        if (contentLengthHeader != null) {
-            if (Long.parseLong(contentLengthHeader) == -1L) {
-                return AsyncHandler.State.ABORT;
-            }
-        }
-
-        if (decoratedAsyncHandler != null) {
-            return decoratedAsyncHandler.onHeadersReceived(headers);
-        }
-        return State.CONTINUE;
+    // The Resumable
+    if (resumableListener != null && resumableListener.length() > 0 && byteTransferred.get() != resumableListener.length()) {
+      byteTransferred.set(resumableListener.length());
     }
-    
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        responseBuilder.accumulate(headers);
-        return State.CONTINUE;
+
+    RequestBuilder builder = new RequestBuilder(request);
+    if (request.getHeaders().get(RANGE) == null && byteTransferred.get() != 0) {
+      builder.setHeader(RANGE, "bytes=" + byteTransferred.get() + "-");
     }
+    return builder.build();
+  }
+
+  /**
+   * Set a {@link ResumableListener}
+   *
+   * @param resumableListener a {@link ResumableListener}
+   * @return this
+   */
+  public ResumableAsyncHandler setResumableListener(ResumableListener resumableListener) {
+    this.resumableListener = resumableListener;
+    return this;
+  }
+
+  /**
+   * An interface to implement in order to manage the way the incomplete file management are handled.
+   */
+  public interface ResumableProcessor {
 
     /**
-     * Invoke this API if you want to set the Range header on your {@link Request} based on the last valid bytes
-     * position.
+     * Associate a key with the number of bytes successfully transferred.
      *
-     * @param request {@link Request}
-     * @return a {@link Request} with the Range header properly set.
+     * @param key              a key. The recommended way is to use an url.
+     * @param transferredBytes The number of bytes successfully transferred.
      */
-    public Request adjustRequestRange(Request request) {
-
-        Long ri = resumableIndex.get(request.getUrl());
-        if (ri != null) {
-            byteTransferred.set(ri);
-        }
-
-        // The Resumable
-        if (resumableListener != null && resumableListener.length() > 0 && byteTransferred.get() != resumableListener.length()) {
-            byteTransferred.set(resumableListener.length());
-        }
-
-        RequestBuilder builder = new RequestBuilder(request);
-        if (request.getHeaders().get(RANGE) == null && byteTransferred.get() != 0) {
-            builder.setHeader(RANGE, "bytes=" + byteTransferred.get() + "-");
-        }
-        return builder.build();
-    }
+    void put(String key, long transferredBytes);
 
     /**
-     * Set a {@link ResumableListener}
+     * Remove the key associate value.
      *
-     * @param resumableListener a {@link ResumableListener}
-     * @return this
+     * @param key key from which the value will be discarded
      */
-    public ResumableAsyncHandler setResumableListener(ResumableListener resumableListener) {
-        this.resumableListener = resumableListener;
-        return this;
-    }
+    void remove(String key);
 
-    private static class ResumableIndexThread extends Thread {
+    /**
+     * Save the current {@link Map} instance which contains information about the current transfer state.
+     * This method *only* invoked when the JVM is shutting down.
+     *
+     * @param map the current transfer state
+     */
+    void save(Map<String, Long> map);
 
-        public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<>();
+    /**
+     * Load the {@link Map} in memory, contains information about the transferred bytes.
+     *
+     * @return {@link Map} current transfer state
+     */
+    Map<String, Long> load();
 
-        public ResumableIndexThread() {
-            Runtime.getRuntime().addShutdownHook(this);
-        }
+  }
 
-        public void addResumableProcessor(ResumableProcessor p) {
-            resumableProcessors.offer(p);
-        }
+  private static class ResumableIndexThread extends Thread {
 
-        public void run() {
-            for (ResumableProcessor p : resumableProcessors) {
-                p.save(resumableIndex);
-            }
-        }
+    public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<>();
+
+    public ResumableIndexThread() {
+      Runtime.getRuntime().addShutdownHook(this);
     }
 
-    /**
-     * An interface to implement in order to manage the way the incomplete file management are handled.
-     */
-    public interface ResumableProcessor {
-
-        /**
-         * Associate a key with the number of bytes successfully transferred.
-         *
-         * @param key              a key. The recommended way is to use an url.
-         * @param transferredBytes The number of bytes successfully transferred.
-         */
-        void put(String key, long transferredBytes);
-
-        /**
-         * Remove the key associate value.
-         *
-         * @param key key from which the value will be discarded
-         */
-        void remove(String key);
-
-        /**
-         * Save the current {@link Map} instance which contains information about the current transfer state.
-         * This method *only* invoked when the JVM is shutting down.
-         *
-         * @param map the current transfer state
-         */
-        void save(Map<String, Long> map);
-
-        /**
-         * Load the {@link Map} in memory, contains information about the transferred bytes.
-         *
-         * @return {@link Map} current transfer state
-         */
-        Map<String, Long> load();
+    public void addResumableProcessor(ResumableProcessor p) {
+      resumableProcessors.offer(p);
+    }
 
+    public void run() {
+      for (ResumableProcessor p : resumableProcessors) {
+        p.save(resumableIndex);
+      }
     }
+  }
 
-    private static class NULLResumableHandler implements ResumableProcessor {
+  private static class NULLResumableHandler implements ResumableProcessor {
 
-        public void put(String url, long transferredBytes) {
-        }
+    public void put(String url, long transferredBytes) {
+    }
 
-        public void remove(String uri) {
-        }
+    public void remove(String uri) {
+    }
 
-        public void save(Map<String, Long> map) {
-        }
+    public void save(Map<String, Long> map) {
+    }
 
-        public Map<String, Long> load() {
-            return new HashMap<>();
-        }
+    public Map<String, Long> load() {
+      return new HashMap<>();
     }
+  }
 
-    private static class NULLResumableListener implements ResumableListener {
+  private static class NULLResumableListener implements ResumableListener {
 
-        private long length = 0L;
+    private long length = 0L;
 
-        public void onBytesReceived(ByteBuffer byteBuffer) throws IOException {
-            length += byteBuffer.remaining();
-        }
+    public void onBytesReceived(ByteBuffer byteBuffer) {
+      length += byteBuffer.remaining();
+    }
 
-        public void onAllBytesReceived() {
-        }
+    public void onAllBytesReceived() {
+    }
 
-        public long length() {
-            return length;
-        }
+    public long length() {
+      return length;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
index c87867499..948bb6649 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
@@ -14,20 +14,19 @@
 
 import org.asynchttpclient.Request;
 import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
 
 /**
  * Simple {@link org.asynchttpclient.filter.IOExceptionFilter} that replay the current {@link org.asynchttpclient.Request} using a {@link ResumableAsyncHandler}
  */
 public class ResumableIOExceptionFilter implements IOExceptionFilter {
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-        if (ctx.getIOException() != null && ctx.getAsyncHandler() instanceof ResumableAsyncHandler) {
+  public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+    if (ctx.getIOException() != null && ctx.getAsyncHandler() instanceof ResumableAsyncHandler) {
 
-            Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
+      Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
 
-            return new FilterContext.FilterContextBuilder<>(ctx).request(request).replayRequest(true).build();
-        }
-        return ctx;
+      return new FilterContext.FilterContextBuilder<>(ctx).request(request).replayRequest(true).build();
     }
+    return ctx;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
index 68261f6af..4e36d7430 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
@@ -20,23 +20,23 @@
  */
 public interface ResumableListener {
 
-    /**
-     * Invoked when some bytes are available to digest.
-     *
-     * @param byteBuffer the current bytes
-     * @throws IOException exception while writing the byteBuffer
-     */
-    void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
+  /**
+   * Invoked when some bytes are available to digest.
+   *
+   * @param byteBuffer the current bytes
+   * @throws IOException exception while writing the byteBuffer
+   */
+  void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
 
-    /**
-     * Invoked when all the bytes has been sucessfully transferred.
-     */
-    void onAllBytesReceived();
+  /**
+   * Invoked when all the bytes has been sucessfully transferred.
+   */
+  void onAllBytesReceived();
 
-    /**
-     * Return the length of previously downloaded bytes.
-     *
-     * @return the length of previously downloaded bytes
-     */
-    long length();
+  /**
+   * Return the length of previously downloaded bytes.
+   *
+   * @return the length of previously downloaded bytes
+   */
+  long length();
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
index 3fc4adecc..918a2b938 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
@@ -12,57 +12,57 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 /**
  * A {@link org.asynchttpclient.handler.resumable.ResumableListener} which use a {@link RandomAccessFile} for storing the received bytes.
  */
 public class ResumableRandomAccessFileListener implements ResumableListener {
-    private final RandomAccessFile file;
+  private final RandomAccessFile file;
 
-    public ResumableRandomAccessFileListener(RandomAccessFile file) {
-        this.file = file;
-    }
+  public ResumableRandomAccessFileListener(RandomAccessFile file) {
+    this.file = file;
+  }
 
-    /**
-     * This method uses the last valid bytes written on disk to position a {@link RandomAccessFile}, allowing
-     * resumable file download.
-     *
-     * @param buffer a {@link ByteBuffer}
-     * @throws IOException exception while writing into the file
-     */
-    public void onBytesReceived(ByteBuffer buffer) throws IOException {
-        file.seek(file.length());
-        if (buffer.hasArray()) {
-            file.write(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
-        } else { // if the buffer is direct or backed by a String...
-            byte[] b = new byte[buffer.remaining()];
-            int pos = buffer.position();
-            buffer.get(b);
-            buffer.position(pos);
-            file.write(b);
-        }
+  /**
+   * This method uses the last valid bytes written on disk to position a {@link RandomAccessFile}, allowing
+   * resumable file download.
+   *
+   * @param buffer a {@link ByteBuffer}
+   * @throws IOException exception while writing into the file
+   */
+  public void onBytesReceived(ByteBuffer buffer) throws IOException {
+    file.seek(file.length());
+    if (buffer.hasArray()) {
+      file.write(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
+    } else { // if the buffer is direct or backed by a String...
+      byte[] b = new byte[buffer.remaining()];
+      int pos = buffer.position();
+      buffer.get(b);
+      buffer.position(pos);
+      file.write(b);
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    public void onAllBytesReceived() {
-        closeSilently(file);
-    }
+  /**
+   * {@inheritDoc}
+   */
+  public void onAllBytesReceived() {
+    closeSilently(file);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    public long length() {
-        try {
-            return file.length();
-        } catch (IOException e) {
-            return 0;
-        }
+  /**
+   * {@inheritDoc}
+   */
+  public long length() {
+    try {
+      return file.length();
+    } catch (IOException e) {
+      return 0;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java b/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
index 7aa86b8e2..9c419de65 100644
--- a/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
+++ b/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
@@ -17,5 +17,5 @@
  * Simple marker for stopping publishing bytes
  */
 public enum DiscardEvent {
-    DISCARD
+  DISCARD
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index 49450e12f..8f2b18961 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,12 +12,12 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.HttpResponseBodyPart;
 
 import java.nio.ByteBuffer;
 
-import org.asynchttpclient.HttpResponseBodyPart;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 
 /**
  * A callback class used when an HTTP response body is received.
@@ -25,30 +25,30 @@
  */
 public class EagerResponseBodyPart extends HttpResponseBodyPart {
 
-    private final byte[] bytes;
-
-    public EagerResponseBodyPart(ByteBuf buf, boolean last) {
-        super(last);
-        bytes = byteBuf2Bytes(buf);
-    }
-
-    /**
-     * Return the response body's part bytes received.
-     * 
-     * @return the response body's part bytes received.
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        return bytes;
-    }
-
-    @Override
-    public int length() {
-        return bytes.length;
-    }
-
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return ByteBuffer.wrap(bytes);
-    }
+  private final byte[] bytes;
+
+  public EagerResponseBodyPart(ByteBuf buf, boolean last) {
+    super(last);
+    bytes = byteBuf2Bytes(buf);
+  }
+
+  /**
+   * Return the response body's part bytes received.
+   *
+   * @return the response body's part bytes received.
+   */
+  @Override
+  public byte[] getBodyPartBytes() {
+    return bytes;
+  }
+
+  @Override
+  public int length() {
+    return bytes.length;
+  }
+
+  @Override
+  public ByteBuffer getBodyByteBuffer() {
+    return ByteBuffer.wrap(bytes);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index 61a1aea83..1abe8ce11 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -13,45 +13,44 @@
 package org.asynchttpclient.netty;
 
 import io.netty.buffer.ByteBuf;
-
-import java.nio.ByteBuffer;
-
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.netty.util.ByteBufUtils;
 
+import java.nio.ByteBuffer;
+
 /**
  * A callback class used when an HTTP response body is received.
  */
 public class LazyResponseBodyPart extends HttpResponseBodyPart {
 
-    private final ByteBuf buf;
-
-    public LazyResponseBodyPart(ByteBuf buf, boolean last) {
-        super(last);
-        this.buf = buf;
-    }
-
-    public ByteBuf getBuf() {
-        return buf;
-    }
-
-    @Override
-    public int length() {
-        return buf.readableBytes();
-    }
-    
-    /**
-     * Return the response body's part bytes received.
-     * 
-     * @return the response body's part bytes received.
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        return ByteBufUtils.byteBuf2Bytes(buf.duplicate());
-    }
-
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return buf.nioBuffer();
-    }
+  private final ByteBuf buf;
+
+  public LazyResponseBodyPart(ByteBuf buf, boolean last) {
+    super(last);
+    this.buf = buf;
+  }
+
+  public ByteBuf getBuf() {
+    return buf;
+  }
+
+  @Override
+  public int length() {
+    return buf.readableBytes();
+  }
+
+  /**
+   * Return the response body's part bytes received.
+   *
+   * @return the response body's part bytes received.
+   */
+  @Override
+  public byte[] getBodyPartBytes() {
+    return ByteBufUtils.byteBuf2Bytes(buf.duplicate());
+  }
+
+  @Override
+  public ByteBuffer getBodyByteBuffer() {
+    return buf.nioBuffer();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
index ff45fb681..a923c321f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -13,13 +13,14 @@
  */
 package org.asynchttpclient.netty;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
 import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
@@ -31,196 +32,185 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
 
 /**
  * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
 public class NettyResponse implements Response {
 
-    private final List<HttpResponseBodyPart> bodyParts;
-    private final HttpHeaders headers;
-    private final HttpResponseStatus status;
-    private List<Cookie> cookies;
-
-    public NettyResponse(HttpResponseStatus status,//
-            HttpHeaders headers,//
-            List<HttpResponseBodyPart> bodyParts) {
-        this.bodyParts = bodyParts;
-        this.headers = headers;
-        this.status = status;
-    }
-
-    private List<Cookie> buildCookies() {
-
-        List<String> setCookieHeaders = headers.getAll(SET_COOKIE2);
-
-        if (!isNonEmpty(setCookieHeaders)) {
-            setCookieHeaders = headers.getAll(SET_COOKIE);
-        }
+  private final List<HttpResponseBodyPart> bodyParts;
+  private final HttpHeaders headers;
+  private final HttpResponseStatus status;
+  private List<Cookie> cookies;
 
-        if (isNonEmpty(setCookieHeaders)) {
-            List<Cookie> cookies = new ArrayList<>(1);
-            for (String value : setCookieHeaders) {
-                Cookie c = ClientCookieDecoder.STRICT.decode(value);
-                if (c != null)
-                    cookies.add(c);
-            }
-            return Collections.unmodifiableList(cookies);
-        }
+  public NettyResponse(HttpResponseStatus status,
+                       HttpHeaders headers,
+                       List<HttpResponseBodyPart> bodyParts) {
+    this.bodyParts = bodyParts;
+    this.headers = headers;
+    this.status = status;
+  }
 
-        return Collections.emptyList();
-    }
-
-    @Override
-    public final int getStatusCode() {
-        return status.getStatusCode();
-    }
-
-    @Override
-    public final String getStatusText() {
-        return status.getStatusText();
-    }
-
-    @Override
-    public final Uri getUri() {
-        return status.getUri();
-    }
-
-    @Override
-    public SocketAddress getRemoteAddress() {
-        return status.getRemoteAddress();
-    }
-
-    @Override
-    public SocketAddress getLocalAddress() {
-        return status.getLocalAddress();
-    }
-
-    @Override
-    public final String getContentType() {
-        return headers != null ? getHeader(CONTENT_TYPE) : null;
-    }
-
-    @Override
-    public final String getHeader(CharSequence name) {
-        return headers != null ? getHeaders().get(name) : null;
-    }
+  private List<Cookie> buildCookies() {
+
+    List<String> setCookieHeaders = headers.getAll(SET_COOKIE2);
 
-    @Override
-    public final List<String> getHeaders(CharSequence name) {
-        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
+    if (!isNonEmpty(setCookieHeaders)) {
+      setCookieHeaders = headers.getAll(SET_COOKIE);
+    }
+
+    if (isNonEmpty(setCookieHeaders)) {
+      List<Cookie> cookies = new ArrayList<>(1);
+      for (String value : setCookieHeaders) {
+        Cookie c = ClientCookieDecoder.STRICT.decode(value);
+        if (c != null)
+          cookies.add(c);
+      }
+      return Collections.unmodifiableList(cookies);
     }
 
-    @Override
-    public final HttpHeaders getHeaders() {
-        return headers != null ? headers : EmptyHttpHeaders.INSTANCE;
-    }
-
-    @Override
-    public final boolean isRedirected() {
-        switch (status.getStatusCode()) {
-        case 301:
-        case 302:
-        case 303:
-        case 307:
-        case 308:
-            return true;
-        default:
-            return false;
-        }
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-
-        if (headers == null) {
-            return Collections.emptyList();
-        }
-
-        if (cookies == null) {
-            cookies = buildCookies();
-        }
-        return cookies;
-
-    }
-
-    @Override
-    public boolean hasResponseStatus() {
-        return status != null;
-    }
-
-    @Override
-    public boolean hasResponseHeaders() {
-        return headers != null && !headers.isEmpty();
-    }
-
-    @Override
-    public boolean hasResponseBody() {
-        return isNonEmpty(bodyParts);
-    }
-
-    @Override
-    public byte[] getResponseBodyAsBytes() {
-        return getResponseBodyAsByteBuffer().array();
-    }
-
-    @Override
-    public ByteBuffer getResponseBodyAsByteBuffer() {
-
-        int length = 0;
-        for (HttpResponseBodyPart part : bodyParts)
-            length += part.length();
-
-        ByteBuffer target = ByteBuffer.wrap(new byte[length]);
-        for (HttpResponseBodyPart part : bodyParts)
-            target.put(part.getBodyPartBytes());
-
-        target.flip();
-        return target;
-    }
-
-    @Override
-    public String getResponseBody() {
-        return getResponseBody(null);
-    }
-
-    private Charset computeCharset(Charset charset) {
-
-        if (charset == null) {
-            String contentType = getContentType();
-            if (contentType != null)
-                charset = parseCharset(contentType); // parseCharset can return
-                                                     // null
-        }
-        return charset != null ? charset : DEFAULT_CHARSET;
-    }
-
-    @Override
-    public String getResponseBody(Charset charset) {
-        return new String(getResponseBodyAsBytes(), computeCharset(charset));
-    }
-
-    @Override
-    public InputStream getResponseBodyAsStream() {
-        return new ByteArrayInputStream(getResponseBodyAsBytes());
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(getClass().getSimpleName()).append(" {\n")//
-                .append("\tstatusCode=").append(getStatusCode()).append("\n")//
-                .append("\theaders=\n");
-
-        for (Map.Entry<String, String> header : getHeaders()) {
-            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
-        }
-        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
-                .append("}").toString();
-        return sb.toString();
-    }
+    return Collections.emptyList();
+  }
+
+  @Override
+  public final int getStatusCode() {
+    return status.getStatusCode();
+  }
+
+  @Override
+  public final String getStatusText() {
+    return status.getStatusText();
+  }
+
+  @Override
+  public final Uri getUri() {
+    return status.getUri();
+  }
+
+  @Override
+  public SocketAddress getRemoteAddress() {
+    return status.getRemoteAddress();
+  }
+
+  @Override
+  public SocketAddress getLocalAddress() {
+    return status.getLocalAddress();
+  }
+
+  @Override
+  public final String getContentType() {
+    return headers != null ? getHeader(CONTENT_TYPE) : null;
+  }
+
+  @Override
+  public final String getHeader(CharSequence name) {
+    return headers != null ? getHeaders().get(name) : null;
+  }
+
+  @Override
+  public final List<String> getHeaders(CharSequence name) {
+    return headers != null ? getHeaders().getAll(name) : Collections.emptyList();
+  }
+
+  @Override
+  public final HttpHeaders getHeaders() {
+    return headers != null ? headers : EmptyHttpHeaders.INSTANCE;
+  }
+
+  @Override
+  public final boolean isRedirected() {
+    switch (status.getStatusCode()) {
+      case 301:
+      case 302:
+      case 303:
+      case 307:
+      case 308:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  @Override
+  public List<Cookie> getCookies() {
+
+    if (headers == null) {
+      return Collections.emptyList();
+    }
+
+    if (cookies == null) {
+      cookies = buildCookies();
+    }
+    return cookies;
+
+  }
+
+  @Override
+  public boolean hasResponseStatus() {
+    return status != null;
+  }
+
+  @Override
+  public boolean hasResponseHeaders() {
+    return headers != null && !headers.isEmpty();
+  }
+
+  @Override
+  public boolean hasResponseBody() {
+    return isNonEmpty(bodyParts);
+  }
+
+  @Override
+  public byte[] getResponseBodyAsBytes() {
+    return getResponseBodyAsByteBuffer().array();
+  }
+
+  @Override
+  public ByteBuffer getResponseBodyAsByteBuffer() {
+
+    int length = 0;
+    for (HttpResponseBodyPart part : bodyParts)
+      length += part.length();
+
+    ByteBuffer target = ByteBuffer.wrap(new byte[length]);
+    for (HttpResponseBodyPart part : bodyParts)
+      target.put(part.getBodyPartBytes());
+
+    target.flip();
+    return target;
+  }
+
+  @Override
+  public String getResponseBody() {
+    return getResponseBody(withDefault(extractContentTypeCharsetAttribute(getContentType()), UTF_8));
+  }
+
+  @Override
+  public String getResponseBody(Charset charset) {
+    return new String(getResponseBodyAsBytes(), charset);
+  }
+
+  @Override
+  public InputStream getResponseBodyAsStream() {
+    return new ByteArrayInputStream(getResponseBodyAsBytes());
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName()).append(" {\n")
+            .append("\tstatusCode=").append(getStatusCode()).append("\n")
+            .append("\theaders=\n");
+
+    for (Map.Entry<String, String> header : getHeaders()) {
+      sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
+    }
+    return sb.append("\tbody=\n").append(getResponseBody()).append("\n")
+            .append("}").toString();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 0aaebc7fb..9f84ada7a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -13,20 +13,7 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.channel.Channel;
-
-import java.io.IOException;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Realm;
@@ -42,509 +29,516 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+
 /**
- * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
- * 
+ * A {@link Future} that can be used to track when an asynchronous HTTP request
+ * has been fully processed.
+ *
  * @param <V> the result type
  */
 public final class NettyResponseFuture<V> implements ListenableFuture<V> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
-
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "redirectCount");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "currentRetry");
-
-    private final long start = unpreciseMillisTime();
-    private final ChannelPoolPartitioning connectionPoolPartitioning;
-    private final ConnectionSemaphore connectionSemaphore;
-    private final ProxyServer proxyServer;
-    private final int maxRetry;
-    private final CompletableFuture<V> future = new CompletableFuture<>();
-
-    // state mutated from outside the event loop
-    // TODO check if they are indeed mutated outside the event loop
-    private volatile int isDone = 0;
-    private volatile int isCancelled = 0;
-    private volatile int inAuth = 0;
-    private volatile int inProxyAuth = 0;
-    private volatile int statusReceived = 0;
-    @SuppressWarnings("unused")
-    private volatile int contentProcessed = 0;
-    @SuppressWarnings("unused")
-    private volatile int onThrowableCalled = 0;
-    @SuppressWarnings("unused")
-    private volatile TimeoutsHolder timeoutsHolder;
-    // partition key, when != null used to release lock in ChannelManager
-    private volatile Object partitionKeyLock;
-
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isDoneField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isDone");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isCancelledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isCancelled");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inAuth");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inProxyAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inProxyAuth");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> contentProcessedField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "contentProcessed");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> onThrowableCalledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class,
-            "onThrowableCalled");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> timeoutsHolderField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class,
-            TimeoutsHolder.class, "timeoutsHolder");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> partitionKeyLockField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class,
-            Object.class, "partitionKeyLock");
-
-    // volatile where we need CAS ops
-    private volatile int redirectCount = 0;
-    private volatile int currentRetry = 0;
-
-    // volatile where we don't need CAS ops
-    private volatile long touch = unpreciseMillisTime();
-    private volatile ChannelState channelState = ChannelState.NEW;
-
-    // state mutated only inside the event loop
-    private Channel channel;
-    private boolean keepAlive = true;
-    private Request targetRequest;
-    private Request currentRequest;
-    private NettyRequest nettyRequest;
-    private AsyncHandler<V> asyncHandler;
-    private boolean streamAlreadyConsumed;
-    private boolean reuseChannel;
-    private boolean headersAlreadyWrittenOnContinue;
-    private boolean dontWriteBodyBecauseExpectContinue;
-    private boolean allowConnect;
-    private Realm realm;
-    private Realm proxyRealm;
-    public Throwable pendingException;
-
-    public NettyResponseFuture(Request originalRequest, //
-            AsyncHandler<V> asyncHandler, //
-            NettyRequest nettyRequest, //
-            int maxRetry, //
-            ChannelPoolPartitioning connectionPoolPartitioning, //
-            ConnectionSemaphore connectionSemaphore, //
-            ProxyServer proxyServer) {
-
-        this.asyncHandler = asyncHandler;
-        this.targetRequest = currentRequest = originalRequest;
-        this.nettyRequest = nettyRequest;
-        this.connectionPoolPartitioning = connectionPoolPartitioning;
-        this.connectionSemaphore = connectionSemaphore;
-        this.proxyServer = proxyServer;
-        this.maxRetry = maxRetry;
-    }
-
-    private void releasePartitionKeyLock() {
-        if (connectionSemaphore == null) {
-            return;
-        }
-
-        Object partitionKey = takePartitionKeyLock();
-        if (partitionKey != null) {
-            connectionSemaphore.releaseChannelLock(partitionKey);
-        }
-    }
-
-    // Take partition key lock object,
-    // but do not release channel lock.
-    public Object takePartitionKeyLock() {
-        // shortcut, much faster than getAndSet
-        if (partitionKeyLock == null) {
-            return null;
-        }
-
-        return partitionKeyLockField.getAndSet(this, null);
-    }
-
-    // java.util.concurrent.Future
-
-    @Override
-    public boolean isDone() {
-        return isDone != 0 || isCancelled();
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return isCancelled != 0;
-    }
-
-    @Override
-    public boolean cancel(boolean force) {
-        releasePartitionKeyLock();
-        cancelTimeouts();
-
-        if (isCancelledField.getAndSet(this, 1) != 0)
-            return false;
-
-        // cancel could happen before channel was attached
-        if (channel != null) {
-            Channels.setDiscard(channel);
-            Channels.silentlyCloseChannel(channel);
-        }
-
-        if (onThrowableCalledField.getAndSet(this, 1) == 0) {
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
+
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "redirectCount");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "currentRetry");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_DONE_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "isDone");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_CANCELLED_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "isCancelled");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_AUTH_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "inAuth");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_PROXY_AUTH_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "inProxyAuth");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CONTENT_PROCESSED_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "contentProcessed");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> ON_THROWABLE_CALLED_FIELD = AtomicIntegerFieldUpdater
+          .newUpdater(NettyResponseFuture.class, "onThrowableCalled");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> TIMEOUTS_HOLDER_FIELD = AtomicReferenceFieldUpdater
+          .newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
+  @SuppressWarnings("rawtypes")
+  private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> PARTITION_KEY_LOCK_FIELD = AtomicReferenceFieldUpdater
+          .newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
+
+  private final long start = unpreciseMillisTime();
+  private final ChannelPoolPartitioning connectionPoolPartitioning;
+  private final ConnectionSemaphore connectionSemaphore;
+  private final ProxyServer proxyServer;
+  private final int maxRetry;
+  private final CompletableFuture<V> future = new CompletableFuture<>();
+  public Throwable pendingException;
+  // state mutated from outside the event loop
+  // TODO check if they are indeed mutated outside the event loop
+  private volatile int isDone = 0;
+  private volatile int isCancelled = 0;
+  private volatile int inAuth = 0;
+  private volatile int inProxyAuth = 0;
+  @SuppressWarnings("unused")
+  private volatile int contentProcessed = 0;
+  @SuppressWarnings("unused")
+  private volatile int onThrowableCalled = 0;
+  @SuppressWarnings("unused")
+  private volatile TimeoutsHolder timeoutsHolder;
+  // partition key, when != null used to release lock in ChannelManager
+  private volatile Object partitionKeyLock;
+  // volatile where we need CAS ops
+  private volatile int redirectCount = 0;
+  private volatile int currentRetry = 0;
+  // volatile where we don't need CAS ops
+  private volatile long touch = unpreciseMillisTime();
+  private volatile ChannelState channelState = ChannelState.NEW;
+  // state mutated only inside the event loop
+  private Channel channel;
+  private boolean keepAlive = true;
+  private Request targetRequest;
+  private Request currentRequest;
+  private NettyRequest nettyRequest;
+  private AsyncHandler<V> asyncHandler;
+  private boolean streamAlreadyConsumed;
+  private boolean reuseChannel;
+  private boolean headersAlreadyWrittenOnContinue;
+  private boolean dontWriteBodyBecauseExpectContinue;
+  private boolean allowConnect;
+  private Realm realm;
+  private Realm proxyRealm;
+
+  public NettyResponseFuture(Request originalRequest,
+                             AsyncHandler<V> asyncHandler,
+                             NettyRequest nettyRequest,
+                             int maxRetry,
+                             ChannelPoolPartitioning connectionPoolPartitioning,
+                             ConnectionSemaphore connectionSemaphore,
+                             ProxyServer proxyServer) {
+
+    this.asyncHandler = asyncHandler;
+    this.targetRequest = currentRequest = originalRequest;
+    this.nettyRequest = nettyRequest;
+    this.connectionPoolPartitioning = connectionPoolPartitioning;
+    this.connectionSemaphore = connectionSemaphore;
+    this.proxyServer = proxyServer;
+    this.maxRetry = maxRetry;
+  }
+
+  private void releasePartitionKeyLock() {
+    if (connectionSemaphore == null) {
+      return;
+    }
+
+    Object partitionKey = takePartitionKeyLock();
+    if (partitionKey != null) {
+      connectionSemaphore.releaseChannelLock(partitionKey);
+    }
+  }
+
+  // Take partition key lock object,
+  // but do not release channel lock.
+  public Object takePartitionKeyLock() {
+    // shortcut, much faster than getAndSet
+    if (partitionKeyLock == null) {
+      return null;
+    }
+
+    return PARTITION_KEY_LOCK_FIELD.getAndSet(this, null);
+  }
+
+  // java.util.concurrent.Future
+
+  @Override
+  public boolean isDone() {
+    return isDone != 0 || isCancelled();
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return isCancelled != 0;
+  }
+
+  @Override
+  public boolean cancel(boolean force) {
+    releasePartitionKeyLock();
+    cancelTimeouts();
+
+    if (IS_CANCELLED_FIELD.getAndSet(this, 1) != 0)
+      return false;
+
+    // cancel could happen before channel was attached
+    if (channel != null) {
+      Channels.setDiscard(channel);
+      Channels.silentlyCloseChannel(channel);
+    }
+
+    if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
+      try {
+        asyncHandler.onThrowable(new CancellationException());
+      } catch (Throwable t) {
+        LOGGER.warn("cancel", t);
+      }
+    }
+
+    future.cancel(false);
+    return true;
+  }
+
+  @Override
+  public V get() throws InterruptedException, ExecutionException {
+    return future.get();
+  }
+
+  @Override
+  public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+    return future.get(l, tu);
+  }
+
+  private void loadContent() throws ExecutionException {
+    if (future.isDone()) {
+      try {
+        future.get();
+      } catch (InterruptedException e) {
+        throw new RuntimeException("unreachable", e);
+      }
+    }
+
+    // No more retry
+    CURRENT_RETRY_UPDATER.set(this, maxRetry);
+    if (CONTENT_PROCESSED_FIELD.getAndSet(this, 1) == 0) {
+      try {
+        future.complete(asyncHandler.onCompleted());
+      } catch (Throwable ex) {
+        if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
+          try {
             try {
-                asyncHandler.onThrowable(new CancellationException());
+              asyncHandler.onThrowable(ex);
             } catch (Throwable t) {
-                LOGGER.warn("cancel", t);
+              LOGGER.debug("asyncHandler.onThrowable", t);
             }
+          } finally {
+            cancelTimeouts();
+          }
         }
-
-        future.cancel(false);
-        return true;
+        future.completeExceptionally(ex);
+      }
     }
+    future.getNow(null);
+  }
 
-    @Override
-    public V get() throws InterruptedException, ExecutionException {
-        return future.get();
-    }
+  // org.asynchttpclient.ListenableFuture
 
-    @Override
-    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
-        return future.get(l, tu);
-    }
+  private boolean terminateAndExit() {
+    releasePartitionKeyLock();
+    cancelTimeouts();
+    this.channel = null;
+    this.reuseChannel = false;
+    return IS_DONE_FIELD.getAndSet(this, 1) != 0 || isCancelled != 0;
+  }
 
-    private V getContent() throws ExecutionException {
-        if (future.isDone()) {
-            try {
-                return future.get();
-            } catch (InterruptedException e) {
-                throw new RuntimeException("unreachable", e);
-            }
-        }
+  public final void done() {
 
-        // No more retry
-        CURRENT_RETRY_UPDATER.set(this, maxRetry);
-        if (contentProcessedField.getAndSet(this, 1) == 0) {
-            try {
-                future.complete(asyncHandler.onCompleted());
-            } catch (Throwable ex) {
-                if (onThrowableCalledField.getAndSet(this, 1) == 0) {
-                    try {
-                        try {
-                            asyncHandler.onThrowable(ex);
-                        } catch (Throwable t) {
-                            LOGGER.debug("asyncHandler.onThrowable", t);
-                        }
-                    } finally {
-                        cancelTimeouts();
-                    }
-                }
-                future.completeExceptionally(ex);
-            }
-        }
-        return future.getNow(null);
-    }
+    if (terminateAndExit())
+      return;
 
-    // org.asynchttpclient.ListenableFuture
+    try {
+      loadContent();
+    } catch (ExecutionException ignored) {
 
-    private boolean terminateAndExit() {
-        releasePartitionKeyLock();
-        cancelTimeouts();
-        this.channel = null;
-        this.reuseChannel = false;
-        return isDoneField.getAndSet(this, 1) != 0 || isCancelled != 0;
+    } catch (RuntimeException t) {
+      future.completeExceptionally(t);
+    } catch (Throwable t) {
+      future.completeExceptionally(t);
+      throw t;
     }
+  }
 
-    public final void done() {
+  public final void abort(final Throwable t) {
 
-        if (terminateAndExit())
-            return;
+    if (terminateAndExit())
+      return;
 
-        try {
-            getContent();
-        } catch (ExecutionException ignored) {
+    future.completeExceptionally(t);
 
-        } catch (RuntimeException t) {
-            future.completeExceptionally(t);
-        } catch (Throwable t) {
-            future.completeExceptionally(t);
-            throw t;
-        }
+    if (ON_THROWABLE_CALLED_FIELD.compareAndSet(this, 0, 1)) {
+      try {
+        asyncHandler.onThrowable(t);
+      } catch (Throwable te) {
+        LOGGER.debug("asyncHandler.onThrowable", te);
+      }
     }
+  }
 
-    public final void abort(final Throwable t) {
-
-        if (terminateAndExit())
-            return;
+  @Override
+  public void touch() {
+    touch = unpreciseMillisTime();
+  }
 
-        future.completeExceptionally(t);
-
-        if (onThrowableCalledField.compareAndSet(this, 0, 1)) {
-            try {
-                asyncHandler.onThrowable(t);
-            } catch (Throwable te) {
-                LOGGER.debug("asyncHandler.onThrowable", te);
-            }
-        }
+  @Override
+  public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
+    if (exec == null) {
+      exec = Runnable::run;
     }
+    future.whenCompleteAsync((r, v) -> listener.run(), exec);
+    return this;
+  }
 
-    @Override
-    public void touch() {
-        touch = unpreciseMillisTime();
-    }
+  @Override
+  public CompletableFuture<V> toCompletableFuture() {
+    return future;
+  }
 
-    @Override
-    public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
-        if (exec == null) {
-            exec = Runnable::run;
-        }
-        future.whenCompleteAsync((r, v) -> listener.run(), exec);
-        return this;
-    }
+  // INTERNAL
 
-    @Override
-    public CompletableFuture<V> toCompletableFuture() {
-        return future;
-    }
+  public Uri getUri() {
+    return targetRequest.getUri();
+  }
 
-    // INTERNAL
+  public ProxyServer getProxyServer() {
+    return proxyServer;
+  }
 
-    public Uri getUri() {
-        return targetRequest.getUri();
+  public void cancelTimeouts() {
+    TimeoutsHolder ref = TIMEOUTS_HOLDER_FIELD.getAndSet(this, null);
+    if (ref != null) {
+      ref.cancel();
     }
+  }
 
-    public ChannelPoolPartitioning getConnectionPoolPartitioning() {
-        return connectionPoolPartitioning;
-    }
+  public final Request getTargetRequest() {
+    return targetRequest;
+  }
 
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
+  public void setTargetRequest(Request targetRequest) {
+    this.targetRequest = targetRequest;
+  }
 
-    public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
-        this.asyncHandler = asyncHandler;
-    }
+  public final Request getCurrentRequest() {
+    return currentRequest;
+  }
 
-    public void cancelTimeouts() {
-        TimeoutsHolder ref = timeoutsHolderField.getAndSet(this, null);
-        if (ref != null) {
-            ref.cancel();
-        }
-    }
+  public void setCurrentRequest(Request currentRequest) {
+    this.currentRequest = currentRequest;
+  }
 
-    public final Request getTargetRequest() {
-        return targetRequest;
-    }
+  public final NettyRequest getNettyRequest() {
+    return nettyRequest;
+  }
 
-    public final Request getCurrentRequest() {
-        return currentRequest;
-    }
+  public final void setNettyRequest(NettyRequest nettyRequest) {
+    this.nettyRequest = nettyRequest;
+  }
 
-    public final NettyRequest getNettyRequest() {
-        return nettyRequest;
-    }
+  public final AsyncHandler<V> getAsyncHandler() {
+    return asyncHandler;
+  }
 
-    public final void setNettyRequest(NettyRequest nettyRequest) {
-        this.nettyRequest = nettyRequest;
-    }
+  public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+    this.asyncHandler = asyncHandler;
+  }
 
-    public final AsyncHandler<V> getAsyncHandler() {
-        return asyncHandler;
-    }
+  public final boolean isKeepAlive() {
+    return keepAlive;
+  }
 
-    public final boolean isKeepAlive() {
-        return keepAlive;
-    }
+  public final void setKeepAlive(final boolean keepAlive) {
+    this.keepAlive = keepAlive;
+  }
 
-    public final void setKeepAlive(final boolean keepAlive) {
-        this.keepAlive = keepAlive;
-    }
+  public int incrementAndGetCurrentRedirectCount() {
+    return REDIRECT_COUNT_UPDATER.incrementAndGet(this);
+  }
 
-    public int incrementAndGetCurrentRedirectCount() {
-        return REDIRECT_COUNT_UPDATER.incrementAndGet(this);
-    }
-
-    public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
-        timeoutsHolderField.set(this, timeoutsHolder);
-    }
-
-    public TimeoutsHolder getTimeoutsHolder() {
-        return timeoutsHolderField.get(this);
-    }
-
-    public boolean isInAuth() {
-        return inAuth != 0;
-    }
-
-    public void setInAuth(boolean inAuth) {
-        this.inAuth = inAuth ? 1 : 0;
-    }
-
-    public boolean isAndSetInAuth(boolean set) {
-        return inAuthField.getAndSet(this, set ? 1 : 0) != 0;
-    }
-
-    public boolean isInProxyAuth() {
-        return inProxyAuth != 0;
-    }
-
-    public void setInProxyAuth(boolean inProxyAuth) {
-        this.inProxyAuth = inProxyAuth ? 1 : 0;
-    }
-
-    public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
-        return inProxyAuthField.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
-    }
-
-    public ChannelState getChannelState() {
-        return channelState;
-    }
-
-    public void setChannelState(ChannelState channelState) {
-        this.channelState = channelState;
-    }
-
-    public boolean isStreamConsumed() {
-        return streamAlreadyConsumed;
-    }
-
-    public void setStreamConsumed(boolean streamConsumed) {
-        this.streamAlreadyConsumed = streamConsumed;
-    }
-
-    public long getLastTouch() {
-        return touch;
-    }
-
-    public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
-        this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
-    }
-
-    public boolean isHeadersAlreadyWrittenOnContinue() {
-        return headersAlreadyWrittenOnContinue;
-    }
-
-    public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
-        this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
-    }
-
-    public boolean isDontWriteBodyBecauseExpectContinue() {
-        return dontWriteBodyBecauseExpectContinue;
-    }
-
-    public void setReuseChannel(boolean reuseChannel) {
-        this.reuseChannel = reuseChannel;
-    }
-
-    public boolean isConnectAllowed() {
-        return allowConnect;
-    }
-
-    public void setConnectAllowed(boolean allowConnect) {
-        this.allowConnect = allowConnect;
-    }
-
-    public void attachChannel(Channel channel, boolean reuseChannel) {
-
-        // future could have been cancelled first
-        if (isDone()) {
-            Channels.silentlyCloseChannel(channel);
-        }
-
-        this.channel = channel;
-        this.reuseChannel = reuseChannel;
-    }
-
-    public Channel channel() {
-        return channel;
-    }
+  public TimeoutsHolder getTimeoutsHolder() {
+    return TIMEOUTS_HOLDER_FIELD.get(this);
+  }
 
-    public boolean isReuseChannel() {
-        return reuseChannel;
-    }
+  public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
+    TIMEOUTS_HOLDER_FIELD.set(this, timeoutsHolder);
+  }
 
-    public boolean incrementRetryAndCheck() {
-        return maxRetry > 0 && CURRENT_RETRY_UPDATER.incrementAndGet(this) <= maxRetry;
-    }
+  public boolean isInAuth() {
+    return inAuth != 0;
+  }
+
+  public void setInAuth(boolean inAuth) {
+    this.inAuth = inAuth ? 1 : 0;
+  }
 
-    public void setTargetRequest(Request targetRequest) {
-        this.targetRequest = targetRequest;
-    }
+  public boolean isAndSetInAuth(boolean set) {
+    return IN_AUTH_FIELD.getAndSet(this, set ? 1 : 0) != 0;
+  }
 
-    public void setCurrentRequest(Request currentRequest) {
-        this.currentRequest = currentRequest;
-    }
+  public boolean isInProxyAuth() {
+    return inProxyAuth != 0;
+  }
 
-    /**
-     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can
-     * recover from that exception.
-     * 
-     * @return true if that {@link Future} cannot be recovered.
-     */
-    public boolean isReplayPossible() {
-        return !isDone() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && inAuth == 0 && inProxyAuth == 0;
-    }
+  public void setInProxyAuth(boolean inProxyAuth) {
+    this.inProxyAuth = inProxyAuth ? 1 : 0;
+  }
 
-    public long getStart() {
-        return start;
-    }
+  public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
+    return IN_PROXY_AUTH_FIELD.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
+  }
 
-    public Object getPartitionKey() {
-        return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(), proxyServer);
-    }
+  public ChannelState getChannelState() {
+    return channelState;
+  }
 
-    public void acquirePartitionLockLazily() throws IOException {
-        if (connectionSemaphore == null || partitionKeyLock != null) {
-            return;
-        }
+  public void setChannelState(ChannelState channelState) {
+    this.channelState = channelState;
+  }
 
-        Object partitionKey = getPartitionKey();
-        connectionSemaphore.acquireChannelLock(partitionKey);
-        Object prevKey = partitionKeyLockField.getAndSet(this, partitionKey);
-        if (prevKey != null) {
-            // self-check
+  public boolean isStreamConsumed() {
+    return streamAlreadyConsumed;
+  }
 
-            connectionSemaphore.releaseChannelLock(prevKey);
-            releasePartitionKeyLock();
+  public void setStreamConsumed(boolean streamConsumed) {
+    this.streamAlreadyConsumed = streamConsumed;
+  }
 
-            throw new IllegalStateException("Trying to acquire partition lock concurrently. Please report.");
-        }
+  public long getLastTouch() {
+    return touch;
+  }
 
-        if (isDone()) {
-            // may be cancelled while we acquired a lock
-            releasePartitionKeyLock();
-        }
-    }
+  public boolean isHeadersAlreadyWrittenOnContinue() {
+    return headersAlreadyWrittenOnContinue;
+  }
 
-    public Realm getRealm() {
-        return realm;
-    }
+  public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
+    this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
+  }
 
-    public void setRealm(Realm realm) {
-        this.realm = realm;
-    }
+  public boolean isDontWriteBodyBecauseExpectContinue() {
+    return dontWriteBodyBecauseExpectContinue;
+  }
 
-    public Realm getProxyRealm() {
-        return proxyRealm;
-    }
+  public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
+    this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
+  }
 
-    public void setProxyRealm(Realm proxyRealm) {
-        this.proxyRealm = proxyRealm;
-    }
+  public boolean isConnectAllowed() {
+    return allowConnect;
+  }
 
-    @Override
-    public String toString() {
-        return "NettyResponseFuture{" + //
-                "currentRetry=" + currentRetry + //
-                ",\n\tisDone=" + isDone + //
-                ",\n\tisCancelled=" + isCancelled + //
-                ",\n\tasyncHandler=" + asyncHandler + //
-                ",\n\tnettyRequest=" + nettyRequest + //
-                ",\n\tfuture=" + future + //
-                ",\n\turi=" + getUri() + //
-                ",\n\tkeepAlive=" + keepAlive + //
-                ",\n\tredirectCount=" + redirectCount + //
-                ",\n\ttimeoutsHolder=" + timeoutsHolderField.get(this) + //
-                ",\n\tinAuth=" + inAuth + //
-                ",\n\tstatusReceived=" + statusReceived + //
-                ",\n\ttouch=" + touch + //
-                '}';
-    }
+  public void setConnectAllowed(boolean allowConnect) {
+    this.allowConnect = allowConnect;
+  }
+
+  public void attachChannel(Channel channel, boolean reuseChannel) {
+
+    // future could have been cancelled first
+    if (isDone()) {
+      Channels.silentlyCloseChannel(channel);
+    }
+
+    this.channel = channel;
+    this.reuseChannel = reuseChannel;
+  }
+
+  public Channel channel() {
+    return channel;
+  }
+
+  public boolean isReuseChannel() {
+    return reuseChannel;
+  }
+
+  public void setReuseChannel(boolean reuseChannel) {
+    this.reuseChannel = reuseChannel;
+  }
+
+  public boolean incrementRetryAndCheck() {
+    return maxRetry > 0 && CURRENT_RETRY_UPDATER.incrementAndGet(this) <= maxRetry;
+  }
+
+  /**
+   * Return true if the {@link Future} can be recovered. There is some scenario
+   * where a connection can be closed by an unexpected IOException, and in some
+   * situation we can recover from that exception.
+   *
+   * @return true if that {@link Future} cannot be recovered.
+   */
+  public boolean isReplayPossible() {
+    return !isDone() && !(Channels.isChannelActive(channel) && !getUri().getScheme().equalsIgnoreCase("https"))
+            && inAuth == 0 && inProxyAuth == 0;
+  }
+
+  public long getStart() {
+    return start;
+  }
+
+  public Object getPartitionKey() {
+    return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(),
+            proxyServer);
+  }
+
+  public void acquirePartitionLockLazily() throws IOException {
+    if (connectionSemaphore == null || partitionKeyLock != null) {
+      return;
+    }
+
+    Object partitionKey = getPartitionKey();
+    connectionSemaphore.acquireChannelLock(partitionKey);
+    Object prevKey = PARTITION_KEY_LOCK_FIELD.getAndSet(this, partitionKey);
+    if (prevKey != null) {
+      // self-check
+
+      connectionSemaphore.releaseChannelLock(prevKey);
+      releasePartitionKeyLock();
+
+      throw new IllegalStateException("Trying to acquire partition lock concurrently. Please report.");
+    }
+
+    if (isDone()) {
+      // may be cancelled while we acquired a lock
+      releasePartitionKeyLock();
+    }
+  }
+
+  public Realm getRealm() {
+    return realm;
+  }
+
+  public void setRealm(Realm realm) {
+    this.realm = realm;
+  }
+
+  public Realm getProxyRealm() {
+    return proxyRealm;
+  }
+
+  public void setProxyRealm(Realm proxyRealm) {
+    this.proxyRealm = proxyRealm;
+  }
+
+  @Override
+  public String toString() {
+    return "NettyResponseFuture{" + //
+            "currentRetry=" + currentRetry + //
+            ",\n\tisDone=" + isDone + //
+            ",\n\tisCancelled=" + isCancelled + //
+            ",\n\tasyncHandler=" + asyncHandler + //
+            ",\n\tnettyRequest=" + nettyRequest + //
+            ",\n\tfuture=" + future + //
+            ",\n\turi=" + getUri() + //
+            ",\n\tkeepAlive=" + keepAlive + //
+            ",\n\tredirectCount=" + redirectCount + //
+            ",\n\ttimeoutsHolder=" + TIMEOUTS_HOLDER_FIELD.get(this) + //
+            ",\n\tinAuth=" + inAuth + //
+            ",\n\ttouch=" + touch + //
+            '}';
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
index 79fa97dae..bd5bce1f6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -15,78 +15,77 @@
 
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpResponse;
-
-import java.net.SocketAddress;
-
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.uri.Uri;
 
+import java.net.SocketAddress;
+
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
 public class NettyResponseStatus extends HttpResponseStatus {
 
-    private final HttpResponse response;
-    private final SocketAddress remoteAddress;
-    private final SocketAddress localAddress;
+  private final HttpResponse response;
+  private final SocketAddress remoteAddress;
+  private final SocketAddress localAddress;
 
-    public NettyResponseStatus(Uri uri, HttpResponse response, Channel channel) {
-        super(uri);
-        this.response = response;
-        if (channel != null) {
-            remoteAddress = channel.remoteAddress();
-            localAddress = channel.localAddress();
-        } else {
-            remoteAddress = null;
-            localAddress = null;
-        }
+  public NettyResponseStatus(Uri uri, HttpResponse response, Channel channel) {
+    super(uri);
+    this.response = response;
+    if (channel != null) {
+      remoteAddress = channel.remoteAddress();
+      localAddress = channel.localAddress();
+    } else {
+      remoteAddress = null;
+      localAddress = null;
     }
+  }
 
-    /**
-     * Return the response status code
-     * 
-     * @return the response status code
-     */
-    public int getStatusCode() {
-        return response.status().code();
-    }
+  /**
+   * Return the response status code
+   *
+   * @return the response status code
+   */
+  public int getStatusCode() {
+    return response.status().code();
+  }
 
-    /**
-     * Return the response status text
-     * 
-     * @return the response status text
-     */
-    public String getStatusText() {
-        return response.status().reasonPhrase();
-    }
+  /**
+   * Return the response status text
+   *
+   * @return the response status text
+   */
+  public String getStatusText() {
+    return response.status().reasonPhrase();
+  }
 
-    @Override
-    public String getProtocolName() {
-        return response.protocolVersion().protocolName();
-    }
+  @Override
+  public String getProtocolName() {
+    return response.protocolVersion().protocolName();
+  }
 
-    @Override
-    public int getProtocolMajorVersion() {
-        return response.protocolVersion().majorVersion();
-    }
+  @Override
+  public int getProtocolMajorVersion() {
+    return response.protocolVersion().majorVersion();
+  }
 
-    @Override
-    public int getProtocolMinorVersion() {
-        return response.protocolVersion().minorVersion();
-    }
+  @Override
+  public int getProtocolMinorVersion() {
+    return response.protocolVersion().minorVersion();
+  }
 
-    @Override
-    public String getProtocolText() {
-        return response.protocolVersion().text();
-    }
+  @Override
+  public String getProtocolText() {
+    return response.protocolVersion().text();
+  }
 
-    @Override
-    public SocketAddress getRemoteAddress() {
-        return remoteAddress;
-    }
+  @Override
+  public SocketAddress getRemoteAddress() {
+    return remoteAddress;
+  }
 
-    @Override
-    public SocketAddress getLocalAddress() {
-        return localAddress;
-    }
+  @Override
+  public SocketAddress getLocalAddress() {
+    return localAddress;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
index 0f1df7e51..87913e3cf 100644
--- a/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
+++ b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
@@ -14,15 +14,15 @@
 
 public abstract class OnLastHttpContentCallback {
 
-    protected final NettyResponseFuture<?> future;
+  protected final NettyResponseFuture<?> future;
 
-    public OnLastHttpContentCallback(NettyResponseFuture<?> future) {
-        this.future = future;
-    }
+  protected OnLastHttpContentCallback(NettyResponseFuture<?> future) {
+    this.future = future;
+  }
 
-    abstract public void call() throws Exception;
+  abstract public void call() throws Exception;
 
-    public NettyResponseFuture<?> future() {
-        return future;
-    }
+  public NettyResponseFuture<?> future() {
+    return future;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
index f2c8c2c91..3d8afa96f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
@@ -19,17 +19,17 @@
 
 public abstract class SimpleChannelFutureListener implements ChannelFutureListener {
 
-    @Override
-    public final void operationComplete(ChannelFuture future) throws Exception {
-        Channel channel = future.channel();
-        if (future.isSuccess()) {
-            onSuccess(channel);
-        } else {
-            onFailure(channel, future.cause());
-        }
+  @Override
+  public final void operationComplete(ChannelFuture future) {
+    Channel channel = future.channel();
+    if (future.isSuccess()) {
+      onSuccess(channel);
+    } else {
+      onFailure(channel, future.cause());
     }
+  }
 
-    public abstract void onSuccess(Channel channel);
+  public abstract void onSuccess(Channel channel);
 
-    public abstract void onFailure(Channel channel, Throwable cause);
+  public abstract void onFailure(Channel channel, Throwable cause);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
index f10f9ff4c..a0f35fce8 100644
--- a/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
@@ -18,16 +18,16 @@
 
 public abstract class SimpleFutureListener<V> implements FutureListener<V> {
 
-    @Override
-    public final void operationComplete(Future<V> future) throws Exception {
-        if (future.isSuccess()) {
-            onSuccess(future.getNow());
-        } else {
-            onFailure(future.cause());
-        }
+  @Override
+  public final void operationComplete(Future<V> future) throws Exception {
+    if (future.isSuccess()) {
+      onSuccess(future.getNow());
+    } else {
+      onFailure(future.cause());
     }
+  }
 
-    protected abstract void onSuccess(V value) throws Exception;
+  protected abstract void onSuccess(V value) throws Exception;
 
-    protected abstract void onFailure(Throwable t) throws Exception;
+  protected abstract void onFailure(Throwable t) throws Exception;
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 0a6b0caad..6a5ed0597 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -13,16 +13,9 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
-
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFactory;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
+import io.netty.channel.*;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -32,34 +25,21 @@
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
 import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
+import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.proxy.ProxyHandler;
+import io.netty.handler.proxy.Socks4ProxyHandler;
+import io.netty.handler.proxy.Socks5ProxyHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.resolver.NameResolver;
 import io.netty.util.Timer;
-import io.netty.util.concurrent.DefaultThreadFactory;
-import io.netty.util.concurrent.GlobalEventExecutor;
-
-import java.net.InetSocketAddress;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLException;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ClientStats;
-import org.asynchttpclient.HostStats;
-import org.asynchttpclient.SslEngineFactory;
+import io.netty.util.concurrent.*;
+import org.asynchttpclient.*;
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.channel.NoopChannelPool;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
@@ -72,377 +52,447 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class ChannelManager {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
-    public static final String PINNED_ENTRY = "entry";
-    public static final String HTTP_CLIENT_CODEC = "http";
-    public static final String SSL_HANDLER = "ssl";
-    public static final String DEFLATER_HANDLER = "deflater";
-    public static final String INFLATER_HANDLER = "inflater";
-    public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
-    public static final String WS_DECODER_HANDLER = "ws-decoder";
-    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
-    public static final String WS_ENCODER_HANDLER = "ws-encoder";
-    public static final String AHC_HTTP_HANDLER = "ahc-http";
-    public static final String AHC_WS_HANDLER = "ahc-ws";
-    public static final String LOGGING_HANDLER = "logging";
-
-    private final AsyncHttpClientConfig config;
-    private final SslEngineFactory sslEngineFactory;
-    private final EventLoopGroup eventLoopGroup;
-    private final boolean allowReleaseEventLoopGroup;
-    private final Bootstrap httpBootstrap;
-    private final Bootstrap wsBootstrap;
-    private final long handshakeTimeout;
-
-    private final ChannelPool channelPool;
-    private final ChannelGroup openChannels;
-
-    private AsyncHttpClientHandler wsHandler;
-
-    public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
-
-        this.config = config;
-
-        this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new DefaultSslEngineFactory();
-        try {
-            this.sslEngineFactory.init(config);
-        } catch (SSLException e) {
-            throw new RuntimeException("Could not initialize sslEngineFactory", e);
-        }
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
-        ChannelPool channelPool = config.getChannelPool();
-        if (channelPool == null) {
-            if (config.isKeepAlive()) {
-                channelPool = new DefaultChannelPool(config, nettyTimer);
-            } else {
-                channelPool = NoopChannelPool.INSTANCE;
-            }
-        }
-        this.channelPool = channelPool;
+public class ChannelManager {
 
-        openChannels = new DefaultChannelGroup("asyncHttpClient", GlobalEventExecutor.INSTANCE);
+  public static final String HTTP_CLIENT_CODEC = "http";
+  public static final String SSL_HANDLER = "ssl";
+  public static final String SOCKS_HANDLER = "socks";
+  public static final String INFLATER_HANDLER = "inflater";
+  public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
+  public static final String WS_DECODER_HANDLER = "ws-decoder";
+  public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
+  public static final String WS_COMPRESSOR_HANDLER = "ws-compressor";
+  public static final String WS_ENCODER_HANDLER = "ws-encoder";
+  public static final String AHC_HTTP_HANDLER = "ahc-http";
+  public static final String AHC_WS_HANDLER = "ahc-ws";
+  public static final String LOGGING_HANDLER = "logging";
+  private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
+  private final AsyncHttpClientConfig config;
+  private final SslEngineFactory sslEngineFactory;
+  private final EventLoopGroup eventLoopGroup;
+  private final boolean allowReleaseEventLoopGroup;
+  private final Bootstrap httpBootstrap;
+  private final Bootstrap wsBootstrap;
+  private final long handshakeTimeout;
+
+  private final ChannelPool channelPool;
+  private final ChannelGroup openChannels;
+
+  private AsyncHttpClientHandler wsHandler;
+
+  public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
+
+    this.config = config;
+
+    this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new DefaultSslEngineFactory();
+    try {
+      this.sslEngineFactory.init(config);
+    } catch (SSLException e) {
+      throw new RuntimeException("Could not initialize sslEngineFactory", e);
+    }
 
-        handshakeTimeout = config.getHandshakeTimeout();
+    ChannelPool channelPool = config.getChannelPool();
+    if (channelPool == null) {
+      if (config.isKeepAlive()) {
+        channelPool = new DefaultChannelPool(config, nettyTimer);
+      } else {
+        channelPool = NoopChannelPool.INSTANCE;
+      }
+    }
+    this.channelPool = channelPool;
+
+    openChannels = new DefaultChannelGroup("asyncHttpClient", GlobalEventExecutor.INSTANCE);
+
+    handshakeTimeout = config.getHandshakeTimeout();
+
+    // check if external EventLoopGroup is defined
+    ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
+    allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
+    ChannelFactory<? extends Channel> channelFactory;
+    if (allowReleaseEventLoopGroup) {
+      if (config.isUseNativeTransport()) {
+        eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);
+        channelFactory = getEpollSocketChannelFactory();
+
+      } else {
+        eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), threadFactory);
+        channelFactory = NioSocketChannelFactory.INSTANCE;
+      }
+
+    } else {
+      eventLoopGroup = config.getEventLoopGroup();
+      if (eventLoopGroup instanceof OioEventLoopGroup)
+        throw new IllegalArgumentException("Oio is not supported");
+
+      if (eventLoopGroup instanceof NioEventLoopGroup) {
+        channelFactory = NioSocketChannelFactory.INSTANCE;
+      } else {
+        channelFactory = getEpollSocketChannelFactory();
+      }
+    }
 
-        // check if external EventLoopGroup is defined
-        ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
-        allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
-        ChannelFactory<? extends Channel> channelFactory;
-        if (allowReleaseEventLoopGroup) {
-            if (config.isUseNativeTransport()) {
-                eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);
-                channelFactory = getEpollSocketChannelFactory();
+    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
+    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
 
-            } else {
-                eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), threadFactory);
-                channelFactory = NioSocketChannelFactory.INSTANCE;
-            }
+    // for reactive streams
+    httpBootstrap.option(ChannelOption.AUTO_READ, false);
+  }
 
-        } else {
-            eventLoopGroup = config.getEventLoopGroup();
-            if (eventLoopGroup instanceof OioEventLoopGroup)
-                throw new IllegalArgumentException("Oio is not supported");
-
-            if (eventLoopGroup instanceof NioEventLoopGroup) {
-                channelFactory = NioSocketChannelFactory.INSTANCE;
-            } else {
-                channelFactory = getEpollSocketChannelFactory();
-            }
-        }
+  public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
+    return pipeline.get(SSL_HANDLER) != null;
+  }
 
-        httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
-        wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
+  private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
+    @SuppressWarnings("deprecation")
+    Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory).group(eventLoopGroup)
+            .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)
+            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())
+            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())
+            .option(ChannelOption.AUTO_CLOSE, false);
 
-        // for reactive streams
-        httpBootstrap.option(ChannelOption.AUTO_READ, false);
+    if (config.getConnectTimeout() > 0) {
+      bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
     }
 
-    private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
-        @SuppressWarnings("deprecation")
-        Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory).group(eventLoopGroup)//
-                .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)//
-                .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())//
-                .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//
-                .option(ChannelOption.AUTO_CLOSE, false);
-
-        if (config.getConnectTimeout() > 0) {
-            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
-        }
-
-        if (config.getSoLinger() >= 0) {
-            bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
-        }
-
-        if (config.getSoSndBuf() >= 0) {
-            bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());
-        }
-
-        if (config.getSoRcvBuf() >= 0) {
-            bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());
-        }
+    if (config.getSoLinger() >= 0) {
+      bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
+    }
 
-        for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
-            bootstrap.option(entry.getKey(), entry.getValue());
-        }
+    if (config.getSoSndBuf() >= 0) {
+      bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());
+    }
 
-        return bootstrap;
+    if (config.getSoRcvBuf() >= 0) {
+      bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());
     }
 
-    private EventLoopGroup newEpollEventLoopGroup(int ioThreadsCount, ThreadFactory threadFactory) {
-        try {
-            Class<?> epollEventLoopGroupClass = Class.forName("io.netty.channel.epoll.EpollEventLoopGroup");
-            return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(ioThreadsCount, threadFactory);
-        } catch (Exception e) {
-            throw new IllegalArgumentException(e);
-        }
+    for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
+      bootstrap.option(entry.getKey(), entry.getValue());
     }
 
-    @SuppressWarnings("unchecked")
-    private ChannelFactory<? extends Channel> getEpollSocketChannelFactory() {
-        try {
-            return (ChannelFactory<? extends Channel>) Class.forName("org.asynchttpclient.netty.channel.EpollSocketChannelFactory").newInstance();
-        } catch (Exception e) {
-            throw new IllegalArgumentException(e);
-        }
+    return bootstrap;
+  }
+
+  private EventLoopGroup newEpollEventLoopGroup(int ioThreadsCount, ThreadFactory threadFactory) {
+    try {
+      Class<?> epollEventLoopGroupClass = Class.forName("io.netty.channel.epoll.EpollEventLoopGroup");
+      return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(ioThreadsCount, threadFactory);
+    } catch (Exception e) {
+      throw new IllegalArgumentException(e);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private ChannelFactory<? extends Channel> getEpollSocketChannelFactory() {
+    try {
+      return (ChannelFactory<? extends Channel>) Class.forName("org.asynchttpclient.netty.channel.EpollSocketChannelFactory").newInstance();
+    } catch (Exception e) {
+      throw new IllegalArgumentException(e);
     }
+  }
 
-    public void configureBootstraps(NettyRequestSender requestSender) {
+  public void configureBootstraps(NettyRequestSender requestSender) {
 
-        final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);
-        wsHandler = new WebSocketHandler(config, this, requestSender);
+    final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);
+    wsHandler = new WebSocketHandler(config, this, requestSender);
 
-        final NoopHandler pinnedEntry = new NoopHandler();
+    final LoggingHandler loggingHandler = new LoggingHandler(LogLevel.TRACE);
 
-        final LoggingHandler loggingHandler = new LoggingHandler(LogLevel.TRACE);
+    httpBootstrap.handler(new ChannelInitializer<Channel>() {
+      @Override
+      protected void initChannel(Channel ch) {
+        ChannelPipeline pipeline = ch.pipeline()
+                .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())
+                .addLast(INFLATER_HANDLER, newHttpContentDecompressor())
+                .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())
+                .addLast(AHC_HTTP_HANDLER, httpHandler);
 
-        httpBootstrap.handler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline()//
-                        .addLast(PINNED_ENTRY, pinnedEntry)//
-                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
-                        .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//
-                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
-                        .addLast(AHC_HTTP_HANDLER, httpHandler);
-
-                if (LOGGER.isTraceEnabled()) {
-                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
-                }
-
-                if (config.getHttpAdditionalChannelInitializer() != null)
-                    config.getHttpAdditionalChannelInitializer().initChannel(ch);
-            }
-        });
+        if (LOGGER.isTraceEnabled()) {
+          pipeline.addFirst(LOGGING_HANDLER, loggingHandler);
+        }
 
-        wsBootstrap.handler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline pipeline = ch.pipeline()//
-                        .addLast(PINNED_ENTRY, pinnedEntry)//
-                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
-                        .addLast(AHC_WS_HANDLER, wsHandler);
-
-                if (LOGGER.isDebugEnabled()) {
-                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
-                }
-
-                if (config.getWsAdditionalChannelInitializer() != null)
-                    config.getWsAdditionalChannelInitializer().initChannel(ch);
-            }
-        });
-    }
+        if (config.getHttpAdditionalChannelInitializer() != null)
+          config.getHttpAdditionalChannelInitializer().accept(ch);
+      }
+    });
 
-    private HttpContentDecompressor newHttpContentDecompressor() {
-        if (config.isKeepEncodingHeader())
-            return new HttpContentDecompressor() {
-                @Override
-                protected String getTargetContentEncoding(String contentEncoding) throws Exception {
-                    return contentEncoding;
-                }
-            };
-        else
-            return new HttpContentDecompressor();
-    }
+    wsBootstrap.handler(new ChannelInitializer<Channel>() {
+      @Override
+      protected void initChannel(Channel ch) {
+        ChannelPipeline pipeline = ch.pipeline()
+                .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())
+                .addLast(AHC_WS_HANDLER, wsHandler);
 
-    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {
-        if (channel.isActive() && keepAlive) {
-            LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
-            Channels.setDiscard(channel);
-
-            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
-            if (asyncHandlerExtensions != null) {
-                try {
-                    asyncHandlerExtensions.onConnectionOffer(channel);
-                } catch (Exception e) {
-                    LOGGER.error("onConnectionOffer crashed", e);
-                }
-            }
+        if (config.isEnableWebSocketCompression()) {
+          pipeline.addBefore(AHC_WS_HANDLER, WS_COMPRESSOR_HANDLER, WebSocketClientCompressionHandler.INSTANCE);
+        }
 
-            if (!channelPool.offer(channel, partitionKey)) {
-                // rejected by pool
-                closeChannel(channel);
-            }
-        } else {
-            // not offered
-            closeChannel(channel);
+        if (LOGGER.isDebugEnabled()) {
+          pipeline.addFirst(LOGGING_HANDLER, loggingHandler);
         }
-    }
 
-    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
-        Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
-        return channelPool.poll(partitionKey);
+        if (config.getWsAdditionalChannelInitializer() != null)
+          config.getWsAdditionalChannelInitializer().accept(ch);
+      }
+    });
+  }
+
+  private HttpContentDecompressor newHttpContentDecompressor() {
+    if (config.isKeepEncodingHeader())
+      return new HttpContentDecompressor() {
+        @Override
+        protected String getTargetContentEncoding(String contentEncoding) {
+          return contentEncoding;
+        }
+      };
+    else
+      return new HttpContentDecompressor();
+  }
+
+  public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {
+    if (channel.isActive() && keepAlive) {
+      LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
+      Channels.setDiscard(channel);
+
+      try {
+        asyncHandler.onConnectionOffer(channel);
+      } catch (Exception e) {
+        LOGGER.error("onConnectionOffer crashed", e);
+      }
+
+      if (!channelPool.offer(channel, partitionKey)) {
+        // rejected by pool
+        closeChannel(channel);
+      }
+    } else {
+      // not offered
+      closeChannel(channel);
     }
-
-    public boolean removeAll(Channel connection) {
-        return channelPool.removeAll(connection);
+  }
+
+  public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
+    Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
+    return channelPool.poll(partitionKey);
+  }
+
+  public void removeAll(Channel connection) {
+    channelPool.removeAll(connection);
+  }
+
+  private void doClose() {
+    openChannels.close();
+    channelPool.destroy();
+  }
+
+  public void close() {
+    if (allowReleaseEventLoopGroup) {
+      eventLoopGroup
+              .shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)
+              .addListener(future -> doClose());
+    } else {
+      doClose();
     }
-
-    private void doClose() {
-        openChannels.close();
-        channelPool.destroy();
+  }
+
+  public void closeChannel(Channel channel) {
+    LOGGER.debug("Closing Channel {} ", channel);
+    Channels.setDiscard(channel);
+    removeAll(channel);
+    Channels.silentlyCloseChannel(channel);
+  }
+
+  public void registerOpenChannel(Channel channel) {
+    openChannels.add(channel);
+  }
+
+  private HttpClientCodec newHttpClientCodec() {
+    return new HttpClientCodec(//
+            config.getHttpClientCodecMaxInitialLineLength(),
+            config.getHttpClientCodecMaxHeaderSize(),
+            config.getHttpClientCodecMaxChunkSize(),
+            false,
+            config.isValidateResponseHeaders(),
+            config.getHttpClientCodecInitialBufferSize());
+  }
+
+  private SslHandler createSslHandler(String peerHost, int peerPort) {
+    SSLEngine sslEngine = sslEngineFactory.newSslEngine(config, peerHost, peerPort);
+    SslHandler sslHandler = new SslHandler(sslEngine);
+    if (handshakeTimeout > 0)
+      sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
+    return sslHandler;
+  }
+
+  public Future<Channel> updatePipelineForHttpTunneling(ChannelPipeline pipeline, Uri requestUri) {
+
+    Future<Channel> whenHanshaked = null;
+
+    if (pipeline.get(HTTP_CLIENT_CODEC) != null)
+      pipeline.remove(HTTP_CLIENT_CODEC);
+
+    if (requestUri.isSecured()) {
+      if (!isSslHandlerConfigured(pipeline)) {
+        SslHandler sslHandler = createSslHandler(requestUri.getHost(), requestUri.getExplicitPort());
+        whenHanshaked = sslHandler.handshakeFuture();
+        pipeline.addBefore(INFLATER_HANDLER, SSL_HANDLER, sslHandler);
+      }
+      pipeline.addAfter(SSL_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
+
+    } else {
+      pipeline.addBefore(AHC_HTTP_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
     }
 
-    public void close() {
-        if (allowReleaseEventLoopGroup) {
-            eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)//
-                    .addListener(future -> doClose());
-        } else {
-            doClose();
-        }
+    if (requestUri.isWebSocket()) {
+      pipeline.addAfter(AHC_HTTP_HANDLER, AHC_WS_HANDLER, wsHandler);
+      pipeline.remove(AHC_HTTP_HANDLER);
     }
-
-    public void closeChannel(Channel channel) {
-        LOGGER.debug("Closing Channel {} ", channel);
-        Channels.setDiscard(channel);
-        removeAll(channel);
-        Channels.silentlyCloseChannel(channel);
+    return whenHanshaked;
+  }
+
+  public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost, boolean hasSocksProxyHandler) {
+    String peerHost;
+    int peerPort;
+
+    if (virtualHost != null) {
+      int i = virtualHost.indexOf(':');
+      if (i == -1) {
+        peerHost = virtualHost;
+        peerPort = uri.getSchemeDefaultPort();
+      } else {
+        peerHost = virtualHost.substring(0, i);
+        peerPort = Integer.valueOf(virtualHost.substring(i + 1));
+      }
+
+    } else {
+      peerHost = uri.getHost();
+      peerPort = uri.getExplicitPort();
     }
 
-    public void registerOpenChannel(Channel channel, Object partitionKey) {
-        openChannels.add(channel);
+    SslHandler sslHandler = createSslHandler(peerHost, peerPort);
+    if (hasSocksProxyHandler) {
+      pipeline.addAfter(SOCKS_HANDLER, SSL_HANDLER, sslHandler);
+    } else {
+      pipeline.addFirst(SSL_HANDLER, sslHandler);
     }
+    return sslHandler;
+  }
 
-    private HttpClientCodec newHttpClientCodec() {
-        return new HttpClientCodec(//
-                config.getHttpClientCodecMaxInitialLineLength(),//
-                config.getHttpClientCodecMaxHeaderSize(),//
-                config.getHttpClientCodecMaxChunkSize(),//
-                false,//
-                config.isValidateResponseHeaders(),//
-                config.getHttpClientCodecInitialBufferSize());
-    }
+  public Future<Bootstrap> getBootstrap(Uri uri, NameResolver<InetAddress> nameResolver, ProxyServer proxy) {
 
-    private SslHandler createSslHandler(String peerHost, int peerPort) {
-        SSLEngine sslEngine = sslEngineFactory.newSslEngine(config, peerHost, peerPort);
-        SslHandler sslHandler = new SslHandler(sslEngine);
-        if (handshakeTimeout > 0)
-            sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
-        return sslHandler;
-    }
+    final Promise<Bootstrap> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
-    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
-        return pipeline.get(SSL_HANDLER) != null;
-    }
+    if (uri.isWebSocket() && proxy == null) {
+      return promise.setSuccess(wsBootstrap);
 
-    public void upgradeProtocol(ChannelPipeline pipeline, Uri requestUri) throws SSLException {
-        if (pipeline.get(HTTP_CLIENT_CODEC) != null)
-            pipeline.remove(HTTP_CLIENT_CODEC);
+    } else if (proxy != null && proxy.getProxyType().isSocks()) {
+      Bootstrap socksBootstrap = httpBootstrap.clone();
+      ChannelHandler httpBootstrapHandler = socksBootstrap.config().handler();
 
-        if (requestUri.isSecured())
-            if (isSslHandlerConfigured(pipeline)) {
-                pipeline.addAfter(SSL_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
-            } else {
-                pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
-                pipeline.addAfter(PINNED_ENTRY, SSL_HANDLER, createSslHandler(requestUri.getHost(), requestUri.getExplicitPort()));
+      nameResolver.resolve(proxy.getHost()).addListener((Future<InetAddress> whenProxyAddress) -> {
+        if (whenProxyAddress.isSuccess()) {
+          socksBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+              httpBootstrapHandler.handlerAdded(ctx);
+              super.handlerAdded(ctx);
             }
 
-        else
-            pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
-
-        if (requestUri.isWebSocket()) {
-            pipeline.addAfter(AHC_HTTP_HANDLER, AHC_WS_HANDLER, wsHandler);
-            pipeline.remove(AHC_HTTP_HANDLER);
-        }
-    }
-
-    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) {
-        String peerHost;
-        int peerPort;
-
-        if (virtualHost != null) {
-            int i = virtualHost.indexOf(':');
-            if (i == -1) {
-                peerHost = virtualHost;
-                peerPort = uri.getSchemeDefaultPort();
-            } else {
-                peerHost = virtualHost.substring(0, i);
-                peerPort = Integer.valueOf(virtualHost.substring(i + 1));
+            @Override
+            protected void initChannel(Channel channel) throws Exception {
+              InetSocketAddress proxyAddress = new InetSocketAddress(whenProxyAddress.get(), proxy.getPort());
+              Realm realm = proxy.getRealm();
+              String username = realm != null ? realm.getPrincipal() : null;
+              String password = realm != null ? realm.getPassword() : null;
+              ProxyHandler socksProxyHandler;
+              switch (proxy.getProxyType()) {
+                case SOCKS_V4:
+                  socksProxyHandler = new Socks4ProxyHandler(proxyAddress, username);
+                  break;
+
+                case SOCKS_V5:
+                  socksProxyHandler = new Socks5ProxyHandler(proxyAddress, username, password);
+                  break;
+
+                default:
+                  throw new IllegalArgumentException("Only SOCKS4 and SOCKS5 supported at the moment.");
+              }
+              channel.pipeline().addFirst(SOCKS_HANDLER, socksProxyHandler);
             }
+          });
+          promise.setSuccess(socksBootstrap);
 
         } else {
-            peerHost = uri.getHost();
-            peerPort = uri.getExplicitPort();
+          promise.setFailure(whenProxyAddress.cause());
         }
+      });
 
-        SslHandler sslHandler = createSslHandler(peerHost, peerPort);
-        pipeline.addFirst(ChannelManager.SSL_HANDLER, sslHandler);
-        return sslHandler;
+    } else {
+      promise.setSuccess(httpBootstrap);
     }
 
-    public Bootstrap getBootstrap(Uri uri, ProxyServer proxy) {
-        return uri.isWebSocket() && proxy == null ? wsBootstrap : httpBootstrap;
-    }
-
-    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
-        pipeline.addAfter(HTTP_CLIENT_CODEC, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
-        pipeline.addBefore(AHC_WS_HANDLER, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
-        if (config.isAggregateWebSocketFrameFragments()) {
-            pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
-        }
-        pipeline.remove(HTTP_CLIENT_CODEC);
-    }
-
-    public final OnLastHttpContentCallback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+    return promise;
+  }
 
-        return new OnLastHttpContentCallback(future) {
-            public void call() {
-                tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
-            }
-        };
-    }
-
-    public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future) {
-        drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
-    }
-
-    public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
-        Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
-    }
-
-    public ChannelPool getChannelPool() {
-        return channelPool;
-    }
-
-    public EventLoopGroup getEventLoopGroup() {
-        return eventLoopGroup;
-    }
-
-    public ClientStats getClientStats() {
-        Map<String, Long> totalConnectionsPerHost = openChannels.stream().map(Channel::remoteAddress).filter(a -> a.getClass() == InetSocketAddress.class)
-                .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostName).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
-        Map<String, Long> idleConnectionsPerHost = channelPool.getIdleChannelCountPerHost();
-        Map<String, HostStats> statsPerHost = totalConnectionsPerHost.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> {
-            final long totalConnectionCount = entry.getValue();
-            final long idleConnectionCount = idleConnectionsPerHost.getOrDefault(entry.getKey(), 0L);
-            final long activeConnectionCount = totalConnectionCount - idleConnectionCount;
-            return new HostStats(activeConnectionCount, idleConnectionCount);
-        }));
-        return new ClientStats(statsPerHost);
-    }
+  public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
+    pipeline.addAfter(HTTP_CLIENT_CODEC, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+    pipeline.addAfter(WS_ENCODER_HANDLER, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, config.isEnableWebSocketCompression(), config.getWebSocketMaxFrameSize()));
 
-    public boolean isOpen() {
-        return channelPool.isOpen();
+    if (config.isAggregateWebSocketFrameFragments()) {
+      pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
     }
+    pipeline.remove(HTTP_CLIENT_CODEC);
+  }
+
+  private OnLastHttpContentCallback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+
+    return new OnLastHttpContentCallback(future) {
+      public void call() {
+        tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
+      }
+    };
+  }
+
+  public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future) {
+    drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
+  }
+
+  public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
+    Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
+  }
+
+  public ChannelPool getChannelPool() {
+    return channelPool;
+  }
+
+  public EventLoopGroup getEventLoopGroup() {
+    return eventLoopGroup;
+  }
+
+  public ClientStats getClientStats() {
+    Map<String, Long> totalConnectionsPerHost = openChannels.stream().map(Channel::remoteAddress).filter(a -> a.getClass() == InetSocketAddress.class)
+            .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostName).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+    Map<String, Long> idleConnectionsPerHost = channelPool.getIdleChannelCountPerHost();
+    Map<String, HostStats> statsPerHost = totalConnectionsPerHost.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> {
+      final long totalConnectionCount = entry.getValue();
+      final long idleConnectionCount = idleConnectionsPerHost.getOrDefault(entry.getKey(), 0L);
+      final long activeConnectionCount = totalConnectionCount - idleConnectionCount;
+      return new HostStats(activeConnectionCount, idleConnectionCount);
+    }));
+    return new ClientStats(statsPerHost);
+  }
+
+  public boolean isOpen() {
+    return channelPool.isOpen();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
index a76df2b90..d4439f682 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
@@ -14,5 +14,5 @@
 package org.asynchttpclient.netty.channel;
 
 public enum ChannelState {
-    NEW, POOLED, RECONNECTED, CLOSED,
+  NEW, POOLED, RECONNECTED, CLOSED,
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 3bd1b82c2..1ddfda1e5 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -16,51 +16,50 @@
 import io.netty.channel.Channel;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
-
 import org.asynchttpclient.netty.DiscardEvent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class Channels {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
 
-    private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
-    private static final AttributeKey<Active> ACTIVE_TOKEN_ATTRIBUTE = AttributeKey.valueOf("activeToken");
+  private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
+  private static final AttributeKey<Active> ACTIVE_TOKEN_ATTRIBUTE = AttributeKey.valueOf("activeToken");
 
-    private enum Active { INSTANCE }
+  public static Object getAttribute(Channel channel) {
+    Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
+    return attr != null ? attr.get() : null;
+  }
 
-    public static Object getAttribute(Channel channel) {
-        Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
-        return attr != null ? attr.get() : null;
-    }
+  public static void setAttribute(Channel channel, Object o) {
+    channel.attr(DEFAULT_ATTRIBUTE).set(o);
+  }
 
-    public static void setAttribute(Channel channel, Object o) {
-        channel.attr(DEFAULT_ATTRIBUTE).set(o);
-    }
+  public static void setDiscard(Channel channel) {
+    setAttribute(channel, DiscardEvent.DISCARD);
+  }
 
-    public static void setDiscard(Channel channel) {
-        setAttribute(channel, DiscardEvent.DISCARD);
-    }
+  public static boolean isChannelActive(Channel channel) {
+    return channel != null && channel.isActive();
+  }
 
-    public static boolean isChannelValid(Channel channel) {
-        return channel != null && channel.isActive();
-    }
-    
-    public static void setActiveToken(Channel channel) {
-        channel.attr(ACTIVE_TOKEN_ATTRIBUTE).set(Active.INSTANCE);
-    }
-    
-    public static boolean isActiveTokenSet(Channel channel) {
-        return channel != null && channel.attr(ACTIVE_TOKEN_ATTRIBUTE).getAndSet(null) != null;
-    }
+  public static void setActiveToken(Channel channel) {
+    channel.attr(ACTIVE_TOKEN_ATTRIBUTE).set(Active.INSTANCE);
+  }
 
-    public static void silentlyCloseChannel(Channel channel) {
-        try {
-            if (channel != null && channel.isActive())
-                channel.close();
-        } catch (Throwable t) {
-            LOGGER.debug("Failed to close channel", t);
-        }
+  public static boolean isActiveTokenSet(Channel channel) {
+    return channel != null && channel.attr(ACTIVE_TOKEN_ATTRIBUTE).getAndSet(null) != null;
+  }
+
+  public static void silentlyCloseChannel(Channel channel) {
+    try {
+      if (channel != null && channel.isActive())
+        channel.close();
+    } catch (Throwable t) {
+      LOGGER.debug("Failed to close channel", t);
     }
+  }
+
+  private enum Active {INSTANCE}
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/CombinedConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/CombinedConnectionSemaphore.java
new file mode 100644
index 000000000..04549fd80
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/CombinedConnectionSemaphore.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A combined {@link ConnectionSemaphore} with two limits - a global limit and a per-host limit
+ */
+public class CombinedConnectionSemaphore extends PerHostConnectionSemaphore {
+  protected final MaxConnectionSemaphore globalMaxConnectionSemaphore;
+
+  CombinedConnectionSemaphore(int maxConnections, int maxConnectionsPerHost, int acquireTimeout) {
+    super(maxConnectionsPerHost, acquireTimeout);
+    this.globalMaxConnectionSemaphore = new MaxConnectionSemaphore(maxConnections, acquireTimeout);
+  }
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) throws IOException {
+    long remainingTime = super.acquireTimeout > 0 ? acquireGlobalTimed(partitionKey) : acquireGlobal(partitionKey);
+
+    try {
+      if (remainingTime < 0 || !getFreeConnectionsForHost(partitionKey).tryAcquire(remainingTime, TimeUnit.MILLISECONDS)) {
+        releaseGlobal(partitionKey);
+        throw tooManyConnectionsPerHost;
+      }
+    } catch (InterruptedException e) {
+      releaseGlobal(partitionKey);
+      throw new RuntimeException(e);
+    }
+  }
+
+  protected void releaseGlobal(Object partitionKey) {
+    this.globalMaxConnectionSemaphore.releaseChannelLock(partitionKey);
+  }
+
+  protected long acquireGlobal(Object partitionKey) throws IOException {
+    this.globalMaxConnectionSemaphore.acquireChannelLock(partitionKey);
+    return 0;
+  }
+
+  /*
+   * Acquires the global lock and returns the remaining time, in millis, to acquire the per-host lock
+   */
+  protected long acquireGlobalTimed(Object partitionKey) throws IOException {
+    long beforeGlobalAcquire = System.currentTimeMillis();
+    acquireGlobal(partitionKey);
+    long lockTime = System.currentTimeMillis() - beforeGlobalAcquire;
+    return this.acquireTimeout - lockTime;
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+    this.globalMaxConnectionSemaphore.releaseChannelLock(partitionKey);
+    super.releaseChannelLock(partitionKey);
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
index 09c693502..dc37d2d0b 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,71 +13,15 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-
 import java.io.IOException;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.exception.TooManyConnectionsException;
-import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
 
 /**
- * Max connections and max-per-host connections limiter.
- *
- * @author Stepan Koltsov
+ * Connections limiter.
  */
-public class ConnectionSemaphore {
-
-    public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
-        return config.getMaxConnections() > 0 || config.getMaxConnectionsPerHost() > 0 ? new ConnectionSemaphore(config) : null;
-    }
-
-    private final int maxTotalConnections;
-    private final NonBlockingSemaphoreLike freeChannels;
-    private final int maxConnectionsPerHost;
-    private final ConcurrentHashMap<Object, NonBlockingSemaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
-
-    private final IOException tooManyConnections;
-    private final IOException tooManyConnectionsPerHost;
-
-    private ConnectionSemaphore(AsyncHttpClientConfig config) {
-        tooManyConnections = unknownStackTrace(new TooManyConnectionsException(config.getMaxConnections()), ConnectionSemaphore.class, "acquireChannelLock");
-        tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()), ConnectionSemaphore.class, "acquireChannelLock");
-        maxTotalConnections = config.getMaxConnections();
-        maxConnectionsPerHost = config.getMaxConnectionsPerHost();
-
-        freeChannels = maxTotalConnections > 0 ?
-                new NonBlockingSemaphore(config.getMaxConnections()) :
-                NonBlockingSemaphoreInfinite.INSTANCE;
-    }
-
-    private boolean tryAcquireGlobal() {
-        return freeChannels.tryAcquire();
-    }
-
-    private NonBlockingSemaphoreLike getFreeConnectionsForHost(Object partitionKey) {
-        return maxConnectionsPerHost > 0 ?
-                freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new NonBlockingSemaphore(maxConnectionsPerHost)) :
-                NonBlockingSemaphoreInfinite.INSTANCE;
-    }
-
-    private boolean tryAcquirePerHost(Object partitionKey) {
-        return getFreeConnectionsForHost(partitionKey).tryAcquire();
-    }
+public interface ConnectionSemaphore {
 
-    public void acquireChannelLock(Object partitionKey) throws IOException {
-        if (!tryAcquireGlobal())
-            throw tooManyConnections;
-        if (!tryAcquirePerHost(partitionKey)) {
-            freeChannels.release();
+    void acquireChannelLock(Object partitionKey) throws IOException;
 
-            throw tooManyConnectionsPerHost;
-        }
-    }
+    void releaseChannelLock(Object partitionKey);
 
-    public void releaseChannelLock(Object partitionKey) {
-        freeChannels.release();
-        getFreeConnectionsForHost(partitionKey).release();
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphoreFactory.java
similarity index 74%
rename from client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java
rename to client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphoreFactory.java
index 5c06dd16b..b94e33639 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphoreFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,13 +13,10 @@
  */
 package org.asynchttpclient.netty.channel;
 
-/**
- * Non-blocking semaphore API.
- *
- * @author Stepan Koltsov
- */
-interface NonBlockingSemaphoreLike {
-    void release();
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public interface ConnectionSemaphoreFactory {
+
+    ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config);
 
-    boolean tryAcquire();
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 771f7e55e..998842159 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -13,8 +13,15 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
+import io.netty.util.*;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.ChannelPool;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -27,371 +34,348 @@
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.channel.ChannelPool;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelId;
-import io.netty.util.Timeout;
-import io.netty.util.Timer;
-import io.netty.util.TimerTask;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
 public final class DefaultChannelPool implements ChannelPool {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
-
-    private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();
-    private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;
-    private final AtomicBoolean isClosed = new AtomicBoolean(false);
-    private final Timer nettyTimer;
-    private final int connectionTtl;
-    private final boolean connectionTtlEnabled;
-    private final int maxIdleTime;
-    private final boolean maxIdleTimeEnabled;
-    private final long cleanerPeriod;
-    private final PoolLeaseStrategy poolLeaseStrategy;
-
-    public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
-        this(config.getPooledConnectionIdleTimeout(),//
-                config.getConnectionTtl(),//
-                hashedWheelTimer,//
-                config.getConnectionPoolCleanerPeriod());
+  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
+  private static final AttributeKey<ChannelCreation> CHANNEL_CREATION_ATTRIBUTE_KEY = AttributeKey.valueOf("channelCreation");
+
+  private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();
+  private final AtomicBoolean isClosed = new AtomicBoolean(false);
+  private final Timer nettyTimer;
+  private final int connectionTtl;
+  private final boolean connectionTtlEnabled;
+  private final int maxIdleTime;
+  private final boolean maxIdleTimeEnabled;
+  private final long cleanerPeriod;
+  private final PoolLeaseStrategy poolLeaseStrategy;
+
+  public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
+    this(config.getPooledConnectionIdleTimeout(),
+            config.getConnectionTtl(),
+            hashedWheelTimer,
+            config.getConnectionPoolCleanerPeriod());
+  }
+
+  public DefaultChannelPool(int maxIdleTime,
+                            int connectionTtl,
+                            Timer nettyTimer,
+                            int cleanerPeriod) {
+    this(maxIdleTime,
+            connectionTtl,
+            PoolLeaseStrategy.LIFO,
+            nettyTimer,
+            cleanerPeriod);
+  }
+
+  public DefaultChannelPool(int maxIdleTime,
+                            int connectionTtl,
+                            PoolLeaseStrategy poolLeaseStrategy,
+                            Timer nettyTimer,
+                            int cleanerPeriod) {
+    this.maxIdleTime = maxIdleTime;
+    this.connectionTtl = connectionTtl;
+    connectionTtlEnabled = connectionTtl > 0;
+    this.nettyTimer = nettyTimer;
+    maxIdleTimeEnabled = maxIdleTime > 0;
+    this.poolLeaseStrategy = poolLeaseStrategy;
+
+    this.cleanerPeriod = Math.min(cleanerPeriod, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));
+
+    if (connectionTtlEnabled || maxIdleTimeEnabled)
+      scheduleNewIdleChannelDetector(new IdleChannelDetector());
+  }
+
+  private void scheduleNewIdleChannelDetector(TimerTask task) {
+    nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
+  }
+
+  private boolean isTtlExpired(Channel channel, long now) {
+    if (!connectionTtlEnabled)
+      return false;
+
+    ChannelCreation creation = channel.attr(CHANNEL_CREATION_ATTRIBUTE_KEY).get();
+    return creation != null && now - creation.creationTime >= connectionTtl;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public boolean offer(Channel channel, Object partitionKey) {
+    if (isClosed.get())
+      return false;
+
+    long now = unpreciseMillisTime();
+
+    if (isTtlExpired(channel, now))
+      return false;
+
+    boolean offered = offer0(channel, partitionKey, now);
+    if (connectionTtlEnabled && offered) {
+      registerChannelCreation(channel, partitionKey, now);
     }
 
-    public DefaultChannelPool(int maxIdleTime,//
-            int connectionTtl,//
-            Timer nettyTimer,//
-            int cleanerPeriod) {
-        this(maxIdleTime,//
-                connectionTtl,//
-                PoolLeaseStrategy.LIFO,//
-                nettyTimer,//
-                cleanerPeriod);
-    }
+    return offered;
+  }
 
-    public DefaultChannelPool(int maxIdleTime,//
-            int connectionTtl,//
-            PoolLeaseStrategy poolLeaseStrategy,//
-            Timer nettyTimer,//
-            int cleanerPeriod) {
-        this.maxIdleTime = maxIdleTime;
-        this.connectionTtl = connectionTtl;
-        connectionTtlEnabled = connectionTtl > 0;
-        channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
-        this.nettyTimer = nettyTimer;
-        maxIdleTimeEnabled = maxIdleTime > 0;
-        this.poolLeaseStrategy = poolLeaseStrategy;
-
-        this.cleanerPeriod = Math.min(cleanerPeriod, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));
-
-        if (connectionTtlEnabled || maxIdleTimeEnabled)
-            scheduleNewIdleChannelDetector(new IdleChannelDetector());
+  private boolean offer0(Channel channel, Object partitionKey, long now) {
+    ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
+    if (partition == null) {
+      partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedDeque<>());
     }
-
-    private void scheduleNewIdleChannelDetector(TimerTask task) {
-        nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
+    return partition.offerFirst(new IdleChannel(channel, now));
+  }
+
+  private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
+    ChannelId id = channel.id();
+    Attribute<ChannelCreation> channelCreationAttribute = channel.attr(CHANNEL_CREATION_ATTRIBUTE_KEY);
+    if (channelCreationAttribute.get() == null) {
+      channelCreationAttribute.set(new ChannelCreation(now, partitionKey));
     }
-
-    private static final class ChannelCreation {
-        final long creationTime;
-        final Object partitionKey;
-
-        ChannelCreation(long creationTime, Object partitionKey) {
-            this.creationTime = creationTime;
-            this.partitionKey = partitionKey;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Channel poll(Object partitionKey) {
+
+    IdleChannel idleChannel = null;
+    ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
+    if (partition != null) {
+      while (idleChannel == null) {
+        idleChannel = poolLeaseStrategy.lease(partition);
+
+        if (idleChannel == null)
+          // pool is empty
+          break;
+        else if (!Channels.isChannelActive(idleChannel.channel)) {
+          idleChannel = null;
+          LOGGER.trace("Channel is inactive, probably remotely closed!");
+        } else if (!idleChannel.takeOwnership()) {
+          idleChannel = null;
+          LOGGER.trace("Couldn't take ownership of channel, probably in the process of being expired!");
         }
+      }
     }
+    return idleChannel != null ? idleChannel.channel : null;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public boolean removeAll(Channel channel) {
+    ChannelCreation creation = connectionTtlEnabled ? channel.attr(CHANNEL_CREATION_ATTRIBUTE_KEY).get() : null;
+    return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(new IdleChannel(channel, Long.MIN_VALUE));
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public boolean isOpen() {
+    return !isClosed.get();
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public void destroy() {
+    if (isClosed.getAndSet(true))
+      return;
+
+    partitions.clear();
+  }
+
+  private void close(Channel channel) {
+    // FIXME pity to have to do this here
+    Channels.setDiscard(channel);
+    Channels.silentlyCloseChannel(channel);
+  }
+
+  private void flushPartition(Object partitionKey, ConcurrentLinkedDeque<IdleChannel> partition) {
+    if (partition != null) {
+      partitions.remove(partitionKey);
+      for (IdleChannel idleChannel : partition)
+        close(idleChannel.channel);
+    }
+  }
+
+  @Override
+  public void flushPartitions(Predicate<Object> predicate) {
+    for (Map.Entry<Object, ConcurrentLinkedDeque<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+      Object partitionKey = partitionsEntry.getKey();
+      if (predicate.test(partitionKey))
+        flushPartition(partitionKey, partitionsEntry.getValue());
+    }
+  }
+
+  @Override
+  public Map<String, Long> getIdleChannelCountPerHost() {
+    return partitions
+            .values()
+            .stream()
+            .flatMap(ConcurrentLinkedDeque::stream)
+            .map(idle -> idle.getChannel().remoteAddress())
+            .filter(a -> a.getClass() == InetSocketAddress.class)
+            .map(a -> (InetSocketAddress) a)
+            .map(InetSocketAddress::getHostName)
+            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+  }
+
+  public enum PoolLeaseStrategy {
+    LIFO {
+      public <E> E lease(Deque<E> d) {
+        return d.pollFirst();
+      }
+    },
+    FIFO {
+      public <E> E lease(Deque<E> d) {
+        return d.pollLast();
+      }
+    };
+
+    abstract <E> E lease(Deque<E> d);
+  }
+
+  private static final class ChannelCreation {
+    final long creationTime;
+    final Object partitionKey;
+
+    ChannelCreation(long creationTime, Object partitionKey) {
+      this.creationTime = creationTime;
+      this.partitionKey = partitionKey;
+    }
+  }
 
-    private static final class IdleChannel {
-        
-        private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
-        
-        final Channel channel;
-        final long start;
-        @SuppressWarnings("unused")
-        private volatile int owned = 0;
-
-        IdleChannel(Channel channel, long start) {
-            this.channel = assertNotNull(channel, "channel");
-            this.start = start;
-        }
-
-        public boolean takeOwnership() {
-            return ownedField.getAndSet(this, 1) == 0;
-        }
+  private static final class IdleChannel {
 
-        public Channel getChannel() {
-            return channel;
-        }
+    private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
 
-        @Override
-        // only depends on channel
-        public boolean equals(Object o) {
-            return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
-        }
+    final Channel channel;
+    final long start;
+    @SuppressWarnings("unused")
+    private volatile int owned = 0;
 
-        @Override
-        public int hashCode() {
-            return channel.hashCode();
-        }
+    IdleChannel(Channel channel, long start) {
+      this.channel = assertNotNull(channel, "channel");
+      this.start = start;
     }
 
-    private boolean isTtlExpired(Channel channel, long now) {
-        if (!connectionTtlEnabled)
-            return false;
+    public boolean takeOwnership() {
+      return ownedField.getAndSet(this, 1) == 0;
+    }
 
-        ChannelCreation creation = channelId2Creation.get(channel.id());
-        return creation != null && now - creation.creationTime >= connectionTtl;
+    public Channel getChannel() {
+      return channel;
     }
 
-    private boolean isRemotelyClosed(Channel channel) {
-        return !channel.isActive();
+    @Override
+    // only depends on channel
+    public boolean equals(Object o) {
+      return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
     }
 
-    private final class IdleChannelDetector implements TimerTask {
+    @Override
+    public int hashCode() {
+      return channel.hashCode();
+    }
+  }
 
-        private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
-            return maxIdleTimeEnabled && now - idleChannel.start >= maxIdleTime;
-        }
+  private final class IdleChannelDetector implements TimerTask {
 
-        private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {
-            // lazy create
-            List<IdleChannel> idleTimeoutChannels = null;
-            for (IdleChannel idleChannel : partition) {
-                boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);
-                boolean isRemotelyClosed = isRemotelyClosed(idleChannel.channel);
-                boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);
-                if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {
-                    LOGGER.debug("Adding Candidate expired Channel {} isIdleTimeoutExpired={} isRemotelyClosed={} isTtlExpired={}", idleChannel.channel, isIdleTimeoutExpired, isRemotelyClosed, isTtlExpired);
-                    if (idleTimeoutChannels == null)
-                        idleTimeoutChannels = new ArrayList<>(1);
-                    idleTimeoutChannels.add(idleChannel);
-                }
-            }
-
-            return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
-        }
+    private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
+      return maxIdleTimeEnabled && now - idleChannel.start >= maxIdleTime;
+    }
 
-        private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
-
-            // lazy create, only if we hit a non-closeable channel
-            List<IdleChannel> closedChannels = null;
-            for (int i = 0; i < candidates.size(); i++) {
-                // We call takeOwnership here to avoid closing a channel that has just been taken out
-                // of the pool, otherwise we risk closing an active connection.
-                IdleChannel idleChannel = candidates.get(i);
-                if (idleChannel.takeOwnership()) {
-                    LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
-                    close(idleChannel.channel);
-                    if (closedChannels != null) {
-                        closedChannels.add(idleChannel);
-                    }
-
-                } else if (closedChannels == null) {
-                    // first non closeable to be skipped, copy all
-                    // previously skipped closeable channels
-                    closedChannels = new ArrayList<>(candidates.size());
-                    for (int j = 0; j < i; j++)
-                        closedChannels.add(candidates.get(j));
-                }
-            }
-
-            return closedChannels != null ? closedChannels : candidates;
+    private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {
+      // lazy create
+      List<IdleChannel> idleTimeoutChannels = null;
+      for (IdleChannel idleChannel : partition) {
+        boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);
+        boolean isRemotelyClosed = !Channels.isChannelActive(idleChannel.channel);
+        boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);
+        if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {
+          LOGGER.debug("Adding Candidate expired Channel {} isIdleTimeoutExpired={} isRemotelyClosed={} isTtlExpired={}", idleChannel.channel, isIdleTimeoutExpired, isRemotelyClosed, isTtlExpired);
+          if (idleTimeoutChannels == null)
+            idleTimeoutChannels = new ArrayList<>(1);
+          idleTimeoutChannels.add(idleChannel);
         }
+      }
 
-        public void run(Timeout timeout) throws Exception {
-
-            if (isClosed.get())
-                return;
-
-            if (LOGGER.isDebugEnabled())
-                for (Object key : partitions.keySet()) {
-                    int size = partitions.get(key).size();
-                    if (size > 0) {
-                        LOGGER.debug("Entry count for : {} : {}", key, size);
-                    }
-                }
-
-            long start = unpreciseMillisTime();
-            int closedCount = 0;
-            int totalCount = 0;
-
-            for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
-
-                // store in intermediate unsynchronized lists to minimize
-                // the impact on the ConcurrentLinkedDeque
-                if (LOGGER.isDebugEnabled())
-                    totalCount += partition.size();
-
-                List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
-
-                if (!closedChannels.isEmpty()) {
-                    if (connectionTtlEnabled) {
-                        for (IdleChannel closedChannel : closedChannels)
-                            channelId2Creation.remove(closedChannel.channel.id());
-                    }
-
-                    partition.removeAll(closedChannels);
-                    closedCount += closedChannels.size();
-                }
-            }
-
-            if (LOGGER.isDebugEnabled()) {
-                long duration = unpreciseMillisTime() - start;
-                if (closedCount > 0) {
-                    LOGGER.debug("Closed {} connections out of {} in {} ms", closedCount, totalCount, duration);
-                }
-            }
-
-            scheduleNewIdleChannelDetector(timeout.task());
-        }
+      return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.emptyList();
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public boolean offer(Channel channel, Object partitionKey) {
-        if (isClosed.get())
-            return false;
-
-        long now = unpreciseMillisTime();
-
-        if (isTtlExpired(channel, now))
-            return false;
-
-        boolean offered = offer0(channel, partitionKey, now);
-        if (connectionTtlEnabled && offered) {
-            registerChannelCreation(channel, partitionKey, now);
+    private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+
+      // lazy create, only if we hit a non-closeable channel
+      List<IdleChannel> closedChannels = null;
+      for (int i = 0; i < candidates.size(); i++) {
+        // We call takeOwnership here to avoid closing a channel that has just been taken out
+        // of the pool, otherwise we risk closing an active connection.
+        IdleChannel idleChannel = candidates.get(i);
+        if (idleChannel.takeOwnership()) {
+          LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
+          close(idleChannel.channel);
+          if (closedChannels != null) {
+            closedChannels.add(idleChannel);
+          }
+
+        } else if (closedChannels == null) {
+          // first non closeable to be skipped, copy all
+          // previously skipped closeable channels
+          closedChannels = new ArrayList<>(candidates.size());
+          for (int j = 0; j < i; j++)
+            closedChannels.add(candidates.get(j));
         }
+      }
 
-        return offered;
+      return closedChannels != null ? closedChannels : candidates;
     }
 
-    private boolean offer0(Channel channel, Object partitionKey, long now) {
-        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
-        if (partition == null) {
-            partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedDeque<>());
-        }
-        return partition.offerFirst(new IdleChannel(channel, now));
-    }
+    public void run(Timeout timeout) {
 
-    private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
-        ChannelId id = channel.id();
-        if (!channelId2Creation.containsKey(id)) {
-            channelId2Creation.putIfAbsent(id, new ChannelCreation(now, partitionKey));
-        }
-    }
+      if (isClosed.get())
+        return;
 
-    /**
-     * {@inheritDoc}
-     */
-    public Channel poll(Object partitionKey) {
-
-        IdleChannel idleChannel = null;
-        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
-        if (partition != null) {
-            while (idleChannel == null) {
-                idleChannel = poolLeaseStrategy.lease(partition);
-
-                if (idleChannel == null)
-                    // pool is empty
-                    break;
-                else if (isRemotelyClosed(idleChannel.channel)) {
-                    idleChannel = null;
-                    LOGGER.trace("Channel not connected or not opened, probably remotely closed!");
-                } else if (!idleChannel.takeOwnership()) {
-                    idleChannel = null;
-                    LOGGER.trace("Couldn't take ownership of channel, probably in the process of being expired!");
-                }
-            }
+      if (LOGGER.isDebugEnabled())
+        for (Object key : partitions.keySet()) {
+          int size = partitions.get(key).size();
+          if (size > 0) {
+            LOGGER.debug("Entry count for : {} : {}", key, size);
+          }
         }
-        return idleChannel != null ? idleChannel.channel : null;
-    }
 
-    /**
-     * {@inheritDoc}
-     */
-    public boolean removeAll(Channel channel) {
-        ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channel.id()) : null;
-        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(new IdleChannel(channel, Long.MIN_VALUE));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isOpen() {
-        return !isClosed.get();
-    }
+      long start = unpreciseMillisTime();
+      int closedCount = 0;
+      int totalCount = 0;
 
-    /**
-     * {@inheritDoc}
-     */
-    public void destroy() {
-        if (isClosed.getAndSet(true))
-            return;
+      for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
 
-        partitions.clear();
-        if (connectionTtlEnabled) {
-            channelId2Creation.clear();
-        }
-    }
+        // store in intermediate unsynchronized lists to minimize
+        // the impact on the ConcurrentLinkedDeque
+        if (LOGGER.isDebugEnabled())
+          totalCount += partition.size();
 
-    private void close(Channel channel) {
-        // FIXME pity to have to do this here
-        Channels.setDiscard(channel);
-        if (connectionTtlEnabled) {
-            channelId2Creation.remove(channel.id());
-        }
-        Channels.silentlyCloseChannel(channel);
-    }
+        List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
 
-    private void flushPartition(Object partitionKey, ConcurrentLinkedDeque<IdleChannel> partition) {
-        if (partition != null) {
-            partitions.remove(partitionKey);
-            for (IdleChannel idleChannel : partition)
-                close(idleChannel.channel);
+        if (!closedChannels.isEmpty()) {
+          partition.removeAll(closedChannels);
+          closedCount += closedChannels.size();
         }
-    }
+      }
 
-    @Override
-    public void flushPartitions(Predicate<Object> predicate) {
-        for (Map.Entry<Object, ConcurrentLinkedDeque<IdleChannel>> partitionsEntry : partitions.entrySet()) {
-            Object partitionKey = partitionsEntry.getKey();
-            if (predicate.test(partitionKey))
-                flushPartition(partitionKey, partitionsEntry.getValue());
+      if (LOGGER.isDebugEnabled()) {
+        long duration = unpreciseMillisTime() - start;
+        if (closedCount > 0) {
+          LOGGER.debug("Closed {} connections out of {} in {} ms", closedCount, totalCount, duration);
         }
-    }
-
-    @Override
-    public Map<String, Long> getIdleChannelCountPerHost() {
-        return partitions
-                .values()
-                .stream()
-                .flatMap(ConcurrentLinkedDeque::stream)
-                .map(idle -> idle.getChannel().remoteAddress())
-                .filter(a -> a.getClass() == InetSocketAddress.class)
-                .map(a -> (InetSocketAddress) a)
-                .map(InetSocketAddress::getHostName)
-                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
-    }
+      }
 
-    public enum PoolLeaseStrategy {
-        LIFO {
-            public <E> E lease(Deque<E> d) {
-                return d.pollFirst();
-            }
-        },
-        FIFO {
-            public <E> E lease(Deque<E> d) {
-                return d.pollLast();
-            }
-        };
-
-        abstract <E> E lease(Deque<E> d);
+      scheduleNewIdleChannelDetector(timeout.task());
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultConnectionSemaphoreFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultConnectionSemaphoreFactory.java
new file mode 100644
index 000000000..eba42186e
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultConnectionSemaphoreFactory.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class DefaultConnectionSemaphoreFactory implements ConnectionSemaphoreFactory {
+
+  public ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
+    int acquireFreeChannelTimeout = Math.max(0, config.getAcquireFreeChannelTimeout());
+    int maxConnections = config.getMaxConnections();
+    int maxConnectionsPerHost = config.getMaxConnectionsPerHost();
+
+    if (maxConnections > 0 && maxConnectionsPerHost > 0) {
+      return new CombinedConnectionSemaphore(maxConnections, maxConnectionsPerHost, acquireFreeChannelTimeout);
+    }
+    if (maxConnections > 0) {
+      return new MaxConnectionSemaphore(maxConnections, acquireFreeChannelTimeout);
+    }
+    if (maxConnectionsPerHost > 0) {
+      return new CombinedConnectionSemaphore(maxConnections, maxConnectionsPerHost, acquireFreeChannelTimeout);
+    }
+
+    return new NoopConnectionSemaphore();
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
index 18880cbdc..c6970b6d6 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
@@ -18,8 +18,8 @@
 
 class EpollSocketChannelFactory implements ChannelFactory<EpollSocketChannel> {
 
-    @Override
-    public EpollSocketChannel newChannel() {
-        return new EpollSocketChannel();
-    }
+  @Override
+  public EpollSocketChannel newChannel() {
+    return new EpollSocketChannel();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/InfiniteSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/InfiniteSemaphore.java
new file mode 100644
index 000000000..97b822473
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/InfiniteSemaphore.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A java.util.concurrent.Semaphore that always has Integer.Integer.MAX_VALUE free permits
+ *
+ * @author Alex Maltinsky
+ */
+public class InfiniteSemaphore extends Semaphore {
+
+  public static final InfiniteSemaphore INSTANCE = new InfiniteSemaphore();
+  private static final long serialVersionUID = 1L;
+
+  private InfiniteSemaphore() {
+    super(Integer.MAX_VALUE);
+  }
+
+  @Override
+  public void acquire() {
+    // NO-OP
+  }
+
+  @Override
+  public void acquireUninterruptibly() {
+    // NO-OP
+  }
+
+  @Override
+  public boolean tryAcquire() {
+    return true;
+  }
+
+  @Override
+  public boolean tryAcquire(long timeout, TimeUnit unit) {
+    return true;
+  }
+
+  @Override
+  public void release() {
+    // NO-OP
+  }
+
+  @Override
+  public void acquire(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public void acquireUninterruptibly(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public boolean tryAcquire(int permits) {
+    return true;
+  }
+
+  @Override
+  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
+    return true;
+  }
+
+  @Override
+  public void release(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public int availablePermits() {
+    return Integer.MAX_VALUE;
+  }
+
+  @Override
+  public int drainPermits() {
+    return Integer.MAX_VALUE;
+  }
+
+  @Override
+  protected void reducePermits(int reduction) {
+    // NO-OP
+  }
+
+  @Override
+  public boolean isFair() {
+    return true;
+  }
+
+  @Override
+  protected Collection<Thread> getQueuedThreads() {
+    return Collections.emptyList();
+  }
+}
+
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionSemaphore.java
new file mode 100644
index 000000000..99c318afa
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionSemaphore.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.exception.TooManyConnectionsException;
+
+import java.io.IOException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
+/**
+ * Max connections limiter.
+ *
+ * @author Stepan Koltsov
+ * @author Alex Maltinsky
+ */
+public class MaxConnectionSemaphore implements ConnectionSemaphore {
+
+  protected final Semaphore freeChannels;
+  protected final IOException tooManyConnections;
+  protected final int acquireTimeout;
+
+  MaxConnectionSemaphore(int maxConnections, int acquireTimeout) {
+    tooManyConnections = unknownStackTrace(new TooManyConnectionsException(maxConnections), MaxConnectionSemaphore.class, "acquireChannelLock");
+    freeChannels = maxConnections > 0 ? new Semaphore(maxConnections) : InfiniteSemaphore.INSTANCE;
+    this.acquireTimeout = Math.max(0, acquireTimeout);
+  }
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) throws IOException {
+    try {
+      if (!freeChannels.tryAcquire(acquireTimeout, TimeUnit.MILLISECONDS)) {
+        throw tooManyConnections;
+      }
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+    freeChannels.release();
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyChannelConnector.java
new file mode 100644
index 000000000..8951bd062
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyChannelConnector.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientState;
+import org.asynchttpclient.netty.SimpleChannelFutureListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.List;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+public class NettyChannelConnector {
+
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyChannelConnector.class);
+
+  private static final AtomicIntegerFieldUpdater<NettyChannelConnector> I_UPDATER = AtomicIntegerFieldUpdater
+          .newUpdater(NettyChannelConnector.class, "i");
+
+  private final AsyncHandler<?> asyncHandler;
+  private final InetSocketAddress localAddress;
+  private final List<InetSocketAddress> remoteAddresses;
+  private final AsyncHttpClientState clientState;
+  private volatile int i = 0;
+
+  public NettyChannelConnector(InetAddress localAddress,
+                               List<InetSocketAddress> remoteAddresses,
+                               AsyncHandler<?> asyncHandler,
+                               AsyncHttpClientState clientState) {
+    this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
+    this.remoteAddresses = remoteAddresses;
+    this.asyncHandler = asyncHandler;
+    this.clientState = clientState;
+  }
+
+  private boolean pickNextRemoteAddress() {
+    I_UPDATER.incrementAndGet(this);
+    return i < remoteAddresses.size();
+  }
+
+  public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
+    final InetSocketAddress remoteAddress = remoteAddresses.get(i);
+
+    try {
+      asyncHandler.onTcpConnectAttempt(remoteAddress);
+    } catch (Exception e) {
+      LOGGER.error("onTcpConnectAttempt crashed", e);
+      connectListener.onFailure(null, e);
+      return;
+    }
+
+    try {
+      connect0(bootstrap, connectListener, remoteAddress);
+    } catch (RejectedExecutionException e) {
+      if (clientState.isClosed()) {
+        LOGGER.info("Connect crash but engine is shutting down");
+      } else {
+        connectListener.onFailure(null, e);
+      }
+    }
+  }
+
+  private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {
+
+    bootstrap.connect(remoteAddress, localAddress)
+            .addListener(new SimpleChannelFutureListener() {
+              @Override
+              public void onSuccess(Channel channel) {
+                try {
+                  asyncHandler.onTcpConnectSuccess(remoteAddress, channel);
+                } catch (Exception e) {
+                  LOGGER.error("onTcpConnectSuccess crashed", e);
+                  connectListener.onFailure(channel, e);
+                  return;
+                }
+                connectListener.onSuccess(channel, remoteAddress);
+              }
+
+              @Override
+              public void onFailure(Channel channel, Throwable t) {
+                try {
+                  asyncHandler.onTcpConnectFailure(remoteAddress, t);
+                } catch (Exception e) {
+                  LOGGER.error("onTcpConnectFailure crashed", e);
+                  connectListener.onFailure(channel, e);
+                  return;
+                }
+                boolean retry = pickNextRemoteAddress();
+                if (retry) {
+                  NettyChannelConnector.this.connect(bootstrap, connectListener);
+                } else {
+                  connectListener.onFailure(channel, t);
+                }
+              }
+            });
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 5140535ce..4a6f4dce2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -13,188 +13,171 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
-import static org.asynchttpclient.util.HttpUtils.getBaseUrl;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.ssl.SslHandler;
-
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
+import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
+import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+
 /**
  * Non Blocking connect.
  */
 public final class NettyConnectListener<T> {
 
-    private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
-
-    private final NettyRequestSender requestSender;
-    private final NettyResponseFuture<T> future;
-    private final ChannelManager channelManager;
-    private final ConnectionSemaphore connectionSemaphore;
-    private final Object partitionKey;
-
-    public NettyConnectListener(NettyResponseFuture<T> future,//
-            NettyRequestSender requestSender,//
-            ChannelManager channelManager,//
-            ConnectionSemaphore connectionSemaphore,//
-            Object partitionKey) {
-        this.future = future;
-        this.requestSender = requestSender;
-        this.channelManager = channelManager;
-        this.connectionSemaphore = connectionSemaphore;
-        this.partitionKey = partitionKey;
+  private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
+
+  private final NettyRequestSender requestSender;
+  private final NettyResponseFuture<T> future;
+  private final ChannelManager channelManager;
+  private final ConnectionSemaphore connectionSemaphore;
+
+  public NettyConnectListener(NettyResponseFuture<T> future,
+                              NettyRequestSender requestSender,
+                              ChannelManager channelManager,
+                              ConnectionSemaphore connectionSemaphore) {
+    this.future = future;
+    this.requestSender = requestSender;
+    this.channelManager = channelManager;
+    this.connectionSemaphore = connectionSemaphore;
+  }
+
+  private boolean futureIsAlreadyCancelled(Channel channel) {
+    // FIXME should we only check isCancelled?
+    if (future.isDone()) {
+      Channels.silentlyCloseChannel(channel);
+      return true;
     }
+    return false;
+  }
 
-    private boolean futureIsAlreadyCancelled(Channel channel) {
-        // FIXME should we only check isCancelled?
-        if (future.isDone()) {
-            Channels.silentlyCloseChannel(channel);
-            return true;
-        }
-        return false;
-    }
+  private void writeRequest(Channel channel) {
 
-    private void writeRequest(Channel channel) {
+    if (futureIsAlreadyCancelled(channel)) {
+      return;
+    }
 
-        if (futureIsAlreadyCancelled(channel)) {
-            return;
-        }
+    if (LOGGER.isDebugEnabled()) {
+      HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+      LOGGER.debug("Using new Channel '{}' for '{}' to '{}'", channel, httpRequest.method(), httpRequest.uri());
+    }
 
-        if (LOGGER.isDebugEnabled()) {
-            HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-            LOGGER.debug("Using new Channel '{}' for '{}' to '{}'", channel, httpRequest.method(), httpRequest.uri());
-        }
+    Channels.setAttribute(channel, future);
 
-        Channels.setAttribute(channel, future);
+    channelManager.registerOpenChannel(channel);
+    future.attachChannel(channel, false);
+    requestSender.writeRequest(future, channel);
+  }
 
-        channelManager.registerOpenChannel(channel, partitionKey);
-        future.attachChannel(channel, false);
-        requestSender.writeRequest(future, channel);
-    }
+  public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
 
-    public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
+    if (connectionSemaphore != null) {
+      // transfer lock from future to channel
+      Object partitionKeyLock = future.takePartitionKeyLock();
 
-        if (connectionSemaphore != null) {
-            // transfer lock from future to channel
-            Object partitionKeyLock = future.takePartitionKeyLock();
+      if (partitionKeyLock != null) {
+        channel.closeFuture().addListener(future -> connectionSemaphore.releaseChannelLock(partitionKeyLock));
+      }
+    }
 
-            if (partitionKeyLock != null) {
-                channel.closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {
-                    @Override
-                    public void operationComplete(Future<? super Void> future) throws Exception {
-                        connectionSemaphore.releaseChannelLock(partitionKeyLock);
-                    }
-                });
-            }
-        }
+    Channels.setActiveToken(channel);
 
-        Channels.setActiveToken(channel);
+    TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();
 
-        TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();
+    if (futureIsAlreadyCancelled(channel)) {
+      return;
+    }
 
-        if (futureIsAlreadyCancelled(channel)) {
+    Request request = future.getTargetRequest();
+    Uri uri = request.getUri();
+
+    timeoutsHolder.setResolvedRemoteAddress(remoteAddress);
+
+    ProxyServer proxyServer = future.getProxyServer();
+
+    // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
+    if ((proxyServer == null || proxyServer.getProxyType().isSocks()) && uri.isSecured()) {
+      SslHandler sslHandler;
+      try {
+        sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost(), proxyServer != null);
+      } catch (Exception sslError) {
+        onFailure(channel, sslError);
+        return;
+      }
+
+      final AsyncHandler<?> asyncHandler = future.getAsyncHandler();
+
+      try {
+        asyncHandler.onTlsHandshakeAttempt();
+      } catch (Exception e) {
+        LOGGER.error("onTlsHandshakeAttempt crashed", e);
+        onFailure(channel, e);
+        return;
+      }
+
+      sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
+        @Override
+        protected void onSuccess(Channel value) {
+          try {
+            asyncHandler.onTlsHandshakeSuccess(sslHandler.engine().getSession());
+          } catch (Exception e) {
+            LOGGER.error("onTlsHandshakeSuccess crashed", e);
+            NettyConnectListener.this.onFailure(channel, e);
             return;
+          }
+          writeRequest(channel);
         }
 
-        Request request = future.getTargetRequest();
-        Uri uri = request.getUri();
-
-        timeoutsHolder.setResolvedRemoteAddress(remoteAddress);
-
-        // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
-        if (future.getProxyServer() == null && uri.isSecured()) {
-            SslHandler sslHandler = null;
-            try {
-                sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost());
-            } catch (Exception sslError) {
-                onFailure(channel, sslError);
-                return;
-            }
-
-            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
-
-            if (asyncHandlerExtensions != null) {
-                try {
-                    asyncHandlerExtensions.onTlsHandshakeAttempt();
-                } catch (Exception e) {
-                    LOGGER.error("onTlsHandshakeAttempt crashed", e);
-                    onFailure(channel, e);
-                    return;
-                }
-            }
-
-            sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
-                @Override
-                protected void onSuccess(Channel value) throws Exception {
-                    if (asyncHandlerExtensions != null) {
-                        try {
-                            asyncHandlerExtensions.onTlsHandshakeSuccess();
-                        } catch (Exception e) {
-                            LOGGER.error("onTlsHandshakeSuccess crashed", e);
-                            NettyConnectListener.this.onFailure(channel, e);
-                            return;
-                        }
-                    }
-                    writeRequest(channel);
-                }
-
-                @Override
-                protected void onFailure(Throwable cause) throws Exception {
-                    if (asyncHandlerExtensions != null) {
-                        try {
-                            asyncHandlerExtensions.onTlsHandshakeFailure(cause);
-                        } catch (Exception e) {
-                            LOGGER.error("onTlsHandshakeFailure crashed", e);
-                            NettyConnectListener.this.onFailure(channel, e);
-                            return;
-                        }
-                    }
-                    NettyConnectListener.this.onFailure(channel, cause);
-                }
-            });
-
-        } else {
-            writeRequest(channel);
+        @Override
+        protected void onFailure(Throwable cause) {
+          try {
+            asyncHandler.onTlsHandshakeFailure(cause);
+          } catch (Exception e) {
+            LOGGER.error("onTlsHandshakeFailure crashed", e);
+            NettyConnectListener.this.onFailure(channel, e);
+            return;
+          }
+          NettyConnectListener.this.onFailure(channel, cause);
         }
+      });
+
+    } else {
+      writeRequest(channel);
     }
+  }
 
-    public void onFailure(Channel channel, Throwable cause) {
+  public void onFailure(Channel channel, Throwable cause) {
 
-        // beware, channel can be null
-        Channels.silentlyCloseChannel(channel);
+    // beware, channel can be null
+    Channels.silentlyCloseChannel(channel);
 
-        boolean canRetry = future.incrementRetryAndCheck();
-        LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
-        if (canRetry//
-                && cause != null // FIXME when can we have a null cause?
-                && (future.getChannelState() != ChannelState.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
+    boolean canRetry = future.incrementRetryAndCheck();
+    LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
+    if (canRetry//
+            && cause != null // FIXME when can we have a null cause?
+            && (future.getChannelState() != ChannelState.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
 
-            if (requestSender.retry(future)) {
-                return;
-            }
-        }
+      if (requestSender.retry(future)) {
+        return;
+      }
+    }
 
-        LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
+    LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
 
-        boolean printCause = cause.getMessage() != null;
-        String printedCause = printCause ? cause.getMessage() : getBaseUrl(future.getUri());
-        ConnectException e = new ConnectException(printedCause);
-        e.initCause(cause);
-        future.abort(e);
-    }
+    String message = cause.getMessage() != null ? cause.getMessage() : future.getUri().getBaseUrl();
+    ConnectException e = new ConnectException(message);
+    e.initCause(cause);
+    future.abort(e);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
index df021b5b6..907623bba 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
@@ -18,10 +18,10 @@
 
 enum NioSocketChannelFactory implements ChannelFactory<NioSocketChannel> {
 
-    INSTANCE;
-    
-    @Override
-    public NioSocketChannel newChannel() {
-        return new NioSocketChannel();
-    }
+  INSTANCE;
+
+  @Override
+  public NioSocketChannel newChannel() {
+    return new NioSocketChannel();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java
deleted file mode 100644
index 923e77d30..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty.channel;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Semaphore-like API, but without blocking.
- *
- * @author Stepan Koltsov
- */
-class NonBlockingSemaphore implements NonBlockingSemaphoreLike {
-
-    private final AtomicInteger permits;
-
-    public NonBlockingSemaphore(int permits) {
-        this.permits = new AtomicInteger(permits);
-    }
-
-    @Override
-    public void release() {
-        permits.incrementAndGet();
-    }
-
-    @Override
-    public boolean tryAcquire() {
-        for (;;) {
-            int count = permits.get();
-            if (count <= 0) {
-                return false;
-            }
-            if (permits.compareAndSet(count, count - 1)) {
-                return true;
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        // mimic toString of Semaphore class
-        return super.toString() + "[Permits = " + permits + "]";
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java b/client/src/main/java/org/asynchttpclient/netty/channel/NoopConnectionSemaphore.java
similarity index 64%
rename from client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
rename to client/src/main/java/org/asynchttpclient/netty/channel/NoopConnectionSemaphore.java
index e0363a85d..15dea9d9c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NoopConnectionSemaphore.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -13,12 +13,18 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import io.netty.channel.ChannelHandlerAdapter;
-import io.netty.channel.ChannelHandler.Sharable;
+import java.io.IOException;
 
 /**
- * A noop handler that just serves as a pinned reference for adding and removing handlers in the pipeline
+ * No-op implementation of {@link ConnectionSemaphore}.
  */
-@Sharable
-public class NoopHandler extends ChannelHandlerAdapter {
+public class NoopConnectionSemaphore implements ConnectionSemaphore {
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) throws IOException {
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionSemaphore.java
new file mode 100644
index 000000000..9ce1f20e9
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionSemaphore.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
+
+import java.io.IOException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
+/**
+ * Max per-host connections limiter.
+ */
+public class PerHostConnectionSemaphore implements ConnectionSemaphore {
+
+  protected final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
+  protected final int maxConnectionsPerHost;
+  protected final IOException tooManyConnectionsPerHost;
+  protected final int acquireTimeout;
+
+  PerHostConnectionSemaphore(int maxConnectionsPerHost, int acquireTimeout) {
+    tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(maxConnectionsPerHost), PerHostConnectionSemaphore.class, "acquireChannelLock");
+    this.maxConnectionsPerHost = maxConnectionsPerHost;
+    this.acquireTimeout = Math.max(0, acquireTimeout);
+  }
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) throws IOException {
+    try {
+      if (!getFreeConnectionsForHost(partitionKey).tryAcquire(acquireTimeout, TimeUnit.MILLISECONDS)) {
+        throw tooManyConnectionsPerHost;
+      }
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+    getFreeConnectionsForHost(partitionKey).release();
+  }
+
+  protected Semaphore getFreeConnectionsForHost(Object partitionKey) {
+    return maxConnectionsPerHost > 0 ?
+            freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new Semaphore(maxConnectionsPerHost)) :
+            InfiniteSemaphore.INSTANCE;
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java b/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
index c02c638ae..626754d3c 100755
--- a/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
@@ -17,46 +17,43 @@
 
 public class StackTraceInspector {
 
-    private static boolean exceptionInMethod(Throwable t, String className, String methodName) {
-        try {
-            for (StackTraceElement element : t.getStackTrace()) {
-                if (element.getClassName().equals(className) && element.getMethodName().equals(methodName))
-                    return true;
-            }
-        } catch (Throwable ignore) {
-        }
-        return false;
+  private static boolean exceptionInMethod(Throwable t, String className, String methodName) {
+    try {
+      for (StackTraceElement element : t.getStackTrace()) {
+        if (element.getClassName().equals(className) && element.getMethodName().equals(methodName))
+          return true;
+      }
+    } catch (Throwable ignore) {
     }
-
-    private static boolean recoverOnConnectCloseException(Throwable t) {
-        return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
-                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
-    }
-
-    public static boolean recoverOnNettyDisconnectException(Throwable t) {
-        return t instanceof ClosedChannelException
-                || exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
-                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
+    return false;
+  }
+
+  private static boolean recoverOnConnectCloseException(Throwable t) {
+    return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
+            || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
+  }
+
+  public static boolean recoverOnNettyDisconnectException(Throwable t) {
+    return t instanceof ClosedChannelException
+            || exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
+            || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
+  }
+
+  public static boolean recoverOnReadOrWriteException(Throwable t) {
+
+    if (t instanceof IOException && "Connection reset by peer".equalsIgnoreCase(t.getMessage()))
+      return true;
+
+    try {
+      for (StackTraceElement element : t.getStackTrace()) {
+        String className = element.getClassName();
+        String methodName = element.getMethodName();
+        if (className.equals("sun.nio.ch.SocketDispatcher") && (methodName.equals("read") || methodName.equals("write")))
+          return true;
+      }
+    } catch (Throwable ignore) {
     }
 
-    public static boolean recoverOnReadOrWriteException(Throwable t) {
-
-        if (t instanceof IOException && "Connection reset by peer".equalsIgnoreCase(t.getMessage()))
-            return true;
-
-        try {
-            for (StackTraceElement element : t.getStackTrace()) {
-                String className = element.getClassName();
-                String methodName = element.getMethodName();
-                if (className.equals("sun.nio.ch.SocketDispatcher") && (methodName.equals("read") || methodName.equals("write")))
-                    return true;
-            }
-        } catch (Throwable ignore) {
-        }
-
-        if (t.getCause() != null)
-            return recoverOnReadOrWriteException(t.getCause());
-
-        return false;
-    }
+    return t.getCause() != null && recoverOnReadOrWriteException(t.getCause());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index c3c5e4861..ec158673f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -13,7 +13,6 @@
  */
 package org.asynchttpclient.netty.handler;
 
-import static org.asynchttpclient.util.MiscUtils.getCause;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -22,16 +21,12 @@
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.ReferenceCountUtil;
-
-import java.io.IOException;
-import java.nio.channels.ClosedChannelException;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.exception.ChannelClosedException;
-import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.DiscardEvent;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
@@ -40,212 +35,219 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
+
+import static org.asynchttpclient.util.MiscUtils.getCause;
+
 public abstract class AsyncHttpClientHandler extends ChannelInboundHandlerAdapter {
 
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    protected final AsyncHttpClientConfig config;
-    protected final ChannelManager channelManager;
-    protected final NettyRequestSender requestSender;
-    protected final Interceptors interceptors;
-    protected final boolean hasIOExceptionFilters;
-
-    public AsyncHttpClientHandler(AsyncHttpClientConfig config,//
-            ChannelManager channelManager,//
-            NettyRequestSender requestSender) {
-        this.config = config;
-        this.channelManager = channelManager;
-        this.requestSender = requestSender;
-        interceptors = new Interceptors(config, channelManager, requestSender);
-        hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
-    }
+  protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+  protected final AsyncHttpClientConfig config;
+  protected final ChannelManager channelManager;
+  protected final NettyRequestSender requestSender;
+  final Interceptors interceptors;
+  final boolean hasIOExceptionFilters;
+
+  AsyncHttpClientHandler(AsyncHttpClientConfig config,
+                                ChannelManager channelManager,
+                                NettyRequestSender requestSender) {
+    this.config = config;
+    this.channelManager = channelManager;
+    this.requestSender = requestSender;
+    interceptors = new Interceptors(config, channelManager, requestSender);
+    hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
+  }
+
+  @Override
+  public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+
+    Channel channel = ctx.channel();
+    Object attribute = Channels.getAttribute(channel);
+
+    try {
+      if (attribute instanceof OnLastHttpContentCallback) {
+        if (msg instanceof LastHttpContent) {
+          ((OnLastHttpContentCallback) attribute).call();
+        }
 
-    @Override
-    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
-
-        Channel channel = ctx.channel();
-        Object attribute = Channels.getAttribute(channel);
-
-        try {
-            if (attribute instanceof OnLastHttpContentCallback && msg instanceof LastHttpContent) {
-                ((OnLastHttpContentCallback) attribute).call();
-
-            } else if (attribute instanceof NettyResponseFuture) {
-                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-                future.touch();
-                handleRead(channel, future, msg);
-
-            } else if (attribute instanceof StreamedResponsePublisher) {
-                StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
-                publisher.future().touch();
-
-                if (msg instanceof HttpContent) {
-                    ByteBuf content = ((HttpContent) msg).content();
-                    // Republish as a HttpResponseBodyPart
-                    if (content.isReadable()) {
-                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
-                        ctx.fireChannelRead(part);
-                    }
-                    if (msg instanceof LastHttpContent) {
-                        // Remove the handler from the pipeline, this will trigger
-                        // it to finish
-                        ctx.pipeline().remove(publisher);
-                        // Trigger a read, just in case the last read complete
-                        // triggered no new read
-                        ctx.read();
-                        // Send the last content on to the protocol, so that it can
-                        // conclude the cleanup
-                        handleRead(channel, publisher.future(), msg);
-                    }
-                } else {
-                    logger.info("Received unexpected message while expecting a chunk: " + msg);
-                    ctx.pipeline().remove(publisher);
-                    Channels.setDiscard(channel);
-                }
-            } else if (attribute != DiscardEvent.DISCARD) {
-                // unhandled message
-                logger.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
-                Channels.silentlyCloseChannel(channel);
-            }
-        } finally {
-            ReferenceCountUtil.release(msg);
+      } else if (attribute instanceof NettyResponseFuture) {
+        NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+        future.touch();
+        handleRead(channel, future, msg);
+
+      } else if (attribute instanceof StreamedResponsePublisher) {
+        StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
+        publisher.future().touch();
+
+        if (msg instanceof HttpContent) {
+          ByteBuf content = ((HttpContent) msg).content();
+          // Republish as a HttpResponseBodyPart
+          if (content.isReadable()) {
+            HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
+            ctx.fireChannelRead(part);
+          }
+          if (msg instanceof LastHttpContent) {
+            // Remove the handler from the pipeline, this will trigger
+            // it to finish
+            ctx.pipeline().remove(publisher);
+            // Trigger a read, just in case the last read complete
+            // triggered no new read
+            ctx.read();
+            // Send the last content on to the protocol, so that it can
+            // conclude the cleanup
+            handleRead(channel, publisher.future(), msg);
+          }
+        } else {
+          logger.info("Received unexpected message while expecting a chunk: " + msg);
+          ctx.pipeline().remove(publisher);
+          Channels.setDiscard(channel);
         }
+      } else if (attribute != DiscardEvent.DISCARD) {
+        // unhandled message
+        logger.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
+        Channels.silentlyCloseChannel(channel);
+      }
+    } finally {
+      ReferenceCountUtil.release(msg);
     }
+  }
 
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-
-        if (requestSender.isClosed())
-            return;
-
-        Channel channel = ctx.channel();
-        channelManager.removeAll(channel);
+  public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
-        Object attribute = Channels.getAttribute(channel);
-        logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
-        if (attribute instanceof StreamedResponsePublisher) {
-            // setting `attribute` to be the underlying future so that the retry
-            // logic can kick-in
-            attribute = ((StreamedResponsePublisher) attribute).future();
-        }
-        if (attribute instanceof OnLastHttpContentCallback) {
-            OnLastHttpContentCallback callback = (OnLastHttpContentCallback) attribute;
-            Channels.setAttribute(channel, callback.future());
-            callback.call();
-
-        } else if (attribute instanceof NettyResponseFuture<?>) {
-            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-            future.touch();
+    if (requestSender.isClosed())
+      return;
 
-            if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
-                return;
+    Channel channel = ctx.channel();
+    channelManager.removeAll(channel);
 
-            handleChannelInactive(future);
-            requestSender.handleUnexpectedClosedChannel(channel, future);
-        }
+    Object attribute = Channels.getAttribute(channel);
+    logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
+    if (attribute instanceof StreamedResponsePublisher) {
+      // setting `attribute` to be the underlying future so that the retry
+      // logic can kick-in
+      attribute = ((StreamedResponsePublisher) attribute).future();
     }
+    if (attribute instanceof OnLastHttpContentCallback) {
+      OnLastHttpContentCallback callback = (OnLastHttpContentCallback) attribute;
+      Channels.setAttribute(channel, callback.future());
+      callback.call();
 
-    @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Exception {
-        Throwable cause = getCause(e);
-
-        if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
-            return;
-
-        Channel channel = ctx.channel();
-        NettyResponseFuture<?> future = null;
+    } else if (attribute instanceof NettyResponseFuture<?>) {
+      NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+      future.touch();
 
-        logger.debug("Unexpected I/O exception on channel {}", channel, cause);
+      if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
+        return;
 
-        try {
-            Object attribute = Channels.getAttribute(channel);
-            if (attribute instanceof StreamedResponsePublisher) {
-                ctx.fireExceptionCaught(e);
-                // setting `attribute` to be the underlying future so that the
-                // retry logic can kick-in
-                attribute = ((StreamedResponsePublisher) attribute).future();
-            }
-            if (attribute instanceof NettyResponseFuture<?>) {
-                future = (NettyResponseFuture<?>) attribute;
-                future.attachChannel(null, false);
-                future.touch();
-
-                if (cause instanceof IOException) {
-
-                    // FIXME why drop the original exception and throw a new one?
-                    if (hasIOExceptionFilters) {
-                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel)) {
-                            // Close the channel so the recovering can occurs.
-                            Channels.silentlyCloseChannel(channel);
-                        }
-                        return;
-                    }
-                }
-
-                if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-                    logger.debug("Trying to recover from dead Channel: {}", channel);
-                    future.pendingException = cause;
-                    return;
-                }
-            } else if (attribute instanceof OnLastHttpContentCallback) {
-                future = OnLastHttpContentCallback.class.cast(attribute).future();
+      handleChannelInactive(future);
+      requestSender.handleUnexpectedClosedChannel(channel, future);
+    }
+  }
+
+  @Override
+  public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) {
+    Throwable cause = getCause(e);
+
+    if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
+      return;
+
+    Channel channel = ctx.channel();
+    NettyResponseFuture<?> future = null;
+
+    logger.debug("Unexpected I/O exception on channel {}", channel, cause);
+
+    try {
+      Object attribute = Channels.getAttribute(channel);
+      if (attribute instanceof StreamedResponsePublisher) {
+        ctx.fireExceptionCaught(e);
+        // setting `attribute` to be the underlying future so that the
+        // retry logic can kick-in
+        attribute = ((StreamedResponsePublisher) attribute).future();
+      }
+      if (attribute instanceof NettyResponseFuture<?>) {
+        future = (NettyResponseFuture<?>) attribute;
+        future.attachChannel(null, false);
+        future.touch();
+
+        if (cause instanceof IOException) {
+
+          // FIXME why drop the original exception and throw a new one?
+          if (hasIOExceptionFilters) {
+            if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel)) {
+              // Close the channel so the recovering can occurs.
+              Channels.silentlyCloseChannel(channel);
             }
-        } catch (Throwable t) {
-            cause = t;
+            return;
+          }
         }
 
-        if (future != null)
-            try {
-                logger.debug("Was unable to recover Future: {}", future);
-                requestSender.abort(channel, future, cause);
-                handleException(future, e);
-            } catch (Throwable t) {
-                logger.error(t.getMessage(), t);
-            }
-
-        channelManager.closeChannel(channel);
-        // FIXME not really sure
-        // ctx.fireChannelRead(e);
-        Channels.silentlyCloseChannel(channel);
+        if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+          logger.debug("Trying to recover from dead Channel: {}", channel);
+          future.pendingException = cause;
+          return;
+        }
+      } else if (attribute instanceof OnLastHttpContentCallback) {
+        future = OnLastHttpContentCallback.class.cast(attribute).future();
+      }
+    } catch (Throwable t) {
+      cause = t;
     }
 
-    @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        ctx.read();
+    if (future != null)
+      try {
+        logger.debug("Was unable to recover Future: {}", future);
+        requestSender.abort(channel, future, cause);
+        handleException(future, e);
+      } catch (Throwable t) {
+        logger.error(t.getMessage(), t);
+      }
+
+    channelManager.closeChannel(channel);
+    // FIXME not really sure
+    // ctx.fireChannelRead(e);
+    Channels.silentlyCloseChannel(channel);
+  }
+
+  @Override
+  public void channelActive(ChannelHandlerContext ctx) {
+    ctx.read();
+  }
+
+  @Override
+  public void channelReadComplete(ChannelHandlerContext ctx) {
+    if (!isHandledByReactiveStreams(ctx)) {
+      ctx.read();
+    } else {
+      ctx.fireChannelReadComplete();
     }
+  }
 
-    @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        if (!isHandledByReactiveStreams(ctx)) {
-            ctx.read();
-        } else {
-            ctx.fireChannelReadComplete();
-        }
-    }
+  private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
+    return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
+  }
+
+  void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean close) {
+    future.cancelTimeouts();
 
-    private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
-        return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
+    if (close) {
+      channelManager.closeChannel(channel);
+    } else {
+      channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), true, future.getPartitionKey());
     }
-    
-    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean close) throws IOException {
-        future.cancelTimeouts();
-        
-        if (close) {
-            channelManager.closeChannel(channel);
-        } else {
-            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), true, future.getPartitionKey());
-        }
 
-        try {
-            future.done();
-        } catch (Exception t) {
-            // Never propagate exception once we know we are done.
-            logger.debug(t.getMessage(), t);
-        }
+    try {
+      future.done();
+    } catch (Exception t) {
+      // Never propagate exception once we know we are done.
+      logger.debug(t.getMessage(), t);
     }
+  }
 
-    public abstract void handleRead(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+  public abstract void handleRead(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
 
-    public abstract void handleException(NettyResponseFuture<?> future, Throwable error);
+  public abstract void handleException(NettyResponseFuture<?> future, Throwable error);
 
-    public abstract void handleChannelInactive(NettyResponseFuture<?> future);
+  public abstract void handleChannelInactive(NettyResponseFuture<?> future);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 1edc5b562..ad29808d9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -16,15 +16,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpObject;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
-
-import java.io.IOException;
-
+import io.netty.handler.codec.DecoderResultProvider;
+import io.netty.handler.codec.http.*;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -36,147 +29,147 @@
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
+import java.io.IOException;
+
 @Sharable
 public final class HttpHandler extends AsyncHttpClientHandler {
 
-    public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager, NettyRequestSender requestSender) {
-        super(config, channelManager, requestSender);
-    }
-
-    private boolean abortAfterHandlingStatus(//
-            AsyncHandler<?> handler,//
-            NettyResponseStatus status) throws Exception {
-        return handler.onStatusReceived(status) == State.ABORT;
-    }
-
-    private boolean abortAfterHandlingHeaders(//
-            AsyncHandler<?> handler,//
-            HttpHeaders responseHeaders) throws Exception {
-        return !responseHeaders.isEmpty() && handler.onHeadersReceived(responseHeaders) == State.ABORT;
-    }
-
-    private boolean abortAfterHandlingReactiveStreams(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler) throws IOException {
-        if (handler instanceof StreamedAsyncHandler) {
-            StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
-            StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
-            // FIXME do we really need to pass the event loop?
-            // FIXME move this to ChannelManager
-            channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
-            Channels.setAttribute(channel, publisher);
-            return streamedAsyncHandler.onStream(publisher) == State.ABORT;
-        }
-        return false;
+  public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager, NettyRequestSender requestSender) {
+    super(config, channelManager, requestSender);
+  }
+
+  private boolean abortAfterHandlingStatus(//
+                                           AsyncHandler<?> handler,
+                                           NettyResponseStatus status) throws Exception {
+    return handler.onStatusReceived(status) == State.ABORT;
+  }
+
+  private boolean abortAfterHandlingHeaders(AsyncHandler<?> handler,
+                                            HttpHeaders responseHeaders) throws Exception {
+    return !responseHeaders.isEmpty() && handler.onHeadersReceived(responseHeaders) == State.ABORT;
+  }
+
+  private boolean abortAfterHandlingReactiveStreams(Channel channel,
+                                                    NettyResponseFuture<?> future,
+                                                    AsyncHandler<?> handler) {
+    if (handler instanceof StreamedAsyncHandler) {
+      StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
+      StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
+      // FIXME do we really need to pass the event loop?
+      // FIXME move this to ChannelManager
+      channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
+      Channels.setAttribute(channel, publisher);
+      return streamedAsyncHandler.onStream(publisher) == State.ABORT;
     }
+    return false;
+  }
 
-    private void handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+  private void handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
 
-        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+    HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+    logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
 
-        future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
+    future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
 
-        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
-        HttpHeaders responseHeaders = response.headers();
+    NettyResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
+    HttpHeaders responseHeaders = response.headers();
 
-        if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
-            boolean abort = abortAfterHandlingStatus(handler, status) || //
-                    abortAfterHandlingHeaders(handler, responseHeaders) || //
-                    abortAfterHandlingReactiveStreams(channel, future, handler);
+    if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+      boolean abort = abortAfterHandlingStatus(handler, status) || //
+              abortAfterHandlingHeaders(handler, responseHeaders) || //
+              abortAfterHandlingReactiveStreams(channel, future, handler);
 
-            if (abort) {
-                finishUpdate(future, channel, true);
-            }
-        }
+      if (abort) {
+        finishUpdate(future, channel, true);
+      }
+    }
+  }
+
+  private void handleChunk(HttpContent chunk,
+                           final Channel channel,
+                           final NettyResponseFuture<?> future,
+                           AsyncHandler<?> handler) throws Exception {
+
+    boolean abort = false;
+    boolean last = chunk instanceof LastHttpContent;
+
+    // Netty 4: the last chunk is not empty
+    if (last) {
+      LastHttpContent lastChunk = (LastHttpContent) chunk;
+      HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
+      if (!trailingHeaders.isEmpty()) {
+        abort = handler.onTrailingHeadersReceived(trailingHeaders) == State.ABORT;
+      }
     }
 
-    private void handleChunk(HttpContent chunk,//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler) throws IOException, Exception {
-
-        boolean abort = false;
-        boolean last = chunk instanceof LastHttpContent;
-
-        // Netty 4: the last chunk is not empty
-        if (last) {
-            LastHttpContent lastChunk = (LastHttpContent) chunk;
-            HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
-            if (!trailingHeaders.isEmpty()) {
-                abort = handler.onTrailingHeadersReceived(trailingHeaders) == State.ABORT;
-            }
-        }
-
-        ByteBuf buf = chunk.content();
-        if (!abort && !(handler instanceof StreamedAsyncHandler) && (buf.isReadable() || last)) {
-            HttpResponseBodyPart bodyPart = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
-            abort = handler.onBodyPartReceived(bodyPart) == State.ABORT;
-        }
+    ByteBuf buf = chunk.content();
+    if (!abort && !(handler instanceof StreamedAsyncHandler) && (buf.isReadable() || last)) {
+      HttpResponseBodyPart bodyPart = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
+      abort = handler.onBodyPartReceived(bodyPart) == State.ABORT;
+    }
 
-        if (abort || last) {
-            boolean close = abort || !future.isKeepAlive();
-            finishUpdate(future, channel, close);
-        }
+    if (abort || last) {
+      boolean close = abort || !future.isKeepAlive();
+      finishUpdate(future, channel, close);
     }
+  }
 
-    @Override
-    public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+  @Override
+  public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
 
-        // future is already done because of an exception or a timeout
-        if (future.isDone()) {
-            // FIXME isn't the channel already properly closed?
-            channelManager.closeChannel(channel);
-            return;
-        }
+    // future is already done because of an exception or a timeout
+    if (future.isDone()) {
+      // FIXME isn't the channel already properly closed?
+      channelManager.closeChannel(channel);
+      return;
+    }
 
-        AsyncHandler<?> handler = future.getAsyncHandler();
-        try {
-            if (e instanceof HttpObject) {
-                HttpObject object = (HttpObject) e;
-                Throwable t = object.decoderResult().cause();
-                if (t != null) {
-                    readFailed(channel, future, t);
-                    return;
-                }
-            }
-            
-            if (e instanceof HttpResponse) {
-                handleHttpResponse((HttpResponse) e, channel, future, handler);
-
-            } else if (e instanceof HttpContent) {
-                handleChunk((HttpContent) e, channel, future, handler);
-            }
-        } catch (Exception t) {
-            // e.g. an IOException when trying to open a connection and send the
-            // next request
-            if (hasIOExceptionFilters//
-                    && t instanceof IOException//
-                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
-                return;
-            }
-
-            readFailed(channel, future, t);
-            throw t;
+    AsyncHandler<?> handler = future.getAsyncHandler();
+    try {
+      if (e instanceof DecoderResultProvider) {
+        DecoderResultProvider object = (DecoderResultProvider) e;
+        Throwable t = object.decoderResult().cause();
+        if (t != null) {
+          readFailed(channel, future, t);
+          return;
         }
+      }
+
+      if (e instanceof HttpResponse) {
+        handleHttpResponse((HttpResponse) e, channel, future, handler);
+
+      } else if (e instanceof HttpContent) {
+        handleChunk((HttpContent) e, channel, future, handler);
+      }
+    } catch (Exception t) {
+      // e.g. an IOException when trying to open a connection and send the
+      // next request
+      if (hasIOExceptionFilters//
+              && t instanceof IOException//
+              && requestSender.applyIoExceptionFiltersAndReplayRequest(future, (IOException) t, channel)) {
+        return;
+      }
+
+      readFailed(channel, future, t);
+      throw t;
     }
-    
-    private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwable t) throws Exception {
-        try {
-            requestSender.abort(channel, future, t);
-        } catch (Exception abortException) {
-            logger.debug("Abort failed", abortException);
-        } finally {
-            finishUpdate(future, channel, true);
-        }
+  }
+
+  private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwable t) {
+    try {
+      requestSender.abort(channel, future, t);
+    } catch (Exception abortException) {
+      logger.debug("Abort failed", abortException);
+    } finally {
+      finishUpdate(future, channel, true);
     }
+  }
 
-    @Override
-    public void handleException(NettyResponseFuture<?> future, Throwable error) {
-    }
+  @Override
+  public void handleException(NettyResponseFuture<?> future, Throwable error) {
+  }
 
-    @Override
-    public void handleChannelInactive(NettyResponseFuture<?> future) {
-    }
+  @Override
+  public void handleChannelInactive(NettyResponseFuture<?> future) {
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
index 0b5d8ce55..f4565f91b 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
@@ -13,10 +13,8 @@
 package org.asynchttpclient.netty.handler;
 
 import com.typesafe.netty.HandlerPublisher;
-
 import io.netty.channel.Channel;
 import io.netty.util.concurrent.EventExecutor;
-
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -25,35 +23,35 @@
 
 public class StreamedResponsePublisher extends HandlerPublisher<HttpResponseBodyPart> {
 
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    private final ChannelManager channelManager;
-    private final NettyResponseFuture<?> future;
-    private final Channel channel;
+  protected final Logger logger = LoggerFactory.getLogger(getClass());
 
-    public StreamedResponsePublisher(EventExecutor executor, ChannelManager channelManager, NettyResponseFuture<?> future, Channel channel) {
-        super(executor, HttpResponseBodyPart.class);
-        this.channelManager = channelManager;
-        this.future = future;
-        this.channel = channel;
-    }
+  private final ChannelManager channelManager;
+  private final NettyResponseFuture<?> future;
+  private final Channel channel;
 
-    @Override
-    protected void cancelled() {
-        logger.debug("Subscriber cancelled, ignoring the rest of the body");
+  StreamedResponsePublisher(EventExecutor executor, ChannelManager channelManager, NettyResponseFuture<?> future, Channel channel) {
+    super(executor, HttpResponseBodyPart.class);
+    this.channelManager = channelManager;
+    this.future = future;
+    this.channel = channel;
+  }
 
-        try {
-            future.done();
-        } catch (Exception t) {
-            // Never propagate exception once we know we are done.
-            logger.debug(t.getMessage(), t);
-        }
+  @Override
+  protected void cancelled() {
+    logger.debug("Subscriber cancelled, ignoring the rest of the body");
 
-        // The subscriber cancelled early - this channel is dead and should be closed.
-        channelManager.closeChannel(channel);
+    try {
+      future.done();
+    } catch (Exception t) {
+      // Never propagate exception once we know we are done.
+      logger.debug(t.getMessage(), t);
     }
 
-    NettyResponseFuture<?> future() {
-        return future;
-    }
+    // The subscriber cancelled early - this channel is dead and should be closed.
+    channelManager.closeChannel(channel);
+  }
+
+  NettyResponseFuture<?> future() {
+    return future;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 637ff2181..533322f4b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -13,20 +13,10 @@
  */
 package org.asynchttpclient.netty.handler;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
-import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.http.HttpHeaderValues;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.codec.http.*;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
-
-import java.io.IOException;
-
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseStatus;
@@ -38,135 +28,141 @@
 import org.asynchttpclient.netty.ws.NettyWebSocket;
 import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 
+import java.io.IOException;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
+import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
+
 @Sharable
 public final class WebSocketHandler extends AsyncHttpClientHandler {
 
-    public WebSocketHandler(AsyncHttpClientConfig config,//
-            ChannelManager channelManager,//
-            NettyRequestSender requestSender) {
-        super(config, channelManager, requestSender);
+  public WebSocketHandler(AsyncHttpClientConfig config,
+                          ChannelManager channelManager,
+                          NettyRequestSender requestSender) {
+    super(config, channelManager, requestSender);
+  }
+
+  private static WebSocketUpgradeHandler getWebSocketUpgradeHandler(NettyResponseFuture<?> future) {
+    return (WebSocketUpgradeHandler) future.getAsyncHandler();
+  }
+
+  private static NettyWebSocket getNettyWebSocket(NettyResponseFuture<?> future) throws Exception {
+    return getWebSocketUpgradeHandler(future).onCompleted();
+  }
+
+  private void upgrade(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponse response, HttpHeaders responseHeaders)
+          throws Exception {
+    boolean validStatus = response.status().equals(SWITCHING_PROTOCOLS);
+    boolean validUpgrade = response.headers().get(UPGRADE) != null;
+    String connection = response.headers().get(CONNECTION);
+    boolean validConnection = HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection);
+    final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
+    if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
+      requestSender.abort(channel, future, new IOException("Invalid handshake response"));
+      return;
     }
 
-    private void upgrade(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponse response, HttpHeaders responseHeaders)
-            throws Exception {
-        boolean validStatus = response.status().equals(SWITCHING_PROTOCOLS);
-        boolean validUpgrade = response.headers().get(UPGRADE) != null;
-        String connection = response.headers().get(CONNECTION);
-        boolean validConnection = HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection);
-        final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
-        if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
-            requestSender.abort(channel, future, new IOException("Invalid handshake response"));
-            return;
-        }
-
-        String accept = response.headers().get(SEC_WEBSOCKET_ACCEPT);
-        String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(SEC_WEBSOCKET_KEY));
-        if (accept == null || !accept.equals(key)) {
-            requestSender.abort(channel, future, new IOException("Invalid challenge. Actual: " + accept + ". Expected: " + key));
-        }
-
-        // set back the future so the protocol gets notified of frames
-        // removing the HttpClientCodec from the pipeline might trigger a read with a WebSocket message
-        // if it comes in the same frame as the HTTP Upgrade response
-        Channels.setAttribute(channel, future);
-
-        handler.setWebSocket(new NettyWebSocket(channel, responseHeaders));
-        channelManager.upgradePipelineForWebSockets(channel.pipeline());
-
-        // We don't need to synchronize as replacing the "ws-decoder" will
-        // process using the same thread.
-        try {
-            handler.onOpen();
-        } catch (Exception ex) {
-            logger.warn("onSuccess unexpected exception", ex);
-        }
-        future.done();
+    String accept = response.headers().get(SEC_WEBSOCKET_ACCEPT);
+    String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(SEC_WEBSOCKET_KEY));
+    if (accept == null || !accept.equals(key)) {
+      requestSender.abort(channel, future, new IOException("Invalid challenge. Actual: " + accept + ". Expected: " + key));
     }
 
-    private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponseStatus status) throws Exception {
-        try {
-            handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
-        } finally {
-            finishUpdate(future, channel, true);
-        }
-    }
+    // set back the future so the protocol gets notified of frames
+    // removing the HttpClientCodec from the pipeline might trigger a read with a WebSocket message
+    // if it comes in the same frame as the HTTP Upgrade response
+    Channels.setAttribute(channel, future);
+
+    handler.setWebSocket(new NettyWebSocket(channel, responseHeaders));
+    channelManager.upgradePipelineForWebSockets(channel.pipeline());
 
-    private static WebSocketUpgradeHandler getWebSocketUpgradeHandler(NettyResponseFuture<?> future) {
-        return (WebSocketUpgradeHandler) future.getAsyncHandler();
+    // We don't need to synchronize as replacing the "ws-decoder" will
+    // process using the same thread.
+    try {
+      handler.onOpen();
+    } catch (Exception ex) {
+      logger.warn("onSuccess unexpected exception", ex);
     }
-    
-    private static NettyWebSocket getNettyWebSocket(NettyResponseFuture<?> future) throws Exception {
-        return getWebSocketUpgradeHandler(future).onCompleted();
+    future.done();
+  }
+
+  private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponseStatus status) {
+    try {
+      handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
+    } finally {
+      finishUpdate(future, channel, true);
     }
-    
-    @Override
-    public void handleRead(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
-
-        if (e instanceof HttpResponse) {
-            HttpResponse response = (HttpResponse) e;
-            if (logger.isDebugEnabled()) {
-                HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-                logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
-            }
-
-            WebSocketUpgradeHandler handler = getWebSocketUpgradeHandler(future);
-            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
-            HttpHeaders responseHeaders = response.headers();
-
-            if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
-                switch (handler.onStatusReceived(status)) {
-                case CONTINUE:
-                    upgrade(channel, future, handler, response, responseHeaders);
-                    break;
-                default:
-                    abort(channel, future, handler, status);
-                }
-            }
-
-        } else if (e instanceof WebSocketFrame) {
-            WebSocketFrame frame = (WebSocketFrame) e;
-            NettyWebSocket webSocket = getNettyWebSocket(future);
-            // retain because we might buffer the frame
-            if (webSocket.isReady()) {
-                webSocket.handleFrame(frame);
-            } else {
-                // WebSocket hasn't been open yet, but upgrading the pipeline triggered a read and a frame was sent along the HTTP upgrade response
-                // as we want to keep sequential order (but can't notify user of open before upgrading so he doesn't to try send immediately), we have to buffer
-                webSocket.bufferFrame(frame);
-            }
-
-        } else if (!(e instanceof LastHttpContent)) {
-            // ignore, end of handshake response
-            logger.error("Invalid message {}", e);
+  }
+
+  @Override
+  public void handleRead(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+
+    if (e instanceof HttpResponse) {
+      HttpResponse response = (HttpResponse) e;
+      if (logger.isDebugEnabled()) {
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+      }
+
+      WebSocketUpgradeHandler handler = getWebSocketUpgradeHandler(future);
+      HttpResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
+      HttpHeaders responseHeaders = response.headers();
+
+      if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+        switch (handler.onStatusReceived(status)) {
+          case CONTINUE:
+            upgrade(channel, future, handler, response, responseHeaders);
+            break;
+          default:
+            abort(channel, future, handler, status);
         }
+      }
+
+    } else if (e instanceof WebSocketFrame) {
+      WebSocketFrame frame = (WebSocketFrame) e;
+      NettyWebSocket webSocket = getNettyWebSocket(future);
+      // retain because we might buffer the frame
+      if (webSocket.isReady()) {
+        webSocket.handleFrame(frame);
+      } else {
+        // WebSocket hasn't been opened yet, but upgrading the pipeline triggered a read and a frame was sent along the HTTP upgrade response
+        // as we want to keep sequential order (but can't notify user of open before upgrading so he doesn't to try send immediately), we have to buffer
+        webSocket.bufferFrame(frame);
+      }
+
+    } else if (!(e instanceof LastHttpContent)) {
+      // ignore, end of handshake response
+      logger.error("Invalid message {}", e);
     }
-
-    @Override
-    public void handleException(NettyResponseFuture<?> future, Throwable e) {
-        logger.warn("onError", e);
-
-        try {
-            NettyWebSocket webSocket = getNettyWebSocket(future);
-            if (webSocket != null) {
-                webSocket.onError(e);
-                webSocket.sendCloseFrame();
-            }
-        } catch (Throwable t) {
-            logger.error("onError", t);
-        }
+  }
+
+  @Override
+  public void handleException(NettyResponseFuture<?> future, Throwable e) {
+    logger.warn("onError", e);
+
+    try {
+      NettyWebSocket webSocket = getNettyWebSocket(future);
+      if (webSocket != null) {
+        webSocket.onError(e);
+        webSocket.sendCloseFrame();
+      }
+    } catch (Throwable t) {
+      logger.error("onError", t);
     }
-
-    @Override
-    public void handleChannelInactive(NettyResponseFuture<?> future) {
-        logger.trace("Connection was closed abnormally (that is, with no close frame being received).");
-
-        try {
-            NettyWebSocket webSocket = getNettyWebSocket(future);
-            if (webSocket != null) {
-                webSocket.onClose(1006, "Connection was closed abnormally (that is, with no close frame being received).");
-            }
-        } catch (Throwable t) {
-            logger.error("onError", t);
-        }
+  }
+
+  @Override
+  public void handleChannelInactive(NettyResponseFuture<?> future) {
+    logger.trace("Connection was closed abnormally (that is, with no close frame being received).");
+
+    try {
+      NettyWebSocket webSocket = getNettyWebSocket(future);
+      if (webSocket != null) {
+        webSocket.onClose(1006, "Connection was closed abnormally (that is, with no close frame being received).");
+      }
+    } catch (Throwable t) {
+      logger.error("onError", t);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
index 8da166e20..753df0020 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
@@ -14,10 +14,7 @@
 package org.asynchttpclient.netty.handler.intercept;
 
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpRequest;
-
-import java.io.IOException;
-
+import io.netty.util.concurrent.Future;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.netty.NettyResponseFuture;
@@ -30,35 +27,38 @@
 
 public class ConnectSuccessInterceptor {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectSuccessInterceptor.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(ConnectSuccessInterceptor.class);
 
-    private final ChannelManager channelManager;
-    private final NettyRequestSender requestSender;
+  private final ChannelManager channelManager;
+  private final NettyRequestSender requestSender;
 
-    public ConnectSuccessInterceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-        this.channelManager = channelManager;
-        this.requestSender = requestSender;
-    }
+  ConnectSuccessInterceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+    this.channelManager = channelManager;
+    this.requestSender = requestSender;
+  }
 
-    public boolean exitAfterHandlingConnect(//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            final Request request,//
-            ProxyServer proxyServer,//
-            int statusCode,//
-            HttpRequest httpRequest) throws IOException {
+  public boolean exitAfterHandlingConnect(Channel channel,
+                                          NettyResponseFuture<?> future,
+                                          Request request,
+                                          ProxyServer proxyServer) {
 
-        if (future.isKeepAlive())
-            future.attachChannel(channel, true);
+    if (future.isKeepAlive())
+      future.attachChannel(channel, true);
 
-        Uri requestUri = request.getUri();
-        LOGGER.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
+    Uri requestUri = request.getUri();
+    LOGGER.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
 
-        channelManager.upgradeProtocol(channel.pipeline(), requestUri);
-        future.setReuseChannel(true);
-        future.setConnectAllowed(false);
-        requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
+    Future<Channel> whenHandshaked =  channelManager.updatePipelineForHttpTunneling(channel.pipeline(), requestUri);
 
-        return true;
+    future.setReuseChannel(true);
+    future.setConnectAllowed(false);
+    Request targetRequest = new RequestBuilder(future.getTargetRequest()).build();
+    if (whenHandshaked == null) {
+      requestSender.drainChannelAndExecuteNextRequest(channel, future, targetRequest);
+    } else {
+      requestSender.drainChannelAndExecuteNextRequest(channel, future, targetRequest, whenHandshaked);
     }
+
+    return true;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
index 189aedf5f..86eb39f7f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
@@ -14,33 +14,30 @@
 package org.asynchttpclient.netty.handler.intercept;
 
 import io.netty.channel.Channel;
-
-import java.io.IOException;
-
-import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
-public class Continue100Interceptor {
+class Continue100Interceptor {
 
-    private final NettyRequestSender requestSender;
+  private final NettyRequestSender requestSender;
 
-    public Continue100Interceptor(NettyRequestSender requestSender) {
-        this.requestSender = requestSender;
-    }
+  Continue100Interceptor(NettyRequestSender requestSender) {
+    this.requestSender = requestSender;
+  }
 
-    public boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
-        future.setHeadersAlreadyWrittenOnContinue(true);
-        future.setDontWriteBodyBecauseExpectContinue(false);
-        // directly send the body
-        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
-            @Override
-            public void call() throws IOException {
-                Channels.setAttribute(channel, future);
-                requestSender.writeRequest(future, channel);
-            }
-        });
-        return true;
-    }
+  public boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future) {
+    future.setHeadersAlreadyWrittenOnContinue(true);
+    future.setDontWriteBodyBecauseExpectContinue(false);
+    // directly send the body
+    Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
+      @Override
+      public void call() {
+        Channels.setAttribute(channel, future);
+        requestSender.writeRequest(future, channel);
+      }
+    });
+    return true;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
index ce144d38b..134213f60 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
@@ -13,82 +13,94 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
-import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
+import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
+import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.*;
+import org.asynchttpclient.cookie.CookieStore;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.proxy.ProxyServer;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
+
 public class Interceptors {
 
-    private final AsyncHttpClientConfig config;
-    private final Unauthorized401Interceptor unauthorized401Interceptor;
-    private final ProxyUnauthorized407Interceptor proxyUnauthorized407Interceptor;
-    private final Continue100Interceptor continue100Interceptor;
-    private final Redirect30xInterceptor redirect30xInterceptor;
-    private final ConnectSuccessInterceptor connectSuccessInterceptor;
-    private final ResponseFiltersInterceptor responseFiltersInterceptor;
-    private final boolean hasResponseFilters;
+  private final AsyncHttpClientConfig config;
+  private final Unauthorized401Interceptor unauthorized401Interceptor;
+  private final ProxyUnauthorized407Interceptor proxyUnauthorized407Interceptor;
+  private final Continue100Interceptor continue100Interceptor;
+  private final Redirect30xInterceptor redirect30xInterceptor;
+  private final ConnectSuccessInterceptor connectSuccessInterceptor;
+  private final ResponseFiltersInterceptor responseFiltersInterceptor;
+  private final boolean hasResponseFilters;
+  private final ClientCookieDecoder cookieDecoder;
 
-    public Interceptors(//
-            AsyncHttpClientConfig config,//
-            ChannelManager channelManager,//
-            NettyRequestSender requestSender) {
-        this.config = config;
-        unauthorized401Interceptor = new Unauthorized401Interceptor(channelManager, requestSender);
-        proxyUnauthorized407Interceptor = new ProxyUnauthorized407Interceptor(channelManager, requestSender);
-        continue100Interceptor = new Continue100Interceptor(requestSender);
-        redirect30xInterceptor = new Redirect30xInterceptor(channelManager, config, requestSender);
-        connectSuccessInterceptor = new ConnectSuccessInterceptor(channelManager, requestSender);
-        responseFiltersInterceptor = new ResponseFiltersInterceptor(config, requestSender);
-        hasResponseFilters = !config.getResponseFilters().isEmpty();
-    }
+  public Interceptors(AsyncHttpClientConfig config,
+                      ChannelManager channelManager,
+                      NettyRequestSender requestSender) {
+    this.config = config;
+    unauthorized401Interceptor = new Unauthorized401Interceptor(channelManager, requestSender);
+    proxyUnauthorized407Interceptor = new ProxyUnauthorized407Interceptor(channelManager, requestSender);
+    continue100Interceptor = new Continue100Interceptor(requestSender);
+    redirect30xInterceptor = new Redirect30xInterceptor(channelManager, config, requestSender);
+    connectSuccessInterceptor = new ConnectSuccessInterceptor(channelManager, requestSender);
+    responseFiltersInterceptor = new ResponseFiltersInterceptor(config, requestSender);
+    hasResponseFilters = !config.getResponseFilters().isEmpty();
+    cookieDecoder = config.isUseLaxCookieEncoder() ? ClientCookieDecoder.LAX : ClientCookieDecoder.STRICT;
+  }
 
-    public boolean exitAfterIntercept(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler,//
-            HttpResponse response,//
-            HttpResponseStatus status,//
-            HttpHeaders responseHeaders) throws Exception {
+  public boolean exitAfterIntercept(Channel channel,
+                                    NettyResponseFuture<?> future,
+                                    AsyncHandler<?> handler,
+                                    HttpResponse response,
+                                    HttpResponseStatus status,
+                                    HttpHeaders responseHeaders) throws Exception {
 
-        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-        ProxyServer proxyServer = future.getProxyServer();
-        int statusCode = response.status().code();
-        Request request = future.getCurrentRequest();
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+    HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+    ProxyServer proxyServer = future.getProxyServer();
+    int statusCode = response.status().code();
+    Request request = future.getCurrentRequest();
+    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
 
-        if (hasResponseFilters && responseFiltersInterceptor.exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
-            return true;
+    // This MUST BE called before Redirect30xInterceptor because latter assumes cookie store is already updated
+    CookieStore cookieStore = config.getCookieStore();
+    if (cookieStore != null) {
+      for (String cookieStr : responseHeaders.getAll(SET_COOKIE)) {
+        Cookie c = cookieDecoder.decode(cookieStr);
+        if (c != null) {
+          // Set-Cookie header could be invalid/malformed
+          cookieStore.add(future.getCurrentRequest().getUri(), c);
         }
+      }
+    }
+
+    if (hasResponseFilters && responseFiltersInterceptor.exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+      return true;
+    }
 
-        if (statusCode == UNAUTHORIZED_401) {
-            return unauthorized401Interceptor.exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer, httpRequest);
+    if (statusCode == UNAUTHORIZED_401) {
+      return unauthorized401Interceptor.exitAfterHandling401(channel, future, response, request, realm, httpRequest);
 
-        } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
-            return proxyUnauthorized407Interceptor.exitAfterHandling407(channel, future, response, request, statusCode, proxyServer, httpRequest);
+    } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
+      return proxyUnauthorized407Interceptor.exitAfterHandling407(channel, future, response, request, proxyServer, httpRequest);
 
-        } else if (statusCode == CONTINUE_100) {
-            return continue100Interceptor.exitAfterHandling100(channel, future, statusCode);
+    } else if (statusCode == CONTINUE_100) {
+      return continue100Interceptor.exitAfterHandling100(channel, future);
 
-        } else if (Redirect30xInterceptor.REDIRECT_STATUSES.contains(statusCode)) {
-            return redirect30xInterceptor.exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
+    } else if (Redirect30xInterceptor.REDIRECT_STATUSES.contains(statusCode)) {
+      return redirect30xInterceptor.exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
 
-        } else if (httpRequest.method() == HttpMethod.CONNECT && statusCode == OK_200) {
-            return connectSuccessInterceptor.exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest);
+    } else if (httpRequest.method() == HttpMethod.CONNECT && statusCode == OK_200) {
+      return connectSuccessInterceptor.exitAfterHandlingConnect(channel, future, request, proxyServer);
 
-        }
-        return false;
     }
+    return false;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
index 89ac2cf62..02ee19562 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
@@ -13,19 +13,8 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpUtil;
-
-import java.util.List;
-
+import io.netty.handler.codec.http.*;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
@@ -41,186 +30,194 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.NEGOTIATE;
+import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
+import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
+
 public class ProxyUnauthorized407Interceptor {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(ProxyUnauthorized407Interceptor.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(ProxyUnauthorized407Interceptor.class);
+
+  private final ChannelManager channelManager;
+  private final NettyRequestSender requestSender;
+
+  ProxyUnauthorized407Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+    this.channelManager = channelManager;
+    this.requestSender = requestSender;
+  }
 
-    private final ChannelManager channelManager;
-    private final NettyRequestSender requestSender;
+  public boolean exitAfterHandling407(Channel channel,
+                                      NettyResponseFuture<?> future,
+                                      HttpResponse response,
+                                      Request request,
+                                      ProxyServer proxyServer,
+                                      HttpRequest httpRequest) {
 
-    public ProxyUnauthorized407Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-        this.channelManager = channelManager;
-        this.requestSender = requestSender;
+    if (future.isAndSetInProxyAuth(true)) {
+      LOGGER.info("Can't handle 407 as auth was already performed");
+      return false;
     }
 
-    public boolean exitAfterHandling407(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            Request request,//
-            int statusCode,//
-            ProxyServer proxyServer,//
-            HttpRequest httpRequest) {
-
-        if (future.isAndSetInProxyAuth(true)) {
-            LOGGER.info("Can't handle 407 as auth was already performed");
-            return false;
-        }
+    Realm proxyRealm = future.getProxyRealm();
 
-        Realm proxyRealm = future.getProxyRealm();
+    if (proxyRealm == null) {
+      LOGGER.debug("Can't handle 407 as there's no proxyRealm");
+      return false;
+    }
 
-        if (proxyRealm == null) {
-            LOGGER.debug("Can't handle 407 as there's no proxyRealm");
-            return false;
-        }
+    List<String> proxyAuthHeaders = response.headers().getAll(PROXY_AUTHENTICATE);
+
+    if (proxyAuthHeaders.isEmpty()) {
+      LOGGER.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
+      return false;
+    }
 
-        List<String> proxyAuthHeaders = response.headers().getAll(PROXY_AUTHENTICATE);
+    // FIXME what's this???
+    future.setChannelState(ChannelState.NEW);
+    HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
 
-        if (proxyAuthHeaders.isEmpty()) {
-            LOGGER.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
-            return false;
+    switch (proxyRealm.getScheme()) {
+      case BASIC:
+        if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
+          LOGGER.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
+          return false;
         }
 
-        // FIXME what's this???
-        future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
-
-        switch (proxyRealm.getScheme()) {
-        case BASIC:
-            if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
-                LOGGER.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-
-            if (proxyRealm.isUsePreemptiveAuth()) {
-                // FIXME do we need this, as future.getAndSetAuth
-                // was tested above?
-                // auth was already performed, most likely auth
-                // failed
-                LOGGER.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
-                return false;
-            }
-
-            // FIXME do we want to update the realm, or directly
-            // set the header?
-            Realm newBasicRealm = realm(proxyRealm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setProxyRealm(newBasicRealm);
-            break;
-
-        case DIGEST:
-            String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
-            if (digestHeader == null) {
-                LOGGER.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            Realm newDigestRealm = realm(proxyRealm)//
-                    .setUri(request.getUri())//
-                    .setMethodName(request.getMethod())//
-                    .setUsePreemptiveAuth(true)//
-                    .parseProxyAuthenticateHeader(digestHeader)//
-                    .build();
-            future.setProxyRealm(newDigestRealm);
-            break;
-
-        case NTLM:
-            String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-            if (ntlmHeader == null) {
-                LOGGER.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            ntlmProxyChallenge(ntlmHeader, request, requestHeaders, proxyRealm, future);
-            Realm newNtlmRealm = realm(proxyRealm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setProxyRealm(newNtlmRealm);
-            break;
-
-        case KERBEROS:
-        case SPNEGO:
-            if (getHeaderWithPrefix(proxyAuthHeaders, NEGOTIATE) == null) {
-                LOGGER.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            try {
-                kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, proxyRealm, requestHeaders, future);
-
-            } catch (SpnegoEngineException e) {
-                // FIXME
-                String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-                if (ntlmHeader2 != null) {
-                    LOGGER.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
-                    ntlmProxyChallenge(ntlmHeader2, request, requestHeaders, proxyRealm, future);
-                    Realm newNtlmRealm2 = realm(proxyRealm)//
-                            .setScheme(AuthScheme.NTLM)//
-                            .setUsePreemptiveAuth(true)//
-                            .build();
-                    future.setProxyRealm(newNtlmRealm2);
-                } else {
-                    requestSender.abort(channel, future, e);
-                    return false;
-                }
-            }
-            break;
-        default:
-            throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
+        if (proxyRealm.isUsePreemptiveAuth()) {
+          // FIXME do we need this, as future.getAndSetAuth
+          // was tested above?
+          // auth was already performed, most likely auth
+          // failed
+          LOGGER.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
+          return false;
         }
 
-        RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
-        if (future.getCurrentRequest().getUri().isSecured()) {
-            nextRequestBuilder.setMethod(CONNECT);
+        // FIXME do we want to update the realm, or directly
+        // set the header?
+        Realm newBasicRealm = realm(proxyRealm)
+                .setUsePreemptiveAuth(true)
+                .build();
+        future.setProxyRealm(newBasicRealm);
+        break;
+
+      case DIGEST:
+        String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
+        if (digestHeader == null) {
+          LOGGER.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
+          return false;
         }
-        final Request nextRequest = nextRequestBuilder.build();
-
-        LOGGER.debug("Sending proxy authentication to {}", request.getUri());
-        if (future.isKeepAlive()//
-                && !HttpUtil.isTransferEncodingChunked(httpRequest)//
-                && !HttpUtil.isTransferEncodingChunked(response)) {
-            future.setConnectAllowed(true);
-            future.setReuseChannel(true);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-        } else {
-            channelManager.closeChannel(channel);
-            requestSender.sendNextRequest(nextRequest, future);
+        Realm newDigestRealm = realm(proxyRealm)
+                .setUri(request.getUri())
+                .setMethodName(request.getMethod())
+                .setUsePreemptiveAuth(true)
+                .parseProxyAuthenticateHeader(digestHeader)
+                .build();
+        future.setProxyRealm(newDigestRealm);
+        break;
+
+      case NTLM:
+        String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+        if (ntlmHeader == null) {
+          LOGGER.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
+          return false;
         }
-
-        return true;
+        ntlmProxyChallenge(ntlmHeader, requestHeaders, proxyRealm, future);
+        Realm newNtlmRealm = realm(proxyRealm)
+                .setUsePreemptiveAuth(true)
+                .build();
+        future.setProxyRealm(newNtlmRealm);
+        break;
+
+      case KERBEROS:
+      case SPNEGO:
+        if (getHeaderWithPrefix(proxyAuthHeaders, NEGOTIATE) == null) {
+          LOGGER.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
+          return false;
+        }
+        try {
+          kerberosProxyChallenge(proxyRealm, proxyServer, requestHeaders);
+
+        } catch (SpnegoEngineException e) {
+          // FIXME
+          String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+          if (ntlmHeader2 != null) {
+            LOGGER.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
+            ntlmProxyChallenge(ntlmHeader2, requestHeaders, proxyRealm, future);
+            Realm newNtlmRealm2 = realm(proxyRealm)
+                    .setScheme(AuthScheme.NTLM)
+                    .setUsePreemptiveAuth(true)
+                    .build();
+            future.setProxyRealm(newNtlmRealm2);
+          } else {
+            requestSender.abort(channel, future, e);
+            return false;
+          }
+        }
+        break;
+      default:
+        throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
     }
 
-    private void kerberosProxyChallenge(Channel channel,//
-            List<String> proxyAuth,//
-            Request request,//
-            ProxyServer proxyServer,//
-            Realm proxyRealm,//
-            HttpHeaders headers,//
-            NettyResponseFuture<?> future) throws SpnegoEngineException {
-
-        String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
-        headers.set(PROXY_AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+    RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
+    if (future.getCurrentRequest().getUri().isSecured()) {
+      nextRequestBuilder.setMethod(CONNECT);
+    }
+    final Request nextRequest = nextRequestBuilder.build();
+
+    LOGGER.debug("Sending proxy authentication to {}", request.getUri());
+    if (future.isKeepAlive()
+            && !HttpUtil.isTransferEncodingChunked(httpRequest)
+            && !HttpUtil.isTransferEncodingChunked(response)) {
+      future.setConnectAllowed(true);
+      future.setReuseChannel(true);
+      requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+    } else {
+      channelManager.closeChannel(channel);
+      requestSender.sendNextRequest(nextRequest, future);
     }
 
-    private void ntlmProxyChallenge(String authenticateHeader,//
-            Request request,//
-            HttpHeaders requestHeaders,//
-            Realm proxyRealm,//
-            NettyResponseFuture<?> future) {
-
-        if (authenticateHeader.equals("NTLM")) {
-            // server replied bare NTLM => we didn't preemptively sent Type1Msg
-            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-            future.setInProxyAuth(false);
-
-        } else {
-            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
-                    proxyRealm.getNtlmHost(), serverChallenge);
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-        }
+    return true;
+  }
+
+  private void kerberosProxyChallenge(Realm proxyRealm,
+                                      ProxyServer proxyServer,
+                                      HttpHeaders headers) throws SpnegoEngineException {
+
+    String challengeHeader = SpnegoEngine.instance(proxyRealm.getPrincipal(),
+        proxyRealm.getPassword(),
+        proxyRealm.getServicePrincipalName(),
+        proxyRealm.getRealmName(),
+        proxyRealm.isUseCanonicalHostname(),
+        proxyRealm.getCustomLoginConfig(),
+        proxyRealm.getLoginContextName()).generateToken(proxyServer.getHost());
+    headers.set(PROXY_AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+  }
+
+  private void ntlmProxyChallenge(String authenticateHeader,
+                                  HttpHeaders requestHeaders,
+                                  Realm proxyRealm,
+                                  NettyResponseFuture<?> future) {
+
+    if (authenticateHeader.equals("NTLM")) {
+      // server replied bare NTLM => we didn't preemptively sent Type1Msg
+      String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+      // FIXME we might want to filter current NTLM and add (leave other
+      // Authorization headers untouched)
+      requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+      future.setInProxyAuth(false);
+
+    } else {
+      String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+      String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
+              proxyRealm.getNtlmHost(), serverChallenge);
+      // FIXME we might want to filter current NTLM and add (leave other
+      // Authorization headers untouched)
+      requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index 907de704f..121bb7165 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -13,27 +13,17 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.util.HttpConstants.Methods.GET;
-import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
-import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
 import io.netty.handler.codec.http.cookie.Cookie;
-
-import java.util.HashSet;
-import java.util.Set;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.cookie.CookieStore;
 import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -42,146 +32,157 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
+import static org.asynchttpclient.util.HttpUtils.followRedirect;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+
 public class Redirect30xInterceptor {
 
-    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
-    static {
-        REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
-        REDIRECT_STATUSES.add(FOUND_302);
-        REDIRECT_STATUSES.add(SEE_OTHER_303);
-        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
-        REDIRECT_STATUSES.add(PERMANENT_REDIRECT_308);
-    }
+  public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
+  private static final Logger LOGGER = LoggerFactory.getLogger(Redirect30xInterceptor.class);
+
+  static {
+    REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
+    REDIRECT_STATUSES.add(FOUND_302);
+    REDIRECT_STATUSES.add(SEE_OTHER_303);
+    REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
+    REDIRECT_STATUSES.add(PERMANENT_REDIRECT_308);
+  }
+
+  private final ChannelManager channelManager;
+  private final AsyncHttpClientConfig config;
+  private final NettyRequestSender requestSender;
+  private final MaxRedirectException maxRedirectException;
+
+  Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+    this.channelManager = channelManager;
+    this.config = config;
+    this.requestSender = requestSender;
+    maxRedirectException = unknownStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()), Redirect30xInterceptor.class,
+            "exitAfterHandlingRedirect");
+  }
+
+  public boolean exitAfterHandlingRedirect(Channel channel,
+                                           NettyResponseFuture<?> future,
+                                           HttpResponse response,
+                                           Request request,
+                                           int statusCode,
+                                           Realm realm) throws Exception {
+
+    if (followRedirect(config, request)) {
+      if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
+        throw maxRedirectException;
+
+      } else {
+        // We must allow auth handling again.
+        future.setInAuth(false);
+        future.setInProxyAuth(false);
+
+        String originalMethod = request.getMethod();
+        boolean switchToGet = !originalMethod.equals(GET)
+                && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
+        boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || statusCode == PERMANENT_REDIRECT_308 || (statusCode == FOUND_302 && config.isStrict302Handling());
+
+        final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)
+                .setChannelPoolPartitioning(request.getChannelPoolPartitioning())
+                .setFollowRedirect(true)
+                .setLocalAddress(request.getLocalAddress())
+                .setNameResolver(request.getNameResolver())
+                .setProxyServer(request.getProxyServer())
+                .setRealm(request.getRealm())
+                .setRequestTimeout(request.getRequestTimeout());
+
+        if (keepBody) {
+          requestBuilder.setCharset(request.getCharset());
+          if (isNonEmpty(request.getFormParams()))
+            requestBuilder.setFormParams(request.getFormParams());
+          else if (request.getStringData() != null)
+            requestBuilder.setBody(request.getStringData());
+          else if (request.getByteData() != null)
+            requestBuilder.setBody(request.getByteData());
+          else if (request.getByteBufferData() != null)
+            requestBuilder.setBody(request.getByteBufferData());
+          else if (request.getBodyGenerator() != null)
+            requestBuilder.setBody(request.getBodyGenerator());
+        }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(Redirect30xInterceptor.class);
+        requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
 
-    private final ChannelManager channelManager;
-    private final AsyncHttpClientConfig config;
-    private final NettyRequestSender requestSender;
-    private final MaxRedirectException maxRedirectException;
+        // in case of a redirect from HTTP to HTTPS, future
+        // attributes might change
+        final boolean initialConnectionKeepAlive = future.isKeepAlive();
+        final Object initialPartitionKey = future.getPartitionKey();
 
-    public Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
-        this.channelManager = channelManager;
-        this.config = config;
-        this.requestSender = requestSender;
-        maxRedirectException = unknownStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()), Redirect30xInterceptor.class,
-                "exitAfterHandlingRedirect");
-    }
+        HttpHeaders responseHeaders = response.headers();
+        String location = responseHeaders.get(LOCATION);
+        Uri newUri = Uri.create(future.getUri(), location);
 
-    public boolean exitAfterHandlingRedirect(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            Request request,//
-            int statusCode,//
-            Realm realm) throws Exception {
-
-        if (followRedirect(config, request)) {
-            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
-                throw maxRedirectException;
-
-            } else {
-                // We must allow auth handling again.
-                future.setInAuth(false);
-                future.setInProxyAuth(false);
-
-                String originalMethod = request.getMethod();
-                boolean switchToGet = !originalMethod.equals(GET)
-                        && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
-                boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || statusCode == PERMANENT_REDIRECT_308 || (statusCode == FOUND_302 && config.isStrict302Handling());
-
-                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)//
-                        .setCookies(request.getCookies())//
-                        .setChannelPoolPartitioning(request.getChannelPoolPartitioning())//
-                        .setFollowRedirect(true)//
-                        .setLocalAddress(request.getLocalAddress())//
-                        .setNameResolver(request.getNameResolver())//
-                        .setProxyServer(request.getProxyServer())//
-                        .setRealm(request.getRealm())//
-                        .setRequestTimeout(request.getRequestTimeout());
-
-                if (keepBody) {
-                    requestBuilder.setCharset(request.getCharset());
-                    if (isNonEmpty(request.getFormParams()))
-                        requestBuilder.setFormParams(request.getFormParams());
-                    else if (request.getStringData() != null)
-                        requestBuilder.setBody(request.getStringData());
-                    else if (request.getByteData() != null)
-                        requestBuilder.setBody(request.getByteData());
-                    else if (request.getByteBufferData() != null)
-                        requestBuilder.setBody(request.getByteBufferData());
-                    else if (request.getBodyGenerator() != null)
-                        requestBuilder.setBody(request.getBodyGenerator());
-                }
-
-                requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
-
-                // in case of a redirect from HTTP to HTTPS, future
-                // attributes might change
-                final boolean initialConnectionKeepAlive = future.isKeepAlive();
-                final Object initialPartitionKey = future.getPartitionKey();
-
-                HttpHeaders responseHeaders = response.headers();
-                String location = responseHeaders.get(LOCATION);
-                Uri newUri = Uri.create(future.getUri(), location);
-
-                LOGGER.debug("Redirecting to {}", newUri);
-
-                for (String cookieStr : responseHeaders.getAll(SET_COOKIE)) {
-                    Cookie c = ClientCookieDecoder.STRICT.decode(cookieStr);
-                    if (c != null)
-                        requestBuilder.addOrReplaceCookie(c);
-                }
-
-                boolean sameBase = isSameBase(request.getUri(), newUri);
-
-                if (sameBase) {
-                    // we can only assume the virtual host is still valid if the baseUrl is the same
-                    requestBuilder.setVirtualHost(request.getVirtualHost());
-                }
-
-                final Request nextRequest = requestBuilder.setUri(newUri).build();
-                future.setTargetRequest(nextRequest);
-
-                LOGGER.debug("Sending redirect to {}", newUri);
-
-                if (future.isKeepAlive() && !HttpUtil.isTransferEncodingChunked(response)) {
-
-                    if (sameBase) {
-                        future.setReuseChannel(true);
-                        // we can't directly send the next request because we still have to received LastContent
-                        requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-                    } else {
-                        channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
-                        requestSender.sendNextRequest(nextRequest, future);
-                    }
-
-                } else {
-                    // redirect + chunking = WAT
-                    channelManager.closeChannel(channel);
-                    requestSender.sendNextRequest(nextRequest, future);
-                }
-
-                return true;
-            }
-        }
-        return false;
-    }
+        LOGGER.debug("Redirecting to {}", newUri);
 
-    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
+        CookieStore cookieStore = config.getCookieStore();
+        if (cookieStore != null) {
+          // Update request's cookies assuming that cookie store is already updated by Interceptors
+          List<Cookie> cookies = cookieStore.get(newUri);
+          if (!cookies.isEmpty())
+            for (Cookie cookie : cookies)
+              requestBuilder.addOrReplaceCookie(cookie);
+        }
 
-        HttpHeaders headers = request.getHeaders()//
-                .remove(HOST)//
-                .remove(CONTENT_LENGTH);
+        boolean sameBase = request.getUri().isSameBase(newUri);
 
-        if (!keepBody) {
-            headers.remove(CONTENT_TYPE);
+        if (sameBase) {
+          // we can only assume the virtual host is still valid if the baseUrl is the same
+          requestBuilder.setVirtualHost(request.getVirtualHost());
         }
 
-        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
-            headers.remove(AUTHORIZATION)//
-                    .remove(PROXY_AUTHORIZATION);
+        final Request nextRequest = requestBuilder.setUri(newUri).build();
+        future.setTargetRequest(nextRequest);
+
+        LOGGER.debug("Sending redirect to {}", newUri);
+
+        if (future.isKeepAlive() && !HttpUtil.isTransferEncodingChunked(response)) {
+          if (sameBase) {
+            future.setReuseChannel(true);
+            // we can't directly send the next request because we still have to received LastContent
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+          } else {
+            channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
+            requestSender.sendNextRequest(nextRequest, future);
+          }
+
+        } else {
+          // redirect + chunking = WAT
+          channelManager.closeChannel(channel);
+          requestSender.sendNextRequest(nextRequest, future);
         }
-        return headers;
+
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
+
+    HttpHeaders headers = request.getHeaders()
+            .remove(HOST)
+            .remove(CONTENT_LENGTH);
+
+    if (!keepBody) {
+      headers.remove(CONTENT_TYPE);
+    }
+
+    if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
+      headers.remove(AUTHORIZATION)
+              .remove(PROXY_AUTHORIZATION);
     }
+    return headers;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
index 8d449476a..7e4625a06 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
@@ -13,10 +13,8 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseStatus;
@@ -26,45 +24,46 @@
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 public class ResponseFiltersInterceptor {
 
-    private final AsyncHttpClientConfig config;
-    private final NettyRequestSender requestSender;
+  private final AsyncHttpClientConfig config;
+  private final NettyRequestSender requestSender;
 
-    public ResponseFiltersInterceptor(AsyncHttpClientConfig config, NettyRequestSender requestSender) {
-        this.config = config;
-        this.requestSender = requestSender;
-    }
+  ResponseFiltersInterceptor(AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+    this.config = config;
+    this.requestSender = requestSender;
+  }
 
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    public boolean exitAfterProcessingFilters(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler, //
-            HttpResponseStatus status,//
-            HttpHeaders responseHeaders) {
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public boolean exitAfterProcessingFilters(Channel channel,
+                                            NettyResponseFuture<?> future,
+                                            AsyncHandler<?> handler,
+                                            HttpResponseStatus status,
+                                            HttpHeaders responseHeaders) {
 
-        FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status)
-                .responseHeaders(responseHeaders).build();
+    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status)
+            .responseHeaders(responseHeaders).build();
 
-        for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                // FIXME Is it worth protecting against this?
-                assertNotNull("fc", "filterContext");
-            } catch (FilterException efe) {
-                requestSender.abort(channel, future, efe);
-            }
-        }
+    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+      try {
+        fc = asyncFilter.filter(fc);
+        // FIXME Is it worth protecting against this?
+        assertNotNull("fc", "filterContext");
+      } catch (FilterException fe) {
+        requestSender.abort(channel, future, fe);
+      }
+    }
 
-        // The handler may have been wrapped.
-        future.setAsyncHandler(fc.getAsyncHandler());
+    // The handler may have been wrapped.
+    future.setAsyncHandler(fc.getAsyncHandler());
 
-        // The request has changed
-        if (fc.replayRequest()) {
-            requestSender.replayRequest(future, fc, channel);
-            return true;
-        }
-        return false;
+    // The request has changed
+    if (fc.replayRequest()) {
+      requestSender.replayRequest(future, fc, channel);
+      return true;
     }
+    return false;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
index 6936ad9a6..30ba1bc3d 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
@@ -13,19 +13,8 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.MiscUtils.withDefault;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpUtil;
-
-import java.util.List;
-
+import io.netty.handler.codec.http.*;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
@@ -35,188 +24,195 @@
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.ntlm.NtlmEngine;
-import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.spnego.SpnegoEngine;
 import org.asynchttpclient.spnego.SpnegoEngineException;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
+import static io.netty.handler.codec.http.HttpHeaderNames.WWW_AUTHENTICATE;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.NEGOTIATE;
+import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
 public class Unauthorized401Interceptor {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(Unauthorized401Interceptor.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(Unauthorized401Interceptor.class);
+
+  private final ChannelManager channelManager;
+  private final NettyRequestSender requestSender;
+
+  Unauthorized401Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+    this.channelManager = channelManager;
+    this.requestSender = requestSender;
+  }
 
-    private final ChannelManager channelManager;
-    private final NettyRequestSender requestSender;
+  public boolean exitAfterHandling401(final Channel channel,
+                                      final NettyResponseFuture<?> future,
+                                      HttpResponse response,
+                                      final Request request,
+                                      Realm realm,
+                                      HttpRequest httpRequest) {
 
-    public Unauthorized401Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-        this.channelManager = channelManager;
-        this.requestSender = requestSender;
+    if (realm == null) {
+      LOGGER.debug("Can't handle 401 as there's no realm");
+      return false;
     }
 
-    public boolean exitAfterHandling401(//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            final Request request,//
-            int statusCode,//
-            Realm realm,//
-            ProxyServer proxyServer,//
-            HttpRequest httpRequest) {
-
-        if (realm == null) {
-            LOGGER.debug("Can't handle 401 as there's no realm");
-            return false;
-        }
+    if (future.isAndSetInAuth(true)) {
+      LOGGER.info("Can't handle 401 as auth was already performed");
+      return false;
+    }
 
-        if (future.isAndSetInAuth(true)) {
-            LOGGER.info("Can't handle 401 as auth was already performed");
-            return false;
-        }
+    List<String> wwwAuthHeaders = response.headers().getAll(WWW_AUTHENTICATE);
 
-        List<String> wwwAuthHeaders = response.headers().getAll(WWW_AUTHENTICATE);
+    if (wwwAuthHeaders.isEmpty()) {
+      LOGGER.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
+      return false;
+    }
 
-        if (wwwAuthHeaders.isEmpty()) {
-            LOGGER.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
-            return false;
+    // FIXME what's this???
+    future.setChannelState(ChannelState.NEW);
+    HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+
+    switch (realm.getScheme()) {
+      case BASIC:
+        if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
+          LOGGER.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
+          return false;
         }
 
-        // FIXME what's this???
-        future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
-
-        switch (realm.getScheme()) {
-        case BASIC:
-            if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
-                LOGGER.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-
-            if (realm.isUsePreemptiveAuth()) {
-                // FIXME do we need this, as future.getAndSetAuth
-                // was tested above?
-                // auth was already performed, most likely auth
-                // failed
-                LOGGER.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
-                return false;
-            }
-
-            // FIXME do we want to update the realm, or directly
-            // set the header?
-            Realm newBasicRealm = realm(realm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setRealm(newBasicRealm);
-            break;
-
-        case DIGEST:
-            String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
-            if (digestHeader == null) {
-                LOGGER.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-            Realm newDigestRealm = realm(realm)//
-                    .setUri(request.getUri())//
-                    .setMethodName(request.getMethod())//
-                    .setUsePreemptiveAuth(true)//
-                    .parseWWWAuthenticateHeader(digestHeader)//
-                    .build();
-            future.setRealm(newDigestRealm);
-            break;
-
-        case NTLM:
-            String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-            if (ntlmHeader == null) {
-                LOGGER.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-
-            ntlmChallenge(ntlmHeader, request, requestHeaders, realm, future);
-            Realm newNtlmRealm = realm(realm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setRealm(newNtlmRealm);
-            break;
-
-        case KERBEROS:
-        case SPNEGO:
-            if (getHeaderWithPrefix(wwwAuthHeaders, NEGOTIATE) == null) {
-                LOGGER.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-            try {
-                kerberosChallenge(channel, wwwAuthHeaders, request, requestHeaders, realm, future);
-
-            } catch (SpnegoEngineException e) {
-                // FIXME
-                String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-                if (ntlmHeader2 != null) {
-                    LOGGER.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
-                    ntlmChallenge(ntlmHeader2, request, requestHeaders, realm, future);
-                    Realm newNtlmRealm2 = realm(realm)//
-                            .setScheme(AuthScheme.NTLM)//
-                            .setUsePreemptiveAuth(true)//
-                            .build();
-                    future.setRealm(newNtlmRealm2);
-                } else {
-                    requestSender.abort(channel, future, e);
-                    return false;
-                }
-            }
-            break;
-        default:
-            throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
+        if (realm.isUsePreemptiveAuth()) {
+          // FIXME do we need this, as future.getAndSetAuth
+          // was tested above?
+          // auth was already performed, most likely auth
+          // failed
+          LOGGER.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
+          return false;
         }
 
-        final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
-
-        LOGGER.debug("Sending authentication to {}", request.getUri());
-        if (future.isKeepAlive()//
-                && !HttpUtil.isTransferEncodingChunked(httpRequest)//
-                && !HttpUtil.isTransferEncodingChunked(response)) {
-            future.setReuseChannel(true);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-        } else {
-            channelManager.closeChannel(channel);
-            requestSender.sendNextRequest(nextRequest, future);
+        // FIXME do we want to update the realm, or directly
+        // set the header?
+        Realm newBasicRealm = realm(realm)
+                .setUsePreemptiveAuth(true)
+                .build();
+        future.setRealm(newBasicRealm);
+        break;
+
+      case DIGEST:
+        String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
+        if (digestHeader == null) {
+          LOGGER.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
+          return false;
+        }
+        Realm newDigestRealm = realm(realm)
+                .setUri(request.getUri())
+                .setMethodName(request.getMethod())
+                .setUsePreemptiveAuth(true)
+                .parseWWWAuthenticateHeader(digestHeader)
+                .build();
+        future.setRealm(newDigestRealm);
+        break;
+
+      case NTLM:
+        String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+        if (ntlmHeader == null) {
+          LOGGER.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
+          return false;
         }
 
-        return true;
+        ntlmChallenge(ntlmHeader, requestHeaders, realm, future);
+        Realm newNtlmRealm = realm(realm)
+                .setUsePreemptiveAuth(true)
+                .build();
+        future.setRealm(newNtlmRealm);
+        break;
+
+      case KERBEROS:
+      case SPNEGO:
+        if (getHeaderWithPrefix(wwwAuthHeaders, NEGOTIATE) == null) {
+          LOGGER.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
+          return false;
+        }
+        try {
+          kerberosChallenge(realm, request, requestHeaders);
+
+        } catch (SpnegoEngineException e) {
+          // FIXME
+          String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+          if (ntlmHeader2 != null) {
+            LOGGER.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
+            ntlmChallenge(ntlmHeader2, requestHeaders, realm, future);
+            Realm newNtlmRealm2 = realm(realm)
+                    .setScheme(AuthScheme.NTLM)
+                    .setUsePreemptiveAuth(true)
+                    .build();
+            future.setRealm(newNtlmRealm2);
+          } else {
+            requestSender.abort(channel, future, e);
+            return false;
+          }
+        }
+        break;
+      default:
+        throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
     }
 
-    private void ntlmChallenge(String authenticateHeader,//
-            Request request,//
-            HttpHeaders requestHeaders,//
-            Realm realm,//
-            NettyResponseFuture<?> future) {
-
-        if (authenticateHeader.equals("NTLM")) {
-            // server replied bare NTLM => we didn't preemptively sent Type1Msg
-            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
-            future.setInAuth(false);
-
-        } else {
-            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
-        }
+    final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
+
+    LOGGER.debug("Sending authentication to {}", request.getUri());
+    if (future.isKeepAlive()
+            && !HttpUtil.isTransferEncodingChunked(httpRequest)
+            && !HttpUtil.isTransferEncodingChunked(response)) {
+      future.setReuseChannel(true);
+      requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+    } else {
+      channelManager.closeChannel(channel);
+      requestSender.sendNextRequest(nextRequest, future);
     }
 
-    private void kerberosChallenge(Channel channel,//
-            List<String> authHeaders,//
-            Request request,//
-            HttpHeaders headers,//
-            Realm realm,//
-            NettyResponseFuture<?> future) throws SpnegoEngineException {
-
-        Uri uri = request.getUri();
-        String host = withDefault(request.getVirtualHost(), uri.getHost());
-        String challengeHeader = SpnegoEngine.instance().generateToken(host);
-        headers.set(AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+    return true;
+  }
+
+  private void ntlmChallenge(String authenticateHeader,
+                             HttpHeaders requestHeaders,
+                             Realm realm,
+                             NettyResponseFuture<?> future) {
+
+    if (authenticateHeader.equals("NTLM")) {
+      // server replied bare NTLM => we didn't preemptively sent Type1Msg
+      String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+      // FIXME we might want to filter current NTLM and add (leave other
+      // Authorization headers untouched)
+      requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
+      future.setInAuth(false);
+
+    } else {
+      String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+      String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
+      // FIXME we might want to filter current NTLM and add (leave other
+      // Authorization headers untouched)
+      requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
     }
+  }
+
+  private void kerberosChallenge(Realm realm,
+                                 Request request,
+                                 HttpHeaders headers) throws SpnegoEngineException {
+
+    Uri uri = request.getUri();
+    String host = withDefault(request.getVirtualHost(), uri.getHost());
+    String challengeHeader = SpnegoEngine.instance(realm.getPrincipal(),
+        realm.getPassword(),
+        realm.getServicePrincipalName(),
+        realm.getRealmName(),
+        realm.isUseCanonicalHostname(),
+        realm.getCustomLoginConfig(),
+        realm.getLoginContextName()).generateToken(host);
+    headers.set(AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
deleted file mode 100644
index 1bccecec4..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty.request;
-
-import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
-import io.netty.bootstrap.Bootstrap;
-import io.netty.channel.Channel;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.util.List;
-import java.util.concurrent.RejectedExecutionException;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpClientState;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.netty.SimpleChannelFutureListener;
-import org.asynchttpclient.netty.channel.NettyConnectListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class NettyChannelConnector {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyChannelConnector.class);
-
-    private final AsyncHandlerExtensions asyncHandlerExtensions;
-    private final InetSocketAddress localAddress;
-    private final List<InetSocketAddress> remoteAddresses;
-    private final AsyncHttpClientState clientState;
-    private volatile int i = 0;
-
-    public NettyChannelConnector(InetAddress localAddress,//
-            List<InetSocketAddress> remoteAddresses,//
-            AsyncHandler<?> asyncHandler,//
-            AsyncHttpClientState clientState,//
-            AsyncHttpClientConfig config) {
-        this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
-        this.remoteAddresses = remoteAddresses;
-        this.asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
-        this.clientState = clientState;
-    }
-
-    private boolean pickNextRemoteAddress() {
-        i++;
-        return i < remoteAddresses.size();
-    }
-
-    public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
-        final InetSocketAddress remoteAddress = remoteAddresses.get(i);
-
-        if (asyncHandlerExtensions != null) {
-            try {
-                asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);
-            } catch (Exception e) {
-                LOGGER.error("onTcpConnectAttempt crashed", e);
-                connectListener.onFailure(null, e);
-                return;
-            }
-        }
-
-        try {
-            connect0(bootstrap, connectListener, remoteAddress);
-        } catch (RejectedExecutionException e) {
-            if (clientState.isClosed()) {
-                LOGGER.info("Connect crash but engine is shutting down");
-            } else {
-                connectListener.onFailure(null, e);
-            }
-        }
-    }
-
-    private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {
-
-        bootstrap.connect(remoteAddress, localAddress)//
-                .addListener(new SimpleChannelFutureListener() {
-                    @Override
-                    public void onSuccess(Channel channel) {
-                        if (asyncHandlerExtensions != null) {
-                            try {
-                                asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);
-                            } catch (Exception e) {
-                                LOGGER.error("onTcpConnectSuccess crashed", e);
-                                connectListener.onFailure(channel, e);
-                                return;
-                            }
-                        }
-                        connectListener.onSuccess(channel, remoteAddress);
-                    }
-
-                    @Override
-                    public void onFailure(Channel channel, Throwable t) {
-                        if (asyncHandlerExtensions != null) {
-                            try {
-                                asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);
-                            } catch (Exception e) {
-                                LOGGER.error("onTcpConnectFailure crashed", e);
-                                connectListener.onFailure(channel, e);
-                                return;
-                            }
-                        }
-                        boolean retry = pickNextRemoteAddress();
-                        if (retry) {
-                            NettyChannelConnector.this.connect(bootstrap, connectListener);
-                        } else {
-                            connectListener.onFailure(channel, t);
-                        }
-                    }
-                });
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
index 65c067b4c..186350157 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
@@ -13,25 +13,24 @@
  */
 package org.asynchttpclient.netty.request;
 
-import org.asynchttpclient.netty.request.body.NettyBody;
-
 import io.netty.handler.codec.http.HttpRequest;
+import org.asynchttpclient.netty.request.body.NettyBody;
 
 public final class NettyRequest {
 
-    private final HttpRequest httpRequest;
-    private final NettyBody body;
+  private final HttpRequest httpRequest;
+  private final NettyBody body;
 
-    public NettyRequest(HttpRequest httpRequest, NettyBody body) {
-        this.httpRequest = httpRequest;
-        this.body = body;
-    }
+  NettyRequest(HttpRequest httpRequest, NettyBody body) {
+    this.httpRequest = httpRequest;
+    this.body = body;
+  }
 
-    public HttpRequest getHttpRequest() {
-        return httpRequest;
-    }
+  public HttpRequest getHttpRequest() {
+    return httpRequest;
+  }
 
-    public NettyBody getBody() {
-        return body;
-    }
+  public NettyBody getBody() {
+    return body;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 881eb13ee..663ced6ce 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -13,37 +13,14 @@
  */
 package org.asynchttpclient.netty.request;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.*;
-import static org.asynchttpclient.ws.WebSocketUtils.getWebSocketKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.DefaultHttpRequest;
-import io.netty.handler.codec.http.HttpHeaderValues;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.*;
 import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
-
-import java.nio.charset.Charset;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.netty.request.body.NettyBody;
-import org.asynchttpclient.netty.request.body.NettyBodyBody;
-import org.asynchttpclient.netty.request.body.NettyByteArrayBody;
-import org.asynchttpclient.netty.request.body.NettyByteBufferBody;
-import org.asynchttpclient.netty.request.body.NettyCompositeByteArrayBody;
-import org.asynchttpclient.netty.request.body.NettyDirectBody;
-import org.asynchttpclient.netty.request.body.NettyFileBody;
-import org.asynchttpclient.netty.request.body.NettyInputStreamBody;
-import org.asynchttpclient.netty.request.body.NettyMultipartBody;
-import org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody;
+import org.asynchttpclient.netty.request.body.*;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.FileBodyGenerator;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
@@ -51,208 +28,216 @@
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.StringUtils;
 
-public final class NettyRequestFactory {
+import java.nio.charset.Charset;
 
-    public static final String BROTLY_ACCEPT_ENCODING_SUFFIX = ", br";
-    public static final String GZIP_DEFLATE = HttpHeaderValues.GZIP + "," + HttpHeaderValues.DEFLATE;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.ws.WebSocketUtils.getWebSocketKey;
 
-    private final AsyncHttpClientConfig config;
-    private final ClientCookieEncoder cookieEncoder;
+public final class NettyRequestFactory {
 
-    public NettyRequestFactory(AsyncHttpClientConfig config) {
-        this.config = config;
-        cookieEncoder = config.isUseLaxCookieEncoder() ? ClientCookieEncoder.LAX : ClientCookieEncoder.STRICT;
-    }
+  private static final Integer ZERO_CONTENT_LENGTH = 0;
 
-    private NettyBody body(Request request) {
-        NettyBody nettyBody = null;
-        Charset bodyCharset = withDefault(request.getCharset(), DEFAULT_CHARSET);
+  private final AsyncHttpClientConfig config;
+  private final ClientCookieEncoder cookieEncoder;
 
-        if (request.getByteData() != null) {
-            nettyBody = new NettyByteArrayBody(request.getByteData());
+  NettyRequestFactory(AsyncHttpClientConfig config) {
+    this.config = config;
+    cookieEncoder = config.isUseLaxCookieEncoder() ? ClientCookieEncoder.LAX : ClientCookieEncoder.STRICT;
+  }
 
-        } else if (request.getCompositeByteData() != null) {
-            nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
+  private NettyBody body(Request request) {
+    NettyBody nettyBody = null;
+    Charset bodyCharset = request.getCharset();
 
-        } else if (request.getStringData() != null) {
-            nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
+    if (request.getByteData() != null) {
+      nettyBody = new NettyByteArrayBody(request.getByteData());
 
-        } else if (request.getByteBufferData() != null) {
-            nettyBody = new NettyByteBufferBody(request.getByteBufferData());
+    } else if (request.getCompositeByteData() != null) {
+      nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
 
-        } else if (request.getStreamData() != null) {
-            nettyBody = new NettyInputStreamBody(request.getStreamData());
+    } else if (request.getStringData() != null) {
+      nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
 
-        } else if (isNonEmpty(request.getFormParams())) {
-            CharSequence contentTypeOverride = request.getHeaders().contains(CONTENT_TYPE) ? null : HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED;
-            nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentTypeOverride);
+    } else if (request.getByteBufferData() != null) {
+      nettyBody = new NettyByteBufferBody(request.getByteBufferData());
 
-        } else if (isNonEmpty(request.getBodyParts())) {
-            nettyBody = new NettyMultipartBody(request.getBodyParts(), request.getHeaders(), config);
+    } else if (request.getStreamData() != null) {
+      nettyBody = new NettyInputStreamBody(request.getStreamData());
 
-        } else if (request.getFile() != null) {
-            nettyBody = new NettyFileBody(request.getFile(), config);
+    } else if (isNonEmpty(request.getFormParams())) {
+      CharSequence contentTypeOverride = request.getHeaders().contains(CONTENT_TYPE) ? null : HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED;
+      nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentTypeOverride);
 
-        } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
-            FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
-            nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
+    } else if (isNonEmpty(request.getBodyParts())) {
+      nettyBody = new NettyMultipartBody(request.getBodyParts(), request.getHeaders(), config);
 
-        } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
-            InputStreamBodyGenerator inStreamGenerator = InputStreamBodyGenerator.class.cast(request.getBodyGenerator());
-            nettyBody = new NettyInputStreamBody(inStreamGenerator.getInputStream(), inStreamGenerator.getContentLength());
+    } else if (request.getFile() != null) {
+      nettyBody = new NettyFileBody(request.getFile(), config);
 
-        } else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator) {
-            ReactiveStreamsBodyGenerator reactiveStreamsBodyGenerator = (ReactiveStreamsBodyGenerator) request.getBodyGenerator();
-            nettyBody = new NettyReactiveStreamsBody(reactiveStreamsBodyGenerator.getPublisher(), reactiveStreamsBodyGenerator.getContentLength());
+    } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
+      FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
+      nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
 
-        } else if (request.getBodyGenerator() != null) {
-            nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
-        }
+    } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
+      InputStreamBodyGenerator inStreamGenerator = InputStreamBodyGenerator.class.cast(request.getBodyGenerator());
+      nettyBody = new NettyInputStreamBody(inStreamGenerator.getInputStream(), inStreamGenerator.getContentLength());
 
-        return nettyBody;
-    }
+    } else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator) {
+      ReactiveStreamsBodyGenerator reactiveStreamsBodyGenerator = (ReactiveStreamsBodyGenerator) request.getBodyGenerator();
+      nettyBody = new NettyReactiveStreamsBody(reactiveStreamsBodyGenerator.getPublisher(), reactiveStreamsBodyGenerator.getContentLength());
 
-    public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
-        if (authorizationHeader != null)
-            // don't override authorization but append
-            headers.add(AUTHORIZATION, authorizationHeader);
+    } else if (request.getBodyGenerator() != null) {
+      nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
     }
 
-    public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
-        if (proxyAuthorizationHeader != null)
-            headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
-    }
+    return nettyBody;
+  }
 
-    public NettyRequest newNettyRequest(Request request, boolean forceConnect, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
+  public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
+    if (authorizationHeader != null)
+      // don't override authorization but append
+      headers.add(AUTHORIZATION, authorizationHeader);
+  }
 
-        Uri uri = request.getUri();
-        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
-        boolean connect = method == HttpMethod.CONNECT;
+  public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
+    if (proxyAuthorizationHeader != null)
+      headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
+  }
 
-        HttpVersion httpVersion = HttpVersion.HTTP_1_1;
-        String requestUri = requestUri(uri, proxyServer, connect);
+  public NettyRequest newNettyRequest(Request request, boolean performConnectRequest, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
 
-        NettyBody body = connect ? null : body(request);
+    Uri uri = request.getUri();
+    HttpMethod method = performConnectRequest ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+    boolean connect = method == HttpMethod.CONNECT;
 
-        NettyRequest nettyRequest;
-        if (body == null) {
-            HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.EMPTY_BUFFER);
-            nettyRequest = new NettyRequest(httpRequest, null);
+    HttpVersion httpVersion = HttpVersion.HTTP_1_1;
+    String requestUri = requestUri(uri, proxyServer, connect);
 
-        } else if (body instanceof NettyDirectBody) {
-            ByteBuf buf = NettyDirectBody.class.cast(body).byteBuf();
-            HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, buf);
-            // body is passed as null as it's written directly with the request
-            nettyRequest = new NettyRequest(httpRequest, null);
+    NettyBody body = connect ? null : body(request);
 
-        } else {
-            HttpRequest httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
-            nettyRequest = new NettyRequest(httpRequest, body);
-        }
+    NettyRequest nettyRequest;
+    if (body == null) {
+      HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.EMPTY_BUFFER);
+      nettyRequest = new NettyRequest(httpRequest, null);
 
-        HttpHeaders headers = nettyRequest.getHttpRequest().headers();
+    } else if (body instanceof NettyDirectBody) {
+      ByteBuf buf = NettyDirectBody.class.cast(body).byteBuf();
+      HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, buf);
+      // body is passed as null as it's written directly with the request
+      nettyRequest = new NettyRequest(httpRequest, null);
 
-        if (connect) {
-            // assign proxy-auth as configured on request
-            headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
+    } else {
+      HttpRequest httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+      nettyRequest = new NettyRequest(httpRequest, body);
+    }
 
-        } else {
-            // assign headers as configured on request
-            headers.set(request.getHeaders());
-
-            if (isNonEmpty(request.getCookies())) {
-                headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
-            }
-
-            String userDefinedAcceptEncoding = headers.get(ACCEPT_ENCODING);
-            if (userDefinedAcceptEncoding != null) {
-                // we don't support Brotly ATM
-                if (userDefinedAcceptEncoding.endsWith(BROTLY_ACCEPT_ENCODING_SUFFIX)) {
-                    headers.set(ACCEPT_ENCODING, userDefinedAcceptEncoding.subSequence(0, userDefinedAcceptEncoding.length() - BROTLY_ACCEPT_ENCODING_SUFFIX.length()));
-                }
-
-            } else if (config.isCompressionEnforced()) {
-                headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
-            }
-        }
+    HttpHeaders headers = nettyRequest.getHttpRequest().headers();
 
-        if (body != null) {
-            if (!headers.contains(CONTENT_LENGTH)) {
-                if (body.getContentLength() < 0) {
-                    headers.set(TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-                } else {
-                    headers.set(CONTENT_LENGTH, body.getContentLength());
-                }
-            }
-
-            if (body.getContentTypeOverride() != null) {
-                headers.set(CONTENT_TYPE, body.getContentTypeOverride());
-            }
-        }
+    if (connect) {
+      // assign proxy-auth as configured on request
+      headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
 
-        // connection header and friends
-        if (!connect && uri.isWebSocket()) {
-            headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)//
-                    .set(CONNECTION, HttpHeaderValues.UPGRADE)//
-                    .set(SEC_WEBSOCKET_KEY, getWebSocketKey())//
-                    .set(SEC_WEBSOCKET_VERSION, "13");
-
-            if (!headers.contains(ORIGIN)) {
-                headers.set(ORIGIN, computeOriginHeader(uri));
-            }
-
-        } else if (!headers.contains(CONNECTION)) {
-            CharSequence connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
-            if (connectionHeaderValue != null) {
-                headers.set(CONNECTION, connectionHeaderValue);
-            }
-        }
+    } else {
+      // assign headers as configured on request
+      headers.set(request.getHeaders());
 
-        if (!headers.contains(HOST)) {
-            headers.set(HOST, hostHeader(request, uri));
-        }
+      if (isNonEmpty(request.getCookies())) {
+        headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
+      }
 
-        // don't override authorization but append
-        addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
-        // only set proxy auth on request over plain HTTP, or when performing CONNECT
-        if (!uri.isSecured() || connect) {
-            setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyRealm));
-        }
+      String userDefinedAcceptEncoding = headers.get(ACCEPT_ENCODING);
+      if (userDefinedAcceptEncoding != null) {
+        // we don't support Brotly ATM
+        headers.set(ACCEPT_ENCODING, filterOutBrotliFromAcceptEncoding(userDefinedAcceptEncoding));
 
-        // Add default accept headers
-        if (!headers.contains(ACCEPT)) {
-            headers.set(ACCEPT, "*/*");
-        }
+      } else if (config.isCompressionEnforced()) {
+        headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
+      }
+    }
 
-        // Add default user agent
-        if (!headers.contains(USER_AGENT) && config.getUserAgent() != null) {
-            headers.set(USER_AGENT, config.getUserAgent());
+    if (!headers.contains(CONTENT_LENGTH)) {
+      if (body != null) {
+        if (body.getContentLength() < 0) {
+          headers.set(TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
+        } else {
+          headers.set(CONTENT_LENGTH, body.getContentLength());
         }
+      } else if (method == HttpMethod.POST || method == HttpMethod.PUT || method == HttpMethod.PATCH) {
+        headers.set(CONTENT_LENGTH, ZERO_CONTENT_LENGTH);
+      }
+    }
 
-        return nettyRequest;
+    if (body != null && body.getContentTypeOverride() != null) {
+      headers.set(CONTENT_TYPE, body.getContentTypeOverride());
     }
 
-    private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
-        if (connect) {
-            // proxy tunnelling, connect need host and explicit port
-            return getAuthority(uri);
+    // connection header and friends
+    if (!connect && uri.isWebSocket()) {
+      headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)
+              .set(CONNECTION, HttpHeaderValues.UPGRADE)
+              .set(SEC_WEBSOCKET_KEY, getWebSocketKey())
+              .set(SEC_WEBSOCKET_VERSION, "13");
+
+      if (!headers.contains(ORIGIN)) {
+        headers.set(ORIGIN, originHeader(uri));
+      }
+
+    } else if (!headers.contains(CONNECTION)) {
+      CharSequence connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
+      if (connectionHeaderValue != null) {
+        headers.set(CONNECTION, connectionHeaderValue);
+      }
+    }
 
-        } else if (proxyServer != null && !uri.isSecured()) {
-            // proxy over HTTP, need full url
-            return uri.toUrl();
+    if (!headers.contains(HOST)) {
+      String virtualHost = request.getVirtualHost();
+      headers.set(HOST, virtualHost != null ? virtualHost : hostHeader(uri));
+    }
 
-        } else {
-            // direct connection to target host or tunnel already connected: only path and query
-            String path = getNonEmptyPath(uri);
-            return isNonEmpty(uri.getQuery()) ? path + "?" + uri.getQuery() : path;
-        }
+    // don't override authorization but append
+    addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
+    // only set proxy auth on request over plain HTTP, or when performing CONNECT
+    if (!uri.isSecured() || connect) {
+      setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyRealm));
     }
 
-    private CharSequence connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
-        if (httpVersion.isKeepAliveDefault()) {
-            return keepAlive ? null : HttpHeaderValues.CLOSE;
-        } else {
-            return keepAlive ? HttpHeaderValues.KEEP_ALIVE : null;
-        }
+    // Add default accept headers
+    if (!headers.contains(ACCEPT)) {
+      headers.set(ACCEPT, ACCEPT_ALL_HEADER_VALUE);
+    }
+
+    // Add default user agent
+    if (!headers.contains(USER_AGENT) && config.getUserAgent() != null) {
+      headers.set(USER_AGENT, config.getUserAgent());
+    }
+
+    return nettyRequest;
+  }
+
+  private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
+    if (connect) {
+      // proxy tunnelling, connect need host and explicit port
+      return uri.getAuthority();
+
+    } else if (proxyServer != null && !uri.isSecured() && proxyServer.getProxyType().isHttp()) {
+      // proxy over HTTP, need full url
+      return uri.toUrl();
+
+    } else {
+      // direct connection to target host or tunnel already connected: only path and query
+      return uri.toRelativeUrl();
+    }
+  }
+
+  private CharSequence connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
+    if (httpVersion.isKeepAliveDefault()) {
+      return keepAlive ? null : HttpHeaderValues.CLOSE;
+    } else {
+      return keepAlive ? HttpHeaderValues.KEEP_ALIVE : null;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index b8cff7f92..03255731f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -13,56 +13,28 @@
  */
 package org.asynchttpclient.netty.request;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
-import static java.util.Collections.singletonList;
-import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.HttpConstants.Methods.*;
-import static org.asynchttpclient.util.MiscUtils.getCause;
-import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelProgressivePromise;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaderValues;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.*;
 import io.netty.util.Timer;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.util.List;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpClientState;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Realm;
+import org.asynchttpclient.*;
 import org.asynchttpclient.Realm.AuthScheme;
-import org.asynchttpclient.Request;
 import org.asynchttpclient.exception.PoolAlreadyClosedException;
 import org.asynchttpclient.exception.RemotelyClosedException;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.SimpleFutureListener;
-import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.channel.ChannelState;
-import org.asynchttpclient.netty.channel.Channels;
-import org.asynchttpclient.netty.channel.ConnectionSemaphore;
-import org.asynchttpclient.netty.channel.NettyConnectListener;
+import org.asynchttpclient.netty.channel.*;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.resolver.RequestHostnameResolver;
@@ -71,541 +43,597 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
+import static java.util.Collections.singletonList;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+import static org.asynchttpclient.util.MiscUtils.getCause;
+import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
+
 public final class NettyRequestSender {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
-
-    private final AsyncHttpClientConfig config;
-    private final ChannelManager channelManager;
-    private final ConnectionSemaphore connectionSemaphore;
-    private final Timer nettyTimer;
-    private final AsyncHttpClientState clientState;
-    private final NettyRequestFactory requestFactory;
-
-    public NettyRequestSender(AsyncHttpClientConfig config,//
-            ChannelManager channelManager,//
-            Timer nettyTimer,//
-            AsyncHttpClientState clientState) {
-        this.config = config;
-        this.channelManager = channelManager;
-        this.connectionSemaphore = ConnectionSemaphore.newConnectionSemaphore(config);
-        this.nettyTimer = nettyTimer;
-        this.clientState = clientState;
-        requestFactory = new NettyRequestFactory(config);
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
+
+  private final AsyncHttpClientConfig config;
+  private final ChannelManager channelManager;
+  private final ConnectionSemaphore connectionSemaphore;
+  private final Timer nettyTimer;
+  private final AsyncHttpClientState clientState;
+  private final NettyRequestFactory requestFactory;
+
+  public NettyRequestSender(AsyncHttpClientConfig config,
+                            ChannelManager channelManager,
+                            Timer nettyTimer,
+                            AsyncHttpClientState clientState) {
+    this.config = config;
+    this.channelManager = channelManager;
+    this.connectionSemaphore = config.getConnectionSemaphoreFactory() == null
+            ? new DefaultConnectionSemaphoreFactory().newConnectionSemaphore(config)
+            : config.getConnectionSemaphoreFactory().newConnectionSemaphore(config);
+    this.nettyTimer = nettyTimer;
+    this.clientState = clientState;
+    requestFactory = new NettyRequestFactory(config);
+  }
+
+  public <T> ListenableFuture<T> sendRequest(final Request request,
+                                             final AsyncHandler<T> asyncHandler,
+                                             NettyResponseFuture<T> future) {
+
+    if (isClosed()) {
+      throw new IllegalStateException("Closed");
     }
 
-    public <T> ListenableFuture<T> sendRequest(final Request request,//
-            final AsyncHandler<T> asyncHandler,//
-            NettyResponseFuture<T> future,//
-            boolean performingNextRequest) {
-
-        if (isClosed())
-            throw new IllegalStateException("Closed");
-
-        validateWebSocketRequest(request, asyncHandler);
-
-        ProxyServer proxyServer = getProxyServer(config, request);
-
-        // websockets use connect tunnelling to work with proxies
-        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))
-            if (future != null && future.isConnectAllowed())
-                // SSL proxy or websocket: CONNECT for sure
-                return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, true);
-            else
-                // CONNECT will depend if we can pool or connection or if we have to open a new one
-                return sendRequestThroughSslProxy(request, asyncHandler, future, performingNextRequest, proxyServer);
-        else
-            // no CONNECT for sure
-            return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);
+    validateWebSocketRequest(request, asyncHandler);
+
+    ProxyServer proxyServer = getProxyServer(config, request);
+
+    // WebSockets use connect tunneling to work with proxies
+    if (proxyServer != null
+            && proxyServer.getProxyType().isHttp()
+            && (request.getUri().isSecured() || request.getUri().isWebSocket())
+            && !isConnectAlreadyDone(request, future)) {
+      // Proxy with HTTPS or WebSocket: CONNECT for sure
+      if (future != null && future.isConnectAllowed()) {
+        // Perform CONNECT
+        return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, true);
+      } else {
+        // CONNECT will depend if we can pool or connection or if we have to open a new one
+        return sendRequestThroughProxy(request, asyncHandler, future, proxyServer);
+      }
+    } else {
+      // no CONNECT for sure
+      return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, false);
     }
-
-    private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
-        return future != null //
-                && future.getNettyRequest() != null //
-                && future.getNettyRequest().getHttpRequest().method() == HttpMethod.CONNECT //
-                && !request.getMethod().equals(CONNECT);
+  }
+
+  private boolean isConnectAlreadyDone(Request request, NettyResponseFuture<?> future) {
+    return future != null
+            && future.getNettyRequest() != null
+            && future.getNettyRequest().getHttpRequest().method() == HttpMethod.CONNECT
+            && !request.getMethod().equals(CONNECT);
+  }
+
+  /**
+   * We know for sure if we have to force to connect or not, so we can build the
+   * HttpRequest right away This reduces the probability of having a pooled
+   * channel closed by the server by the time we build the request
+   */
+  private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(Request request,
+                                                                     AsyncHandler<T> asyncHandler,
+                                                                     NettyResponseFuture<T> future,
+                                                                     ProxyServer proxyServer,
+                                                                     boolean performConnectRequest) {
+
+    NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer,
+            performConnectRequest);
+
+    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
+
+    return Channels.isChannelActive(channel)
+            ? sendRequestWithOpenChannel(newFuture, asyncHandler, channel)
+            : sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
+  }
+
+  /**
+   * Using CONNECT depends on wither we can fetch a valid channel or not Loop
+   * until we get a valid channel from the pool and it's still valid once the
+   * request is built @
+   */
+  private <T> ListenableFuture<T> sendRequestThroughProxy(Request request,
+                                                          AsyncHandler<T> asyncHandler,
+                                                          NettyResponseFuture<T> future,
+                                                          ProxyServer proxyServer) {
+
+    NettyResponseFuture<T> newFuture = null;
+    for (int i = 0; i < 3; i++) {
+      Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
+
+      if (channel == null) {
+        // pool is empty
+        break;
+      }
+
+      if (newFuture == null) {
+        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
+      }
+
+      if (Channels.isChannelActive(channel)) {
+        // if the channel is still active, we can use it,
+        // otherwise, channel was closed by the time we computed the request, try again
+        return sendRequestWithOpenChannel(newFuture, asyncHandler, channel);
+      }
     }
 
-    /**
-     * We know for sure if we have to force to connect or not, so we can build the HttpRequest right away This reduces the probability of having a pooled channel closed by the
-     * server by the time we build the request
-     */
-    private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
-            Request request,//
-            AsyncHandler<T> asyncHandler,//
-            NettyResponseFuture<T> future,//
-            boolean performingNextRequest,//
-            ProxyServer proxyServer,//
-            boolean forceConnect) {
-
-        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
-
-        Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
-
-        if (Channels.isChannelValid(channel))
-            return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
-        else
-            return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
+    // couldn't poll an active channel
+    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
+    return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
+  }
+
+  private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request,
+                                                                      final AsyncHandler<T> asyncHandler,
+                                                                      NettyResponseFuture<T> originalFuture,
+                                                                      ProxyServer proxy,
+                                                                      boolean performConnectRequest) {
+
+    Realm realm;
+    if (originalFuture != null) {
+      realm = originalFuture.getRealm();
+    } else {
+      realm = request.getRealm();
+      if (realm == null) {
+        realm = config.getRealm();
+      }
     }
 
-    /**
-     * Using CONNECT depends on wither we can fetch a valid channel or not Loop until we get a valid channel from the pool and it's still valid once the request is built @
-     */
-    @SuppressWarnings("unused")
-    private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
-            Request request,//
-            AsyncHandler<T> asyncHandler,//
-            NettyResponseFuture<T> future,//
-            boolean performingNextRequest,//
-            ProxyServer proxyServer) {
-
-        NettyResponseFuture<T> newFuture = null;
-        for (int i = 0; i < 3; i++) {
-            Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
-            if (Channels.isChannelValid(channel))
-                if (newFuture == null)
-                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
-
-            if (Channels.isChannelValid(channel))
-                // if the channel is still active, we can use it, otherwise try
-                // gain
-                return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
-            else
-                // pool is empty
-                break;
-        }
-
-        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
-        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
+    Realm proxyRealm = null;
+    if (originalFuture != null) {
+      proxyRealm = originalFuture.getProxyRealm();
+    } else if (proxy != null) {
+      proxyRealm = proxy.getRealm();
     }
 
-    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
-            ProxyServer proxy, boolean forceConnect) {
-
-        Realm realm = null;
-        if (originalFuture != null) {
-            realm = originalFuture.getRealm();
-        } else {
-            realm = request.getRealm();
-            if (realm == null) {
-                realm = config.getRealm();
-            }
-        }
-
-        Realm proxyRealm = null;
-        if (originalFuture != null) {
-            proxyRealm = originalFuture.getProxyRealm();
-        } else if (proxy != null) {
-            proxyRealm = proxy.getRealm();
-        }
-
-        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, forceConnect, proxy, realm, proxyRealm);
-
-        if (originalFuture == null) {
-            NettyResponseFuture<T> future = newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
-            future.setRealm(realm);
-            future.setProxyRealm(proxyRealm);
-            return future;
-        } else {
-            originalFuture.setNettyRequest(nettyRequest);
-            originalFuture.setCurrentRequest(request);
-            return originalFuture;
-        }
+    NettyRequest nettyRequest = requestFactory.newNettyRequest(request, performConnectRequest, proxy, realm,
+            proxyRealm);
+
+    if (originalFuture == null) {
+      NettyResponseFuture<T> future = newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
+      future.setRealm(realm);
+      future.setProxyRealm(proxyRealm);
+      return future;
+    } else {
+      originalFuture.setNettyRequest(nettyRequest);
+      originalFuture.setCurrentRequest(request);
+      return originalFuture;
     }
-
-    private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
-        if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel())) {
-            return future.channel();
-        } else {
-            return pollPooledChannel(request, proxyServer, asyncHandler);
-        }
+  }
+
+  private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer,
+                                 AsyncHandler<?> asyncHandler) {
+    if (future != null && future.isReuseChannel() && Channels.isChannelActive(future.channel())) {
+      return future.channel();
+    } else {
+      return pollPooledChannel(request, proxyServer, asyncHandler);
     }
-
-    private <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
-
-        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
-        if (asyncHandlerExtensions != null) {
-            try {
-                asyncHandlerExtensions.onConnectionPooled(channel);
-            } catch (Exception e) {
-                LOGGER.error("onConnectionPooled crashed", e);
-                abort(channel, future, e);
-                return future;
-            }
-        }
-
-        SocketAddress channelRemoteAddress = channel.remoteAddress();
-        if (channelRemoteAddress != null) {
-            // otherwise, bad luck, the channel was closed, see bellow
-            scheduleRequestTimeout(future, (InetSocketAddress) channelRemoteAddress);
-        }
-
-        future.setChannelState(ChannelState.POOLED);
-        future.attachChannel(channel, false);
-
-        if (LOGGER.isDebugEnabled()) {
-            HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-            LOGGER.debug("Using open Channel {} for {} '{}'", channel, httpRequest.method(), httpRequest.uri());
-        }
-
-        // channelInactive might be called between isChannelValid and writeRequest
-        // so if we don't store the Future now, channelInactive won't perform handleUnexpectedClosedChannel
-        Channels.setAttribute(channel, future);
-
-        if (Channels.isChannelValid(channel)) {
-            writeRequest(future, channel);
-        } else {
-            // bad luck, the channel was closed in-between
-            // there's a very good chance onClose was already notified but the
-            // future wasn't already registered
-            handleUnexpectedClosedChannel(channel, future);
-        }
-
-        return future;
+  }
+
+  private <T> ListenableFuture<T> sendRequestWithOpenChannel(NettyResponseFuture<T> future,
+                                                             AsyncHandler<T> asyncHandler,
+                                                             Channel channel) {
+
+    try {
+      asyncHandler.onConnectionPooled(channel);
+    } catch (Exception e) {
+      LOGGER.error("onConnectionPooled crashed", e);
+      abort(channel, future, e);
+      return future;
     }
 
-    private <T> ListenableFuture<T> sendRequestWithNewChannel(//
-            Request request,//
-            ProxyServer proxy,//
-            NettyResponseFuture<T> future,//
-            AsyncHandler<T> asyncHandler,//
-            boolean performingNextRequest) {
+    SocketAddress channelRemoteAddress = channel.remoteAddress();
+    if (channelRemoteAddress != null) {
+      // otherwise, bad luck, the channel was closed, see bellow
+      scheduleRequestTimeout(future, (InetSocketAddress) channelRemoteAddress);
+    }
 
-        // some headers are only set when performing the first request
-        HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
-        Realm realm = future.getRealm();
-        Realm proxyRealm = future.getProxyRealm();
-        requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
-        requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
+    future.setChannelState(ChannelState.POOLED);
+    future.attachChannel(channel, false);
 
-        future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
-        future.setInProxyAuth(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
+    if (LOGGER.isDebugEnabled()) {
+      HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+      LOGGER.debug("Using open Channel {} for {} '{}'", channel, httpRequest.method(), httpRequest.uri());
+    }
 
-        // Do not throw an exception when we need an extra connection for a redirect
-        // FIXME why? This violate the max connection per host handling, right?
-        Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);
+    // channelInactive might be called between isChannelValid and writeRequest
+    // so if we don't store the Future now, channelInactive won't perform
+    // handleUnexpectedClosedChannel
+    Channels.setAttribute(channel, future);
+
+    if (Channels.isChannelActive(channel)) {
+      writeRequest(future, channel);
+    } else {
+      // bad luck, the channel was closed in-between
+      // there's a very good chance onClose was already notified but the
+      // future wasn't already registered
+      handleUnexpectedClosedChannel(channel, future);
+    }
 
-        Object partitionKey = future.getPartitionKey();
+    return future;
+  }
+
+  private <T> ListenableFuture<T> sendRequestWithNewChannel(Request request,
+                                                            ProxyServer proxy,
+                                                            NettyResponseFuture<T> future,
+                                                            AsyncHandler<T> asyncHandler) {
+
+    // some headers are only set when performing the first request
+    HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
+    Realm realm = future.getRealm();
+    Realm proxyRealm = future.getProxyRealm();
+    requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
+    requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
+
+    future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
+    future.setInProxyAuth(
+            proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
+
+    try {
+      if (!channelManager.isOpen()) {
+        throw PoolAlreadyClosedException.INSTANCE;
+      }
+
+      // Do not throw an exception when we need an extra connection for a
+      // redirect.
+      future.acquirePartitionLockLazily();
+    } catch (Throwable t) {
+      abort(null, future, getCause(t));
+      // exit and don't try to resolve address
+      return future;
+    }
 
+    resolveAddresses(request, proxy, future, asyncHandler)
+            .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
+
+              @Override
+              protected void onSuccess(List<InetSocketAddress> addresses) {
+                NettyConnectListener<T> connectListener = new NettyConnectListener<>(future,
+                        NettyRequestSender.this, channelManager, connectionSemaphore);
+                NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(),
+                        addresses, asyncHandler, clientState);
+                if (!future.isDone()) {
+                  // Do not throw an exception when we need an extra connection for a redirect
+                  // FIXME why? This violate the max connection per host handling, right?
+                  channelManager.getBootstrap(request.getUri(), request.getNameResolver(), proxy)
+                          .addListener((Future<Bootstrap> whenBootstrap) -> {
+                            if (whenBootstrap.isSuccess()) {
+                              connector.connect(whenBootstrap.get(), connectListener);
+                            } else {
+                              abort(null, future, whenBootstrap.cause());
+                            }
+                          });
+                }
+              }
+
+              @Override
+              protected void onFailure(Throwable cause) {
+                abort(null, future, getCause(cause));
+              }
+            });
+
+    return future;
+  }
+
+  private <T> Future<List<InetSocketAddress>> resolveAddresses(Request request,
+                                                               ProxyServer proxy,
+                                                               NettyResponseFuture<T> future,
+                                                               AsyncHandler<T> asyncHandler) {
+
+    Uri uri = request.getUri();
+    final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+
+    if (proxy != null && !proxy.isIgnoredForHost(uri.getHost()) && proxy.getProxyType().isHttp()) {
+      int port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
+      InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(proxy.getHost(), port);
+      scheduleRequestTimeout(future, unresolvedRemoteAddress);
+      return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
+
+    } else {
+      int port = uri.getExplicitPort();
+
+      InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(uri.getHost(), port);
+      scheduleRequestTimeout(future, unresolvedRemoteAddress);
+
+      if (request.getAddress() != null) {
+        // bypass resolution
+        InetSocketAddress inetSocketAddress = new InetSocketAddress(request.getAddress(), port);
+        return promise.setSuccess(singletonList(inetSocketAddress));
+      } else {
+        return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
+      }
+    }
+  }
+
+  private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request,
+                                                            AsyncHandler<T> asyncHandler,
+                                                            NettyRequest nettyRequest,
+                                                            ProxyServer proxyServer) {
+
+    NettyResponseFuture<T> future = new NettyResponseFuture<>(
+            request,
+            asyncHandler,
+            nettyRequest,
+            config.getMaxRequestRetry(),
+            request.getChannelPoolPartitioning(),
+            connectionSemaphore,
+            proxyServer);
+
+    String expectHeader = request.getHeaders().get(EXPECT);
+    if (HttpHeaderValues.CONTINUE.contentEqualsIgnoreCase(expectHeader))
+      future.setDontWriteBodyBecauseExpectContinue(true);
+    return future;
+  }
+
+  public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
+
+    NettyRequest nettyRequest = future.getNettyRequest();
+    HttpRequest httpRequest = nettyRequest.getHttpRequest();
+    AsyncHandler<T> asyncHandler = future.getAsyncHandler();
+
+    // if the channel is dead because it was pooled and the remote server decided to
+    // close it,
+    // we just let it go and the channelInactive do its work
+    if (!Channels.isChannelActive(channel))
+      return;
+
+    try {
+      if (asyncHandler instanceof TransferCompletionHandler) {
+        configureTransferAdapter(asyncHandler, httpRequest);
+      }
+
+      boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue()
+              && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
+
+      if (!future.isHeadersAlreadyWrittenOnContinue()) {
         try {
-            if (!channelManager.isOpen()) {
-                throw PoolAlreadyClosedException.INSTANCE;
-            }
-
-            // Do not throw an exception when we need an extra connection for a
-            // redirect.
-            future.acquirePartitionLockLazily();
-        } catch (Throwable t) {
-            abort(null, future, getCause(t));
-            // exit and don't try to resolve address
-            return future;
+          asyncHandler.onRequestSend(nettyRequest);
+        } catch (Exception e) {
+          LOGGER.error("onRequestSend crashed", e);
+          abort(channel, future, e);
+          return;
         }
 
-        resolveAddresses(request, proxy, future, asyncHandler)//
-                .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
-
-                    @Override
-                    protected void onSuccess(List<InetSocketAddress> addresses) {
-                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, connectionSemaphore, partitionKey);
-                        NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);
-                        if (!future.isDone()) {
-                            connector.connect(bootstrap, connectListener);
-                        }
-                    }
-
-                    @Override
-                    protected void onFailure(Throwable cause) {
-                        abort(null, future, getCause(cause));
-                    }
-                });
-
-        return future;
-    }
-    
-    private <T> Future<List<InetSocketAddress>> resolveAddresses(
-            Request request,//
-            ProxyServer proxy,//
-            NettyResponseFuture<T> future,//
-            AsyncHandler<T> asyncHandler) {
-        
-        Uri uri = request.getUri();
-        final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
-
-        if (proxy != null && !proxy.isIgnoredForHost(uri.getHost())) {
-            int port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
-            InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(proxy.getHost(), port);
-            scheduleRequestTimeout(future, unresolvedRemoteAddress);
-            return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
-            
+        // if the request has a body, we want to track progress
+        if (writeBody) {
+          // FIXME does this really work??? the promise is for the request without body!!!
+          ChannelProgressivePromise promise = channel.newProgressivePromise();
+          ChannelFuture f = channel.write(httpRequest, promise);
+          f.addListener(new WriteProgressListener(future, true, 0L));
         } else {
-            int port = uri.getExplicitPort();
-            
-            if (request.getAddress() != null) {
-                // bypass resolution
-                InetSocketAddress inetSocketAddress = new InetSocketAddress(request.getAddress(), port);
-                return promise.setSuccess(singletonList(inetSocketAddress));
-                
-            } else {
-                InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(uri.getHost(), port);
-                scheduleRequestTimeout(future, unresolvedRemoteAddress);
-                return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
-            }
+          // we can just track write completion
+          ChannelPromise promise = channel.newPromise();
+          ChannelFuture f = channel.writeAndFlush(httpRequest, promise);
+          f.addListener(new WriteCompleteListener(future));
         }
-    }
-
-    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
-
-        NettyResponseFuture<T> future = new NettyResponseFuture<>(//
-                request,//
-                asyncHandler,//
-                nettyRequest,//
-                config.getMaxRequestRetry(),//
-                request.getChannelPoolPartitioning(),//
-                connectionSemaphore,//
-                proxyServer);
-
-        String expectHeader = request.getHeaders().get(EXPECT);
-        if (HttpHeaderValues.CONTINUE.contentEqualsIgnoreCase(expectHeader))
-            future.setDontWriteBodyBecauseExpectContinue(true);
-        return future;
-    }
-
-    public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
-
-        NettyRequest nettyRequest = future.getNettyRequest();
-        HttpRequest httpRequest = nettyRequest.getHttpRequest();
-        AsyncHandler<T> handler = future.getAsyncHandler();
-
-        // if the channel is dead because it was pooled and the remote server decided to close it,
-        // we just let it go and the channelInactive do its work
-        if (!Channels.isChannelValid(channel))
-            return;
-
-        try {
-            if (handler instanceof TransferCompletionHandler) {
-                configureTransferAdapter(handler, httpRequest);
-            }
-
-            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue() && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
-
-            if (!future.isHeadersAlreadyWrittenOnContinue()) {
-                final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(handler);
-                if (asyncHandlerExtensions != null) {
-                    try {
-                        asyncHandlerExtensions.onRequestSend(nettyRequest);
-                    } catch (Exception e) {
-                        LOGGER.error("onRequestSend crashed", e);
-                        abort(channel, future, e);
-                        return;
-                    }
-                }
-
-                // if the request has a body, we want to track progress
-                if (writeBody) {
-                    // FIXME does this really work??? the promise is for the request without body!!!
-                    ChannelProgressivePromise promise = channel.newProgressivePromise();
-                    ChannelFuture f = channel.write(httpRequest, promise);
-                    f.addListener(new WriteProgressListener(future, true, 0L));
-                } else {
-                    // we can just track write completion
-                    ChannelPromise promise = channel.newPromise();
-                    ChannelFuture f = channel.writeAndFlush(httpRequest, promise);
-                    f.addListener(new WriteCompleteListener(future));
-                }
-            }
+      }
 
-            if (writeBody)
-                nettyRequest.getBody().write(channel, future);
+      if (writeBody)
+        nettyRequest.getBody().write(channel, future);
 
-            // don't bother scheduling read timeout if channel became invalid
-            if (Channels.isChannelValid(channel)) {
-                scheduleReadTimeout(future);
-            }
+      // don't bother scheduling read timeout if channel became invalid
+      if (Channels.isChannelActive(channel)) {
+        scheduleReadTimeout(future);
+      }
 
-        } catch (Exception e) {
-            LOGGER.error("Can't write request", e);
-            abort(channel, future, e);
-        }
+    } catch (Exception e) {
+      LOGGER.error("Can't write request", e);
+      abort(channel, future, e);
     }
-
-    private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
-        HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
-        TransferCompletionHandler.class.cast(handler).headers(h);
+  }
+
+  private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
+    HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
+    TransferCompletionHandler.class.cast(handler).headers(h);
+  }
+
+  private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture,
+                                      InetSocketAddress originalRemoteAddress) {
+    nettyResponseFuture.touch();
+    TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config,
+            originalRemoteAddress);
+    nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
+  }
+
+  private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
+    TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
+    if (timeoutsHolder != null) {
+      // on very fast requests, it's entirely possible that the response has already
+      // been completed
+      // by the time we try to schedule the read timeout
+      nettyResponseFuture.touch();
+      timeoutsHolder.startReadTimeout();
     }
+  }
 
-    private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture, InetSocketAddress originalRemoteAddress) {
-        nettyResponseFuture.touch();
-        TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config, originalRemoteAddress);
-        nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
-    }
+  public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
 
-    private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
-        TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
-        if (timeoutsHolder != null) {
-            // on very fast requests, it's entirely possible that the response has already been completed
-            // by the time we try to schedule the read timeout
-            nettyResponseFuture.touch();
-            timeoutsHolder.startReadTimeout();
-        }
+    if (channel != null && channel.isActive()) {
+      channelManager.closeChannel(channel);
     }
 
-    public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
-
-        if (channel != null) {
-            channelManager.closeChannel(channel);
-        }
-
-        if (!future.isDone()) {
-            future.setChannelState(ChannelState.CLOSED);
-            LOGGER.debug("Aborting Future {}\n", future);
-            LOGGER.debug(t.getMessage(), t);
-            future.abort(t);
-        }
+    if (!future.isDone()) {
+      future.setChannelState(ChannelState.CLOSED);
+      LOGGER.debug("Aborting Future {}\n", future);
+      LOGGER.debug(t.getMessage(), t);
+      future.abort(t);
     }
-
-    public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
-        if (Channels.isActiveTokenSet(channel)) {
-            if (future.isDone()) {
-                channelManager.closeChannel(channel);
-            } else if (future.incrementRetryAndCheck() && retry(future)) {
-                future.pendingException = null;
-            } else {
-                abort(channel, future, future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
-            }
-        }
+  }
+
+  public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
+    if (Channels.isActiveTokenSet(channel)) {
+      if (future.isDone()) {
+        channelManager.closeChannel(channel);
+      } else if (future.incrementRetryAndCheck() && retry(future)) {
+        future.pendingException = null;
+      } else {
+        abort(channel, future,
+                future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
+      }
     }
+  }
 
-    public boolean retry(NettyResponseFuture<?> future) {
-
-        if (isClosed()) {
-            return false;
-        }
+  public boolean retry(NettyResponseFuture<?> future) {
 
-        if (future.isReplayPossible()) {
-            future.setChannelState(ChannelState.RECONNECTED);
-
-            LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
-            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
-            if (asyncHandlerExtensions != null) {
-                try {
-                    asyncHandlerExtensions.onRetry();
-                } catch (Exception e) {
-                    LOGGER.error("onRetry crashed", e);
-                    abort(future.channel(), future, e);
-                    return false;
-                }
-            }
-
-            try {
-                sendNextRequest(future.getCurrentRequest(), future);
-                return true;
-
-            } catch (Exception e) {
-                abort(future.channel(), future, e);
-                return false;
-            }
-        } else {
-            LOGGER.debug("Unable to recover future {}\n", future);
-            return false;
-        }
+    if (isClosed()) {
+      return false;
     }
 
-    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) {
-
-        boolean replayed = false;
-
-        @SuppressWarnings({ "unchecked", "rawtypes" })
-        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getCurrentRequest()).ioException(e).build();
-        for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                assertNotNull(fc, "filterContext");
-            } catch (FilterException efe) {
-                abort(channel, future, efe);
-            }
-        }
-
-        if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
-            future.setKeepAlive(false);
-            replayRequest(future, fc, channel);
-            replayed = true;
-        }
-        return replayed;
+    if (future.isReplayPossible()) {
+      future.setChannelState(ChannelState.RECONNECTED);
+
+      LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
+      try {
+        future.getAsyncHandler().onRetry();
+      } catch (Exception e) {
+        LOGGER.error("onRetry crashed", e);
+        abort(future.channel(), future, e);
+        return false;
+      }
+
+      try {
+        sendNextRequest(future.getCurrentRequest(), future);
+        return true;
+
+      } catch (Exception e) {
+        abort(future.channel(), future, e);
+        return false;
+      }
+    } else {
+      LOGGER.debug("Unable to recover future {}\n", future);
+      return false;
     }
-
-    public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
-        sendRequest(request, future.getAsyncHandler(), future, true);
+  }
+
+  public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e,
+                                                         Channel channel) {
+
+    boolean replayed = false;
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
+            .request(future.getCurrentRequest()).ioException(e).build();
+    for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
+      try {
+        fc = asyncFilter.filter(fc);
+        assertNotNull(fc, "filterContext");
+      } catch (FilterException efe) {
+        abort(channel, future, efe);
+      }
     }
 
-    private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-        Uri uri = request.getUri();
-        boolean isWs = uri.isWebSocket();
-        if (asyncHandler instanceof WebSocketUpgradeHandler) {
-            if (!isWs) {
-                throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
-            } else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT)) {
-                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
-            }
-        } else if (isWs) {
-            throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
-        }
+    if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
+      future.setKeepAlive(false);
+      replayRequest(future, fc, channel);
+      replayed = true;
     }
+    return replayed;
+  }
+
+  public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
+    sendRequest(request, future.getAsyncHandler(), future);
+  }
+
+  private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+    Uri uri = request.getUri();
+    boolean isWs = uri.isWebSocket();
+    if (asyncHandler instanceof WebSocketUpgradeHandler) {
+      if (!isWs) {
+        throw new IllegalArgumentException(
+                "WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
+      } else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT)) {
+        throw new IllegalArgumentException(
+                "WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
+      }
+    } else if (isWs) {
+      throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
+    }
+  }
 
-    private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
-
-        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
-        if (asyncHandlerExtensions != null) {
-            try {
-                asyncHandlerExtensions.onConnectionPoolAttempt();
-            } catch (Exception e) {
-                LOGGER.error("onConnectionPoolAttempt crashed", e);
-            }
-        }
-
-        Uri uri = request.getUri();
-        String virtualHost = request.getVirtualHost();
-        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
-
-        if (channel != null) {
-            LOGGER.debug("Using pooled Channel '{}' for '{}' to '{}'", channel, request.getMethod(), uri);
-        }
-        return channel;
+  private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
+    try {
+      asyncHandler.onConnectionPoolAttempt();
+    } catch (Exception e) {
+      LOGGER.error("onConnectionPoolAttempt crashed", e);
     }
 
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
-
-        Request newRequest = fc.getRequest();
-        future.setAsyncHandler(fc.getAsyncHandler());
-        future.setChannelState(ChannelState.NEW);
-        future.touch();
-
-        LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
-        if (asyncHandlerExtensions != null) {
-            try {
-                asyncHandlerExtensions.onRetry();
-            } catch (Exception e) {
-                LOGGER.error("onRetry crashed", e);
-                abort(channel, future, e);
-                return;
-            }
-        }
+    Uri uri = request.getUri();
+    String virtualHost = request.getVirtualHost();
+    final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
 
-        channelManager.drainChannelAndOffer(channel, future);
-        sendNextRequest(newRequest, future);
+    if (channel != null) {
+      LOGGER.debug("Using pooled Channel '{}' for '{}' to '{}'", channel, request.getMethod(), uri);
     }
-
-    public boolean isClosed() {
-        return clientState.isClosed();
+    return channel;
+  }
+
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
+
+    Request newRequest = fc.getRequest();
+    future.setAsyncHandler(fc.getAsyncHandler());
+    future.setChannelState(ChannelState.NEW);
+    future.touch();
+
+    LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+    try {
+      future.getAsyncHandler().onRetry();
+    } catch (Exception e) {
+      LOGGER.error("onRetry crashed", e);
+      abort(channel, future, e);
+      return;
     }
 
-    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
-        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
-            @Override
-            public void call() {
-                sendNextRequest(nextRequest, future);
-            }
-        });
-    }
+    channelManager.drainChannelAndOffer(channel, future);
+    sendNextRequest(newRequest, future);
+  }
+
+  public boolean isClosed() {
+    return clientState.isClosed();
+  }
+
+  public void drainChannelAndExecuteNextRequest(final Channel channel,
+                                                final NettyResponseFuture<?> future,
+                                                Request nextRequest) {
+    Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
+      @Override
+      public void call() {
+        sendNextRequest(nextRequest, future);
+      }
+    });
+  }
+
+  public void drainChannelAndExecuteNextRequest(final Channel channel,
+                                                final NettyResponseFuture<?> future,
+                                                Request nextRequest,
+                                                Future<Channel> whenHandshaked) {
+    Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
+      @Override
+      public void call() {
+        whenHandshaked.addListener(f -> {
+          if (f.isSuccess()) {
+            sendNextRequest(nextRequest, future);
+          } else {
+            future.abort(f.cause());
+          }
+        }
+        );
+      }
+    });
+  }
+
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
index d82f540d0..0d3560fb7 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
@@ -13,19 +13,18 @@
  */
 package org.asynchttpclient.netty.request;
 
-import org.asynchttpclient.netty.NettyResponseFuture;
-
 import io.netty.channel.ChannelFuture;
 import io.netty.util.concurrent.GenericFutureListener;
+import org.asynchttpclient.netty.NettyResponseFuture;
 
 public class WriteCompleteListener extends WriteListener implements GenericFutureListener<ChannelFuture> {
 
-    public WriteCompleteListener(NettyResponseFuture<?> future) {
-        super(future, true);
-    }
+  WriteCompleteListener(NettyResponseFuture<?> future) {
+    super(future, true);
+  }
 
-    @Override
-    public void operationComplete(ChannelFuture future) throws Exception {
-        operationComplete(future.channel(), future.cause());
-    }
+  @Override
+  public void operationComplete(ChannelFuture future) {
+    operationComplete(future.channel(), future.cause());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
index 74c748f6e..ab38a66f9 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
@@ -14,68 +14,64 @@
 package org.asynchttpclient.netty.request;
 
 import io.netty.channel.Channel;
-
-import java.nio.channels.ClosedChannelException;
-
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.nio.channels.ClosedChannelException;
+
 public abstract class WriteListener {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(WriteListener.class);
-    protected final NettyResponseFuture<?> future;
-    protected final ProgressAsyncHandler<?> progressAsyncHandler;
-    protected final boolean notifyHeaders;
+  private static final Logger LOGGER = LoggerFactory.getLogger(WriteListener.class);
+  protected final NettyResponseFuture<?> future;
+  final ProgressAsyncHandler<?> progressAsyncHandler;
+  final boolean notifyHeaders;
 
-    public WriteListener(NettyResponseFuture<?> future, boolean notifyHeaders) {
-        this.future = future;
-        this.progressAsyncHandler = future.getAsyncHandler() instanceof ProgressAsyncHandler ? (ProgressAsyncHandler<?>) future.getAsyncHandler() : null;
-        this.notifyHeaders = notifyHeaders;
+  WriteListener(NettyResponseFuture<?> future, boolean notifyHeaders) {
+    this.future = future;
+    this.progressAsyncHandler = future.getAsyncHandler() instanceof ProgressAsyncHandler ? (ProgressAsyncHandler<?>) future.getAsyncHandler() : null;
+    this.notifyHeaders = notifyHeaders;
+  }
+
+  private boolean abortOnThrowable(Channel channel, Throwable cause) {
+    if (cause != null) {
+      if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+        LOGGER.debug(cause.getMessage(), cause);
+        Channels.silentlyCloseChannel(channel);
+
+      } else {
+        future.abort(cause);
+      }
+      return true;
     }
 
-    private boolean abortOnThrowable(Channel channel, Throwable cause) {
-        if (cause != null && future.getChannelState() != ChannelState.NEW) {
-            if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-                LOGGER.debug(cause.getMessage(), cause);
-                Channels.silentlyCloseChannel(channel);
+    return false;
+  }
 
-            } else {
-                future.abort(cause);
-            }
-            return true;
-        }
+  void operationComplete(Channel channel, Throwable cause) {
+    future.touch();
 
-        return false;
+    // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+    // Let's retry a second time.
+    if (abortOnThrowable(channel, cause)) {
+      return;
     }
 
-    protected void operationComplete(Channel channel, Throwable cause) {
-        future.touch();
-
-        // The write operation failed. If the channel was cached, it means it got asynchronously closed.
-        // Let's retry a second time.
-        if (abortOnThrowable(channel, cause)) {
-            return;
-        }
+    if (progressAsyncHandler != null) {
+       // We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
+       // causing unpredictable behavior.
+      boolean startPublishing = !future.isInAuth() && !future.isInProxyAuth();
+      if (startPublishing) {
 
-        if (progressAsyncHandler != null) {
-            /**
-             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
-             * causing unpredictable behavior.
-             */
-            boolean startPublishing = !future.isInAuth() && !future.isInProxyAuth();
-            if (startPublishing) {
-                
-                if (notifyHeaders) {
-                    progressAsyncHandler.onHeadersWritten();
-                } else {
-                    progressAsyncHandler.onContentWritten();
-                }
-            }
+        if (notifyHeaders) {
+          progressAsyncHandler.onHeadersWritten();
+        } else {
+          progressAsyncHandler.onContentWritten();
         }
+      }
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
index 7fc3ec4a6..c7d0ef20c 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
@@ -15,39 +15,38 @@
 
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.channel.ChannelProgressiveFutureListener;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 
 public class WriteProgressListener extends WriteListener implements ChannelProgressiveFutureListener {
 
-    private final long expectedTotal;
-    private long lastProgress = 0L;
-
-    public WriteProgressListener(NettyResponseFuture<?> future,//
-            boolean notifyHeaders,//
-            long expectedTotal) {
-        super(future, notifyHeaders);
-        this.expectedTotal = expectedTotal;
-    }
-
-    @Override
-    public void operationComplete(ChannelProgressiveFuture cf) {
-        operationComplete(cf.channel(), cf.cause());
-    }
-
-    @Override
-    public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
-        future.touch();
-
-        if (progressAsyncHandler != null && !notifyHeaders) {
-            long lastLastProgress = lastProgress;
-            lastProgress = progress;
-            if (total < 0) {
-                total = expectedTotal;
-            }
-            if (progress != lastLastProgress) {
-                progressAsyncHandler.onContentWriteProgress(progress - lastLastProgress, progress, total);
-            }
-        }
+  private final long expectedTotal;
+  private long lastProgress = 0L;
+
+  public WriteProgressListener(NettyResponseFuture<?> future,
+                               boolean notifyHeaders,
+                               long expectedTotal) {
+    super(future, notifyHeaders);
+    this.expectedTotal = expectedTotal;
+  }
+
+  @Override
+  public void operationComplete(ChannelProgressiveFuture cf) {
+    operationComplete(cf.channel(), cf.cause());
+  }
+
+  @Override
+  public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
+    future.touch();
+
+    if (progressAsyncHandler != null && !notifyHeaders) {
+      long lastLastProgress = lastProgress;
+      lastProgress = progress;
+      if (total < 0) {
+        total = expectedTotal;
+      }
+      if (progress != lastLastProgress) {
+        progressAsyncHandler.onContentWriteProgress(progress - lastLastProgress, progress, total);
+      }
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index b1f246244..d5f1852e2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -13,83 +13,83 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.stream.ChunkedInput;
-
 import org.asynchttpclient.request.body.Body;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 /**
  * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
  */
 public class BodyChunkedInput implements ChunkedInput<ByteBuf> {
 
-    public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
+  public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
 
-    private final Body body;
-    private final int chunkSize;
-    private boolean endOfInput;
-    private final long contentLength;
-    private long progress = 0L;
+  private final Body body;
+  private final int chunkSize;
+  private final long contentLength;
+  private boolean endOfInput;
+  private long progress = 0L;
 
-    public BodyChunkedInput(Body body) {
-        this.body = assertNotNull(body, "body");
-        this.contentLength = body.getContentLength();
-        if (contentLength <= 0)
-            chunkSize = DEFAULT_CHUNK_SIZE;
-        else
-            chunkSize = (int) Math.min(contentLength, (long) DEFAULT_CHUNK_SIZE);
-    }
+  BodyChunkedInput(Body body) {
+    this.body = assertNotNull(body, "body");
+    this.contentLength = body.getContentLength();
+    if (contentLength <= 0)
+      chunkSize = DEFAULT_CHUNK_SIZE;
+    else
+      chunkSize = (int) Math.min(contentLength, (long) DEFAULT_CHUNK_SIZE);
+  }
 
-    @Override
-    @Deprecated
-         public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
-        return readChunk(ctx.alloc());
-    }
+  @Override
+  @Deprecated
+  public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
+    return readChunk(ctx.alloc());
+  }
 
-    @Override
-    public ByteBuf readChunk(ByteBufAllocator alloc) throws Exception {
+  @Override
+  public ByteBuf readChunk(ByteBufAllocator alloc) throws Exception {
 
-        if (endOfInput)
-            return null;
+    if (endOfInput)
+      return null;
 
-        ByteBuf buffer = alloc.buffer(chunkSize);
-        Body.BodyState state = body.transferTo(buffer);
-        progress += buffer.writerIndex();
-        switch (state) {
-        case STOP:
-            endOfInput = true;
-            return buffer;
-        case SUSPEND:
-            // this will suspend the stream in ChunkedWriteHandler
-            buffer.release();
-            return null;
-        case CONTINUE:
-            return buffer;
-        default:
-            throw new IllegalStateException("Unknown state: " + state);
-        }
+    ByteBuf buffer = alloc.buffer(chunkSize);
+    Body.BodyState state = body.transferTo(buffer);
+    progress += buffer.writerIndex();
+    switch (state) {
+      case STOP:
+        endOfInput = true;
+        return buffer;
+      case SUSPEND:
+        // this will suspend the stream in ChunkedWriteHandler
+        buffer.release();
+        return null;
+      case CONTINUE:
+        return buffer;
+      default:
+        throw new IllegalStateException("Unknown state: " + state);
     }
+  }
 
-    @Override
-    public boolean isEndOfInput() throws Exception {
-        return endOfInput;
-    }
+  @Override
+  public boolean isEndOfInput() {
+    return endOfInput;
+  }
 
-    @Override
-    public void close() throws Exception {
-        body.close();
-    }
+  @Override
+  public void close() throws Exception {
+    body.close();
+  }
 
-    @Override
-    public long length() {
-        return contentLength;
-    }
-     
-    @Override
-    public long progress() {
-        return progress;
-    }
+  @Override
+  public long length() {
+    return contentLength;
+  }
+
+  @Override
+  public long progress() {
+    return progress;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
index 59ef476d0..bc2ac041f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -13,83 +13,81 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.util.Assertions.*;
-
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
-import org.asynchttpclient.request.body.RandomAccessBody;
-
 import io.netty.channel.FileRegion;
 import io.netty.util.AbstractReferenceCounted;
+import org.asynchttpclient.request.body.RandomAccessBody;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 /**
  * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
  */
-public class BodyFileRegion extends AbstractReferenceCounted implements FileRegion {
-
-    private final RandomAccessBody body;
-    private long transferred;
-
-    public BodyFileRegion(RandomAccessBody body) {
-        this.body = assertNotNull(body, "body");
-    }
-
-    @Override
-    public long position() {
-        return 0;
+class BodyFileRegion extends AbstractReferenceCounted implements FileRegion {
+
+  private final RandomAccessBody body;
+  private long transferred;
+
+  BodyFileRegion(RandomAccessBody body) {
+    this.body = assertNotNull(body, "body");
+  }
+
+  @Override
+  public long position() {
+    return 0;
+  }
+
+  @Override
+  public long count() {
+    return body.getContentLength();
+  }
+
+  @Override
+  public long transfered() {
+    return transferred();
+  }
+
+  @Override
+  public long transferred() {
+    return transferred;
+  }
+
+  @Override
+  public FileRegion retain() {
+    super.retain();
+    return this;
+  }
+
+  @Override
+  public FileRegion retain(int arg0) {
+    super.retain(arg0);
+    return this;
+  }
+
+  @Override
+  public FileRegion touch() {
+    return this;
+  }
+
+  @Override
+  public FileRegion touch(Object arg0) {
+    return this;
+  }
+
+  @Override
+  public long transferTo(WritableByteChannel target, long position) throws IOException {
+    long written = body.transferTo(target);
+    if (written > 0) {
+      transferred += written;
     }
+    return written;
+  }
 
-    @Override
-    public long count() {
-        return body.getContentLength();
-    }
-
-    @Override
-    public long transfered() {
-        return transferred();
-    }
-
-    @Override
-    public long transferred() {
-        return transferred;
-    }
-
-    @Override
-    public FileRegion retain() {
-        super.retain();
-        return this;
-    }
-
-    @Override
-    public FileRegion retain(int arg0) {
-        super.retain(arg0);
-        return this;
-    }
-
-    @Override
-    public FileRegion touch() {
-        return this;
-    }
-
-    @Override
-    public FileRegion touch(Object arg0) {
-        return this;
-    }
-
-    @Override
-    public long transferTo(WritableByteChannel target, long position) throws IOException {
-        long written = body.transferTo(target);
-        if (written > 0) {
-            transferred += written;
-        }
-        return written;
-    }
-
-    @Override
-    protected void deallocate() {
-        closeSilently(body);
-    }
+  @Override
+  protected void deallocate() {
+    closeSilently(body);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
index 41e2ade2f..fc8258304 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
@@ -14,18 +14,17 @@
 package org.asynchttpclient.netty.request.body;
 
 import io.netty.channel.Channel;
+import org.asynchttpclient.netty.NettyResponseFuture;
 
 import java.io.IOException;
 
-import org.asynchttpclient.netty.NettyResponseFuture;
-
 public interface NettyBody {
 
-    long getContentLength();
+  long getContentLength();
 
-    default CharSequence getContentTypeOverride() {
-        return null;
-    }
+  default CharSequence getContentTypeOverride() {
+    return null;
+  }
 
-    void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
+  void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 76f5c2c28..1a7d50b3f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -13,14 +13,10 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedWriteHandler;
-
-import java.io.IOException;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -32,58 +28,60 @@
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
 import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
 
-public class NettyBodyBody implements NettyBody {
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
-    private final Body body;
-    private final AsyncHttpClientConfig config;
+public class NettyBodyBody implements NettyBody {
 
-    public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
-        this.body = body;
-        this.config = config;
-    }
+  private final Body body;
+  private final AsyncHttpClientConfig config;
 
-    public Body getBody() {
-        return body;
-    }
+  public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
+    this.body = body;
+    this.config = config;
+  }
 
-    @Override
-    public long getContentLength() {
-        return body.getContentLength();
-    }
+  public Body getBody() {
+    return body;
+  }
 
-    @Override
-    public void write(final Channel channel, NettyResponseFuture<?> future) throws IOException {
+  @Override
+  public long getContentLength() {
+    return body.getContentLength();
+  }
 
-        Object msg;
-        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !config.isDisableZeroCopy()) {
-            msg = new BodyFileRegion((RandomAccessBody) body);
+  @Override
+  public void write(final Channel channel, NettyResponseFuture<?> future) {
 
-        } else {
-            msg = new BodyChunkedInput(body);
+    Object msg;
+    if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !config.isDisableZeroCopy() && getContentLength() > 0) {
+      msg = new BodyFileRegion((RandomAccessBody) body);
 
-            BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
-            if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
-                final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
-                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
-                    @Override
-                    public void onContentAdded() {
-                        chunkedWriteHandler.resumeTransfer();
-                    }
+    } else {
+      msg = new BodyChunkedInput(body);
 
-                    @Override
-                    public void onError(Throwable t) {
-                    }
-                });
-            }
-        }
+      BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
+      if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
+        final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
+        FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+          @Override
+          public void onContentAdded() {
+            chunkedWriteHandler.resumeTransfer();
+          }
 
-        channel.write(msg, channel.newProgressivePromise())//
-                .addListener(new WriteProgressListener(future, false, getContentLength()) {
-                    public void operationComplete(ChannelProgressiveFuture cf) {
-                        closeSilently(body);
-                        super.operationComplete(cf);
-                    }
-                });
-        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+          @Override
+          public void onError(Throwable t) {
+          }
+        });
+      }
     }
+
+    channel.write(msg, channel.newProgressivePromise())
+            .addListener(new WriteProgressListener(future, false, getContentLength()) {
+              public void operationComplete(ChannelProgressiveFuture cf) {
+                closeSilently(body);
+                super.operationComplete(cf);
+              }
+            });
+    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
index 2b54340a4..981aea522 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
@@ -16,22 +16,21 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 
-
 public class NettyByteArrayBody extends NettyDirectBody {
 
-    private final byte[] bytes;
+  private final byte[] bytes;
 
-    public NettyByteArrayBody(byte[] bytes) {
-        this.bytes = bytes;
-    }
+  public NettyByteArrayBody(byte[] bytes) {
+    this.bytes = bytes;
+  }
 
-    @Override
-    public long getContentLength() {
-        return bytes.length;
-    }
+  @Override
+  public long getContentLength() {
+    return bytes.length;
+  }
 
-    @Override
-    public ByteBuf byteBuf() {
-        return Unpooled.wrappedBuffer(bytes);
-    }
+  @Override
+  public ByteBuf byteBuf() {
+    return Unpooled.wrappedBuffer(bytes);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
index 9d320aa17..b957dfb4c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
@@ -20,35 +20,35 @@
 
 public class NettyByteBufferBody extends NettyDirectBody {
 
-    private final ByteBuffer bb;
-    private final CharSequence contentTypeOverride;
-    private final long length;
-
-    public NettyByteBufferBody(ByteBuffer bb) {
-        this(bb, null);
-    }
-
-    public NettyByteBufferBody(ByteBuffer bb, CharSequence contentTypeOverride) {
-        this.bb = bb;
-        length = bb.remaining();
-        bb.mark();
-        this.contentTypeOverride = contentTypeOverride;
-    }
-
-    @Override
-    public long getContentLength() {
-        return length;
-    }
-
-    @Override
-    public CharSequence getContentTypeOverride() {
-        return contentTypeOverride;
-    }
-
-    @Override
-    public ByteBuf byteBuf() {
-        // for retry
-        bb.reset();
-        return Unpooled.wrappedBuffer(bb);
-    }
+  private final ByteBuffer bb;
+  private final CharSequence contentTypeOverride;
+  private final long length;
+
+  public NettyByteBufferBody(ByteBuffer bb) {
+    this(bb, null);
+  }
+
+  public NettyByteBufferBody(ByteBuffer bb, CharSequence contentTypeOverride) {
+    this.bb = bb;
+    length = bb.remaining();
+    bb.mark();
+    this.contentTypeOverride = contentTypeOverride;
+  }
+
+  @Override
+  public long getContentLength() {
+    return length;
+  }
+
+  @Override
+  public CharSequence getContentTypeOverride() {
+    return contentTypeOverride;
+  }
+
+  @Override
+  public ByteBuf byteBuf() {
+    // for retry
+    bb.reset();
+    return Unpooled.wrappedBuffer(bb);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
index 3ec8ab3dd..bf7085c6a 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
@@ -20,25 +20,25 @@
 
 public class NettyCompositeByteArrayBody extends NettyDirectBody {
 
-    private final byte[][] bytes;
-    private final long contentLength;
+  private final byte[][] bytes;
+  private final long contentLength;
 
-    public NettyCompositeByteArrayBody(List<byte[]> bytes) {
-        this.bytes = new byte[bytes.size()][];
-        bytes.toArray(this.bytes);
-        long l = 0;
-        for (byte[] b : bytes)
-            l += b.length;
-        contentLength = l;
-    }
+  public NettyCompositeByteArrayBody(List<byte[]> bytes) {
+    this.bytes = new byte[bytes.size()][];
+    bytes.toArray(this.bytes);
+    long l = 0;
+    for (byte[] b : bytes)
+      l += b.length;
+    contentLength = l;
+  }
 
-    @Override
-    public long getContentLength() {
-        return contentLength;
-    }
+  @Override
+  public long getContentLength() {
+    return contentLength;
+  }
 
-    @Override
-    public ByteBuf byteBuf() {
-        return Unpooled.wrappedBuffer(bytes);
-    }
+  @Override
+  public ByteBuf byteBuf() {
+    return Unpooled.wrappedBuffer(bytes);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
index caa8fbefb..9d4eacb16 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
@@ -15,17 +15,14 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
-
-import java.io.IOException;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 
 public abstract class NettyDirectBody implements NettyBody {
 
-    public abstract ByteBuf byteBuf();
+  public abstract ByteBuf byteBuf();
 
-    @Override
-    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
-    }
+  @Override
+  public void write(Channel channel, NettyResponseFuture<?> future) {
+    throw new UnsupportedOperationException("This kind of body is supposed to be written directly");
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
index 4710166d6..db6591fb6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
@@ -17,61 +17,56 @@
 import io.netty.channel.DefaultFileRegion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedNioFile;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.WriteProgressListener;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.request.WriteProgressListener;
-
 public class NettyFileBody implements NettyBody {
 
-    private final File file;
-    private final long offset;
-    private final long length;
-    private final AsyncHttpClientConfig config;
+  private final File file;
+  private final long offset;
+  private final long length;
+  private final AsyncHttpClientConfig config;
 
-    public NettyFileBody(File file, AsyncHttpClientConfig config) {
-        this(file, 0, file.length(), config);
-    }
+  public NettyFileBody(File file, AsyncHttpClientConfig config) {
+    this(file, 0, file.length(), config);
+  }
 
-    public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
-        if (!file.isFile()) {
-            throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
-        }
-        this.file = file;
-        this.offset = offset;
-        this.length = length;
-        this.config = config;
+  public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
+    if (!file.isFile()) {
+      throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
     }
+    this.file = file;
+    this.offset = offset;
+    this.length = length;
+    this.config = config;
+  }
 
-    public File getFile() {
-        return file;
-    }
+  public File getFile() {
+    return file;
+  }
 
-    public long getOffset() {
-        return offset;
-    }
+  @Override
+  public long getContentLength() {
+    return length;
+  }
 
-    @Override
-    public long getContentLength() {
-        return length;
-    }
-
-    @Override
-    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        @SuppressWarnings("resource")
-        // netty will close the FileChannel
-        FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
-        boolean noZeroCopy = ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy();
-        Object body = noZeroCopy ? new ChunkedNioFile(fileChannel, offset, length, config.getChunkedFileChunkSize()) : new DefaultFileRegion(fileChannel, offset, length);
+  @Override
+  public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+    @SuppressWarnings("resource")
+    // netty will close the FileChannel
+            FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
+    boolean noZeroCopy = ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy();
+    Object body = noZeroCopy ? new ChunkedNioFile(fileChannel, offset, length, config.getChunkedFileChunkSize()) : new DefaultFileRegion(fileChannel, offset, length);
 
-        channel.write(body, channel.newProgressivePromise())//
-                .addListener(new WriteProgressListener(future, false, length));
-        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
-    }
+    channel.write(body, channel.newProgressivePromise())
+            .addListener(new WriteProgressListener(future, false, length));
+    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
index b267a7a82..8afc38703 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
@@ -13,68 +13,67 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.request.WriteProgressListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedStream;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.WriteProgressListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.io.InputStream;
 
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 public class NettyInputStreamBody implements NettyBody {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
 
-    private final InputStream inputStream;
-    private final long contentLength;
+  private final InputStream inputStream;
+  private final long contentLength;
 
-    public NettyInputStreamBody(InputStream inputStream) {
-        this(inputStream, -1L);
-    }
+  public NettyInputStreamBody(InputStream inputStream) {
+    this(inputStream, -1L);
+  }
 
-    public NettyInputStreamBody(InputStream inputStream, long contentLength) {
-        this.inputStream = inputStream;
-        this.contentLength = contentLength;
-    }
+  public NettyInputStreamBody(InputStream inputStream, long contentLength) {
+    this.inputStream = inputStream;
+    this.contentLength = contentLength;
+  }
 
-    public InputStream getInputStream() {
-        return inputStream;
-    }
-
-    @Override
-    public long getContentLength() {
-        return contentLength;
-    }
+  public InputStream getInputStream() {
+    return inputStream;
+  }
 
-    @Override
-    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        final InputStream is = inputStream;
+  @Override
+  public long getContentLength() {
+    return contentLength;
+  }
 
-        if (future.isStreamConsumed()) {
-            if (is.markSupported())
-                is.reset();
-            else {
-                LOGGER.warn("Stream has already been consumed and cannot be reset");
-                return;
-            }
-        } else {
-            future.setStreamConsumed(true);
-        }
+  @Override
+  public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+    final InputStream is = inputStream;
 
-        channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
-                new WriteProgressListener(future, false, getContentLength()) {
-                    public void operationComplete(ChannelProgressiveFuture cf) {
-                        closeSilently(is);
-                        super.operationComplete(cf);
-                    }
-                });
-        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+    if (future.isStreamConsumed()) {
+      if (is.markSupported())
+        is.reset();
+      else {
+        LOGGER.warn("Stream has already been consumed and cannot be reset");
+        return;
+      }
+    } else {
+      future.setStreamConsumed(true);
     }
+
+    channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
+            new WriteProgressListener(future, false, getContentLength()) {
+              public void operationComplete(ChannelProgressiveFuture cf) {
+                closeSilently(is);
+                super.operationComplete(cf);
+              }
+            });
+    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
index 00c461263..142e10d6d 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
@@ -13,30 +13,30 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.request.body.multipart.MultipartUtils.newMultipartBody;
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.List;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.request.body.multipart.MultipartBody;
 import org.asynchttpclient.request.body.multipart.Part;
 
+import java.util.List;
+
+import static org.asynchttpclient.request.body.multipart.MultipartUtils.newMultipartBody;
+
 public class NettyMultipartBody extends NettyBodyBody {
 
-    private final String contentTypeOverride;
+  private final String contentTypeOverride;
 
-    public NettyMultipartBody(List<Part> parts, HttpHeaders headers, AsyncHttpClientConfig config) {
-        this(newMultipartBody(parts, headers), config);
-    }
+  public NettyMultipartBody(List<Part> parts, HttpHeaders headers, AsyncHttpClientConfig config) {
+    this(newMultipartBody(parts, headers), config);
+  }
 
-    private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
-        super(body, config);
-        contentTypeOverride = body.getContentType();
-    }
+  private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
+    super(body, config);
+    contentTypeOverride = body.getContentType();
+  }
 
-    @Override
-    public String getContentTypeOverride() {
-        return contentTypeOverride;
-    }
+  @Override
+  public String getContentTypeOverride() {
+    return contentTypeOverride;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
index 9002e600e..d3dd3f549 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -12,15 +12,12 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import com.typesafe.netty.HandlerSubscriber;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
-
-import java.io.IOException;
-import java.util.NoSuchElementException;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -28,100 +25,126 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.typesafe.netty.HandlerSubscriber;
+import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 
 public class NettyReactiveStreamsBody implements NettyBody {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
-    private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
+  private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
+
+  private final Publisher<ByteBuf> publisher;
+
+  private final long contentLength;
+
+  public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
+    this.publisher = publisher;
+    this.contentLength = contentLength;
+  }
+
+  @Override
+  public long getContentLength() {
+    return contentLength;
+  }
+
+  @Override
+  public void write(Channel channel, NettyResponseFuture<?> future) {
+    if (future.isStreamConsumed()) {
+      LOGGER.warn("Stream has already been consumed and cannot be reset");
+    } else {
+      future.setStreamConsumed(true);
+      NettySubscriber subscriber = new NettySubscriber(channel, future);
+      channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
+      publisher.subscribe(new SubscriberAdapter(subscriber));
+      subscriber.delayedStart();
+    }
+  }
 
-    private final Publisher<ByteBuf> publisher;
+  private static class SubscriberAdapter implements Subscriber<ByteBuf> {
+    private final Subscriber<HttpContent> subscriber;
 
-    private final long contentLength;
+    SubscriberAdapter(Subscriber<HttpContent> subscriber) {
+      this.subscriber = subscriber;
+    }
 
-    public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
-        this.publisher = publisher;
-        this.contentLength = contentLength;
+    @Override
+    public void onSubscribe(Subscription s) {
+      subscriber.onSubscribe(s);
     }
 
     @Override
-    public long getContentLength() {
-        return contentLength;
+    public void onNext(ByteBuf buffer) {
+      HttpContent content = new DefaultHttpContent(buffer);
+      subscriber.onNext(content);
     }
 
     @Override
-    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        if (future.isStreamConsumed()) {
-            LOGGER.warn("Stream has already been consumed and cannot be reset");
-        } else {
-            future.setStreamConsumed(true);
-            NettySubscriber subscriber = new NettySubscriber(channel, future);
-            channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
-            publisher.subscribe(new SubscriberAdapter(subscriber));
-        }
+    public void onError(Throwable t) {
+      subscriber.onError(t);
     }
 
-    private static class SubscriberAdapter implements Subscriber<ByteBuf> {
-        private final Subscriber<HttpContent> subscriber;
-
-        public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
-            this.subscriber = subscriber;
-        }
-
-        @Override
-        public void onSubscribe(Subscription s) {
-            subscriber.onSubscribe(s);
-        }
-
-        @Override
-        public void onNext(ByteBuf buffer) {
-            HttpContent content = new DefaultHttpContent(buffer);
-            subscriber.onNext(content);
-        }
-
-        @Override
-        public void onError(Throwable t) {
-            subscriber.onError(t);
-        }
-
-        @Override
-        public void onComplete() {
-            subscriber.onComplete();
-        }
+    @Override
+    public void onComplete() {
+      subscriber.onComplete();
+    }
+  }
+
+  private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
+
+    private static final Subscription DO_NOT_DELAY = new Subscription() {
+      public void cancel() {}
+      public void request(long l) {}
+    };
+      
+    private final Channel channel;
+    private final NettyResponseFuture<?> future;
+    private AtomicReference<Subscription> deferredSubscription = new AtomicReference<>();      
+
+    NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
+      super(channel.eventLoop());
+      this.channel = channel;
+      this.future = future;
+    }
+
+    @Override
+    protected void complete() {
+      channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
+              .addListener(future -> removeFromPipeline()));
+    }
+
+    @Override
+    public void onSubscribe(Subscription subscription) {
+      if (!deferredSubscription.compareAndSet(null, subscription)) {
+        super.onSubscribe(subscription);
+      }
+    }
+
+    void delayedStart() {
+      // If we won the race against onSubscribe, we need to tell it
+      // know not to delay, because we won't be called again.
+      Subscription subscription = deferredSubscription.getAndSet(DO_NOT_DELAY);
+      if (subscription != null) {
+        super.onSubscribe(subscription);
+      }
+    }
+
+    @Override
+    protected void error(Throwable error) {
+      assertNotNull(error, "error");
+      removeFromPipeline();
+      future.abort(error);
     }
 
-    private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
-        private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
-
-        private final Channel channel;
-        private final NettyResponseFuture<?> future;
-
-        public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
-            super(channel.eventLoop());
-            this.channel = channel;
-            this.future = future;
-        }
-
-        @Override
-        protected void complete() {
-            channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(future -> removeFromPipeline()));
-        }
-
-        @Override
-        protected void error(Throwable error) {
-            if (error == null)
-                throw null;
-            removeFromPipeline();
-            future.abort(error);
-        }
-
-        private void removeFromPipeline() {
-            try {
-                channel.pipeline().remove(this);
-                LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
-            } catch (NoSuchElementException e) {
-                LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
-            }
-        }
+    private void removeFromPipeline() {
+      try {
+        channel.pipeline().remove(this);
+        LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
+      } catch (NoSuchElementException e) {
+        LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
+      }
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
index 5a35ac334..60b14b56e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
@@ -13,72 +13,75 @@
  */
 package org.asynchttpclient.netty.ssl;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBufAllocator;
+import io.netty.handler.ssl.IdentityCipherSuiteFilter;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.SslProvider;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
-
-import java.util.Arrays;
+import org.asynchttpclient.AsyncHttpClientConfig;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLException;
+import java.util.Arrays;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 public class DefaultSslEngineFactory extends SslEngineFactoryBase {
 
-    private volatile SslContext sslContext;
+  private volatile SslContext sslContext;
 
-    private SslContext buildSslContext(AsyncHttpClientConfig config) throws SSLException {
-        if (config.getSslContext() != null) {
-            return config.getSslContext();
-        }
-
-        SslContextBuilder sslContextBuilder = SslContextBuilder.forClient()//
-                .sslProvider(config.isUseOpenSsl() ? SslProvider.OPENSSL : SslProvider.JDK)//
-                .sessionCacheSize(config.getSslSessionCacheSize())//
-                .sessionTimeout(config.getSslSessionTimeout());
-
-        if (isNonEmpty(config.getEnabledProtocols())) {
-            sslContextBuilder.protocols(config.getEnabledProtocols());
-        }
-
-        if (isNonEmpty(config.getEnabledCipherSuites())) {
-            sslContextBuilder.ciphers(Arrays.asList(config.getEnabledCipherSuites()));
-        }
-
-        if (config.isUseInsecureTrustManager()) {
-            sslContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);
-        }
-
-        return configureSslContextBuilder(sslContextBuilder).build();
+  private SslContext buildSslContext(AsyncHttpClientConfig config) throws SSLException {
+    if (config.getSslContext() != null) {
+      return config.getSslContext();
     }
 
-    @Override
-    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
-        // FIXME should be using ctx allocator
-        SSLEngine sslEngine = sslContext.newEngine(ByteBufAllocator.DEFAULT, peerHost, peerPort);
-        configureSslEngine(sslEngine, config);
-        return sslEngine;
+    SslContextBuilder sslContextBuilder = SslContextBuilder.forClient()
+            .sslProvider(config.isUseOpenSsl() ? SslProvider.OPENSSL : SslProvider.JDK)
+            .sessionCacheSize(config.getSslSessionCacheSize())
+            .sessionTimeout(config.getSslSessionTimeout());
+
+    if (isNonEmpty(config.getEnabledProtocols())) {
+      sslContextBuilder.protocols(config.getEnabledProtocols());
     }
 
-    @Override
-    public void init(AsyncHttpClientConfig config) throws SSLException {
-        sslContext = buildSslContext(config);
+    if (isNonEmpty(config.getEnabledCipherSuites())) {
+      sslContextBuilder.ciphers(Arrays.asList(config.getEnabledCipherSuites()));
+    } else if (!config.isFilterInsecureCipherSuites()) {
+      sslContextBuilder.ciphers(null, IdentityCipherSuiteFilter.INSTANCE_DEFAULTING_TO_SUPPORTED_CIPHERS);
     }
 
-    /**
-     * The last step of configuring the SslContextBuilder used to create an SslContext when no context is provided in the {@link AsyncHttpClientConfig}. This defaults to no-op and
-     * is intended to be overridden as needed.
-     *
-     * @param builder builder with normal configuration applied
-     * @return builder to be used to build context (can be the same object as the input)
-     */
-    protected SslContextBuilder configureSslContextBuilder(SslContextBuilder builder) {
-        // default to no op
-        return builder;
+    if (config.isUseInsecureTrustManager()) {
+      sslContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);
     }
 
+    return configureSslContextBuilder(sslContextBuilder).build();
+  }
+
+  @Override
+  public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+    SSLEngine sslEngine =
+      config.isDisableHttpsEndpointIdentificationAlgorithm() ?
+        sslContext.newEngine(ByteBufAllocator.DEFAULT) :
+        sslContext.newEngine(ByteBufAllocator.DEFAULT, domain(peerHost), peerPort);
+    configureSslEngine(sslEngine, config);
+    return sslEngine;
+  }
+
+  @Override
+  public void init(AsyncHttpClientConfig config) throws SSLException {
+    sslContext = buildSslContext(config);
+  }
+
+  /**
+   * The last step of configuring the SslContextBuilder used to create an SslContext when no context is provided in the {@link AsyncHttpClientConfig}. This defaults to no-op and
+   * is intended to be overridden as needed.
+   *
+   * @param builder builder with normal configuration applied
+   * @return builder to be used to build context (can be the same object as the input)
+   */
+  protected SslContextBuilder configureSslContextBuilder(SslContextBuilder builder) {
+    // default to no op
+    return builder;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
index aa05d0262..1725d3565 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
@@ -13,23 +13,23 @@
  */
 package org.asynchttpclient.netty.ssl;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-
 public class JsseSslEngineFactory extends SslEngineFactoryBase {
 
-    private final SSLContext sslContext;
+  private final SSLContext sslContext;
 
-    public JsseSslEngineFactory(SSLContext sslContext) {
-        this.sslContext = sslContext;
-    }
+  public JsseSslEngineFactory(SSLContext sslContext) {
+    this.sslContext = sslContext;
+  }
 
-    @Override
-    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
-        SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
-        configureSslEngine(sslEngine, config);
-        return sslEngine;
-    }
+  @Override
+  public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+    SSLEngine sslEngine = sslContext.createSSLEngine(domain(peerHost), peerPort);
+    configureSslEngine(sslEngine, config);
+    return sslEngine;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
index c4722b127..d95237ac9 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
@@ -13,20 +13,27 @@
  */
 package org.asynchttpclient.netty.ssl;
 
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLParameters;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.SslEngineFactory;
 
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLParameters;
+
 public abstract class SslEngineFactoryBase implements SslEngineFactory {
 
-    protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
-        sslEngine.setUseClientMode(true);
-        if (!config.isDisableHttpsEndpointIdentificationAlgorithm()) {
-            SSLParameters params = sslEngine.getSSLParameters();
-            params.setEndpointIdentificationAlgorithm("HTTPS");
-            sslEngine.setSSLParameters(params);
-        }
+  protected String domain(String hostname) {
+    int fqdnLength = hostname.length() - 1;
+    return hostname.charAt(fqdnLength) == '.' ?
+            hostname.substring(0, fqdnLength) :
+            hostname;
+  }
+
+  protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
+    sslEngine.setUseClientMode(true);
+    if (!config.isDisableHttpsEndpointIdentificationAlgorithm()) {
+      SSLParameters params = sslEngine.getSSLParameters();
+      params.setEndpointIdentificationAlgorithm("HTTPS");
+      sslEngine.setSSLParameters(params);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index a91a8ea1b..5aebed9f8 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -13,54 +13,53 @@
  */
 package org.asynchttpclient.netty.timeout;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.util.StringBuilderPool;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+
 public class ReadTimeoutTimerTask extends TimeoutTimerTask {
 
-    private final long readTimeout;
+  private final long readTimeout;
 
-    public ReadTimeoutTimerTask(//
-            NettyResponseFuture<?> nettyResponseFuture,//
-            NettyRequestSender requestSender,//
-            TimeoutsHolder timeoutsHolder,//
-            int readTimeout) {
-        super(nettyResponseFuture, requestSender, timeoutsHolder);
-        this.readTimeout = readTimeout;
-    }
+  ReadTimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture,
+                       NettyRequestSender requestSender,
+                       TimeoutsHolder timeoutsHolder,
+                       int readTimeout) {
+    super(nettyResponseFuture, requestSender, timeoutsHolder);
+    this.readTimeout = readTimeout;
+  }
+
+  public void run(Timeout timeout) {
 
-    public void run(Timeout timeout) throws Exception {
+    if (done.getAndSet(true) || requestSender.isClosed())
+      return;
 
-        if (done.getAndSet(true) || requestSender.isClosed())
-            return;
-        
-        if (nettyResponseFuture.isDone()) {
-            timeoutsHolder.cancel();
-            return;
-        }
+    if (nettyResponseFuture.isDone()) {
+      timeoutsHolder.cancel();
+      return;
+    }
 
-        long now = unpreciseMillisTime();
+    long now = unpreciseMillisTime();
 
-        long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
-        long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
+    long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
+    long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
 
-        if (durationBeforeCurrentReadTimeout <= 0L) {
-            // idleConnectTimeout reached
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Read timeout to ");
-            appendRemoteAddress(sb);
-            String message = sb.append(" after ").append(readTimeout).append(" ms").toString();
-            long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
-            expire(message, durationSinceLastTouch);
-            // cancel request timeout sibling
-            timeoutsHolder.cancel();
+    if (durationBeforeCurrentReadTimeout <= 0L) {
+      // idleConnectTimeout reached
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Read timeout to ");
+      appendRemoteAddress(sb);
+      String message = sb.append(" after ").append(readTimeout).append(" ms").toString();
+      long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
+      expire(message, durationSinceLastTouch);
+      // cancel request timeout sibling
+      timeoutsHolder.cancel();
 
-        } else {
-            done.set(false);
-            timeoutsHolder.startReadTimeout(this);
-        }
+    } else {
+      done.set(false);
+      timeoutsHolder.startReadTimeout(this);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index b8b67be3d..ea8cef4f1 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -13,41 +13,40 @@
  */
 package org.asynchttpclient.netty.timeout;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.util.StringBuilderPool;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+
 public class RequestTimeoutTimerTask extends TimeoutTimerTask {
 
-    private final long requestTimeout;
+  private final long requestTimeout;
 
-    public RequestTimeoutTimerTask(//
-            NettyResponseFuture<?> nettyResponseFuture,//
-            NettyRequestSender requestSender,//
-            TimeoutsHolder timeoutsHolder,//
-            int requestTimeout) {
-        super(nettyResponseFuture, requestSender, timeoutsHolder);
-        this.requestTimeout = requestTimeout;
-    }
+  RequestTimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture,
+                                 NettyRequestSender requestSender,
+                                 TimeoutsHolder timeoutsHolder,
+                                 int requestTimeout) {
+    super(nettyResponseFuture, requestSender, timeoutsHolder);
+    this.requestTimeout = requestTimeout;
+  }
 
-    public void run(Timeout timeout) throws Exception {
+  public void run(Timeout timeout) {
 
-        if (done.getAndSet(true) || requestSender.isClosed())
-            return;
+    if (done.getAndSet(true) || requestSender.isClosed())
+      return;
 
-        // in any case, cancel possible readTimeout sibling
-        timeoutsHolder.cancel();
+    // in any case, cancel possible readTimeout sibling
+    timeoutsHolder.cancel();
 
-        if (nettyResponseFuture.isDone())
-            return;
+    if (nettyResponseFuture.isDone())
+      return;
 
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Request timeout to ");
-        appendRemoteAddress(sb);
-        String message =  sb.append(" after ").append(requestTimeout).append(" ms").toString();
-        long age = unpreciseMillisTime() - nettyResponseFuture.getStart();
-        expire(message, age);
-    }
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Request timeout to ");
+    appendRemoteAddress(sb);
+    String message = sb.append(" after ").append(requestTimeout).append(" ms").toString();
+    long age = unpreciseMillisTime() - nettyResponseFuture.getStart();
+    expire(message, age);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index a0f468852..e746adfdb 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -14,52 +14,51 @@
 package org.asynchttpclient.netty.timeout;
 
 import io.netty.util.TimerTask;
-
-import java.net.InetSocketAddress;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.InetSocketAddress;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 public abstract class TimeoutTimerTask implements TimerTask {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
 
-    protected final AtomicBoolean done = new AtomicBoolean();
-    protected volatile NettyResponseFuture<?> nettyResponseFuture;
-    protected final NettyRequestSender requestSender;
-    protected final TimeoutsHolder timeoutsHolder;
+  protected final AtomicBoolean done = new AtomicBoolean();
+  protected final NettyRequestSender requestSender;
+  final TimeoutsHolder timeoutsHolder;
+  volatile NettyResponseFuture<?> nettyResponseFuture;
 
-    public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
-        this.nettyResponseFuture = nettyResponseFuture;
-        this.requestSender = requestSender;
-        this.timeoutsHolder = timeoutsHolder;
-    }
+  TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
+    this.nettyResponseFuture = nettyResponseFuture;
+    this.requestSender = requestSender;
+    this.timeoutsHolder = timeoutsHolder;
+  }
 
-    protected void expire(String message, long time) {
-        LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
-        requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
-    }
+  void expire(String message, long time) {
+    LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
+    requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
+  }
 
-    /**
-     * When the timeout is cancelled, it could still be referenced for quite some time in the Timer. Holding a reference to the future might mean holding a reference to the
-     * channel, and heavy objects such as SslEngines
-     */
-    public void clean() {
-        if (done.compareAndSet(false, true)) {
-            nettyResponseFuture = null;
-        }
+  /**
+   * When the timeout is cancelled, it could still be referenced for quite some time in the Timer. Holding a reference to the future might mean holding a reference to the
+   * channel, and heavy objects such as SslEngines
+   */
+  public void clean() {
+    if (done.compareAndSet(false, true)) {
+      nettyResponseFuture = null;
     }
+  }
 
-    protected void appendRemoteAddress(StringBuilder sb) {
-        InetSocketAddress remoteAddress = timeoutsHolder.remoteAddress();
-        sb.append(remoteAddress.getHostName());
-        if (!remoteAddress.isUnresolved()) {
-            sb.append('/').append(remoteAddress.getAddress().getHostAddress());
-        }
-        sb.append(':').append(remoteAddress.getPort());
+  void appendRemoteAddress(StringBuilder sb) {
+    InetSocketAddress remoteAddress = timeoutsHolder.remoteAddress();
+    sb.append(remoteAddress.getHostName());
+    if (!remoteAddress.isUnresolved()) {
+      sb.append('/').append(remoteAddress.getAddress().getHostAddress());
     }
+    sb.append(':').append(remoteAddress.getPort());
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
index 57e01c372..89d3faf58 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
@@ -13,102 +13,100 @@
  */
 package org.asynchttpclient.netty.timeout;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
 import io.netty.util.TimerTask;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.request.NettyRequestSender;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 
 public class TimeoutsHolder {
 
-    private final AtomicBoolean cancelled = new AtomicBoolean();
-
-    private final Timer nettyTimer;
-    private final NettyRequestSender requestSender;
-    private final long requestTimeoutMillisTime;
-    private final int readTimeoutValue;
-
-    private volatile NettyResponseFuture<?> nettyResponseFuture;
-    public final Timeout requestTimeout;
-    public volatile Timeout readTimeout;
-    private volatile InetSocketAddress remoteAddress;
-
-    public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config, InetSocketAddress originalRemoteAddress) {
-        this.nettyTimer = nettyTimer;
-        this.nettyResponseFuture = nettyResponseFuture;
-        this.requestSender = requestSender;
-        this.remoteAddress = originalRemoteAddress;
-
-        final Request targetRequest = nettyResponseFuture.getTargetRequest();
-
-        final int readTimeoutInMs = targetRequest.getReadTimeout();
-        this.readTimeoutValue = readTimeoutInMs == 0 ? config.getReadTimeout() : readTimeoutInMs;
-
-        int requestTimeoutInMs = targetRequest.getRequestTimeout();
-        if (requestTimeoutInMs == 0) {
-            requestTimeoutInMs = config.getRequestTimeout();
-        }
-
-        if (requestTimeoutInMs != -1) {
-            requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;
-            requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);
-        } else {
-            requestTimeoutMillisTime = -1L;
-            requestTimeout = null;
-        }
+  private final Timeout requestTimeout;
+  private final AtomicBoolean cancelled = new AtomicBoolean();
+  private final Timer nettyTimer;
+  private final NettyRequestSender requestSender;
+  private final long requestTimeoutMillisTime;
+  private final int readTimeoutValue;
+  private volatile Timeout readTimeout;
+  private volatile NettyResponseFuture<?> nettyResponseFuture;
+  private volatile InetSocketAddress remoteAddress;
+
+  public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config, InetSocketAddress originalRemoteAddress) {
+    this.nettyTimer = nettyTimer;
+    this.nettyResponseFuture = nettyResponseFuture;
+    this.requestSender = requestSender;
+    this.remoteAddress = originalRemoteAddress;
+
+    final Request targetRequest = nettyResponseFuture.getTargetRequest();
+
+    final int readTimeoutInMs = targetRequest.getReadTimeout();
+    this.readTimeoutValue = readTimeoutInMs == 0 ? config.getReadTimeout() : readTimeoutInMs;
+
+    int requestTimeoutInMs = targetRequest.getRequestTimeout();
+    if (requestTimeoutInMs == 0) {
+      requestTimeoutInMs = config.getRequestTimeout();
     }
 
-    public void setResolvedRemoteAddress(InetSocketAddress address) {
-        remoteAddress = address;
+    if (requestTimeoutInMs != -1) {
+      requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;
+      requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);
+    } else {
+      requestTimeoutMillisTime = -1L;
+      requestTimeout = null;
     }
+  }
 
-    InetSocketAddress remoteAddress() {
-        return remoteAddress;
-    }
+  public void setResolvedRemoteAddress(InetSocketAddress address) {
+    remoteAddress = address;
+  }
 
-    public void startReadTimeout() {
-        if (readTimeoutValue != -1) {
-            startReadTimeout(null);
-        }
-    }
+  InetSocketAddress remoteAddress() {
+    return remoteAddress;
+  }
 
-    void startReadTimeout(ReadTimeoutTimerTask task) {
-        if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {
-            // only schedule a new readTimeout if the requestTimeout doesn't happen first
-            if (task == null) {
-                // first call triggered from outside (else is read timeout is re-scheduling itself)
-                task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);
-            }
-            this.readTimeout = newTimeout(task, readTimeoutValue);
-
-        } else if (task != null) {
-            // read timeout couldn't re-scheduling itself, clean up
-            task.clean();
-        }
+  public void startReadTimeout() {
+    if (readTimeoutValue != -1) {
+      startReadTimeout(null);
     }
-
-    public void cancel() {
-        if (cancelled.compareAndSet(false, true)) {
-            if (requestTimeout != null) {
-                requestTimeout.cancel();
-                RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
-            }
-            if (readTimeout != null) {
-                readTimeout.cancel();
-                ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
-            }
-        }
+  }
+
+  void startReadTimeout(ReadTimeoutTimerTask task) {
+    if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {
+      // only schedule a new readTimeout if the requestTimeout doesn't happen first
+      if (task == null) {
+        // first call triggered from outside (else is read timeout is re-scheduling itself)
+        task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);
+      }
+      this.readTimeout = newTimeout(task, readTimeoutValue);
+
+    } else if (task != null) {
+      // read timeout couldn't re-scheduling itself, clean up
+      task.clean();
     }
-
-    private Timeout newTimeout(TimerTask task, long delay) {
-        return requestSender.isClosed() ? null : nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+  }
+
+  public void cancel() {
+    if (cancelled.compareAndSet(false, true)) {
+      if (requestTimeout != null) {
+        requestTimeout.cancel();
+        RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
+      }
+      if (readTimeout != null) {
+        readTimeout.cancel();
+        ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
+      }
     }
+  }
+
+  private Timeout newTimeout(TimerTask task, long delay) {
+    return requestSender.isClosed() ? null : nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index c4f053e05..531eaadd8 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -13,27 +13,12 @@
  */
 package org.asynchttpclient.netty.ws;
 
-import static io.netty.buffer.Unpooled.wrappedBuffer;
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.WebSocketFrame;
+import io.netty.handler.codec.http.websocketx.*;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
-
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.util.Utf8ByteBufCharsetDecoder;
 import org.asynchttpclient.ws.WebSocket;
@@ -41,312 +26,321 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class NettyWebSocket implements WebSocket {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
-
-    protected final Channel channel;
-    protected final HttpHeaders upgradeHeaders;
-    protected final Collection<WebSocketListener> listeners;
-    // no need for volatile because only mutated in IO thread
-    private boolean ready;
-    private List<WebSocketFrame> bufferedFrames;
-    protected FragmentedFrameType expectedFragmentedFrameType;
-
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
-        this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
-    }
-
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
-        this.channel = channel;
-        this.upgradeHeaders = upgradeHeaders;
-        this.listeners = listeners;
-    }
-
-    @Override
-    public HttpHeaders getUpgradeHeaders() {
-        return upgradeHeaders;
-    }
-
-    @Override
-    public SocketAddress getRemoteAddress() {
-        return channel.remoteAddress();
-    }
-
-    @Override
-    public SocketAddress getLocalAddress() {
-        return channel.localAddress();
-    }
-
-    @Override
-    public Future<Void> sendTextFrame(String message) {
-        return sendTextFrame(message, true, 0);
-    }
-
-    @Override
-    public Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv) {
-        return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
-    }
-
-    @Override
-    public Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-        return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
-    }
-
-    @Override
-    public Future<Void> sendBinaryFrame(byte[] payload) {
-        return sendBinaryFrame(payload, true, 0);
-    }
-
-    @Override
-    public Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
-        return sendBinaryFrame(wrappedBuffer(payload), finalFragment, rsv);
-    }
-
-    @Override
-    public Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-        return channel.writeAndFlush(new BinaryWebSocketFrame(payload));
-    }
-
-    @Override
-    public Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv) {
-        return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
-    }
-
-    @Override
-    public Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv) {
-        return sendContinuationFrame(wrappedBuffer(payload), finalFragment, rsv);
-    }
-
-    @Override
-    public Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-        return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
-    }
-
-    @Override
-    public Future<Void> sendPingFrame() {
-        return channel.writeAndFlush(new PingWebSocketFrame());
-    }
-
-    @Override
-    public Future<Void> sendPingFrame(byte[] payload) {
-        return sendPingFrame(wrappedBuffer(payload));
-    }
-
-    @Override
-    public Future<Void> sendPingFrame(ByteBuf payload) {
-        return channel.writeAndFlush(new PingWebSocketFrame(payload));
-    }
-
-    @Override
-    public Future<Void> sendPongFrame() {
-        return channel.writeAndFlush(new PongWebSocketFrame());
-    }
-
-    @Override
-    public Future<Void> sendPongFrame(byte[] payload) {
-        return sendPongFrame(wrappedBuffer(payload));
-    }
-
-    @Override
-    public Future<Void> sendPongFrame(ByteBuf payload) {
-        return channel.writeAndFlush(new PongWebSocketFrame(wrappedBuffer(payload)));
-    }
-
-    @Override
-    public Future<Void> sendCloseFrame() {
-        return sendCloseFrame(1000, "normal closure");
-    }
-
-    @Override
-    public Future<Void> sendCloseFrame(int statusCode, String reasonText) {
-        if (channel.isOpen()) {
-            return channel.writeAndFlush(new CloseWebSocketFrame(1000, "normal closure"));
-        }
-        return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);
-    }
-
-    @Override
-    public boolean isOpen() {
-        return channel.isOpen();
-    }
-
-    @Override
-    public WebSocket addWebSocketListener(WebSocketListener l) {
-        listeners.add(l);
-        return this;
-    }
-
-    @Override
-    public WebSocket removeWebSocketListener(WebSocketListener l) {
-        listeners.remove(l);
-        return this;
-    }
-
-    // INTERNAL, NOT FOR PUBLIC USAGE!!!
-
-    public boolean isReady() {
-        return ready;
-    }
-
-    public void bufferFrame(WebSocketFrame frame) {
-        if (bufferedFrames == null) {
-            bufferedFrames = new ArrayList<>(1);
-        }
-        frame.retain();
-        bufferedFrames.add(frame);
-    }
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
-    private void releaseBufferedFrames() {
-        if (bufferedFrames != null) {
-            for (WebSocketFrame frame : bufferedFrames) {
-                frame.release();
-            }
-            bufferedFrames = null;
-        }
-    }
+import static io.netty.buffer.Unpooled.wrappedBuffer;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 
-    public void processBufferedFrames() {
-        ready = true;
-        if (bufferedFrames != null) {
-            try {
-                for (WebSocketFrame frame : bufferedFrames) {
-                    handleFrame(frame);
-                }
-            } finally {
-                releaseBufferedFrames();
-            }
-            bufferedFrames = null;
+public final class NettyWebSocket implements WebSocket {
+
+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
+
+  protected final Channel channel;
+  private final HttpHeaders upgradeHeaders;
+  private final Collection<WebSocketListener> listeners;
+  private FragmentedFrameType expectedFragmentedFrameType;
+  // no need for volatile because only mutated in IO thread
+  private boolean ready;
+  private List<WebSocketFrame> bufferedFrames;
+
+  public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
+    this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
+  }
+
+  private NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
+    this.channel = channel;
+    this.upgradeHeaders = upgradeHeaders;
+    this.listeners = listeners;
+  }
+
+  @Override
+  public HttpHeaders getUpgradeHeaders() {
+    return upgradeHeaders;
+  }
+
+  @Override
+  public SocketAddress getRemoteAddress() {
+    return channel.remoteAddress();
+  }
+
+  @Override
+  public SocketAddress getLocalAddress() {
+    return channel.localAddress();
+  }
+
+  @Override
+  public Future<Void> sendTextFrame(String message) {
+    return sendTextFrame(message, true, 0);
+  }
+
+  @Override
+  public Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv) {
+    return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
+  }
+
+  @Override
+  public Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+    return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
+  }
+
+  @Override
+  public Future<Void> sendBinaryFrame(byte[] payload) {
+    return sendBinaryFrame(payload, true, 0);
+  }
+
+  @Override
+  public Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
+    return sendBinaryFrame(wrappedBuffer(payload), finalFragment, rsv);
+  }
+
+  @Override
+  public Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+    return channel.writeAndFlush(new BinaryWebSocketFrame(finalFragment, rsv, payload));
+  }
+
+  @Override
+  public Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv) {
+    return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
+  }
+
+  @Override
+  public Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv) {
+    return sendContinuationFrame(wrappedBuffer(payload), finalFragment, rsv);
+  }
+
+  @Override
+  public Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+    return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
+  }
+
+  @Override
+  public Future<Void> sendPingFrame() {
+    return channel.writeAndFlush(new PingWebSocketFrame());
+  }
+
+  @Override
+  public Future<Void> sendPingFrame(byte[] payload) {
+    return sendPingFrame(wrappedBuffer(payload));
+  }
+
+  @Override
+  public Future<Void> sendPingFrame(ByteBuf payload) {
+    return channel.writeAndFlush(new PingWebSocketFrame(payload));
+  }
+
+  @Override
+  public Future<Void> sendPongFrame() {
+    return channel.writeAndFlush(new PongWebSocketFrame());
+  }
+
+  @Override
+  public Future<Void> sendPongFrame(byte[] payload) {
+    return sendPongFrame(wrappedBuffer(payload));
+  }
+
+  @Override
+  public Future<Void> sendPongFrame(ByteBuf payload) {
+    return channel.writeAndFlush(new PongWebSocketFrame(wrappedBuffer(payload)));
+  }
+
+  @Override
+  public Future<Void> sendCloseFrame() {
+    return sendCloseFrame(1000, "normal closure");
+  }
+
+  @Override
+  public Future<Void> sendCloseFrame(int statusCode, String reasonText) {
+    if (channel.isOpen()) {
+      return channel.writeAndFlush(new CloseWebSocketFrame(1000, "normal closure"));
+    }
+    return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);
+  }
+
+  @Override
+  public boolean isOpen() {
+    return channel.isOpen();
+  }
+
+  @Override
+  public WebSocket addWebSocketListener(WebSocketListener l) {
+    listeners.add(l);
+    return this;
+  }
+
+  @Override
+  public WebSocket removeWebSocketListener(WebSocketListener l) {
+    listeners.remove(l);
+    return this;
+  }
+
+  // INTERNAL, NOT FOR PUBLIC USAGE!!!
+
+  public boolean isReady() {
+    return ready;
+  }
+
+  public void bufferFrame(WebSocketFrame frame) {
+    if (bufferedFrames == null) {
+      bufferedFrames = new ArrayList<>(1);
+    }
+    frame.retain();
+    bufferedFrames.add(frame);
+  }
+
+  private void releaseBufferedFrames() {
+    if (bufferedFrames != null) {
+      for (WebSocketFrame frame : bufferedFrames) {
+        frame.release();
+      }
+      bufferedFrames = null;
+    }
+  }
+
+  public void processBufferedFrames() {
+    ready = true;
+    if (bufferedFrames != null) {
+      try {
+        for (WebSocketFrame frame : bufferedFrames) {
+          handleFrame(frame);
         }
+      } finally {
+        releaseBufferedFrames();
+      }
+      bufferedFrames = null;
     }
+  }
 
-    public void handleFrame(WebSocketFrame frame) {
-        if (frame instanceof TextWebSocketFrame) {
-            onTextFrame((TextWebSocketFrame) frame);
+  public void handleFrame(WebSocketFrame frame) {
+    if (frame instanceof TextWebSocketFrame) {
+      onTextFrame((TextWebSocketFrame) frame);
 
-        } else if (frame instanceof BinaryWebSocketFrame) {
-            onBinaryFrame((BinaryWebSocketFrame) frame);
+    } else if (frame instanceof BinaryWebSocketFrame) {
+      onBinaryFrame((BinaryWebSocketFrame) frame);
 
-        } else if (frame instanceof CloseWebSocketFrame) {
-            Channels.setDiscard(channel);
-            CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
-            onClose(closeFrame.statusCode(), closeFrame.reasonText());
-            Channels.silentlyCloseChannel(channel);
+    } else if (frame instanceof CloseWebSocketFrame) {
+      Channels.setDiscard(channel);
+      CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
+      onClose(closeFrame.statusCode(), closeFrame.reasonText());
+      Channels.silentlyCloseChannel(channel);
 
-        } else if (frame instanceof PingWebSocketFrame) {
-            onPingFrame((PingWebSocketFrame) frame);
+    } else if (frame instanceof PingWebSocketFrame) {
+      onPingFrame((PingWebSocketFrame) frame);
 
-        } else if (frame instanceof PongWebSocketFrame) {
-            onPongFrame((PongWebSocketFrame) frame);
+    } else if (frame instanceof PongWebSocketFrame) {
+      onPongFrame((PongWebSocketFrame) frame);
 
-        } else if (frame instanceof ContinuationWebSocketFrame) {
-            onContinuationFrame((ContinuationWebSocketFrame) frame);
-        }
+    } else if (frame instanceof ContinuationWebSocketFrame) {
+      onContinuationFrame((ContinuationWebSocketFrame) frame);
     }
+  }
 
-    public void onError(Throwable t) {
+  public void onError(Throwable t) {
+    try {
+      for (WebSocketListener listener : listeners) {
         try {
-            for (WebSocketListener listener : listeners) {
-                try {
-                    listener.onError(t);
-                } catch (Throwable t2) {
-                    LOGGER.error("WebSocketListener.onError crash", t2);
-                }
-            }
-        } finally {
-            releaseBufferedFrames();
+          listener.onError(t);
+        } catch (Throwable t2) {
+          LOGGER.error("WebSocketListener.onError crash", t2);
         }
+      }
+    } finally {
+      releaseBufferedFrames();
     }
+  }
 
-    public void onClose(int code, String reason) {
+  public void onClose(int code, String reason) {
+    try {
+      for (WebSocketListener l : listeners) {
         try {
-            for (WebSocketListener l : listeners) {
-                try {
-                    l.onClose(this, code, reason);
-                } catch (Throwable t) {
-                    l.onError(t);
-                }
-            }
-            listeners.clear();
-        } finally {
-            releaseBufferedFrames();
+          l.onClose(this, code, reason);
+        } catch (Throwable t) {
+          l.onError(t);
         }
-    }
-
-    @Override
-    public String toString() {
-        return "NettyWebSocket{channel=" + channel + '}';
-    }
-
-    public void onBinaryFrame(BinaryWebSocketFrame frame) {
-        if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
-            expectedFragmentedFrameType = FragmentedFrameType.BINARY;
-        }
-        onBinaryFrame0(frame);
-    }
-
-    private void onBinaryFrame0(WebSocketFrame frame) {
-        byte[] bytes = byteBuf2Bytes(frame.content());
-        for (WebSocketListener listener : listeners) {
-            listener.onBinaryFrame(bytes, frame.isFinalFragment(), frame.rsv());
-        }
-    }
-
-    public void onTextFrame(TextWebSocketFrame frame) {
-        if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
-            expectedFragmentedFrameType = FragmentedFrameType.TEXT;
-        }
-        onTextFrame0(frame);
-    }
-
-    private void onTextFrame0(WebSocketFrame frame) {
-        // faster than frame.text();
-        String text = Utf8ByteBufCharsetDecoder.decodeUtf8(frame.content());
-        frame.isFinalFragment();
-        frame.rsv();
-        for (WebSocketListener listener : listeners) {
-            listener.onTextFrame(text, frame.isFinalFragment(), frame.rsv());
-        }
-    }
-
-    public void onContinuationFrame(ContinuationWebSocketFrame frame) {
-        if (expectedFragmentedFrameType == null) {
-            LOGGER.warn("Received continuation frame without an original text or binary frame, ignoring");
-            return;
-        }
-        try {
-            switch (expectedFragmentedFrameType) {
-            case BINARY:
-                onBinaryFrame0(frame);
-                break;
-            case TEXT:
-                onTextFrame0(frame);
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown FragmentedFrameType " + expectedFragmentedFrameType);
-            }
-        } finally {
-            if (frame.isFinalFragment()) {
-                expectedFragmentedFrameType = null;
-            }
-        }
-    }
-
-    public void onPingFrame(PingWebSocketFrame frame) {
-        byte[] bytes = byteBuf2Bytes(frame.content());
-        for (WebSocketListener listener : listeners) {
-            listener.onPingFrame(bytes);
-        }
-    }
-
-    public void onPongFrame(PongWebSocketFrame frame) {
-        byte[] bytes = byteBuf2Bytes(frame.content());
-        for (WebSocketListener listener : listeners) {
-            listener.onPongFrame(bytes);
-        }
-    }
-
-    private enum FragmentedFrameType {
-        TEXT, BINARY;
-    }
+      }
+      listeners.clear();
+    } finally {
+      releaseBufferedFrames();
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "NettyWebSocket{channel=" + channel + '}';
+  }
+
+  private void onBinaryFrame(BinaryWebSocketFrame frame) {
+    if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
+      expectedFragmentedFrameType = FragmentedFrameType.BINARY;
+    }
+    onBinaryFrame0(frame);
+  }
+
+  private void onBinaryFrame0(WebSocketFrame frame) {
+    byte[] bytes = byteBuf2Bytes(frame.content());
+    for (WebSocketListener listener : listeners) {
+      listener.onBinaryFrame(bytes, frame.isFinalFragment(), frame.rsv());
+    }
+  }
+
+  private void onTextFrame(TextWebSocketFrame frame) {
+    if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
+      expectedFragmentedFrameType = FragmentedFrameType.TEXT;
+    }
+    onTextFrame0(frame);
+  }
+
+  private void onTextFrame0(WebSocketFrame frame) {
+    // faster than frame.text();
+    String text = Utf8ByteBufCharsetDecoder.decodeUtf8(frame.content());
+    frame.isFinalFragment();
+    frame.rsv();
+    for (WebSocketListener listener : listeners) {
+      listener.onTextFrame(text, frame.isFinalFragment(), frame.rsv());
+    }
+  }
+
+  private void onContinuationFrame(ContinuationWebSocketFrame frame) {
+    if (expectedFragmentedFrameType == null) {
+      LOGGER.warn("Received continuation frame without an original text or binary frame, ignoring");
+      return;
+    }
+    try {
+      switch (expectedFragmentedFrameType) {
+        case BINARY:
+          onBinaryFrame0(frame);
+          break;
+        case TEXT:
+          onTextFrame0(frame);
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown FragmentedFrameType " + expectedFragmentedFrameType);
+      }
+    } finally {
+      if (frame.isFinalFragment()) {
+        expectedFragmentedFrameType = null;
+      }
+    }
+  }
+
+  private void onPingFrame(PingWebSocketFrame frame) {
+    byte[] bytes = byteBuf2Bytes(frame.content());
+    for (WebSocketListener listener : listeners) {
+      listener.onPingFrame(bytes);
+    }
+  }
+
+  private void onPongFrame(PongWebSocketFrame frame) {
+    byte[] bytes = byteBuf2Bytes(frame.content());
+    for (WebSocketListener listener : listeners) {
+      listener.onPongFrame(bytes);
+    }
+  }
+
+  private enum FragmentedFrameType {
+    TEXT, BINARY
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
index 3874723bf..06a70b918 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
@@ -27,20 +27,18 @@
 // fork from Apache HttpComponents
 package org.asynchttpclient.ntlm;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
-
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.UnsupportedCharsetException;
 import java.security.Key;
 import java.security.MessageDigest;
 import java.util.Arrays;
+import java.util.Base64;
 import java.util.Locale;
 
-import javax.crypto.Cipher;
-import javax.crypto.spec.SecretKeySpec;
-
-import org.asynchttpclient.util.Base64;
+import static java.nio.charset.StandardCharsets.US_ASCII;
 
 /**
  * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
@@ -763,7 +761,7 @@ private static void oddParity(final byte[] bytes) {
 
         /** Constructor to use when message contents are known */
         NTLMMessage(final String messageBody, final int expectedType) throws NtlmEngineException {
-            messageContents = Base64.decode(messageBody);
+            messageContents = Base64.getDecoder().decode(messageBody);
             // Look for NTLM message
             if (messageContents.length < SIGNATURE.length) {
                 throw new NtlmEngineException("NTLM message decoding error - packet too short");
@@ -901,7 +899,7 @@ String getResponse() {
             } else {
                 resp = messageContents;
             }
-            return Base64.encode(resp);
+            return Base64.getEncoder().encodeToString(resp);
         }
 
     }
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
index 23f005ebf..fe15cffd3 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
@@ -30,28 +30,27 @@
 /**
  * Signals NTLM protocol failure.
  */
-public class NtlmEngineException extends RuntimeException {
+class NtlmEngineException extends RuntimeException {
 
-    private static final long serialVersionUID = 6027981323731768824L;
+  private static final long serialVersionUID = 6027981323731768824L;
 
-    /**
-     * Creates a new NTLMEngineException with the specified message.
-     *
-     * @param message the exception detail message
-     */
-    public NtlmEngineException(String message) {
-        super(message);
-    }
-
-    /**
-     * Creates a new NTLMEngineException with the specified detail message and cause.
-     *
-     * @param message the exception detail message
-     * @param cause   the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
-     *                if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
-     */
-    public NtlmEngineException(String message, Throwable cause) {
-        super(message, cause);
-    }
+  /**
+   * Creates a new NTLMEngineException with the specified message.
+   *
+   * @param message the exception detail message
+   */
+  NtlmEngineException(String message) {
+    super(message);
+  }
 
+  /**
+   * Creates a new NTLMEngineException with the specified detail message and cause.
+   *
+   * @param message the exception detail message
+   * @param cause   the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
+   *                if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
+   */
+  NtlmEngineException(String message, Throwable cause) {
+    super(message, cause);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java b/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
index 5e4aab488..dd193daf4 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
@@ -1,18 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
  *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.oauth;
 
@@ -22,60 +19,25 @@
  * Value class for OAuth consumer keys.
  */
 public class ConsumerKey {
-    private final String key;
-    private final String secret;
-    private final String percentEncodedKey;
-
-    public ConsumerKey(String key, String secret) {
-        this.key = key;
-        this.secret = secret;
-        this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
-    }
-
-    public String getKey() {
-        return key;
-    }
-
-    public String getSecret() {
-        return secret;
-    }
-
-    String getPercentEncodedKey() {
-        return percentEncodedKey;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder("{Consumer key, key=");
-        appendValue(sb, key);
-        sb.append(", secret=");
-        appendValue(sb, secret);
-        sb.append("}");
-        return sb.toString();
-    }
-
-    private void appendValue(StringBuilder sb, String value) {
-        if (value == null) {
-            sb.append("null");
-        } else {
-            sb.append('"');
-            sb.append(value);
-            sb.append('"');
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return key.hashCode() + secret.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o == this)
-            return true;
-        if (o == null || o.getClass() != getClass())
-            return false;
-        ConsumerKey other = (ConsumerKey) o;
-        return key.equals(other.key) && secret.equals(other.secret);
-    }
+  private final String key;
+  private final String secret;
+  private final String percentEncodedKey;
+
+  public ConsumerKey(String key, String secret) {
+    this.key = key;
+    this.secret = secret;
+    this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
+  }
+
+  public String getKey() {
+    return key;
+  }
+
+  public String getSecret() {
+    return secret;
+  }
+
+  public String getPercentEncodedKey() {
+    return percentEncodedKey;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index 2527d7d51..a0235bb5a 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -13,47 +13,53 @@
  */
 package org.asynchttpclient.oauth;
 
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-
+import io.netty.handler.codec.http.HttpHeaderNames;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
 
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
 /**
  * OAuth {@link SignatureCalculator} that delegates to {@link OAuthSignatureCalculatorInstance}s.
  */
 public class OAuthSignatureCalculator implements SignatureCalculator {
 
-    private static final ThreadLocal<OAuthSignatureCalculatorInstance> INSTANCES = new ThreadLocal<OAuthSignatureCalculatorInstance>() {
-        protected OAuthSignatureCalculatorInstance initialValue() {
-            try {
-                return new OAuthSignatureCalculatorInstance();
-            } catch (NoSuchAlgorithmException e) {
-                throw new ExceptionInInitializerError(e);
-            }
-        };
-    };
-
-    private final ConsumerKey consumerAuth;
-
-    private final RequestToken userAuth;
-
-    /**
-     * @param consumerAuth Consumer key to use for signature calculation
-     * @param userAuth Request/access token to use for signature calculation
-     */
-    public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth) {
-        this.consumerAuth = consumerAuth;
-        this.userAuth = userAuth;
+  private static final ThreadLocal<OAuthSignatureCalculatorInstance> INSTANCES = ThreadLocal.withInitial(() -> {
+    try {
+      return new OAuthSignatureCalculatorInstance();
+    } catch (NoSuchAlgorithmException e) {
+      throw new ExceptionInInitializerError(e);
     }
+  });
+
+  private final ConsumerKey consumerAuth;
+
+  private final RequestToken userAuth;
+
+  /**
+   * @param consumerAuth Consumer key to use for signature calculation
+   * @param userAuth     Request/access token to use for signature calculation
+   */
+  public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth) {
+    this.consumerAuth = consumerAuth;
+    this.userAuth = userAuth;
+  }
 
-    @Override
-    public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
-        try {
-            INSTANCES.get().sign(consumerAuth, userAuth, request, requestBuilder);
-        } catch (InvalidKeyException e) {
-            throw new IllegalArgumentException("Failed to compute a valid key from consumer and user secrets", e);
-        }
+  @Override
+  public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
+    try {
+      String authorization = INSTANCES.get().computeAuthorizationHeader(
+        consumerAuth,
+        userAuth,
+        request.getUri(),
+        request.getMethod(),
+        request.getFormParams(),
+        request.getQueryParams());
+      requestBuilder.setHeader(HttpHeaderNames.AUTHORIZATION, authorization);
+    } catch (InvalidKeyException e) {
+      throw new IllegalArgumentException("Failed to compute a valid key from consumer and user secrets", e);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
index 4d171694a..aa92c5aaa 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
@@ -13,181 +13,213 @@
  */
 package org.asynchttpclient.oauth;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import io.netty.handler.codec.http.HttpHeaderNames;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.SignatureCalculator;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StringBuilderPool;
+import org.asynchttpclient.util.StringUtils;
+import org.asynchttpclient.util.Utf8UrlEncoder;
 
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
 import java.nio.ByteBuffer;
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
+import java.util.Base64;
 import java.util.List;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.regex.Pattern;
 
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
-
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilderBase;
-import org.asynchttpclient.SignatureCalculator;
-import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.StringBuilderPool;
-import org.asynchttpclient.util.StringUtils;
-import org.asynchttpclient.util.Utf8UrlEncoder;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * Non thread-safe {@link SignatureCalculator} for OAuth1.
- * 
+ * <p>
  * Supports most common signature inclusion and calculation methods: HMAC-SHA1 for calculation, and Header inclusion as inclusion method. Nonce generation uses simple random
  * numbers with base64 encoding.
  */
-class OAuthSignatureCalculatorInstance {
-
-    private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
-    private static final Pattern PLUS_CHAR_PATTERN = Pattern.compile("+", Pattern.LITERAL);
-    private static final Pattern ENCODED_TILDE_PATTERN = Pattern.compile("%7E", Pattern.LITERAL);
-    private static final String KEY_OAUTH_CONSUMER_KEY = "oauth_consumer_key";
-    private static final String KEY_OAUTH_NONCE = "oauth_nonce";
-    private static final String KEY_OAUTH_SIGNATURE = "oauth_signature";
-    private static final String KEY_OAUTH_SIGNATURE_METHOD = "oauth_signature_method";
-    private static final String KEY_OAUTH_TIMESTAMP = "oauth_timestamp";
-    private static final String KEY_OAUTH_TOKEN = "oauth_token";
-    private static final String KEY_OAUTH_VERSION = "oauth_version";
-    private static final String OAUTH_VERSION_1_0 = "1.0";
-    private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
-    private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
-
-    private final Mac mac;
-    private final byte[] nonceBuffer = new byte[16];
-    private final Parameters parameters = new Parameters();
-
-    public OAuthSignatureCalculatorInstance() throws NoSuchAlgorithmException {
-        mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
+public class OAuthSignatureCalculatorInstance {
+
+  private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
+  private static final Pattern PLUS_CHAR_PATTERN = Pattern.compile("+", Pattern.LITERAL);
+  private static final Pattern ENCODED_TILDE_PATTERN = Pattern.compile("%7E", Pattern.LITERAL);
+  private static final String KEY_OAUTH_CONSUMER_KEY = "oauth_consumer_key";
+  private static final String KEY_OAUTH_NONCE = "oauth_nonce";
+  private static final String KEY_OAUTH_SIGNATURE = "oauth_signature";
+  private static final String KEY_OAUTH_SIGNATURE_METHOD = "oauth_signature_method";
+  private static final String KEY_OAUTH_TIMESTAMP = "oauth_timestamp";
+  private static final String KEY_OAUTH_TOKEN = "oauth_token";
+  private static final String KEY_OAUTH_VERSION = "oauth_version";
+  private static final String OAUTH_VERSION_1_0 = "1.0";
+  private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
+  private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
+
+  private final Mac mac;
+  private final byte[] nonceBuffer = new byte[16];
+  private final Parameters parameters = new Parameters();
+
+  public OAuthSignatureCalculatorInstance() throws NoSuchAlgorithmException {
+    mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
+  }
+
+  public String computeAuthorizationHeader(ConsumerKey consumerAuth,
+                                           RequestToken userAuth,
+                                           Uri uri,
+                                           String method,
+                                           List<Param> formParams,
+                                           List<Param> queryParams) throws InvalidKeyException {
+    String nonce = generateNonce();
+    long timestamp = generateTimestamp();
+    return computeAuthorizationHeader(consumerAuth, userAuth, uri, method, formParams, queryParams, timestamp, nonce);
+  }
+
+  private String generateNonce() {
+    ThreadLocalRandom.current().nextBytes(nonceBuffer);
+    // let's use base64 encoding over hex, slightly more compact than hex or decimals
+    return Base64.getEncoder().encodeToString(nonceBuffer);
+  }
+
+  private static long generateTimestamp() {
+    return System.currentTimeMillis() / 1000L;
+  }
+
+  String computeAuthorizationHeader(ConsumerKey consumerAuth,
+                                    RequestToken userAuth,
+                                    Uri uri,
+                                    String method,
+                                    List<Param> formParams,
+                                    List<Param> queryParams,
+                                    long timestamp,
+                                    String nonce) throws InvalidKeyException {
+    String percentEncodedNonce = Utf8UrlEncoder.percentEncodeQueryElement(nonce);
+    String signature = computeSignature(consumerAuth, userAuth, uri, method, formParams, queryParams, timestamp, percentEncodedNonce);
+    return computeAuthorizationHeader(consumerAuth, userAuth, signature, timestamp, percentEncodedNonce);
+  }
+
+  String computeSignature(ConsumerKey consumerAuth,
+                            RequestToken userAuth,
+                            Uri uri,
+                            String method,
+                            List<Param> formParams,
+                            List<Param> queryParams,
+                            long oauthTimestamp,
+                            String percentEncodedNonce) throws InvalidKeyException {
+
+    StringBuilder sb = signatureBaseString(
+      consumerAuth,
+      userAuth,
+      uri,
+      method,
+      formParams,
+      queryParams,
+      oauthTimestamp,
+      percentEncodedNonce);
+
+    ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
+    byte[] rawSignature = digest(consumerAuth, userAuth, rawBase);
+    // and finally, base64 encoded... phew!
+    return Base64.getEncoder().encodeToString(rawSignature);
+  }
+
+  StringBuilder signatureBaseString(ConsumerKey consumerAuth,
+                                    RequestToken userAuth,
+                                    Uri uri,
+                                    String method,
+                                    List<Param> formParams,
+                                    List<Param> queryParams,
+                                    long oauthTimestamp,
+                                    String percentEncodedNonce) {
+
+    // beware: must generate first as we're using pooled StringBuilder
+    String baseUrl = uri.toBaseUrl();
+    String encodedParams = encodedParams(consumerAuth, userAuth, oauthTimestamp, percentEncodedNonce, formParams, queryParams);
+
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    sb.append(method); // POST / GET etc (nothing to URL encode)
+    sb.append('&');
+    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, baseUrl);
+
+    // and all that needs to be URL encoded (... again!)
+    sb.append('&');
+    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, encodedParams);
+    return sb;
+  }
+
+  private String encodedParams(ConsumerKey consumerAuth,
+                               RequestToken userAuth,
+                               long oauthTimestamp,
+                               String percentEncodedNonce,
+                               List<Param> formParams,
+                               List<Param> queryParams) {
+
+    parameters.reset();
+
+    // List of all query and form parameters added to this request; needed for calculating request signature
+    // Start with standard OAuth parameters we need
+    parameters.add(KEY_OAUTH_CONSUMER_KEY, consumerAuth.getPercentEncodedKey())
+            .add(KEY_OAUTH_NONCE, percentEncodedNonce)
+            .add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD)
+            .add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
+    if (userAuth.getKey() != null) {
+      parameters.add(KEY_OAUTH_TOKEN, userAuth.getPercentEncodedKey());
     }
+    parameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
 
-    public void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder) throws InvalidKeyException {
-        String nonce = generateNonce();
-        long timestamp = generateTimestamp();
-        sign(consumerAuth, userAuth, request, requestBuilder, timestamp, nonce);
+    if (formParams != null) {
+      for (Param param : formParams) {
+        // formParams are not already encoded
+        parameters.add(Utf8UrlEncoder.percentEncodeQueryElement(param.getName()), Utf8UrlEncoder.percentEncodeQueryElement(param.getValue()));
+      }
     }
-
-    private String generateNonce() {
-        ThreadLocalRandom.current().nextBytes(nonceBuffer);
-        // let's use base64 encoding over hex, slightly more compact than hex or decimals
-        return Base64.encode(nonceBuffer);
+    if (queryParams != null) {
+      for (Param param : queryParams) {
+        // queryParams are already form-url-encoded
+        // but OAuth1 uses RFC3986_UNRESERVED_CHARS so * and + have to be encoded
+        parameters.add(percentEncodeAlreadyFormUrlEncoded(param.getName()), percentEncodeAlreadyFormUrlEncoded(param.getValue()));
+      }
     }
-
-    private static long generateTimestamp() {
-        return System.currentTimeMillis() / 1000L;
+    return parameters.sortAndConcat();
+  }
+
+  private String percentEncodeAlreadyFormUrlEncoded(String s) {
+    s = STAR_CHAR_PATTERN.matcher(s).replaceAll("%2A");
+    s = PLUS_CHAR_PATTERN.matcher(s).replaceAll("%20");
+    s = ENCODED_TILDE_PATTERN.matcher(s).replaceAll("~");
+    return s;
+  }
+
+  private byte[] digest(ConsumerKey consumerAuth, RequestToken userAuth, ByteBuffer message) throws InvalidKeyException {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    Utf8UrlEncoder.encodeAndAppendQueryElement(sb, consumerAuth.getSecret());
+    sb.append('&');
+    if (userAuth != null && userAuth.getSecret() != null) {
+      Utf8UrlEncoder.encodeAndAppendQueryElement(sb, userAuth.getSecret());
     }
-
-    void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder, long timestamp, String nonce) throws InvalidKeyException {
-        String percentEncodedNonce = Utf8UrlEncoder.percentEncodeQueryElement(nonce);
-        String signature = calculateSignature(consumerAuth, userAuth, request, timestamp, percentEncodedNonce);
-        String headerValue = constructAuthHeader(consumerAuth, userAuth, signature, timestamp, percentEncodedNonce);
-        requestBuilder.setHeader(HttpHeaderNames.AUTHORIZATION, headerValue);
-    }
-
-    String calculateSignature(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) throws InvalidKeyException {
-
-        StringBuilder sb = signatureBaseString(consumerAuth, userAuth, request, oauthTimestamp, percentEncodedNonce);
-
-        ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
-        byte[] rawSignature = digest(consumerAuth, userAuth, rawBase);
-        // and finally, base64 encoded... phew!
-        return Base64.encode(rawSignature);
-    }
-
-    StringBuilder signatureBaseString(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) {
-
-        // beware: must generate first as we're using pooled StringBuilder
-        String baseUrl = request.getUri().toBaseUrl();
-        String encodedParams = encodedParams(consumerAuth, userAuth, oauthTimestamp, percentEncodedNonce, request.getFormParams(), request.getQueryParams());
-
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        sb.append(request.getMethod()); // POST / GET etc (nothing to URL encode)
-        sb.append('&');
-        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, baseUrl);
-
-        // and all that needs to be URL encoded (... again!)
-        sb.append('&');
-        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, encodedParams);
-        return sb;
+    byte[] keyBytes = StringUtils.charSequence2Bytes(sb, UTF_8);
+    SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
+
+    mac.init(signingKey);
+    mac.update(message);
+    return mac.doFinal();
+  }
+
+  String computeAuthorizationHeader(ConsumerKey consumerAuth, RequestToken userAuth, String signature, long oauthTimestamp, String percentEncodedNonce) {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    sb.append("OAuth ");
+    sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getPercentEncodedKey()).append("\", ");
+    if (userAuth.getKey() != null) {
+      sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getPercentEncodedKey()).append("\", ");
     }
+    sb.append(KEY_OAUTH_SIGNATURE_METHOD).append("=\"").append(OAUTH_SIGNATURE_METHOD).append("\", ");
 
-    private String encodedParams(ConsumerKey consumerAuth, RequestToken userAuth, long oauthTimestamp, String percentEncodedNonce, List<Param> formParams, List<Param> queryParams) {
-
-        parameters.reset();
-
-        /**
-         * List of all query and form parameters added to this request; needed for calculating request signature
-         */
-        // start with standard OAuth parameters we need
-        parameters.add(KEY_OAUTH_CONSUMER_KEY, consumerAuth.getPercentEncodedKey())//
-                .add(KEY_OAUTH_NONCE, percentEncodedNonce)
-                .add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD)//
-                .add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
-        if (userAuth.getKey() != null) {
-            parameters.add(KEY_OAUTH_TOKEN, userAuth.getPercentEncodedKey());
-        }
-        parameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
-
-        if (formParams != null) {
-            for (Param param : formParams) {
-                // formParams are not already encoded
-                parameters.add(Utf8UrlEncoder.percentEncodeQueryElement(param.getName()), Utf8UrlEncoder.percentEncodeQueryElement(param.getValue()));
-            }
-        }
-        if (queryParams != null) {
-            for (Param param : queryParams) {
-                // queryParams are already form-url-encoded
-                // but OAuth1 uses RFC3986_UNRESERVED_CHARS so * and + have to be encoded
-                parameters.add(percentEncodeAlreadyFormUrlEncoded(param.getName()), percentEncodeAlreadyFormUrlEncoded(param.getValue()));
-            }
-        }
-        return parameters.sortAndConcat();
-    }
+    // careful: base64 has chars that need URL encoding:
+    sb.append(KEY_OAUTH_SIGNATURE).append("=\"");
+    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, signature).append("\", ");
+    sb.append(KEY_OAUTH_TIMESTAMP).append("=\"").append(oauthTimestamp).append("\", ");
 
-    private String percentEncodeAlreadyFormUrlEncoded(String s) {
-        s = STAR_CHAR_PATTERN.matcher(s).replaceAll("%2A");
-        s = PLUS_CHAR_PATTERN.matcher(s).replaceAll("%20");
-        s = ENCODED_TILDE_PATTERN.matcher(s).replaceAll("~");
-        return s;
-    }
-
-    private byte[] digest(ConsumerKey consumerAuth, RequestToken userAuth, ByteBuffer message) throws InvalidKeyException {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, consumerAuth.getSecret());
-        sb.append('&');
-        if (userAuth != null && userAuth.getSecret() != null) {
-            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, userAuth.getSecret());
-        }
-        byte[] keyBytes = StringUtils.charSequence2Bytes(sb, UTF_8);
-        SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
-
-        mac.init(signingKey);
-        mac.reset();
-        mac.update(message);
-        return mac.doFinal();
-    }
+    sb.append(KEY_OAUTH_NONCE).append("=\"").append(percentEncodedNonce).append("\", ");
 
-    String constructAuthHeader(ConsumerKey consumerAuth, RequestToken userAuth, String signature, long oauthTimestamp, String percentEncodedNonce) {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        sb.append("OAuth ");
-        sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getPercentEncodedKey()).append("\", ");
-        if (userAuth.getKey() != null) {
-            sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getPercentEncodedKey()).append("\", ");
-        }
-        sb.append(KEY_OAUTH_SIGNATURE_METHOD).append("=\"").append(OAUTH_SIGNATURE_METHOD).append("\", ");
-
-        // careful: base64 has chars that need URL encoding:
-        sb.append(KEY_OAUTH_SIGNATURE).append("=\"");
-        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, signature).append("\", ");
-        sb.append(KEY_OAUTH_TIMESTAMP).append("=\"").append(oauthTimestamp).append("\", ");
-
-        sb.append(KEY_OAUTH_NONCE).append("=\"").append(percentEncodedNonce).append("\", ");
-
-        sb.append(KEY_OAUTH_VERSION).append("=\"").append(OAUTH_VERSION_1_0).append("\"");
-        return sb.toString();
-    }
+    sb.append(KEY_OAUTH_VERSION).append("=\"").append(OAUTH_VERSION_1_0).append("\"");
+    return sb.toString();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/Parameter.java b/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
index 8da44279d..bc4734ea2 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
@@ -18,39 +18,39 @@
  */
 final class Parameter implements Comparable<Parameter> {
 
-    final String key, value;
-
-    public Parameter(String key, String value) {
-        this.key = key;
-        this.value = value;
-    }
-
-    @Override
-    public int compareTo(Parameter other) {
-        int keyDiff = key.compareTo(other.key);
-        return keyDiff == 0 ? value.compareTo(other.value) : keyDiff;
-    }
-
-    @Override
-    public String toString() {
-        return key + "=" + value;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o)
-            return true;
-        if (o == null || getClass() != o.getClass())
-            return false;
-
-        Parameter parameter = (Parameter) o;
-        return key.equals(parameter.key) && value.equals(parameter.value);
-    }
-
-    @Override
-    public int hashCode() {
-        int result = key.hashCode();
-        result = 31 * result + value.hashCode();
-        return result;
-    }
+  final String key, value;
+
+  public Parameter(String key, String value) {
+    this.key = key;
+    this.value = value;
+  }
+
+  @Override
+  public int compareTo(Parameter other) {
+    int keyDiff = key.compareTo(other.key);
+    return keyDiff == 0 ? value.compareTo(other.value) : keyDiff;
+  }
+
+  @Override
+  public String toString() {
+    return key + "=" + value;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o)
+      return true;
+    if (o == null || getClass() != o.getClass())
+      return false;
+
+    Parameter parameter = (Parameter) o;
+    return key.equals(parameter.key) && value.equals(parameter.value);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = key.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/Parameters.java b/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
index 17f4af9f6..b0c533ac2 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
@@ -13,39 +13,38 @@
  */
 package org.asynchttpclient.oauth;
 
+import org.asynchttpclient.util.StringBuilderPool;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import org.asynchttpclient.util.StringBuilderPool;
+final class Parameters {
 
-class Parameters {
+  private List<Parameter> parameters = new ArrayList<>();
 
-    private List<Parameter> parameters = new ArrayList<>();
+  public Parameters add(String key, String value) {
+    parameters.add(new Parameter(key, value));
+    return this;
+  }
 
-    Parameters add(String key, String value) {
-        parameters.add(new Parameter(key, value));
-        return this;
-    }
+  public void reset() {
+    parameters.clear();
+  }
 
-    void reset() {
-        parameters.clear();
-    }
+  String sortAndConcat() {
+    // then sort them (AFTER encoding, important)
+    Collections.sort(parameters);
 
-    String sortAndConcat() {
-        // then sort them (AFTER encoding, important)
-        Collections.sort(parameters);
-
-        // and build parameter section using pre-encoded pieces:
-        StringBuilder encodedParams = StringBuilderPool.DEFAULT.stringBuilder();
-        for (int i = 0; i < parameters.size(); i++) {
-            Parameter param = parameters.get(i);
-            encodedParams.append(param.key).append('=').append(param.value).append('&');
-        }
-        int length = encodedParams.length();
-        if (length > 0) {
-            encodedParams.setLength(length - 1);
-        }
-        return encodedParams.toString();
+    // and build parameter section using pre-encoded pieces:
+    StringBuilder encodedParams = StringBuilderPool.DEFAULT.stringBuilder();
+    for (Parameter param : parameters) {
+      encodedParams.append(param.key).append('=').append(param.value).append('&');
+    }
+    int length = encodedParams.length();
+    if (length > 0) {
+      encodedParams.setLength(length - 1);
     }
+    return encodedParams.toString();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java b/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
index 0cad6a71d..883eb3bca 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
@@ -1,18 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
  *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.oauth;
 
@@ -24,60 +21,25 @@
  * confidential ("secret") part.
  */
 public class RequestToken {
-    private final String key;
-    private final String secret;
-    private final String percentEncodedKey;
-
-    public RequestToken(String key, String token) {
-        this.key = key;
-        this.secret = token;
-        this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
-    }
-
-    public String getKey() {
-        return key;
-    }
-
-    public String getSecret() {
-        return secret;
-    }
-
-    String getPercentEncodedKey() {
-        return percentEncodedKey;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder("{ key=");
-        appendValue(sb, key);
-        sb.append(", secret=");
-        appendValue(sb, secret);
-        sb.append("}");
-        return sb.toString();
-    }
-
-    private void appendValue(StringBuilder sb, String value) {
-        if (value == null) {
-            sb.append("null");
-        } else {
-            sb.append('"');
-            sb.append(value);
-            sb.append('"');
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return key.hashCode() + secret.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o == this)
-            return true;
-        if (o == null || o.getClass() != getClass())
-            return false;
-        RequestToken other = (RequestToken) o;
-        return key.equals(other.key) && secret.equals(other.secret);
-    }
+  private final String key;
+  private final String secret;
+  private final String percentEncodedKey;
+
+  public RequestToken(String key, String token) {
+    this.key = key;
+    this.secret = token;
+    this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
+  }
+
+  public String getKey() {
+    return key;
+  }
+
+  public String getSecret() {
+    return secret;
+  }
+
+  public String getPercentEncodedKey() {
+    return percentEncodedKey;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index 62e5a5393..13c33590b 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -16,130 +16,152 @@
  */
 package org.asynchttpclient.proxy;
 
-import static org.asynchttpclient.util.Assertions.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.Realm;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import org.asynchttpclient.Realm;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 /**
  * Represents a proxy server.
  */
 public class ProxyServer {
 
-    private final String host;
-    private final int port;
-    private final int securedPort;
-    private final Realm realm;
-    private final List<String> nonProxyHosts;
-
-    public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts) {
-        this.host = host;
-        this.port = port;
-        this.securedPort = securedPort;
-        this.realm = realm;
-        this.nonProxyHosts = nonProxyHosts;
+  private final String host;
+  private final int port;
+  private final int securedPort;
+  private final Realm realm;
+  private final List<String> nonProxyHosts;
+  private final ProxyType proxyType;
+
+  public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts,
+                     ProxyType proxyType) {
+    this.host = host;
+    this.port = port;
+    this.securedPort = securedPort;
+    this.realm = realm;
+    this.nonProxyHosts = nonProxyHosts;
+    this.proxyType = proxyType;
+  }
+
+  public String getHost() {
+    return host;
+  }
+
+  public int getPort() {
+    return port;
+  }
+
+  public int getSecuredPort() {
+    return securedPort;
+  }
+
+  public List<String> getNonProxyHosts() {
+    return nonProxyHosts;
+  }
+
+  public Realm getRealm() {
+    return realm;
+  }
+
+  public ProxyType getProxyType() {
+    return proxyType;
+  }
+
+  /**
+   * Checks whether proxy should be used according to nonProxyHosts settings of
+   * it, or we want to go directly to target host. If <code>null</code> proxy is
+   * passed in, this method returns true -- since there is NO proxy, we should
+   * avoid to use it. Simple hostname pattern matching using "*" are supported,
+   * but only as prefixes.
+   *
+   * @param hostname the hostname
+   * @return true if we have to ignore proxy use (obeying non-proxy hosts
+   * settings), false otherwise.
+   * @see <a href=
+   * "https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking
+   * Properties</a>
+   */
+  public boolean isIgnoredForHost(String hostname) {
+    assertNotNull(hostname, "hostname");
+    if (isNonEmpty(nonProxyHosts)) {
+      for (String nonProxyHost : nonProxyHosts) {
+        if (matchNonProxyHost(hostname, nonProxyHost))
+          return true;
+      }
     }
 
-    public String getHost() {
-        return host;
-    }
+    return false;
+  }
+
+  private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
 
-    public int getPort() {
-        return port;
+    if (nonProxyHost.length() > 1) {
+      if (nonProxyHost.charAt(0) == '*') {
+        return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1,
+                nonProxyHost.length() - 1);
+      } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
+        return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
     }
 
-    public int getSecuredPort() {
-        return securedPort;
+    return nonProxyHost.equalsIgnoreCase(targetHost);
+  }
+
+  public static class Builder {
+
+    private String host;
+    private int port;
+    private int securedPort;
+    private Realm realm;
+    private List<String> nonProxyHosts;
+    private ProxyType proxyType;
+
+    public Builder(String host, int port) {
+      this.host = host;
+      this.port = port;
+      this.securedPort = port;
     }
 
-    public List<String> getNonProxyHosts() {
-        return nonProxyHosts;
+    public Builder setSecuredPort(int securedPort) {
+      this.securedPort = securedPort;
+      return this;
     }
 
-    public Realm getRealm() {
-        return realm;
+    public Builder setRealm(Realm realm) {
+      this.realm = realm;
+      return this;
     }
 
-    /**
-     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to target host. If <code>null</code> proxy is passed in, this method
-     * returns true -- since there is NO proxy, we should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
-     * 
-     * @param hostname the hostname
-     * @return true if we have to ignore proxy use (obeying non-proxy hosts settings), false otherwise.
-     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-     */
-    public boolean isIgnoredForHost(String hostname) {
-        assertNotNull(hostname, "hostname");
-        if (isNonEmpty(nonProxyHosts)) {
-            for (String nonProxyHost : nonProxyHosts) {
-                if (matchNonProxyHost(hostname, nonProxyHost))
-                    return true;
-            }
-        }
-
-        return false;
+    public Builder setRealm(Realm.Builder realm) {
+      this.realm = realm.build();
+      return this;
     }
 
-    private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
+    public Builder setNonProxyHost(String nonProxyHost) {
+      if (nonProxyHosts == null)
+        nonProxyHosts = new ArrayList<>(1);
+      nonProxyHosts.add(nonProxyHost);
+      return this;
+    }
 
-        if (nonProxyHost.length() > 1) {
-            if (nonProxyHost.charAt(0) == '*') {
-                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1, nonProxyHost.length() - 1);
-            } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
-                return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
-        }
+    public Builder setNonProxyHosts(List<String> nonProxyHosts) {
+      this.nonProxyHosts = nonProxyHosts;
+      return this;
+    }
 
-        return nonProxyHost.equalsIgnoreCase(targetHost);
+    public Builder setProxyType(ProxyType proxyType) {
+      this.proxyType = proxyType;
+      return this;
     }
 
-    public static class Builder {
-
-        private String host;
-        private int port;
-        private int securedPort;
-        private Realm realm;
-        private List<String> nonProxyHosts;
-
-        public Builder(String host, int port) {
-            this.host = host;
-            this.port = port;
-            this.securedPort = port;
-        }
-
-        public Builder setSecuredPort(int securedPort) {
-            this.securedPort = securedPort;
-            return this;
-        }
-
-        public Builder setRealm(Realm realm) {
-            this.realm = realm;
-            return this;
-        }
-
-        public Builder setRealm(Realm.Builder realm) {
-            this.realm = realm.build();
-            return this;
-        }
-
-        public Builder setNonProxyHost(String nonProxyHost) {
-            if (nonProxyHosts == null)
-                nonProxyHosts = new ArrayList<>(1);
-            nonProxyHosts.add(nonProxyHost);
-            return this;
-        }
-
-        public Builder setNonProxyHosts(List<String> nonProxyHosts) {
-            this.nonProxyHosts = nonProxyHosts;
-            return this;
-        }
-
-        public ProxyServer build() {
-            List<String> nonProxyHosts = this.nonProxyHosts != null ? Collections.unmodifiableList(this.nonProxyHosts) : Collections.emptyList();
-            return new ProxyServer(host, port, securedPort, realm, nonProxyHosts);
-        }
+    public ProxyServer build() {
+      List<String> nonProxyHosts = this.nonProxyHosts != null ? Collections.unmodifiableList(this.nonProxyHosts)
+              : Collections.emptyList();
+      ProxyType proxyType = this.proxyType != null ? this.proxyType : ProxyType.HTTP;
+      return new ProxyServer(host, port, securedPort, realm, nonProxyHosts, proxyType);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
index 359878b48..c3381005a 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
@@ -7,16 +7,16 @@
  */
 public interface ProxyServerSelector {
 
-    /**
-     * Select a proxy server to use for the given URI.
-     *
-     * @param uri The URI to select a proxy server for.
-     * @return The proxy server to use, if any.  May return null.
-     */
-    ProxyServer select(Uri uri);
+  /**
+   * A selector that always selects no proxy.
+   */
+  ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
 
-    /**
-     * A selector that always selects no proxy.
-     */
-    ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
+  /**
+   * Select a proxy server to use for the given URI.
+   *
+   * @param uri The URI to select a proxy server for.
+   * @return The proxy server to use, if any.  May return null.
+   */
+  ProxyServer select(Uri uri);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyType.java
similarity index 53%
rename from client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java
rename to client/src/main/java/org/asynchttpclient/proxy/ProxyType.java
index 41a4bcd0b..bf680018a 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -11,29 +11,22 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel;
+package org.asynchttpclient.proxy;
 
-/**
- * Non-blocking semaphore-like object with infinite permits.
- *
- * So try-acquire always succeeds.
- *
- * @author Stepan Koltsov
- */
-enum NonBlockingSemaphoreInfinite implements NonBlockingSemaphoreLike {
-    INSTANCE;
+public enum ProxyType {
+  HTTP(true), SOCKS_V4(false), SOCKS_V5(false);
+
+  private final boolean http;
 
-    @Override
-    public void release() {
-    }
+  ProxyType(boolean http) {
+    this.http = http;
+  }
 
-    @Override
-    public boolean tryAcquire() {
-        return true;
-    }
+  public boolean isHttp() {
+    return http;
+  }
 
-    @Override
-    public String toString() {
-        return NonBlockingSemaphore.class.getName();
-    }
+  public boolean isSocks() {
+    return !isHttp();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/Body.java b/client/src/main/java/org/asynchttpclient/request/body/Body.java
index 66a588739..80e7e1c6b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/Body.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -1,15 +1,15 @@
 /*
-* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
-*
-* This program is licensed to you under the Apache License Version 2.0,
-* and you may not use this file except in compliance with the Apache License Version 2.0.
-* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the Apache License Version 2.0 is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
-*/
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 
 package org.asynchttpclient.request.body;
 
@@ -23,37 +23,37 @@
  */
 public interface Body extends Closeable {
 
-    enum BodyState {
+  /**
+   * Gets the length of the body.
+   *
+   * @return The length of the body in bytes, or negative if unknown.
+   */
+  long getContentLength();
 
-        /**
-         * There's something to read
-         */
-        CONTINUE,
+  /**
+   * Reads the next chunk of bytes from the body.
+   *
+   * @param target The buffer to store the chunk in, must not be {@code null}.
+   * @return The state.
+   * @throws IOException If the chunk could not be read.
+   */
+  BodyState transferTo(ByteBuf target) throws IOException;
 
-        /**
-         * There's nothing to read and input has to suspend
-         */
-        SUSPEND,
+  enum BodyState {
 
-        /**
-         * There's nothing to read and input has to stop
-         */
-        STOP
-    }
+    /**
+     * There's something to read
+     */
+    CONTINUE,
 
     /**
-     * Gets the length of the body.
-     *
-     * @return The length of the body in bytes, or negative if unknown.
+     * There's nothing to read and input has to suspend
      */
-    long getContentLength();
+    SUSPEND,
 
     /**
-     * Reads the next chunk of bytes from the body.
-     *
-     * @param target The buffer to store the chunk in, must not be {@code null}.
-     * @return The non-negative number of bytes actually read or {@code -1} if the body has been read completely.
-     * @throws IOException If the chunk could not be read.
+     * There's nothing to read and input has to stop
      */
-    BodyState transferTo(ByteBuf target) throws IOException;
+    STOP
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
index e5bea4bf8..2d706fa63 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
@@ -21,14 +21,12 @@
  */
 public interface RandomAccessBody extends Body {
 
-    /**
-     * Transfers the specified chunk of bytes from this body to the specified channel.
-     * 
-     * @param target
-     *            The destination channel to transfer the body chunk to, must not be {@code null}.
-     * @return The non-negative number of bytes actually transferred.
-     * @throws IOException
-     *             If the body chunk could not be transferred.
-     */
-    long transferTo(WritableByteChannel target) throws IOException;
+  /**
+   * Transfers the specified chunk of bytes from this body to the specified channel.
+   *
+   * @param target The destination channel to transfer the body chunk to, must not be {@code null}.
+   * @return The non-negative number of bytes actually transferred.
+   * @throws IOException If the body chunk could not be transferred.
+   */
+  long transferTo(WritableByteChannel target) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
index d754a9d65..c4e01fbff 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
@@ -16,11 +16,11 @@
 import io.netty.buffer.ByteBuf;
 
 public final class BodyChunk {
-    public final boolean last;
-    public final ByteBuf buffer;
+  public final boolean last;
+  public final ByteBuf buffer;
 
-    public BodyChunk(ByteBuf buffer, boolean last) {
-        this.buffer = buffer;
-        this.last = last;
-    }
+  BodyChunk(ByteBuf buffer, boolean last) {
+    this.buffer = buffer;
+    this.last = last;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
index 4b20ee978..be44180f0 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
@@ -20,12 +20,12 @@
  */
 public interface BodyGenerator {
 
-    /**
-     * Creates a new instance of the request body to be read. While each invocation of this method is supposed to create
-     * a fresh instance of the body, the actual contents of all these body instances is the same. For example, the body
-     * needs to be resend after an authentication challenge of a redirect.
-     *
-     * @return The request body, never {@code null}.
-     */
-    Body createBody();
+  /**
+   * Creates a new instance of the request body to be read. While each invocation of this method is supposed to create
+   * a fresh instance of the body, the actual contents of all these body instances is the same. For example, the body
+   * needs to be resend after an authentication challenge of a redirect.
+   *
+   * @return The request body, never {@code null}.
+   */
+  Body createBody();
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
index ff6ca2627..b19590c54 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
@@ -18,12 +18,12 @@
 
 public final class BoundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<BlockingQueue<BodyChunk>> {
 
-    public BoundedQueueFeedableBodyGenerator(int capacity) {
-        super(new ArrayBlockingQueue<>(capacity, true));
-    }
+  public BoundedQueueFeedableBodyGenerator(int capacity) {
+    super(new ArrayBlockingQueue<>(capacity, true));
+  }
 
-    @Override
-    protected boolean offer(BodyChunk chunk) throws InterruptedException {
-        return queue.offer(chunk);
-    }
+  @Override
+  protected boolean offer(BodyChunk chunk) throws InterruptedException {
+    return queue.offer(chunk);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
index 9790b0fee..ccbfd86fb 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
@@ -13,9 +13,6 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
-
-import java.io.IOException;
-
 import org.asynchttpclient.request.body.Body;
 
 /**
@@ -23,49 +20,49 @@
  */
 public final class ByteArrayBodyGenerator implements BodyGenerator {
 
-    private final byte[] bytes;
+  private final byte[] bytes;
 
-    public ByteArrayBodyGenerator(byte[] bytes) {
-        this.bytes = bytes;
-    }
+  public ByteArrayBodyGenerator(byte[] bytes) {
+    this.bytes = bytes;
+  }
 
-    protected final class ByteBody implements Body {
-        private boolean eof = false;
-        private int lastPosition = 0;
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public Body createBody() {
+    return new ByteBody();
+  }
 
-        public long getContentLength() {
-            return bytes.length;
-        }
+  protected final class ByteBody implements Body {
+    private boolean eof = false;
+    private int lastPosition = 0;
 
-        public BodyState transferTo(ByteBuf target) throws IOException {
+    public long getContentLength() {
+      return bytes.length;
+    }
 
-            if (eof) {
-                return BodyState.STOP;
-            }
+    public BodyState transferTo(ByteBuf target) {
 
-            final int remaining = bytes.length - lastPosition;
-            final int initialTargetWritableBytes = target.writableBytes();
-            if (remaining <= initialTargetWritableBytes) {
-                target.writeBytes(bytes, lastPosition, remaining);
-                eof = true;
-            } else {
-                target.writeBytes(bytes, lastPosition, initialTargetWritableBytes);
-                lastPosition += initialTargetWritableBytes;
-            }
-            return BodyState.CONTINUE;
-        }
+      if (eof) {
+        return BodyState.STOP;
+      }
 
-        public void close() throws IOException {
-            lastPosition = 0;
-            eof = false;
-        }
+      final int remaining = bytes.length - lastPosition;
+      final int initialTargetWritableBytes = target.writableBytes();
+      if (remaining <= initialTargetWritableBytes) {
+        target.writeBytes(bytes, lastPosition, remaining);
+        eof = true;
+      } else {
+        target.writeBytes(bytes, lastPosition, initialTargetWritableBytes);
+        lastPosition += initialTargetWritableBytes;
+      }
+      return BodyState.CONTINUE;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Body createBody() {
-        return new ByteBody();
+    public void close() {
+      lastPosition = 0;
+      eof = false;
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
index 63c0c0262..3ca74f562 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
@@ -14,7 +14,7 @@
 package org.asynchttpclient.request.body.generator;
 
 public interface FeedListener {
-    void onContentAdded();
+  void onContentAdded();
 
-    void onError(Throwable t);
+  void onError(Throwable t);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
index dc259c7b7..9016cdcd3 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -21,7 +21,7 @@
  */
 public interface FeedableBodyGenerator extends BodyGenerator {
 
-    boolean feed(ByteBuf buffer, boolean isLast) throws Exception;
+  boolean feed(ByteBuf buffer, boolean isLast) throws Exception;
 
-    void setListener(FeedListener listener);
+  void setListener(FeedListener listener);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
index 55db64295..1b260ee51 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
@@ -12,48 +12,48 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import static org.asynchttpclient.util.Assertions.*;
+import org.asynchttpclient.request.body.RandomAccessBody;
 
 import java.io.File;
 
-import org.asynchttpclient.request.body.RandomAccessBody;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 
 /**
  * Creates a request body from the contents of a file.
  */
 public final class FileBodyGenerator implements BodyGenerator {
 
-    private final File file;
-    private final long regionSeek;
-    private final long regionLength;
-
-    public FileBodyGenerator(File file) {
-        this(file, 0L, file.length());
-    }
-
-    public FileBodyGenerator(File file, long regionSeek, long regionLength) {
-        this.file = assertNotNull(file, "file");
-        this.regionLength = regionLength;
-        this.regionSeek = regionSeek;
-    }
-
-    public File getFile() {
-        return file;
-    }
-
-    public long getRegionLength() {
-        return regionLength;
-    }
-
-    public long getRegionSeek() {
-        return regionSeek;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public RandomAccessBody createBody() {
-        throw new UnsupportedOperationException("FileBodyGenerator.createBody isn't used, Netty direclt sends the file");
-    }
+  private final File file;
+  private final long regionSeek;
+  private final long regionLength;
+
+  public FileBodyGenerator(File file) {
+    this(file, 0L, file.length());
+  }
+
+  public FileBodyGenerator(File file, long regionSeek, long regionLength) {
+    this.file = assertNotNull(file, "file");
+    this.regionLength = regionLength;
+    this.regionSeek = regionSeek;
+  }
+
+  public File getFile() {
+    return file;
+  }
+
+  public long getRegionLength() {
+    return regionLength;
+  }
+
+  public long getRegionSeek() {
+    return regionSeek;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public RandomAccessBody createBody() {
+    throw new UnsupportedOperationException("FileBodyGenerator.createBody isn't used, Netty direclt sends the file");
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
index 155bd0764..b69e6b1eb 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
@@ -14,14 +14,13 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
-
-import java.io.IOException;
-import java.io.InputStream;
-
 import org.asynchttpclient.request.body.Body;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.io.InputStream;
+
 /**
  * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
  * <br>
@@ -30,73 +29,73 @@
  */
 public final class InputStreamBodyGenerator implements BodyGenerator {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
-    private final InputStream inputStream;
-    private final long contentLength;
+  private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
+  private final InputStream inputStream;
+  private final long contentLength;
 
-    public InputStreamBodyGenerator(InputStream inputStream) {
-        this(inputStream, -1L);
-    }
+  public InputStreamBodyGenerator(InputStream inputStream) {
+    this(inputStream, -1L);
+  }
 
-    public InputStreamBodyGenerator(InputStream inputStream, long contentLength) {
-        this.inputStream = inputStream;
-        this.contentLength = contentLength;
-    }
+  public InputStreamBodyGenerator(InputStream inputStream, long contentLength) {
+    this.inputStream = inputStream;
+    this.contentLength = contentLength;
+  }
 
-    public InputStream getInputStream() {
-        return inputStream;
-    }
+  public InputStream getInputStream() {
+    return inputStream;
+  }
 
-    public long getContentLength() {
-        return contentLength;
-    }
+  public long getContentLength() {
+    return contentLength;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Body createBody() {
-        return new InputStreamBody(inputStream, contentLength);
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public Body createBody() {
+    return new InputStreamBody(inputStream, contentLength);
+  }
 
-    private class InputStreamBody implements Body {
+  private class InputStreamBody implements Body {
 
-        private final InputStream inputStream;
-        private final long contentLength;
-        private byte[] chunk;
+    private final InputStream inputStream;
+    private final long contentLength;
+    private byte[] chunk;
 
-        private InputStreamBody(InputStream inputStream, long contentLength) {
-            this.inputStream = inputStream;
-            this.contentLength = contentLength;
-        }
+    private InputStreamBody(InputStream inputStream, long contentLength) {
+      this.inputStream = inputStream;
+      this.contentLength = contentLength;
+    }
 
-        public long getContentLength() {
-            return contentLength;
-        }
+    public long getContentLength() {
+      return contentLength;
+    }
 
-        public BodyState transferTo(ByteBuf target) throws IOException {
+    public BodyState transferTo(ByteBuf target) {
 
-            // To be safe.
-            chunk = new byte[target.writableBytes() - 10];
+      // To be safe.
+      chunk = new byte[target.writableBytes() - 10];
 
-            int read = -1;
-            boolean write = false;
-            try {
-                read = inputStream.read(chunk);
-            } catch (IOException ex) {
-                LOGGER.warn("Unable to read", ex);
-            }
+      int read = -1;
+      boolean write = false;
+      try {
+        read = inputStream.read(chunk);
+      } catch (IOException ex) {
+        LOGGER.warn("Unable to read", ex);
+      }
 
-            if (read > 0) {
-                target.writeBytes(chunk, 0, read);
-                write = true;
-            }
-            return write ? BodyState.CONTINUE : BodyState.STOP;
-        }
+      if (read > 0) {
+        target.writeBytes(chunk, 0, read);
+        write = true;
+      }
+      return write ? BodyState.CONTINUE : BodyState.STOP;
+    }
 
-        public void close() throws IOException {
-            inputStream.close();
-        }
+    public void close() throws IOException {
+      inputStream.close();
     }
+  }
 }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
index 08e2a935e..180108de5 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
@@ -14,67 +14,65 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.request.body.Body;
 
-import java.io.IOException;
 import java.util.Queue;
 
-import org.asynchttpclient.request.body.Body;
-
 public final class PushBody implements Body {
 
-    private final Queue<BodyChunk> queue;
-    private BodyState state = BodyState.CONTINUE;
+  private final Queue<BodyChunk> queue;
+  private BodyState state = BodyState.CONTINUE;
 
-    public PushBody(Queue<BodyChunk> queue) {
-        this.queue = queue;
-    }
+  public PushBody(Queue<BodyChunk> queue) {
+    this.queue = queue;
+  }
 
-    @Override
-    public long getContentLength() {
-        return -1;
-    }
+  @Override
+  public long getContentLength() {
+    return -1;
+  }
 
-    @Override
-    public BodyState transferTo(final ByteBuf target) throws IOException {
-        switch (state) {
-        case CONTINUE:
-            return readNextChunk(target);
-        case STOP:
-            return BodyState.STOP;
-        default:
-            throw new IllegalStateException("Illegal process state.");
-        }
+  @Override
+  public BodyState transferTo(final ByteBuf target) {
+    switch (state) {
+      case CONTINUE:
+        return readNextChunk(target);
+      case STOP:
+        return BodyState.STOP;
+      default:
+        throw new IllegalStateException("Illegal process state.");
     }
+  }
 
-    private BodyState readNextChunk(ByteBuf target) throws IOException {
-        BodyState res = BodyState.SUSPEND;
-        while (target.isWritable() && state != BodyState.STOP) {
-            BodyChunk nextChunk = queue.peek();
-            if (nextChunk == null) {
-                // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
-                return res;
-            } else if (!nextChunk.buffer.isReadable() && !nextChunk.last) {
-                // skip empty buffers
-                queue.remove();
-            } else {
-                res = BodyState.CONTINUE;
-                readChunk(target, nextChunk);
-            }
-        }
+  private BodyState readNextChunk(ByteBuf target) {
+    BodyState res = BodyState.SUSPEND;
+    while (target.isWritable() && state != BodyState.STOP) {
+      BodyChunk nextChunk = queue.peek();
+      if (nextChunk == null) {
+        // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
         return res;
+      } else if (!nextChunk.buffer.isReadable() && !nextChunk.last) {
+        // skip empty buffers
+        queue.remove();
+      } else {
+        res = BodyState.CONTINUE;
+        readChunk(target, nextChunk);
+      }
     }
+    return res;
+  }
 
-    private void readChunk(ByteBuf target, BodyChunk part) {
-        target.writeBytes(part.buffer);
-        if (!part.buffer.isReadable()) {
-            if (part.last) {
-                state = BodyState.STOP;
-            }
-            queue.remove();
-        }
+  private void readChunk(ByteBuf target, BodyChunk part) {
+    target.writeBytes(part.buffer);
+    if (!part.buffer.isReadable()) {
+      if (part.last) {
+        state = BodyState.STOP;
+      }
+      queue.remove();
     }
+  }
 
-    @Override
-    public void close() {
-    }
+  @Override
+  public void close() {
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
index a945292d8..d0f387821 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
@@ -14,38 +14,37 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.request.body.Body;
 
 import java.util.Queue;
 
-import org.asynchttpclient.request.body.Body;
-
 public abstract class QueueBasedFeedableBodyGenerator<T extends Queue<BodyChunk>> implements FeedableBodyGenerator {
 
-    protected final T queue;
-    private FeedListener listener;
+  protected final T queue;
+  private FeedListener listener;
 
-    public QueueBasedFeedableBodyGenerator(T queue) {
-        this.queue = queue;
-    }
+  public QueueBasedFeedableBodyGenerator(T queue) {
+    this.queue = queue;
+  }
 
-    @Override
-    public Body createBody() {
-        return new PushBody(queue);
-    }
+  @Override
+  public Body createBody() {
+    return new PushBody(queue);
+  }
 
-    protected abstract boolean offer(BodyChunk chunk) throws Exception;
+  protected abstract boolean offer(BodyChunk chunk) throws Exception;
 
-    @Override
-    public boolean feed(final ByteBuf buffer, final boolean isLast) throws Exception {
-        boolean offered = offer(new BodyChunk(buffer, isLast));
-        if (offered && listener != null) {
-            listener.onContentAdded();
-        }
-        return offered;
+  @Override
+  public boolean feed(final ByteBuf buffer, final boolean isLast) throws Exception {
+    boolean offered = offer(new BodyChunk(buffer, isLast));
+    if (offered && listener != null) {
+      listener.onContentAdded();
     }
+    return offered;
+  }
 
-    @Override
-    public void setListener(FeedListener listener) {
-        this.listener = listener;
-    }
+  @Override
+  public void setListener(FeedListener listener) {
+    this.listener = listener;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
index 949a0fa43..7cf1c14fd 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -14,10 +14,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.asynchttpclient.request.body.Body;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -25,141 +21,143 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 public class ReactiveStreamsBodyGenerator implements FeedableBodyGenerator {
 
-    private final Publisher<ByteBuf> publisher;
-    private final FeedableBodyGenerator feedableBodyGenerator;
-    private volatile FeedListener feedListener;
-    private final long contentLength;
+  private final Publisher<ByteBuf> publisher;
+  private final FeedableBodyGenerator feedableBodyGenerator;
+  private final long contentLength;
+  private volatile FeedListener feedListener;
+
+  /**
+   * Creates a Streamable Body which takes a Content-Length.
+   * If the contentLength parameter is -1L a Http Header of Transfer-Encoding: chunked will be set.
+   * Otherwise it will set the Content-Length header to the value provided
+   *
+   * @param publisher     Body as a Publisher
+   * @param contentLength Content-Length of the Body
+   */
+  public ReactiveStreamsBodyGenerator(Publisher<ByteBuf> publisher, long contentLength) {
+    this.publisher = publisher;
+    this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+    this.contentLength = contentLength;
+  }
+
+  public Publisher<ByteBuf> getPublisher() {
+    return this.publisher;
+  }
+
+  @Override
+  public boolean feed(ByteBuf buffer, boolean isLast) throws Exception {
+    return feedableBodyGenerator.feed(buffer, isLast);
+  }
+
+  @Override
+  public void setListener(FeedListener listener) {
+    feedListener = listener;
+    feedableBodyGenerator.setListener(listener);
+  }
+
+  public long getContentLength() {
+    return contentLength;
+  }
+
+  @Override
+  public Body createBody() {
+    return new StreamedBody(feedableBodyGenerator, contentLength);
+  }
+
+  private class StreamedBody implements Body {
+    private final AtomicBoolean initialized = new AtomicBoolean(false);
+
+    private final SimpleSubscriber subscriber;
+    private final Body body;
 
-    /**
-     *  Creates a Streamable Body which takes a Content-Length.
-     *  If the contentLength parameter is -1L a Http Header of Transfer-Encoding: chunked will be set.
-     *  Otherwise it will set the Content-Length header to the value provided
-     *
-     * @param publisher Body as a Publisher
-     * @param contentLength Content-Length of the Body
-     */
-    public ReactiveStreamsBodyGenerator(Publisher<ByteBuf> publisher, long contentLength) {
-        this.publisher = publisher;
-        this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-        this.contentLength = contentLength;
-    }
+    private final long contentLength;
 
-    public Publisher<ByteBuf> getPublisher() {
-        return this.publisher;
+    public StreamedBody(FeedableBodyGenerator bodyGenerator, long contentLength) {
+      this.body = bodyGenerator.createBody();
+      this.subscriber = new SimpleSubscriber(bodyGenerator);
+      this.contentLength = contentLength;
     }
 
     @Override
-    public boolean feed(ByteBuf buffer, boolean isLast) throws Exception {
-        return feedableBodyGenerator.feed(buffer, isLast);
+    public void close() throws IOException {
+      body.close();
     }
 
     @Override
-    public void setListener(FeedListener listener) {
-        feedListener = listener;
-        feedableBodyGenerator.setListener(listener);
-    }
-
     public long getContentLength() {
-        return contentLength;
+      return contentLength;
     }
 
     @Override
-    public Body createBody() {
-        return new StreamedBody(publisher, feedableBodyGenerator, contentLength);
-    }
+    public BodyState transferTo(ByteBuf target) throws IOException {
+      if (initialized.compareAndSet(false, true)) {
+        publisher.subscribe(subscriber);
+      }
 
-    private class StreamedBody implements Body {
-        private final AtomicBoolean initialized = new AtomicBoolean(false);
+      return body.transferTo(target);
+    }
+  }
 
-        private final SimpleSubscriber subscriber;
-        private final Body body;
+  private class SimpleSubscriber implements Subscriber<ByteBuf> {
 
-        private final long contentLength;
+    private final Logger LOGGER = LoggerFactory.getLogger(SimpleSubscriber.class);
 
-        public StreamedBody(Publisher<ByteBuf> publisher, FeedableBodyGenerator bodyGenerator, long contentLength) {
-            this.body = bodyGenerator.createBody();
-            this.subscriber = new SimpleSubscriber(bodyGenerator);
-            this.contentLength = contentLength;
-        }
+    private final FeedableBodyGenerator feeder;
+    private volatile Subscription subscription;
 
-        @Override
-        public void close() throws IOException {
-            body.close();
-        }
+    public SimpleSubscriber(FeedableBodyGenerator feeder) {
+      this.feeder = feeder;
+    }
 
-        @Override
-        public long getContentLength() {
-            return contentLength;
-        }
+    @Override
+    public void onSubscribe(Subscription s) {
+      assertNotNull(s, "subscription");
+
+      // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
+      if (this.subscription != null) {
+        s.cancel(); // Cancel the additional subscription
+      } else {
+        subscription = s;
+        subscription.request(Long.MAX_VALUE);
+      }
+    }
 
-        @Override
-        public BodyState transferTo(ByteBuf target) throws IOException {
-            if (initialized.compareAndSet(false, true)) {
-                publisher.subscribe(subscriber);
-            }
+    @Override
+    public void onNext(ByteBuf b) {
+      assertNotNull(b, "bytebuf");
+      try {
+        feeder.feed(b, false);
+      } catch (Exception e) {
+        LOGGER.error("Exception occurred while processing element in stream.", e);
+        subscription.cancel();
+      }
+    }
 
-            return body.transferTo(target);
-        }
+    @Override
+    public void onError(Throwable t) {
+      assertNotNull(t, "throwable");
+      LOGGER.debug("Error occurred while consuming body stream.", t);
+      FeedListener listener = feedListener;
+      if (listener != null) {
+        listener.onError(t);
+      }
     }
 
-    private class SimpleSubscriber implements Subscriber<ByteBuf> {
-
-        private final Logger LOGGER = LoggerFactory.getLogger(SimpleSubscriber.class);
-
-        private final FeedableBodyGenerator feeder;
-        private volatile Subscription subscription;
-
-        public SimpleSubscriber(FeedableBodyGenerator feeder) {
-            this.feeder = feeder;
-        }
-
-        @Override
-        public void onSubscribe(Subscription s) {
-            if (s == null)
-                throw null;
-
-            // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
-            if (this.subscription != null) {
-                s.cancel(); // Cancel the additional subscription
-            } else {
-                subscription = s;
-                subscription.request(Long.MAX_VALUE);
-            }
-        }
-
-        @Override
-        public void onNext(ByteBuf t) {
-            if (t == null)
-                throw null;
-            try {
-                feeder.feed(t, false);
-            } catch (Exception e) {
-                LOGGER.error("Exception occurred while processing element in stream.", e);
-                subscription.cancel();
-            }
-        }
-
-        @Override
-        public void onError(Throwable t) {
-            if (t == null)
-                throw null;
-            LOGGER.debug("Error occurred while consuming body stream.", t);
-            FeedListener listener = feedListener;
-            if (listener != null) {
-                listener.onError(t);
-            }
-        }
-
-        @Override
-        public void onComplete() {
-            try {
-                feeder.feed(Unpooled.EMPTY_BUFFER, true);
-            } catch (Exception e) {
-                LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
-                this.subscription.cancel();
-            }
-        }
+    @Override
+    public void onComplete() {
+      try {
+        feeder.feed(Unpooled.EMPTY_BUFFER, true);
+      } catch (Exception e) {
+        LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
+        this.subscription.cancel();
+      }
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
index d76ae9d03..b74319506 100755
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
@@ -17,12 +17,12 @@
 
 public final class UnboundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<ConcurrentLinkedQueue<BodyChunk>> {
 
-    public UnboundedQueueFeedableBodyGenerator() {
-        super(new ConcurrentLinkedQueue<>());
-    }
+  public UnboundedQueueFeedableBodyGenerator() {
+    super(new ConcurrentLinkedQueue<>());
+  }
 
-    @Override
-    protected boolean offer(BodyChunk chunk) throws Exception {
-        return queue.offer(chunk);
-    }
+  @Override
+  protected boolean offer(BodyChunk chunk) {
+    return queue.offer(chunk);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
index d2f4df30e..9a2200e42 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
@@ -12,40 +12,40 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 import java.nio.charset.Charset;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 public class ByteArrayPart extends FileLikePart {
 
-    private final byte[] bytes;
+  private final byte[] bytes;
 
-    public ByteArrayPart(String name, byte[] bytes) {
-        this(name, bytes, null);
-    }
+  public ByteArrayPart(String name, byte[] bytes) {
+    this(name, bytes, null);
+  }
 
-    public ByteArrayPart(String name, byte[] bytes, String contentType) {
-        this(name, bytes, contentType, null);
-    }
+  public ByteArrayPart(String name, byte[] bytes, String contentType) {
+    this(name, bytes, contentType, null);
+  }
 
-    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset) {
-        this(name, bytes, contentType, charset, null);
-    }
+  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset) {
+    this(name, bytes, contentType, charset, null);
+  }
 
-    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName) {
-        this(name, bytes, contentType, charset, fileName, null);
-    }
+  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName) {
+    this(name, bytes, contentType, charset, fileName, null);
+  }
 
-    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId) {
-        this(name, bytes, contentType, charset, fileName, contentId, null);
-    }
+  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId) {
+    this(name, bytes, contentType, charset, fileName, contentId, null);
+  }
 
-    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
-        super(name, contentType, charset, fileName, contentId, transferEncoding);
-        this.bytes = assertNotNull(bytes, "bytes");
-    }
+  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+    super(name, contentType, charset, fileName, contentId, transferEncoding);
+    this.bytes = assertNotNull(bytes, "bytes");
+  }
 
-    public byte[] getBytes() {
-        return bytes;
-    }
+  public byte[] getBytes() {
+    return bytes;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
index a53277978..ad3a70251 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
@@ -12,66 +12,62 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.MiscUtils.withDefault;
-
+import javax.activation.MimetypesFileTypeMap;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
 
-import javax.activation.MimetypesFileTypeMap;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
  */
 public abstract class FileLikePart extends PartBase {
 
-    private static final MimetypesFileTypeMap MIME_TYPES_FILE_TYPE_MAP;
+  private static final MimetypesFileTypeMap MIME_TYPES_FILE_TYPE_MAP;
 
-    static {
-        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("ahc-mime.types")) {
-            MIME_TYPES_FILE_TYPE_MAP = new MimetypesFileTypeMap(is);
-        } catch (IOException e) {
-            throw new ExceptionInInitializerError(e);
-        }
+  static {
+    try (InputStream is = FileLikePart.class.getResourceAsStream("ahc-mime.types")) {
+      MIME_TYPES_FILE_TYPE_MAP = new MimetypesFileTypeMap(is);
+    } catch (IOException e) {
+      throw new ExceptionInInitializerError(e);
     }
+  }
 
-    /**
-     * Default content encoding of file attachments.
-     */
-    private String fileName;
+  /**
+   * Default content encoding of file attachments.
+   */
+  private String fileName;
 
-    private static String computeContentType(String contentType, String fileName) {
-        return contentType != null ? contentType : MIME_TYPES_FILE_TYPE_MAP.getContentType(withDefault(fileName, ""));
-    }
+  /**
+   * FilePart Constructor.
+   *
+   * @param name              the name for this part
+   * @param contentType       the content type for this part, if <code>null</code> try to figure out from the fileName mime type
+   * @param charset           the charset encoding for this part
+   * @param fileName          the fileName
+   * @param contentId         the content id
+   * @param transfertEncoding the transfer encoding
+   */
+  public FileLikePart(String name, String contentType, Charset charset, String fileName, String contentId, String transfertEncoding) {
+    super(name,
+            computeContentType(contentType, fileName),
+            charset,
+            contentId,
+            transfertEncoding);
+    this.fileName = fileName;
+  }
 
-    /**
-     * FilePart Constructor.
-     * 
-     * @param name the name for this part
-     * @param contentType the content type for this part, if <code>null</code> try to figure out from the fileName mime type
-     * @param charset the charset encoding for this part
-     * @param fileName the fileName
-     * @param contentId the content id
-     * @param transfertEncoding the transfer encoding
-     */
-    public FileLikePart(String name, String contentType, Charset charset, String fileName, String contentId, String transfertEncoding) {
-        super(name,//
-                computeContentType(contentType, fileName),//
-                charset,//
-                contentId,//
-                transfertEncoding);
-        this.fileName = fileName;
-    }
+  private static String computeContentType(String contentType, String fileName) {
+    return contentType != null ? contentType : MIME_TYPES_FILE_TYPE_MAP.getContentType(withDefault(fileName, ""));
+  }
 
-    public String getFileName() {
-        return fileName;
-    }
+  public String getFileName() {
+    return fileName;
+  }
 
-    @Override
-    public String toString() {
-        return new StringBuilder()//
-                .append(super.toString())//
-                .append(" filename=").append(fileName)//
-                .toString();
-    }
+  @Override
+  public String toString() {
+    return super.toString() + " filename=" + fileName;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
index 306750057..b164fbc2b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
@@ -12,50 +12,50 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 import java.io.File;
 import java.nio.charset.Charset;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 public class FilePart extends FileLikePart {
 
-    private final File file;
-
-    public FilePart(String name, File file) {
-        this(name, file, null);
-    }
-
-    public FilePart(String name, File file, String contentType) {
-        this(name, file, contentType, null);
-    }
-
-    public FilePart(String name, File file, String contentType, Charset charset) {
-        this(name, file, contentType, charset, null);
-    }
-
-    public FilePart(String name, File file, String contentType, Charset charset, String fileName) {
-        this(name, file, contentType, charset, fileName, null);
-    }
-
-    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId) {
-        this(name, file, contentType, charset, fileName, contentId, null);
-    }
-
-    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
-        super(name,//
-                contentType,//
-                charset,//
-                fileName != null ? fileName : file.getName(),//
-                contentId,//
-                transferEncoding);
-        if (!assertNotNull(file, "file").isFile())
-            throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
-        if (!file.canRead())
-            throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
-        this.file = file;
-    }
-
-    public File getFile() {
-        return file;
-    }
+  private final File file;
+
+  public FilePart(String name, File file) {
+    this(name, file, null);
+  }
+
+  public FilePart(String name, File file, String contentType) {
+    this(name, file, contentType, null);
+  }
+
+  public FilePart(String name, File file, String contentType, Charset charset) {
+    this(name, file, contentType, charset, null);
+  }
+
+  public FilePart(String name, File file, String contentType, Charset charset, String fileName) {
+    this(name, file, contentType, charset, fileName, null);
+  }
+
+  public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId) {
+    this(name, file, contentType, charset, fileName, contentId, null);
+  }
+
+  public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+    super(name,
+            contentType,
+            charset,
+            fileName != null ? fileName : file.getName(),
+            contentId,
+            transferEncoding);
+    if (!assertNotNull(file, "file").isFile())
+      throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
+    if (!file.canRead())
+      throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
+    this.file = file;
+  }
+
+  public File getFile() {
+    return file;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
deleted file mode 100644
index 8dcf9c777..000000000
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
-* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
-*
-* This program is licensed to you under the Apache License Version 2.0,
-* and you may not use this file except in compliance with the Apache License Version 2.0.
-* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the Apache License Version 2.0 is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
-*/
-package org.asynchttpclient.request.body.multipart;
-
-import java.io.IOException;
-
-/**
- * @author Gail Hernandez
- */
-@SuppressWarnings("serial")
-public class FileUploadStalledException extends IOException {
-}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/InputStreamPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/InputStreamPart.java
new file mode 100644
index 000000000..ca7d0db36
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/InputStreamPart.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
+public class InputStreamPart extends FileLikePart {
+
+  private final InputStream inputStream;
+  private final long contentLength;
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName) {
+    this(name, inputStream, fileName, -1);
+  }
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName, long contentLength) {
+    this(name, inputStream, fileName, contentLength, null);
+  }
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName, long contentLength, String contentType) {
+    this(name, inputStream, fileName, contentLength, contentType, null);
+  }
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName, long contentLength, String contentType, Charset charset) {
+    this(name, inputStream, fileName, contentLength, contentType, charset, null);
+  }
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName, long contentLength, String contentType, Charset charset,
+                         String contentId) {
+    this(name, inputStream, fileName, contentLength, contentType, charset, contentId, null);
+  }
+
+  public InputStreamPart(String name, InputStream inputStream, String fileName, long contentLength, String contentType, Charset charset,
+                         String contentId, String transferEncoding) {
+    super(name,
+            contentType,
+            charset,
+            fileName,
+            contentId,
+            transferEncoding);
+    this.inputStream = assertNotNull(inputStream, "inputStream");
+    this.contentLength = contentLength;
+  }
+
+  public InputStream getInputStream() {
+    return inputStream;
+  }
+
+  public long getContentLength() {
+    return contentLength;
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
index 16f590d06..f2d8eb959 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
@@ -13,15 +13,7 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.buffer.ByteBuf;
-
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.asynchttpclient.netty.request.body.BodyChunkedInput;
 import org.asynchttpclient.request.body.RandomAccessBody;
 import org.asynchttpclient.request.body.multipart.part.MultipartPart;
@@ -29,106 +21,114 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class MultipartBody implements RandomAccessBody {
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-    private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
-
-    private final List<MultipartPart<? extends Part>> parts;
-    private final String contentType;
-    private final byte[] boundary;
-    private final long contentLength;
-    private int currentPartIndex;
-    private boolean done = false;
-    private AtomicBoolean closed = new AtomicBoolean();
-
-    public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
-        this.boundary = boundary;
-        this.contentType = contentType;
-        this.parts = assertNotNull(parts, "parts");
-        this.contentLength = computeContentLength();
-    }
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
-    private long computeContentLength() {
-        try {
-            long total = 0;
-            for (MultipartPart<? extends Part> part : parts) {
-                long l = part.length();
-                if (l < 0) {
-                    return -1;
-                }
-                total += l;
-            }
-            return total;
-        } catch (Exception e) {
-            LOGGER.error("An exception occurred while getting the length of the parts", e);
-            return 0L;
-        }
-    }
+public class MultipartBody implements RandomAccessBody {
 
-    public void close() throws IOException {
-        if (closed.compareAndSet(false, true)) {
-            for (MultipartPart<? extends Part> part : parts) {
-                closeSilently(part);
-            }
+  private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
+
+  private final List<MultipartPart<? extends Part>> parts;
+  private final String contentType;
+  private final byte[] boundary;
+  private final long contentLength;
+  private int currentPartIndex;
+  private boolean done = false;
+  private AtomicBoolean closed = new AtomicBoolean();
+
+  public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
+    this.boundary = boundary;
+    this.contentType = contentType;
+    this.parts = assertNotNull(parts, "parts");
+    this.contentLength = computeContentLength();
+  }
+
+  private long computeContentLength() {
+    try {
+      long total = 0;
+      for (MultipartPart<? extends Part> part : parts) {
+        long l = part.length();
+        if (l < 0) {
+          return -1;
         }
+        total += l;
+      }
+      return total;
+    } catch (Exception e) {
+      LOGGER.error("An exception occurred while getting the length of the parts", e);
+      return 0L;
     }
+  }
 
-    public long getContentLength() {
-        return contentLength;
+  public void close() {
+    if (closed.compareAndSet(false, true)) {
+      for (MultipartPart<? extends Part> part : parts) {
+        closeSilently(part);
+      }
     }
+  }
 
-    public String getContentType() {
-        return contentType;
-    }
+  public long getContentLength() {
+    return contentLength;
+  }
 
-    public byte[] getBoundary() {
-        return boundary;
-    }
+  public String getContentType() {
+    return contentType;
+  }
 
-    // Regular Body API
-    public BodyState transferTo(ByteBuf target) throws IOException {
+  public byte[] getBoundary() {
+    return boundary;
+  }
 
-        if (done)
-            return BodyState.STOP;
+  // Regular Body API
+  public BodyState transferTo(ByteBuf target) throws IOException {
 
-        while (target.isWritable() && !done) {
-            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
-            currentPart.transferTo(target);
+    if (done)
+      return BodyState.STOP;
 
-            if (currentPart.getState() == MultipartState.DONE) {
-                currentPartIndex++;
-                if (currentPartIndex == parts.size()) {
-                    done = true;
-                }
-            }
-        }
+    while (target.isWritable() && !done) {
+      MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+      currentPart.transferTo(target);
 
-        return BodyState.CONTINUE;
+      if (currentPart.getState() == MultipartState.DONE) {
+        currentPartIndex++;
+        if (currentPartIndex == parts.size()) {
+          done = true;
+        }
+      }
     }
 
-    // RandomAccessBody API, suited for HTTP but not for HTTPS (zero-copy)
-    @Override
-    public long transferTo(WritableByteChannel target) throws IOException {
+    return BodyState.CONTINUE;
+  }
 
-        if (done)
-            return -1L;
+  // RandomAccessBody API, suited for HTTP but not for HTTPS (zero-copy)
+  @Override
+  public long transferTo(WritableByteChannel target) throws IOException {
 
-        long transferred = 0L;
-        boolean slowTarget = false;
+    if (done)
+      return -1L;
 
-        while (transferred < BodyChunkedInput.DEFAULT_CHUNK_SIZE && !done && !slowTarget) {
-            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
-            transferred += currentPart.transferTo(target);
-            slowTarget = currentPart.isTargetSlow();
+    long transferred = 0L;
+    boolean slowTarget = false;
 
-            if (currentPart.getState() == MultipartState.DONE) {
-                currentPartIndex++;
-                if (currentPartIndex == parts.size()) {
-                    done = true;
-                }
-            }
-        }
+    while (transferred < BodyChunkedInput.DEFAULT_CHUNK_SIZE && !done && !slowTarget) {
+      MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+      transferred += currentPart.transferTo(target);
+      slowTarget = currentPart.isTargetSlow();
 
-        return transferred;
+      if (currentPart.getState() == MultipartState.DONE) {
+        currentPartIndex++;
+        if (currentPartIndex == parts.size()) {
+          done = true;
+        }
+      }
     }
+
+    return transferred;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index de3f30b8e..78e2d130a 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -13,102 +13,78 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.request.body.multipart.part.*;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ThreadLocalRandom;
 
-import org.asynchttpclient.request.body.multipart.part.ByteArrayMultipartPart;
-import org.asynchttpclient.request.body.multipart.part.FileMultipartPart;
-import org.asynchttpclient.request.body.multipart.part.MessageEndMultipartPart;
-import org.asynchttpclient.request.body.multipart.part.MultipartPart;
-import org.asynchttpclient.request.body.multipart.part.StringMultipartPart;
-import org.asynchttpclient.util.StringBuilderPool;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 public class MultipartUtils {
 
-    /**
-     * The pool of ASCII chars to be used for generating a multipart boundary.
-     */
-    private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(US_ASCII);
-
-    /**
-     * Creates a new multipart entity containing the given parts.
-     * 
-     * @param parts the parts to include.
-     * @param requestHeaders the request headers
-     * @return a MultipartBody
-     */
-    public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders requestHeaders) {
-        assertNotNull(parts, "parts");
-
-        byte[] boundary;
-        String contentType;
-
-        String contentTypeHeader = requestHeaders.get(CONTENT_TYPE);
-        if (isNonEmpty(contentTypeHeader)) {
-            int boundaryLocation = contentTypeHeader.indexOf("boundary=");
-            if (boundaryLocation != -1) {
-                // boundary defined in existing Content-Type
-                contentType = contentTypeHeader;
-                boundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim()).getBytes(US_ASCII);
-            } else {
-                // generate boundary and append it to existing Content-Type
-                boundary = generateBoundary();
-                contentType = computeContentType(contentTypeHeader, boundary);
-            }
-        } else {
-            boundary = generateBoundary();
-            contentType = computeContentType(HttpHeaderValues.MULTIPART_FORM_DATA, boundary);
-        }
-
-        List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
-
-        return new MultipartBody(multipartParts, contentType, boundary);
+  /**
+   * Creates a new multipart entity containing the given parts.
+   *
+   * @param parts          the parts to include.
+   * @param requestHeaders the request headers
+   * @return a MultipartBody
+   */
+  public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders requestHeaders) {
+    assertNotNull(parts, "parts");
+
+    byte[] boundary;
+    String contentType;
+
+    String contentTypeHeader = requestHeaders.get(CONTENT_TYPE);
+    if (isNonEmpty(contentTypeHeader)) {
+      int boundaryLocation = contentTypeHeader.indexOf("boundary=");
+      if (boundaryLocation != -1) {
+        // boundary defined in existing Content-Type
+        contentType = contentTypeHeader;
+        boundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim()).getBytes(US_ASCII);
+      } else {
+        // generate boundary and append it to existing Content-Type
+        boundary = computeMultipartBoundary();
+        contentType = patchContentTypeWithBoundaryAttribute(contentTypeHeader, boundary);
+      }
+    } else {
+      boundary = computeMultipartBoundary();
+      contentType = patchContentTypeWithBoundaryAttribute(HttpHeaderValues.MULTIPART_FORM_DATA, boundary);
     }
 
-    public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
-        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
-        for (Part part : parts) {
-            if (part instanceof FilePart) {
-                multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
+    List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
 
-            } else if (part instanceof ByteArrayPart) {
-                multipartParts.add(new ByteArrayMultipartPart((ByteArrayPart) part, boundary));
+    return new MultipartBody(multipartParts, contentType, boundary);
+  }
 
-            } else if (part instanceof StringPart) {
-                multipartParts.add(new StringMultipartPart((StringPart) part, boundary));
+  public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
+    List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
+    for (Part part : parts) {
+      if (part instanceof FilePart) {
+        multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
 
-            } else {
-                throw new IllegalArgumentException("Unknown part type: " + part);
-            }
-        }
-        // add an extra fake part for terminating the message
-        multipartParts.add(new MessageEndMultipartPart(boundary));
+      } else if (part instanceof ByteArrayPart) {
+        multipartParts.add(new ByteArrayMultipartPart((ByteArrayPart) part, boundary));
 
-        return multipartParts;
-    }
+      } else if (part instanceof StringPart) {
+        multipartParts.add(new StringMultipartPart((StringPart) part, boundary));
 
-    // a random size from 30 to 40
-    private static byte[] generateBoundary() {
-        ThreadLocalRandom random = ThreadLocalRandom.current();
-        byte[] bytes = new byte[random.nextInt(11) + 30];
-        for (int i = 0; i < bytes.length; i++) {
-            bytes[i] = MULTIPART_CHARS[random.nextInt(MULTIPART_CHARS.length)];
-        }
-        return bytes;
-    }
+      } else if (part instanceof InputStreamPart) {
+        multipartParts.add(new InputStreamMultipartPart((InputStreamPart) part, boundary));
 
-    private static String computeContentType(CharSequence base, byte[] boundary) {
-        StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder().append(base);
-        if (base.length() != 0 && base.charAt(base.length() - 1) != ';')
-            buffer.append(';');
-        return buffer.append(" boundary=").append(new String(boundary, US_ASCII)).toString();
+      } else {
+        throw new IllegalArgumentException("Unknown part type: " + part);
+      }
     }
+    // add an extra fake part for terminating the message
+    multipartParts.add(new MessageEndMultipartPart(boundary));
+
+    return multipartParts;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
index cb84fce34..77c4a0f07 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
@@ -12,110 +12,58 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
+import org.asynchttpclient.Param;
 
 import java.nio.charset.Charset;
 import java.util.List;
 
-import org.asynchttpclient.Param;
-
 public interface Part {
 
-    /**
-     * Carriage return/linefeed as a byte array
-     */
-    byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
-
-    /**
-     * Content dispostion as a byte
-     */
-    byte QUOTE_BYTE = '\"';
-
-    /**
-     * Extra characters as a byte array
-     */
-    byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
-
-    /**
-     * Content dispostion as a byte array
-     */
-    byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
-
-    /**
-     * form-data as a byte array
-     */
-    byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
-
-    /**
-     * name as a byte array
-     */
-    byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
-
-    /**
-     * Content charset as a byte array
-     */
-    byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
-
-    /**
-     * Return the name of this part.
-     * 
-     * @return The name.
-     */
-    String getName();
-
-    /**
-     * Returns the content type of this part.
-     * 
-     * @return the content type, or <code>null</code> to exclude the content
-     *         type header
-     */
-    String getContentType();
-
-    /**
-     * Return the character encoding of this part.
-     * 
-     * @return the character encoding, or <code>null</code> to exclude the
-     *         character encoding header
-     */
-    Charset getCharset();
-
-    /**
-     * Return the transfer encoding of this part.
-     * 
-     * @return the transfer encoding, or <code>null</code> to exclude the
-     *         transfer encoding header
-     */
-    String getTransferEncoding();
-
-    /**
-     * Return the content ID of this part.
-     * 
-     * @return the content ID, or <code>null</code> to exclude the content ID
-     *         header
-     */
-    String getContentId();
-
-    /**
-     * Gets the disposition-type to be used in Content-Disposition header
-     * 
-     * @return the disposition-type
-     */
-    String getDispositionType();
-
-    List<Param> getCustomHeaders();
+  /**
+   * Return the name of this part.
+   *
+   * @return The name.
+   */
+  String getName();
+
+  /**
+   * Returns the content type of this part.
+   *
+   * @return the content type, or <code>null</code> to exclude the content
+   * type header
+   */
+  String getContentType();
+
+  /**
+   * Return the character encoding of this part.
+   *
+   * @return the character encoding, or <code>null</code> to exclude the
+   * character encoding header
+   */
+  Charset getCharset();
+
+  /**
+   * Return the transfer encoding of this part.
+   *
+   * @return the transfer encoding, or <code>null</code> to exclude the
+   * transfer encoding header
+   */
+  String getTransferEncoding();
+
+  /**
+   * Return the content ID of this part.
+   *
+   * @return the content ID, or <code>null</code> to exclude the content ID
+   * header
+   */
+  String getContentId();
+
+  /**
+   * Gets the disposition-type to be used in Content-Disposition header
+   *
+   * @return the disposition-type
+   */
+  String getDispositionType();
+
+  List<Param> getCustomHeaders();
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index ba487476c..950f3987e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -12,125 +12,123 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import org.asynchttpclient.Param;
+
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.asynchttpclient.Param;
-
 public abstract class PartBase implements Part {
 
-    /**
-     * The name of the form field, part of the Content-Disposition header
-     */
-    private final String name;
-
-    /**
-     * The main part of the Content-Type header
-     */
-    private final String contentType;
-
-    /**
-     * The charset (part of Content-Type header)
-     */
-    private final Charset charset;
-
-    /**
-     * The Content-Transfer-Encoding header value.
-     */
-    private final String transferEncoding;
-
-    /**
-     * The Content-Id
-     */
-    private final String contentId;
-
-    /**
-     * The disposition type (part of Content-Disposition)
-     */
-    private String dispositionType;
-
-    /**
-     * Additional part headers
-     */
-    private List<Param> customHeaders;
-
-    /**
-     * Constructor.
-     * 
-     * @param name The name of the part, or <code>null</code>
-     * @param contentType The content type, or <code>null</code>
-     * @param charset The character encoding, or <code>null</code>
-     * @param contentId The content id, or <code>null</code>
-     * @param transferEncoding The transfer encoding, or <code>null</code>
-     */
-    public PartBase(String name, String contentType, Charset charset, String contentId, String transferEncoding) {
-        this.name = name;
-        this.contentType = contentType;
-        this.charset = charset;
-        this.contentId = contentId;
-        this.transferEncoding = transferEncoding;
-    }
-
-    @Override
-    public String getName() {
-        return this.name;
-    }
-
-    @Override
-    public String getContentType() {
-        return this.contentType;
-    }
-
-    @Override
-    public Charset getCharset() {
-        return this.charset;
-    }
-
-    @Override
-    public String getTransferEncoding() {
-        return transferEncoding;
-    }
-
-    @Override
-    public String getContentId() {
-        return contentId;
-    }
-
-    @Override
-    public String getDispositionType() {
-        return dispositionType;
-    }
-
-    @Override
-    public List<Param> getCustomHeaders() {
-        return customHeaders;
-    }
-
-    public void setDispositionType(String dispositionType) {
-        this.dispositionType = dispositionType;
-    }
-
-    public void addCustomHeader(String name, String value) {
-        if (customHeaders == null) {
-            customHeaders = new ArrayList<>(2);
-        }
-        customHeaders.add(new Param(name, value));
-    }
-
-    public void setCustomHeaders(List<Param> customHeaders) {
-        this.customHeaders = customHeaders;
-    }
-
-    public String toString() {
-        return new StringBuilder()//
-                .append(getClass().getSimpleName())//
-                .append(" name=").append(getName())//
-                .append(" contentType=").append(getContentType())//
-                .append(" charset=").append(getCharset())//
-                .append(" tranferEncoding=").append(getTransferEncoding())//
-                .append(" contentId=").append(getContentId())//
-                .append(" dispositionType=").append(getDispositionType())//
-                .toString();
+  /**
+   * The name of the form field, part of the Content-Disposition header
+   */
+  private final String name;
+
+  /**
+   * The main part of the Content-Type header
+   */
+  private final String contentType;
+
+  /**
+   * The charset (part of Content-Type header)
+   */
+  private final Charset charset;
+
+  /**
+   * The Content-Transfer-Encoding header value.
+   */
+  private final String transferEncoding;
+
+  /**
+   * The Content-Id
+   */
+  private final String contentId;
+
+  /**
+   * The disposition type (part of Content-Disposition)
+   */
+  private String dispositionType;
+
+  /**
+   * Additional part headers
+   */
+  private List<Param> customHeaders;
+
+  /**
+   * Constructor.
+   *
+   * @param name             The name of the part, or <code>null</code>
+   * @param contentType      The content type, or <code>null</code>
+   * @param charset          The character encoding, or <code>null</code>
+   * @param contentId        The content id, or <code>null</code>
+   * @param transferEncoding The transfer encoding, or <code>null</code>
+   */
+  public PartBase(String name, String contentType, Charset charset, String contentId, String transferEncoding) {
+    this.name = name;
+    this.contentType = contentType;
+    this.charset = charset;
+    this.contentId = contentId;
+    this.transferEncoding = transferEncoding;
+  }
+
+  @Override
+  public String getName() {
+    return this.name;
+  }
+
+  @Override
+  public String getContentType() {
+    return this.contentType;
+  }
+
+  @Override
+  public Charset getCharset() {
+    return this.charset;
+  }
+
+  @Override
+  public String getTransferEncoding() {
+    return transferEncoding;
+  }
+
+  @Override
+  public String getContentId() {
+    return contentId;
+  }
+
+  @Override
+  public String getDispositionType() {
+    return dispositionType;
+  }
+
+  public void setDispositionType(String dispositionType) {
+    this.dispositionType = dispositionType;
+  }
+
+  @Override
+  public List<Param> getCustomHeaders() {
+    return customHeaders;
+  }
+
+  public void setCustomHeaders(List<Param> customHeaders) {
+    this.customHeaders = customHeaders;
+  }
+
+  public void addCustomHeader(String name, String value) {
+    if (customHeaders == null) {
+      customHeaders = new ArrayList<>(2);
     }
+    customHeaders.add(new Param(name, value));
+  }
+
+  public String toString() {
+    return getClass().getSimpleName() +
+            " name=" + getName() +
+            " contentType=" + getContentType() +
+            " charset=" + getCharset() +
+            " tranferEncoding=" + getTransferEncoding() +
+            " contentId=" + getContentId() +
+            " dispositionType=" + getDispositionType();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
index 5420000ab..6d2e078cb 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
@@ -12,56 +12,56 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import java.nio.charset.Charset;
+
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.MiscUtils.withDefault;
 
-import java.nio.charset.Charset;
-
 public class StringPart extends PartBase {
 
-    /**
-     * Default charset of string parameters
-     */
-    public static final Charset DEFAULT_CHARSET = UTF_8;
+  /**
+   * Default charset of string parameters
+   */
+  private static final Charset DEFAULT_CHARSET = UTF_8;
 
-    /**
-     * Contents of this StringPart.
-     */
-    private final String value;
+  /**
+   * Contents of this StringPart.
+   */
+  private final String value;
 
-    private static Charset charsetOrDefault(Charset charset) {
-        return withDefault(charset, DEFAULT_CHARSET);
-    }
+  public StringPart(String name, String value) {
+    this(name, value, null);
+  }
 
-    public StringPart(String name, String value) {
-        this(name, value, null);
-    }
+  public StringPart(String name, String value, String contentType) {
+    this(name, value, contentType, null);
+  }
 
-    public StringPart(String name, String value, String contentType) {
-        this(name, value, contentType, null);
-    }
+  public StringPart(String name, String value, String contentType, Charset charset) {
+    this(name, value, contentType, charset, null);
+  }
 
-    public StringPart(String name, String value, String contentType, Charset charset) {
-        this(name, value, contentType, charset, null);
-    }
+  public StringPart(String name, String value, String contentType, Charset charset, String contentId) {
+    this(name, value, contentType, charset, contentId, null);
+  }
 
-    public StringPart(String name, String value, String contentType, Charset charset, String contentId) {
-        this(name, value, contentType, charset, contentId, null);
-    }
+  public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
+    super(name, contentType, charsetOrDefault(charset), contentId, transferEncoding);
+    assertNotNull(value, "value");
 
-    public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
-        super(name, contentType, charsetOrDefault(charset), contentId, transferEncoding);
-        assertNotNull(value, "value");
+    if (value.indexOf(0) != -1)
+      // See RFC 2048, 2.8. "8bit Data"
+      throw new IllegalArgumentException("NULs may not be present in string parts");
 
-        if (value.indexOf(0) != -1)
-            // See RFC 2048, 2.8. "8bit Data"
-            throw new IllegalArgumentException("NULs may not be present in string parts");
+    this.value = value;
+  }
 
-        this.value = value;
-    }
+  private static Charset charsetOrDefault(Charset charset) {
+    return withDefault(charset, DEFAULT_CHARSET);
+  }
 
-    public String getValue() {
-        return value;
-    }
+  public String getValue() {
+    return value;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
index 4d44ee78c..d54560107 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
@@ -15,39 +15,38 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
-import org.asynchttpclient.request.body.multipart.ByteArrayPart;
-
 public class ByteArrayMultipartPart extends FileLikeMultipartPart<ByteArrayPart> {
 
-    private final ByteBuf contentBuffer;
-
-    public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
-        super(part, boundary);
-        contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
-    }
-
-    @Override
-    protected long getContentLength() {
-        return part.getBytes().length;
-    }
-
-    @Override
-    protected long transferContentTo(ByteBuf target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-    }
-
-    @Override
-    protected long transferContentTo(WritableByteChannel target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-    }
-
-    @Override
-    public void close() {
-        super.close();
-        contentBuffer.release();
-    }
+  private final ByteBuf contentBuffer;
+
+  public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
+    super(part, boundary);
+    contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
+  }
+
+  @Override
+  protected long getContentLength() {
+    return part.getBytes().length;
+  }
+
+  @Override
+  protected long transferContentTo(ByteBuf target) {
+    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+  }
+
+  @Override
+  protected long transferContentTo(WritableByteChannel target) throws IOException {
+    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+  }
+
+  @Override
+  public void close() {
+    super.close();
+    contentBuffer.release();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
index c564a7259..e3023cc62 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
@@ -1,27 +1,27 @@
 package org.asynchttpclient.request.body.multipart.part;
 
-import static java.nio.charset.StandardCharsets.*;
-
 import org.asynchttpclient.request.body.multipart.FileLikePart;
 
+import static java.nio.charset.StandardCharsets.*;
+
 public abstract class FileLikeMultipartPart<T extends FileLikePart> extends MultipartPart<T> {
 
-    /**
-     * Attachment's file name as a byte array
-     */
-    private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
-    
-    public FileLikeMultipartPart(T part, byte[] boundary) {
-        super(part, boundary);
-    }
-    
-    protected void visitDispositionHeader(PartVisitor visitor) {
-        super.visitDispositionHeader(visitor);
-        if (part.getFileName() != null) {
-            visitor.withBytes(FILE_NAME_BYTES);
-            visitor.withByte(QUOTE_BYTE);
-            visitor.withBytes(part.getFileName().getBytes(part.getCharset() != null ? part.getCharset() : UTF_8));
-            visitor.withByte(QUOTE_BYTE);
-        }
+  /**
+   * Attachment's file name as a byte array
+   */
+  private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
+
+  FileLikeMultipartPart(T part, byte[] boundary) {
+    super(part, boundary);
+  }
+
+  protected void visitDispositionHeader(PartVisitor visitor) {
+    super.visitDispositionHeader(visitor);
+    if (part.getFileName() != null) {
+      visitor.withBytes(FILE_NAME_BYTES);
+      visitor.withByte(QUOTE_BYTE);
+      visitor.withBytes(part.getFileName().getBytes(part.getCharset() != null ? part.getCharset() : UTF_8));
+      visitor.withByte(QUOTE_BYTE);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
index 007778cf6..1b5caca7a 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
@@ -13,69 +13,84 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.multipart.FilePart;
 
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.RandomAccessFile;
+import java.io.*;
 import java.nio.channels.FileChannel;
 import java.nio.channels.WritableByteChannel;
 
-import org.asynchttpclient.netty.request.body.BodyChunkedInput;
-import org.asynchttpclient.request.body.multipart.FilePart;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 public class FileMultipartPart extends FileLikeMultipartPart<FilePart> {
 
-    private final FileChannel channel;
-    private final long length;
-    private long position = 0L;
+  private final long length;
+  private FileChannel channel;
+  private long position = 0L;
 
-    @SuppressWarnings("resource")
-    public FileMultipartPart(FilePart part, byte[] boundary) {
-        super(part, boundary);
-        try {
-            channel = new RandomAccessFile(part.getFile(), "r").getChannel();
-        } catch (FileNotFoundException e) {
-            throw new IllegalArgumentException("File part doesn't exist: " + part.getFile().getAbsolutePath(), e);
-        }
-        length = part.getFile().length();
+  public FileMultipartPart(FilePart part, byte[] boundary) {
+    super(part, boundary);
+    File file = part.getFile();
+    if (!file.exists()) {
+      throw new IllegalArgumentException("File part doesn't exist: " + file.getAbsolutePath());
+    } else if (!file.canRead()) {
+      throw new IllegalArgumentException("File part can't be read: " + file.getAbsolutePath());
     }
+    length = file.length();
+  }
 
-    @Override
-    protected long getContentLength() {
-        return part.getFile().length();
+  private FileChannel getChannel() throws IOException {
+    if (channel == null) {
+      channel = new RandomAccessFile(part.getFile(), "r").getChannel();
     }
+    return channel;
+  }
 
-    @Override
-    protected long transferContentTo(ByteBuf target) throws IOException {
-        int transferred = target.writeBytes(channel, target.writableBytes());
-        position += transferred;
-        if (position == length) {
-            state = MultipartState.POST_CONTENT;
-            channel.close();
-        }
-        return transferred;
-    }
+  @Override
+  protected long getContentLength() {
+    return length;
+  }
 
-    @Override
-    protected long transferContentTo(WritableByteChannel target) throws IOException {
-        // WARN: don't use channel.position(), it's always 0 here
-        // from FileChannel javadoc: "This method does not modify this channel's position."
-        long transferred = channel.transferTo(position, BodyChunkedInput.DEFAULT_CHUNK_SIZE, target);
-        position += transferred;
-        if (position == length) {
-            state = MultipartState.POST_CONTENT;
-            channel.close();
-        } else {
-            slowTarget = true;
-        }
-        return transferred;
+  @Override
+  protected long transferContentTo(ByteBuf target) throws IOException {
+    // can return -1 if file is empty or FileChannel was closed
+    int transferred = target.writeBytes(getChannel(), target.writableBytes());
+    if (transferred > 0) {
+      position += transferred;
+    }
+    if (position == length || transferred < 0) {
+      state = MultipartState.POST_CONTENT;
+      if (channel.isOpen()) {
+        channel.close();
+      }
     }
+    return transferred;
+  }
 
-    @Override
-    public void close() {
-        super.close();
-        closeSilently(channel);
+  @Override
+  protected long transferContentTo(WritableByteChannel target) throws IOException {
+    // WARN: don't use channel.position(), it's always 0 here
+    // from FileChannel javadoc: "This method does not modify this channel's
+    // position."
+    long transferred = getChannel().transferTo(position, BodyChunkedInput.DEFAULT_CHUNK_SIZE, target);
+    if (transferred > 0) {
+      position += transferred;
     }
+    if (position == length || transferred < 0) {
+      state = MultipartState.POST_CONTENT;
+      if (channel.isOpen()) {
+        channel.close();
+      }
+    } else {
+      slowTarget = true;
+    }
+    return transferred;
+  }
+
+  @Override
+  public void close() {
+    super.close();
+    closeSilently(channel);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/InputStreamMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/InputStreamMultipartPart.java
new file mode 100644
index 000000000..1c2ca251d
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/InputStreamMultipartPart.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.multipart.InputStreamPart;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+public class InputStreamMultipartPart extends FileLikeMultipartPart<InputStreamPart> {
+
+  private long position = 0L;
+  private ByteBuffer buffer;
+  private ReadableByteChannel channel;
+
+  public InputStreamMultipartPart(InputStreamPart part, byte[] boundary) {
+    super(part, boundary);
+  }
+
+  private ByteBuffer getBuffer() {
+    if (buffer == null) {
+      buffer = ByteBuffer.allocateDirect(BodyChunkedInput.DEFAULT_CHUNK_SIZE);
+    }
+    return buffer;
+  }
+
+  private ReadableByteChannel getChannel() {
+    if (channel == null) {
+      channel = Channels.newChannel(part.getInputStream());
+    }
+    return channel;
+  }
+
+  @Override
+  protected long getContentLength() {
+    return part.getContentLength();
+  }
+
+  @Override
+  protected long transferContentTo(ByteBuf target) throws IOException {
+    InputStream inputStream = part.getInputStream();
+    int transferred = target.writeBytes(inputStream, target.writableBytes());
+    if (transferred > 0) {
+      position += transferred;
+    }
+    if (position == getContentLength() || transferred < 0) {
+      state = MultipartState.POST_CONTENT;
+      inputStream.close();
+    }
+    return transferred;
+  }
+
+  @Override
+  protected long transferContentTo(WritableByteChannel target) throws IOException {
+    ReadableByteChannel channel = getChannel();
+    ByteBuffer buffer = getBuffer();
+
+    int transferred = 0;
+    int read = channel.read(buffer);
+
+    if (read > 0) {
+      buffer.flip();
+      while (buffer.hasRemaining()) {
+        transferred += target.write(buffer);
+      }
+      buffer.compact();
+      position += transferred;
+    }
+    if (position == getContentLength() || read < 0) {
+      state = MultipartState.POST_CONTENT;
+      if (channel.isOpen()) {
+        channel.close();
+      }
+    }
+
+    return transferred;
+  }
+
+  @Override
+  public void close() {
+    super.close();
+    closeSilently(part.getInputStream());
+    closeSilently(channel);
+  }
+
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
index 6c3b20133..e81fb905f 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
@@ -13,84 +13,82 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
-import static org.asynchttpclient.request.body.multipart.Part.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.Unpooled;
+import org.asynchttpclient.request.body.multipart.FileLikePart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
-import org.asynchttpclient.request.body.multipart.FileLikePart;
-
 public class MessageEndMultipartPart extends MultipartPart<FileLikePart> {
 
-    // lazy
-    private ByteBuf contentBuffer;
-
-    public MessageEndMultipartPart(byte[] boundary) {
-        super(null, boundary);
-        state = MultipartState.PRE_CONTENT;
-    }
-
-    @Override
-    public long transferTo(ByteBuf target) throws IOException {
-        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
-    }
-
-    @Override
-    public long transferTo(WritableByteChannel target) throws IOException {
-        slowTarget = false;
-        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
-    }
-
-    private ByteBuf lazyLoadContentBuffer() {
-        if (contentBuffer == null) {
-            contentBuffer = ByteBufAllocator.DEFAULT.buffer((int) getContentLength());
-            contentBuffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
-        }
-        return contentBuffer;
-    }
-
-    @Override
-    protected int computePreContentLength() {
-        return 0;
-    }
-
-    @Override
-    protected ByteBuf computePreContentBytes(int preContentLength) {
-        return Unpooled.EMPTY_BUFFER;
-    }
-
-    @Override
-    protected int computePostContentLength() {
-        return 0;
-    }
-
-    @Override
-    protected ByteBuf computePostContentBytes(int postContentLength) {
-        return Unpooled.EMPTY_BUFFER;
-    }
-
-    @Override
-    protected long getContentLength() {
-        return EXTRA_BYTES.length + boundary.length + EXTRA_BYTES.length + CRLF_BYTES.length;
-    }
-
-    @Override
-    protected long transferContentTo(ByteBuf target) throws IOException {
-        throw new UnsupportedOperationException("Not supposed to be called");
-    }
-
-    @Override
-    protected long transferContentTo(WritableByteChannel target) throws IOException {
-        throw new UnsupportedOperationException("Not supposed to be called");
-    }
-
-    @Override
-    public void close() {
-        super.close();
-        if (contentBuffer != null)
-            contentBuffer.release();
+  // lazy
+  private ByteBuf contentBuffer;
+
+  public MessageEndMultipartPart(byte[] boundary) {
+    super(null, boundary);
+    state = MultipartState.PRE_CONTENT;
+  }
+
+  @Override
+  public long transferTo(ByteBuf target) {
+    return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
+  }
+
+  @Override
+  public long transferTo(WritableByteChannel target) throws IOException {
+    slowTarget = false;
+    return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
+  }
+
+  private ByteBuf lazyLoadContentBuffer() {
+    if (contentBuffer == null) {
+      contentBuffer = ByteBufAllocator.DEFAULT.buffer((int) getContentLength());
+      contentBuffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
     }
+    return contentBuffer;
+  }
+
+  @Override
+  protected int computePreContentLength() {
+    return 0;
+  }
+
+  @Override
+  protected ByteBuf computePreContentBytes(int preContentLength) {
+    return Unpooled.EMPTY_BUFFER;
+  }
+
+  @Override
+  protected int computePostContentLength() {
+    return 0;
+  }
+
+  @Override
+  protected ByteBuf computePostContentBytes(int postContentLength) {
+    return Unpooled.EMPTY_BUFFER;
+  }
+
+  @Override
+  protected long getContentLength() {
+    return EXTRA_BYTES.length + boundary.length + EXTRA_BYTES.length + CRLF_BYTES.length;
+  }
+
+  @Override
+  protected long transferContentTo(ByteBuf target) {
+    throw new UnsupportedOperationException("Not supposed to be called");
+  }
+
+  @Override
+  protected long transferContentTo(WritableByteChannel target) {
+    throw new UnsupportedOperationException("Not supposed to be called");
+  }
+
+  @Override
+  public void close() {
+    super.close();
+    if (contentBuffer != null)
+      contentBuffer.release();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
index 8f9d61081..b8c862268 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -13,10 +13,12 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.request.body.multipart.PartBase;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.ByteBufVisitor;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -25,311 +27,311 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 
-import org.asynchttpclient.Param;
-import org.asynchttpclient.request.body.multipart.PartBase;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.ByteBufVisitor;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 public abstract class MultipartPart<T extends PartBase> implements Closeable {
 
-    /**
-     * Carriage return/linefeed as a byte array
-     */
-    private static final byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
-
-    /**
-     * Content disposition as a byte
-     */
-    protected static final byte QUOTE_BYTE = '\"';
-
-    /**
-     * Extra characters as a byte array
-     */
-    private static final byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
-
-    /**
-     * Content disposition as a byte array
-     */
-    private static final byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
-
-    /**
-     * form-data as a byte array
-     */
-    private static final byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
-
-    /**
-     * name as a byte array
-     */
-    private static final byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    private static final byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
-
-    /**
-     * Content charset as a byte array
-     */
-    private static final byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    private static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
-    
-    /**
-     * Content type header as a byte array
-     */
-    private static final byte[] HEADER_NAME_VALUE_SEPARATOR_BYTES = ": ".getBytes(US_ASCII);
-
-    /**
-     * Content type header as a byte array
-     */
-    private static final byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
-
-    protected final T part;
-    protected final byte[] boundary;
-
-    private final int preContentLength;
-    private final int postContentLength;
-    protected MultipartState state;
-    protected boolean slowTarget;
-
-    // lazy
-    private ByteBuf preContentBuffer;
-    private ByteBuf postContentBuffer;
-
-    public MultipartPart(T part, byte[] boundary) {
-        this.part = part;
-        this.boundary = boundary;
-        preContentLength = computePreContentLength();
-        postContentLength = computePostContentLength();
-        state = MultipartState.PRE_CONTENT;
-    }
-
-    public long length() {
-        return preContentLength + postContentLength + getContentLength();
-    }
-
-    public MultipartState getState() {
-        return state;
-    }
-
-    public boolean isTargetSlow() {
-        return slowTarget;
-    }
-
-    public long transferTo(ByteBuf target) throws IOException {
-
-        switch (state) {
-        case DONE:
-            return 0L;
-
-        case PRE_CONTENT:
-            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
-
-        case CONTENT:
-            return transferContentTo(target);
-
-        case POST_CONTENT:
-            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
-
-        default:
-            throw new IllegalStateException("Unknown state " + state);
-        }
-    }
-
-    public long transferTo(WritableByteChannel target) throws IOException {
-        slowTarget = false;
-
-        switch (state) {
-        case DONE:
-            return 0L;
-
-        case PRE_CONTENT:
-            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
-
-        case CONTENT:
-            return transferContentTo(target);
-
-        case POST_CONTENT:
-            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
-
-        default:
-            throw new IllegalStateException("Unknown state " + state);
-        }
+  /**
+   * Content disposition as a byte
+   */
+  static final byte QUOTE_BYTE = '\"';
+  /**
+   * Carriage return/linefeed as a byte array
+   */
+  protected static final byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
+  /**
+   * Extra characters as a byte array
+   */
+  protected static final byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
+
+  /**
+   * Content disposition as a byte array
+   */
+  private static final byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
+
+  /**
+   * form-data as a byte array
+   */
+  private static final byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
+
+  /**
+   * name as a byte array
+   */
+  private static final byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
+
+  /**
+   * Content type header as a byte array
+   */
+  private static final byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
+
+  /**
+   * Content charset as a byte array
+   */
+  private static final byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
+
+  /**
+   * Content type header as a byte array
+   */
+  private static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
+
+  /**
+   * Content type header as a byte array
+   */
+  private static final byte[] HEADER_NAME_VALUE_SEPARATOR_BYTES = ": ".getBytes(US_ASCII);
+
+  /**
+   * Content type header as a byte array
+   */
+  private static final byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
+
+  protected final T part;
+  protected final byte[] boundary;
+
+  private final int preContentLength;
+  private final int postContentLength;
+  protected MultipartState state;
+  boolean slowTarget;
+
+  // lazy
+  private ByteBuf preContentBuffer;
+  private ByteBuf postContentBuffer;
+
+  MultipartPart(T part, byte[] boundary) {
+    this.part = part;
+    this.boundary = boundary;
+    preContentLength = computePreContentLength();
+    postContentLength = computePostContentLength();
+    state = MultipartState.PRE_CONTENT;
+  }
+
+  public long length() {
+    long contentLength = getContentLength();
+    if (contentLength < 0) {
+      return contentLength;
     }
+    return preContentLength + postContentLength + getContentLength();
+  }
 
-    private ByteBuf lazyLoadPreContentBuffer() {
-        if (preContentBuffer == null)
-            preContentBuffer = computePreContentBytes(preContentLength);
-        return preContentBuffer;
-    }
-
-    private ByteBuf lazyLoadPostContentBuffer() {
-        if (postContentBuffer == null)
-            postContentBuffer = computePostContentBytes(postContentLength);
-        return postContentBuffer;
-    }
+  public MultipartState getState() {
+    return state;
+  }
 
-    @Override
-    public void close() {
-        if (preContentBuffer != null)
-            preContentBuffer.release();
-        if (postContentBuffer != null)
-            postContentBuffer.release();
-    }
+  public boolean isTargetSlow() {
+    return slowTarget;
+  }
 
-    protected abstract long getContentLength();
+  public long transferTo(ByteBuf target) throws IOException {
 
-    protected abstract long transferContentTo(ByteBuf target) throws IOException;
+    switch (state) {
+      case DONE:
+        return 0L;
 
-    protected abstract long transferContentTo(WritableByteChannel target) throws IOException;
+      case PRE_CONTENT:
+        return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
 
-    protected long transfer(ByteBuf source, ByteBuf target, MultipartState sourceFullyWrittenState) {
+      case CONTENT:
+        return transferContentTo(target);
 
-        int sourceRemaining = source.readableBytes();
-        int targetRemaining = target.writableBytes();
+      case POST_CONTENT:
+        return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
 
-        if (sourceRemaining <= targetRemaining) {
-            target.writeBytes(source);
-            state = sourceFullyWrittenState;
-            return sourceRemaining;
-        } else {
-            target.writeBytes(source, targetRemaining);
-            return targetRemaining;
-        }
+      default:
+        throw new IllegalStateException("Unknown state " + state);
     }
+  }
 
-    protected long transfer(ByteBuf source, WritableByteChannel target, MultipartState sourceFullyWrittenState) throws IOException {
-
-        int transferred = 0;
-        if (target instanceof GatheringByteChannel) {
-            transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
-        } else {
-            for (ByteBuffer byteBuffer : source.nioBuffers()) {
-                int len = byteBuffer.remaining();
-                int written = target.write(byteBuffer);
-                transferred += written;
-                if (written != len) {
-                    // couldn't write full buffer, exit loop
-                    break;
-                }
-            }
-            // assume this is a basic single ByteBuf
-            source.readerIndex(source.readerIndex() + transferred);
-        }
+  public long transferTo(WritableByteChannel target) throws IOException {
+    slowTarget = false;
 
-        if (source.isReadable()) {
-            slowTarget = true;
-        } else {
-            state = sourceFullyWrittenState;
-        }
-        return transferred;
-    }
+    switch (state) {
+      case DONE:
+        return 0L;
 
-    protected int computePreContentLength() {
-        CounterPartVisitor counterVisitor = new CounterPartVisitor();
-        visitPreContent(counterVisitor);
-        return counterVisitor.getCount();
-    }
-
-    protected ByteBuf computePreContentBytes(int preContentLength) {
-        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(preContentLength);
-        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
-        visitPreContent(bytesVisitor);
-        return buffer;
-    }
+      case PRE_CONTENT:
+        return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
 
-    protected int computePostContentLength() {
-        CounterPartVisitor counterVisitor = new CounterPartVisitor();
-        visitPostContent(counterVisitor);
-        return counterVisitor.getCount();
-    }
+      case CONTENT:
+        return transferContentTo(target);
 
-    protected ByteBuf computePostContentBytes(int postContentLength) {
-        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(postContentLength);
-        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
-        visitPostContent(bytesVisitor);
-        return buffer;
-    }
+      case POST_CONTENT:
+        return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
 
-    protected void visitStart(PartVisitor visitor) {
-        visitor.withBytes(EXTRA_BYTES);
-        visitor.withBytes(boundary);
+      default:
+        throw new IllegalStateException("Unknown state " + state);
     }
-
-    protected void visitDispositionHeader(PartVisitor visitor) {
-        visitor.withBytes(CRLF_BYTES);
-        visitor.withBytes(CONTENT_DISPOSITION_BYTES);
-        visitor.withBytes(part.getDispositionType() != null ? part.getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
-        if (part.getName() != null) {
-            visitor.withBytes(NAME_BYTES);
-            visitor.withByte(QUOTE_BYTE);
-            visitor.withBytes(part.getName().getBytes(US_ASCII));
-            visitor.withByte(QUOTE_BYTE);
-        }
+  }
+
+  private ByteBuf lazyLoadPreContentBuffer() {
+    if (preContentBuffer == null)
+      preContentBuffer = computePreContentBytes(preContentLength);
+    return preContentBuffer;
+  }
+
+  private ByteBuf lazyLoadPostContentBuffer() {
+    if (postContentBuffer == null)
+      postContentBuffer = computePostContentBytes(postContentLength);
+    return postContentBuffer;
+  }
+
+  @Override
+  public void close() {
+    if (preContentBuffer != null)
+      preContentBuffer.release();
+    if (postContentBuffer != null)
+      postContentBuffer.release();
+  }
+
+  protected abstract long getContentLength();
+
+  protected abstract long transferContentTo(ByteBuf target) throws IOException;
+
+  protected abstract long transferContentTo(WritableByteChannel target) throws IOException;
+
+  protected long transfer(ByteBuf source, ByteBuf target, MultipartState sourceFullyWrittenState) {
+
+    int sourceRemaining = source.readableBytes();
+    int targetRemaining = target.writableBytes();
+
+    if (sourceRemaining <= targetRemaining) {
+      target.writeBytes(source);
+      state = sourceFullyWrittenState;
+      return sourceRemaining;
+    } else {
+      target.writeBytes(source, targetRemaining);
+      return targetRemaining;
     }
-
-    protected void visitContentTypeHeader(PartVisitor visitor) {
-        String contentType = part.getContentType();
-        if (contentType != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_TYPE_BYTES);
-            visitor.withBytes(contentType.getBytes(US_ASCII));
-            Charset charSet = part.getCharset();
-            if (charSet != null) {
-                visitor.withBytes(CHARSET_BYTES);
-                visitor.withBytes(part.getCharset().name().getBytes(US_ASCII));
-            }
+  }
+
+  protected long transfer(ByteBuf source, WritableByteChannel target, MultipartState sourceFullyWrittenState) throws IOException {
+
+    int transferred = 0;
+    if (target instanceof GatheringByteChannel) {
+      transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
+    } else {
+      for (ByteBuffer byteBuffer : source.nioBuffers()) {
+        int len = byteBuffer.remaining();
+        int written = target.write(byteBuffer);
+        transferred += written;
+        if (written != len) {
+          // couldn't write full buffer, exit loop
+          break;
         }
+      }
+      // assume this is a basic single ByteBuf
+      source.readerIndex(source.readerIndex() + transferred);
     }
 
-    protected void visitTransferEncodingHeader(PartVisitor visitor) {
-        String transferEncoding = part.getTransferEncoding();
-        if (transferEncoding != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
-            visitor.withBytes(transferEncoding.getBytes(US_ASCII));
-        }
+    if (source.isReadable()) {
+      slowTarget = true;
+    } else {
+      state = sourceFullyWrittenState;
     }
-
-    protected void visitContentIdHeader(PartVisitor visitor) {
-        String contentId = part.getContentId();
-        if (contentId != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_ID_BYTES);
-            visitor.withBytes(contentId.getBytes(US_ASCII));
-        }
+    return transferred;
+  }
+
+  protected int computePreContentLength() {
+    CounterPartVisitor counterVisitor = new CounterPartVisitor();
+    visitPreContent(counterVisitor);
+    return counterVisitor.getCount();
+  }
+
+  protected ByteBuf computePreContentBytes(int preContentLength) {
+    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(preContentLength);
+    ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+    visitPreContent(bytesVisitor);
+    return buffer;
+  }
+
+  protected int computePostContentLength() {
+    CounterPartVisitor counterVisitor = new CounterPartVisitor();
+    visitPostContent(counterVisitor);
+    return counterVisitor.getCount();
+  }
+
+  protected ByteBuf computePostContentBytes(int postContentLength) {
+    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(postContentLength);
+    ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+    visitPostContent(bytesVisitor);
+    return buffer;
+  }
+
+  protected void visitStart(PartVisitor visitor) {
+    visitor.withBytes(EXTRA_BYTES);
+    visitor.withBytes(boundary);
+  }
+
+  protected void visitDispositionHeader(PartVisitor visitor) {
+    visitor.withBytes(CRLF_BYTES);
+    visitor.withBytes(CONTENT_DISPOSITION_BYTES);
+    visitor.withBytes(part.getDispositionType() != null ? part.getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
+    if (part.getName() != null) {
+      visitor.withBytes(NAME_BYTES);
+      visitor.withByte(QUOTE_BYTE);
+      visitor.withBytes(part.getName().getBytes(US_ASCII));
+      visitor.withByte(QUOTE_BYTE);
     }
-
-    protected void visitCustomHeaders(PartVisitor visitor) {
-        if (isNonEmpty(part.getCustomHeaders())) {
-            for (Param param : part.getCustomHeaders()) {
-                visitor.withBytes(CRLF_BYTES);
-                visitor.withBytes(param.getName().getBytes(US_ASCII));
-                visitor.withBytes(HEADER_NAME_VALUE_SEPARATOR_BYTES);
-                visitor.withBytes(param.getValue().getBytes(US_ASCII));
-            }
-        }
+  }
+
+  protected void visitContentTypeHeader(PartVisitor visitor) {
+    String contentType = part.getContentType();
+    if (contentType != null) {
+      visitor.withBytes(CRLF_BYTES);
+      visitor.withBytes(CONTENT_TYPE_BYTES);
+      visitor.withBytes(contentType.getBytes(US_ASCII));
+      Charset charSet = part.getCharset();
+      if (charSet != null) {
+        visitor.withBytes(CHARSET_BYTES);
+        visitor.withBytes(part.getCharset().name().getBytes(US_ASCII));
+      }
     }
-
-    protected void visitEndOfHeaders(PartVisitor visitor) {
-        visitor.withBytes(CRLF_BYTES);
-        visitor.withBytes(CRLF_BYTES);
+  }
+
+  protected void visitTransferEncodingHeader(PartVisitor visitor) {
+    String transferEncoding = part.getTransferEncoding();
+    if (transferEncoding != null) {
+      visitor.withBytes(CRLF_BYTES);
+      visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
+      visitor.withBytes(transferEncoding.getBytes(US_ASCII));
     }
-
-    protected void visitPreContent(PartVisitor visitor) {
-        visitStart(visitor);
-        visitDispositionHeader(visitor);
-        visitContentTypeHeader(visitor);
-        visitTransferEncodingHeader(visitor);
-        visitContentIdHeader(visitor);
-        visitCustomHeaders(visitor);
-        visitEndOfHeaders(visitor);
+  }
+
+  protected void visitContentIdHeader(PartVisitor visitor) {
+    String contentId = part.getContentId();
+    if (contentId != null) {
+      visitor.withBytes(CRLF_BYTES);
+      visitor.withBytes(CONTENT_ID_BYTES);
+      visitor.withBytes(contentId.getBytes(US_ASCII));
     }
+  }
 
-    protected void visitPostContent(PartVisitor visitor) {
+  protected void visitCustomHeaders(PartVisitor visitor) {
+    if (isNonEmpty(part.getCustomHeaders())) {
+      for (Param param : part.getCustomHeaders()) {
         visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(param.getName().getBytes(US_ASCII));
+        visitor.withBytes(HEADER_NAME_VALUE_SEPARATOR_BYTES);
+        visitor.withBytes(param.getValue().getBytes(US_ASCII));
+      }
     }
+  }
+
+  protected void visitEndOfHeaders(PartVisitor visitor) {
+    visitor.withBytes(CRLF_BYTES);
+    visitor.withBytes(CRLF_BYTES);
+  }
+
+  protected void visitPreContent(PartVisitor visitor) {
+    visitStart(visitor);
+    visitDispositionHeader(visitor);
+    visitContentTypeHeader(visitor);
+    visitTransferEncodingHeader(visitor);
+    visitContentIdHeader(visitor);
+    visitCustomHeaders(visitor);
+    visitEndOfHeaders(visitor);
+  }
+
+  protected void visitPostContent(PartVisitor visitor) {
+    visitor.withBytes(CRLF_BYTES);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
index 6a44deac1..1d9f4b9de 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
@@ -15,11 +15,11 @@
 
 public enum MultipartState {
 
-    PRE_CONTENT,
+  PRE_CONTENT,
 
-    CONTENT,
+  CONTENT,
 
-    POST_CONTENT,
+  POST_CONTENT,
 
-    DONE
+  DONE
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
index ec3f57d1e..8f3abd221 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
@@ -14,67 +14,46 @@
 
 import io.netty.buffer.ByteBuf;
 
-import java.nio.ByteBuffer;
-
 public interface PartVisitor {
 
-    void withBytes(byte[] bytes);
-
-    void withByte(byte b);
+  void withBytes(byte[] bytes);
 
-    class CounterPartVisitor implements PartVisitor {
+  void withByte(byte b);
 
-        private int count = 0;
+  class CounterPartVisitor implements PartVisitor {
 
-        @Override
-        public void withBytes(byte[] bytes) {
-            count += bytes.length;
-        }
+    private int count = 0;
 
-        @Override
-        public void withByte(byte b) {
-            count++;
-        }
-
-        public int getCount() {
-            return count;
-        }
+    @Override
+    public void withBytes(byte[] bytes) {
+      count += bytes.length;
     }
 
-    class ByteBufferVisitor implements PartVisitor {
-
-        private final ByteBuffer target;
+    @Override
+    public void withByte(byte b) {
+      count++;
+    }
 
-        public ByteBufferVisitor(ByteBuffer target) {
-            this.target = target;
-        }
+    public int getCount() {
+      return count;
+    }
+  }
 
-        @Override
-        public void withBytes(byte[] bytes) {
-            target.put(bytes);
-        }
+  class ByteBufVisitor implements PartVisitor {
+    private final ByteBuf target;
 
-        @Override
-        public void withByte(byte b) {
-            target.put(b);
-        }
+    public ByteBufVisitor(ByteBuf target) {
+      this.target = target;
     }
-    
-    class ByteBufVisitor implements PartVisitor {
-        private final ByteBuf target;
 
-        public ByteBufVisitor(ByteBuf target) {
-            this.target = target;
-        }
-
-        @Override
-        public void withBytes(byte[] bytes) {
-            target.writeBytes(bytes);
-        }
+    @Override
+    public void withBytes(byte[] bytes) {
+      target.writeBytes(bytes);
+    }
 
-        @Override
-        public void withByte(byte b) {
-            target.writeByte(b);
-        }
+    @Override
+    public void withByte(byte b) {
+      target.writeByte(b);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
index 73618a1eb..daf37a97c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
@@ -15,39 +15,38 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import org.asynchttpclient.request.body.multipart.StringPart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
-import org.asynchttpclient.request.body.multipart.StringPart;
-
 public class StringMultipartPart extends MultipartPart<StringPart> {
 
-    private final ByteBuf contentBuffer;
-
-    public StringMultipartPart(StringPart part, byte[] boundary) {
-        super(part, boundary);
-        contentBuffer = Unpooled.wrappedBuffer(part.getValue().getBytes(part.getCharset()));
-    }
-
-    @Override
-    protected long getContentLength() {
-        return contentBuffer.capacity();
-    }
-
-    @Override
-    protected long transferContentTo(ByteBuf target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-    }
-
-    @Override
-    protected long transferContentTo(WritableByteChannel target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-    }
-
-    @Override
-    public void close() {
-        super.close();
-        contentBuffer.release();
-    }
+  private final ByteBuf contentBuffer;
+
+  public StringMultipartPart(StringPart part, byte[] boundary) {
+    super(part, boundary);
+    contentBuffer = Unpooled.wrappedBuffer(part.getValue().getBytes(part.getCharset()));
+  }
+
+  @Override
+  protected long getContentLength() {
+    return contentBuffer.capacity();
+  }
+
+  @Override
+  protected long transferContentTo(ByteBuf target) {
+    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+  }
+
+  @Override
+  protected long transferContentTo(WritableByteChannel target) throws IOException {
+    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+  }
+
+  @Override
+  public void close() {
+    super.close();
+    contentBuffer.release();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
index ebeff4975..3edf13ff1 100644
--- a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -17,76 +17,69 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.SimpleFutureListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.netty.SimpleFutureListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 public enum RequestHostnameResolver {
 
-    INSTANCE;
+  INSTANCE;
 
-    public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandlerExtensions asyncHandlerExtensions) {
+  private static final Logger LOGGER = LoggerFactory.getLogger(RequestHostnameResolver.class);
 
-        final String hostname = unresolvedAddress.getHostName();
-        final int port = unresolvedAddress.getPort();
-        final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+  public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandler<?> asyncHandler) {
 
-        if (asyncHandlerExtensions != null) {
-            try {
-                asyncHandlerExtensions.onHostnameResolutionAttempt(hostname);
-            } catch (Exception e) {
-                LOGGER.error("onHostnameResolutionAttempt crashed", e);
-                promise.tryFailure(e);
-                return promise;
-            }
-        }
+    final String hostname = unresolvedAddress.getHostName();
+    final int port = unresolvedAddress.getPort();
+    final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
-        final Future<List<InetAddress>> whenResolved = nameResolver.resolveAll(hostname);
+    try {
+      asyncHandler.onHostnameResolutionAttempt(hostname);
+    } catch (Exception e) {
+      LOGGER.error("onHostnameResolutionAttempt crashed", e);
+      promise.tryFailure(e);
+      return promise;
+    }
 
-        whenResolved.addListener(new SimpleFutureListener<List<InetAddress>>() {
+    final Future<List<InetAddress>> whenResolved = nameResolver.resolveAll(hostname);
 
-            @Override
-            protected void onSuccess(List<InetAddress> value) throws Exception {
-                ArrayList<InetSocketAddress> socketAddresses = new ArrayList<>(value.size());
-                for (InetAddress a : value) {
-                    socketAddresses.add(new InetSocketAddress(a, port));
-                }
-                if (asyncHandlerExtensions != null) {
-                    try {
-                        asyncHandlerExtensions.onHostnameResolutionSuccess(hostname, socketAddresses);
-                    } catch (Exception e) {
-                        LOGGER.error("onHostnameResolutionSuccess crashed", e);
-                        promise.tryFailure(e);
-                        return;
-                    }
-                }
-                promise.trySuccess(socketAddresses);
-            }
+    whenResolved.addListener(new SimpleFutureListener<List<InetAddress>>() {
 
-            @Override
-            protected void onFailure(Throwable t) throws Exception {
-                if (asyncHandlerExtensions != null) {
-                    try {
-                        asyncHandlerExtensions.onHostnameResolutionFailure(hostname, t);
-                    } catch (Exception e) {
-                        LOGGER.error("onHostnameResolutionFailure crashed", e);
-                        promise.tryFailure(e);
-                        return;
-                    }
-                }
-                promise.tryFailure(t);
-            }
-        });
+      @Override
+      protected void onSuccess(List<InetAddress> value) {
+        ArrayList<InetSocketAddress> socketAddresses = new ArrayList<>(value.size());
+        for (InetAddress a : value) {
+          socketAddresses.add(new InetSocketAddress(a, port));
+        }
+        try {
+          asyncHandler.onHostnameResolutionSuccess(hostname, socketAddresses);
+        } catch (Exception e) {
+          LOGGER.error("onHostnameResolutionSuccess crashed", e);
+          promise.tryFailure(e);
+          return;
+        }
+        promise.trySuccess(socketAddresses);
+      }
 
-        return promise;
-    }
+      @Override
+      protected void onFailure(Throwable t) {
+        try {
+          asyncHandler.onHostnameResolutionFailure(hostname, t);
+        } catch (Exception e) {
+          LOGGER.error("onHostnameResolutionFailure crashed", e);
+          promise.tryFailure(e);
+          return;
+        }
+        promise.tryFailure(t);
+      }
+    });
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(RequestHostnameResolver.class);
+    return promise;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/NamePasswordCallbackHandler.java b/client/src/main/java/org/asynchttpclient/spnego/NamePasswordCallbackHandler.java
new file mode 100644
index 000000000..ba79f9883
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/spnego/NamePasswordCallbackHandler.java
@@ -0,0 +1,82 @@
+package org.asynchttpclient.spnego;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import javax.security.auth.callback.UnsupportedCallbackException;
+import java.io.IOException;
+import java.lang.reflect.Method;
+
+public class NamePasswordCallbackHandler implements CallbackHandler {
+  private final Logger log = LoggerFactory.getLogger(getClass());
+  private static final String PASSWORD_CALLBACK_NAME = "setObject";
+  private static final Class<?>[] PASSWORD_CALLBACK_TYPES =
+      new Class<?>[] {Object.class, char[].class, String.class};
+
+  private String username;
+  private String password;
+
+  private String passwordCallbackName;
+
+  public NamePasswordCallbackHandler(String username, String password) {
+    this(username, password, null);
+  }
+
+  public NamePasswordCallbackHandler(String username, String password, String passwordCallbackName) {
+    this.username = username;
+    this.password = password;
+    this.passwordCallbackName = passwordCallbackName;
+  }
+
+  public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
+    for (int i = 0; i < callbacks.length; i++) {
+      Callback callback = callbacks[i];
+      if (handleCallback(callback)) {
+        continue;
+      } else if (callback instanceof NameCallback) {
+        ((NameCallback) callback).setName(username);
+      } else if (callback instanceof PasswordCallback) {
+        PasswordCallback pwCallback = (PasswordCallback) callback;
+        pwCallback.setPassword(password.toCharArray());
+      } else if (!invokePasswordCallback(callback)) {
+        String errorMsg = "Unsupported callback type " + callbacks[i].getClass().getName();
+        log.info(errorMsg);
+        throw new UnsupportedCallbackException(callbacks[i], errorMsg);
+      }
+    }
+  }
+
+  protected boolean handleCallback(Callback callback) {
+    return false;
+  }
+
+  /*
+   * This method is called from the handle(Callback[]) method when the specified callback
+   * did not match any of the known callback classes. It looks for the callback method
+   * having the specified method name with one of the suppported parameter types.
+   * If found, it invokes the callback method on the object and returns true.
+   * If not, it returns false.
+   */
+  private boolean invokePasswordCallback(Callback callback) {
+    String cbname = passwordCallbackName == null
+        ? PASSWORD_CALLBACK_NAME : passwordCallbackName;
+    for (Class<?> arg : PASSWORD_CALLBACK_TYPES) {
+      try {
+        Method method = callback.getClass().getMethod(cbname, arg);
+        Object args[] = new Object[] {
+            arg == String.class ? password : password.toCharArray()
+        };
+        method.invoke(callback, args);
+        return true;
+      } catch (Exception e) {
+        // ignore and continue
+        log.debug(e.toString());
+      }
+    }
+    return false;
+  }
+}
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index 53d97051a..515bf6318 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -37,8 +37,8 @@
 
 package org.asynchttpclient.spnego;
 
-import org.asynchttpclient.util.Base64;
 import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
 import org.ietf.jgss.GSSException;
 import org.ietf.jgss.GSSManager;
 import org.ietf.jgss.GSSName;
@@ -46,129 +46,264 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.security.auth.Subject;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.login.AppConfigurationEntry;
+import javax.security.auth.login.Configuration;
+import javax.security.auth.login.LoginContext;
+import javax.security.auth.login.LoginException;
 import java.io.IOException;
+import java.net.InetAddress;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.Base64;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme.
- * 
+ *
  * @since 4.1
  */
 public class SpnegoEngine {
 
-    private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
-    private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+  private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
+  private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+  private static Map<String, SpnegoEngine> instances = new HashMap<>();
+  private final Logger log = LoggerFactory.getLogger(getClass());
+  private final SpnegoTokenGenerator spnegoGenerator;
+  private final String username;
+  private final String password;
+  private final String servicePrincipalName;
+  private final String realmName;
+  private final boolean useCanonicalHostname;
+  private final String loginContextName;
+  private final Map<String, String> customLoginConfig;
 
-    private final Logger log = LoggerFactory.getLogger(getClass());
+  public SpnegoEngine(final String username,
+                      final String password,
+                      final String servicePrincipalName,
+                      final String realmName,
+                      final boolean useCanonicalHostname,
+                      final Map<String, String> customLoginConfig,
+                      final String loginContextName,
+                      final SpnegoTokenGenerator spnegoGenerator) {
+    this.username = username;
+    this.password = password;
+    this.servicePrincipalName = servicePrincipalName;
+    this.realmName = realmName;
+    this.useCanonicalHostname = useCanonicalHostname;
+    this.customLoginConfig = customLoginConfig;
+    this.spnegoGenerator = spnegoGenerator;
+    this.loginContextName = loginContextName;
+  }
 
-    private final SpnegoTokenGenerator spnegoGenerator;
+  public SpnegoEngine() {
+    this(null,
+        null,
+        null,
+        null,
+        true,
+        null,
+        null,
+        null);
+  }
 
-    public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
-        this.spnegoGenerator = spnegoGenerator;
+  public static SpnegoEngine instance(final String username,
+                                      final String password,
+                                      final String servicePrincipalName,
+                                      final String realmName,
+                                      final boolean useCanonicalHostname,
+                                      final Map<String, String> customLoginConfig,
+                                      final String loginContextName) {
+    String key = "";
+    if (customLoginConfig != null && !customLoginConfig.isEmpty()) {
+      StringBuilder customLoginConfigKeyValues = new StringBuilder();
+      for (String loginConfigKey : customLoginConfig.keySet()) {
+        customLoginConfigKeyValues.append(loginConfigKey).append("=")
+          .append(customLoginConfig.get(loginConfigKey));
+      }
+      key = customLoginConfigKeyValues.toString();
+    }
+    if (username != null) {
+      key += username;
+    }
+    if (loginContextName != null) {
+      key += loginContextName;
     }
+    if (!instances.containsKey(key)) {
+      instances.put(key, new SpnegoEngine(username,
+          password,
+          servicePrincipalName,
+          realmName,
+          useCanonicalHostname,
+          customLoginConfig,
+          loginContextName,
+          null));
+    }
+    return instances.get(key);
+  }
+
+  public String generateToken(String host) throws SpnegoEngineException {
+    GSSContext gssContext = null;
+    byte[] token = null; // base64 decoded challenge
+    Oid negotiationOid;
+
+    try {
+      /*
+       * Using the SPNEGO OID is the correct method. Kerberos v5 works for IIS but not JBoss. Unwrapping the initial token when using SPNEGO OID looks like what is described
+       * here...
+       *
+       * http://msdn.microsoft.com/en-us/library/ms995330.aspx
+       *
+       * Another helpful URL...
+       *
+       * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
+       *
+       * Unfortunately SPNEGO is JRE >=1.6.
+       */
+
+      // Try SPNEGO by default, fall back to Kerberos later if error
+      negotiationOid = new Oid(SPNEGO_OID);
+
+      boolean tryKerberos = false;
+      String spn = getCompleteServicePrincipalName(host);
+      try {
+        GSSManager manager = GSSManager.getInstance();
+        GSSName serverName = manager.createName(spn, GSSName.NT_HOSTBASED_SERVICE);
+        GSSCredential myCred = null;
+        if (username != null || loginContextName != null || (customLoginConfig != null && !customLoginConfig.isEmpty())) {
+          String contextName = loginContextName;
+          if (contextName == null) {
+            contextName = "";
+          }
+          LoginContext loginContext = new LoginContext(contextName,
+              null,
+              getUsernamePasswordHandler(),
+              getLoginConfiguration());
+          loginContext.login();
+          final Oid negotiationOidFinal = negotiationOid;
+          final PrivilegedExceptionAction<GSSCredential> action = () -> manager.createCredential(null,
+            GSSCredential.INDEFINITE_LIFETIME, negotiationOidFinal, GSSCredential.INITIATE_AND_ACCEPT);
+          myCred = Subject.doAs(loginContext.getSubject(), action);
+        }
+        gssContext = manager.createContext(useCanonicalHostname ? serverName.canonicalize(negotiationOid) : serverName,
+            negotiationOid,
+            myCred,
+            GSSContext.DEFAULT_LIFETIME);
+        gssContext.requestMutualAuth(true);
+        gssContext.requestCredDeleg(true);
+      } catch (GSSException ex) {
+        log.error("generateToken", ex);
+        // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
+        // Rethrow any other exception.
+        if (ex.getMajor() == GSSException.BAD_MECH) {
+          log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
+          tryKerberos = true;
+        } else {
+          throw ex;
+        }
 
-    public SpnegoEngine() {
-        this(null);
+      }
+      if (tryKerberos) {
+        /* Kerberos v5 GSS-API mechanism defined in RFC 1964. */
+        log.debug("Using Kerberos MECH {}", KERBEROS_OID);
+        negotiationOid = new Oid(KERBEROS_OID);
+        GSSManager manager = GSSManager.getInstance();
+        GSSName serverName = manager.createName(spn, GSSName.NT_HOSTBASED_SERVICE);
+        gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
+                GSSContext.DEFAULT_LIFETIME);
+        gssContext.requestMutualAuth(true);
+        gssContext.requestCredDeleg(true);
+      }
+
+      // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
+      if (token == null) {
+        token = new byte[0];
+      }
+
+      token = gssContext.initSecContext(token, 0, token.length);
+      if (token == null) {
+        throw new SpnegoEngineException("GSS security context initialization failed");
+      }
+
+      /*
+       * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish? seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
+       */
+      if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
+        token = spnegoGenerator.generateSpnegoDERObject(token);
+      }
+
+      gssContext.dispose();
+
+      String tokenstr = Base64.getEncoder().encodeToString(token);
+      log.debug("Sending response '{}' back to the server", tokenstr);
+
+      return tokenstr;
+    } catch (GSSException gsse) {
+      log.error("generateToken", gsse);
+      if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
+        throw new SpnegoEngineException(gsse.getMessage(), gsse);
+      if (gsse.getMajor() == GSSException.NO_CRED)
+        throw new SpnegoEngineException(gsse.getMessage(), gsse);
+      if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
+              || gsse.getMajor() == GSSException.OLD_TOKEN)
+        throw new SpnegoEngineException(gsse.getMessage(), gsse);
+      // other error
+      throw new SpnegoEngineException(gsse.getMessage());
+    } catch (IOException | LoginException | PrivilegedActionException ex) {
+      throw new SpnegoEngineException(ex.getMessage());
+    }
+  }
+
+  String getCompleteServicePrincipalName(String host) {
+    String name;
+    if (servicePrincipalName == null) {
+      if (useCanonicalHostname) {
+        host = getCanonicalHostname(host);
+      }
+      name = "HTTP@" + host;
+    } else {
+      name = servicePrincipalName;
+      if (realmName != null && !name.contains("@")) {
+        name += "@" + realmName;
+      }
     }
+    log.debug("Service Principal Name is {}", name);
+    return name;
+  }
 
-    private static SpnegoEngine instance;
+  private String getCanonicalHostname(String hostname) {
+    String canonicalHostname = hostname;
+    try {
+      InetAddress in = InetAddress.getByName(hostname);
+      canonicalHostname = in.getCanonicalHostName();
+      log.debug("Resolved hostname={} to canonicalHostname={}", hostname, canonicalHostname);
+    } catch (Exception e) {
+      log.warn("Unable to resolve canonical hostname", e);
+    }
+    return canonicalHostname;
+  }
 
-    public static SpnegoEngine instance() {
-        if (instance == null)
-            instance = new SpnegoEngine();
-        return instance;
+  private CallbackHandler getUsernamePasswordHandler() {
+    if (username == null) {
+      return null;
     }
+    return new NamePasswordCallbackHandler(username, password);
+  }
 
-    public String generateToken(String server) throws SpnegoEngineException {
-        GSSContext gssContext = null;
-        byte[] token = null; // base64 decoded challenge
-        Oid negotiationOid;
-
-        try {
-            log.debug("init {}", server);
-            /*
-             * Using the SPNEGO OID is the correct method. Kerberos v5 works for IIS but not JBoss. Unwrapping the initial token when using SPNEGO OID looks like what is described
-             * here...
-             * 
-             * http://msdn.microsoft.com/en-us/library/ms995330.aspx
-             * 
-             * Another helpful URL...
-             * 
-             * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
-             * 
-             * Unfortunately SPNEGO is JRE >=1.6.
-             */
-
-            /** Try SPNEGO by default, fall back to Kerberos later if error */
-            negotiationOid = new Oid(SPNEGO_OID);
-
-            boolean tryKerberos = false;
-            try {
-                GSSManager manager = GSSManager.getInstance();
-                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
-                        GSSContext.DEFAULT_LIFETIME);
-                gssContext.requestMutualAuth(true);
-                gssContext.requestCredDeleg(true);
-            } catch (GSSException ex) {
-                log.error("generateToken", ex);
-                // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
-                // Rethrow any other exception.
-                if (ex.getMajor() == GSSException.BAD_MECH) {
-                    log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
-                    tryKerberos = true;
-                } else {
-                    throw ex;
-                }
-
-            }
-            if (tryKerberos) {
-                /* Kerberos v5 GSS-API mechanism defined in RFC 1964. */
-                log.debug("Using Kerberos MECH {}", KERBEROS_OID);
-                negotiationOid = new Oid(KERBEROS_OID);
-                GSSManager manager = GSSManager.getInstance();
-                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
-                        GSSContext.DEFAULT_LIFETIME);
-                gssContext.requestMutualAuth(true);
-                gssContext.requestCredDeleg(true);
-            }
-
-            // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
-            if (token == null) {
-                token = new byte[0];
-            }
-
-            token = gssContext.initSecContext(token, 0, token.length);
-            if (token == null) {
-                throw new SpnegoEngineException("GSS security context initialization failed");
-            }
-
-            /*
-             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish? seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
-             */
-            if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
-                token = spnegoGenerator.generateSpnegoDERObject(token);
-            }
-
-            gssContext.dispose();
-
-            String tokenstr = Base64.encode(token);
-            log.debug("Sending response '{}' back to the server", tokenstr);
-
-            return tokenstr;
-        } catch (GSSException gsse) {
-            log.error("generateToken", gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
-                throw new SpnegoEngineException(gsse.getMessage(), gsse);
-            if (gsse.getMajor() == GSSException.NO_CRED)
-                throw new SpnegoEngineException(gsse.getMessage(), gsse);
-            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
-                    || gsse.getMajor() == GSSException.OLD_TOKEN)
-                throw new SpnegoEngineException(gsse.getMessage(), gsse);
-            // other error
-            throw new SpnegoEngineException(gsse.getMessage());
-        } catch (IOException ex) {
-            throw new SpnegoEngineException(ex.getMessage());
+  public Configuration getLoginConfiguration() {
+    if (customLoginConfig != null && !customLoginConfig.isEmpty()) {
+      return new Configuration() {
+        @Override
+        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {
+          return new AppConfigurationEntry[] {
+              new AppConfigurationEntry("com.sun.security.auth.module.Krb5LoginModule",
+                  AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,
+                  customLoginConfig)};
         }
+      };
     }
+    return null;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
index c7118d358..5e5570429 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
@@ -18,13 +18,13 @@
  */
 public class SpnegoEngineException extends Exception {
 
-    private static final long serialVersionUID = -3123799505052881438L;
+  private static final long serialVersionUID = -3123799505052881438L;
 
-    public SpnegoEngineException(String message) {
-        super(message);
-    }
+  public SpnegoEngineException(String message) {
+    super(message);
+  }
 
-    public SpnegoEngineException(String message, Throwable cause) {
-        super(message, cause);
-    }
+  public SpnegoEngineException(String message, Throwable cause) {
+    super(message, cause);
+  }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
index 3034b02cc..5db40b184 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
@@ -50,5 +50,5 @@
  */
 public interface SpnegoTokenGenerator {
 
-    byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
+  byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/uri/Uri.java b/client/src/main/java/org/asynchttpclient/uri/Uri.java
index 6075ca4f7..19986dcfc 100644
--- a/client/src/main/java/org/asynchttpclient/uri/Uri.java
+++ b/client/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -12,235 +12,282 @@
  */
 package org.asynchttpclient.uri;
 
-import static org.asynchttpclient.util.Assertions.assertNotEmpty;
-import static org.asynchttpclient.util.MiscUtils.*;
+import org.asynchttpclient.util.MiscUtils;
+import org.asynchttpclient.util.StringBuilderPool;
 
 import java.net.URI;
 import java.net.URISyntaxException;
 
-import org.asynchttpclient.util.MiscUtils;
-import org.asynchttpclient.util.StringBuilderPool;
+import static org.asynchttpclient.util.Assertions.assertNotEmpty;
+import static org.asynchttpclient.util.MiscUtils.isEmpty;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 public class Uri {
 
-    public static final String HTTP = "http";
-    public static final String HTTPS = "https";
-    public static final String WS = "ws";
-    public static final String WSS = "wss";
-
-    public static Uri create(String originalUrl) {
-        return create(null, originalUrl);
-    }
-
-    public static Uri create(Uri context, final String originalUrl) {
-        UriParser parser = new UriParser();
-        parser.parse(context, originalUrl);
-
-        if (isEmpty(parser.scheme)) {
-            throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing scheme");
-        }
-        if (isEmpty(parser.host)) {
-            throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing host");
-        }
-
-        return new Uri(parser.scheme,//
-                parser.userInfo,//
-                parser.host,//
-                parser.port,//
-                parser.path,//
-                parser.query);
-    }
-
-    private final String scheme;
-    private final String userInfo;
-    private final String host;
-    private final int port;
-    private final String query;
-    private final String path;
-    private String url;
-    private boolean secured;
-    private boolean webSocket;
-
-    public Uri(String scheme,//
-            String userInfo,//
-            String host,//
-            int port,//
-            String path,//
-            String query) {
-
-        this.scheme = assertNotEmpty(scheme, "scheme");
-        this.userInfo = userInfo;
-        this.host = assertNotEmpty(host, "host");
-        this.port = port;
-        this.path = path;
-        this.query = query;
-        this.secured = HTTPS.equals(scheme) || WSS.equals(scheme);
-        this.webSocket = WS.equals(scheme) || WSS.equalsIgnoreCase(scheme);
-    }
-
-    public String getQuery() {
-        return query;
-    }
-
-    public String getPath() {
-        return path;
-    }
-
-    public String getUserInfo() {
-        return userInfo;
-    }
-
-    public int getPort() {
-        return port;
-    }
-
-    public String getScheme() {
-        return scheme;
-    }
-
-    public String getHost() {
-        return host;
-    }
-
-    public boolean isSecured() {
-        return secured;
-    }
-
-    public boolean isWebSocket() {
-        return webSocket;
-    }
-
-    public URI toJavaNetURI() throws URISyntaxException {
-        return new URI(toUrl());
-    }
-
-    public int getExplicitPort() {
-        return port == -1 ? getSchemeDefaultPort() : port;
-    }
-
-    public int getSchemeDefaultPort() {
-        return isSecured() ? 443 : 80;
+  public static final String HTTP = "http";
+  public static final String HTTPS = "https";
+  public static final String WS = "ws";
+  public static final String WSS = "wss";
+  private final String scheme;
+  private final String userInfo;
+  private final String host;
+  private final int port;
+  private final String query;
+  private final String path;
+  private final String fragment;
+  private String url;
+  private boolean secured;
+  private boolean webSocket;
+
+  public Uri(String scheme,
+             String userInfo,
+             String host,
+             int port,
+             String path,
+             String query,
+             String fragment) {
+
+    this.scheme = assertNotEmpty(scheme, "scheme");
+    this.userInfo = userInfo;
+    this.host = assertNotEmpty(host, "host");
+    this.port = port;
+    this.path = path;
+    this.query = query;
+    this.fragment = fragment;
+    this.secured = HTTPS.equals(scheme) || WSS.equals(scheme);
+    this.webSocket = WS.equals(scheme) || WSS.equalsIgnoreCase(scheme);
+  }
+
+  public static Uri create(String originalUrl) {
+    return create(null, originalUrl);
+  }
+
+  public static Uri create(Uri context, final String originalUrl) {
+    UriParser parser = new UriParser();
+    parser.parse(context, originalUrl);
+
+    if (isEmpty(parser.scheme)) {
+      throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing scheme");
     }
-
-    public String toUrl() {
-        if (url == null) {
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            sb.append(scheme).append("://");
-            if (userInfo != null)
-                sb.append(userInfo).append('@');
-            sb.append(host);
-            if (port != -1)
-                sb.append(':').append(port);
-            if (path != null)
-                sb.append(path);
-            if (query != null)
-                sb.append('?').append(query);
-            url = sb.toString();
-            sb.setLength(0);
-        }
-        return url;
-    }
-
-    /**
-     * @return [scheme]://[hostname](:[port]). Port is omitted if it matches the scheme's default one.
-     */
-    public String toBaseUrl() {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        sb.append(scheme).append("://").append(host);
-        if (port != -1 && port != getSchemeDefaultPort()) {
-            sb.append(':').append(port);
-        }
-        if (isNonEmpty(path)) {
-            sb.append(path);
-        }
-        return sb.toString();
+    if (isEmpty(parser.host)) {
+      throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing host");
     }
 
-    public String toRelativeUrl() {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        if (MiscUtils.isNonEmpty(path))
-            sb.append(path);
-        else
-            sb.append('/');
-        if (query != null)
-            sb.append('?').append(query);
-
-        return sb.toString();
+    return new Uri(parser.scheme,
+            parser.userInfo,
+            parser.host,
+            parser.port,
+            parser.path,
+            parser.query,
+            parser.fragment);
+  }
+
+  public String getQuery() {
+    return query;
+  }
+
+  public String getPath() {
+    return path;
+  }
+
+  public String getUserInfo() {
+    return userInfo;
+  }
+
+  public int getPort() {
+    return port;
+  }
+
+  public String getScheme() {
+    return scheme;
+  }
+
+  public String getHost() {
+    return host;
+  }
+
+  public String getFragment() {
+    return fragment;
+  }
+
+  public boolean isSecured() {
+    return secured;
+  }
+
+  public boolean isWebSocket() {
+    return webSocket;
+  }
+
+  public URI toJavaNetURI() throws URISyntaxException {
+    return new URI(toUrl());
+  }
+
+  public int getExplicitPort() {
+    return port == -1 ? getSchemeDefaultPort() : port;
+  }
+
+  public int getSchemeDefaultPort() {
+    return isSecured() ? 443 : 80;
+  }
+
+  public String toUrl() {
+    if (url == null) {
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      sb.append(scheme).append("://");
+      if (userInfo != null)
+        sb.append(userInfo).append('@');
+      sb.append(host);
+      if (port != -1)
+        sb.append(':').append(port);
+      if (path != null)
+        sb.append(path);
+      if (query != null)
+        sb.append('?').append(query);
+      url = sb.toString();
+      sb.setLength(0);
     }
-
-    @Override
-    public String toString() {
-        // for now, but might change
-        return toUrl();
+    return url;
+  }
+
+  /**
+   * @return [scheme]://[hostname](:[port])/path. Port is omitted if it matches the scheme's default one.
+   */
+  public String toBaseUrl() {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    sb.append(scheme).append("://").append(host);
+    if (port != -1 && port != getSchemeDefaultPort()) {
+      sb.append(':').append(port);
     }
-
-    public Uri withNewScheme(String newScheme) {
-        return new Uri(newScheme,//
-                userInfo,//
-                host,//
-                port,//
-                path,//
-                query);
+    if (isNonEmpty(path)) {
+      sb.append(path);
     }
-
-    public Uri withNewQuery(String newQuery) {
-        return new Uri(scheme,//
-                userInfo,//
-                host,//
-                port,//
-                path,//
-                newQuery);
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((host == null) ? 0 : host.hashCode());
-        result = prime * result + ((path == null) ? 0 : path.hashCode());
-        result = prime * result + port;
-        result = prime * result + ((query == null) ? 0 : query.hashCode());
-        result = prime * result + ((scheme == null) ? 0 : scheme.hashCode());
-        result = prime * result + ((userInfo == null) ? 0 : userInfo.hashCode());
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        Uri other = (Uri) obj;
-        if (host == null) {
-            if (other.host != null)
-                return false;
-        } else if (!host.equals(other.host))
-            return false;
-        if (path == null) {
-            if (other.path != null)
-                return false;
-        } else if (!path.equals(other.path))
-            return false;
-        if (port != other.port)
-            return false;
-        if (query == null) {
-            if (other.query != null)
-                return false;
-        } else if (!query.equals(other.query))
-            return false;
-        if (scheme == null) {
-            if (other.scheme != null)
-                return false;
-        } else if (!scheme.equals(other.scheme))
-            return false;
-        if (userInfo == null) {
-            if (other.userInfo != null)
-                return false;
-        } else if (!userInfo.equals(other.userInfo))
-            return false;
-        return true;
+    return sb.toString();
+  }
+
+  public String toRelativeUrl() {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    if (MiscUtils.isNonEmpty(path))
+      sb.append(path);
+    else
+      sb.append('/');
+    if (query != null)
+      sb.append('?').append(query);
+
+    return sb.toString();
+  }
+
+  public String toFullUrl() {
+    return fragment == null ? toUrl() : toUrl() + "#" + fragment;
+  }
+
+  public String getBaseUrl() {
+    return scheme + "://" + host + ":" + getExplicitPort();
+  }
+
+  public String getAuthority() {
+    return host + ":" + getExplicitPort();
+  }
+
+  public boolean isSameBase(Uri other) {
+    return scheme.equals(other.getScheme())
+      && host.equals(other.getHost())
+      && getExplicitPort() == other.getExplicitPort();
+  }
+
+  public String getNonEmptyPath() {
+    return isNonEmpty(path) ? path : "/";
+  }
+
+  @Override
+  public String toString() {
+    // for now, but might change
+    return toUrl();
+  }
+
+  public Uri withNewScheme(String newScheme) {
+    return new Uri(newScheme,
+            userInfo,
+            host,
+            port,
+            path,
+            query,
+            fragment);
+  }
+
+  public Uri withNewQuery(String newQuery) {
+    return new Uri(scheme,
+            userInfo,
+            host,
+            port,
+            path,
+            newQuery,
+            fragment);
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((host == null) ? 0 : host.hashCode());
+    result = prime * result + ((path == null) ? 0 : path.hashCode());
+    result = prime * result + port;
+    result = prime * result + ((query == null) ? 0 : query.hashCode());
+    result = prime * result + ((scheme == null) ? 0 : scheme.hashCode());
+    result = prime * result + ((userInfo == null) ? 0 : userInfo.hashCode());
+    result = prime * result + ((fragment == null) ? 0 : fragment.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (obj == null)
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    Uri other = (Uri) obj;
+    if (host == null) {
+      if (other.host != null)
+        return false;
+    } else if (!host.equals(other.host))
+      return false;
+    if (path == null) {
+      if (other.path != null)
+        return false;
+    } else if (!path.equals(other.path))
+      return false;
+    if (port != other.port)
+      return false;
+    if (query == null) {
+      if (other.query != null)
+        return false;
+    } else if (!query.equals(other.query))
+      return false;
+    if (scheme == null) {
+      if (other.scheme != null)
+        return false;
+    } else if (!scheme.equals(other.scheme))
+      return false;
+    if (userInfo == null) {
+      if (other.userInfo != null)
+        return false;
+    } else if (!userInfo.equals(other.userInfo))
+      return false;
+    if (fragment == null) {
+      if (other.fragment != null)
+        return false;
+    } else if (!fragment.equals(other.fragment))
+      return false;
+    return true;
+  }
+
+  public static void validateSupportedScheme(Uri uri) {
+    final String scheme = uri.getScheme();
+    if (scheme == null || !scheme.equalsIgnoreCase(HTTP) && !scheme.equalsIgnoreCase(HTTPS)
+      && !scheme.equalsIgnoreCase(WS) && !scheme.equalsIgnoreCase(WSS)) {
+      throw new IllegalArgumentException("The URI scheme, of the URI " + uri
+        + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/uri/UriParser.java b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
index 2ff07d6a7..37948e65b 100644
--- a/client/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -12,345 +12,350 @@
  */
 package org.asynchttpclient.uri;
 
-import static org.asynchttpclient.util.Assertions.*;
-import static org.asynchttpclient.util.MiscUtils.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 final class UriParser {
 
-    public String scheme;
-    public String host;
-    public int port = -1;
-    public String query;
-    public String authority;
-    public String path;
-    public String userInfo;
-
-    private String originalUrl;
-    private int start, end, currentIndex = 0;
-
-    private void trimLeft() {
-        while (start < end && originalUrl.charAt(start) <= ' ') {
-            start++;
-        }
-
-        if (originalUrl.regionMatches(true, start, "url:", 0, 4)) {
-            start += 4;
-        }
+  public String scheme;
+  public String host;
+  public int port = -1;
+  public String query;
+  public String fragment;
+  private String authority;
+  public String path;
+  public String userInfo;
+
+  private String originalUrl;
+  private int start, end, currentIndex = 0;
+
+  private void trimLeft() {
+    while (start < end && originalUrl.charAt(start) <= ' ') {
+      start++;
     }
 
-    private void trimRight() {
-        end = originalUrl.length();
-        while (end > 0 && originalUrl.charAt(end - 1) <= ' ') {
-            end--;
-        }
+    if (originalUrl.regionMatches(true, start, "url:", 0, 4)) {
+      start += 4;
     }
+  }
 
-    private boolean isFragmentOnly() {
-        return start < originalUrl.length() && originalUrl.charAt(start) == '#';
+  private void trimRight() {
+    end = originalUrl.length();
+    while (end > 0 && originalUrl.charAt(end - 1) <= ' ') {
+      end--;
     }
+  }
 
-    private boolean isValidProtocolChar(char c) {
-        return Character.isLetterOrDigit(c) && c != '.' && c != '+' && c != '-';
-    }
+  private boolean isFragmentOnly() {
+    return start < originalUrl.length() && originalUrl.charAt(start) == '#';
+  }
 
-    private boolean isValidProtocolChars(String protocol) {
-        for (int i = 1; i < protocol.length(); i++) {
-            if (!isValidProtocolChar(protocol.charAt(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
+  private boolean isValidProtocolChar(char c) {
+    return Character.isLetterOrDigit(c) && c != '.' && c != '+' && c != '-';
+  }
 
-    private boolean isValidProtocol(String protocol) {
-        return protocol.length() > 0 && Character.isLetter(protocol.charAt(0)) && isValidProtocolChars(protocol);
+  private boolean isValidProtocolChars(String protocol) {
+    for (int i = 1; i < protocol.length(); i++) {
+      if (!isValidProtocolChar(protocol.charAt(i))) {
+        return false;
+      }
     }
-
-    private void computeInitialScheme() {
-        for (int i = currentIndex; i < end; i++) {
-            char c = originalUrl.charAt(i);
-            if (c == ':') {
-                String s = originalUrl.substring(currentIndex, i);
-                if (isValidProtocol(s)) {
-                    scheme = s.toLowerCase();
-                    currentIndex = i + 1;
-                }
-                break;
-            } else if (c == '/') {
-                break;
-            }
+    return true;
+  }
+
+  private boolean isValidProtocol(String protocol) {
+    return protocol.length() > 0 && Character.isLetter(protocol.charAt(0)) && isValidProtocolChars(protocol);
+  }
+
+  private void computeInitialScheme() {
+    for (int i = currentIndex; i < end; i++) {
+      char c = originalUrl.charAt(i);
+      if (c == ':') {
+        String s = originalUrl.substring(currentIndex, i);
+        if (isValidProtocol(s)) {
+          scheme = s.toLowerCase();
+          currentIndex = i + 1;
         }
+        break;
+      } else if (c == '/') {
+        break;
+      }
     }
+  }
 
-    private boolean overrideWithContext(Uri context) {
+  private boolean overrideWithContext(Uri context) {
 
-        boolean isRelative = false;
+    boolean isRelative = false;
 
-        // use context only if schemes match
-        if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {
+    // use context only if schemes match
+    if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {
 
-            // see RFC2396 5.2.3
-            String contextPath = context.getPath();
-            if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/') {
-                scheme = null;
-            }
-
-            if (scheme == null) {
-                scheme = context.getScheme();
-                userInfo = context.getUserInfo();
-                host = context.getHost();
-                port = context.getPort();
-                path = contextPath;
-                isRelative = true;
-            }
-        }
-        return isRelative;
-    }
+      // see RFC2396 5.2.3
+      String contextPath = context.getPath();
+      if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/') {
+        scheme = null;
+      }
 
-    private int findWithinCurrentRange(char c) {
-        int pos = originalUrl.indexOf(c, currentIndex);
-        return pos > end ? -1 : pos;
+      if (scheme == null) {
+        scheme = context.getScheme();
+        userInfo = context.getUserInfo();
+        host = context.getHost();
+        port = context.getPort();
+        path = contextPath;
+        isRelative = true;
+      }
     }
-
-    private void trimFragment() {
-        int charpPosition = findWithinCurrentRange('#');
-        if (charpPosition >= 0) {
-            end = charpPosition;
-        }
+    return isRelative;
+  }
+
+  private int findWithinCurrentRange(char c) {
+    int pos = originalUrl.indexOf(c, currentIndex);
+    return pos > end ? -1 : pos;
+  }
+
+  private void trimFragment() {
+    int charpPosition = findWithinCurrentRange('#');
+    if (charpPosition >= 0) {
+      end = charpPosition;
+      if (charpPosition + 1 < originalUrl.length()) {
+        fragment = originalUrl.substring(charpPosition + 1);
+      }
     }
+  }
 
-    private void inheritContextQuery(Uri context, boolean isRelative) {
-        // see RFC2396 5.2.2: query and fragment inheritance
-        if (isRelative && currentIndex == end) {
-            query = context.getQuery();
-        }
+  private void inheritContextQuery(Uri context, boolean isRelative) {
+    // see RFC2396 5.2.2: query and fragment inheritance
+    if (isRelative && currentIndex == end) {
+      query = context.getQuery();
+      fragment = context.getFragment();
     }
-
-    private boolean computeQuery() {
-        if (currentIndex < end) {
-            int askPosition = findWithinCurrentRange('?');
-            if (askPosition != -1) {
-                query = originalUrl.substring(askPosition + 1, end);
-                if (end > askPosition) {
-                    end = askPosition;
-                }
-                return askPosition == currentIndex;
-            }
+  }
+
+  private boolean computeQuery() {
+    if (currentIndex < end) {
+      int askPosition = findWithinCurrentRange('?');
+      if (askPosition != -1) {
+        query = originalUrl.substring(askPosition + 1, end);
+        if (end > askPosition) {
+          end = askPosition;
         }
-        return false;
-    }
-
-    private boolean currentPositionStartsWith4Slashes() {
-        return originalUrl.regionMatches(currentIndex, "////", 0, 4);
+        return askPosition == currentIndex;
+      }
     }
-
-    private boolean currentPositionStartsWith2Slashes() {
-        return originalUrl.regionMatches(currentIndex, "//", 0, 2);
+    return false;
+  }
+
+  private boolean currentPositionStartsWith4Slashes() {
+    return originalUrl.regionMatches(currentIndex, "////", 0, 4);
+  }
+
+  private boolean currentPositionStartsWith2Slashes() {
+    return originalUrl.regionMatches(currentIndex, "//", 0, 2);
+  }
+
+  private void computeAuthority() {
+    int authorityEndPosition = findWithinCurrentRange('/');
+    if (authorityEndPosition == -1) {
+      authorityEndPosition = findWithinCurrentRange('?');
+      if (authorityEndPosition == -1) {
+        authorityEndPosition = end;
+      }
     }
-
-    private void computeAuthority() {
-        int authorityEndPosition = findWithinCurrentRange('/');
-        if (authorityEndPosition == -1) {
-            authorityEndPosition = findWithinCurrentRange('?');
-            if (authorityEndPosition == -1) {
-                authorityEndPosition = end;
-            }
-        }
-        host = authority = originalUrl.substring(currentIndex, authorityEndPosition);
-        currentIndex = authorityEndPosition;
+    host = authority = originalUrl.substring(currentIndex, authorityEndPosition);
+    currentIndex = authorityEndPosition;
+  }
+
+  private void computeUserInfo() {
+    int atPosition = authority.indexOf('@');
+    if (atPosition != -1) {
+      userInfo = authority.substring(0, atPosition);
+      host = authority.substring(atPosition + 1);
+    } else {
+      userInfo = null;
     }
-
-    private void computeUserInfo() {
-        int atPosition = authority.indexOf('@');
-        if (atPosition != -1) {
-            userInfo = authority.substring(0, atPosition);
-            host = authority.substring(atPosition + 1);
+  }
+
+  private boolean isMaybeIPV6() {
+    // If the host is surrounded by [ and ] then its an IPv6
+    // literal address as specified in RFC2732
+    return host.length() > 0 && host.charAt(0) == '[';
+  }
+
+  private void computeIPV6() {
+    int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
+    if (positionAfterClosingSquareBrace > 1) {
+
+      port = -1;
+
+      if (host.length() > positionAfterClosingSquareBrace) {
+        if (host.charAt(positionAfterClosingSquareBrace) == ':') {
+          // see RFC2396: port can be null
+          int portPosition = positionAfterClosingSquareBrace + 1;
+          if (host.length() > portPosition) {
+            port = Integer.parseInt(host.substring(portPosition));
+          }
         } else {
-            userInfo = null;
+          throw new IllegalArgumentException("Invalid authority field: " + authority);
         }
-    }
-
-    private boolean isMaybeIPV6() {
-        // If the host is surrounded by [ and ] then its an IPv6
-        // literal address as specified in RFC2732
-        return host.length() > 0 && host.charAt(0) == '[';
-    }
+      }
 
-    private void computeIPV6() {
-        int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
-        if (positionAfterClosingSquareBrace > 1) {
+      host = host.substring(0, positionAfterClosingSquareBrace);
 
-            port = -1;
-
-            if (host.length() > positionAfterClosingSquareBrace) {
-                if (host.charAt(positionAfterClosingSquareBrace) == ':') {
-                    // see RFC2396: port can be null
-                    int portPosition = positionAfterClosingSquareBrace + 1;
-                    if (host.length() > portPosition) {
-                        port = Integer.parseInt(host.substring(portPosition));
-                    }
-                } else {
-                    throw new IllegalArgumentException("Invalid authority field: " + authority);
-                }
-            }
-
-            host = host.substring(0, positionAfterClosingSquareBrace);
-
-        } else {
-            throw new IllegalArgumentException("Invalid authority field: " + authority);
-        }
-    }
-
-    private void computeRegularHostPort() {
-        int colonPosition = host.indexOf(':');
-        port = -1;
-        if (colonPosition >= 0) {
-            // see RFC2396: port can be null
-            int portPosition = colonPosition + 1;
-            if (host.length() > portPosition)
-                port = Integer.parseInt(host.substring(portPosition));
-            host = host.substring(0, colonPosition);
-        }
+    } else {
+      throw new IllegalArgumentException("Invalid authority field: " + authority);
     }
-
-    // /./
-    private void removeEmbeddedDot() {
-        path = path.replace("/./", "/");
+  }
+
+  private void computeRegularHostPort() {
+    int colonPosition = host.indexOf(':');
+    port = -1;
+    if (colonPosition >= 0) {
+      // see RFC2396: port can be null
+      int portPosition = colonPosition + 1;
+      if (host.length() > portPosition)
+        port = Integer.parseInt(host.substring(portPosition));
+      host = host.substring(0, colonPosition);
     }
-
-    // /../
-    private void removeEmbedded2Dots() {
-        int i = 0;
-        while ((i = path.indexOf("/../", i)) >= 0) {
-            if (i > 0) {
-                end = path.lastIndexOf('/', i - 1);
-                if (end >= 0 && path.indexOf("/../", end) != 0) {
-                    path = path.substring(0, end) + path.substring(i + 3);
-                    i = 0;
-                } else if (end == 0) {
-                    break;
-                }
-            } else {
-                i = i + 3;
-            }
+  }
+
+  // /./
+  private void removeEmbeddedDot() {
+    path = path.replace("/./", "/");
+  }
+
+  // /../
+  private void removeEmbedded2Dots() {
+    int i = 0;
+    while ((i = path.indexOf("/../", i)) >= 0) {
+      if (i > 0) {
+        end = path.lastIndexOf('/', i - 1);
+        if (end >= 0 && path.indexOf("/../", end) != 0) {
+          path = path.substring(0, end) + path.substring(i + 3);
+          i = 0;
+        } else if (end == 0) {
+          break;
         }
+      } else {
+        i = i + 3;
+      }
     }
-
-    private void removeTailing2Dots() {
-        while (path.endsWith("/..")) {
-            end = path.lastIndexOf('/', path.length() - 4);
-            if (end >= 0) {
-                path = path.substring(0, end + 1);
-            } else {
-                break;
-            }
-        }
+  }
+
+  private void removeTailing2Dots() {
+    while (path.endsWith("/..")) {
+      end = path.lastIndexOf('/', path.length() - 4);
+      if (end >= 0) {
+        path = path.substring(0, end + 1);
+      } else {
+        break;
+      }
     }
+  }
 
-    private void removeStartingDot() {
-        if (path.startsWith("./") && path.length() > 2) {
-            path = path.substring(2);
-        }
+  private void removeStartingDot() {
+    if (path.startsWith("./") && path.length() > 2) {
+      path = path.substring(2);
     }
+  }
 
-    private void removeTrailingDot() {
-        if (path.endsWith("/.")) {
-            path = path.substring(0, path.length() - 1);
-        }
+  private void removeTrailingDot() {
+    if (path.endsWith("/.")) {
+      path = path.substring(0, path.length() - 1);
     }
+  }
 
-    private void handleRelativePath() {
-        int lastSlashPosition = path.lastIndexOf('/');
-        String pathEnd = originalUrl.substring(currentIndex, end);
+  private void handleRelativePath() {
+    int lastSlashPosition = path.lastIndexOf('/');
+    String pathEnd = originalUrl.substring(currentIndex, end);
 
-        if (lastSlashPosition == -1) {
-            path = authority != null ? "/" + pathEnd : pathEnd;
-        } else {
-            path = path.substring(0, lastSlashPosition + 1) + pathEnd;
-        }
+    if (lastSlashPosition == -1) {
+      path = authority != null ? "/" + pathEnd : pathEnd;
+    } else {
+      path = path.substring(0, lastSlashPosition + 1) + pathEnd;
     }
-
-    private void handlePathDots() {
-        if (path.indexOf('.') != -1) {
-            removeEmbeddedDot();
-            removeEmbedded2Dots();
-            removeTailing2Dots();
-            removeStartingDot();
-            removeTrailingDot();
-        }
+  }
+
+  private void handlePathDots() {
+    if (path.indexOf('.') != -1) {
+      removeEmbeddedDot();
+      removeEmbedded2Dots();
+      removeTailing2Dots();
+      removeStartingDot();
+      removeTrailingDot();
     }
+  }
 
-    private void parseAuthority() {
-        if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
-            currentIndex += 2;
-
-            computeAuthority();
-            computeUserInfo();
-
-            if (host != null) {
-                if (isMaybeIPV6()) {
-                    computeIPV6();
-                } else {
-                    computeRegularHostPort();
-                }
-            }
-
-            if (port < -1) {
-                throw new IllegalArgumentException("Invalid port number :" + port);
-            }
-
-            // see RFC2396 5.2.4: ignore context path if authority is defined
-            if (isNonEmpty(authority)) {
-                path = "";
-            }
-        }
-    }
+  private void parseAuthority() {
+    if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
+      currentIndex += 2;
+
+      computeAuthority();
+      computeUserInfo();
 
-    private void computeRegularPath() {
-        if (originalUrl.charAt(currentIndex) == '/') {
-            path = originalUrl.substring(currentIndex, end);
-        } else if (isNonEmpty(path)) {
-            handleRelativePath();
+      if (host != null) {
+        if (isMaybeIPV6()) {
+          computeIPV6();
         } else {
-            String pathEnd = originalUrl.substring(currentIndex, end);
-            path = isNonEmpty(pathEnd) && pathEnd.charAt(0) != '/' ? "/" + pathEnd : pathEnd;
+          computeRegularHostPort();
         }
-        handlePathDots();
-    }
+      }
 
-    private void computeQueryOnlyPath() {
-        int lastSlashPosition = path.lastIndexOf('/');
-        path = lastSlashPosition < 0 ? "/" : path.substring(0, lastSlashPosition) + "/";
-    }
+      if (port < -1) {
+        throw new IllegalArgumentException("Invalid port number :" + port);
+      }
 
-    private void computePath(boolean queryOnly) {
-        // Parse the file path if any
-        if (currentIndex < end) {
-            computeRegularPath();
-        } else if (queryOnly && path != null) {
-            computeQueryOnlyPath();
-        } else if (path == null) {
-            path = "";
-        }
+      // see RFC2396 5.2.4: ignore context path if authority is defined
+      if (isNonEmpty(authority)) {
+        path = "";
+      }
     }
+  }
+
+  private void computeRegularPath() {
+    if (originalUrl.charAt(currentIndex) == '/') {
+      path = originalUrl.substring(currentIndex, end);
+    } else if (isNonEmpty(path)) {
+      handleRelativePath();
+    } else {
+      String pathEnd = originalUrl.substring(currentIndex, end);
+      path = isNonEmpty(pathEnd) && pathEnd.charAt(0) != '/' ? "/" + pathEnd : pathEnd;
+    }
+    handlePathDots();
+  }
+
+  private void computeQueryOnlyPath() {
+    int lastSlashPosition = path.lastIndexOf('/');
+    path = lastSlashPosition < 0 ? "/" : path.substring(0, lastSlashPosition) + "/";
+  }
+
+  private void computePath(boolean queryOnly) {
+    // Parse the file path if any
+    if (currentIndex < end) {
+      computeRegularPath();
+    } else if (queryOnly && path != null) {
+      computeQueryOnlyPath();
+    } else if (path == null) {
+      path = "";
+    }
+  }
 
-    public void parse(Uri context, final String originalUrl) {
+  public void parse(Uri context, final String originalUrl) {
 
-        assertNotNull(originalUrl, "orginalUri");
-        this.originalUrl = originalUrl;
-        this.end = originalUrl.length();
+    assertNotNull(originalUrl, "originalUrl");
+    this.originalUrl = originalUrl;
+    this.end = originalUrl.length();
 
-        trimLeft();
-        trimRight();
-        currentIndex = start;
-        if (!isFragmentOnly()) {
-            computeInitialScheme();
-        }
-        boolean isRelative = overrideWithContext(context);
-        trimFragment();
-        inheritContextQuery(context, isRelative);
-        boolean queryOnly = computeQuery();
-        parseAuthority();
-        computePath(queryOnly);
+    trimLeft();
+    trimRight();
+    currentIndex = start;
+    if (!isFragmentOnly()) {
+      computeInitialScheme();
     }
+    boolean isRelative = overrideWithContext(context);
+    trimFragment();
+    inheritContextQuery(context, isRelative);
+    boolean queryOnly = computeQuery();
+    parseAuthority();
+    computePath(queryOnly);
+  }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/util/Assertions.java b/client/src/main/java/org/asynchttpclient/util/Assertions.java
index 3a4126fbb..6d7d8ad23 100644
--- a/client/src/main/java/org/asynchttpclient/util/Assertions.java
+++ b/client/src/main/java/org/asynchttpclient/util/Assertions.java
@@ -15,20 +15,20 @@
 
 public final class Assertions {
 
-    private Assertions() {
-    }
+  private Assertions() {
+  }
 
-    public static <T> T assertNotNull(T value, String name) {
-        if (value == null)
-            throw new NullPointerException(name);
-        return value;
+  public static <T> T assertNotNull(T value, String name) {
+    if (value == null)
+      throw new NullPointerException(name);
+    return value;
 
-    }
+  }
 
-    public static String assertNotEmpty(String value, String name) {
-        assertNotNull(value, name);
-        if (value.length() == 0)
-            throw new IllegalArgumentException("empty " + name);
-        return value;
-    }
+  public static String assertNotEmpty(String value, String name) {
+    assertNotNull(value, name);
+    if (value.length() == 0)
+      throw new IllegalArgumentException("empty " + name);
+    return value;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index eea95f7dc..00d69af7d 100644
--- a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -12,15 +12,6 @@
  */
 package org.asynchttpclient.util;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.HttpUtils.getNonEmptyPath;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import java.nio.charset.Charset;
-import java.util.List;
-
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.ntlm.NtlmEngine;
@@ -29,196 +20,212 @@
 import org.asynchttpclient.spnego.SpnegoEngineException;
 import org.asynchttpclient.uri.Uri;
 
-public final class AuthenticatorUtils {
+import java.nio.charset.Charset;
+import java.util.Base64;
+import java.util.List;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-    public static final String NEGOTIATE = "Negotiate";
+public final class AuthenticatorUtils {
 
-    public static String getHeaderWithPrefix(List<String> authenticateHeaders, String prefix) {
-        if (authenticateHeaders != null) {
-            for (String authenticateHeader : authenticateHeaders) {
-                if (authenticateHeader.regionMatches(true, 0, prefix, 0, prefix.length()))
-                    return authenticateHeader;
-            }
-        }
+  public static final String NEGOTIATE = "Negotiate";
 
-        return null;
+  public static String getHeaderWithPrefix(List<String> authenticateHeaders, String prefix) {
+    if (authenticateHeaders != null) {
+      for (String authenticateHeader : authenticateHeaders) {
+        if (authenticateHeader.regionMatches(true, 0, prefix, 0, prefix.length()))
+          return authenticateHeader;
+      }
     }
 
-    public static String computeBasicAuthentication(Realm realm) {
-        return realm != null ? computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset()) : null;
-    }
+    return null;
+  }
 
-    private static String computeBasicAuthentication(String principal, String password, Charset charset) {
-        String s = principal + ":" + password;
-        return "Basic " + Base64.encode(s.getBytes(charset));
-    }
+  private static String computeBasicAuthentication(Realm realm) {
+    return realm != null ? computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset()) : null;
+  }
 
-    public static String computeRealmURI(Uri uri, boolean useAbsoluteURI, boolean omitQuery) {
-        if (useAbsoluteURI) {
-            return omitQuery && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
-        } else {
-            String path = getNonEmptyPath(uri);
-            return omitQuery || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
-        }
-    }
+  private static String computeBasicAuthentication(String principal, String password, Charset charset) {
+    String s = principal + ":" + password;
+    return "Basic " + Base64.getEncoder().encodeToString(s.getBytes(charset));
+  }
 
-    private static String computeDigestAuthentication(Realm realm) {
-        
-        String realmUri = computeRealmURI(realm.getUri(), realm.isUseAbsoluteURI(), realm.isOmitQuery());
-
-        StringBuilder builder = new StringBuilder().append("Digest ");
-        append(builder, "username", realm.getPrincipal(), true);
-        append(builder, "realm", realm.getRealmName(), true);
-        append(builder, "nonce", realm.getNonce(), true);
-        append(builder, "uri", realmUri, true);
-        if (isNonEmpty(realm.getAlgorithm()))
-            append(builder, "algorithm", realm.getAlgorithm(), false);
-
-        append(builder, "response", realm.getResponse(), true);
-
-        if (realm.getOpaque() != null)
-            append(builder, "opaque", realm.getOpaque(), true);
-
-        if (realm.getQop() != null) {
-            append(builder, "qop", realm.getQop(), false);
-            // nc and cnonce only sent if server sent qop
-            append(builder, "nc", realm.getNc(), false);
-            append(builder, "cnonce", realm.getCnonce(), true);
-        }
-        builder.setLength(builder.length() - 2); // remove tailing ", "
-
-        // FIXME isn't there a more efficient way?
-        return new String(StringUtils.charSequence2Bytes(builder, ISO_8859_1));
+  public static String computeRealmURI(Uri uri, boolean useAbsoluteURI, boolean omitQuery) {
+    if (useAbsoluteURI) {
+      return omitQuery && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
+    } else {
+      String path = uri.getNonEmptyPath();
+      return omitQuery || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
     }
+  }
 
-    private static StringBuilder append(StringBuilder builder, String name, String value, boolean quoted) {
-        builder.append(name).append('=');
-        if (quoted)
-            builder.append('"').append(value).append('"');
-        else
-            builder.append(value);
+  private static String computeDigestAuthentication(Realm realm) {
 
-        return builder.append(", ");
-    }
+    String realmUri = computeRealmURI(realm.getUri(), realm.isUseAbsoluteURI(), realm.isOmitQuery());
+
+    StringBuilder builder = new StringBuilder().append("Digest ");
+    append(builder, "username", realm.getPrincipal(), true);
+    append(builder, "realm", realm.getRealmName(), true);
+    append(builder, "nonce", realm.getNonce(), true);
+    append(builder, "uri", realmUri, true);
+    if (isNonEmpty(realm.getAlgorithm()))
+      append(builder, "algorithm", realm.getAlgorithm(), false);
+
+    append(builder, "response", realm.getResponse(), true);
 
-    public static String perConnectionProxyAuthorizationHeader(Request request, Realm proxyRealm) {
-        String proxyAuthorization = null;
-        if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
-            switch (proxyRealm.getScheme()) {
-            case NTLM:
-            case KERBEROS:
-            case SPNEGO:
-                List<String> auth = request.getHeaders().getAll(PROXY_AUTHORIZATION);
-                if (getHeaderWithPrefix(auth, "NTLM") == null) {
-                    String msg = NtlmEngine.INSTANCE.generateType1Msg();
-                    proxyAuthorization = "NTLM " + msg;
-                }
-
-                break;
-            default:
-            }
-        }
-
-        return proxyAuthorization;
+    if (realm.getOpaque() != null)
+      append(builder, "opaque", realm.getOpaque(), true);
+
+    if (realm.getQop() != null) {
+      append(builder, "qop", realm.getQop(), false);
+      // nc and cnonce only sent if server sent qop
+      append(builder, "nc", realm.getNc(), false);
+      append(builder, "cnonce", realm.getCnonce(), true);
+    }
+    builder.setLength(builder.length() - 2); // remove tailing ", "
+
+    // FIXME isn't there a more efficient way?
+    return new String(StringUtils.charSequence2Bytes(builder, ISO_8859_1));
+  }
+
+  private static void append(StringBuilder builder, String name, String value, boolean quoted) {
+    builder.append(name).append('=');
+    if (quoted)
+      builder.append('"').append(value).append('"');
+    else
+      builder.append(value);
+
+    builder.append(", ");
+  }
+
+  public static String perConnectionProxyAuthorizationHeader(Request request, Realm proxyRealm) {
+    String proxyAuthorization = null;
+    if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
+      switch (proxyRealm.getScheme()) {
+        case NTLM:
+        case KERBEROS:
+        case SPNEGO:
+          List<String> auth = request.getHeaders().getAll(PROXY_AUTHORIZATION);
+          if (getHeaderWithPrefix(auth, "NTLM") == null) {
+            String msg = NtlmEngine.INSTANCE.generateType1Msg();
+            proxyAuthorization = "NTLM " + msg;
+          }
+
+          break;
+        default:
+      }
     }
 
-    public static String perRequestProxyAuthorizationHeader(Request request, Realm proxyRealm) {
-
-        String proxyAuthorization = null;
-        if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
-
-            switch (proxyRealm.getScheme()) {
-            case BASIC:
-                proxyAuthorization = computeBasicAuthentication(proxyRealm);
-                break;
-            case DIGEST:
-                if (isNonEmpty(proxyRealm.getNonce())) {
-                    // update realm with request information
-                    proxyRealm = realm(proxyRealm)//
-                            .setUri(request.getUri())//
-                            .setMethodName(request.getMethod())//
-                            .build();
-                    proxyAuthorization = computeDigestAuthentication(proxyRealm);
-                }
-                break;
-            case NTLM:
-            case KERBEROS:
-            case SPNEGO:
-                // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
-                // see perConnectionProxyAuthorizationHeader
-                break;
-            default:
-                throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
-            }
-        }
-
-        return proxyAuthorization;
+    return proxyAuthorization;
+  }
+
+  public static String perRequestProxyAuthorizationHeader(Request request, Realm proxyRealm) {
+
+    String proxyAuthorization = null;
+    if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
+
+      switch (proxyRealm.getScheme()) {
+        case BASIC:
+          proxyAuthorization = computeBasicAuthentication(proxyRealm);
+          break;
+        case DIGEST:
+          if (isNonEmpty(proxyRealm.getNonce())) {
+            // update realm with request information
+            proxyRealm = realm(proxyRealm)
+                    .setUri(request.getUri())
+                    .setMethodName(request.getMethod())
+                    .build();
+            proxyAuthorization = computeDigestAuthentication(proxyRealm);
+          }
+          break;
+        case NTLM:
+        case KERBEROS:
+        case SPNEGO:
+          // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
+          // see perConnectionProxyAuthorizationHeader
+          break;
+        default:
+          throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
+      }
     }
 
-    public static String perConnectionAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm) {
-        String authorizationHeader = null;
-
-        if (realm != null && realm.isUsePreemptiveAuth()) {
-            switch (realm.getScheme()) {
-            case NTLM:
-                String msg = NtlmEngine.INSTANCE.generateType1Msg();
-                authorizationHeader = "NTLM " + msg;
-                break;
-            case KERBEROS:
-            case SPNEGO:
-                String host;
-                if (proxyServer != null)
-                    host = proxyServer.getHost();
-                else if (request.getVirtualHost() != null)
-                    host = request.getVirtualHost();
-                else
-                    host = request.getUri().getHost();
-
-                try {
-                    authorizationHeader = NEGOTIATE + " " + SpnegoEngine.instance().generateToken(host);
-                } catch (SpnegoEngineException e) {
-                    throw new RuntimeException(e);
-                }
-                break;
-            default:
-                break;
-            }
-        }
-
-        return authorizationHeader;
+    return proxyAuthorization;
+  }
+
+  public static String perConnectionAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm) {
+    String authorizationHeader = null;
+
+    if (realm != null && realm.isUsePreemptiveAuth()) {
+      switch (realm.getScheme()) {
+        case NTLM:
+          String msg = NtlmEngine.INSTANCE.generateType1Msg();
+          authorizationHeader = "NTLM " + msg;
+          break;
+        case KERBEROS:
+        case SPNEGO:
+          String host;
+          if (proxyServer != null)
+            host = proxyServer.getHost();
+          else if (request.getVirtualHost() != null)
+            host = request.getVirtualHost();
+          else
+            host = request.getUri().getHost();
+
+          try {
+            authorizationHeader = NEGOTIATE + " " + SpnegoEngine.instance(
+                realm.getPrincipal(),
+                realm.getPassword(),
+                realm.getServicePrincipalName(),
+                realm.getRealmName(),
+                realm.isUseCanonicalHostname(),
+                realm.getCustomLoginConfig(),
+                realm.getLoginContextName()).generateToken(host);
+          } catch (SpnegoEngineException e) {
+            throw new RuntimeException(e);
+          }
+          break;
+        default:
+          break;
+      }
     }
 
-    public static String perRequestAuthorizationHeader(Request request, Realm realm) {
-
-        String authorizationHeader = null;
-
-        if (realm != null && realm.isUsePreemptiveAuth()) {
-
-            switch (realm.getScheme()) {
-            case BASIC:
-                authorizationHeader = computeBasicAuthentication(realm);
-                break;
-            case DIGEST:
-                if (isNonEmpty(realm.getNonce())) {
-                    // update realm with request information
-                    realm = realm(realm)//
-                            .setUri(request.getUri())//
-                            .setMethodName(request.getMethod())//
-                            .build();
-                    authorizationHeader = computeDigestAuthentication(realm);
-                }
-                break;
-            case NTLM:
-            case KERBEROS:
-            case SPNEGO:
-                // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
-                // see perConnectionAuthorizationHeader
-                break;
-            default:
-                throw new IllegalStateException("Invalid Authentication " + realm);
-            }
-        }
-
-        return authorizationHeader;
+    return authorizationHeader;
+  }
+
+  public static String perRequestAuthorizationHeader(Request request, Realm realm) {
+
+    String authorizationHeader = null;
+
+    if (realm != null && realm.isUsePreemptiveAuth()) {
+
+      switch (realm.getScheme()) {
+        case BASIC:
+          authorizationHeader = computeBasicAuthentication(realm);
+          break;
+        case DIGEST:
+          if (isNonEmpty(realm.getNonce())) {
+            // update realm with request information
+            realm = realm(realm)
+                    .setUri(request.getUri())
+                    .setMethodName(request.getMethod())
+                    .build();
+            authorizationHeader = computeDigestAuthentication(realm);
+          }
+          break;
+        case NTLM:
+        case KERBEROS:
+        case SPNEGO:
+          // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
+          // see perConnectionAuthorizationHeader
+          break;
+        default:
+          throw new IllegalStateException("Invalid Authentication " + realm);
+      }
     }
+
+    return authorizationHeader;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Base64.java b/client/src/main/java/org/asynchttpclient/util/Base64.java
deleted file mode 100644
index 757203387..000000000
--- a/client/src/main/java/org/asynchttpclient/util/Base64.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-/**
- * Implements the "base64" binary encoding scheme as defined by <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>. <br>
- * Portions of code here are taken from Apache Pivot
- */
-public final class Base64 {
-    private static final StringBuilderPool SB_POOL = new StringBuilderPool();
-    private static final char[] LOOKUP = new char[64];
-    private static final byte[] REVERSE_LOOKUP = new byte[256];
-
-    static {
-        // Populate the lookup array
-
-        for (int i = 0; i < 26; i++) {
-            LOOKUP[i] = (char) ('A' + i);
-        }
-
-        for (int i = 26, j = 0; i < 52; i++, j++) {
-            LOOKUP[i] = (char) ('a' + j);
-        }
-
-        for (int i = 52, j = 0; i < 62; i++, j++) {
-            LOOKUP[i] = (char) ('0' + j);
-        }
-
-        LOOKUP[62] = '+';
-        LOOKUP[63] = '/';
-
-        // Populate the reverse lookup array
-
-        for (int i = 0; i < 256; i++) {
-            REVERSE_LOOKUP[i] = -1;
-        }
-
-        for (int i = 'Z'; i >= 'A'; i--) {
-            REVERSE_LOOKUP[i] = (byte) (i - 'A');
-        }
-
-        for (int i = 'z'; i >= 'a'; i--) {
-            REVERSE_LOOKUP[i] = (byte) (i - 'a' + 26);
-        }
-
-        for (int i = '9'; i >= '0'; i--) {
-            REVERSE_LOOKUP[i] = (byte) (i - '0' + 52);
-        }
-
-        REVERSE_LOOKUP['+'] = 62;
-        REVERSE_LOOKUP['/'] = 63;
-        REVERSE_LOOKUP['='] = 0;
-    }
-
-    private Base64() {
-    }
-
-    /**
-     * Encodes the specified data into a base64 string.
-     *
-     * @param bytes The unencoded raw data.
-     * @return the encoded data
-     */
-    public static String encode(byte[] bytes) {
-        StringBuilder buf = SB_POOL.stringBuilder();
-
-        // first, handle complete chunks (fast loop)
-        int i = 0;
-        for (int end = bytes.length - 2; i < end;) {
-            int chunk = ((bytes[i++] & 0xFF) << 16) | ((bytes[i++] & 0xFF) << 8) | (bytes[i++] & 0xFF);
-            buf.append(LOOKUP[chunk >> 18]);
-            buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-            buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
-            buf.append(LOOKUP[chunk & 0x3F]);
-        }
-
-        // then leftovers, if any
-        int len = bytes.length;
-        if (i < len) { // 1 or 2 extra bytes?
-            int chunk = ((bytes[i++] & 0xFF) << 16);
-            buf.append(LOOKUP[chunk >> 18]);
-            if (i < len) { // 2 bytes
-                chunk |= ((bytes[i] & 0xFF) << 8);
-                buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-                buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
-            } else { // 1 byte
-                buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-                buf.append('=');
-            }
-            buf.append('=');
-        }
-        return buf.toString();
-    }
-
-    /**
-     * Decodes the specified base64 string back into its raw data.
-     *
-     * @param encoded The base64 encoded string.
-     * @return the decoded data
-     */
-    public static byte[] decode(String encoded) {
-        int padding = 0;
-
-        for (int i = encoded.length() - 1; encoded.charAt(i) == '='; i--) {
-            padding++;
-        }
-
-        int length = encoded.length() * 6 / 8 - padding;
-        byte[] bytes = new byte[length];
-
-        for (int i = 0, index = 0, n = encoded.length(); i < n; i += 4) {
-            int word = REVERSE_LOOKUP[encoded.charAt(i)] << 18;
-            word += REVERSE_LOOKUP[encoded.charAt(i + 1)] << 12;
-            word += REVERSE_LOOKUP[encoded.charAt(i + 2)] << 6;
-            word += REVERSE_LOOKUP[encoded.charAt(i + 3)];
-
-            for (int j = 0; j < 3 && index + j < length; j++) {
-                bytes[index + j] = (byte) (word >> (8 * (2 - j)));
-            }
-
-            index += 3;
-        }
-
-        return bytes;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/DateUtils.java b/client/src/main/java/org/asynchttpclient/util/DateUtils.java
index ec78648dd..b8bf42cd1 100644
--- a/client/src/main/java/org/asynchttpclient/util/DateUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/DateUtils.java
@@ -15,10 +15,10 @@
 
 public final class DateUtils {
 
-    private DateUtils() {
-    }
-    
-    public static long unpreciseMillisTime() {
-        return System.currentTimeMillis();
-    }
+  private DateUtils() {
+  }
+
+  public static long unpreciseMillisTime() {
+    return System.currentTimeMillis();
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
index 9e0f37b3d..e17681e6d 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -18,38 +18,37 @@
 
 public final class HttpConstants {
 
-    public static final class Methods {
-        public static final String CONNECT = HttpMethod.CONNECT.name();
-        public static final String DELETE = HttpMethod.DELETE.name();
-        public static final String GET = HttpMethod.GET.name();
-        public static final String HEAD = HttpMethod.HEAD.name();
-        public static final String OPTIONS = HttpMethod.OPTIONS.name();
-        public static final String PATCH = HttpMethod.PATCH.name();
-        public static final String POST = HttpMethod.POST.name();
-        public static final String PUT = HttpMethod.PUT.name();
-        public static final String TRACE = HttpMethod.TRACE.name();
+  private HttpConstants() {
+  }
 
-        private Methods() {
-        }
-    }
-
-    public static final class ResponseStatusCodes {
-        public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
-        public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
-        public static final int OK_200 = HttpResponseStatus.OK.code();
-        public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
-        public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
-        public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
-        public static final int NOT_MODIFIED_304 = HttpResponseStatus.NOT_MODIFIED.code();
-        public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
-        public static final int PERMANENT_REDIRECT_308 = HttpResponseStatus.PERMANENT_REDIRECT.code();
-        public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
-        public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
+  public static final class Methods {
+    public static final String CONNECT = HttpMethod.CONNECT.name();
+    public static final String DELETE = HttpMethod.DELETE.name();
+    public static final String GET = HttpMethod.GET.name();
+    public static final String HEAD = HttpMethod.HEAD.name();
+    public static final String OPTIONS = HttpMethod.OPTIONS.name();
+    public static final String PATCH = HttpMethod.PATCH.name();
+    public static final String POST = HttpMethod.POST.name();
+    public static final String PUT = HttpMethod.PUT.name();
+    public static final String TRACE = HttpMethod.TRACE.name();
 
-        private ResponseStatusCodes() {
-        }
+    private Methods() {
     }
+  }
+
+  public static final class ResponseStatusCodes {
+    public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
+    public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
+    public static final int OK_200 = HttpResponseStatus.OK.code();
+    public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
+    public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
+    public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
+    public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
+    public static final int PERMANENT_REDIRECT_308 = HttpResponseStatus.PERMANENT_REDIRECT.code();
+    public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
+    public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
 
-    private HttpConstants() {
+    private ResponseStatusCodes() {
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index 45b9c39cc..779dba9c7 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -12,130 +12,170 @@
  */
 package org.asynchttpclient.util;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.util.AsciiString;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.uri.Uri;
+import static java.nio.charset.StandardCharsets.*;
 
 /**
  * {@link org.asynchttpclient.AsyncHttpClient} common utilities.
  */
 public class HttpUtils {
 
-    public final static Charset DEFAULT_CHARSET = ISO_8859_1;
+  public static final AsciiString ACCEPT_ALL_HEADER_VALUE = new AsciiString("*/*");
 
-    public static void validateSupportedScheme(Uri uri) {
-        final String scheme = uri.getScheme();
-        if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
-            throw new IllegalArgumentException("The URI scheme, of the URI " + uri + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
-        }
-    }
+  public static final AsciiString GZIP_DEFLATE = new AsciiString(HttpHeaderValues.GZIP + "," + HttpHeaderValues.DEFLATE);
 
-    public static String getBaseUrl(Uri uri) {
-        // getAuthority duplicate but we don't want to re-concatenate
-        return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
-    }
+  private static final String CONTENT_TYPE_CHARSET_ATTRIBUTE = "charset=";
 
-    public static String getAuthority(Uri uri) {
-        return uri.getHost() + ":" + uri.getExplicitPort();
-    }
+  private static final String CONTENT_TYPE_BOUNDARY_ATTRIBUTE = "boundary=";
 
-    public static boolean isSameBase(Uri uri1, Uri uri2) {
-        return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost()) && uri1.getExplicitPort() == uri2.getExplicitPort();
-    }
+  private static final String BROTLY_ACCEPT_ENCODING_SUFFIX = ", br";
 
-    /**
-     * @param uri the uri
-     * @return the raw path or "/" if it's null
-     */
-    public static String getNonEmptyPath(Uri uri) {
-        return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
-    }
+  private HttpUtils() {
+  }
 
-    public static Charset parseCharset(String contentType) {
-        for (String part : contentType.split(";")) {
-            if (part.trim().startsWith("charset=")) {
-                String[] val = part.split("=");
-                if (val.length > 1) {
-                    String charset = val[1].trim();
-                    // Quite a lot of sites have charset="CHARSET",
-                    // e.g. charset="utf-8". Note the quotes. This is
-                    // not correct, but client should be able to handle
-                    // it (all browsers do, Grizzly strips it by default)
-                    // This is a poor man's trim("\"").trim("'")
-                    String charsetName = charset.replaceAll("\"", "").replaceAll("'", "");
-                    return Charset.forName(charsetName);
-                }
-            }
-        }
-        return null;
-    }
+  public static String hostHeader(Uri uri) {
+    String host = uri.getHost();
+    int port = uri.getPort();
+    return port == -1 || port == uri.getSchemeDefaultPort() ? host : host + ":" + port;
+  }
 
-    public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
-        return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
+  public static String originHeader(Uri uri) {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    sb.append(uri.isSecured() ? "https://" : "http://").append(uri.getHost());
+    if (uri.getExplicitPort() != uri.getSchemeDefaultPort()) {
+      sb.append(':').append(uri.getPort());
     }
+    return sb.toString();
+  }
 
-    public static ByteBuffer urlEncodeFormParams(List<Param> params, Charset charset) {
-        return StringUtils.charSequence2ByteBuffer(urlEncodeFormParams0(params, charset), US_ASCII);
+  public static Charset extractContentTypeCharsetAttribute(String contentType) {
+    String charsetName = extractContentTypeAttribute(contentType, CONTENT_TYPE_CHARSET_ATTRIBUTE);
+    return charsetName != null ? Charset.forName(charsetName) : null;
+  }
+
+  public static String extractContentTypeBoundaryAttribute(String contentType) {
+    return extractContentTypeAttribute(contentType, CONTENT_TYPE_BOUNDARY_ATTRIBUTE);
+  }
+
+  private static String extractContentTypeAttribute(String contentType, String attribute) {
+    if (contentType == null) {
+      return null;
     }
 
-    private static StringBuilder urlEncodeFormParams0(List<Param> params, Charset charset) {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        for (Param param : params) {
-            encodeAndAppendFormParam(sb, param.getName(), param.getValue(), charset);
+    for (int i = 0; i < contentType.length(); i++) {
+      if (contentType.regionMatches(true, i, attribute, 0,
+              attribute.length())) {
+        int start = i + attribute.length();
+
+        // trim left
+        while (start < contentType.length()) {
+          char c = contentType.charAt(start);
+          if (c == ' ' || c == '\'' || c == '"') {
+            start++;
+          } else {
+            break;
+          }
+        }
+        if (start == contentType.length()) {
+          break;
         }
-        sb.setLength(sb.length() - 1);
-        return sb;
-    }
 
-    private static void encodeAndAppendFormParam(StringBuilder sb, String name, String value, Charset charset) {
-        encodeAndAppendFormField(sb, name, charset);
-        if (value != null) {
-            sb.append('=');
-            encodeAndAppendFormField(sb, value, charset);
+        // trim right
+        int end = start + 1;
+        while (end < contentType.length()) {
+          char c = contentType.charAt(end);
+          if (c == ' ' || c == '\'' || c == '"' || c == ';') {
+            break;
+          } else {
+            end++;
+          }
         }
-        sb.append('&');
+
+        return contentType.substring(start, end);
+      }
     }
 
-    private static void encodeAndAppendFormField(StringBuilder sb, String field, Charset charset) {
-        if (charset.equals(UTF_8)) {
-            Utf8UrlEncoder.encodeAndAppendFormElement(sb, field);
-        } else {
-            try {
-                // TODO there's probably room for perf improvements
-                sb.append(URLEncoder.encode(field, charset.name()));
-            } catch (UnsupportedEncodingException e) {
-                // can't happen, as Charset was already resolved
-            }
-        }
+    return null;
+  }
+
+  // The pool of ASCII chars to be used for generating a multipart boundary.
+  private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(US_ASCII);
+
+  // a random size from 30 to 40
+  public static byte[] computeMultipartBoundary() {
+    ThreadLocalRandom random = ThreadLocalRandom.current();
+    byte[] bytes = new byte[random.nextInt(11) + 30];
+    for (int i = 0; i < bytes.length; i++) {
+      bytes[i] = MULTIPART_CHARS[random.nextInt(MULTIPART_CHARS.length)];
     }
+    return bytes;
+  }
 
-    public static String hostHeader(Request request, Uri uri) {
-        String virtualHost = request.getVirtualHost();
-        if (virtualHost != null)
-            return virtualHost;
-        else {
-            String host = uri.getHost();
-            int port = uri.getPort();
-            return port == -1 || port == uri.getSchemeDefaultPort() ? host : host + ":" + port;
-        }
+  public static String patchContentTypeWithBoundaryAttribute(CharSequence base, byte[] boundary) {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append(base);
+    if (base.length() != 0 && base.charAt(base.length() - 1) != ';') {
+      sb.append(';');
     }
-    
-    public static String computeOriginHeader(Uri uri) {
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-        sb.append(uri.isSecured() ? "https://" : "http://").append(uri.getHost());
-        if (uri.getExplicitPort() != uri.getSchemeDefaultPort()) {
-            sb.append(':').append(uri.getPort());
-        }
-        return sb.toString();
+    return sb.append(' ').append(CONTENT_TYPE_BOUNDARY_ATTRIBUTE).append(new String(boundary, US_ASCII)).toString();
+  }
+
+  public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
+    return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
+  }
+
+  public static ByteBuffer urlEncodeFormParams(List<Param> params, Charset charset) {
+    return StringUtils.charSequence2ByteBuffer(urlEncodeFormParams0(params, charset), US_ASCII);
+  }
+
+  private static StringBuilder urlEncodeFormParams0(List<Param> params, Charset charset) {
+    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+    for (Param param : params) {
+      encodeAndAppendFormParam(sb, param.getName(), param.getValue(), charset);
+    }
+    sb.setLength(sb.length() - 1);
+    return sb;
+  }
+
+  private static void encodeAndAppendFormParam(StringBuilder sb, String name, String value, Charset charset) {
+    encodeAndAppendFormField(sb, name, charset);
+    if (value != null) {
+      sb.append('=');
+      encodeAndAppendFormField(sb, value, charset);
+    }
+    sb.append('&');
+  }
+
+  private static void encodeAndAppendFormField(StringBuilder sb, String field, Charset charset) {
+    if (charset.equals(UTF_8)) {
+      Utf8UrlEncoder.encodeAndAppendFormElement(sb, field);
+    } else {
+      try {
+        // TODO there's probably room for perf improvements
+        sb.append(URLEncoder.encode(field, charset.name()));
+      } catch (UnsupportedEncodingException e) {
+        // can't happen, as Charset was already resolved
+      }
+    }
+  }
+
+  public static CharSequence filterOutBrotliFromAcceptEncoding(String acceptEncoding) {
+    // we don't support Brotly ATM
+    if (acceptEncoding.endsWith(BROTLY_ACCEPT_ENCODING_SUFFIX)) {
+      return acceptEncoding.subSequence(0, acceptEncoding.length() - BROTLY_ACCEPT_ENCODING_SUFFIX.length());
     }
+    return acceptEncoding;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java b/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
index 17a7e62d1..3b5cfb426 100644
--- a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
@@ -18,31 +18,31 @@
 
 public final class MessageDigestUtils {
 
-	private static final ThreadLocal<MessageDigest> MD5_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("MD5");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("MD5 not supported on this platform");
-		}
-	});
+  private static final ThreadLocal<MessageDigest> MD5_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
+    try {
+      return MessageDigest.getInstance("MD5");
+    } catch (NoSuchAlgorithmException e) {
+      throw new InternalError("MD5 not supported on this platform");
+    }
+  });
 
-	private static final ThreadLocal<MessageDigest> SHA1_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("SHA1");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("SHA1 not supported on this platform");
-		}
-	});
+  private static final ThreadLocal<MessageDigest> SHA1_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
+    try {
+      return MessageDigest.getInstance("SHA1");
+    } catch (NoSuchAlgorithmException e) {
+      throw new InternalError("SHA1 not supported on this platform");
+    }
+  });
 
-	public static MessageDigest pooledMd5MessageDigest() {
-		MessageDigest md = MD5_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
+  public static MessageDigest pooledMd5MessageDigest() {
+    MessageDigest md = MD5_MESSAGE_DIGESTS.get();
+    md.reset();
+    return md;
+  }
 
-	public static MessageDigest pooledSha1MessageDigest() {
-		MessageDigest md = SHA1_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
+  public static MessageDigest pooledSha1MessageDigest() {
+    MessageDigest md = SHA1_MESSAGE_DIGESTS.get();
+    md.reset();
+    return md;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
index 02cb28257..26e98fe9d 100644
--- a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -19,52 +19,48 @@
 
 public class MiscUtils {
 
-    private MiscUtils() {
-    }
+  private MiscUtils() {
+  }
 
-    public static boolean isNonEmpty(String string) {
-        return !isEmpty(string);
-    }
-    
-    public static boolean isEmpty(String string) {
-        return string == null || string.isEmpty();
-    }
+  public static boolean isNonEmpty(String string) {
+    return !isEmpty(string);
+  }
 
-    public static boolean isNonEmpty(Object[] array) {
-        return array != null && array.length != 0;
-    }
+  public static boolean isEmpty(String string) {
+    return string == null || string.isEmpty();
+  }
 
-    public static boolean isNonEmpty(byte[] array) {
-        return array != null && array.length != 0;
-    }
+  public static boolean isNonEmpty(Object[] array) {
+    return array != null && array.length != 0;
+  }
 
-    public static boolean isNonEmpty(Collection<?> collection) {
-        return collection != null && !collection.isEmpty();
-    }
+  public static boolean isNonEmpty(byte[] array) {
+    return array != null && array.length != 0;
+  }
 
-    public static boolean isNonEmpty(Map<?, ?> map) {
-        return map != null && !map.isEmpty();
-    }
+  public static boolean isNonEmpty(Collection<?> collection) {
+    return collection != null && !collection.isEmpty();
+  }
 
-    public static boolean getBoolean(String systemPropName, boolean defaultValue) {
-        String systemPropValue = System.getProperty(systemPropName);
-        return systemPropValue != null ? systemPropValue.equalsIgnoreCase("true") : defaultValue;
-    }
+  public static boolean isNonEmpty(Map<?, ?> map) {
+    return map != null && !map.isEmpty();
+  }
 
-    public static <T> T withDefault(T value, T def) {
-        return value == null ? def : value;
-    }
+  public static <T> T withDefault(T value, T def) {
+    return value == null ? def : value;
+  }
 
-    public static void closeSilently(Closeable closeable) {
-        if (closeable != null)
-            try {
-                closeable.close();
-            } catch (IOException e) {
-            }
-    }
+  public static void closeSilently(Closeable closeable) {
+    if (closeable != null)
+      try {
+        closeable.close();
+      } catch (IOException e) {
+        //
+      }
+  }
 
-    public static Throwable getCause(Throwable t) {
-        Throwable cause = t.getCause();
-        return cause != null ? getCause(cause) : t;
-    }
+  public static Throwable getCause(Throwable t) {
+    Throwable cause = t.getCause();
+    return cause != null ? getCause(cause) : t;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 569c8e649..5a22abc36 100644
--- a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -12,27 +12,23 @@
  */
 package org.asynchttpclient.util;
 
-import static org.asynchttpclient.Dsl.*;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Properties;
-
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
-import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Properties;
+
+import static org.asynchttpclient.Dsl.basicAuthRealm;
+import static org.asynchttpclient.Dsl.proxyServer;
+
 /**
  * Utilities for Proxy handling.
  *
@@ -40,144 +36,141 @@
  */
 public final class ProxyUtils {
 
-    private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
-
-    /**
-     * The host to use as proxy.
-     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-     */
-    public static final String PROXY_HOST = "http.proxyHost";
-
-    /**
-     * The port to use for the proxy.
-     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-     */
-    public static final String PROXY_PORT = "http.proxyPort";
-
-    /**
-     * A specification of non-proxy hosts.
-     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-     */
-    public static final String PROXY_NONPROXYHOSTS = "http.nonProxyHosts";
-
-    private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
-
-    /**
-     * The username to use for authentication for the proxy server.
-     */
-    public static final String PROXY_USER = PROPERTY_PREFIX + "user";
-
-    /**
-     * The password to use for authentication for the proxy server.
-     */
-    public static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
-
-    private ProxyUtils() {
-    }
-    
-    /**
-     * @param config the global config
-     * @param request the request
-     * @return the proxy server to be used for this request (can be null)
-     */
-    public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
-        ProxyServer proxyServer = request.getProxyServer();
-        if (proxyServer == null) {
-            ProxyServerSelector selector = config.getProxyServerSelector();
-            if (selector != null) {
-                proxyServer = selector.select(request.getUri());
-            }
-        }
-        return proxyServer != null && !proxyServer.isIgnoredForHost(request.getUri().getHost()) ? proxyServer : null;
-    }
-    
-    /**
-     * Creates a proxy server instance from the given properties.
-     * Currently the default http.* proxy properties are supported as well as properties specific for AHC.
-     *
-     * @param properties the properties to evaluate. Must not be null.
-     * @return a ProxyServer instance or null, if no valid properties were set.
-     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-     * @see #PROXY_HOST
-     * @see #PROXY_PORT
-     * @see #PROXY_NONPROXYHOSTS
-     */
-    public static ProxyServerSelector createProxyServerSelector(Properties properties) {
-        String host = properties.getProperty(PROXY_HOST);
-
-        if (host != null) {
-            int port = Integer.valueOf(properties.getProperty(PROXY_PORT, "80"));
-
-            String principal = properties.getProperty(PROXY_USER);
-            String password = properties.getProperty(PROXY_PASSWORD);
-            
-            Realm realm = null;
-            if (principal != null) {
-                realm = basicAuthRealm(principal, password).build();
-            }
-            
-            ProxyServer.Builder proxyServer = proxyServer(host, port).setRealm(realm);
-
-            String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
-            if (nonProxyHosts != null) {
-                proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
-            }
-
-            ProxyServer proxy = proxyServer.build();
-            return uri -> proxy;
-        }
-
-        return ProxyServerSelector.NO_PROXY_SELECTOR;
+  /**
+   * The host to use as proxy.
+   *
+   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+   */
+  public static final String PROXY_HOST = "http.proxyHost";
+  /**
+   * The port to use for the proxy.
+   *
+   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+   */
+  public static final String PROXY_PORT = "http.proxyPort";
+  /**
+   * A specification of non-proxy hosts.
+   *
+   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+   */
+  public static final String PROXY_NONPROXYHOSTS = "http.nonProxyHosts";
+  private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
+  private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
+
+  /**
+   * The username to use for authentication for the proxy server.
+   */
+  private static final String PROXY_USER = PROPERTY_PREFIX + "user";
+
+  /**
+   * The password to use for authentication for the proxy server.
+   */
+  private static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
+
+  private ProxyUtils() {
+  }
+
+  /**
+   * @param config  the global config
+   * @param request the request
+   * @return the proxy server to be used for this request (can be null)
+   */
+  public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
+    ProxyServer proxyServer = request.getProxyServer();
+    if (proxyServer == null) {
+      ProxyServerSelector selector = config.getProxyServerSelector();
+      if (selector != null) {
+        proxyServer = selector.select(request.getUri());
+      }
     }
-
-    /**
-     * Get a proxy server selector based on the JDK default proxy selector.
-     *
-     * @return The proxy server selector.
-     */
-    public static ProxyServerSelector getJdkDefaultProxyServerSelector() {
-        return createProxyServerSelector(ProxySelector.getDefault());
+    return proxyServer != null && !proxyServer.isIgnoredForHost(request.getUri().getHost()) ? proxyServer : null;
+  }
+
+  /**
+   * Creates a proxy server instance from the given properties.
+   * Currently the default http.* proxy properties are supported as well as properties specific for AHC.
+   *
+   * @param properties the properties to evaluate. Must not be null.
+   * @return a ProxyServer instance or null, if no valid properties were set.
+   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+   * @see #PROXY_HOST
+   * @see #PROXY_PORT
+   * @see #PROXY_NONPROXYHOSTS
+   */
+  public static ProxyServerSelector createProxyServerSelector(Properties properties) {
+    String host = properties.getProperty(PROXY_HOST);
+
+    if (host != null) {
+      int port = Integer.valueOf(properties.getProperty(PROXY_PORT, "80"));
+
+      String principal = properties.getProperty(PROXY_USER);
+      String password = properties.getProperty(PROXY_PASSWORD);
+
+      Realm realm = null;
+      if (principal != null) {
+        realm = basicAuthRealm(principal, password).build();
+      }
+
+      ProxyServer.Builder proxyServer = proxyServer(host, port).setRealm(realm);
+
+      String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
+      if (nonProxyHosts != null) {
+        proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
+      }
+
+      ProxyServer proxy = proxyServer.build();
+      return uri -> proxy;
     }
 
-    /**
-     * Create a proxy server selector based on the passed in JDK proxy selector.
-     *
-     * @param proxySelector The proxy selector to use.  Must not be null.
-     * @return The proxy server selector.
-     */
-    public static ProxyServerSelector createProxyServerSelector(final ProxySelector proxySelector) {
-        return new ProxyServerSelector() {
-            public ProxyServer select(Uri uri) {
-                try {
-                    URI javaUri = uri.toJavaNetURI();
-
-                    List<Proxy> proxies = proxySelector.select(javaUri);
-                    if (proxies != null) {
-                        // Loop through them until we find one that we know how to use
-                        for (Proxy proxy : proxies) {
-                            switch (proxy.type()) {
-                            case HTTP:
-                                if (!(proxy.address() instanceof InetSocketAddress)) {
-                                    logger.warn("Don't know how to connect to address " + proxy.address());
-                                    return null;
-                                } else {
-                                    InetSocketAddress address = (InetSocketAddress) proxy.address();
-                                    return proxyServer(address.getHostName(), address.getPort()).build();
-                                }
-                            case DIRECT:
-                                return null;
-                            default:
-                                logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
-                                break;
-                            }
-                        }
-                    }
-                    return null;
-                } catch (URISyntaxException e) {
-                    logger.warn(uri + " couldn't be turned into a java.net.URI", e);
+    return ProxyServerSelector.NO_PROXY_SELECTOR;
+  }
+
+  /**
+   * Get a proxy server selector based on the JDK default proxy selector.
+   *
+   * @return The proxy server selector.
+   */
+  public static ProxyServerSelector getJdkDefaultProxyServerSelector() {
+    return createProxyServerSelector(ProxySelector.getDefault());
+  }
+
+  /**
+   * Create a proxy server selector based on the passed in JDK proxy selector.
+   *
+   * @param proxySelector The proxy selector to use.  Must not be null.
+   * @return The proxy server selector.
+   */
+  private static ProxyServerSelector createProxyServerSelector(final ProxySelector proxySelector) {
+    return uri -> {
+        try {
+          URI javaUri = uri.toJavaNetURI();
+
+          List<Proxy> proxies = proxySelector.select(javaUri);
+          if (proxies != null) {
+            // Loop through them until we find one that we know how to use
+            for (Proxy proxy : proxies) {
+              switch (proxy.type()) {
+                case HTTP:
+                  if (!(proxy.address() instanceof InetSocketAddress)) {
+                    logger.warn("Don't know how to connect to address " + proxy.address());
                     return null;
-                }
+                  } else {
+                    InetSocketAddress address = (InetSocketAddress) proxy.address();
+                    return proxyServer(address.getHostName(), address.getPort()).build();
+                  }
+                case DIRECT:
+                  return null;
+                default:
+                  logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
+                  break;
+              }
             }
-        };
-    }
+          }
+          return null;
+        } catch (URISyntaxException e) {
+          logger.warn(uri + " couldn't be turned into a java.net.URI", e);
+          return null;
+        }
+    };
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java b/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
index 98e5af398..2e89ad78d 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
@@ -14,18 +14,18 @@
 
 public class StringBuilderPool {
 
-    public static final StringBuilderPool DEFAULT = new StringBuilderPool();
+  public static final StringBuilderPool DEFAULT = new StringBuilderPool();
 
-    private final ThreadLocal<StringBuilder> pool = ThreadLocal.withInitial(() -> new StringBuilder(512));
+  private final ThreadLocal<StringBuilder> pool = ThreadLocal.withInitial(() -> new StringBuilder(512));
 
-    /**
-     * BEWARE: MUSN'T APPEND TO ITSELF!
-     * 
-     * @return a pooled StringBuilder
-     */
-    public StringBuilder stringBuilder() {
-        StringBuilder sb = pool.get();
-        sb.setLength(0);
-        return sb;
-    }
+  /**
+   * BEWARE: MUSN'T APPEND TO ITSELF!
+   *
+   * @return a pooled StringBuilder
+   */
+  public StringBuilder stringBuilder() {
+    StringBuilder sb = pool.get();
+    sb.setLength(0);
+    return sb;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringUtils.java b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
index e3f793769..ef08f938d 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
@@ -18,45 +18,45 @@
 
 public final class StringUtils {
 
-    private StringUtils() {
+  private StringUtils() {
+  }
+
+  public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
+    return charset.encode(CharBuffer.wrap(cs));
+  }
+
+  public static byte[] byteBuffer2ByteArray(ByteBuffer bb) {
+    byte[] rawBase = new byte[bb.remaining()];
+    bb.get(rawBase);
+    return rawBase;
+  }
+
+  public static byte[] charSequence2Bytes(CharSequence sb, Charset charset) {
+    ByteBuffer bb = charSequence2ByteBuffer(sb, charset);
+    return byteBuffer2ByteArray(bb);
+  }
+
+  public static String toHexString(byte[] data) {
+    StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder();
+    for (byte aData : data) {
+      buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
+      buffer.append(Integer.toHexString(aData & 0x0f));
     }
-
-    public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
-        return charset.encode(CharBuffer.wrap(cs));
-    }
-
-    public static byte[] byteBuffer2ByteArray(ByteBuffer bb) {
-        byte[] rawBase = new byte[bb.remaining()];
-        bb.get(rawBase);
-        return rawBase;
-    }
-
-    public static byte[] charSequence2Bytes(CharSequence sb, Charset charset) {
-        ByteBuffer bb = charSequence2ByteBuffer(sb, charset);
-        return byteBuffer2ByteArray(bb);
-    }
-
-    public static String toHexString(byte[] data) {
-        StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder();
-        for (byte aData : data) {
-            buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
-            buffer.append(Integer.toHexString(aData & 0x0f));
-        }
-        return buffer.toString();
-    }
-
-    public static void appendBase16(StringBuilder buf, byte[] bytes) {
-        int base = 16;
-        for (byte b : bytes) {
-            int bi = 0xff & b;
-            int c = '0' + (bi / base) % base;
-            if (c > '9')
-                c = 'a' + (c - '0' - 10);
-            buf.append((char) c);
-            c = '0' + bi % base;
-            if (c > '9')
-                c = 'a' + (c - '0' - 10);
-            buf.append((char) c);
-        }
+    return buffer.toString();
+  }
+
+  public static void appendBase16(StringBuilder buf, byte[] bytes) {
+    int base = 16;
+    for (byte b : bytes) {
+      int bi = 0xff & b;
+      int c = '0' + (bi / base) % base;
+      if (c > '9')
+        c = 'a' + (c - '0' - 10);
+      buf.append((char) c);
+      c = '0' + bi % base;
+      if (c > '9')
+        c = 'a' + (c - '0' - 10);
+      buf.append((char) c);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java b/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
index 1a260f273..dd586658a 100644
--- a/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
+++ b/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
@@ -14,18 +14,18 @@
 
 public final class ThrowableUtil {
 
-    private ThrowableUtil() {
-    }
+  private ThrowableUtil() {
+  }
 
-    /**
-     * @param <T> the Throwable type
-     * @param t the throwable whose stacktrace we want to remove
-     * @param clazz the caller class
-     * @param method the caller method
-     * @return the input throwable with removed stacktrace
-     */
-    public static <T extends Throwable> T unknownStackTrace(T t, Class<?> clazz, String method) {
-        t.setStackTrace(new StackTraceElement[] { new StackTraceElement(clazz.getName(), method, null, -1) });
-        return t;
-    }
+  /**
+   * @param <T>    the Throwable type
+   * @param t      the throwable whose stacktrace we want to remove
+   * @param clazz  the caller class
+   * @param method the caller method
+   * @return the input throwable with removed stacktrace
+   */
+  public static <T extends Throwable> T unknownStackTrace(T t, Class<?> clazz, String method) {
+    t.setStackTrace(new StackTraceElement[]{new StackTraceElement(clazz.getName(), method, null, -1)});
+    return t;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
index 0ef949839..4349d0d31 100644
--- a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
@@ -12,135 +12,134 @@
  */
 package org.asynchttpclient.util;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.Utf8UrlEncoder.encodeAndAppendQuery;
-
 import org.asynchttpclient.Param;
 import org.asynchttpclient.uri.Uri;
 
 import java.util.List;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.Utf8UrlEncoder.encodeAndAppendQuery;
+
 public enum UriEncoder {
 
-    FIXING {
-
-        public String encodePath(String path) {
-            return Utf8UrlEncoder.encodePath(path);
-        }
-
-        private void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
-            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, name);
-            if (value != null) {
-                sb.append('=');
-                Utf8UrlEncoder.encodeAndAppendQueryElement(sb, value);
-            }
-            sb.append('&');
-        }
-
-        private void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
-            for (Param param : queryParams)
-                encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
-        }
-
-        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
-            // concatenate encoded query + encoded query params
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            encodeAndAppendQuery(sb, query);
-            sb.append('&');
-            encodeAndAppendQueryParams(sb, queryParams);
-            sb.setLength(sb.length() - 1);
-            return sb.toString();
-        }
-
-        protected String withQueryWithoutParams(final String query) {
-            // encode query
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            encodeAndAppendQuery(sb, query);
-            return sb.toString();
-        }
-
-        protected String withoutQueryWithParams(final List<Param> queryParams) {
-            // concatenate encoded query params
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            encodeAndAppendQueryParams(sb, queryParams);
-            sb.setLength(sb.length() - 1);
-            return sb.toString();
-        }
-    }, //
-
-    RAW {
-
-        public String encodePath(String path) {
-            return path;
-        }
-
-        private void appendRawQueryParam(StringBuilder sb, String name, String value) {
-            sb.append(name);
-            if (value != null)
-                sb.append('=').append(value);
-            sb.append('&');
-        }
-
-        private void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
-            for (Param param : queryParams)
-                appendRawQueryParam(sb, param.getName(), param.getValue());
-        }
-
-        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
-            // concatenate raw query + raw query params
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            sb.append(query);
-            appendRawQueryParams(sb, queryParams);
-            sb.setLength(sb.length() - 1);
-            return sb.toString();
-        }
-
-        protected String withQueryWithoutParams(final String query) {
-            // return raw query as is
-            return query;
-        }
-
-        protected String withoutQueryWithParams(final List<Param> queryParams) {
-            // concatenate raw queryParams
-            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-            appendRawQueryParams(sb, queryParams);
-            sb.setLength(sb.length() - 1);
-            return sb.toString();
-        }
-    };
-
-    public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
-        return disableUrlEncoding ? RAW : FIXING;
+  FIXING {
+    public String encodePath(String path) {
+      return Utf8UrlEncoder.encodePath(path);
     }
 
-    protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
+    private void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
+      Utf8UrlEncoder.encodeAndAppendQueryElement(sb, name);
+      if (value != null) {
+        sb.append('=');
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, value);
+      }
+      sb.append('&');
+    }
 
-    protected abstract String withQueryWithoutParams(final String query);
+    private void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+      for (Param param : queryParams)
+        encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
+    }
+
+    protected String withQueryWithParams(final String query, final List<Param> queryParams) {
+      // concatenate encoded query + encoded query params
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      encodeAndAppendQuery(sb, query);
+      sb.append('&');
+      encodeAndAppendQueryParams(sb, queryParams);
+      sb.setLength(sb.length() - 1);
+      return sb.toString();
+    }
 
-    protected abstract String withoutQueryWithParams(final List<Param> queryParams);
+    protected String withQueryWithoutParams(final String query) {
+      // encode query
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      encodeAndAppendQuery(sb, query);
+      return sb.toString();
+    }
 
-    private String withQuery(final String query, final List<Param> queryParams) {
-        return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
+    protected String withoutQueryWithParams(final List<Param> queryParams) {
+      // concatenate encoded query params
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      encodeAndAppendQueryParams(sb, queryParams);
+      sb.setLength(sb.length() - 1);
+      return sb.toString();
     }
+  },
 
-    private String withoutQuery(final List<Param> queryParams) {
-        return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
+  RAW {
+    public String encodePath(String path) {
+      return path;
     }
 
-    public Uri encode(Uri uri, List<Param> queryParams) {
-        String newPath = encodePath(uri.getPath());
-        String newQuery = encodeQuery(uri.getQuery(), queryParams);
-        return new Uri(uri.getScheme(),//
-                uri.getUserInfo(),//
-                uri.getHost(),//
-                uri.getPort(),//
-                newPath,//
-                newQuery);
+    private void appendRawQueryParam(StringBuilder sb, String name, String value) {
+      sb.append(name);
+      if (value != null)
+        sb.append('=').append(value);
+      sb.append('&');
     }
 
-    protected abstract String encodePath(String path);
+    private void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+      for (Param param : queryParams)
+        appendRawQueryParam(sb, param.getName(), param.getValue());
+    }
 
-    private String encodeQuery(final String query, final List<Param> queryParams) {
-        return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
+    protected String withQueryWithParams(final String query, final List<Param> queryParams) {
+      // concatenate raw query + raw query params
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      sb.append(query);
+      appendRawQueryParams(sb, queryParams);
+      sb.setLength(sb.length() - 1);
+      return sb.toString();
     }
+
+    protected String withQueryWithoutParams(final String query) {
+      // return raw query as is
+      return query;
+    }
+
+    protected String withoutQueryWithParams(final List<Param> queryParams) {
+      // concatenate raw queryParams
+      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+      appendRawQueryParams(sb, queryParams);
+      sb.setLength(sb.length() - 1);
+      return sb.toString();
+    }
+  };
+
+  public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
+    return disableUrlEncoding ? RAW : FIXING;
+  }
+
+  protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
+
+  protected abstract String withQueryWithoutParams(final String query);
+
+  protected abstract String withoutQueryWithParams(final List<Param> queryParams);
+
+  private String withQuery(final String query, final List<Param> queryParams) {
+    return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
+  }
+
+  private String withoutQuery(final List<Param> queryParams) {
+    return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
+  }
+
+  public Uri encode(Uri uri, List<Param> queryParams) {
+    String newPath = encodePath(uri.getPath());
+    String newQuery = encodeQuery(uri.getQuery(), queryParams);
+    return new Uri(uri.getScheme(),
+            uri.getUserInfo(),
+            uri.getHost(),
+            uri.getPort(),
+            newPath,
+            newQuery,
+            uri.getFragment());
+  }
+
+  protected abstract String encodePath(String path);
+
+  private String encodeQuery(final String query, final List<Param> queryParams) {
+    return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
index 7499b2567..cdac64e11 100644
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -17,219 +17,219 @@
 
 public final class Utf8UrlEncoder {
 
-    // see http://tools.ietf.org/html/rfc3986#section-3.4
-    // ALPHA / DIGIT / "-" / "." / "_" / "~"
-    private static final BitSet RFC3986_UNRESERVED_CHARS = new BitSet();
-    static {
-        for (int i = 'a'; i <= 'z'; ++i) {
-            RFC3986_UNRESERVED_CHARS.set(i);
-        }
-        for (int i = 'A'; i <= 'Z'; ++i) {
-            RFC3986_UNRESERVED_CHARS.set(i);
-        }
-        for (int i = '0'; i <= '9'; ++i) {
-            RFC3986_UNRESERVED_CHARS.set(i);
-        }
-        RFC3986_UNRESERVED_CHARS.set('-');
-        RFC3986_UNRESERVED_CHARS.set('.');
-        RFC3986_UNRESERVED_CHARS.set('_');
-        RFC3986_UNRESERVED_CHARS.set('~');
-    }
-
-    // gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"
-    private static final BitSet RFC3986_GENDELIM_CHARS = new BitSet();
-    static {
-        RFC3986_GENDELIM_CHARS.set(':');
-        RFC3986_GENDELIM_CHARS.set('/');
-        RFC3986_GENDELIM_CHARS.set('?');
-        RFC3986_GENDELIM_CHARS.set('#');
-        RFC3986_GENDELIM_CHARS.set('[');
-        RFC3986_GENDELIM_CHARS.set(']');
-        RFC3986_GENDELIM_CHARS.set('@');
-    }
-
-    // "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
-    private static final BitSet RFC3986_SUBDELIM_CHARS = new BitSet();
-    static {
-        RFC3986_SUBDELIM_CHARS.set('!');
-        RFC3986_SUBDELIM_CHARS.set('$');
-        RFC3986_SUBDELIM_CHARS.set('&');
-        RFC3986_SUBDELIM_CHARS.set('\'');
-        RFC3986_SUBDELIM_CHARS.set('(');
-        RFC3986_SUBDELIM_CHARS.set(')');
-        RFC3986_SUBDELIM_CHARS.set('*');
-        RFC3986_SUBDELIM_CHARS.set('+');
-        RFC3986_SUBDELIM_CHARS.set(',');
-        RFC3986_SUBDELIM_CHARS.set(';');
-        RFC3986_SUBDELIM_CHARS.set('=');
-    }
-
-    // gen-delims / sub-delims
-    private static final BitSet RFC3986_RESERVED_CHARS = new BitSet();
-    static {
-        RFC3986_RESERVED_CHARS.or(RFC3986_GENDELIM_CHARS);
-        RFC3986_RESERVED_CHARS.or(RFC3986_SUBDELIM_CHARS);
-    }
-
-    // unreserved / pct-encoded / sub-delims / ":" / "@"
-    private static final BitSet RFC3986_PCHARS = new BitSet();
-    static {
-        RFC3986_PCHARS.or(RFC3986_UNRESERVED_CHARS);
-        RFC3986_PCHARS.or(RFC3986_SUBDELIM_CHARS);
-        RFC3986_PCHARS.set(':');
-        RFC3986_PCHARS.set('@');
-    }
-
-    private static final BitSet BUILT_PATH_UNTOUCHED_CHARS = new BitSet();
-    static {
-        BUILT_PATH_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
-        BUILT_PATH_UNTOUCHED_CHARS.set('%');
-        BUILT_PATH_UNTOUCHED_CHARS.set('/');
-    }
-
-    private static final BitSet BUILT_QUERY_UNTOUCHED_CHARS = new BitSet();
-    static {
-        BUILT_QUERY_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
-        BUILT_QUERY_UNTOUCHED_CHARS.set('%');
-        BUILT_QUERY_UNTOUCHED_CHARS.set('/');
-        BUILT_QUERY_UNTOUCHED_CHARS.set('?');
-    }
-
-    // http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
-    private static final BitSet FORM_URL_ENCODED_SAFE_CHARS = new BitSet();
-    static {
-        for (int i = 'a'; i <= 'z'; ++i) {
-            FORM_URL_ENCODED_SAFE_CHARS.set(i);
-        }
-        for (int i = 'A'; i <= 'Z'; ++i) {
-            FORM_URL_ENCODED_SAFE_CHARS.set(i);
-        }
-        for (int i = '0'; i <= '9'; ++i) {
-            FORM_URL_ENCODED_SAFE_CHARS.set(i);
-        }
-
-        FORM_URL_ENCODED_SAFE_CHARS.set('-');
-        FORM_URL_ENCODED_SAFE_CHARS.set('.');
-        FORM_URL_ENCODED_SAFE_CHARS.set('_');
-        FORM_URL_ENCODED_SAFE_CHARS.set('*');
-    }
-
-    private static final char[] HEX = "0123456789ABCDEF".toCharArray();
-
-    private Utf8UrlEncoder() {
-    }
-
-    public static String encodePath(String input) {
-        StringBuilder sb = lazyAppendEncoded(null, input, BUILT_PATH_UNTOUCHED_CHARS, false);
-        return sb == null ? input : sb.toString();
-    }
-
-    public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
-        return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
-    }
-
-    public static String encodeQueryElement(String input) {
-        StringBuilder sb = new StringBuilder(input.length() + 6);
-        encodeAndAppendQueryElement(sb, input);
-        return sb.toString();
-    }
-
-    public static StringBuilder encodeAndAppendQueryElement(StringBuilder sb, CharSequence input) {
-        return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, false);
-    }
-
-    public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSequence input) {
-        return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
-    }
-
-    public static String percentEncodeQueryElement(String input) {
-        if (input == null) {
-            return null;
-        }
-        StringBuilder sb = new StringBuilder(input.length() + 6);
-        encodeAndAppendPercentEncoded(sb, input);
-        return sb.toString();
-    }
-
-    public static StringBuilder encodeAndAppendPercentEncoded(StringBuilder sb, CharSequence input) {
-        return appendEncoded(sb, input, RFC3986_UNRESERVED_CHARS, false);
-    }
-
-    private static StringBuilder lazyInitStringBuilder(CharSequence input, int firstNonUsAsciiPosition) {
-        StringBuilder sb = new StringBuilder(input.length() + 6);
-        for (int i = 0; i < firstNonUsAsciiPosition; i++) {
-            sb.append(input.charAt(i));
-        }
-        return sb;
-    }
-
-    private static StringBuilder lazyAppendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
-        int c;
-        for (int i = 0; i < input.length(); i += Character.charCount(c)) {
-            c = Character.codePointAt(input, i);
-            if (c <= 127) {
-                if (dontNeedEncoding.get(c)) {
-                    if (sb != null) {
-                        sb.append((char) c);
-                    }
-                } else {
-                    if (sb == null) {
-                        sb = lazyInitStringBuilder(input, i);
-                    }
-                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
-                }
-            } else {
-                if (sb == null) {
-                    sb = lazyInitStringBuilder(input, i);
-                }
-                appendMultiByteEncoded(sb, c);
-            }
+  // see http://tools.ietf.org/html/rfc3986#section-3.4
+  // ALPHA / DIGIT / "-" / "." / "_" / "~"
+  private static final BitSet RFC3986_UNRESERVED_CHARS = new BitSet();
+  // gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+  private static final BitSet RFC3986_GENDELIM_CHARS = new BitSet();
+  // "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
+  private static final BitSet RFC3986_SUBDELIM_CHARS = new BitSet();
+  // gen-delims / sub-delims
+  private static final BitSet RFC3986_RESERVED_CHARS = new BitSet();
+  // unreserved / pct-encoded / sub-delims / ":" / "@"
+  private static final BitSet RFC3986_PCHARS = new BitSet();
+  private static final BitSet BUILT_PATH_UNTOUCHED_CHARS = new BitSet();
+  private static final BitSet BUILT_QUERY_UNTOUCHED_CHARS = new BitSet();
+  // http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
+  private static final BitSet FORM_URL_ENCODED_SAFE_CHARS = new BitSet();
+  private static final char[] HEX = "0123456789ABCDEF".toCharArray();
+
+  static {
+    for (int i = 'a'; i <= 'z'; ++i) {
+      RFC3986_UNRESERVED_CHARS.set(i);
+    }
+    for (int i = 'A'; i <= 'Z'; ++i) {
+      RFC3986_UNRESERVED_CHARS.set(i);
+    }
+    for (int i = '0'; i <= '9'; ++i) {
+      RFC3986_UNRESERVED_CHARS.set(i);
+    }
+    RFC3986_UNRESERVED_CHARS.set('-');
+    RFC3986_UNRESERVED_CHARS.set('.');
+    RFC3986_UNRESERVED_CHARS.set('_');
+    RFC3986_UNRESERVED_CHARS.set('~');
+  }
+
+  static {
+    RFC3986_GENDELIM_CHARS.set(':');
+    RFC3986_GENDELIM_CHARS.set('/');
+    RFC3986_GENDELIM_CHARS.set('?');
+    RFC3986_GENDELIM_CHARS.set('#');
+    RFC3986_GENDELIM_CHARS.set('[');
+    RFC3986_GENDELIM_CHARS.set(']');
+    RFC3986_GENDELIM_CHARS.set('@');
+  }
+
+  static {
+    RFC3986_SUBDELIM_CHARS.set('!');
+    RFC3986_SUBDELIM_CHARS.set('$');
+    RFC3986_SUBDELIM_CHARS.set('&');
+    RFC3986_SUBDELIM_CHARS.set('\'');
+    RFC3986_SUBDELIM_CHARS.set('(');
+    RFC3986_SUBDELIM_CHARS.set(')');
+    RFC3986_SUBDELIM_CHARS.set('*');
+    RFC3986_SUBDELIM_CHARS.set('+');
+    RFC3986_SUBDELIM_CHARS.set(',');
+    RFC3986_SUBDELIM_CHARS.set(';');
+    RFC3986_SUBDELIM_CHARS.set('=');
+  }
+
+  static {
+    RFC3986_RESERVED_CHARS.or(RFC3986_GENDELIM_CHARS);
+    RFC3986_RESERVED_CHARS.or(RFC3986_SUBDELIM_CHARS);
+  }
+
+  static {
+    RFC3986_PCHARS.or(RFC3986_UNRESERVED_CHARS);
+    RFC3986_PCHARS.or(RFC3986_SUBDELIM_CHARS);
+    RFC3986_PCHARS.set(':');
+    RFC3986_PCHARS.set('@');
+  }
+
+  static {
+    BUILT_PATH_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+    BUILT_PATH_UNTOUCHED_CHARS.set('%');
+    BUILT_PATH_UNTOUCHED_CHARS.set('/');
+  }
+
+  static {
+    BUILT_QUERY_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+    BUILT_QUERY_UNTOUCHED_CHARS.set('%');
+    BUILT_QUERY_UNTOUCHED_CHARS.set('/');
+    BUILT_QUERY_UNTOUCHED_CHARS.set('?');
+  }
+
+  static {
+    for (int i = 'a'; i <= 'z'; ++i) {
+      FORM_URL_ENCODED_SAFE_CHARS.set(i);
+    }
+    for (int i = 'A'; i <= 'Z'; ++i) {
+      FORM_URL_ENCODED_SAFE_CHARS.set(i);
+    }
+    for (int i = '0'; i <= '9'; ++i) {
+      FORM_URL_ENCODED_SAFE_CHARS.set(i);
+    }
+
+    FORM_URL_ENCODED_SAFE_CHARS.set('-');
+    FORM_URL_ENCODED_SAFE_CHARS.set('.');
+    FORM_URL_ENCODED_SAFE_CHARS.set('_');
+    FORM_URL_ENCODED_SAFE_CHARS.set('*');
+  }
+
+  private Utf8UrlEncoder() {
+  }
+
+  public static String encodePath(String input) {
+    StringBuilder sb = lazyAppendEncoded(null, input, BUILT_PATH_UNTOUCHED_CHARS, false);
+    return sb == null ? input : sb.toString();
+  }
+
+  public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
+    return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
+  }
+
+  public static String encodeQueryElement(String input) {
+    StringBuilder sb = new StringBuilder(input.length() + 6);
+    encodeAndAppendQueryElement(sb, input);
+    return sb.toString();
+  }
+
+  public static StringBuilder encodeAndAppendQueryElement(StringBuilder sb, CharSequence input) {
+    return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, false);
+  }
+
+  public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSequence input) {
+    return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
+  }
+
+  public static String percentEncodeQueryElement(String input) {
+    if (input == null) {
+      return null;
+    }
+    StringBuilder sb = new StringBuilder(input.length() + 6);
+    encodeAndAppendPercentEncoded(sb, input);
+    return sb.toString();
+  }
+
+  public static StringBuilder encodeAndAppendPercentEncoded(StringBuilder sb, CharSequence input) {
+    return appendEncoded(sb, input, RFC3986_UNRESERVED_CHARS, false);
+  }
+
+  private static StringBuilder lazyInitStringBuilder(CharSequence input, int firstNonUsAsciiPosition) {
+    StringBuilder sb = new StringBuilder(input.length() + 6);
+    for (int i = 0; i < firstNonUsAsciiPosition; i++) {
+      sb.append(input.charAt(i));
+    }
+    return sb;
+  }
+
+  private static StringBuilder lazyAppendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+    int c;
+    for (int i = 0; i < input.length(); i += Character.charCount(c)) {
+      c = Character.codePointAt(input, i);
+      if (c <= 127) {
+        if (dontNeedEncoding.get(c)) {
+          if (sb != null) {
+            sb.append((char) c);
+          }
+        } else {
+          if (sb == null) {
+            sb = lazyInitStringBuilder(input, i);
+          }
+          appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
         }
-        return sb;
-    }
-
-    private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
-        int c;
-        for (int i = 0; i < input.length(); i += Character.charCount(c)) {
-            c = Character.codePointAt(input, i);
-            if (c <= 127) {
-                if (dontNeedEncoding.get(c)) {
-                    sb.append((char) c);
-                } else {
-                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
-                }
-            } else {
-                appendMultiByteEncoded(sb, c);
-            }
+      } else {
+        if (sb == null) {
+          sb = lazyInitStringBuilder(input, i);
         }
-        return sb;
-    }
-
-    private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
-
-        if (value == ' ' && encodeSpaceAsPlus) {
-            sb.append('+');
-            return;
-        }
-
-        sb.append('%');
-        sb.append(HEX[value >> 4]);
-        sb.append(HEX[value & 0xF]);
-    }
-
-    private static void appendMultiByteEncoded(StringBuilder sb, int value) {
-        if (value < 0x800) {
-            appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
-        } else if (value < 0x10000) {
-            appendSingleByteEncoded(sb, (0xe0 | (value >> 12)), false);
-            appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)), false);
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+        appendMultiByteEncoded(sb, c);
+      }
+    }
+    return sb;
+  }
+
+  private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+    int c;
+    for (int i = 0; i < input.length(); i += Character.charCount(c)) {
+      c = Character.codePointAt(input, i);
+      if (c <= 127) {
+        if (dontNeedEncoding.get(c)) {
+          sb.append((char) c);
         } else {
-            appendSingleByteEncoded(sb, (0xf0 | (value >> 18)), false);
-            appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f), false);
-            appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f), false);
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+          appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
         }
-    }
+      } else {
+        appendMultiByteEncoded(sb, c);
+      }
+    }
+    return sb;
+  }
+
+  private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
+
+    if (value == ' ' && encodeSpaceAsPlus) {
+      sb.append('+');
+      return;
+    }
+
+    sb.append('%');
+    sb.append(HEX[value >> 4]);
+    sb.append(HEX[value & 0xF]);
+  }
+
+  private static void appendMultiByteEncoded(StringBuilder sb, int value) {
+    if (value < 0x800) {
+      appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
+      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+    } else if (value < 0x10000) {
+      appendSingleByteEncoded(sb, (0xe0 | (value >> 12)), false);
+      appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)), false);
+      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+    } else {
+      appendSingleByteEncoded(sb, (0xf0 | (value >> 18)), false);
+      appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f), false);
+      appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f), false);
+      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+    }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index 551150933..a6df2fccf 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -14,17 +14,6 @@
 package org.asynchttpclient.webdav;
 
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -38,164 +27,166 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Simple {@link AsyncHandler} that add support for WebDav's response manipulation.
  *
  * @param <T> the result type
  */
 public abstract class WebDavCompletionHandlerBase<T> implements AsyncHandler<T> {
-    private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
-
-    private HttpResponseStatus status;
-    private HttpHeaders headers;
-    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
+  private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
+  private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
+  private HttpResponseStatus status;
+  private HttpHeaders headers;
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public final State onBodyPartReceived(final HttpResponseBodyPart content) {
+    bodyParts.add(content);
+    return State.CONTINUE;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public final State onStatusReceived(final HttpResponseStatus status) {
+    this.status = status;
+    return State.CONTINUE;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public final State onHeadersReceived(final HttpHeaders headers) {
+    this.headers = headers;
+    return State.CONTINUE;
+  }
+
+  private Document readXMLResponse(InputStream stream) {
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+    Document document;
+    try {
+      document = factory.newDocumentBuilder().parse(stream);
+      parse(document);
+    } catch (SAXException | IOException | ParserConfigurationException e) {
+      logger.error(e.getMessage(), e);
+      throw new RuntimeException(e);
+    }
+    return document;
+  }
+
+  private void parse(Document document) {
+    Element element = document.getDocumentElement();
+    NodeList statusNode = element.getElementsByTagName("status");
+    for (int i = 0; i < statusNode.getLength(); i++) {
+      Node node = statusNode.item(i);
+
+      String value = node.getFirstChild().getNodeValue();
+      int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
+      String statusText = value.substring(value.lastIndexOf(" "));
+      status = new HttpStatusWrapper(status, statusText, statusCode);
+    }
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public final T onCompleted() throws Exception {
+    if (status != null) {
+      Document document = null;
+      if (status.getStatusCode() == 207) {
+        document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
+      }
+      // recompute response as readXMLResponse->parse might have updated it
+      return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
+    } else {
+      throw new IllegalStateException("Status is null");
+    }
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void onThrowable(Throwable t) {
+    logger.debug(t.getMessage(), t);
+  }
+
+  /**
+   * Invoked once the HTTP response has been fully read.
+   *
+   * @param response The {@link org.asynchttpclient.Response}
+   * @return Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+   * @throws Exception if something wrong happens
+   */
+  abstract public T onCompleted(WebDavResponse response) throws Exception;
+
+  private class HttpStatusWrapper extends HttpResponseStatus {
+
+    private final HttpResponseStatus wrapped;
+
+    private final String statusText;
+
+    private final int statusCode;
+
+    HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int statusCode) {
+      super(wrapper.getUri());
+      this.wrapped = wrapper;
+      this.statusText = statusText;
+      this.statusCode = statusCode;
+    }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public final State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        bodyParts.add(content);
-        return State.CONTINUE;
+    public int getStatusCode() {
+      return (statusText == null ? wrapped.getStatusCode() : statusCode);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public final State onStatusReceived(final HttpResponseStatus status) throws Exception {
-        this.status = status;
-        return State.CONTINUE;
+    public String getStatusText() {
+      return (statusText == null ? wrapped.getStatusText() : statusText);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public final State onHeadersReceived(final HttpHeaders headers) throws Exception {
-        this.headers = headers;
-        return State.CONTINUE;
+    public String getProtocolName() {
+      return wrapped.getProtocolName();
     }
 
-    private Document readXMLResponse(InputStream stream) {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        Document document = null;
-        try {
-            document = factory.newDocumentBuilder().parse(stream);
-            parse(document);
-        } catch (SAXException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (IOException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (ParserConfigurationException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        }
-        return document;
+    @Override
+    public int getProtocolMajorVersion() {
+      return wrapped.getProtocolMajorVersion();
     }
 
-    private void parse(Document document) {
-        Element element = document.getDocumentElement();
-        NodeList statusNode = element.getElementsByTagName("status");
-        for (int i = 0; i < statusNode.getLength(); i++) {
-            Node node = statusNode.item(i);
-
-            String value = node.getFirstChild().getNodeValue();
-            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
-            String statusText = value.substring(value.lastIndexOf(" "));
-            status = new HttpStatusWrapper(status, statusText, statusCode);
-        }
+    @Override
+    public int getProtocolMinorVersion() {
+      return wrapped.getProtocolMinorVersion();
     }
-    
-    /**
-     * {@inheritDoc}
-     */
+
     @Override
-    public final T onCompleted() throws Exception {
-        if (status != null) {
-            Document document = null;
-            if (status.getStatusCode() == 207) {
-                document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
-            }
-            // recompute response as readXMLResponse->parse might have updated it
-            return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
-        } else {
-            throw new IllegalStateException("Status is null");
-        }
+    public String getProtocolText() {
+      return wrapped.getStatusText();
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public void onThrowable(Throwable t) {
-        logger.debug(t.getMessage(), t);
+    public SocketAddress getRemoteAddress() {
+      return wrapped.getRemoteAddress();
     }
 
-    /**
-     * Invoked once the HTTP response has been fully read.
-     *
-     * @param response The {@link org.asynchttpclient.Response}
-     * @return Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-     * @throws Exception if something wrong happens
-     */
-    abstract public T onCompleted(WebDavResponse response) throws Exception;
-
-    private class HttpStatusWrapper extends HttpResponseStatus {
-
-        private final HttpResponseStatus wrapped;
-
-        private final String statusText;
-
-        private final int statusCode;
-
-        public HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int statusCode) {
-            super(wrapper.getUri());
-            this.wrapped = wrapper;
-            this.statusText = statusText;
-            this.statusCode = statusCode;
-        }
-
-        @Override
-        public int getStatusCode() {
-            return (statusText == null ? wrapped.getStatusCode() : statusCode);
-        }
-
-        @Override
-        public String getStatusText() {
-            return (statusText == null ? wrapped.getStatusText() : statusText);
-        }
-
-        @Override
-        public String getProtocolName() {
-            return wrapped.getProtocolName();
-        }
-
-        @Override
-        public int getProtocolMajorVersion() {
-            return wrapped.getProtocolMajorVersion();
-        }
-
-        @Override
-        public int getProtocolMinorVersion() {
-            return wrapped.getProtocolMinorVersion();
-        }
-
-        @Override
-        public String getProtocolText() {
-            return wrapped.getStatusText();
-        }
-
-        @Override
-        public SocketAddress getRemoteAddress() {
-            return wrapped.getRemoteAddress();
-        }
-        
-        @Override
-        public SocketAddress getLocalAddress() {
-            return wrapped.getLocalAddress();
-        }
+    @Override
+    public SocketAddress getLocalAddress() {
+      return wrapped.getLocalAddress();
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
index 78f26ac70..b5c4e23ec 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
@@ -14,6 +14,9 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.w3c.dom.Document;
 
 import java.io.InputStream;
 import java.net.SocketAddress;
@@ -21,101 +24,97 @@
 import java.nio.charset.Charset;
 import java.util.List;
 
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
-import org.w3c.dom.Document;
-
 /**
  * Customized {@link Response} which add support for getting the response's body as an XML document (@link WebDavResponse#getBodyAsXML}
  */
 public class WebDavResponse implements Response {
 
-    private final Response response;
-    private final Document document;
+  private final Response response;
+  private final Document document;
 
-    public WebDavResponse(Response response, Document document) {
-        this.response = response;
-        this.document = document;
-    }
+  WebDavResponse(Response response, Document document) {
+    this.response = response;
+    this.document = document;
+  }
 
-    public int getStatusCode() {
-        return response.getStatusCode();
-    }
+  public int getStatusCode() {
+    return response.getStatusCode();
+  }
 
-    public String getStatusText() {
-        return response.getStatusText();
-    }
+  public String getStatusText() {
+    return response.getStatusText();
+  }
 
-    @Override
-    public byte[] getResponseBodyAsBytes() {
-        return response.getResponseBodyAsBytes();
-    }
+  @Override
+  public byte[] getResponseBodyAsBytes() {
+    return response.getResponseBodyAsBytes();
+  }
 
-    public ByteBuffer getResponseBodyAsByteBuffer() {
-        return response.getResponseBodyAsByteBuffer();
-    }
+  public ByteBuffer getResponseBodyAsByteBuffer() {
+    return response.getResponseBodyAsByteBuffer();
+  }
 
-    public InputStream getResponseBodyAsStream() {
-        return response.getResponseBodyAsStream();
-    }
+  public InputStream getResponseBodyAsStream() {
+    return response.getResponseBodyAsStream();
+  }
 
-    public String getResponseBody() {
-        return response.getResponseBody();
-    }
+  public String getResponseBody() {
+    return response.getResponseBody();
+  }
 
-    public String getResponseBody(Charset charset) {
-        return response.getResponseBody(charset);
-    }
+  public String getResponseBody(Charset charset) {
+    return response.getResponseBody(charset);
+  }
 
-    public Uri getUri() {
-        return response.getUri();
-    }
+  public Uri getUri() {
+    return response.getUri();
+  }
 
-    public String getContentType() {
-        return response.getContentType();
-    }
+  public String getContentType() {
+    return response.getContentType();
+  }
 
-    public String getHeader(CharSequence name) {
-        return response.getHeader(name);
-    }
+  public String getHeader(CharSequence name) {
+    return response.getHeader(name);
+  }
 
-    public List<String> getHeaders(CharSequence name) {
-        return response.getHeaders(name);
-    }
+  public List<String> getHeaders(CharSequence name) {
+    return response.getHeaders(name);
+  }
 
-    public HttpHeaders getHeaders() {
-        return response.getHeaders();
-    }
+  public HttpHeaders getHeaders() {
+    return response.getHeaders();
+  }
 
-    public boolean isRedirected() {
-        return response.isRedirected();
-    }
+  public boolean isRedirected() {
+    return response.isRedirected();
+  }
 
-    public List<Cookie> getCookies() {
-        return response.getCookies();
-    }
+  public List<Cookie> getCookies() {
+    return response.getCookies();
+  }
 
-    public boolean hasResponseStatus() {
-        return response.hasResponseStatus();
-    }
+  public boolean hasResponseStatus() {
+    return response.hasResponseStatus();
+  }
 
-    public boolean hasResponseHeaders() {
-        return response.hasResponseHeaders();
-    }
+  public boolean hasResponseHeaders() {
+    return response.hasResponseHeaders();
+  }
 
-    public boolean hasResponseBody() {
-        return response.hasResponseBody();
-    }
+  public boolean hasResponseBody() {
+    return response.hasResponseBody();
+  }
 
-    public SocketAddress getRemoteAddress() {
-        return response.getRemoteAddress();
-    }
+  public SocketAddress getRemoteAddress() {
+    return response.getRemoteAddress();
+  }
 
-    public SocketAddress getLocalAddress() {
-        return response.getLocalAddress();
-    }
+  public SocketAddress getLocalAddress() {
+    return response.getLocalAddress();
+  }
 
-    public Document getBodyAsXML() {
-        return document;
-    }
+  public Document getBodyAsXML() {
+    return document;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocket.java b/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
index e5dd664e4..7b64468ba 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
@@ -13,202 +13,202 @@
  */
 package org.asynchttpclient.ws;
 
-import java.net.SocketAddress;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.util.concurrent.Future;
 
+import java.net.SocketAddress;
+
 /**
  * A WebSocket client
  */
 public interface WebSocket {
 
-    /**
-     * @return the headers received in the Upgrade response
-     */
-    HttpHeaders getUpgradeHeaders();
-
-    /**
-     * Get remote address client initiated request to.
-     * 
-     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
-     */
-    SocketAddress getRemoteAddress();
-
-    /**
-     * Get local address client initiated request from.
-     * 
-     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
-     */
-    SocketAddress getLocalAddress();
-
-    /**
-     * Send a full text frame
-     * 
-     * @param payload a text payload
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendTextFrame(String payload);
-
-    /**
-     * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-     * 
-     * @param payload a text fragment.
-     * @param finalFragment flag indicating whether or not this is the final fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv);
-
-    /**
-     * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-     * 
-     * @param payload a ByteBuf fragment.
-     * @param finalFragment flag indicating whether or not this is the final fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-    /**
-     * Send a full binary frame.
-     * 
-     * @param payload a binary payload
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendBinaryFrame(byte[] payload);
-
-    /**
-     * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-     * 
-     * @param payload a binary payload
-     * @param finalFragment flag indicating whether or not this is the last fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv);
-
-    /**
-     * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-     * 
-     * @param payload a ByteBuf payload
-     * @param finalFragment flag indicating whether or not this is the last fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-    /**
-     * Send a text continuation frame. The last fragment must have finalFragment set to true.
-     * 
-     * @param payload the text fragment
-     * @param finalFragment flag indicating whether or not this is the last fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv);
-
-    /**
-     * Send a binary continuation frame. The last fragment must have finalFragment set to true.
-     * 
-     * @param payload the binary fragment
-     * @param finalFragment flag indicating whether or not this is the last fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv);
-
-    /**
-     * Send a continuation frame (those are actually untyped as counterpart must have memorized first fragmented frame type). The last fragment must have finalFragment set to true.
-     * 
-     * @param payload a ByteBuf fragment
-     * @param finalFragment flag indicating whether or not this is the last fragment
-     * @param rsv extension bits, 0 otherwise
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-    /**
-     * Send a empty ping frame
-     * 
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPingFrame();
-
-    /**
-     * Send a ping frame with a byte array payload (limited to 125 bytes or less).
-     * 
-     * @param payload the payload.
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPingFrame(byte[] payload);
-
-    /**
-     * Send a ping frame with a ByteBuf payload (limited to 125 bytes or less).
-     * 
-     * @param payload the payload.
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPingFrame(ByteBuf payload);
-
-    /**
-     * Send a empty pong frame
-     * 
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPongFrame();
-
-    /**
-     * Send a pong frame with a byte array payload (limited to 125 bytes or less).
-     * 
-     * @param payload the payload.
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPongFrame(byte[] payload);
-
-    /**
-     * Send a pong frame with a ByteBuf payload (limited to 125 bytes or less).
-     * 
-     * @param payload the payload.
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendPongFrame(ByteBuf payload);
-
-    /**
-     * Send a empty close frame.
-     *
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendCloseFrame();
-
-    /**
-     * Send a empty close frame.
-     *
-     * @param statusCode a status code
-     * @param reasonText a reason
-     * @return a future that will be completed once the frame will be actually written on the wire
-     */
-    Future<Void> sendCloseFrame(int statusCode, String reasonText);
-
-    /**
-     * @return <code>true</code> if the WebSocket is open/connected.
-     */
-    boolean isOpen();
-
-    /**
-     * Add a {@link WebSocketListener}
-     * 
-     * @param l a {@link WebSocketListener}
-     * @return this
-     */
-    WebSocket addWebSocketListener(WebSocketListener l);
-
-    /**
-     * Remove a {@link WebSocketListener}
-     * 
-     * @param l a {@link WebSocketListener}
-     * @return this
-     */
-    WebSocket removeWebSocketListener(WebSocketListener l);
+  /**
+   * @return the headers received in the Upgrade response
+   */
+  HttpHeaders getUpgradeHeaders();
+
+  /**
+   * Get remote address client initiated request to.
+   *
+   * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
+   */
+  SocketAddress getRemoteAddress();
+
+  /**
+   * Get local address client initiated request from.
+   *
+   * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
+   */
+  SocketAddress getLocalAddress();
+
+  /**
+   * Send a full text frame
+   *
+   * @param payload a text payload
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendTextFrame(String payload);
+
+  /**
+   * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+   *
+   * @param payload       a text fragment.
+   * @param finalFragment flag indicating whether or not this is the final fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv);
+
+  /**
+   * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+   *
+   * @param payload       a ByteBuf fragment.
+   * @param finalFragment flag indicating whether or not this is the final fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+  /**
+   * Send a full binary frame.
+   *
+   * @param payload a binary payload
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendBinaryFrame(byte[] payload);
+
+  /**
+   * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+   *
+   * @param payload       a binary payload
+   * @param finalFragment flag indicating whether or not this is the last fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv);
+
+  /**
+   * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+   *
+   * @param payload       a ByteBuf payload
+   * @param finalFragment flag indicating whether or not this is the last fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+  /**
+   * Send a text continuation frame. The last fragment must have finalFragment set to true.
+   *
+   * @param payload       the text fragment
+   * @param finalFragment flag indicating whether or not this is the last fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv);
+
+  /**
+   * Send a binary continuation frame. The last fragment must have finalFragment set to true.
+   *
+   * @param payload       the binary fragment
+   * @param finalFragment flag indicating whether or not this is the last fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv);
+
+  /**
+   * Send a continuation frame (those are actually untyped as counterpart must have memorized first fragmented frame type). The last fragment must have finalFragment set to true.
+   *
+   * @param payload       a ByteBuf fragment
+   * @param finalFragment flag indicating whether or not this is the last fragment
+   * @param rsv           extension bits, 0 otherwise
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+  /**
+   * Send a empty ping frame
+   *
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPingFrame();
+
+  /**
+   * Send a ping frame with a byte array payload (limited to 125 bytes or less).
+   *
+   * @param payload the payload.
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPingFrame(byte[] payload);
+
+  /**
+   * Send a ping frame with a ByteBuf payload (limited to 125 bytes or less).
+   *
+   * @param payload the payload.
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPingFrame(ByteBuf payload);
+
+  /**
+   * Send a empty pong frame
+   *
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPongFrame();
+
+  /**
+   * Send a pong frame with a byte array payload (limited to 125 bytes or less).
+   *
+   * @param payload the payload.
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPongFrame(byte[] payload);
+
+  /**
+   * Send a pong frame with a ByteBuf payload (limited to 125 bytes or less).
+   *
+   * @param payload the payload.
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendPongFrame(ByteBuf payload);
+
+  /**
+   * Send a empty close frame.
+   *
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendCloseFrame();
+
+  /**
+   * Send a empty close frame.
+   *
+   * @param statusCode a status code
+   * @param reasonText a reason
+   * @return a future that will be completed once the frame will be actually written on the wire
+   */
+  Future<Void> sendCloseFrame(int statusCode, String reasonText);
+
+  /**
+   * @return <code>true</code> if the WebSocket is open/connected.
+   */
+  boolean isOpen();
+
+  /**
+   * Add a {@link WebSocketListener}
+   *
+   * @param l a {@link WebSocketListener}
+   * @return this
+   */
+  WebSocket addWebSocketListener(WebSocketListener l);
+
+  /**
+   * Remove a {@link WebSocketListener}
+   *
+   * @param l a {@link WebSocketListener}
+   * @return this
+   */
+  WebSocket removeWebSocketListener(WebSocketListener l);
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
index 6902ef8d9..3b37e74c5 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
@@ -17,64 +17,63 @@
  */
 public interface WebSocketListener {
 
-    /**
-     * Invoked when the {@link WebSocket} is open.
-     *
-     * @param websocket the WebSocket
-     */
-    void onOpen(WebSocket websocket);
+  /**
+   * Invoked when the {@link WebSocket} is open.
+   *
+   * @param websocket the WebSocket
+   */
+  void onOpen(WebSocket websocket);
 
-    /**
-     * Invoked when the {@link WebSocket} is closed.
-     * 
-     * @see "http://tools.ietf.org/html/rfc6455#section-5.5.1"
-     *
-     * @param websocket the WebSocket
-     * @param code the status code
-     * @param reason the reason message
-     */
-    void onClose(WebSocket websocket, int code, String reason);
+  /**
+   * Invoked when the {@link WebSocket} is closed.
+   *
+   * @param websocket the WebSocket
+   * @param code      the status code
+   * @param reason    the reason message
+   * @see "http://tools.ietf.org/html/rfc6455#section-5.5.1"
+   */
+  void onClose(WebSocket websocket, int code, String reason);
 
-    /**
-     * Invoked when the {@link WebSocket} crashes.
-     *
-     * @param t a {@link Throwable}
-     */
-    void onError(Throwable t);
+  /**
+   * Invoked when the {@link WebSocket} crashes.
+   *
+   * @param t a {@link Throwable}
+   */
+  void onError(Throwable t);
 
-    /**
-     * Invoked when a binary frame is received.
-     * 
-     * @param payload a byte array
-     * @param finalFragment true if this frame is the final fragment
-     * @param rsv extension bits
-     */
-    default void onBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
-    };
+  /**
+   * Invoked when a binary frame is received.
+   *
+   * @param payload       a byte array
+   * @param finalFragment true if this frame is the final fragment
+   * @param rsv           extension bits
+   */
+  default void onBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
+  }
 
-    /**
-     * Invoked when a text frame is received.
-     * 
-     * @param payload a UTF-8 {@link String} message
-     * @param finalFragment true if this frame is the final fragment
-     * @param rsv extension bits
-     */
-    default void onTextFrame(String payload, boolean finalFragment, int rsv) {
-    };
+  /**
+   * Invoked when a text frame is received.
+   *
+   * @param payload       a UTF-8 {@link String} message
+   * @param finalFragment true if this frame is the final fragment
+   * @param rsv           extension bits
+   */
+  default void onTextFrame(String payload, boolean finalFragment, int rsv) {
+  }
 
-    /**
-     * Invoked when a ping frame is received
-     * 
-     * @param payload a byte array
-     */
-    default void onPingFrame(byte[] payload) {
-    };
+  /**
+   * Invoked when a ping frame is received
+   *
+   * @param payload a byte array
+   */
+  default void onPingFrame(byte[] payload) {
+  }
 
-    /**
-     * Invoked when a pong frame is received
-     * 
-     * @param payload a byte array
-     */
-    default void onPongFrame(byte[] payload) {
-    };
+  /**
+   * Invoked when a pong frame is received
+   *
+   * @param payload a byte array
+   */
+  default void onPongFrame(byte[] payload) {
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
index f6f1a3979..a4624d633 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
@@ -14,122 +14,134 @@
 package org.asynchttpclient.ws;
 
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.netty.ws.NettyWebSocket;
 
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.SWITCHING_PROTOCOLS_101;
+
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * An {@link AsyncHandler} which is able to execute WebSocket upgrade. Use the Builder for configuring WebSocket options.
  */
 public class WebSocketUpgradeHandler implements AsyncHandler<NettyWebSocket> {
 
-    private static final int SWITCHING_PROTOCOLS = io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS.code();
-
-    private NettyWebSocket webSocket;
-    private final List<WebSocketListener> listeners;
-
-    public WebSocketUpgradeHandler(List<WebSocketListener> listeners) {
-        this.listeners = listeners;
+  private final List<WebSocketListener> listeners;
+  private NettyWebSocket webSocket;
+
+  public WebSocketUpgradeHandler(List<WebSocketListener> listeners) {
+    this.listeners = listeners;
+  }
+
+  protected void setWebSocket0(NettyWebSocket webSocket) {
+  }
+
+  protected void onStatusReceived0(HttpResponseStatus responseStatus) throws Exception {
+  }
+
+  protected void onHeadersReceived0(HttpHeaders headers) throws Exception {
+  }
+
+  protected void onBodyPartReceived0(HttpResponseBodyPart bodyPart) throws Exception {
+  }
+
+  protected void onCompleted0() throws Exception {
+  }
+
+  protected void onThrowable0(Throwable t) {
+  }
+
+  protected void onOpen0() {
+  }
+
+  @Override
+  public final State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+    onStatusReceived0(responseStatus);
+    return responseStatus.getStatusCode() == SWITCHING_PROTOCOLS_101 ? State.CONTINUE : State.ABORT;
+  }
+
+  @Override
+  public final State onHeadersReceived(HttpHeaders headers) throws Exception {
+    onHeadersReceived0(headers);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public final State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    onBodyPartReceived0(bodyPart);
+    return State.CONTINUE;
+  }
+
+  @Override
+  public final NettyWebSocket onCompleted() throws Exception {
+    onCompleted0();
+    return webSocket;
+  }
+
+  @Override
+  public final void onThrowable(Throwable t) {
+    onThrowable0(t);
+    for (WebSocketListener listener : listeners) {
+      if (webSocket != null) {
+        webSocket.addWebSocketListener(listener);
+      }
+      listener.onError(t);
     }
-    
-    protected void setWebSocket0(NettyWebSocket webSocket) {}
-    protected void onStatusReceived0(HttpResponseStatus responseStatus) throws Exception {}
-    protected void onHeadersReceived0(HttpHeaders headers) throws Exception {}
-    protected void onBodyPartReceived0(HttpResponseBodyPart bodyPart) throws Exception {}
-    protected void onCompleted0() throws Exception {}
-    protected void onThrowable0(Throwable t) {}
-    protected void onOpen0() {}
-
-    @Override
-    public final State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-    	onStatusReceived0(responseStatus);
-        return responseStatus.getStatusCode() == SWITCHING_PROTOCOLS ? State.CONTINUE : State.ABORT;
+  }
+
+  public final void setWebSocket(NettyWebSocket webSocket) {
+    this.webSocket = webSocket;
+    setWebSocket0(webSocket);
+  }
+
+  public final void onOpen() {
+    onOpen0();
+    for (WebSocketListener listener : listeners) {
+      webSocket.addWebSocketListener(listener);
+      listener.onOpen(webSocket);
     }
+    webSocket.processBufferedFrames();
+  }
 
-    @Override
-    public final State onHeadersReceived(HttpHeaders headers) throws Exception {
-    	onHeadersReceived0(headers);
-        return State.CONTINUE;
-    }
+  /**
+   * Build a {@link WebSocketUpgradeHandler}
+   */
+  public final static class Builder {
 
-    @Override
-    public final State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-    	onBodyPartReceived0(bodyPart);
-        return State.CONTINUE;
-    }
+    private List<WebSocketListener> listeners = new ArrayList<>(1);
 
-    @Override
-    public final NettyWebSocket onCompleted() throws Exception {
-    	onCompleted0();
-        return webSocket;
-    }
-
-    @Override
-    public final void onThrowable(Throwable t) {
-    	onThrowable0(t);
-        for (WebSocketListener listener : listeners) {
-            if (webSocket != null) {
-                webSocket.addWebSocketListener(listener);
-            }
-            listener.onError(t);
-        }
+    /**
+     * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
+     *
+     * @param listener a {@link WebSocketListener}
+     * @return this
+     */
+    public Builder addWebSocketListener(WebSocketListener listener) {
+      listeners.add(listener);
+      return this;
     }
 
-    public final void setWebSocket(NettyWebSocket webSocket) {
-        this.webSocket = webSocket;
-        setWebSocket0(webSocket);
-    }
-    
-    public final void onOpen() {
-    	onOpen0();
-        for (WebSocketListener listener : listeners) {
-            webSocket.addWebSocketListener(listener);
-            listener.onOpen(webSocket);
-        }
-        webSocket.processBufferedFrames();
+    /**
+     * Remove a {@link WebSocketListener}
+     *
+     * @param listener a {@link WebSocketListener}
+     * @return this
+     */
+    public Builder removeWebSocketListener(WebSocketListener listener) {
+      listeners.remove(listener);
+      return this;
     }
 
     /**
      * Build a {@link WebSocketUpgradeHandler}
+     *
+     * @return a {@link WebSocketUpgradeHandler}
      */
-    public final static class Builder {
-
-        private List<WebSocketListener> listeners = new ArrayList<>(1);
-
-        /**
-         * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
-         *
-         * @param listener a {@link WebSocketListener}
-         * @return this
-         */
-        public Builder addWebSocketListener(WebSocketListener listener) {
-            listeners.add(listener);
-            return this;
-        }
-
-        /**
-         * Remove a {@link WebSocketListener}
-         *
-         * @param listener a {@link WebSocketListener}
-         * @return this
-         */
-        public Builder removeWebSocketListener(WebSocketListener listener) {
-            listeners.remove(listener);
-            return this;
-        }
-
-        /**
-         * Build a {@link WebSocketUpgradeHandler}
-         *
-         * @return a {@link WebSocketUpgradeHandler}
-         */
-        public WebSocketUpgradeHandler build() {
-            return new WebSocketUpgradeHandler(listeners);
-        }
+    public WebSocketUpgradeHandler build() {
+      return new WebSocketUpgradeHandler(listeners);
     }
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index 0a6438660..31bd8f5c2 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -13,26 +13,27 @@
  */
 package org.asynchttpclient.ws;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledSha1MessageDigest;
+import io.netty.util.internal.ThreadLocalRandom;
 
-import org.asynchttpclient.util.Base64;
+import java.util.Base64;
 
-import io.netty.util.internal.ThreadLocalRandom;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.MessageDigestUtils.pooledSha1MessageDigest;
 
 public final class WebSocketUtils {
-	public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+  private static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
-	public static String getWebSocketKey() {
-		byte[] nonce = new byte[16];
-		ThreadLocalRandom random = ThreadLocalRandom.current();
-		for (int i = 0; i < nonce.length; i++) {
-			nonce[i] = (byte) random.nextInt(256);
-		}
-		return Base64.encode(nonce);
-	}
+  public static String getWebSocketKey() {
+    byte[] nonce = new byte[16];
+    ThreadLocalRandom random = ThreadLocalRandom.current();
+    for (int i = 0; i < nonce.length; i++) {
+      nonce[i] = (byte) random.nextInt(256);
+    }
+    return Base64.getEncoder().encodeToString(nonce);
+  }
 
-	public static String getAcceptKey(String key) {
-		return Base64.encode(pooledSha1MessageDigest().digest((key + MAGIC_GUID).getBytes(US_ASCII)));
-	}
+  public static String getAcceptKey(String key) {
+    return Base64.getEncoder().encodeToString(pooledSha1MessageDigest().digest(
+              (key + MAGIC_GUID).getBytes(US_ASCII)));
+  }
 }
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/org/asynchttpclient/config/ahc-default.properties
similarity index 95%
rename from client/src/main/resources/ahc-default.properties
rename to client/src/main/resources/org/asynchttpclient/config/ahc-default.properties
index 1a9505e3a..c6fb355d7 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/org/asynchttpclient/config/ahc-default.properties
@@ -1,6 +1,7 @@
 org.asynchttpclient.threadPoolName=AsyncHttpClient
 org.asynchttpclient.maxConnections=-1
 org.asynchttpclient.maxConnectionsPerHost=-1
+org.asynchttpclient.acquireFreeChannelTimeout=0
 org.asynchttpclient.connectTimeout=5000
 org.asynchttpclient.pooledConnectionIdleTimeout=60000
 org.asynchttpclient.connectionPoolCleanerPeriod=1000
@@ -13,6 +14,7 @@ org.asynchttpclient.compressionEnforced=false
 org.asynchttpclient.userAgent=AHC/2.1
 org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
 org.asynchttpclient.enabledCipherSuites=
+org.asynchttpclient.filterInsecureCipherSuites=true
 org.asynchttpclient.useProxySelector=false
 org.asynchttpclient.useProxyProperties=false
 org.asynchttpclient.validateResponseHeaders=true
diff --git a/client/src/main/resources/ahc-version.properties b/client/src/main/resources/org/asynchttpclient/config/ahc-version.properties
similarity index 100%
rename from client/src/main/resources/ahc-version.properties
rename to client/src/main/resources/org/asynchttpclient/config/ahc-version.properties
diff --git a/client/src/main/resources/ahc-mime.types b/client/src/main/resources/org/asynchttpclient/request/body/multipart/ahc-mime.types
similarity index 100%
rename from client/src/main/resources/ahc-mime.types
rename to client/src/main/resources/org/asynchttpclient/request/body/multipart/ahc-mime.types
diff --git a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
index 916b1f357..94b5c6d53 100644
--- a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
@@ -15,10 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.fail;
-import io.netty.handler.codec.http.HttpHeaders;
-
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -28,88 +24,61 @@
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+
 public abstract class AbstractBasicTest {
 
-    protected final static int TIMEOUT = 30;
+  protected final static int TIMEOUT = 30;
 
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
+  protected final Logger logger = LoggerFactory.getLogger(getClass());
 
-    protected Server server;
-    protected int port1 = -1;
-    protected int port2  =-1;
+  protected Server server;
+  protected int port1 = -1;
+  protected int port2 = -1;
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        server.setHandler(configureHandler());
-        ServerConnector connector2 = addHttpConnector(server);
-        server.start();
-        
-        port1 = connector1.getLocalPort();
-        port2 = connector2.getLocalPort();
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    server.setHandler(configureHandler());
+    ServerConnector connector2 = addHttpConnector(server);
+    server.start();
 
-        logger.info("Local HTTP server started successfully");
-    }
+    port1 = connector1.getLocalPort();
+    port2 = connector2.getLocalPort();
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        if (server != null) {
-            server.stop();
-        }
-    }
+    logger.info("Local HTTP server started successfully");
+  }
 
-    protected String getTargetUrl() {
-        return String.format("http://localhost:%d/foo/test", port1);
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    if (server != null) {
+      server.stop();
     }
+  }
 
-    protected String getTargetUrl2() {
-        return String.format("https://localhost:%d/foo/test", port2);
-    }
+  protected String getTargetUrl() {
+    return String.format("http://localhost:%d/foo/test", port1);
+  }
 
-    public AbstractHandler configureHandler() throws Exception {
-        return new EchoHandler();
-    }
+  protected String getTargetUrl2() {
+    return String.format("https://localhost:%d/foo/test", port2);
+  }
 
-    public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+  public AbstractHandler configureHandler() throws Exception {
+    return new EchoHandler();
+  }
 
-        @Override
-        public Response onCompleted(Response response) throws Exception {
-            return response;
-        }
+  public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
 
-        @Override
-        public void onThrowable(Throwable t) {
-            t.printStackTrace();
-        }
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+      return response;
     }
 
-    public static class AsyncHandlerAdapter implements AsyncHandler<String> {
-
-        @Override
-        public void onThrowable(Throwable t) {
-            t.printStackTrace();
-            fail("Unexpected exception", t);
-        }
-
-        @Override
-        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-            return State.CONTINUE;
-        }
-
-        @Override
-        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-            return State.CONTINUE;
-        }
-
-        @Override
-        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-            return State.CONTINUE;
-        }
-
-        @Override
-        public String onCompleted() throws Exception {
-            return "";
-        }
+    @Override
+    public void onThrowable(Throwable t) {
+      t.printStackTrace();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index 6aabb0ce1..bbbb512a5 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -13,8 +13,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
-
 import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.testng.Assert;
@@ -22,144 +20,146 @@
 
 import java.lang.reflect.Method;
 
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
+
 @Test
 public class AsyncHttpClientDefaultsTest {
 
-    public void testDefaultMaxTotalConnections() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(), -1);
-        testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
-    }
-
-    public void testDefaultMaxConnectionPerHost() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnectionsPerHost(), -1);
-        testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
-    }
-
-    public void testDefaultConnectTimeOut() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectTimeout(), 5 * 1000);
-        testIntegerSystemProperty("connectTimeout", "defaultConnectTimeout", "100");
-    }
-
-    public void testDefaultPooledConnectionIdleTimeout() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
-        testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
-    }
-
-    public void testDefaultReadTimeout() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
-        testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
-    }
-
-    public void testDefaultRequestTimeout() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
-        testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
-    }
-
-    public void testDefaultConnectionTtl() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTtl(), -1);
-        testIntegerSystemProperty("connectionTtl", "defaultConnectionTtl", "100");
-    }
-
-    public void testDefaultFollowRedirect() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultFollowRedirect());
-        testBooleanSystemProperty("followRedirect", "defaultFollowRedirect", "true");
-    }
-
-    public void testDefaultMaxRedirects() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRedirects(), 5);
-        testIntegerSystemProperty("maxRedirects", "defaultMaxRedirects", "100");
-    }
-
-    public void testDefaultCompressionEnforced() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultCompressionEnforced());
-        testBooleanSystemProperty("compressionEnforced", "defaultCompressionEnforced", "true");
-    }
-
-    public void testDefaultUserAgent() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.1");
-        testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
-    }
-
-    public void testDefaultUseProxySelector() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxySelector());
-        testBooleanSystemProperty("useProxySelector", "defaultUseProxySelector", "true");
-    }
-
-    public void testDefaultUseProxyProperties() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxyProperties());
-        testBooleanSystemProperty("useProxyProperties", "defaultUseProxyProperties", "true");
-    }
-
-    public void testDefaultStrict302Handling() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultStrict302Handling());
-        testBooleanSystemProperty("strict302Handling", "defaultStrict302Handling", "true");
-    }
-
-    public void testDefaultAllowPoolingConnection() {
-        Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultKeepAlive());
-        testBooleanSystemProperty("keepAlive", "defaultKeepAlive", "false");
-    }
-
-    public void testDefaultMaxRequestRetry() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
-        testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
-    }
-
-    public void testDefaultDisableUrlEncodingForBoundRequests() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultDisableUrlEncodingForBoundRequests());
-        testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
-    }
-
-    public void testDefaultUseInsecureTrustManager() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseInsecureTrustManager());
-        testBooleanSystemProperty("useInsecureTrustManager", "defaultUseInsecureTrustManager", "false");
-    }
-
-    private void testIntegerSystemProperty(String propertyName, String methodName, String value) {
-        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
-            Assert.assertEquals(method.invoke(null, new Object[] {}), Integer.parseInt(value));
-        } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName, e);
-        }
-        if (previous != null)
-            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-        else
-            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    }
-
-    private void testBooleanSystemProperty(String propertyName, String methodName, String value) {
-        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
-            Assert.assertEquals(method.invoke(null, new Object[] {}), Boolean.parseBoolean(value));
-        } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName, e);
-        }
-        if (previous != null)
-            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-        else
-            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    }
-
-    private void testStringSystemProperty(String propertyName, String methodName, String value) {
-        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
-            Assert.assertEquals(method.invoke(null, new Object[] {}), value);
-        } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName, e);
-        }
-        if (previous != null)
-            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-        else
-            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    }
+  public void testDefaultMaxTotalConnections() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(), -1);
+    testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
+  }
+
+  public void testDefaultMaxConnectionPerHost() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnectionsPerHost(), -1);
+    testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
+  }
+
+  public void testDefaultConnectTimeOut() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectTimeout(), 5 * 1000);
+    testIntegerSystemProperty("connectTimeout", "defaultConnectTimeout", "100");
+  }
+
+  public void testDefaultPooledConnectionIdleTimeout() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
+    testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
+  }
+
+  public void testDefaultReadTimeout() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
+    testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
+  }
+
+  public void testDefaultRequestTimeout() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
+    testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
+  }
+
+  public void testDefaultConnectionTtl() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTtl(), -1);
+    testIntegerSystemProperty("connectionTtl", "defaultConnectionTtl", "100");
+  }
+
+  public void testDefaultFollowRedirect() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultFollowRedirect());
+    testBooleanSystemProperty("followRedirect", "defaultFollowRedirect", "true");
+  }
+
+  public void testDefaultMaxRedirects() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRedirects(), 5);
+    testIntegerSystemProperty("maxRedirects", "defaultMaxRedirects", "100");
+  }
+
+  public void testDefaultCompressionEnforced() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultCompressionEnforced());
+    testBooleanSystemProperty("compressionEnforced", "defaultCompressionEnforced", "true");
+  }
+
+  public void testDefaultUserAgent() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.1");
+    testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
+  }
+
+  public void testDefaultUseProxySelector() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxySelector());
+    testBooleanSystemProperty("useProxySelector", "defaultUseProxySelector", "true");
+  }
+
+  public void testDefaultUseProxyProperties() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxyProperties());
+    testBooleanSystemProperty("useProxyProperties", "defaultUseProxyProperties", "true");
+  }
+
+  public void testDefaultStrict302Handling() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultStrict302Handling());
+    testBooleanSystemProperty("strict302Handling", "defaultStrict302Handling", "true");
+  }
+
+  public void testDefaultAllowPoolingConnection() {
+    Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultKeepAlive());
+    testBooleanSystemProperty("keepAlive", "defaultKeepAlive", "false");
+  }
+
+  public void testDefaultMaxRequestRetry() {
+    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
+    testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
+  }
+
+  public void testDefaultDisableUrlEncodingForBoundRequests() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultDisableUrlEncodingForBoundRequests());
+    testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
+  }
+
+  public void testDefaultUseInsecureTrustManager() {
+    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseInsecureTrustManager());
+    testBooleanSystemProperty("useInsecureTrustManager", "defaultUseInsecureTrustManager", "false");
+  }
+
+  private void testIntegerSystemProperty(String propertyName, String methodName, String value) {
+    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try {
+      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
+      Assert.assertEquals(method.invoke(null), Integer.parseInt(value));
+    } catch (Exception e) {
+      Assert.fail("Couldn't find or execute method : " + methodName, e);
+    }
+    if (previous != null)
+      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+    else
+      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+  }
+
+  private void testBooleanSystemProperty(String propertyName, String methodName, String value) {
+    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try {
+      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
+      Assert.assertEquals(method.invoke(null), Boolean.parseBoolean(value));
+    } catch (Exception e) {
+      Assert.fail("Couldn't find or execute method : " + methodName, e);
+    }
+    if (previous != null)
+      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+    else
+      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+  }
+
+  private void testStringSystemProperty(String propertyName, String methodName, String value) {
+    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try {
+      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
+      Assert.assertEquals(method.invoke(null), value);
+    } catch (Exception e) {
+      Assert.fail("Couldn't find or execute method : " + methodName, e);
+    }
+    if (previous != null)
+      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+    else
+      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index 110b5fe0e..1547872aa 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -15,478 +15,490 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.test.TestUtils.*;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.asynchttpclient.test.TestUtils.AsyncHandlerAdapter;
-import org.asynchttpclient.testserver.HttpServer;
-import org.asynchttpclient.testserver.HttpTest;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+import static org.testng.Assert.*;
 
 public class AsyncStreamHandlerTest extends HttpTest {
 
-    private static final String RESPONSE = "param_1_";
-
-    private static HttpServer server;
-
-    @BeforeClass
-    public static void start() throws Throwable {
-        server = new HttpServer();
-        server.start();
-    }
-
-    @AfterClass
-    public static void stop() throws Throwable {
-        server.close();
-    }
-
-    private static String getTargetUrl() {
-        return server.getHttpUrl() + "/foo/bar";
-    }
-
-    @Test
-    public void getWithOnHeadersReceivedAbort() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-                    @Override
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                        return State.ABORT;
-                    }
-                }).get(5, TimeUnit.SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void asyncStreamPOSTTest() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-
-                String responseBody = client.preparePost(getTargetUrl())//
-                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
-                        .addFormParam("param_1", "value_1")//
-                        .execute(new AsyncHandlerAdapter() {
-                            private StringBuilder builder = new StringBuilder();
-
-                            @Override
-                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                                return State.CONTINUE;
-                            }
-
-                            @Override
-                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                                builder.append(new String(content.getBodyPartBytes(), US_ASCII));
-                                return State.CONTINUE;
-                            }
-
-                            @Override
-                            public String onCompleted() throws Exception {
-                                return builder.toString().trim();
-                            }
-                        }).get(10, TimeUnit.SECONDS);
-
-                assertEquals(responseBody, RESPONSE);
-            });
-        });
-    }
-
-    @Test
-    public void asyncStreamInterruptTest() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-
-                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
-                final AtomicBoolean onBodyPartReceived = new AtomicBoolean();
-                final AtomicBoolean onThrowable = new AtomicBoolean();
-
-                client.preparePost(getTargetUrl())//
-                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
-                        .addFormParam("param_1", "value_1")//
-                        .execute(new AsyncHandlerAdapter() {
-
-                            @Override
-                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                                onHeadersReceived.set(true);
-                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                                return State.ABORT;
-                            }
-
-                            @Override
-                            public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                                onBodyPartReceived.set(true);
-                                return State.ABORT;
-                            }
-
-                            @Override
-                            public void onThrowable(Throwable t) {
-                                onThrowable.set(true);
-                            }
-                        }).get(5, TimeUnit.SECONDS);
-
-                assertTrue(onHeadersReceived.get(), "Headers weren't received");
-                assertFalse(onBodyPartReceived.get(), "Abort not working");
-                assertFalse(onThrowable.get(), "Shouldn't get an exception");
-            });
-        });
-    }
-
-    @Test
-    public void asyncStreamFutureTest() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-
-                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
-                final AtomicBoolean onThrowable = new AtomicBoolean();
-
-                String responseBody = client.preparePost(getTargetUrl())//
-                        .addFormParam("param_1", "value_1")//
-                        .execute(new AsyncHandlerAdapter() {
-                            private StringBuilder builder = new StringBuilder();
-
-                            @Override
-                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                                onHeadersReceived.set(true);
-                                return State.CONTINUE;
-                            }
-
-                            @Override
-                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                                builder.append(new String(content.getBodyPartBytes()));
-                                return State.CONTINUE;
-                            }
-
-                            @Override
-                            public String onCompleted() throws Exception {
-                                return builder.toString().trim();
-                            }
-
-                            @Override
-                            public void onThrowable(Throwable t) {
-                                onThrowable.set(true);
-                            }
-                        }).get(5, TimeUnit.SECONDS);
-
-                assertTrue(onHeadersReceived.get(), "Headers weren't received");
-                assertFalse(onThrowable.get(), "Shouldn't get an exception");
-                assertEquals(responseBody, RESPONSE, "Unexpected response body");
-            });
-        });
-    }
-
-    @Test
-    public void asyncStreamThrowableRefusedTest() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-
-                final CountDownLatch l = new CountDownLatch(1);
-                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-                    @Override
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        throw unknownStackTrace(new RuntimeException("FOO"), AsyncStreamHandlerTest.class, "asyncStreamThrowableRefusedTest");
+  private static final String RESPONSE = "param_1=value_1";
+
+  private static HttpServer server;
+
+  @BeforeClass
+  public static void start() throws Throwable {
+    server = new HttpServer();
+    server.start();
+  }
+
+  @AfterClass
+  public static void stop() throws Throwable {
+    server.close();
+  }
+
+  private static String getTargetUrl() {
+    return server.getHttpUrl() + "/foo/bar";
+  }
+
+  @Test
+  public void getWithOnHeadersReceivedAbort() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            return State.ABORT;
+          }
+        }).get(5, TimeUnit.SECONDS);
+      }));
+  }
+
+  @Test
+  public void asyncStreamPOSTTest() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        server.enqueueEcho();
+
+        String responseBody = client.preparePost(getTargetUrl())
+                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
+                .addFormParam("param_1", "value_1")
+                .execute(new AsyncHandlerAdapter() {
+                  private StringBuilder builder = new StringBuilder();
+
+                  @Override
+                  public State onHeadersReceived(HttpHeaders headers) {
+                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    for (Map.Entry<String, String> header : headers) {
+                      if (header.getKey().startsWith("X-param")) {
+                        builder.append(header.getKey().substring(2)).append("=").append(header.getValue()).append("&");
+                      }
                     }
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        try {
-                            if (t.getMessage() != null) {
-                                assertEquals(t.getMessage(), "FOO");
-                            }
-                        } finally {
-                            l.countDown();
-                        }
+                    return State.CONTINUE;
+                  }
+
+                  @Override
+                  public State onBodyPartReceived(HttpResponseBodyPart content) {
+                    return State.CONTINUE;
+                  }
+
+                  @Override
+                  public String onCompleted() {
+                    if (builder.length() > 0) {
+                      builder.setLength(builder.length() - 1);
                     }
-                });
-
-                if (!l.await(10, TimeUnit.SECONDS)) {
-                    fail("Timed out");
-                }
-            });
-        });
-    }
+                    return builder.toString();
+                  }
+                }).get(10, TimeUnit.SECONDS);
+
+        assertEquals(responseBody, RESPONSE);
+      }));
+  }
+
+  @Test
+  public void asyncStreamInterruptTest() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        server.enqueueEcho();
+
+        final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+        final AtomicBoolean onBodyPartReceived = new AtomicBoolean();
+        final AtomicBoolean onThrowable = new AtomicBoolean();
+
+        client.preparePost(getTargetUrl())
+                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
+                .addFormParam("param_1", "value_1")
+                .execute(new AsyncHandlerAdapter() {
+
+                  @Override
+                  public State onHeadersReceived(HttpHeaders headers) {
+                    onHeadersReceived.set(true);
+                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    return State.ABORT;
+                  }
+
+                  @Override
+                  public State onBodyPartReceived(final HttpResponseBodyPart content) {
+                    onBodyPartReceived.set(true);
+                    return State.ABORT;
+                  }
+
+                  @Override
+                  public void onThrowable(Throwable t) {
+                    onThrowable.set(true);
+                  }
+                }).get(5, TimeUnit.SECONDS);
 
-    @Test
-    public void asyncStreamReusePOSTTest() throws Throwable {
+        assertTrue(onHeadersReceived.get(), "Headers weren't received");
+        assertFalse(onBodyPartReceived.get(), "Abort not working");
+        assertFalse(onThrowable.get(), "Shouldn't get an exception");
+      }));
+  }
 
-        withClient().run(client -> {
-            withServer(server).run(server -> {
+  @Test
+  public void asyncStreamFutureTest() throws Throwable {
 
-                server.enqueueEcho();
+    withClient().run(client ->
+      withServer(server).run(server -> {
 
-                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+        server.enqueueEcho();
 
-                BoundRequestBuilder rb = client.preparePost(getTargetUrl())//
-                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
-                        .addFormParam("param_1", "value_1");
+        final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+        final AtomicBoolean onThrowable = new AtomicBoolean();
 
-                Future<String> f = rb.execute(new AsyncHandlerAdapter() {
-                    private StringBuilder builder = new StringBuilder();
+        String responseBody = client.preparePost(getTargetUrl())
+                .addFormParam("param_1", "value_1")
+                .execute(new AsyncHandlerAdapter() {
+                  private StringBuilder builder = new StringBuilder();
 
-                    @Override
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        responseHeaders.set(headers);
-                        return State.CONTINUE;
+                  @Override
+                  public State onHeadersReceived(HttpHeaders headers) {
+                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    onHeadersReceived.set(true);
+                    for (Map.Entry<String, String> header : headers) {
+                      if (header.getKey().startsWith("X-param")) {
+                        builder.append(header.getKey().substring(2)).append("=").append(header.getValue()).append("&");
+                      }
                     }
-
-                    @Override
-                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                        builder.append(new String(content.getBodyPartBytes()));
-                        return State.CONTINUE;
+                    return State.CONTINUE;
+                  }
+
+                  @Override
+                  public State onBodyPartReceived(HttpResponseBodyPart content) {
+                    return State.CONTINUE;
+                  }
+
+                  @Override
+                  public String onCompleted() {
+                    if (builder.length() > 0) {
+                      builder.setLength(builder.length() - 1);
                     }
+                    return builder.toString().trim();
+                  }
 
-                    @Override
-                    public String onCompleted() throws Exception {
-                        return builder.toString();
-                    }
-                });
-
-                String r = f.get(5, TimeUnit.SECONDS);
-                HttpHeaders h = responseHeaders.get();
-                assertNotNull(h, "Should receive non null headers");
-                assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                assertNotNull(r, "No response body");
-                assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-
-                responseHeaders.set(null);
-
-                server.enqueueEcho();
-
-                // Let do the same again
-                    f = rb.execute(new AsyncHandlerAdapter() {
-                        private StringBuilder builder = new StringBuilder();
-
-                        @Override
-                        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                            responseHeaders.set(headers);
-                            return State.CONTINUE;
-                        }
-
-                        @Override
-                        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                            builder.append(new String(content.getBodyPartBytes()));
-                            return State.CONTINUE;
-                        }
-
-                        @Override
-                        public String onCompleted() throws Exception {
-                            return builder.toString();
-                        }
-                    });
-
-                    f.get(5, TimeUnit.SECONDS);
-                    h = responseHeaders.get();
-                    assertNotNull(h, "Should receive non null headers");
-                    assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    assertNotNull(r, "No response body");
-                    assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-                });
-        });
-    }
-
-    @Test
-    public void asyncStream302RedirectWithBody() throws Throwable {
-
-        withClient(config().setFollowRedirect(true)).run(client -> {
-            withServer(server).run(server -> {
-
-                String originalUrl = server.getHttpUrl() + "/original";
-                String redirectUrl = server.getHttpUrl() + "/redirect";
-
-                server.enqueueResponse(response -> {
-                    response.setStatus(302);
-                    response.setHeader(LOCATION.toString(), redirectUrl);
-                    response.getOutputStream().println("You are being asked to redirect to " + redirectUrl);
-                });
-                server.enqueueOk();
-
-                Response response = client.prepareGet(originalUrl).execute().get(20, TimeUnit.SECONDS);
+                  @Override
+                  public void onThrowable(Throwable t) {
+                    onThrowable.set(true);
+                  }
+                }).get(5, TimeUnit.SECONDS);
 
-                assertEquals(response.getStatusCode(), 200);
-                assertTrue(response.getResponseBody().isEmpty());
-            });
+        assertTrue(onHeadersReceived.get(), "Headers weren't received");
+        assertFalse(onThrowable.get(), "Shouldn't get an exception");
+        assertEquals(responseBody, RESPONSE, "Unexpected response body");
+      }));
+  }
+
+  @Test
+  public void asyncStreamThrowableRefusedTest() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        server.enqueueEcho();
+
+        final CountDownLatch l = new CountDownLatch(1);
+        client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            throw unknownStackTrace(new RuntimeException("FOO"), AsyncStreamHandlerTest.class, "asyncStreamThrowableRefusedTest");
+          }
+
+          @Override
+          public void onThrowable(Throwable t) {
+            try {
+              if (t.getMessage() != null) {
+                assertEquals(t.getMessage(), "FOO");
+              }
+            } finally {
+              l.countDown();
+            }
+          }
         });
-    }
 
-    @Test(timeOut = 3000)
-    public void asyncStreamJustStatusLine() throws Throwable {
-
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                server.enqueueEcho();
-
-                final int STATUS = 0;
-                final int COMPLETED = 1;
-                final int OTHER = 2;
-                final boolean[] whatCalled = new boolean[] { false, false, false };
-                final CountDownLatch latch = new CountDownLatch(1);
-                Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
-                    private int status = -1;
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        whatCalled[OTHER] = true;
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                        whatCalled[OTHER] = true;
-                        latch.countDown();
-                        return State.ABORT;
-                    }
-
-                    @Override
-                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                        whatCalled[STATUS] = true;
-                        status = responseStatus.getStatusCode();
-                        latch.countDown();
-                        return State.ABORT;
-                    }
-
-                    @Override
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        whatCalled[OTHER] = true;
-                        latch.countDown();
-                        return State.ABORT;
-                    }
+        if (!l.await(10, TimeUnit.SECONDS)) {
+          fail("Timed out");
+        }
+      }));
+  }
+
+  @Test
+  public void asyncStreamReusePOSTTest() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        server.enqueueEcho();
+
+        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+
+        BoundRequestBuilder rb = client.preparePost(getTargetUrl())
+                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
+                .addFormParam("param_1", "value_1");
+
+        Future<String> f = rb.execute(new AsyncHandlerAdapter() {
+          private StringBuilder builder = new StringBuilder();
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            responseHeaders.set(headers);
+            for (Map.Entry<String, String> header : headers) {
+              if (header.getKey().startsWith("X-param")) {
+                builder.append(header.getKey().substring(2)).append("=").append(header.getValue()).append("&");
+              }
+            }
+            return State.CONTINUE;
+          }
+
+          @Override
+          public State onBodyPartReceived(HttpResponseBodyPart content) {
+            return State.CONTINUE;
+          }
+
+          @Override
+          public String onCompleted() {
+            if (builder.length() > 0) {
+              builder.setLength(builder.length() - 1);
+            }
+            return builder.toString();
+          }
+        });
 
-                    @Override
-                    public Integer onCompleted() throws Exception {
-                        whatCalled[COMPLETED] = true;
-                        latch.countDown();
-                        return status;
-                    }
-                });
-
-                if (!latch.await(2, TimeUnit.SECONDS)) {
-                    fail("Timeout");
-                    return;
-                }
-                Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-                assertEquals((int) status, 200, "Expected status code failed.");
-
-                if (!whatCalled[STATUS]) {
-                    fail("onStatusReceived not called.");
-                }
-                if (!whatCalled[COMPLETED]) {
-                    fail("onCompleted not called.");
-                }
-                if (whatCalled[OTHER]) {
-                    fail("Other method of AsyncHandler got called.");
-                }
-            });
+        String r = f.get(5, TimeUnit.SECONDS);
+        HttpHeaders h = responseHeaders.get();
+        assertNotNull(h, "Should receive non null headers");
+        assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+        assertNotNull(r, "No response body");
+        assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+
+        responseHeaders.set(null);
+
+        server.enqueueEcho();
+
+        // Let do the same again
+        f = rb.execute(new AsyncHandlerAdapter() {
+          private StringBuilder builder = new StringBuilder();
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            responseHeaders.set(headers);
+            return State.CONTINUE;
+          }
+
+          @Override
+          public State onBodyPartReceived(HttpResponseBodyPart content) {
+            builder.append(new String(content.getBodyPartBytes()));
+            return State.CONTINUE;
+          }
+
+          @Override
+          public String onCompleted() {
+            return builder.toString();
+          }
         });
-    }
 
-    @Test(groups = "online")
-    public void asyncOptionsTest() throws Throwable {
+        f.get(5, TimeUnit.SECONDS);
+        h = responseHeaders.get();
+        assertNotNull(h, "Should receive non null headers");
+        assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+        assertNotNull(r, "No response body");
+        assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+      }));
+  }
 
-        withClient().run(client -> {
-            withServer(server).run(server -> {
+  @Test
+  public void asyncStream302RedirectWithBody() throws Throwable {
 
-                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+    withClient(config().setFollowRedirect(true)).run(client ->
+      withServer(server).run(server -> {
 
-                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST" };
-                Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+        String originalUrl = server.getHttpUrl() + "/original";
+        String redirectUrl = server.getHttpUrl() + "/redirect";
 
-                    @Override
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        responseHeaders.set(headers);
-                        return State.ABORT;
-                    }
+        server.enqueueResponse(response -> {
+          response.setStatus(302);
+          response.setHeader(LOCATION.toString(), redirectUrl);
+          response.getOutputStream().println("You are being asked to redirect to " + redirectUrl);
+        });
+        server.enqueueOk();
+
+        Response response = client.prepareGet(originalUrl).execute().get(20, TimeUnit.SECONDS);
+
+        assertEquals(response.getStatusCode(), 200);
+        assertTrue(response.getResponseBody().isEmpty());
+      }));
+  }
+
+  @Test(timeOut = 3000)
+  public void asyncStreamJustStatusLine() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        server.enqueueEcho();
+
+        final int STATUS = 0;
+        final int COMPLETED = 1;
+        final int OTHER = 2;
+        final boolean[] whatCalled = new boolean[]{false, false, false};
+        final CountDownLatch latch = new CountDownLatch(1);
+        Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
+          private int status = -1;
+
+          @Override
+          public void onThrowable(Throwable t) {
+            whatCalled[OTHER] = true;
+            latch.countDown();
+          }
+
+          @Override
+          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
+            whatCalled[OTHER] = true;
+            latch.countDown();
+            return State.ABORT;
+          }
+
+          @Override
+          public State onStatusReceived(HttpResponseStatus responseStatus) {
+            whatCalled[STATUS] = true;
+            status = responseStatus.getStatusCode();
+            latch.countDown();
+            return State.ABORT;
+          }
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            whatCalled[OTHER] = true;
+            latch.countDown();
+            return State.ABORT;
+          }
+
+          @Override
+          public Integer onCompleted() {
+            whatCalled[COMPLETED] = true;
+            latch.countDown();
+            return status;
+          }
+        });
 
-                    @Override
-                    public String onCompleted() throws Exception {
-                        return "OK";
-                    }
-                });
-
-                f.get(20, TimeUnit.SECONDS);
-                HttpHeaders h = responseHeaders.get();
-                assertNotNull(h);
-                String[] values = h.get(ALLOW).split(",|, ");
-                assertNotNull(values);
-                assertEquals(values.length, expected.length);
-                Arrays.sort(values);
-                assertEquals(values, expected);
-            });
+        if (!latch.await(2, TimeUnit.SECONDS)) {
+          fail("Timeout");
+          return;
+        }
+        Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
+        assertEquals((int) status, 200, "Expected status code failed.");
+
+        if (!whatCalled[STATUS]) {
+          fail("onStatusReceived not called.");
+        }
+        if (!whatCalled[COMPLETED]) {
+          fail("onCompleted not called.");
+        }
+        if (whatCalled[OTHER]) {
+          fail("Other method of AsyncHandler got called.");
+        }
+      }));
+  }
+
+  @Test(groups = "online")
+  public void asyncOptionsTest() throws Throwable {
+
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+
+        final String[] expected = {"GET", "HEAD", "OPTIONS", "POST"};
+        Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+
+          @Override
+          public State onHeadersReceived(HttpHeaders headers) {
+            responseHeaders.set(headers);
+            return State.ABORT;
+          }
+
+          @Override
+          public String onCompleted() {
+            return "OK";
+          }
         });
-    }
 
-    @Test
-    public void closeConnectionTest() throws Throwable {
+        f.get(20, TimeUnit.SECONDS);
+        HttpHeaders h = responseHeaders.get();
+        assertNotNull(h);
+        String[] values = h.get(ALLOW).split(",|, ");
+        assertNotNull(values);
+        assertEquals(values.length, expected.length);
+        Arrays.sort(values);
+        assertEquals(values, expected);
+      }));
+  }
 
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
+  @Test
+  public void closeConnectionTest() throws Throwable {
 
-                Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
 
-                    private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+        Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
 
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        builder.accumulate(headers);
-                        return State.CONTINUE;
-                    }
+          private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-                    public void onThrowable(Throwable t) {
-                    }
+          public State onHeadersReceived(HttpHeaders headers) {
+            builder.accumulate(headers);
+            return State.CONTINUE;
+          }
 
-                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                        builder.accumulate(content);
-                        return content.isLast() ? State.ABORT : State.CONTINUE;
-                    }
+          public void onThrowable(Throwable t) {
+          }
 
-                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                        builder.accumulate(responseStatus);
+          public State onBodyPartReceived(HttpResponseBodyPart content) {
+            builder.accumulate(content);
+            return content.isLast() ? State.ABORT : State.CONTINUE;
+          }
 
-                        return State.CONTINUE;
-                    }
+          public State onStatusReceived(HttpResponseStatus responseStatus) {
+            builder.accumulate(responseStatus);
 
-                    public Response onCompleted() throws Exception {
-                        return builder.build();
-                    }
-                }).get();
+            return State.CONTINUE;
+          }
 
-                assertNotNull(r);
-                assertEquals(r.getStatusCode(), 200);
-            });
-        });
-    }
+          public Response onCompleted() {
+            return builder.build();
+          }
+        }).get();
+
+        assertNotNull(r);
+        assertEquals(r.getStatusCode(), 200);
+      }));
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index 2cd0282b3..2f3647cbc 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -15,131 +15,120 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.Test;
 
+import javax.servlet.AsyncContext;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.Test;
-
-import io.netty.handler.codec.http.HttpHeaders;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 
 /**
  * Tests default asynchronous life cycle.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class AsyncStreamLifecycleTest extends AbstractBasicTest {
-    private ExecutorService executorService = Executors.newFixedThreadPool(2);
+  private ExecutorService executorService = Executors.newFixedThreadPool(2);
 
-    @AfterClass
-    @Override
-    public void tearDownGlobal() throws Exception {
-        super.tearDownGlobal();
-        executorService.shutdownNow();
-    }
+  @AfterClass
+  @Override
+  public void tearDownGlobal() throws Exception {
+    super.tearDownGlobal();
+    executorService.shutdownNow();
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
-            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
-                resp.setContentType("text/plain;charset=utf-8");
-                resp.setStatus(200);
-                final AsyncContext asyncContext = request.startAsync();
-                final PrintWriter writer = resp.getWriter();
-                executorService.submit(new Runnable() {
-                    public void run() {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            logger.error("Failed to sleep for 100 ms.", e);
-                        }
-                        logger.info("Delivering part1.");
-                        writer.write("part1");
-                        writer.flush();
-                    }
-                });
-                executorService.submit(new Runnable() {
-                    public void run() {
-                        try {
-                            Thread.sleep(200);
-                        } catch (InterruptedException e) {
-                            logger.error("Failed to sleep for 200 ms.", e);
-                        }
-                        logger.info("Delivering part2.");
-                        writer.write("part2");
-                        writer.flush();
-                        asyncContext.complete();
-                    }
-                });
-                request.setHandled(true);
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
+      public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException {
+        resp.setContentType("text/plain;charset=utf-8");
+        resp.setStatus(200);
+        final AsyncContext asyncContext = request.startAsync();
+        final PrintWriter writer = resp.getWriter();
+        executorService.submit(() -> {
+            try {
+              Thread.sleep(100);
+            } catch (InterruptedException e) {
+              logger.error("Failed to sleep for 100 ms.", e);
             }
-        };
-    }
+            logger.info("Delivering part1.");
+            writer.write("part1");
+            writer.flush();
+        });
+        executorService.submit(() -> {
+            try {
+              Thread.sleep(200);
+            } catch (InterruptedException e) {
+              logger.error("Failed to sleep for 200 ms.", e);
+            }
+            logger.info("Delivering part2.");
+            writer.write("part2");
+            writer.flush();
+            asyncContext.complete();
+        });
+        request.setHandled(true);
+      }
+    };
+  }
 
-    @Test(groups = "standalone")
-    public void testStream() throws Exception {
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            final AtomicBoolean err = new AtomicBoolean(false);
-            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
-            final AtomicBoolean status = new AtomicBoolean(false);
-            final AtomicInteger headers = new AtomicInteger(0);
-            final CountDownLatch latch = new CountDownLatch(1);
-            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-                public void onThrowable(Throwable t) {
-                    fail("Got throwable.", t);
-                    err.set(true);
-                }
+  @Test
+  public void testStream() throws Exception {
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      final AtomicBoolean err = new AtomicBoolean(false);
+      final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
+      final AtomicBoolean status = new AtomicBoolean(false);
+      final AtomicInteger headers = new AtomicInteger(0);
+      final CountDownLatch latch = new CountDownLatch(1);
+      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+        public void onThrowable(Throwable t) {
+          fail("Got throwable.", t);
+          err.set(true);
+        }
 
-                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                    if (e.length() != 0) {
-                        String s = new String(e.getBodyPartBytes());
-                        logger.info("got part: {}", s);
-                        queue.put(s);
-                    }
-                    return State.CONTINUE;
-                }
+        public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+          if (e.length() != 0) {
+            String s = new String(e.getBodyPartBytes());
+            logger.info("got part: {}", s);
+            queue.put(s);
+          }
+          return State.CONTINUE;
+        }
 
-                public State onStatusReceived(HttpResponseStatus e) throws Exception {
-                    status.set(true);
-                    return State.CONTINUE;
-                }
+        public State onStatusReceived(HttpResponseStatus e) {
+          status.set(true);
+          return State.CONTINUE;
+        }
 
-                public State onHeadersReceived(HttpHeaders e) throws Exception {
-                    if (headers.incrementAndGet() == 2) {
-                        throw new Exception("Analyze this.");
-                    }
-                    return State.CONTINUE;
-                }
+        public State onHeadersReceived(HttpHeaders e) throws Exception {
+          if (headers.incrementAndGet() == 2) {
+            throw new Exception("Analyze this.");
+          }
+          return State.CONTINUE;
+        }
 
-                public Object onCompleted() throws Exception {
-                    latch.countDown();
-                    return null;
-                }
-            });
-            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-            assertFalse(err.get());
-            assertEquals(queue.size(), 2);
-            assertTrue(queue.contains("part1"));
-            assertTrue(queue.contains("part2"));
-            assertTrue(status.get());
-            assertEquals(headers.get(), 1);
+        public Object onCompleted() {
+          latch.countDown();
+          return null;
         }
+      });
+      assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+      assertFalse(err.get());
+      assertEquals(queue.size(), 2);
+      assertTrue(queue.contains("part1"));
+      assertTrue(queue.contains("part2"));
+      assertTrue(status.get());
+      assertEquals(headers.get(), 1);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 84e7f4aa6..78af7855e 100644
--- a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -12,20 +12,6 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -34,156 +20,170 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class AuthTimeoutTest extends AbstractBasicTest {
-
-    private static final int REQUEST_TIMEOUT = 1000;
-    private static final int SHORT_FUTURE_TIMEOUT = 500; // shorter than REQUEST_TIMEOUT
-    private static final int LONG_FUTURE_TIMEOUT = 1500; // longer than REQUEST_TIMEOUT
-
-    private Server server2;
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void setUpGlobal() throws Exception {
-
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        addBasicAuthHandler(server, configureHandler());
-        server.start();
-        port1 = connector1.getLocalPort();
-
-        server2 = new Server();
-        ServerConnector connector2 = addHttpConnector(server2);
-        addDigestAuthHandler(server2, configureHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
-
-        logger.info("Local HTTP server started successfully");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        super.tearDownGlobal();
-        server2.stop();
-    }
-
-    private class IncompleteResponseHandler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
-            response.setStatus(200);
-            OutputStream out = response.getOutputStream();
-            response.setIntHeader(CONTENT_LENGTH.toString(), 1000);
-            out.write(0);
-            out.flush();
-            try {
-                Thread.sleep(LONG_FUTURE_TIMEOUT + 100);
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void basicAuthTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, true, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        } catch (Exception e) {
-            throw e.getCause();
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void basicPreemptiveAuthTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, true, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        } catch (Exception e) {
-            throw e.getCause();
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void digestAuthTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, false, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        } catch (Exception e) {
-            throw e.getCause();
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class, enabled = false)
-    public void digestPreemptiveAuthTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, false, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        } catch (Exception e) {
-            throw e.getCause();
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void basicAuthFutureTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, true, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void basicPreemptiveAuthFutureTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, true, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void digestAuthFutureTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, false, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        }
-    }
-
-    @Test(expectedExceptions = TimeoutException.class, enabled = false)
-    public void digestPreemptiveAuthFutureTimeoutTest() throws Throwable {
-        try (AsyncHttpClient client = newClient()) {
-            execute(client, false, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-        }
-    }
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
-    private AsyncHttpClient newClient() {
-        return asyncHttpClient(config().setRequestTimeout(REQUEST_TIMEOUT));
-    }
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
 
-    protected Future<Response> execute(AsyncHttpClient client, boolean basic, boolean preemptive) throws IOException {
-        Realm.Builder realm;
-        String url;
-
-        if (basic) {
-            realm = basicAuthRealm(USER, ADMIN);
-            url = getTargetUrl();
-        } else {
-            realm = digestAuthRealm(USER, ADMIN);
-            url = getTargetUrl2();
-            if (preemptive) {
-                realm.setRealmName("MyRealm");
-                realm.setAlgorithm("MD5");
-                realm.setQop("auth");
-                realm.setNonce("fFDVc60re9zt8fFDvht0tNrYuvqrcchN");
-            }
-        }
-
-        return client.prepareGet(url).setRealm(realm.setUsePreemptiveAuth(preemptive).build()).execute();
-    }
+public class AuthTimeoutTest extends AbstractBasicTest {
 
-    @Override
-    protected String getTargetUrl() {
-        return "http://localhost:" + port1 + "/";
-    }
+  private static final int REQUEST_TIMEOUT = 1000;
+  private static final int SHORT_FUTURE_TIMEOUT = 500; // shorter than REQUEST_TIMEOUT
+  private static final int LONG_FUTURE_TIMEOUT = 1500; // longer than REQUEST_TIMEOUT
 
-    @Override
-    protected String getTargetUrl2() {
-        return "http://localhost:" + port2 + "/";
-    }
+  private Server server2;
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new IncompleteResponseHandler();
-    }
+  @BeforeClass(alwaysRun = true)
+  @Override
+  public void setUpGlobal() throws Exception {
+
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    addBasicAuthHandler(server, configureHandler());
+    server.start();
+    port1 = connector1.getLocalPort();
+
+    server2 = new Server();
+    ServerConnector connector2 = addHttpConnector(server2);
+    addDigestAuthHandler(server2, configureHandler());
+    server2.start();
+    port2 = connector2.getLocalPort();
+
+    logger.info("Local HTTP server started successfully");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    super.tearDownGlobal();
+    server2.stop();
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void basicAuthTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, true, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    } catch (Exception e) {
+      throw e.getCause();
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void basicPreemptiveAuthTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, true, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    } catch (Exception e) {
+      throw e.getCause();
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void digestAuthTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, false, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    } catch (Exception e) {
+      throw e.getCause();
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class, enabled = false)
+  public void digestPreemptiveAuthTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, false, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    } catch (Exception e) {
+      throw e.getCause();
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void basicAuthFutureTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, true, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void basicPreemptiveAuthFutureTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, true, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void digestAuthFutureTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, false, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    }
+  }
+
+  @Test(expectedExceptions = TimeoutException.class, enabled = false)
+  public void digestPreemptiveAuthFutureTimeoutTest() throws Throwable {
+    try (AsyncHttpClient client = newClient()) {
+      execute(client, false, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+    }
+  }
+
+  private AsyncHttpClient newClient() {
+    return asyncHttpClient(config().setRequestTimeout(REQUEST_TIMEOUT));
+  }
+
+  protected Future<Response> execute(AsyncHttpClient client, boolean basic, boolean preemptive) {
+    Realm.Builder realm;
+    String url;
+
+    if (basic) {
+      realm = basicAuthRealm(USER, ADMIN);
+      url = getTargetUrl();
+    } else {
+      realm = digestAuthRealm(USER, ADMIN);
+      url = getTargetUrl2();
+      if (preemptive) {
+        realm.setRealmName("MyRealm");
+        realm.setAlgorithm("MD5");
+        realm.setQop("auth");
+        realm.setNonce("fFDVc60re9zt8fFDvht0tNrYuvqrcchN");
+      }
+    }
+
+    return client.prepareGet(url).setRealm(realm.setUsePreemptiveAuth(preemptive).build()).execute();
+  }
+
+  @Override
+  protected String getTargetUrl() {
+    return "http://localhost:" + port1 + "/";
+  }
+
+  @Override
+  protected String getTargetUrl2() {
+    return "http://localhost:" + port2 + "/";
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new IncompleteResponseHandler();
+  }
+
+  private class IncompleteResponseHandler extends AbstractHandler {
+
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
+      response.setStatus(200);
+      OutputStream out = response.getOutputStream();
+      response.setIntHeader(CONTENT_LENGTH.toString(), 1000);
+      out.write(0);
+      out.flush();
+      try {
+        Thread.sleep(LONG_FUTURE_TIMEOUT + 100);
+      } catch (InterruptedException e) {
+        //
+      }
+    }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
index defa24768..f36ef7d48 100644
--- a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -15,24 +15,7 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -43,299 +26,312 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class BasicAuthTest extends AbstractBasicTest {
-
-    protected static final String MY_MESSAGE = "my message";
-
-    private Server server2;
-    private Server serverNoAuth;
-    private int portNoAuth;
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void setUpGlobal() throws Exception {
-
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        addBasicAuthHandler(server, configureHandler());
-        server.start();
-        port1 = connector1.getLocalPort();
-
-        server2 = new Server();
-        ServerConnector connector2 = addHttpConnector(server2);
-        addBasicAuthHandler(server2, new RedirectHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
-
-        // need noAuth server to verify the preemptive auth mode (see basicAuthTestPreemtiveTest)
-        serverNoAuth = new Server();
-        ServerConnector connectorNoAuth = addHttpConnector(serverNoAuth);
-        serverNoAuth.setHandler(new SimpleHandler());
-        serverNoAuth.start();
-        portNoAuth = connectorNoAuth.getLocalPort();
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
-        logger.info("Local HTTP server started successfully");
-    }
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        super.tearDownGlobal();
-        server2.stop();
-        serverNoAuth.stop();
-    }
+public class BasicAuthTest extends AbstractBasicTest {
 
-    @Override
-    protected String getTargetUrl() {
-        return "http://localhost:" + port1 + "/";
+  private Server server2;
+  private Server serverNoAuth;
+  private int portNoAuth;
+
+  @BeforeClass(alwaysRun = true)
+  @Override
+  public void setUpGlobal() throws Exception {
+
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    addBasicAuthHandler(server, configureHandler());
+    server.start();
+    port1 = connector1.getLocalPort();
+
+    server2 = new Server();
+    ServerConnector connector2 = addHttpConnector(server2);
+    addBasicAuthHandler(server2, new RedirectHandler());
+    server2.start();
+    port2 = connector2.getLocalPort();
+
+    // need noAuth server to verify the preemptive auth mode (see basicAuthTestPreemtiveTest)
+    serverNoAuth = new Server();
+    ServerConnector connectorNoAuth = addHttpConnector(serverNoAuth);
+    serverNoAuth.setHandler(new SimpleHandler());
+    serverNoAuth.start();
+    portNoAuth = connectorNoAuth.getLocalPort();
+
+    logger.info("Local HTTP server started successfully");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    super.tearDownGlobal();
+    server2.stop();
+    serverNoAuth.stop();
+  }
+
+  @Override
+  protected String getTargetUrl() {
+    return "http://localhost:" + port1 + "/";
+  }
+
+  @Override
+  protected String getTargetUrl2() {
+    return "http://localhost:" + port2 + "/uff";
+  }
+
+  private String getTargetUrlNoAuth() {
+    return "http://localhost:" + portNoAuth + "/";
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new SimpleHandler();
+  }
+
+  @Test
+  public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet(getTargetUrl())
+              .setRealm(basicAuthRealm(USER, ADMIN).build())
+              .execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
     }
-
-    @Override
-    protected String getTargetUrl2() {
-        return "http://localhost:" + port2 + "/uff";
+  }
+
+  @Test
+  public void redirectAndBasicAuthTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
+      Future<Response> f = client.prepareGet(getTargetUrl2())
+              .setRealm(basicAuthRealm(USER, ADMIN).build())
+              .execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
     }
+  }
 
-    protected String getTargetUrlNoAuth() {
-        return "http://localhost:" + portNoAuth + "/";
-    }
+  @Test
+  public void basic401Test() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl())
+              .setHeader("X-401", "401")
+              .setRealm(basicAuthRealm(USER, ADMIN).build());
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SimpleHandler();
-    }
+      Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
 
-    private static class RedirectHandler extends AbstractHandler {
+        private HttpResponseStatus status;
 
-        private static final Logger LOGGER = LoggerFactory.getLogger(RedirectHandler.class);
+        public void onThrowable(Throwable t) {
 
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        }
 
-            LOGGER.info("request: " + request.getRequestURI());
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
+          return State.CONTINUE;
+        }
 
-            if ("/uff".equals(request.getRequestURI())) {
-                LOGGER.info("redirect to /bla");
-                response.setStatus(302);
-                response.setContentLength(0);
-                response.setHeader("Location", "/bla");
+        public State onStatusReceived(HttpResponseStatus responseStatus) {
+          this.status = responseStatus;
 
-            } else {
-                LOGGER.info("got redirected" + request.getRequestURI());
-                response.setStatus(200);
-                response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
-                byte[] b = "content".getBytes(UTF_8);
-                response.setContentLength(b.length);
-                response.getOutputStream().write(b);
-            }
-            response.getOutputStream().flush();
-            response.getOutputStream().close();
+          if (status.getStatusCode() != 200) {
+            return State.ABORT;
+          }
+          return State.CONTINUE;
         }
-    }
 
-    public static class SimpleHandler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-
-            if (request.getHeader("X-401") != null) {
-                response.setStatus(401);
-                response.setContentLength(0);
-
-            } else {
-                response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
-                response.setIntHeader("X-" + CONTENT_LENGTH, request.getContentLength());
-                response.setStatus(200);
-
-                int size = 10 * 1024;
-                byte[] bytes = new byte[size];
-                int contentLength = 0;
-                if (bytes.length > 0) {
-                    int read = 0;
-                    do {
-                        read = request.getInputStream().read(bytes);
-                        if (read > 0) {
-                            contentLength += read;
-                            response.getOutputStream().write(bytes, 0, read);
-                        }
-                    } while (read >= 0);
-                }
-                response.setContentLength(contentLength);
-            }
-            response.getOutputStream().flush();
-            response.getOutputStream().close();
+        public State onHeadersReceived(HttpHeaders headers) {
+          return State.CONTINUE;
         }
-    }
 
-    @Test(groups = "standalone")
-    public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet(getTargetUrl())//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
-                    .execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        public Integer onCompleted() {
+          return status.getStatusCode();
         }
+      });
+      Integer statusCode = f.get(10, TimeUnit.SECONDS);
+      assertNotNull(statusCode);
+      assertEquals(statusCode.intValue(), 401);
     }
-
-    @Test(groups = "standalone")
-    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
-            Future<Response> f = client.prepareGet(getTargetUrl2())//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
-                    .execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-        }
+  }
+
+  @Test
+  public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      // send the request to the no-auth endpoint to be able to verify the
+      // auth header is really sent preemptively for the initial call.
+      Future<Response> f = client.prepareGet(getTargetUrlNoAuth())
+              .setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true).build())
+              .execute();
+
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
     }
-
-    @Test(groups = "standalone")
-    public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl())//
-                    .setHeader("X-401", "401")//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build());
-
-            Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
-
-                private HttpResponseStatus status;
-
-                public void onThrowable(Throwable t) {
-
-                }
-
-                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    this.status = responseStatus;
-
-                    if (status.getStatusCode() != 200) {
-                        return State.ABORT;
-                    }
-                    return State.CONTINUE;
-                }
-
-                public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public Integer onCompleted() throws Exception {
-                    return status.getStatusCode();
-                }
-            });
-            Integer statusCode = f.get(10, TimeUnit.SECONDS);
-            assertNotNull(statusCode);
-            assertEquals(statusCode.intValue(), 401);
-        }
+  }
+
+  @Test
+  public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet(getTargetUrl())
+              .setRealm(basicAuthRealm("fake", ADMIN).build())
+              .execute();
+
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), 401);
     }
-
-    @Test(groups = "standalone")
-    public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // send the request to the no-auth endpoint to be able to verify the
-            // auth header is really sent preemptively for the initial call.
-            Future<Response> f = client.prepareGet(getTargetUrlNoAuth())//
-                    .setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true).build())//
-                    .execute();
-
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
+  }
+
+  @Test
+  public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost(getTargetUrl())
+              .setBody(new ByteArrayInputStream("test".getBytes()))
+              .setRealm(basicAuthRealm(USER, ADMIN).build())
+              .execute();
+
+      Response resp = f.get(30, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), "test");
     }
-
-    @Test(groups = "standalone")
-    public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet(getTargetUrl())//
-                    .setRealm(basicAuthRealm("fake", ADMIN).build())//
-                    .execute();
-
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), 401);
-        }
+  }
+
+  @Test
+  public void basicAuthFileTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost(getTargetUrl())
+              .setBody(SIMPLE_TEXT_FILE)
+              .setRealm(basicAuthRealm(USER, ADMIN).build())
+              .execute();
+
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
-
-    @Test(groups = "standalone")
-    public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost(getTargetUrl())//
-                    .setBody(new ByteArrayInputStream("test".getBytes()))//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
-                    .execute();
-
-            Response resp = f.get(30, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), "test");
-        }
+  }
+
+  @Test
+  public void basicAuthAsyncConfigTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN)))) {
+      Future<Response> f = client.preparePost(getTargetUrl())
+              .setBody(SIMPLE_TEXT_FILE_STRING)
+              .execute();
+
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
-
-    @Test(groups = "standalone")
-    public void basicAuthFileTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost(getTargetUrl())//
-                    .setBody(SIMPLE_TEXT_FILE)//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
-                    .execute();
-
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        }
+  }
+
+  @Test
+  public void basicAuthFileNoKeepAliveTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
+
+      Future<Response> f = client.preparePost(getTargetUrl())
+              .setBody(SIMPLE_TEXT_FILE)
+              .setRealm(basicAuthRealm(USER, ADMIN).build())
+              .execute();
+
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
-
-    @Test(groups = "standalone")
-    public void basicAuthAsyncConfigTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN)))) {
-            Future<Response> f = client.preparePost(getTargetUrl())//
-                    .setBody(SIMPLE_TEXT_FILE_STRING)//
-                    .execute();
-
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        }
+  }
+
+  @Test
+  public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(basicAuthRealm(USER, ADMIN).build());
+
+      Future<Response> f = r.execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertNotNull(resp.getHeader("X-Auth"));
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void basicAuthFileNoKeepAliveTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
+  private static class RedirectHandler extends AbstractHandler {
 
-            Future<Response> f = client.preparePost(getTargetUrl())//
-                    .setBody(SIMPLE_TEXT_FILE)//
-                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
-                    .execute();
+    private static final Logger LOGGER = LoggerFactory.getLogger(RedirectHandler.class);
 
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        }
-    }
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-    @Test(groups = "standalone")
-    public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(basicAuthRealm(USER, ADMIN).build());
+      LOGGER.info("request: " + request.getRequestURI());
 
-            Future<Response> f = r.execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertNotNull(resp.getHeader("X-Auth"));
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
+      if ("/uff".equals(request.getRequestURI())) {
+        LOGGER.info("redirect to /bla");
+        response.setStatus(302);
+        response.setContentLength(0);
+        response.setHeader("Location", "/bla");
+
+      } else {
+        LOGGER.info("got redirected" + request.getRequestURI());
+        response.setStatus(200);
+        response.addHeader("X-Auth", request.getHeader("Authorization"));
+        response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
+        byte[] b = "content".getBytes(UTF_8);
+        response.setContentLength(b.length);
+        response.getOutputStream().write(b);
+      }
+      response.getOutputStream().flush();
+      response.getOutputStream().close();
+    }
+  }
+
+  public static class SimpleHandler extends AbstractHandler {
+
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+      if (request.getHeader("X-401") != null) {
+        response.setStatus(401);
+        response.setContentLength(0);
+
+      } else {
+        response.addHeader("X-Auth", request.getHeader("Authorization"));
+        response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
+        response.setIntHeader("X-" + CONTENT_LENGTH, request.getContentLength());
+        response.setStatus(200);
+
+        int size = 10 * 1024;
+        byte[] bytes = new byte[size];
+        int contentLength = 0;
+        int read;
+        do {
+          read = request.getInputStream().read(bytes);
+          if (read > 0) {
+            contentLength += read;
+            response.getOutputStream().write(bytes, 0, read);
+          }
+        } while (read >= 0);
+        response.setContentLength(contentLength);
+      }
+      response.getOutputStream().flush();
+      response.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
index 1c9170ffc..758e03960 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
@@ -13,18 +13,6 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ProxyServlet;
@@ -39,94 +27,106 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+
 /**
  * Test that validates that when having an HTTP proxy and trying to access an HTTP through the proxy the proxy credentials should be passed after it gets a 407 response.
  */
 public class BasicHttpProxyToHttpTest {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpTest.class);
-
-    private int httpPort;
-    private int proxyPort;
-
-    private Server httpServer;
-    private Server proxy;
-
-    @SuppressWarnings("serial")
-    public static class BasicAuthProxyServlet extends ProxyServlet {
-
-        @Override
-        protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
-            LOGGER.debug(">>> got a request !");
-
-            String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
-            if (authorization == null) {
-                response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
-                response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
-                response.getOutputStream().flush();
+  private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpTest.class);
+
+  private int httpPort;
+  private int proxyPort;
+
+  private Server httpServer;
+  private Server proxy;
+
+  @BeforeClass
+  public void setUpGlobal() throws Exception {
+
+    httpServer = new Server();
+    ServerConnector connector1 = addHttpConnector(httpServer);
+    httpServer.setHandler(new EchoHandler());
+    httpServer.start();
+    httpPort = connector1.getLocalPort();
+
+    proxy = new Server();
+    ServerConnector connector2 = addHttpConnector(proxy);
+    ServletHandler servletHandler = new ServletHandler();
+    ServletHolder servletHolder = servletHandler.addServletWithMapping(BasicAuthProxyServlet.class, "/*");
+    servletHolder.setInitParameter("maxThreads", "20");
+    proxy.setHandler(servletHandler);
+    proxy.start();
+    proxyPort = connector2.getLocalPort();
+
+    LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() {
+    if (proxy != null) {
+      try {
+        proxy.stop();
+      } catch (Exception e) {
+        LOGGER.error("Failed to properly close proxy", e);
+      }
+    }
+    if (httpServer != null) {
+      try {
+        httpServer.stop();
+      } catch (Exception e) {
+        LOGGER.error("Failed to properly close server", e);
+      }
+    }
+  }
+
+  @Test
+  public void nonPreemptiveProxyAuthWithPlainHttpTarget() throws IOException, InterruptedException, ExecutionException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String targetUrl = "http://localhost:" + httpPort + "/foo/bar";
+      Request request = get(targetUrl)
+              .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))
+              // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))
+              .build();
+      Future<Response> responseFuture = client.executeRequest(request);
+      Response response = responseFuture.get();
+
+      Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+      Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
+    }
+  }
 
-            } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
-                super.service(request, response);
+  @SuppressWarnings("serial")
+  public static class BasicAuthProxyServlet extends ProxyServlet {
 
-            } else {
-                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
-                response.getOutputStream().flush();
-            }
-        }
-    }
+    @Override
+    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
+      LOGGER.debug(">>> got a request !");
 
-    @BeforeClass
-    public void setUpGlobal() throws Exception {
-
-        httpServer = new Server();
-        ServerConnector connector1 = addHttpConnector(httpServer);
-        httpServer.setHandler(new EchoHandler());
-        httpServer.start();
-        httpPort = connector1.getLocalPort();
-
-        proxy = new Server();
-        ServerConnector connector2 = addHttpConnector(proxy);
-        ServletHandler servletHandler = new ServletHandler();
-        ServletHolder servletHolder = servletHandler.addServletWithMapping(BasicAuthProxyServlet.class, "/*");
-        servletHolder.setInitParameter("maxThreads", "20");
-        proxy.setHandler(servletHandler);
-        proxy.start();
-        proxyPort = connector2.getLocalPort();
-
-        LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
-    }
+      String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
+      if (authorization == null) {
+        response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
+        response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
+        response.getOutputStream().flush();
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        if (proxy != null) {
-            try {
-                proxy.stop();
-            } catch (Exception e) {
-                LOGGER.error("Failed to properly close proxy", e);
-            }
-        }
-        if (httpServer != null) {
-            try {
-                httpServer.stop();
-            } catch (Exception e) {
-                LOGGER.error("Failed to properly close server", e);
-            }
-        }
-    }
+      } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
+        super.service(request, response);
 
-    @Test
-    public void nonPreemptiveProxyAuthWithPlainHttpTarget() throws IOException, InterruptedException, ExecutionException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String targetUrl = "http://localhost:" + httpPort + "/foo/bar";
-            Request request = get(targetUrl)//
-                    .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))//
-                    // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))//
-                    .build();
-            Future<Response> responseFuture = client.executeRequest(request);
-            Response response = responseFuture.get();
-
-            Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-            Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
-        }
+      } else {
+        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+        response.getOutputStream().flush();
+      }
     }
+  }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
index 4df3dc866..a1919f6f4 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
@@ -13,17 +13,6 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
@@ -36,74 +25,86 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
+
 /**
  * Test that validates that when having an HTTP proxy and trying to access an HTTPS through the proxy the proxy credentials should be passed during the CONNECT request.
  */
 public class BasicHttpProxyToHttpsTest {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpsTest.class);
-
-    private int httpPort;
-    private int proxyPort;
-
-    private Server httpServer;
-    private Server proxy;
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-
-        // HTTP server
-        httpServer = new Server();
-        ServerConnector connector1 = addHttpsConnector(httpServer);
-        httpServer.setHandler(new EchoHandler());
-        httpServer.start();
-        httpPort = connector1.getLocalPort();
-
-        // proxy
-        proxy = new Server();
-        ServerConnector connector2 = addHttpConnector(proxy);
-        ConnectHandler connectHandler = new ConnectHandler() {
-
-            @Override
-            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {
-                String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
-                if (authorization == null) {
-                    response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
-                    response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
-                    return false;
-                } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
-                    return true;
-                }
-                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
-                return false;
-            }
-        };
-        proxy.setHandler(connectHandler);
-        proxy.start();
-        proxyPort = connector2.getLocalPort();
-
-        LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        httpServer.stop();
-        proxy.stop();
-    }
-
-    @Test
-    public void nonPreemptiveProxyAuthWithHttpsTarget() throws IOException, InterruptedException, ExecutionException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setUseInsecureTrustManager(true))) {
-            String targetUrl = "https://localhost:" + httpPort + "/foo/bar";
-            Request request = get(targetUrl)//
-                    .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))//
-                    // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))//
-                    .build();
-            Future<Response> responseFuture = client.executeRequest(request);
-            Response response = responseFuture.get();
-
-            Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-            Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
+  private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpsTest.class);
+
+  private int httpPort;
+  private int proxyPort;
+
+  private Server httpServer;
+  private Server proxy;
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+
+    // HTTP server
+    httpServer = new Server();
+    ServerConnector connector1 = addHttpsConnector(httpServer);
+    httpServer.setHandler(new EchoHandler());
+    httpServer.start();
+    httpPort = connector1.getLocalPort();
+
+    // proxy
+    proxy = new Server();
+    ServerConnector connector2 = addHttpConnector(proxy);
+    ConnectHandler connectHandler = new ConnectHandler() {
+
+      @Override
+      protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {
+        String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
+        if (authorization == null) {
+          response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
+          response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
+          return false;
+        } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
+          return true;
         }
+        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+        return false;
+      }
+    };
+    proxy.setHandler(connectHandler);
+    proxy.start();
+    proxyPort = connector2.getLocalPort();
+
+    LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    httpServer.stop();
+    proxy.stop();
+  }
+
+  @Test
+  public void nonPreemptiveProxyAuthWithHttpsTarget() throws IOException, InterruptedException, ExecutionException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setUseInsecureTrustManager(true))) {
+      String targetUrl = "https://localhost:" + httpPort + "/foo/bar";
+      Request request = get(targetUrl)
+              .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))
+              // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))
+              .build();
+      Future<Response> responseFuture = client.executeRequest(request);
+      Response response = responseFuture.get();
+
+      Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+      Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
     }
+  }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index dee17f46a..d38c930f9 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -13,49 +13,16 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.codec.http.cookie.DefaultCookie;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ConnectException;
-import java.net.UnknownHostException;
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import javax.net.ssl.SSLException;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
 import org.asynchttpclient.request.body.multipart.StringPart;
 import org.asynchttpclient.test.EventCollectingHandler;
-import org.asynchttpclient.test.TestUtils.AsyncCompletionHandlerAdapter;
+import org.asynchttpclient.test.TestUtils.*;
 import org.asynchttpclient.testserver.HttpServer;
 import org.asynchttpclient.testserver.HttpServer.EchoHandler;
 import org.asynchttpclient.testserver.HttpTest;
@@ -64,936 +31,972 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class BasicHttpTest extends HttpTest {
-
-    private static HttpServer server;
-
-    @BeforeClass
-    public static void start() throws Throwable {
-        server = new HttpServer();
-        server.start();
-    }
-
-    @AfterClass
-    public static void stop() throws Throwable {
-        server.close();
-    }
-
-    private static String getTargetUrl() {
-        return server.getHttpUrl() + "/foo/bar";
-    }
-
-    @Test
-    public void getRootUrl() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                String url = server.getHttpUrl();
-                server.enqueueOk();
-
-                Response response = client.executeRequest(get(url), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-                assertEquals(response.getUri().toUrl(), url);
-            });
-        });
-    }
-
-    @Test
-    public void getUrlWithPathWithoutQuery() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueOk();
+import javax.net.ssl.SSLException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.ConnectException;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
-                Response response = client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-                assertEquals(response.getUri().toUrl(), getTargetUrl());
-            });
-        });
-    }
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+import static org.testng.Assert.*;
 
-    @Test
-    public void getUrlWithPathWithQuery() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                String targetUrl = getTargetUrl() + "?q=+%20x";
-                Request request = get(targetUrl).build();
-                assertEquals(request.getUrl(), targetUrl);
-                server.enqueueOk();
-
-                Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-                assertEquals(response.getUri().toUrl(), targetUrl);
-            });
-        });
-    }
+public class BasicHttpTest extends HttpTest {
 
-    @Test
-    public void getUrlWithPathWithQueryParams() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueOk();
+  private static HttpServer server;
+
+  @BeforeClass
+  public static void start() throws Throwable {
+    server = new HttpServer();
+    server.start();
+  }
+
+  @AfterClass
+  public static void stop() throws Throwable {
+    server.close();
+  }
+
+  private static String getTargetUrl() {
+    return server.getHttpUrl() + "/foo/bar";
+  }
+
+  @Test
+  public void getRootUrl() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        String url = server.getHttpUrl();
+        server.enqueueOk();
+
+        Response response = client.executeRequest(get(url), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+        assertEquals(response.getUri().toUrl(), url);
+      }));
+  }
+
+  @Test
+  public void getUrlWithPathWithoutQuery() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueOk();
+
+        Response response = client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+        assertEquals(response.getUri().toUrl(), getTargetUrl());
+      }));
+  }
+
+  @Test
+  public void getUrlWithPathWithQuery() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        String targetUrl = getTargetUrl() + "?q=+%20x";
+        Request request = get(targetUrl).build();
+        assertEquals(request.getUrl(), targetUrl);
+        server.enqueueOk();
+
+        Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+        assertEquals(response.getUri().toUrl(), targetUrl);
+      }));
+  }
+
+  @Test
+  public void getUrlWithPathWithQueryParams() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueOk();
+
+        Response response = client.executeRequest(get(getTargetUrl()).addQueryParam("q", "a b"), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+        assertEquals(response.getUri().toUrl(), getTargetUrl() + "?q=a%20b");
+      }));
+  }
+
+  @Test
+  public void getResponseBody() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final String body = "Hello World";
+
+        server.enqueueResponse(response -> {
+          response.setStatus(200);
+          response.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+          writeResponseBody(response, body);
+        });
+
+        client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            String contentLengthHeader = response.getHeader(CONTENT_LENGTH);
+            assertNotNull(contentLengthHeader);
+            assertEquals(Integer.parseInt(contentLengthHeader), body.length());
+            assertContentTypesEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            assertEquals(response.getResponseBody(), body);
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void getWithHeaders() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        for (int i = 1; i < 5; i++) {
+          h.add("Test" + i, "Test" + i);
+        }
+
+        server.enqueueEcho();
+
+        client.executeRequest(get(getTargetUrl()).setHeaders(h), new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            for (int i = 1; i < 5; i++) {
+              assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+            }
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void postWithHeadersAndFormParams() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+
+        Map<String, List<String>> m = new HashMap<>();
+        for (int i = 0; i < 5; i++) {
+          m.put("param_" + i, Collections.singletonList("value_" + i));
+        }
+
+        Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
+
+        server.enqueueEcho();
+
+        client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            for (int i = 1; i < 5; i++) {
+              assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            }
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+      }));
+  }
 
-                Response response = client.executeRequest(get(getTargetUrl()).addQueryParam("q", "a b"), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-                assertEquals(response.getUri().toUrl(), getTargetUrl() + "?q=a%20b");
-            });
-        });
-    }
+  @Test
+  public void postChineseChar() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
 
-    @Test
-    public void getResponseBody() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final String body = "Hello World";
-
-                server.enqueueResponse(response -> {
-                    response.setStatus(200);
-                    response.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    writeResponseBody(response, body);
-                });
-
-                client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertEquals(response.getStatusCode(), 200);
-                        String contentLengthHeader = response.getHeader(CONTENT_LENGTH);
-                        assertNotNull(contentLengthHeader);
-                        assertEquals(Integer.parseInt(contentLengthHeader), body.length());
-                        assertContentTypesEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                        assertEquals(response.getResponseBody(), body);
-                        return response;
-                    }
-                }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
+        String chineseChar = "是";
 
-    @Test
-    public void getWithHeaders() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                for (int i = 1; i < 5; i++) {
-                    h.add("Test" + i, "Test" + i);
-                }
+        Map<String, List<String>> m = new HashMap<>();
+        m.put("param", Collections.singletonList(chineseChar));
 
-                server.enqueueEcho();
+        Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
 
-                client.executeRequest(get(getTargetUrl()).setHeaders(h), new AsyncCompletionHandlerAdapter() {
+        server.enqueueEcho();
 
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
-                        }
-                        return response;
-                    }
+        client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            String value;
+            try {
+              // headers must be encoded
+              value = URLDecoder.decode(response.getHeader("X-param"), StandardCharsets.UTF_8.name());
+            } catch (UnsupportedEncodingException e) {
+              throw new RuntimeException(e);
+            }
+            assertEquals(value, chineseChar);
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void headHasEmptyBody() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueOk();
+
+        Response response = client.executeRequest(head(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+
+        assertTrue(response.getResponseBody().isEmpty());
+      }));
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void nullSchemeThrowsNPE() throws Throwable {
+    withClient().run(client -> client.prepareGet("gatling.io").execute());
+  }
+
+  @Test
+  public void jettyRespondsWithChunkedTransferEncoding() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        client.prepareGet(getTargetUrl())
+                .execute(new AsyncCompletionHandlerAdapter() {
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    assertEquals(response.getHeader(TRANSFER_ENCODING), HttpHeaderValues.CHUNKED.toString());
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void postWithHeadersAndFormParams() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-
-                Map<String, List<String>> m = new HashMap<>();
-                for (int i = 0; i < 5; i++) {
-                    m.put("param_" + i, Arrays.asList("value_" + i));
-                }
-
-                Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
-
-                server.enqueueEcho();
-
-                client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                        }
-                        return response;
-                    }
+      }));
+  }
+
+  @Test
+  public void getWithCookies() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final Cookie coo = new DefaultCookie("foo", "value");
+        coo.setDomain("/");
+        coo.setPath("/");
+        server.enqueueEcho();
+
+        client.prepareGet(getTargetUrl())
+                .addCookie(coo)
+                .execute(new AsyncCompletionHandlerAdapter() {
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    List<Cookie> cookies = response.getCookies();
+                    assertEquals(cookies.size(), 1);
+                    assertEquals(cookies.get(0).toString(), "foo=value");
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
+      }));
+  }
+
+  @Test
+  public void defaultRequestBodyEncodingIsUtf8() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        Response response = client.preparePost(getTargetUrl())
+                .setBody("\u017D\u017D\u017D\u017D\u017D\u017D")
+                .execute().get();
+        assertEquals(response.getResponseBodyAsBytes(), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes(UTF_8));
+      }));
+  }
+
+  @Test
+  public void postFormParametersAsBodyString() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < 5; i++) {
+          sb.append("param_").append(i).append("=value_").append(i).append("&");
+        }
+        sb.setLength(sb.length() - 1);
+
+        server.enqueueEcho();
+        client.preparePost(getTargetUrl())
+                .setHeaders(h)
+                .setBody(sb.toString())
+                .execute(new AsyncCompletionHandlerAdapter() {
+
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    for (int i = 1; i < 5; i++) {
+                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
 
-    @Test
-    public void headHasEmptyBody() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueOk();
-
-                Response response = client.executeRequest(head(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertEquals(response.getStatusCode(), 200);
-                        return response;
                     }
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void postFormParametersAsBodyStream() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < 5; i++) {
+          sb.append("param_").append(i).append("=value_").append(i).append("&");
+        }
+        sb.setLength(sb.length() - 1);
+
+        server.enqueueEcho();
+        client.preparePost(getTargetUrl())
+                .setHeaders(h)
+                .setBody(new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8)))
+                .execute(new AsyncCompletionHandlerAdapter() {
+
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    for (int i = 1; i < 5; i++) {
+                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
 
-                assertTrue(response.getResponseBody().isEmpty());
-            });
-        });
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void nullSchemeThrowsNPE() throws Throwable {
-        withClient().run(client -> client.prepareGet("gatling.io").execute());
-    }
-
-    @Test
-    public void jettyRespondsWithChunkedTransferEncoding() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                client.prepareGet(getTargetUrl())//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                assertEquals(response.getHeader(TRANSFER_ENCODING), HttpHeaderValues.CHUNKED.toString());
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void getWithCookies() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final Cookie coo = new DefaultCookie("foo", "value");
-                coo.setDomain("/");
-                coo.setPath("/");
-                server.enqueueEcho();
-
-                client.prepareGet(getTargetUrl())//
-                        .addCookie(coo)//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                List<Cookie> cookies = response.getCookies();
-                                assertEquals(cookies.size(), 1);
-                                assertEquals(cookies.get(0).toString(), "foo=value");
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void defaultRequestBodyEncodingIsIso() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                Response response = client.preparePost(getTargetUrl())//
-                        .setBody("\u017D\u017D\u017D\u017D\u017D\u017D")//
-                        .execute().get();
-                assertEquals(response.getResponseBodyAsBytes(), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes(ISO_8859_1));
-            });
-        });
-    }
-
-    @Test
-    public void postFormParametersAsBodyString() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-
-                StringBuilder sb = new StringBuilder();
-                for (int i = 0; i < 5; i++) {
-                    sb.append("param_").append(i).append("=value_").append(i).append("&");
-                }
-                sb.setLength(sb.length() - 1);
-
-                server.enqueueEcho();
-                client.preparePost(getTargetUrl())//
-                        .setHeaders(h)//
-                        .setBody(sb.toString())//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                for (int i = 1; i < 5; i++) {
-                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                                }
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void postFormParametersAsBodyStream() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-                StringBuilder sb = new StringBuilder();
-                for (int i = 0; i < 5; i++) {
-                    sb.append("param_").append(i).append("=value_").append(i).append("&");
-                }
-                sb.setLength(sb.length() - 1);
-
-                server.enqueueEcho();
-                client.preparePost(getTargetUrl())//
-                        .setHeaders(h)//
-                        .setBody(new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8)))//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                for (int i = 1; i < 5; i++) {
-                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                                }
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void putFormParametersAsBodyStream() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-                StringBuilder sb = new StringBuilder();
-                for (int i = 0; i < 5; i++) {
-                    sb.append("param_").append(i).append("=value_").append(i).append("&");
-                }
-                sb.setLength(sb.length() - 1);
-                ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-                server.enqueueEcho();
-                client.preparePut(getTargetUrl())//
-                        .setHeaders(h)//
-                        .setBody(is)//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                for (int i = 1; i < 5; i++) {
-                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                                }
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void postSingleStringPart() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                client.preparePost(getTargetUrl())//
-                        .addBodyPart(new StringPart("foo", "bar"))//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                String requestContentType = response.getHeader("X-" + CONTENT_TYPE);
-                                String boundary = requestContentType.substring((requestContentType.indexOf("boundary") + "boundary".length() + 1));
-                                assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void getVirtualHost() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                String virtualHost = "localhost:" + server.getHttpPort();
-
-                server.enqueueEcho();
-                Response response = client.prepareGet(getTargetUrl())//
-                        .setVirtualHost(virtualHost)//
-                        .execute(new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-
-                assertEquals(response.getStatusCode(), 200);
-                if (response.getHeader("X-" + HOST) == null) {
-                    System.err.println(response);
-                }
-                assertEquals(response.getHeader("X-" + HOST), virtualHost);
-            });
-        });
-    }
-
-    @Test(expectedExceptions = CancellationException.class)
-    public void cancelledFutureThrowsCancellationException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders headers = new DefaultHttpHeaders();
-                headers.add("X-Delay", 5_000);
-                server.enqueueEcho();
-
-                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public void onThrowable(Throwable t) {
-                    }
-                });
-                future.cancel(true);
-                future.get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void futureTimeOutThrowsTimeoutException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders headers = new DefaultHttpHeaders();
-                headers.add("X-Delay", 5_000);
-
-                server.enqueueEcho();
-                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public void onThrowable(Throwable t) {
-                    }
-                });
-
-                future.get(2, SECONDS);
-            });
-        });
-    }
-
-    @Test(expectedExceptions = ConnectException.class)
-    public void connectFailureThrowsConnectException() throws Throwable {
-        withClient().run(client -> {
-            int dummyPort = findFreePort();
-            try {
-                client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public void onThrowable(Throwable t) {
                     }
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
-            } catch (ExecutionException ex) {
-                throw ex.getCause();
-            }
-        });
-    }
-
-    @Test
-    public void connectFailureNotifiesHandlerWithConnectException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final CountDownLatch l = new CountDownLatch(1);
-                int port = findFreePort();
-
-                client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        try {
-                            assertTrue(t instanceof ConnectException);
-                        } finally {
-                            l.countDown();
-                        }
-                    }
-                });
-
-                if (!l.await(TIMEOUT, SECONDS)) {
-                    fail("Timed out");
-                }
-            });
-        });
-    }
-
-    @Test(expectedExceptions = UnknownHostException.class)
-    public void unknownHostThrowsUnknownHostException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                try {
-                    client.prepareGet("http://null.gatling.io").execute(new AsyncCompletionHandlerAdapter() {
-                        @Override
-                        public void onThrowable(Throwable t) {
-                        }
-                    }).get(TIMEOUT, SECONDS);
-                } catch (ExecutionException e) {
-                    throw e.getCause();
-                }
-            });
-        });
-    }
-
-    @Test
-    public void getEmptyBody() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueOk();
-                Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter())//
-                        .get(TIMEOUT, SECONDS);
-                assertTrue(response.getResponseBody().isEmpty());
-            });
-        });
-    }
-
-    @Test
-    public void getEmptyBodyNotifiesHandler() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final AtomicBoolean handlerWasNotified = new AtomicBoolean();
-
-                server.enqueueOk();
-                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertEquals(response.getStatusCode(), 200);
-                        handlerWasNotified.set(true);
-                        return response;
+      }));
+  }
+
+  @Test
+  public void putFormParametersAsBodyStream() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < 5; i++) {
+          sb.append("param_").append(i).append("=value_").append(i).append("&");
+        }
+        sb.setLength(sb.length() - 1);
+        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
+
+        server.enqueueEcho();
+        client.preparePut(getTargetUrl())
+                .setHeaders(h)
+                .setBody(is)
+                .execute(new AsyncCompletionHandlerAdapter() {
+
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    for (int i = 1; i < 5; i++) {
+                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
                     }
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
-                assertTrue(handlerWasNotified.get());
-            });
-        });
-    }
-
-    @Test
-    public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final CountDownLatch latch = new CountDownLatch(1);
-                final AtomicReference<String> message = new AtomicReference<>();
-
-                server.enqueueOk();
-                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToOnThrowable");
-
-                    }
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        message.set(t.getMessage());
-                        latch.countDown();
-                    }
-                });
-
-                if (!latch.await(TIMEOUT, SECONDS)) {
-                    fail("Timed out");
-                }
-
-                assertEquals(message.get(), "FOO");
-            });
-        });
-    }
-
-    @Test(expectedExceptions = IllegalStateException.class)
-    public void exceptionInOnCompletedGetNotifiedToFuture() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueOk();
-                Future<Response> whenResponse = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToFuture");
-                    }
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                    }
-                });
-
-                try {
-                    whenResponse.get(TIMEOUT, SECONDS);
-                } catch (ExecutionException e) {
-                    throw e.getCause();
-                }
-            });
-        });
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void configTimeoutNotifiesOnThrowableAndFuture() throws Throwable {
-        withClient(config().setRequestTimeout(1_000)).run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders headers = new DefaultHttpHeaders();
-                headers.add("X-Delay", 5_000); // delay greater than timeout
-
-                    final AtomicBoolean onCompletedWasNotified = new AtomicBoolean();
-                    final AtomicBoolean onThrowableWasNotifiedWithTimeoutException = new AtomicBoolean();
-                    final CountDownLatch latch = new CountDownLatch(1);
-
-                    server.enqueueEcho();
-                    Future<Response> whenResponse = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-
-                        @Override
-                        public Response onCompleted(Response response) throws Exception {
-                            onCompletedWasNotified.set(true);
-                            latch.countDown();
-                            return response;
-                        }
-
-                        @Override
-                        public void onThrowable(Throwable t) {
-                            onThrowableWasNotifiedWithTimeoutException.set(t instanceof TimeoutException);
-                            latch.countDown();
-                        }
-                    });
-
-                    if (!latch.await(TIMEOUT, SECONDS)) {
-                        fail("Timed out");
-                    }
-
-                    assertFalse(onCompletedWasNotified.get());
-                    assertTrue(onThrowableWasNotifiedWithTimeoutException.get());
-
-                    try {
-                        whenResponse.get(TIMEOUT, SECONDS);
-                    } catch (ExecutionException e) {
-                        throw e.getCause();
-                    }
-                });
-        });
-    }
-
-    @Test(expectedExceptions = TimeoutException.class)
-    public void configRequestTimeoutHappensInDueTime() throws Throwable {
-        withClient(config().setRequestTimeout(1_000)).run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-                h.add("X-Delay", 2_000);
-
-                server.enqueueEcho();
-                long start = unpreciseMillisTime();
-                try {
-                    client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
-                } catch (Throwable ex) {
-                    final long elapsedTime = unpreciseMillisTime() - start;
-                    assertTrue(elapsedTime >= 1_000 && elapsedTime <= 1_500);
-                    throw ex.getCause();
-                }
-            });
-        });
-    }
-
-    @Test
-    public void getProperPathAndQueryString() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                client.prepareGet(getTargetUrl() + "?foo=bar").execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        assertTrue(response.getHeader("X-PathInfo") != null);
-                        assertTrue(response.getHeader("X-QueryString") != null);
-                        return response;
-                    }
+      }));
+  }
+
+  @Test
+  public void postSingleStringPart() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        client.preparePost(getTargetUrl())
+                .addBodyPart(new StringPart("foo", "bar"))
+                .execute(new AsyncCompletionHandlerAdapter() {
+                  @Override
+                  public Response onCompleted(Response response) {
+                    String requestContentType = response.getHeader("X-" + CONTENT_TYPE);
+                    String boundary = requestContentType.substring((requestContentType.indexOf("boundary") + "boundary".length() + 1));
+                    assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
+                    return response;
+                  }
                 }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void connectionIsReusedForSequentialRequests() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                final CountDownLatch l = new CountDownLatch(2);
-
-                AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-                    volatile String clientPort;
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        try {
-                            assertEquals(response.getStatusCode(), 200);
-                            if (clientPort == null) {
-                                clientPort = response.getHeader("X-ClientPort");
-                            } else {
-                                // verify that the server saw the same client remote address/port
-                                // so the same connection was used
-                                assertEquals(response.getHeader("X-ClientPort"), clientPort);
-                            }
-                        } finally {
-                            l.countDown();
-                        }
-                        return response;
-                    }
-                };
-
-                server.enqueueEcho();
-                client.prepareGet(getTargetUrl()).execute(handler).get(TIMEOUT, SECONDS);
-                server.enqueueEcho();
-                client.prepareGet(getTargetUrl()).execute(handler);
-
-                if (!l.await(TIMEOUT, SECONDS)) {
-                    fail("Timed out");
-                }
-            });
-        });
-    }
+      }));
+  }
 
-    @Test(expectedExceptions = MaxRedirectException.class)
-    public void reachingMaxRedirectThrowsMaxRedirectException() throws Throwable {
-        withClient(config().setMaxRedirects(1).setFollowRedirect(true)).run(client -> {
+  @Test
+  public void postWithBody() throws Throwable {
+    withClient().run(client ->
             withServer(server).run(server -> {
-                try {
-                    // max redirect is 1, so second redirect will fail
-                    server.enqueueRedirect(301, getTargetUrl());
-                    server.enqueueRedirect(301, getTargetUrl());
-                    client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+              server.enqueueEcho();
+              client.preparePost(getTargetUrl())
+                      .execute(new AsyncCompletionHandlerAdapter() {
                         @Override
-                        public Response onCompleted(Response response) throws Exception {
-                            fail("Should not be here");
-                            return response;
-                        }
-
-                        @Override
-                        public void onThrowable(Throwable t) {
-                        }
-                    }).get(TIMEOUT, SECONDS);
-                } catch (ExecutionException e) {
-                    throw e.getCause();
-                }
-            });
-        });
-    }
-
-    @Test
-    public void nonBlockingNestedRequetsFromIoThreadAreFine() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-
-                final int maxNested = 5;
-
-                final CountDownLatch latch = new CountDownLatch(2);
-
-                final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
-
-                    private AtomicInteger nestedCount = new AtomicInteger(0);
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        try {
-                            if (nestedCount.getAndIncrement() < maxNested) {
-                                client.prepareGet(getTargetUrl()).execute(this);
-                            }
-                        } finally {
-                            latch.countDown();
+                        public Response onCompleted(Response response) {
+                          assertEquals(response.getHeader("X-" + CONTENT_LENGTH), "0");
+                          return response;
                         }
-                        return response;
-                    }
-                };
-
-                for (int i = 0; i < maxNested + 1; i++) {
-                    server.enqueueOk();
-                }
-
-                client.prepareGet(getTargetUrl()).execute(handler);
-
-                if (!latch.await(TIMEOUT, SECONDS)) {
-                    fail("Timed out");
-                }
-            });
-        });
-    }
-
-    @Test
-    public void optionsIsSupported() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                Response response = client.prepareOptions(getTargetUrl()).execute().get();
-                assertEquals(response.getStatusCode(), 200);
-                assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
-            });
-        });
-    }
-
-    @Test
-    public void cancellingFutureNotifiesOnThrowableWithCancellationException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-                h.add("X-Delay", 2_000);
-
-                CountDownLatch latch = new CountDownLatch(1);
-
-                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody("Body").execute(new AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        if (t instanceof CancellationException) {
-                            latch.countDown();
-                        }
-                    }
-                });
+                      }).get(TIMEOUT, SECONDS);
+            }));
+  }
+
+  @Test
+  public void getVirtualHost() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        String virtualHost = "localhost:" + server.getHttpPort();
+
+        server.enqueueEcho();
+        Response response = client.prepareGet(getTargetUrl())
+                .setVirtualHost(virtualHost)
+                .execute(new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+
+        assertEquals(response.getStatusCode(), 200);
+        if (response.getHeader("X-" + HOST) == null) {
+          System.err.println(response);
+        }
+        assertEquals(response.getHeader("X-" + HOST), virtualHost);
+      }));
+  }
+
+  @Test(expectedExceptions = CancellationException.class)
+  public void cancelledFutureThrowsCancellationException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders headers = new DefaultHttpHeaders();
+        headers.add("X-Delay", 5_000);
+        server.enqueueEcho();
+
+        Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public void onThrowable(Throwable t) {
+          }
+        });
+        future.cancel(true);
+        future.get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void futureTimeOutThrowsTimeoutException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders headers = new DefaultHttpHeaders();
+        headers.add("X-Delay", 5_000);
+
+        server.enqueueEcho();
+        Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public void onThrowable(Throwable t) {
+          }
+        });
+
+        future.get(2, SECONDS);
+      }));
+  }
+
+  @Test(expectedExceptions = ConnectException.class)
+  public void connectFailureThrowsConnectException() throws Throwable {
+    withClient().run(client -> {
+      int dummyPort = findFreePort();
+      try {
+        client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public void onThrowable(Throwable t) {
+          }
+        }).get(TIMEOUT, SECONDS);
+      } catch (ExecutionException ex) {
+        throw ex.getCause();
+      }
+    });
+  }
+
+  @Test
+  public void connectFailureNotifiesHandlerWithConnectException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final CountDownLatch l = new CountDownLatch(1);
+        int port = findFreePort();
+
+        client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public void onThrowable(Throwable t) {
+            try {
+              assertTrue(t instanceof ConnectException);
+            } finally {
+              l.countDown();
+            }
+          }
+        });
+
+        if (!l.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+      }));
+  }
+
+  @Test(expectedExceptions = UnknownHostException.class)
+  public void unknownHostThrowsUnknownHostException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        try {
+          client.prepareGet("http://null.gatling.io").execute(new AsyncCompletionHandlerAdapter() {
+            @Override
+            public void onThrowable(Throwable t) {
+            }
+          }).get(TIMEOUT, SECONDS);
+        } catch (ExecutionException e) {
+          throw e.getCause();
+        }
+      }));
+  }
+
+  @Test
+  public void getEmptyBody() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueOk();
+        Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter())
+                .get(TIMEOUT, SECONDS);
+        assertTrue(response.getResponseBody().isEmpty());
+      }));
+  }
+
+  @Test
+  public void getEmptyBodyNotifiesHandler() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final AtomicBoolean handlerWasNotified = new AtomicBoolean();
+
+        server.enqueueOk();
+        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public Response onCompleted(Response response) {
+            assertEquals(response.getStatusCode(), 200);
+            handlerWasNotified.set(true);
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+        assertTrue(handlerWasNotified.get());
+      }));
+  }
+
+  @Test
+  public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<String> message = new AtomicReference<>();
+
+        server.enqueueOk();
+        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public Response onCompleted(Response response) {
+            throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToOnThrowable");
+
+          }
+
+          @Override
+          public void onThrowable(Throwable t) {
+            message.set(t.getMessage());
+            latch.countDown();
+          }
+        });
+
+        if (!latch.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+
+        assertEquals(message.get(), "FOO");
+      }));
+  }
+
+  @Test(expectedExceptions = IllegalStateException.class)
+  public void exceptionInOnCompletedGetNotifiedToFuture() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueOk();
+        Future<Response> whenResponse = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public Response onCompleted(Response response) {
+            throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToFuture");
+          }
+
+          @Override
+          public void onThrowable(Throwable t) {
+          }
+        });
+
+        try {
+          whenResponse.get(TIMEOUT, SECONDS);
+        } catch (ExecutionException e) {
+          throw e.getCause();
+        }
+      }));
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void configTimeoutNotifiesOnThrowableAndFuture() throws Throwable {
+    withClient(config().setRequestTimeout(1_000)).run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders headers = new DefaultHttpHeaders();
+        headers.add("X-Delay", 5_000); // delay greater than timeout
+
+        final AtomicBoolean onCompletedWasNotified = new AtomicBoolean();
+        final AtomicBoolean onThrowableWasNotifiedWithTimeoutException = new AtomicBoolean();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        server.enqueueEcho();
+        Future<Response> whenResponse = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public Response onCompleted(Response response) {
+            onCompletedWasNotified.set(true);
+            latch.countDown();
+            return response;
+          }
+
+          @Override
+          public void onThrowable(Throwable t) {
+            onThrowableWasNotifiedWithTimeoutException.set(t instanceof TimeoutException);
+            latch.countDown();
+          }
+        });
+
+        if (!latch.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+
+        assertFalse(onCompletedWasNotified.get());
+        assertTrue(onThrowableWasNotifiedWithTimeoutException.get());
+
+        try {
+          whenResponse.get(TIMEOUT, SECONDS);
+        } catch (ExecutionException e) {
+          throw e.getCause();
+        }
+      }));
+  }
+
+  @Test(expectedExceptions = TimeoutException.class)
+  public void configRequestTimeoutHappensInDueTime() throws Throwable {
+    withClient(config().setRequestTimeout(1_000)).run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+        h.add("X-Delay", 2_000);
+
+        server.enqueueEcho();
+        long start = unpreciseMillisTime();
+        try {
+          client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
+        } catch (Throwable ex) {
+          final long elapsedTime = unpreciseMillisTime() - start;
+          assertTrue(elapsedTime >= 1_000 && elapsedTime <= 1_500);
+          throw ex.getCause();
+        }
+      }));
+  }
+
+  @Test
+  public void getProperPathAndQueryString() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        client.prepareGet(getTargetUrl() + "?foo=bar").execute(new AsyncCompletionHandlerAdapter() {
+          @Override
+          public Response onCompleted(Response response) {
+            assertTrue(response.getHeader("X-PathInfo") != null);
+            assertTrue(response.getHeader("X-QueryString") != null);
+            return response;
+          }
+        }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void connectionIsReusedForSequentialRequests() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        final CountDownLatch l = new CountDownLatch(2);
+
+        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+          volatile String clientPort;
+
+          @Override
+          public Response onCompleted(Response response) {
+            try {
+              assertEquals(response.getStatusCode(), 200);
+              if (clientPort == null) {
+                clientPort = response.getHeader("X-ClientPort");
+              } else {
+                // verify that the server saw the same client remote address/port
+                // so the same connection was used
+                assertEquals(response.getHeader("X-ClientPort"), clientPort);
+              }
+            } finally {
+              l.countDown();
+            }
+            return response;
+          }
+        };
+
+        server.enqueueEcho();
+        client.prepareGet(getTargetUrl()).execute(handler).get(TIMEOUT, SECONDS);
+        server.enqueueEcho();
+        client.prepareGet(getTargetUrl()).execute(handler);
+
+        if (!l.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+      }));
+  }
+
+  @Test(expectedExceptions = MaxRedirectException.class)
+  public void reachingMaxRedirectThrowsMaxRedirectException() throws Throwable {
+    withClient(config().setMaxRedirects(1).setFollowRedirect(true)).run(client ->
+      withServer(server).run(server -> {
+        try {
+          // max redirect is 1, so second redirect will fail
+          server.enqueueRedirect(301, getTargetUrl());
+          server.enqueueRedirect(301, getTargetUrl());
+          client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+            @Override
+            public Response onCompleted(Response response) {
+              fail("Should not be here");
+              return response;
+            }
 
-                future.cancel(true);
-                if (!latch.await(TIMEOUT, SECONDS)) {
-                    fail("Timed out");
-                }
-            });
-        });
-    }
+            @Override
+            public void onThrowable(Throwable t) {
+            }
+          }).get(TIMEOUT, SECONDS);
+        } catch (ExecutionException e) {
+          throw e.getCause();
+        }
+      }));
+  }
 
-    @Test
-    public void getShouldAllowBody() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
-            });
-        });
-    }
+  @Test
+  public void nonBlockingNestedRequetsFromIoThreadAreFine() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
 
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void malformedUriThrowsException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                client.prepareGet(String.format("http:localhost:%d/foo/test", server.getHttpPort())).build();
-            });
-        });
-    }
+        final int maxNested = 5;
 
-    @Test
-    public void emptyResponseBodyBytesAreEmpty() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                Response response = client.prepareGet(getTargetUrl()).execute().get();
-                assertEquals(response.getStatusCode(), 200);
-                assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
-            });
-        });
-    }
+        final CountDownLatch latch = new CountDownLatch(2);
 
-    @Test
-    public void newConnectionEventsAreFired() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
+        final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
 
-                Request request = get(getTargetUrl()).build();
-
-                EventCollectingHandler handler = new EventCollectingHandler();
-                client.executeRequest(request, handler).get(3, SECONDS);
-                handler.waitForCompletion(3, SECONDS);
-
-                Object[] expectedEvents = new Object[] {//
-                CONNECTION_POOL_EVENT,//
-                        HOSTNAME_RESOLUTION_EVENT,//
-                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
-                        CONNECTION_OPEN_EVENT,//
-                        CONNECTION_SUCCESS_EVENT,//
-                        REQUEST_SEND_EVENT,//
-                        HEADERS_WRITTEN_EVENT,//
-                        STATUS_RECEIVED_EVENT,//
-                        HEADERS_RECEIVED_EVENT,//
-                        CONNECTION_OFFER_EVENT,//
-                        COMPLETED_EVENT };
-
-                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-            });
-        });
-    }
+          private AtomicInteger nestedCount = new AtomicInteger(0);
 
-    @Test
-    public void requestingPlainHttpEndpointOverHttpsThrowsSslException() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                try {
-                    client.prepareGet(getTargetUrl().replace("http", "https")).execute().get();
-                    fail("Request shouldn't succeed");
-                } catch (ExecutionException e) {
-                    assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
-                    assertTrue(e.getCause().getCause() instanceof SSLException, "Root cause should be a SslException");
-                }
-            });
-        });
-    }
-
-    @Test
-    public void postUnboundedInputStreamAsBodyStream() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
-                server.enqueue(new AbstractHandler() {
-                    EchoHandler chain = new EchoHandler();
-
-                    @Override
-                    public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
-                            throws IOException, ServletException {
-                        assertEquals(request.getHeader(TRANSFER_ENCODING.toString()), HttpHeaderValues.CHUNKED.toString());
-                        assertNull(request.getHeader(CONTENT_LENGTH.toString()));
-                        chain.handle(target, request, httpServletRequest, httpServletResponse);
-                    }
-                });
-                server.enqueueEcho();
-
-                client.preparePost(getTargetUrl())//
-                        .setHeaders(h)//
-                        .setBody(new ByteArrayInputStream("{}".getBytes(StandardCharsets.ISO_8859_1)))//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                assertEquals(response.getResponseBody(), "{}");
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
-
-    @Test
-    public void postInputStreamWithContentLengthAsBodyGenerator() throws Throwable {
-        withClient().run(client -> {
-            withServer(server).run(server -> {
-                HttpHeaders h = new DefaultHttpHeaders();
-                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
-                server.enqueue(new AbstractHandler() {
-                    EchoHandler chain = new EchoHandler();
-
-                    @Override
-                    public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
-                            throws IOException, ServletException {
-                        assertNull(request.getHeader(TRANSFER_ENCODING.toString()));
-                        assertEquals(request.getHeader(CONTENT_LENGTH.toString()),//
-                                Integer.toString("{}".getBytes(StandardCharsets.ISO_8859_1).length));
-                        chain.handle(target, request, httpServletRequest, httpServletResponse);
-                    }
-                });
-
-                byte[] bodyBytes = "{}".getBytes(StandardCharsets.ISO_8859_1);
-                InputStream bodyStream = new ByteArrayInputStream(bodyBytes);
-
-                client.preparePost(getTargetUrl())//
-                        .setHeaders(h)//
-                        .setBody(new InputStreamBodyGenerator(bodyStream, bodyBytes.length))//
-                        .execute(new AsyncCompletionHandlerAdapter() {
-
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                assertEquals(response.getStatusCode(), 200);
-                                assertEquals(response.getResponseBody(), "{}");
-                                return response;
-                            }
-                        }).get(TIMEOUT, SECONDS);
-            });
-        });
-    }
+          @Override
+          public Response onCompleted(Response response) {
+            try {
+              if (nestedCount.getAndIncrement() < maxNested) {
+                client.prepareGet(getTargetUrl()).execute(this);
+              }
+            } finally {
+              latch.countDown();
+            }
+            return response;
+          }
+        };
+
+        for (int i = 0; i < maxNested + 1; i++) {
+          server.enqueueOk();
+        }
+
+        client.prepareGet(getTargetUrl()).execute(handler);
+
+        if (!latch.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+      }));
+  }
+
+  @Test
+  public void optionsIsSupported() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        Response response = client.prepareOptions(getTargetUrl()).execute().get();
+        assertEquals(response.getStatusCode(), 200);
+        assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+      }));
+  }
+
+  @Test
+  public void cancellingFutureNotifiesOnThrowableWithCancellationException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+        h.add("X-Delay", 2_000);
+
+        CountDownLatch latch = new CountDownLatch(1);
+
+        Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody("Body").execute(new AsyncCompletionHandlerAdapter() {
+
+          @Override
+          public void onThrowable(Throwable t) {
+            if (t instanceof CancellationException) {
+              latch.countDown();
+            }
+          }
+        });
+
+        future.cancel(true);
+        if (!latch.await(TIMEOUT, SECONDS)) {
+          fail("Timed out");
+        }
+      }));
+  }
+
+  @Test
+  public void getShouldAllowBody() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server ->
+        client.prepareGet(getTargetUrl()).setBody("Boo!").execute()));
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void malformedUriThrowsException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> client.prepareGet(String.format("http:localhost:%d/foo/test", server.getHttpPort())).build()));
+  }
+
+  @Test
+  public void emptyResponseBodyBytesAreEmpty() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        Response response = client.prepareGet(getTargetUrl()).execute().get();
+        assertEquals(response.getStatusCode(), 200);
+        assertEquals(response.getResponseBodyAsBytes(), new byte[]{});
+      }));
+  }
+
+  @Test
+  public void newConnectionEventsAreFired() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+
+        Request request = get(getTargetUrl()).build();
+
+        EventCollectingHandler handler = new EventCollectingHandler();
+        client.executeRequest(request, handler).get(3, SECONDS);
+        handler.waitForCompletion(3, SECONDS);
+
+        Object[] expectedEvents = new Object[]{
+                CONNECTION_POOL_EVENT,
+                HOSTNAME_RESOLUTION_EVENT,
+                HOSTNAME_RESOLUTION_SUCCESS_EVENT,
+                CONNECTION_OPEN_EVENT,
+                CONNECTION_SUCCESS_EVENT,
+                REQUEST_SEND_EVENT,
+                HEADERS_WRITTEN_EVENT,
+                STATUS_RECEIVED_EVENT,
+                HEADERS_RECEIVED_EVENT,
+                CONNECTION_OFFER_EVENT,
+                COMPLETED_EVENT};
+
+        assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+      }));
+  }
+
+  @Test
+  public void requestingPlainHttpEndpointOverHttpsThrowsSslException() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        try {
+          client.prepareGet(getTargetUrl().replace("http", "https")).execute().get();
+          fail("Request shouldn't succeed");
+        } catch (ExecutionException e) {
+          assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
+          assertTrue(e.getCause().getCause() instanceof SSLException, "Root cause should be a SslException");
+        }
+      }));
+  }
+
+  @Test
+  public void postUnboundedInputStreamAsBodyStream() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
+        server.enqueue(new AbstractHandler() {
+          EchoHandler chain = new EchoHandler();
+
+          @Override
+          public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
+                  throws IOException, ServletException {
+            assertEquals(request.getHeader(TRANSFER_ENCODING.toString()), HttpHeaderValues.CHUNKED.toString());
+            assertNull(request.getHeader(CONTENT_LENGTH.toString()));
+            chain.handle(target, request, httpServletRequest, httpServletResponse);
+          }
+        });
+        server.enqueueEcho();
+
+        client.preparePost(getTargetUrl())
+                .setHeaders(h)
+                .setBody(new ByteArrayInputStream("{}".getBytes(StandardCharsets.ISO_8859_1)))
+                .execute(new AsyncCompletionHandlerAdapter() {
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    assertEquals(response.getResponseBody(), "{}");
+                    return response;
+                  }
+                }).get(TIMEOUT, SECONDS);
+      }));
+  }
+
+  @Test
+  public void postInputStreamWithContentLengthAsBodyGenerator() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        HttpHeaders h = new DefaultHttpHeaders();
+        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
+        server.enqueue(new AbstractHandler() {
+          EchoHandler chain = new EchoHandler();
+
+          @Override
+          public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
+                  throws IOException, ServletException {
+            assertNull(request.getHeader(TRANSFER_ENCODING.toString()));
+            assertEquals(request.getHeader(CONTENT_LENGTH.toString()),
+                    Integer.toString("{}".getBytes(StandardCharsets.ISO_8859_1).length));
+            chain.handle(target, request, httpServletRequest, httpServletResponse);
+          }
+        });
+
+        byte[] bodyBytes = "{}".getBytes(StandardCharsets.ISO_8859_1);
+        InputStream bodyStream = new ByteArrayInputStream(bodyBytes);
+
+        client.preparePost(getTargetUrl())
+                .setHeaders(h)
+                .setBody(new InputStreamBodyGenerator(bodyStream, bodyBytes.length))
+                .execute(new AsyncCompletionHandlerAdapter() {
+
+                  @Override
+                  public Response onCompleted(Response response) {
+                    assertEquals(response.getStatusCode(), 200);
+                    assertEquals(response.getResponseBody(), "{}");
+                    return response;
+                  }
+                }).get(TIMEOUT, SECONDS);
+      }));
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 40c01f048..216e26043 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -15,21 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-
-import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.net.ssl.SSLHandshakeException;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.asynchttpclient.testserver.HttpServer;
@@ -38,185 +23,186 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.net.ssl.SSLHandshakeException;
+import javax.servlet.http.HttpServletResponse;
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 public class BasicHttpsTest extends HttpTest {
 
-    private static HttpServer server;
-
-    @BeforeClass
-    public static void start() throws Throwable {
-        server = new HttpServer();
-        server.start();
-    }
-
-    @AfterClass
-    public static void stop() throws Throwable {
-        server.close();
-    }
-
-    private static String getTargetUrl() {
-        return server.getHttpsUrl() + "/foo/bar";
-    }
-
-    @Test
-    public void postFileOverHttps() throws Throwable {
-        logger.debug(">>> postBodyOverHttps");
-        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-
-                Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader(CONTENT_TYPE, "text/html").execute().get();
-                assertNotNull(resp);
-                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-                assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-            });
-        });
-        logger.debug("<<< postBodyOverHttps");
-    }
-    
-    @Test
-    public void postLargeFileOverHttps() throws Throwable {
-        logger.debug(">>> postLargeFileOverHttps");
-        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-
-                Response resp = client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_FILE).setHeader(CONTENT_TYPE, "image/png").execute().get();
-                assertNotNull(resp);
-                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-                assertEquals(resp.getResponseBodyAsBytes().length, LARGE_IMAGE_FILE.length());
-            });
-        });
-        logger.debug("<<< postLargeFileOverHttps");
-    }
-
-    @Test
-    public void multipleSequentialPostRequestsOverHttps() throws Throwable {
-        logger.debug(">>> multipleSequentialPostRequestsOverHttps");
-        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                server.enqueueEcho();
-
-                String body = "hello there";
-                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-                assertEquals(response.getResponseBody(), body);
-
-                response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-                assertEquals(response.getResponseBody(), body);
-            });
-        });
-        logger.debug("<<< multipleSequentialPostRequestsOverHttps");
-    }
-
-    @Test
-    public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
-        logger.debug(">>> multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
-
-        KeepAliveStrategy keepAliveStrategy = new KeepAliveStrategy() {
-            @Override
-            public boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse) {
-                return !ahcRequest.getUri().isSecured();
-            }
-        };
-
-        withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                server.enqueueEcho();
-                server.enqueueEcho();
-
-                String body = "hello there";
-
-                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
-                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
-
-                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get();
-                assertEquals(response.getResponseBody(), body);
-            });
-        });
-
-        logger.debug("<<< multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
-    }
-
-    @Test
-    public void reconnectAfterFailedCertificationPath() throws Throwable {
-        logger.debug(">>> reconnectAfterFailedCertificationPath");
-
-        AtomicBoolean trust = new AtomicBoolean();
-
-        withClient(config().setMaxRequestRetry(0).setSslEngineFactory(createSslEngineFactory(trust))).run(client -> {
-            withServer(server).run(server -> {
-                server.enqueueEcho();
-                server.enqueueEcho();
-
-                String body = "hello there";
-
-                // first request fails because server certificate is rejected
-                    Throwable cause = null;
-                    try {
-                        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-                    } catch (final ExecutionException e) {
-                        cause = e.getCause();
-                    }
-                    assertNotNull(cause);
-
-                    // second request should succeed
-                    trust.set(true);
-                    Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-
-                    assertEquals(response.getResponseBody(), body);
-                });
-        });
-        logger.debug("<<< reconnectAfterFailedCertificationPath");
-    }
-
-    @Test(timeOut = 2000, expectedExceptions = SSLHandshakeException.class)
-    public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
-        logger.debug(">>> failInstantlyIfNotAllowedSelfSignedCertificate");
-
-        withClient(config().setMaxRequestRetry(0).setRequestTimeout(2000)).run(client -> {
-            withServer(server).run(server -> {
-                try {
-                    client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, SECONDS);
-                } catch (ExecutionException e) {
-                    throw e.getCause().getCause();
-                }
-            });
-        });
-        logger.debug("<<< failInstantlyIfNotAllowedSelfSignedCertificate");
-
-    }
-
-    @Test(groups = "standalone")
-    public void testNormalEventsFired() throws Throwable {
-        logger.debug(">>> testNormalEventsFired");
-
-        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
-            withServer(server).run(server -> {
-                EventCollectingHandler handler = new EventCollectingHandler();
-
-                server.enqueueEcho();
-                client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, SECONDS);
-                handler.waitForCompletion(3, SECONDS);
-
-                Object[] expectedEvents = new Object[] { //
-                CONNECTION_POOL_EVENT,//
-                        HOSTNAME_RESOLUTION_EVENT,//
-                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
-                        CONNECTION_OPEN_EVENT,//
-                        CONNECTION_SUCCESS_EVENT,//
-                        TLS_HANDSHAKE_EVENT,//
-                        TLS_HANDSHAKE_SUCCESS_EVENT,//
-                        REQUEST_SEND_EVENT,//
-                        HEADERS_WRITTEN_EVENT,//
-                        STATUS_RECEIVED_EVENT,//
-                        HEADERS_RECEIVED_EVENT,//
-                        CONNECTION_OFFER_EVENT,//
-                        COMPLETED_EVENT };
-
-                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-            });
-        });
-        logger.debug("<<< testNormalEventsFired");
-    }
+  private static HttpServer server;
+
+  @BeforeClass
+  public static void start() throws Throwable {
+    server = new HttpServer();
+    server.start();
+  }
+
+  @AfterClass
+  public static void stop() throws Throwable {
+    server.close();
+  }
+
+  private static String getTargetUrl() {
+    return server.getHttpsUrl() + "/foo/bar";
+  }
+
+  @Test
+  public void postFileOverHttps() throws Throwable {
+    logger.debug(">>> postBodyOverHttps");
+    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+
+        Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader(CONTENT_TYPE, "text/html").execute().get();
+        assertNotNull(resp);
+        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+      }));
+    logger.debug("<<< postBodyOverHttps");
+  }
+
+  @Test
+  public void postLargeFileOverHttps() throws Throwable {
+    logger.debug(">>> postLargeFileOverHttps");
+    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+
+        Response resp = client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_FILE).setHeader(CONTENT_TYPE, "image/png").execute().get();
+        assertNotNull(resp);
+        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        assertEquals(resp.getResponseBodyAsBytes().length, LARGE_IMAGE_FILE.length());
+      }));
+    logger.debug("<<< postLargeFileOverHttps");
+  }
+
+  @Test
+  public void multipleSequentialPostRequestsOverHttps() throws Throwable {
+    logger.debug(">>> multipleSequentialPostRequestsOverHttps");
+    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        server.enqueueEcho();
+
+        String body = "hello there";
+        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+        assertEquals(response.getResponseBody(), body);
+
+        response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+        assertEquals(response.getResponseBody(), body);
+      }));
+    logger.debug("<<< multipleSequentialPostRequestsOverHttps");
+  }
+
+  @Test
+  public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
+    logger.debug(">>> multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
+
+    KeepAliveStrategy keepAliveStrategy = (ahcRequest, nettyRequest, nettyResponse) -> !ahcRequest.getUri().isSecured();
+
+    withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        server.enqueueEcho();
+        server.enqueueEcho();
+
+        String body = "hello there";
+
+        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
+        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
+
+        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get();
+        assertEquals(response.getResponseBody(), body);
+      }));
+
+    logger.debug("<<< multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
+  }
+
+  @Test
+  public void reconnectAfterFailedCertificationPath() throws Throwable {
+    logger.debug(">>> reconnectAfterFailedCertificationPath");
+
+    AtomicBoolean trust = new AtomicBoolean();
+
+    withClient(config().setMaxRequestRetry(0).setSslEngineFactory(createSslEngineFactory(trust))).run(client ->
+      withServer(server).run(server -> {
+        server.enqueueEcho();
+        server.enqueueEcho();
+
+        String body = "hello there";
+
+        // first request fails because server certificate is rejected
+        Throwable cause = null;
+        try {
+          client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+        } catch (final ExecutionException e) {
+          cause = e.getCause();
+        }
+        assertNotNull(cause);
+
+        // second request should succeed
+        trust.set(true);
+        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+
+        assertEquals(response.getResponseBody(), body);
+      }));
+    logger.debug("<<< reconnectAfterFailedCertificationPath");
+  }
+
+  @Test(timeOut = 2000, expectedExceptions = SSLHandshakeException.class)
+  public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
+    logger.debug(">>> failInstantlyIfNotAllowedSelfSignedCertificate");
+
+    withClient(config().setMaxRequestRetry(0).setRequestTimeout(2000)).run(client ->
+      withServer(server).run(server -> {
+        try {
+          client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, SECONDS);
+        } catch (ExecutionException e) {
+          throw e.getCause().getCause();
+        }
+      }));
+    logger.debug("<<< failInstantlyIfNotAllowedSelfSignedCertificate");
+
+  }
+
+  @Test
+  public void testNormalEventsFired() throws Throwable {
+    logger.debug(">>> testNormalEventsFired");
+
+    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
+      withServer(server).run(server -> {
+        EventCollectingHandler handler = new EventCollectingHandler();
+
+        server.enqueueEcho();
+        client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, SECONDS);
+        handler.waitForCompletion(3, SECONDS);
+
+        Object[] expectedEvents = new Object[]{
+                CONNECTION_POOL_EVENT,
+                HOSTNAME_RESOLUTION_EVENT,
+                HOSTNAME_RESOLUTION_SUCCESS_EVENT,
+                CONNECTION_OPEN_EVENT,
+                CONNECTION_SUCCESS_EVENT,
+                TLS_HANDSHAKE_EVENT,
+                TLS_HANDSHAKE_SUCCESS_EVENT,
+                REQUEST_SEND_EVENT,
+                HEADERS_WRITTEN_EVENT,
+                STATUS_RECEIVED_EVENT,
+                HEADERS_RECEIVED_EVENT,
+                CONNECTION_OFFER_EVENT,
+                COMPLETED_EVENT};
+
+        assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+      }));
+    logger.debug("<<< testNormalEventsFired");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 487faa8de..4a60e6521 100644
--- a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
+++ b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -12,10 +12,13 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -23,75 +26,72 @@
 import java.util.Enumeration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 public class ByteBufferCapacityTest extends AbstractBasicTest {
 
-    private class BasicHandler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                final InputStream in = httpRequest.getInputStream();
-                final OutputStream out = httpResponse.getOutputStream();
-                int read;
-                while ((read = in.read(bytes)) != -1) {
-                    out.write(bytes, 0, read);
-                }
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new BasicHandler();
+  }
+
+  @Test
+  public void basicByteBufferTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      File largeFile = createTempFile(1024 * 100 * 10);
+      final AtomicInteger byteReceived = new AtomicInteger();
+
+      Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
+        @Override
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+          byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
+          return super.onBodyPartReceived(content);
         }
-    }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new BasicHandler();
-    }
-
-    @Test(groups = "standalone")
-    public void basicByteBufferTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            File largeFile = createTempFile(1024 * 100 * 10);
-            final AtomicInteger byteReceived = new AtomicInteger();
-
-            Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                    byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
-                    return super.onBodyPartReceived(content);
-                }
+      }).get();
 
-            }).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(byteReceived.get(), largeFile.length());
-            assertEquals(response.getResponseBody().length(), largeFile.length());
-        }
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(byteReceived.get(), largeFile.length());
+      assertEquals(response.getResponseBody().length(), largeFile.length());
     }
+  }
+
+  public String getTargetUrl() {
+    return String.format("http://localhost:%d/foo/test", port1);
+  }
+
+  private class BasicHandler extends AbstractHandler {
+
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      String param;
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
+        httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+      }
+
+      int size = 10 * 1024;
+      if (httpRequest.getContentLength() > 0) {
+        size = httpRequest.getContentLength();
+      }
+      byte[] bytes = new byte[size];
+      if (bytes.length > 0) {
+        final InputStream in = httpRequest.getInputStream();
+        final OutputStream out = httpResponse.getOutputStream();
+        int read;
+        while ((read = in.read(bytes)) != -1) {
+          out.write(bytes, 0, read);
+        }
+      }
 
-    public String getTargetUrl() {
-        return String.format("http://localhost:%d/foo/test", port1);
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ClientStatsTest.java b/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
index 10c04d10d..64dfff737 100644
--- a/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
+++ b/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
@@ -13,173 +13,173 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
+import org.testng.annotations.Test;
 
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 /**
  * Created by grenville on 9/25/16.
  */
 public class ClientStatsTest extends AbstractBasicTest {
 
-    private final static String hostname = "localhost";
+  private final static String hostname = "localhost";
 
-    @Test(groups = "standalone")
-    public void testClientStatus() throws Throwable {
-        try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setPooledConnectionIdleTimeout(5000))) {
-            final String url = getTargetUrl();
+  @Test
+  public void testClientStatus() throws Throwable {
+    try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setPooledConnectionIdleTimeout(5000))) {
+      final String url = getTargetUrl();
 
-            final ClientStats emptyStats = client.getClientStats();
+      final ClientStats emptyStats = client.getClientStats();
 
-            assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-            assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(emptyStats.getTotalConnectionCount(), 0);
-            assertNull(emptyStats.getStatsPerHost().get(hostname));
+      assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+      assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(emptyStats.getTotalConnectionCount(), 0);
+      assertNull(emptyStats.getStatsPerHost().get(hostname));
 
-            final List<ListenableFuture<Response>> futures =
-                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
-                            .limit(5)
-                            .collect(Collectors.toList());
+      final List<ListenableFuture<Response>> futures =
+              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
+                      .limit(5)
+                      .collect(Collectors.toList());
 
-            Thread.sleep(2000);
+      Thread.sleep(2000);
 
-            final ClientStats activeStats = client.getClientStats();
+      final ClientStats activeStats = client.getClientStats();
 
-            assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
-            assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
-            assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(activeStats.getTotalConnectionCount(), 5);
-            assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+      assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
+      assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
+      assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(activeStats.getTotalConnectionCount(), 5);
+      assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-            futures.forEach(future -> future.toCompletableFuture().join());
+      futures.forEach(future -> future.toCompletableFuture().join());
 
-            Thread.sleep(1000);
+      Thread.sleep(1000);
 
-            final ClientStats idleStats = client.getClientStats();
+      final ClientStats idleStats = client.getClientStats();
 
-            assertEquals(idleStats.toString(), "There are 5 total connections, 0 are active and 5 are idle.");
-            assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(idleStats.getTotalIdleConnectionCount(), 5);
-            assertEquals(idleStats.getTotalConnectionCount(), 5);
-            assertEquals(idleStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+      assertEquals(idleStats.toString(), "There are 5 total connections, 0 are active and 5 are idle.");
+      assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(idleStats.getTotalIdleConnectionCount(), 5);
+      assertEquals(idleStats.getTotalConnectionCount(), 5);
+      assertEquals(idleStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-            // Let's make sure the active count is correct when reusing cached connections.
+      // Let's make sure the active count is correct when reusing cached connections.
 
-            final List<ListenableFuture<Response>> repeatedFutures =
-                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
-                            .limit(3)
-                            .collect(Collectors.toList());
+      final List<ListenableFuture<Response>> repeatedFutures =
+              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
+                      .limit(3)
+                      .collect(Collectors.toList());
 
-            Thread.sleep(2000);
+      Thread.sleep(2000);
 
-            final ClientStats activeCachedStats = client.getClientStats();
+      final ClientStats activeCachedStats = client.getClientStats();
 
-            assertEquals(activeCachedStats.toString(), "There are 5 total connections, 3 are active and 2 are idle.");
-            assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
-            assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 2);
-            assertEquals(activeCachedStats.getTotalConnectionCount(), 5);
-            assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+      assertEquals(activeCachedStats.toString(), "There are 5 total connections, 3 are active and 2 are idle.");
+      assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
+      assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 2);
+      assertEquals(activeCachedStats.getTotalConnectionCount(), 5);
+      assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-            repeatedFutures.forEach(future -> future.toCompletableFuture().join());
+      repeatedFutures.forEach(future -> future.toCompletableFuture().join());
 
-            Thread.sleep(1000);
+      Thread.sleep(1000);
 
-            final ClientStats idleCachedStats = client.getClientStats();
+      final ClientStats idleCachedStats = client.getClientStats();
 
-            assertEquals(idleCachedStats.toString(), "There are 3 total connections, 0 are active and 3 are idle.");
-            assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 3);
-            assertEquals(idleCachedStats.getTotalConnectionCount(), 3);
-            assertEquals(idleCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
+      assertEquals(idleCachedStats.toString(), "There are 3 total connections, 0 are active and 3 are idle.");
+      assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 3);
+      assertEquals(idleCachedStats.getTotalConnectionCount(), 3);
+      assertEquals(idleCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
 
-            Thread.sleep(5000);
+      Thread.sleep(5000);
 
-            final ClientStats timeoutStats = client.getClientStats();
+      final ClientStats timeoutStats = client.getClientStats();
 
-            assertEquals(timeoutStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-            assertEquals(timeoutStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(timeoutStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(timeoutStats.getTotalConnectionCount(), 0);
-            assertNull(timeoutStats.getStatsPerHost().get(hostname));
-        }
+      assertEquals(timeoutStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+      assertEquals(timeoutStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(timeoutStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(timeoutStats.getTotalConnectionCount(), 0);
+      assertNull(timeoutStats.getStatsPerHost().get(hostname));
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testClientStatusNoKeepalive() throws Throwable {
-        try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
-            final String url = getTargetUrl();
+  @Test
+  public void testClientStatusNoKeepalive() throws Throwable {
+    try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
+      final String url = getTargetUrl();
 
-            final ClientStats emptyStats = client.getClientStats();
+      final ClientStats emptyStats = client.getClientStats();
 
-            assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-            assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(emptyStats.getTotalConnectionCount(), 0);
-            assertNull(emptyStats.getStatsPerHost().get(hostname));
+      assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+      assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(emptyStats.getTotalConnectionCount(), 0);
+      assertNull(emptyStats.getStatsPerHost().get(hostname));
 
-            final List<ListenableFuture<Response>> futures =
-                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
-                            .limit(5)
-                            .collect(Collectors.toList());
+      final List<ListenableFuture<Response>> futures =
+              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
+                      .limit(5)
+                      .collect(Collectors.toList());
 
-            Thread.sleep(2000);
+      Thread.sleep(2000);
 
-            final ClientStats activeStats = client.getClientStats();
+      final ClientStats activeStats = client.getClientStats();
 
-            assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
-            assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
-            assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(activeStats.getTotalConnectionCount(), 5);
-            assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+      assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
+      assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
+      assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(activeStats.getTotalConnectionCount(), 5);
+      assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-            futures.forEach(future -> future.toCompletableFuture().join());
+      futures.forEach(future -> future.toCompletableFuture().join());
 
-            Thread.sleep(1000);
+      Thread.sleep(1000);
 
-            final ClientStats idleStats = client.getClientStats();
+      final ClientStats idleStats = client.getClientStats();
 
-            assertEquals(idleStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-            assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(idleStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(idleStats.getTotalConnectionCount(), 0);
-            assertNull(idleStats.getStatsPerHost().get(hostname));
+      assertEquals(idleStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+      assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(idleStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(idleStats.getTotalConnectionCount(), 0);
+      assertNull(idleStats.getStatsPerHost().get(hostname));
 
-            // Let's make sure the active count is correct when reusing cached connections.
+      // Let's make sure the active count is correct when reusing cached connections.
 
-            final List<ListenableFuture<Response>> repeatedFutures =
-                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
-                            .limit(3)
-                            .collect(Collectors.toList());
+      final List<ListenableFuture<Response>> repeatedFutures =
+              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
+                      .limit(3)
+                      .collect(Collectors.toList());
 
-            Thread.sleep(2000);
+      Thread.sleep(2000);
 
-            final ClientStats activeCachedStats = client.getClientStats();
+      final ClientStats activeCachedStats = client.getClientStats();
 
-            assertEquals(activeCachedStats.toString(), "There are 3 total connections, 3 are active and 0 are idle.");
-            assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
-            assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(activeCachedStats.getTotalConnectionCount(), 3);
-            assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
+      assertEquals(activeCachedStats.toString(), "There are 3 total connections, 3 are active and 0 are idle.");
+      assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
+      assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(activeCachedStats.getTotalConnectionCount(), 3);
+      assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
 
-            repeatedFutures.forEach(future -> future.toCompletableFuture().join());
+      repeatedFutures.forEach(future -> future.toCompletableFuture().join());
 
-            Thread.sleep(1000);
+      Thread.sleep(1000);
 
-            final ClientStats idleCachedStats = client.getClientStats();
+      final ClientStats idleCachedStats = client.getClientStats();
 
-            assertEquals(idleCachedStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-            assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
-            assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 0);
-            assertEquals(idleCachedStats.getTotalConnectionCount(), 0);
-            assertNull(idleCachedStats.getStatsPerHost().get(hostname));
-        }
+      assertEquals(idleCachedStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+      assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
+      assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 0);
+      assertEquals(idleCachedStats.getTotalConnectionCount(), 0);
+      assertNull(idleCachedStats.getStatsPerHost().get(hostname));
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
index eb054629e..1189ef1fd 100644
--- a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
+++ b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -15,38 +15,38 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
+import org.testng.annotations.Test;
 
 import java.util.concurrent.TimeUnit;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
 
 public class ComplexClientTest extends AbstractBasicTest {
 
-    @Test(groups = "standalone")
-    public void multipleRequestsTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            String body = "hello there";
+  @Test
+  public void multipleRequestsTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      String body = "hello there";
 
-            // once
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      // once
+      Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getResponseBody(), body);
+      assertEquals(response.getResponseBody(), body);
 
-            // twice
-            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      // twice
+      response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getResponseBody(), body);
-        }
+      assertEquals(response.getResponseBody(), body);
     }
-
-    @Test(groups = "standalone")
-    public void urlWithoutSlashTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            String body = "hello there";
-            Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(response.getResponseBody(), body);
-        }
+  }
+
+  @Test
+  public void urlWithoutSlashTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      String body = "hello there";
+      Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(response.getResponseBody(), body);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/CookieStoreTest.java b/client/src/test/java/org/asynchttpclient/CookieStoreTest.java
new file mode 100644
index 000000000..e16a477c2
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/CookieStoreTest.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient;
+
+import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
+import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
+import io.netty.handler.codec.http.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieStore;
+import org.asynchttpclient.cookie.ThreadSafeCookieStore;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+import java.util.List;
+
+import static org.testng.Assert.assertTrue;
+
+public class CookieStoreTest {
+
+  private final Logger logger = LoggerFactory.getLogger(getClass());
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() {
+    logger.info("Local HTTP server started successfully");
+    System.out.println("--Start");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() {
+    System.out.println("--Stop");
+  }
+
+  @Test
+  public void runAllSequentiallyBecauseNotThreadSafe() {
+    addCookieWithEmptyPath();
+    dontReturnCookieForAnotherDomain();
+    returnCookieWhenItWasSetOnSamePath();
+    returnCookieWhenItWasSetOnParentPath();
+    dontReturnCookieWhenDomainMatchesButPathIsDifferent();
+    dontReturnCookieWhenDomainMatchesButPathIsParent();
+    returnCookieWhenDomainMatchesAndPathIsChild();
+    returnCookieWhenItWasSetOnSubdomain();
+    replaceCookieWhenSetOnSameDomainAndPath();
+    dontReplaceCookiesWhenTheyHaveDifferentName();
+    expireCookieWhenSetWithDateInThePast();
+    cookieWithSameNameMustCoexistIfSetOnDifferentDomains();
+    handleMissingDomainAsRequestHost();
+    handleMissingPathAsSlash();
+    returnTheCookieWheniTSissuedFromRequestWithSubpath();
+    handleMissingPathAsRequestPathWhenFromRootDir();
+    handleMissingPathAsRequestPathWhenPathIsNotEmpty();
+    handleDomainInCaseInsensitiveManner();
+    handleCookieNameInCaseInsensitiveManner();
+    handleCookiePathInCaseSensitiveManner();
+    ignoreQueryParametersInUri();
+    shouldServerOnSubdomainWhenDomainMatches();
+    replaceCookieWhenSetOnSamePathBySameUri();
+    handleMultipleCookieOfSameNameOnDifferentPaths();
+    handleTrailingSlashesInPaths();
+    returnMultipleCookiesEvenIfTheyHaveSameName();
+    shouldServeCookiesBasedOnTheUriScheme();
+    shouldAlsoServeNonSecureCookiesBasedOnTheUriScheme();
+    shouldNotServeSecureCookiesForDefaultRetrievedHttpUriScheme();
+    shouldServeSecureCookiesForSpecificallyRetrievedHttpUriScheme();
+  }
+
+  private void addCookieWithEmptyPath() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path="));
+    assertTrue(store.get(uri).size() > 0);
+  }
+
+  private void dontReturnCookieForAnotherDomain() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path="));
+    assertTrue(store.get(Uri.create("http://www.bar.com")).isEmpty());
+  }
+
+  private void returnCookieWhenItWasSetOnSamePath() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path=/bar/"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/bar/")).size() == 1);
+  }
+
+  private void returnCookieWhenItWasSetOnParentPath() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/bar/baz")).size() == 1);
+  }
+
+  private void dontReturnCookieWhenDomainMatchesButPathIsDifferent() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/baz")).isEmpty());
+  }
+
+  private void dontReturnCookieWhenDomainMatchesButPathIsParent() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(Uri.create("http://www.foo.com")).isEmpty());
+  }
+
+  private void returnCookieWhenDomainMatchesAndPathIsChild() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/bar/baz")).size() == 1);
+  }
+
+  private void returnCookieWhenItWasSetOnSubdomain() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=.foo.com"));
+    assertTrue(store.get(Uri.create("http://bar.foo.com")).size() == 1);
+  }
+
+  private void replaceCookieWhenSetOnSameDomainAndPath() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com/bar/baz");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE2"));
+  }
+
+  private void dontReplaceCookiesWhenTheyHaveDifferentName() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com/bar/baz");
+    store.add(uri, ClientCookieDecoder.LAX.decode("BETA=VALUE1; Domain=www.foo.com; path=/bar"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(uri).size() == 2);
+  }
+
+  private void expireCookieWhenSetWithDateInThePast() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com/bar");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=EXPIRED; Domain=www.foo.com; Path=/bar; Expires=Sun, 06 Nov 1994 08:49:37 GMT"));
+    assertTrue(store.getAll().isEmpty());
+  }
+
+  private void cookieWithSameNameMustCoexistIfSetOnDifferentDomains() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri1 = Uri.create("http://www.foo.com");
+    store.add(uri1, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com"));
+    Uri uri2 = Uri.create("http://www.bar.com");
+    store.add(uri2, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.bar.com"));
+
+    assertTrue(store.get(uri1).size() == 1);
+    assertTrue(store.get(uri1).get(0).value().equals("VALUE1"));
+
+    assertTrue(store.get(uri2).size() == 1);
+    assertTrue(store.get(uri2).get(0).value().equals("VALUE2"));
+  }
+
+  private void handleMissingDomainAsRequestHost() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Path=/"));
+    assertTrue(store.get(uri).size() == 1);
+  }
+
+  private void handleMissingPathAsSlash() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com");
+    store.add(uri, ClientCookieDecoder.LAX.decode("tooe_token=0b1d81dd02d207491a6e9b0a2af9470da9eb1dad"));
+    assertTrue(store.get(uri).size() == 1);
+  }
+
+  private void returnTheCookieWheniTSissuedFromRequestWithSubpath() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE; path=/"));
+    assertTrue(store.get(Uri.create("http://www.foo.com")).size() == 1);
+  }
+
+  private void handleMissingPathAsRequestPathWhenFromRootDir() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
+    assertTrue(store.get(uri).size() == 1);
+  }
+
+  private void handleMissingPathAsRequestPathWhenPathIsNotEmpty() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/baz")).isEmpty());
+  }
+
+  // RFC 2965 sec. 3.3.3
+  private void handleDomainInCaseInsensitiveManner() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
+    assertTrue(store.get(Uri.create("http://www.FoO.com/bar")).size() == 1);
+  }
+
+  // RFC 2965 sec. 3.3.3
+  private void handleCookieNameInCaseInsensitiveManner() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("http://www.foo.com/bar/baz");
+    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("alpha=VALUE2; Domain=www.foo.com; path=/bar"));
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE2"));
+  }
+
+  // RFC 2965 sec. 3.3.3
+  private void handleCookiePathInCaseSensitiveManner() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/foo/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
+    assertTrue(store.get(Uri.create("http://www.FoO.com/Foo/bAr")).isEmpty());
+  }
+
+  private void ignoreQueryParametersInUri() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com/bar?query1"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/"));
+    assertTrue(store.get(Uri.create("http://www.foo.com/bar?query2")).size() == 1);
+  }
+
+  // RFC 6265, 5.1.3.  Domain Matching
+  private void shouldServerOnSubdomainWhenDomainMatches() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("https://x.foo.org/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/; Domain=foo.org;"));
+    assertTrue(store.get(Uri.create("https://y.x.foo.org/")).size() == 1);
+  }
+
+  // NOTE: Similar to replaceCookieWhenSetOnSameDomainAndPath()
+  private void replaceCookieWhenSetOnSamePathBySameUri() {
+    CookieStore store = new ThreadSafeCookieStore();
+    Uri uri = Uri.create("https://foo.org/");
+    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
+    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/"));
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
+  }
+
+  private void handleMultipleCookieOfSameNameOnDifferentPaths() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("cookie=VALUE0; path=/"));
+    store.add(Uri.create("http://www.foo.com/foo/bar"), ClientCookieDecoder.LAX.decode("cookie=VALUE1; path=/foo/bar/"));
+    store.add(Uri.create("http://www.foo.com/foo/baz"), ClientCookieDecoder.LAX.decode("cookie=VALUE2; path=/foo/baz/"));
+
+    Uri uri1 = Uri.create("http://www.foo.com/foo/bar/");
+    List<Cookie> cookies1 = store.get(uri1);
+    assertTrue(cookies1.size() == 2);
+    assertTrue(cookies1.stream().filter(c -> c.value().equals("VALUE0") || c.value().equals("VALUE1")).count() == 2);
+
+    Uri uri2 = Uri.create("http://www.foo.com/foo/baz/");
+    List<Cookie> cookies2 = store.get(uri2);
+    assertTrue(cookies2.size() == 2);
+    assertTrue(cookies2.stream().filter(c -> c.value().equals("VALUE0") || c.value().equals("VALUE2")).count() == 2);
+  }
+
+  private void handleTrailingSlashesInPaths() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(
+            Uri.create("https://vagrant.moolb.com/app/consumer/j_spring_cas_security_check?ticket=ST-5-Q7gzqPpvG3N3Bb02bm3q-llinder-vagrantmgr.moolb.com"),
+            ClientCookieDecoder.LAX.decode("JSESSIONID=211D17F016132BCBD31D9ABB31D90960; Path=/app/consumer/; HttpOnly"));
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(Uri.create("https://vagrant.moolb.com/app/consumer/")).get(0).value().equals("211D17F016132BCBD31D9ABB31D90960"));
+  }
+
+  private void returnMultipleCookiesEvenIfTheyHaveSameName() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("http://foo.com"), ClientCookieDecoder.LAX.decode("JSESSIONID=FOO; Domain=.foo.com"));
+    store.add(Uri.create("http://sub.foo.com"), ClientCookieDecoder.LAX.decode("JSESSIONID=BAR; Domain=sub.foo.com"));
+
+    Uri uri1 = Uri.create("http://sub.foo.com");
+    List<Cookie> cookies1 = store.get(uri1);
+    assertTrue(cookies1.size() == 2);
+    assertTrue(cookies1.stream().filter(c -> c.value().equals("FOO") || c.value().equals("BAR")).count() == 2);
+
+    String result = ClientCookieEncoder.LAX.encode(cookies1.get(0), cookies1.get(1));
+    assertTrue(result.equals("JSESSIONID=FOO; JSESSIONID=BAR"));
+  }
+
+  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
+  private void shouldServeCookiesBasedOnTheUriScheme() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
+
+    Uri uri = Uri.create("https://foo.org/moodle/login");
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
+    assertTrue(store.get(uri).get(0).isSecure());
+  }
+
+  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
+  private void shouldAlsoServeNonSecureCookiesBasedOnTheUriScheme() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; HttpOnly"));
+
+    Uri uri = Uri.create("https://foo.org/moodle/login");
+    assertTrue(store.getAll().size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
+    assertTrue(!store.get(uri).get(0).isSecure());
+  }
+
+  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
+  private void shouldNotServeSecureCookiesForDefaultRetrievedHttpUriScheme() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
+
+    Uri uri = Uri.create("http://foo.org/moodle/login");
+    assertTrue(store.get(uri).isEmpty());
+  }
+
+  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
+  private void shouldServeSecureCookiesForSpecificallyRetrievedHttpUriScheme() {
+    CookieStore store = new ThreadSafeCookieStore();
+    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
+    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
+
+    Uri uri = Uri.create("https://foo.org/moodle/login");
+    assertTrue(store.get(uri).size() == 1);
+    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
+    assertTrue(store.get(uri).get(0).isSecure());
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/CustomRemoteAddressTest.java b/client/src/test/java/org/asynchttpclient/CustomRemoteAddressTest.java
new file mode 100755
index 000000000..c4b802644
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/CustomRemoteAddressTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+import io.netty.util.internal.SocketUtils;
+import org.asynchttpclient.test.TestUtils.AsyncCompletionHandlerAdapter;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.get;
+import static org.asynchttpclient.test.TestUtils.TIMEOUT;
+import static org.testng.Assert.assertEquals;
+
+public class CustomRemoteAddressTest extends HttpTest {
+
+  private static HttpServer server;
+
+  @BeforeClass
+  public static void start() throws Throwable {
+    server = new HttpServer();
+    server.start();
+  }
+
+  @AfterClass
+  public static void stop() throws Throwable {
+    server.close();
+  }
+
+  @Test
+  public void getRootUrlWithCustomRemoteAddress() throws Throwable {
+    withClient().run(client ->
+      withServer(server).run(server -> {
+        String url = server.getHttpUrl();
+        server.enqueueOk();
+        RequestBuilder request = get(url).setAddress(SocketUtils.addressByName("localhost"));
+        Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+        assertEquals(response.getStatusCode(), 200);
+      }));
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
index 323b1a108..55e1d0d88 100644
--- a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -12,89 +12,90 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.digestAuthRealm;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 public class DigestAuthTest extends AbstractBasicTest {
 
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        addDigestAuthHandler(server, configureHandler());
-        server.start();
-        port1 = connector.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-    }
+  @BeforeClass(alwaysRun = true)
+  @Override
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    addDigestAuthHandler(server, configureHandler());
+    server.start();
+    port1 = connector.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
 
-    private static class SimpleHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            response.addHeader("X-Auth", request.getHeader("Authorization"));
-            response.setStatus(200);
-            response.getOutputStream().flush();
-            response.getOutputStream().close();
-        }
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new SimpleHandler();
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SimpleHandler();
+  @Test
+  public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
+              .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())
+              .execute();
+      Response resp = f.get(60, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertNotNull(resp.getHeader("X-Auth"));
     }
+  }
 
-    @Test(groups = "standalone")
-    public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
-                    .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
-                    .execute();
-            Response resp = f.get(60, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertNotNull(resp.getHeader("X-Auth"));
-        }
+  @Test
+  public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
+              .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())
+              .execute();
+      Response resp = f.get(60, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertNotNull(resp.getHeader("X-Auth"));
     }
+  }
 
-    @Test(groups = "standalone")
-    public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
-                    .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
-                    .execute();
-            Response resp = f.get(60, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertNotNull(resp.getHeader("X-Auth"));
-        }
+  @Test
+  public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
+              .setRealm(digestAuthRealm("fake", ADMIN).build())
+              .execute();
+      Response resp = f.get(20, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), 401);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
-                    .setRealm(digestAuthRealm("fake", ADMIN).build())//
-                    .execute();
-            Response resp = f.get(20, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), 401);
-        }
+  private static class SimpleHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      response.addHeader("X-Auth", request.getHeader("Authorization"));
+      response.setStatus(200);
+      response.getOutputStream().flush();
+      response.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
index 9b5b224e2..739dfb7ef 100644
--- a/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
+++ b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
@@ -13,46 +13,47 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
-
-import java.io.IOException;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.eclipse.jetty.server.handler.gzip.GzipHandler;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.handler.gzip.GzipHandler;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 
 public class EofTerminatedTest extends AbstractBasicTest {
 
-    private static class StreamHandler extends AbstractHandler {
-        @Override
-        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-            request.getResponse().getHttpOutput().sendContent(EofTerminatedTest.class.getClassLoader().getResourceAsStream("SimpleTextFile.txt"));
-        }
-    }
-
-    protected String getTargetUrl() {
-        return String.format("http://localhost:%d/", port1);
+  protected String getTargetUrl() {
+    return String.format("http://localhost:%d/", port1);
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    GzipHandler gzipHandler = new GzipHandler();
+    gzipHandler.setHandler(new StreamHandler());
+    return gzipHandler;
+  }
+
+  @Test
+  public void testEolTerminatedResponse() throws Exception {
+    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
+      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).setHeader(ACCEPT_ENCODING, HttpHeaderValues.GZIP_DEFLATE).setHeader(CONNECTION, HttpHeaderValues.CLOSE).build())
+              .get();
     }
+  }
 
+  private static class StreamHandler extends AbstractHandler {
     @Override
-    public AbstractHandler configureHandler() throws Exception {
-        GzipHandler gzipHandler = new GzipHandler();
-        gzipHandler.setHandler(new StreamHandler());
-        return gzipHandler;
-    }
-
-    @Test
-    public void testEolTerminatedResponse() throws Exception {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
-            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).setHeader(ACCEPT_ENCODING, HttpHeaderValues.GZIP_DEFLATE).setHeader(CONNECTION, HttpHeaderValues.CLOSE).build())
-                    .get();
-        }
+    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+      request.getResponse().getHttpOutput().sendContent(EofTerminatedTest.class.getClassLoader().getResourceAsStream("SimpleTextFile.txt"));
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index f69406696..9edf6e2d9 100644
--- a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -16,58 +16,59 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 /**
  * Tests to reproduce issues with handling of error responses
- * 
+ *
  * @author Tatu Saloranta
  */
 public class ErrorResponseTest extends AbstractBasicTest {
-    final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
+  final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
 
-    private static class ErrorHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            try {
-                Thread.sleep(210L);
-            } catch (InterruptedException e) {
-            }
-            response.setContentType("text/plain");
-            response.setStatus(400);
-            OutputStream out = response.getOutputStream();
-            out.write(BAD_REQUEST_STR.getBytes(UTF_8));
-            out.flush();
-        }
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new ErrorHandler();
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ErrorHandler();
+  @Test(groups = "standalone")
+  public void testQueryParameters() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), 400);
+      assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testQueryParameters() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), 400);
-            assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
-        }
+  private static class ErrorHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      try {
+        Thread.sleep(210L);
+      } catch (InterruptedException e) {
+        //
+      }
+      response.setContentType("text/plain");
+      response.setStatus(400);
+      OutputStream out = response.getOutputStream();
+      out.write(BAD_REQUEST_STR.getBytes(UTF_8));
+      out.flush();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index ed43033cc..0aad5721f 100644
--- a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
+++ b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -15,62 +15,63 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
-
-import java.io.IOException;
-import java.util.concurrent.Future;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.Future;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 /**
  * Test the Expect: 100-Continue.
  */
 public class Expect100ContinueTest extends AbstractBasicTest {
 
-    private static class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                final int read = httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes, 0, read);
-            }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new ZeroCopyHandler();
+  }
 
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-        }
+  @Test
+  public void Expect100Continue() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")
+              .setHeader(EXPECT, HttpHeaderValues.CONTINUE)
+              .setBody(SIMPLE_TEXT_FILE)
+              .execute();
+      Response resp = f.get();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ZeroCopyHandler();
-    }
+  private static class ZeroCopyHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      int size = 10 * 1024;
+      if (httpRequest.getContentLength() > 0) {
+        size = httpRequest.getContentLength();
+      }
+      byte[] bytes = new byte[size];
+      if (bytes.length > 0) {
+        final int read = httpRequest.getInputStream().read(bytes);
+        httpResponse.getOutputStream().write(bytes, 0, read);
+      }
 
-    @Test(groups = "standalone")
-    public void Expect100Continue() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")//
-                    .setHeader(EXPECT, HttpHeaderValues.CONTINUE)//
-                    .setBody(SIMPLE_TEXT_FILE)//
-                    .execute();
-            Response resp = f.get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        }
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
index f36abf6ce..e7eeec8e3 100644
--- a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
+++ b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
@@ -15,78 +15,74 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeoutException;
+import java.util.concurrent.*;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 
 /**
  * Simple stress test for exercising the follow redirect.
  */
 public class FollowingThreadTest extends AbstractBasicTest {
 
-    private static final int COUNT = 10;
+  private static final int COUNT = 10;
 
-    @Test(groups = "online", timeOut = 30 * 1000)
-    public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+  @Test(groups = "online", timeOut = 30 * 1000)
+  public void testFollowRedirect() throws InterruptedException {
 
-        final CountDownLatch countDown = new CountDownLatch(COUNT);
-        ExecutorService pool = Executors.newCachedThreadPool();
-        try {
-            for (int i = 0; i < COUNT; i++) {
-                pool.submit(new Runnable() {
+    final CountDownLatch countDown = new CountDownLatch(COUNT);
+    ExecutorService pool = Executors.newCachedThreadPool();
+    try {
+      for (int i = 0; i < COUNT; i++) {
+        pool.submit(new Runnable() {
 
-                    private int status;
+          private int status;
 
-                    public void run() {
-                        final CountDownLatch l = new CountDownLatch(1);
-                        try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true))) {
-                            ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
+          public void run() {
+            final CountDownLatch l = new CountDownLatch(1);
+            try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true))) {
+              ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
 
-                                public void onThrowable(Throwable t) {
-                                    t.printStackTrace();
-                                }
+                public void onThrowable(Throwable t) {
+                  t.printStackTrace();
+                }
 
-                                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                                    System.out.println(new String(bodyPart.getBodyPartBytes()));
-                                    return State.CONTINUE;
-                                }
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
+                  System.out.println(new String(bodyPart.getBodyPartBytes()));
+                  return State.CONTINUE;
+                }
 
-                                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                                    status = responseStatus.getStatusCode();
-                                    System.out.println(responseStatus.getStatusText());
-                                    return State.CONTINUE;
-                                }
+                public State onStatusReceived(HttpResponseStatus responseStatus) {
+                  status = responseStatus.getStatusCode();
+                  System.out.println(responseStatus.getStatusText());
+                  return State.CONTINUE;
+                }
 
-                                public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                                    return State.CONTINUE;
-                                }
+                public State onHeadersReceived(HttpHeaders headers) {
+                  return State.CONTINUE;
+                }
 
-                                public Integer onCompleted() throws Exception {
-                                    l.countDown();
-                                    return status;
-                                }
-                            });
+                public Integer onCompleted() {
+                  l.countDown();
+                  return status;
+                }
+              });
 
-                            l.await();
-                        } catch (Exception e) {
-                            e.printStackTrace();
-                        } finally {
-                            countDown.countDown();
-                        }
-                    }
-                });
+              l.await();
+            } catch (Exception e) {
+              e.printStackTrace();
+            } finally {
+              countDown.countDown();
             }
-            countDown.await();
-        } finally {
-            pool.shutdown();
-        }
+          }
+        });
+      }
+      countDown.await();
+    } finally {
+      pool.shutdown();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Head302Test.java b/client/src/test/java/org/asynchttpclient/Head302Test.java
index 2512b9cb1..2072f3dbb 100644
--- a/client/src/test/java/org/asynchttpclient/Head302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Head302Test.java
@@ -15,76 +15,70 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
-import java.io.IOException;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.*;
 
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.head;
+import static org.testng.Assert.*;
 
 /**
  * Tests HEAD request that gets 302 response.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class Head302Test extends AbstractBasicTest {
 
-    /**
-     * Handler that does Found (302) in response to HEAD method.
-     */
-    private static class Head302handler extends AbstractHandler {
-        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("HEAD".equalsIgnoreCase(request.getMethod())) {
-                response.setStatus(HttpServletResponse.SC_FOUND); // 302
-                response.setHeader("Location", request.getPathInfo() + "_moved");
-            } else if ("GET".equalsIgnoreCase(request.getMethod())) {
-                response.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
-            }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new Head302handler();
+  }
+
+  @Test
+  public void testHEAD302() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    AsyncHttpClientConfig clientConfig = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+    try (AsyncHttpClient client = asyncHttpClient(clientConfig)) {
+      final CountDownLatch l = new CountDownLatch(1);
+      Request request = head("http://localhost:" + port1 + "/Test").build();
 
-            r.setHandled(true);
+      Response response = client.executeRequest(request, new AsyncCompletionHandlerBase() {
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+          l.countDown();
+          return super.onCompleted(response);
         }
-    }
+      }).get(3, TimeUnit.SECONDS);
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new Head302handler();
+      if (l.await(TIMEOUT, TimeUnit.SECONDS)) {
+        assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+        assertTrue(response.getUri().getPath().endsWith("_moved"));
+      } else {
+        fail("Timeout out");
+      }
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
-        AsyncHttpClientConfig clientConfig = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        try (AsyncHttpClient client = asyncHttpClient(clientConfig)) {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = head("http://localhost:" + port1 + "/Test").build();
-
-            Response response = client.executeRequest(request, new AsyncCompletionHandlerBase() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    l.countDown();
-                    return super.onCompleted(response);
-                }
-            }).get(3, TimeUnit.SECONDS);
+  /**
+   * Handler that does Found (302) in response to HEAD method.
+   */
+  private static class Head302handler extends AbstractHandler {
+    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("HEAD".equalsIgnoreCase(request.getMethod())) {
+        response.setStatus(HttpServletResponse.SC_FOUND); // 302
+        response.setHeader("Location", request.getPathInfo() + "_moved");
+      } else if ("GET".equalsIgnoreCase(request.getMethod())) {
+        response.setStatus(HttpServletResponse.SC_OK);
+      } else {
+        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
+      }
 
-            if (l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-                assertTrue(response.getUri().getPath().endsWith("_moved"));
-            } else {
-                fail("Timeout out");
-            }
-        }
+      r.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
index 39ab2c3e2..cb6910e2b 100644
--- a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
@@ -15,18 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -34,115 +22,128 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class HttpToHttpsRedirectTest extends AbstractBasicTest {
-
-    // FIXME super NOT threadsafe!!!
-    private final AtomicBoolean redirectDone = new AtomicBoolean(false);
-
-    private class Relative302Handler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            String param;
-            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-                if (param.startsWith("X-redirect") && !redirectDone.getAndSet(true)) {
-                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
-                    httpResponse.setStatus(302);
-                    httpResponse.getOutputStream().flush();
-                    httpResponse.getOutputStream().close();
-                    return;
-                }
-            }
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
-            if (r.getScheme().equalsIgnoreCase("https")) {
-                httpResponse.addHeader("X-httpToHttps", "PASS");
-                redirectDone.getAndSet(false);
-            }
+public class HttpToHttpsRedirectTest extends AbstractBasicTest {
 
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
+  // FIXME super NOT threadsafe!!!
+  private final AtomicBoolean redirectDone = new AtomicBoolean(false);
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    ServerConnector connector2 = addHttpsConnector(server);
+    server.setHandler(new Relative302Handler());
+    server.start();
+    port1 = connector1.getLocalPort();
+    port2 = connector2.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
+
+  @Test
+  // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
+  public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+    httpToHttpsRedirect();
+    httpToHttpsProperConfig();
+    relativeLocationUrl();
+  }
+
+  @Test(enabled = false)
+  public void httpToHttpsRedirect() throws Exception {
+    redirectDone.getAndSet(false);
+
+    AsyncHttpClientConfig cg = config()
+            .setMaxRedirects(5)
+            .setFollowRedirect(true)
+            .setUseInsecureTrustManager(true)
+            .build();
+    try (AsyncHttpClient c = asyncHttpClient(cg)) {
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
     }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        ServerConnector connector2 = addHttpsConnector(server);
-        server.setHandler(new Relative302Handler());
-        server.start();
-        port1 = connector1.getLocalPort();
-        port2 = connector2.getLocalPort();
-        logger.info("Local HTTP server started successfully");
+  }
+
+  @Test(enabled = false)
+  public void httpToHttpsProperConfig() throws Exception {
+    redirectDone.getAndSet(false);
+
+    AsyncHttpClientConfig cg = config()
+            .setMaxRedirects(5)
+            .setFollowRedirect(true)
+            .setUseInsecureTrustManager(true)
+            .build();
+    try (AsyncHttpClient c = asyncHttpClient(cg)) {
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+
+      // Test if the internal channel is downgraded to clean http.
+      response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
     }
-
-    @Test(groups = "standalone")
-    // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
-    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
-        httpToHttpsRedirect();
-        httpToHttpsProperConfig();
-        relativeLocationUrl();
+  }
+
+  @Test(enabled = false)
+  public void relativeLocationUrl() throws Exception {
+    redirectDone.getAndSet(false);
+
+    AsyncHttpClientConfig cg = config()
+            .setMaxRedirects(5)
+            .setFollowRedirect(true)
+            .setUseInsecureTrustManager(true)
+            .build();
+    try (AsyncHttpClient c = asyncHttpClient(cg)) {
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getUri().toString(), getTargetUrl());
     }
+  }
 
-    // @Test(groups = "standalone")
-    public void httpToHttpsRedirect() throws Exception {
-        redirectDone.getAndSet(false);
+  private class Relative302Handler extends AbstractHandler {
 
-        AsyncHttpClientConfig cg = config()//
-                .setMaxRedirects(5)//
-                .setFollowRedirect(true)//
-                .setUseInsecureTrustManager(true)//
-                .build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        }
-    }
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-    // @Test(groups = "standalone")
-    public void httpToHttpsProperConfig() throws Exception {
-        redirectDone.getAndSet(false);
+      String param;
+      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
 
-        AsyncHttpClientConfig cg = config()//
-                .setMaxRedirects(5)//
-                .setFollowRedirect(true)//
-                .setUseInsecureTrustManager(true)//
-                .build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-
-            // Test if the internal channel is downgraded to clean http.
-            response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+        if (param.startsWith("X-redirect") && !redirectDone.getAndSet(true)) {
+          httpResponse.addHeader("Location", httpRequest.getHeader(param));
+          httpResponse.setStatus(302);
+          httpResponse.getOutputStream().flush();
+          httpResponse.getOutputStream().close();
+          return;
         }
-    }
+      }
 
-    // @Test(groups = "standalone")
-    public void relativeLocationUrl() throws Exception {
+      if (r.getScheme().equalsIgnoreCase("https")) {
+        httpResponse.addHeader("X-httpToHttps", "PASS");
         redirectDone.getAndSet(false);
+      }
 
-        AsyncHttpClientConfig cg = config()//
-                .setMaxRedirects(5)//
-                .setFollowRedirect(true)//
-                .setUseInsecureTrustManager(true)//
-                .build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getUri().toString(), getTargetUrl());
-        }
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
index 39d702728..0ee80f419 100644
--- a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
@@ -15,17 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.fail;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -33,39 +22,50 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class IdleStateHandlerTest extends AbstractBasicTest {
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
 
-    private class IdleStateHandler extends AbstractHandler {
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.fail;
 
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+public class IdleStateHandlerTest extends AbstractBasicTest {
 
-            try {
-                Thread.sleep(20 * 1000);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
-    }
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(new IdleStateHandler());
+    server.start();
+    port1 = connector.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new IdleStateHandler());
-        server.start();
-        port1 = connector.getLocalPort();
-        logger.info("Local HTTP server started successfully");
+  @Test
+  public void idleStateTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setPooledConnectionIdleTimeout(10 * 1000))) {
+      c.prepareGet(getTargetUrl()).execute().get();
+    } catch (ExecutionException e) {
+      fail("Should allow to finish processing request.", e);
     }
+  }
+
+  private class IdleStateHandler extends AbstractHandler {
+
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-    @Test(groups = "standalone")
-    public void idleStateTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setPooledConnectionIdleTimeout(10 * 1000))) {
-            c.prepareGet(getTargetUrl()).execute().get();
-        } catch (ExecutionException e) {
-            fail("Should allow to finish processing request.", e);
-        }
+      try {
+        Thread.sleep(20 * 1000);
+      } catch (InterruptedException e) {
+        e.printStackTrace();
+      }
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 71e612d46..9138fc059 100644
--- a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -12,8 +12,7 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
+import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -21,56 +20,57 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
 
 public class ListenableFutureTest extends AbstractBasicTest {
 
-    @Test
-    public void testListenableFuture() throws Exception {
-        final AtomicInteger statusCode = new AtomicInteger(500);
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-            future.addListener(() -> {
-                try {
-                    statusCode.set(future.get().getStatusCode());
-                    latch.countDown();
-                } catch (InterruptedException | ExecutionException e) {
-                    e.printStackTrace();
-                }
-            }, Executors.newFixedThreadPool(1));
-
-            latch.await(10, TimeUnit.SECONDS);
-            assertEquals(statusCode.get(), 200);
+  @Test
+  public void testListenableFuture() throws Exception {
+    final AtomicInteger statusCode = new AtomicInteger(500);
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+      future.addListener(() -> {
+        try {
+          statusCode.set(future.get().getStatusCode());
+          latch.countDown();
+        } catch (InterruptedException | ExecutionException e) {
+          e.printStackTrace();
         }
-    }
+      }, Executors.newFixedThreadPool(1));
 
-    @Test
-    public void testListenableFutureAfterCompletion() throws Exception {
+      latch.await(10, TimeUnit.SECONDS);
+      assertEquals(statusCode.get(), 200);
+    }
+  }
 
-        final CountDownLatch latch = new CountDownLatch(1);
+  @Test
+  public void testListenableFutureAfterCompletion() throws Exception {
 
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-            future.get();
-            future.addListener(() -> latch.countDown(), Runnable::run);
-        }
+    final CountDownLatch latch = new CountDownLatch(1);
 
-        latch.await(10, TimeUnit.SECONDS);
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+      future.get();
+      future.addListener(latch::countDown, Runnable::run);
     }
 
-    @Test
-    public void testListenableFutureBeforeAndAfterCompletion() throws Exception {
+    latch.await(10, TimeUnit.SECONDS);
+  }
 
-        final CountDownLatch latch = new CountDownLatch(2);
+  @Test
+  public void testListenableFutureBeforeAndAfterCompletion() throws Exception {
 
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-            future.addListener(() -> latch.countDown(), Runnable::run);
-            future.get();
-            future.addListener(() -> latch.countDown(), Runnable::run);
-        }
+    final CountDownLatch latch = new CountDownLatch(2);
 
-        latch.await(10, TimeUnit.SECONDS);
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+      future.addListener(latch::countDown, Runnable::run);
+      future.get();
+      future.addListener(latch::countDown, Runnable::run);
     }
+
+    latch.await(10, TimeUnit.SECONDS);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
index 273309faf..0bad2af9b 100644
--- a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
+++ b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
@@ -12,183 +12,170 @@
  */
 package org.asynchttpclient;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
+import javax.net.ServerSocketFactory;
+import java.io.*;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import javax.net.ServerSocketFactory;
+import java.util.concurrent.*;
 
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.get;
+import static org.testng.Assert.*;
 
 /**
  * @author Hubert Iwaniuk
  */
 public class MultipleHeaderTest extends AbstractBasicTest {
-    private ExecutorService executorService;
-    private ServerSocket serverSocket;
-    private Future<?> voidFuture;
-
-    @BeforeClass
-    public void setUpGlobal() throws Exception {
-        serverSocket = ServerSocketFactory.getDefault().createServerSocket(0);
-        port1 = serverSocket.getLocalPort();
-        executorService = Executors.newFixedThreadPool(1);
-        voidFuture = executorService.submit(new Callable<Void>() {
-            public Void call() throws Exception {
-                Socket socket;
-                while ((socket = serverSocket.accept()) != null) {
-                    InputStream inputStream = socket.getInputStream();
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-                    String req = reader.readLine().split(" ")[1];
-                    int i = inputStream.available();
-                    long l = inputStream.skip(i);
-                    assertEquals(l, i);
-                    socket.shutdownInput();
-                    if (req.endsWith("MultiEnt")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n"
-                                + "Content-Length: 1\n" + "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    } else if (req.endsWith("MultiOther")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n"
-                                + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    }
-                }
-                return null;
-            }
-        });
-    }
+  private ExecutorService executorService;
+  private ServerSocket serverSocket;
+  private Future<?> voidFuture;
+
+  @BeforeClass
+  public void setUpGlobal() throws Exception {
+    serverSocket = ServerSocketFactory.getDefault().createServerSocket(0);
+    port1 = serverSocket.getLocalPort();
+    executorService = Executors.newFixedThreadPool(1);
+    voidFuture = executorService.submit(() -> {
+        Socket socket;
+        while ((socket = serverSocket.accept()) != null) {
+          InputStream inputStream = socket.getInputStream();
+          BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+          String req = reader.readLine().split(" ")[1];
+          int i = inputStream.available();
+          long l = inputStream.skip(i);
+          assertEquals(l, i);
+          socket.shutdownInput();
+          if (req.endsWith("MultiEnt")) {
+            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+            outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n"
+                    + "Content-Length: 1\n" + "\n0\n");
+            outputStreamWriter.flush();
+            socket.shutdownOutput();
+          } else if (req.endsWith("MultiOther")) {
+            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+            outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n"
+                    + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
+            outputStreamWriter.flush();
+            socket.shutdownOutput();
+          }
+        }
+        return null;
+      });
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    voidFuture.cancel(true);
+    executorService.shutdownNow();
+    serverSocket.close();
+  }
+
+  @Test
+  public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    final String[] xffHeaders = new String[]{null, null};
+
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      Request req = get("http://localhost:" + port1 + "/MultiOther").build();
+      final CountDownLatch latch = new CountDownLatch(1);
+      ahc.executeRequest(req, new AsyncHandler<Void>() {
+        public void onThrowable(Throwable t) {
+          t.printStackTrace(System.out);
+        }
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        voidFuture.cancel(true);
-        executorService.shutdownNow();
-        serverSocket.close();
-    }
+        public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) {
+          return State.CONTINUE;
+        }
 
-    @Test(groups = "standalone")
-    public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] xffHeaders = new String[] { null, null };
-
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            Request req = get("http://localhost:" + port1 + "/MultiOther").build();
-            final CountDownLatch latch = new CountDownLatch(1);
-            ahc.executeRequest(req, new AsyncHandler<Void>() {
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace(System.out);
-                }
-
-                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public State onHeadersReceived(HttpHeaders response) throws Exception {
-                    int i = 0;
-                    for (String header : response.getAll("X-Forwarded-For")) {
-                        xffHeaders[i++] = header;
-                    }
-                    latch.countDown();
-                    return State.CONTINUE;
-                }
-
-                public Void onCompleted() throws Exception {
-                    return null;
-                }
-            }).get(3, TimeUnit.SECONDS);
-
-            if (!latch.await(2, TimeUnit.SECONDS)) {
-                fail("Time out");
-            }
-            assertNotNull(xffHeaders[0]);
-            assertNotNull(xffHeaders[1]);
-            try {
-                assertEquals(xffHeaders[0], "abc");
-                assertEquals(xffHeaders[1], "def");
-            } catch (AssertionError ex) {
-                assertEquals(xffHeaders[1], "abc");
-                assertEquals(xffHeaders[0], "def");
-            }
+        public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) {
+          return State.CONTINUE;
+        }
+
+        public State onHeadersReceived(HttpHeaders response) {
+          int i = 0;
+          for (String header : response.getAll("X-Forwarded-For")) {
+            xffHeaders[i++] = header;
+          }
+          latch.countDown();
+          return State.CONTINUE;
+        }
+
+        public Void onCompleted() {
+          return null;
         }
+      }).get(3, TimeUnit.SECONDS);
+
+      if (!latch.await(2, TimeUnit.SECONDS)) {
+        fail("Time out");
+      }
+      assertNotNull(xffHeaders[0]);
+      assertNotNull(xffHeaders[1]);
+      try {
+        assertEquals(xffHeaders[0], "abc");
+        assertEquals(xffHeaders[1], "def");
+      } catch (AssertionError ex) {
+        assertEquals(xffHeaders[1], "abc");
+        assertEquals(xffHeaders[0], "def");
+      }
     }
+  }
+
+  @Test
+  public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    final String[] clHeaders = new String[]{null, null};
+
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      Request req = get("http://localhost:" + port1 + "/MultiEnt").build();
+      final CountDownLatch latch = new CountDownLatch(1);
+      ahc.executeRequest(req, new AsyncHandler<Void>() {
+        public void onThrowable(Throwable t) {
+          t.printStackTrace(System.out);
+        }
 
-    @Test(groups = "standalone")
-    public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] clHeaders = new String[] { null, null };
-
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            Request req = get("http://localhost:" + port1 + "/MultiEnt").build();
-            final CountDownLatch latch = new CountDownLatch(1);
-            ahc.executeRequest(req, new AsyncHandler<Void>() {
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace(System.out);
-                }
-
-                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                    return State.CONTINUE;
-                }
-
-                public State onHeadersReceived(HttpHeaders response) throws Exception {
-                    try {
-                        int i = 0;
-                        for (String header : response.getAll(CONTENT_LENGTH)) {
-                            clHeaders[i++] = header;
-                        }
-                    } finally {
-                        latch.countDown();
-                    }
-                    return State.CONTINUE;
-                }
-
-                public Void onCompleted() throws Exception {
-                    return null;
-                }
-            }).get(3, TimeUnit.SECONDS);
-
-            if (!latch.await(2, TimeUnit.SECONDS)) {
-                fail("Time out");
-            }
-            assertNotNull(clHeaders[0]);
-            assertNotNull(clHeaders[1]);
-
-            // We can predict the order
-            try {
-                assertEquals(clHeaders[0], "2");
-                assertEquals(clHeaders[1], "1");
-            } catch (Throwable ex) {
-                assertEquals(clHeaders[0], "1");
-                assertEquals(clHeaders[1], "2");
+        public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) {
+          return State.CONTINUE;
+        }
+
+        public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) {
+          return State.CONTINUE;
+        }
+
+        public State onHeadersReceived(HttpHeaders response) {
+          try {
+            int i = 0;
+            for (String header : response.getAll(CONTENT_LENGTH)) {
+              clHeaders[i++] = header;
             }
+          } finally {
+            latch.countDown();
+          }
+          return State.CONTINUE;
+        }
+
+        public Void onCompleted() {
+          return null;
         }
+      }).get(3, TimeUnit.SECONDS);
+
+      if (!latch.await(2, TimeUnit.SECONDS)) {
+        fail("Time out");
+      }
+      assertNotNull(clHeaders[0]);
+      assertNotNull(clHeaders[1]);
+
+      // We can predict the order
+      try {
+        assertEquals(clHeaders[0], "2");
+        assertEquals(clHeaders[1], "1");
+      } catch (Throwable ex) {
+        assertEquals(clHeaders[0], "1");
+        assertEquals(clHeaders[1], "2");
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
index 7d01d2360..696ca6697 100644
--- a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
@@ -16,34 +16,35 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertNotNull;
-
 import org.testng.annotations.Test;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertNotNull;
+
 public class NoNullResponseTest extends AbstractBasicTest {
-    private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
+  private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
 
-    @Test(groups = "online", invocationCount = 4)
-    public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
+  @Test(groups = "online", invocationCount = 4)
+  public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
 
-        AsyncHttpClientConfig config = config()//
-                .setFollowRedirect(true)//
-                .setKeepAlive(true)//
-                .setConnectTimeout(10000)//
-                .setPooledConnectionIdleTimeout(60000)//
-                .setRequestTimeout(10000)//
-                .setMaxConnectionsPerHost(-1)//
-                .setMaxConnections(-1)//
-                .build();
+    AsyncHttpClientConfig config = config()
+            .setFollowRedirect(true)
+            .setKeepAlive(true)
+            .setConnectTimeout(10000)
+            .setPooledConnectionIdleTimeout(60000)
+            .setRequestTimeout(10000)
+            .setMaxConnectionsPerHost(-1)
+            .setMaxConnections(-1)
+            .build();
 
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
-            final Response response1 = builder.execute().get();
-            Thread.sleep(4000);
-            final Response response2 = builder.execute().get();
-            assertNotNull(response1);
-            assertNotNull(response2);
-        }
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
+      final Response response1 = builder.execute().get();
+      Thread.sleep(4000);
+      final Response response2 = builder.execute().get();
+      assertNotNull(response1);
+      assertNotNull(response2);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
index aec48d83f..d59285531 100644
--- a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
+++ b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
@@ -12,72 +12,71 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
 
 public class NonAsciiContentLengthTest extends AbstractBasicTest {
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new AbstractHandler() {
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(new AbstractHandler() {
 
-            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-                int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
-                byte[] b = new byte[MAX_BODY_SIZE];
-                int offset = 0;
-                int numBytesRead;
-                try (ServletInputStream is = request.getInputStream()) {
-                    while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
-                        offset += numBytesRead;
-                    }
-                }
-                assertEquals(request.getContentLength(), offset);
-                response.setStatus(200);
-                response.setCharacterEncoding(request.getCharacterEncoding());
-                response.setContentLength(request.getContentLength());
-                try (ServletOutputStream os = response.getOutputStream()) {
-                    os.write(b, 0, offset);
-                }
-            }
-        });
-        server.start();
-        port1 = connector.getLocalPort();
-    }
+      public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
+        int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
+        byte[] b = new byte[MAX_BODY_SIZE];
+        int offset = 0;
+        int numBytesRead;
+        try (ServletInputStream is = request.getInputStream()) {
+          while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
+            offset += numBytesRead;
+          }
+        }
+        assertEquals(request.getContentLength(), offset);
+        response.setStatus(200);
+        response.setCharacterEncoding(request.getCharacterEncoding());
+        response.setContentLength(request.getContentLength());
+        try (ServletOutputStream os = response.getOutputStream()) {
+          os.write(b, 0, offset);
+        }
+      }
+    });
+    server.start();
+    port1 = connector.getLocalPort();
+  }
 
-    @Test(groups = "standalone")
-    public void testNonAsciiContentLength() throws Exception {
-        execute("test");
-        execute("\u4E00"); // Unicode CJK ideograph for one
-    }
+  @Test
+  public void testNonAsciiContentLength() throws Exception {
+    execute("test");
+    execute("\u4E00"); // Unicode CJK ideograph for one
+  }
 
-    protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setCharset(UTF_8);
-            Future<Response> f = r.execute();
-            Response resp = f.get();
-            assertEquals(resp.getStatusCode(), 200);
-            assertEquals(body, resp.getResponseBody(UTF_8));
-        }
+  protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setCharset(UTF_8);
+      Future<Response> f = r.execute();
+      Response resp = f.get();
+      assertEquals(resp.getStatusCode(), 200);
+      assertEquals(body, resp.getResponseBody(UTF_8));
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index 790b3109b..43783647e 100644
--- a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -15,59 +15,59 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 public class ParamEncodingTest extends AbstractBasicTest {
 
-    private class ParamEncoding extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("POST".equalsIgnoreCase(request.getMethod())) {
-                String p = request.getParameter("test");
-                if (isNonEmpty(p)) {
-                    response.setStatus(HttpServletResponse.SC_OK);
-                    response.addHeader("X-Param", p);
-                } else {
-                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
-                }
-            } else { // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-            response.getOutputStream().flush();
-            response.getOutputStream().close();
-        }
+  @Test
+  public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+
+    String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
+      Response resp = f.get(10, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("X-Param"), value.trim());
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new ParamEncoding();
+  }
 
-        String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
-            Response resp = f.get(10, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("X-Param"), value.trim());
+  private class ParamEncoding extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("POST".equalsIgnoreCase(request.getMethod())) {
+        String p = request.getParameter("test");
+        if (isNonEmpty(p)) {
+          response.setStatus(HttpServletResponse.SC_OK);
+          response.addHeader("X-Param", p);
+        } else {
+          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
         }
+      } else { // this handler is to handle POST request
+        response.sendError(HttpServletResponse.SC_FORBIDDEN);
+      }
+      response.getOutputStream().flush();
+      response.getOutputStream().close();
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ParamEncoding();
-    }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 8156aa0e3..e8433fa48 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -15,20 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.util.Enumeration;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.uri.Uri;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -37,125 +23,139 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class PerRequestRelative302Test extends AbstractBasicTest {
-
- // FIXME super NOT threadsafe!!!
-    private final AtomicBoolean isSet = new AtomicBoolean(false);
-
-    private class Relative302Handler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            String param;
-            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-
-                if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
-                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
-                    httpResponse.setStatus(302);
-                    httpResponse.getOutputStream().flush();
-                    httpResponse.getOutputStream().close();
-                    return;
-                }
-            }
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
-    }
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.util.Enumeration;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 
-        server.setHandler(new Relative302Handler());
-        server.start();
-        port1 = connector.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-        port2 = findFreePort();
-    }
+public class PerRequestRelative302Test extends AbstractBasicTest {
 
-    @Test(groups = "online")
-    // FIXME threadsafe
-    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
-        redirected302Test();
-        notRedirected302Test();
-        relativeLocationUrl();
-        redirected302InvalidTest();
+  // FIXME super NOT threadsafe!!!
+  private final AtomicBoolean isSet = new AtomicBoolean(false);
+
+  private static int getPort(Uri uri) {
+    int port = uri.getPort();
+    if (port == -1)
+      port = uri.getScheme().equals("http") ? 80 : 443;
+    return port;
+  }
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+
+    server.setHandler(new Relative302Handler());
+    server.start();
+    port1 = connector.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+    port2 = findFreePort();
+  }
+
+  @Test(groups = "online")
+  // FIXME threadsafe
+  public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+    redirected302Test();
+    notRedirected302Test();
+    relativeLocationUrl();
+    redirected302InvalidTest();
+  }
+
+  @Test(groups = "online", enabled = false)
+  public void redirected302Test() throws Exception {
+    isSet.getAndSet(false);
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "https://www.microsoft.com/").execute().get();
+
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+
+      String anyMicrosoftPage = "https://www.microsoft.com[^:]*:443";
+      String baseUrl = getBaseUrl(response.getUri());
+
+      assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
     }
-
-    // @Test(groups = "online")
-    public void redirected302Test() throws Exception {
-        isSet.getAndSet(false);
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "https://www.microsoft.com/").execute().get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-
-            String anyMicrosoftPage = "https://www.microsoft.com[^:]*:443";
-            String baseUrl = getBaseUrl(response.getUri());
-
-            assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
-        }
+  }
+
+  @Test(groups = "online", enabled = false)
+  public void notRedirected302Test() throws Exception {
+    isSet.getAndSet(false);
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 302);
     }
-
-    // @Test(groups = "online")
-    public void notRedirected302Test() throws Exception {
-        isSet.getAndSet(false);
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 302);
-        }
+  }
+
+  private String getBaseUrl(Uri uri) {
+    String url = uri.toString();
+    int port = uri.getPort();
+    if (port == -1) {
+      port = getPort(uri);
+      url = url.substring(0, url.length() - 1) + ":" + port;
     }
-
-    private String getBaseUrl(Uri uri) {
-        String url = uri.toString();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url = url.substring(0, url.length() - 1) + ":" + port;
-        }
-        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+    return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+  }
+
+  @Test(groups = "online", enabled = false)
+  public void redirected302InvalidTest() throws Exception {
+    isSet.getAndSet(false);
+    Exception e = null;
+
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+    } catch (ExecutionException ex) {
+      e = ex;
     }
 
-    private static int getPort(Uri uri) {
-        int port = uri.getPort();
-        if (port == -1)
-            port = uri.getScheme().equals("http") ? 80 : 443;
-        return port;
+    assertNotNull(e);
+    Throwable cause = e.getCause();
+    assertTrue(cause instanceof ConnectException);
+    assertTrue(cause.getMessage().contains(":" + port2));
+  }
+
+  @Test(enabled = false)
+  public void relativeLocationUrl() throws Exception {
+    isSet.getAndSet(false);
+
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getUri().toString(), getTargetUrl());
     }
+  }
 
-    // @Test(groups = "standalone")
-    public void redirected302InvalidTest() throws Exception {
-        isSet.getAndSet(false);
-        Exception e = null;
+  private class Relative302Handler extends AbstractHandler {
 
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-        } catch (ExecutionException ex) {
-            e = ex;
-        }
-
-        assertNotNull(e);
-        Throwable cause = e.getCause();
-        assertTrue(cause instanceof ConnectException);
-        assertTrue(cause.getMessage().contains(":" + port2));
-    }
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-    // @Test(groups = "standalone")
-    public void relativeLocationUrl() throws Exception {
-        isSet.getAndSet(false);
+      String param;
+      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
 
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getUri().toString(), getTargetUrl());
+        if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
+          httpResponse.addHeader("Location", httpRequest.getHeader(param));
+          httpResponse.setStatus(302);
+          httpResponse.getOutputStream().flush();
+          httpResponse.getOutputStream().close();
+          return;
         }
+      }
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 7b878ec13..219860292 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -15,175 +15,167 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.AsyncContext;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import static org.testng.Assert.*;
 
 /**
  * Per request timeout configuration test.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class PerRequestTimeoutTest extends AbstractBasicTest {
-    private static final String MSG = "Enough is enough.";
-
-    private void checkTimeoutMessage(String message, boolean requestTimeout) {
-        if (requestTimeout)
-            assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
-        else
-            assertTrue(message.startsWith("Read timeout"), "error message indicates reason of error but got: " + message);
-        assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
-        assertTrue(message.contains("after 100 ms"), "error message contains timeout configuration value but got: " + message);
+  private static final String MSG = "Enough is enough.";
+
+  private void checkTimeoutMessage(String message, boolean requestTimeout) {
+    if (requestTimeout)
+      assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
+    else
+      assertTrue(message.startsWith("Read timeout"), "error message indicates reason of error but got: " + message);
+    assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
+    assertTrue(message.contains("after 100 ms"), "error message contains timeout configuration value but got: " + message);
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new SlowHandler();
+  }
+
+  @Test
+  public void testRequestTimeout() throws IOException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
+      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+      assertNull(response);
+    } catch (InterruptedException e) {
+      fail("Interrupted.", e);
+    } catch (ExecutionException e) {
+      assertTrue(e.getCause() instanceof TimeoutException);
+      checkTimeoutMessage(e.getCause().getMessage(), true);
+    } catch (TimeoutException e) {
+      fail("Timeout.", e);
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SlowHandler();
+  }
+
+  @Test
+  public void testReadTimeout() throws IOException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setReadTimeout(100))) {
+      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
+      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+      assertNull(response);
+    } catch (InterruptedException e) {
+      fail("Interrupted.", e);
+    } catch (ExecutionException e) {
+      assertTrue(e.getCause() instanceof TimeoutException);
+      checkTimeoutMessage(e.getCause().getMessage(), false);
+    } catch (TimeoutException e) {
+      fail("Timeout.", e);
     }
-
-    private class SlowHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
-            response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        Thread.sleep(1500);
-                        response.getOutputStream().print(MSG);
-                        response.getOutputStream().flush();
-                    } catch (InterruptedException e) {
-                        logger.error(e.getMessage(), e);
-                    } catch (IOException e) {
-                        logger.error(e.getMessage(), e);
-                    }
-                }
-            }).start();
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        Thread.sleep(3000);
-                        response.getOutputStream().print(MSG);
-                        response.getOutputStream().flush();
-                        asyncContext.complete();
-                    } catch (InterruptedException e) {
-                        logger.error(e.getMessage(), e);
-                    } catch (IOException e) {
-                        logger.error(e.getMessage(), e);
-                    }
-                }
-            }).start();
-            baseRequest.setHandled(true);
-        }
+  }
+
+  @Test
+  public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
+      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
+      Response response = responseFuture.get();
+      assertNotNull(response);
+    } catch (InterruptedException e) {
+      fail("Interrupted.", e);
+    } catch (ExecutionException e) {
+      assertTrue(e.getCause() instanceof TimeoutException);
+      checkTimeoutMessage(e.getCause().getMessage(), true);
     }
-
-    @Test(groups = "standalone")
-    public void testRequestTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
-            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-            assertNull(response);
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        } catch (ExecutionException e) {
-            assertTrue(e.getCause() instanceof TimeoutException);
-            checkTimeoutMessage(e.getCause().getMessage(), true);
-        } catch (TimeoutException e) {
-            fail("Timeout.", e);
-        }
+  }
+
+  @Test
+  public void testGlobalRequestTimeout() throws IOException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
+      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
+      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+      assertNull(response);
+    } catch (InterruptedException e) {
+      fail("Interrupted.", e);
+    } catch (ExecutionException e) {
+      assertTrue(e.getCause() instanceof TimeoutException);
+      checkTimeoutMessage(e.getCause().getMessage(), true);
+    } catch (TimeoutException e) {
+      fail("Timeout.", e);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testReadTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setReadTimeout(100))) {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
-            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-            assertNull(response);
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        } catch (ExecutionException e) {
-            assertTrue(e.getCause() instanceof TimeoutException);
-            checkTimeoutMessage(e.getCause().getMessage(), false);
-        } catch (TimeoutException e) {
-            fail("Timeout.", e);
-        }
-    }
+  @Test
+  public void testGlobalIdleTimeout() throws IOException {
+    final long times[] = new long[]{-1, -1};
 
-    @Test(groups = "standalone")
-    public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
-            Response response = responseFuture.get();
-            assertNotNull(response);
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        } catch (ExecutionException e) {
-            assertTrue(e.getCause() instanceof TimeoutException);
-            checkTimeoutMessage(e.getCause().getMessage(), true);
+    try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000))) {
+      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
+        @Override
+        public Response onCompleted(Response response) {
+          return response;
         }
-    }
 
-    @Test(groups = "standalone")
-    public void testGlobalRequestTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
-            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-            assertNull(response);
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        } catch (ExecutionException e) {
-            assertTrue(e.getCause() instanceof TimeoutException);
-            checkTimeoutMessage(e.getCause().getMessage(), true);
-        } catch (TimeoutException e) {
-            fail("Timeout.", e);
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+          times[0] = unpreciseMillisTime();
+          return super.onBodyPartReceived(content);
         }
-    }
 
-    @Test(groups = "standalone")
-    public void testGlobalIdleTimeout() throws IOException {
-        final long times[] = new long[] { -1, -1 };
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000))) {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    return response;
-                }
-
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    times[0] = unpreciseMillisTime();
-                    return super.onBodyPartReceived(content);
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    times[1] = unpreciseMillisTime();
-                    super.onThrowable(t);
-                }
-            });
-            Response response = responseFuture.get();
-            assertNotNull(response);
-            assertEquals(response.getResponseBody(), MSG + MSG);
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        } catch (ExecutionException e) {
-            logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
-            fail("Timeouted on idle.", e);
+        @Override
+        public void onThrowable(Throwable t) {
+          times[1] = unpreciseMillisTime();
+          super.onThrowable(t);
         }
+      });
+      Response response = responseFuture.get();
+      assertNotNull(response);
+      assertEquals(response.getResponseBody(), MSG + MSG);
+    } catch (InterruptedException e) {
+      fail("Interrupted.", e);
+    } catch (ExecutionException e) {
+      logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
+      fail("Timeouted on idle.", e);
+    }
+  }
+
+  private class SlowHandler extends AbstractHandler {
+    public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+      response.setStatus(HttpServletResponse.SC_OK);
+      final AsyncContext asyncContext = request.startAsync();
+      new Thread(() -> {
+          try {
+            Thread.sleep(1500);
+            response.getOutputStream().print(MSG);
+            response.getOutputStream().flush();
+          } catch (InterruptedException | IOException e) {
+            logger.error(e.getMessage(), e);
+          }
+      }).start();
+      new Thread(() -> {
+          try {
+            Thread.sleep(3000);
+            response.getOutputStream().print(MSG);
+            response.getOutputStream().flush();
+            asyncContext.complete();
+          } catch (InterruptedException | IOException e) {
+            logger.error(e.getMessage(), e);
+          }
+      }).start();
+      baseRequest.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
index 4762556fb..c231b3761 100644
--- a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
@@ -12,191 +12,186 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-public class PostRedirectGetTest extends AbstractBasicTest {
-
-    // ------------------------------------------------------ Test Configuration
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new PostRedirectGetHandler();
-    }
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
 
-    // ------------------------------------------------------------ Test Methods
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
 
-    @Test(groups = "standalone")
-    public void postRedirectGet302Test() throws Exception {
-        doTestPositive(302);
-    }
+public class PostRedirectGetTest extends AbstractBasicTest {
 
-    @Test(groups = "standalone")
-    public void postRedirectGet302StrictTest() throws Exception {
-        doTestNegative(302, true);
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new PostRedirectGetHandler();
+  }
+
+  @Test
+  public void postRedirectGet302Test() throws Exception {
+    doTestPositive(302);
+  }
+
+  @Test
+  public void postRedirectGet302StrictTest() throws Exception {
+    doTestNegative(302, true);
+  }
+
+  @Test
+  public void postRedirectGet303Test() throws Exception {
+    doTestPositive(303);
+  }
+
+  @Test
+  public void postRedirectGet301Test() throws Exception {
+    doTestPositive(301);
+  }
+
+  @Test
+  public void postRedirectGet307Test() throws Exception {
+    doTestNegative(307, false);
+  }
+
+  // --------------------------------------------------------- Private Methods
+
+  private void doTestNegative(final int status, boolean strict) throws Exception {
+
+    ResponseFilter responseFilter = new ResponseFilter() {
+      @Override
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        // pass on the x-expect-get and remove the x-redirect
+        // headers if found in the response
+        ctx.getResponseHeaders().get("x-expect-post");
+        ctx.getRequest().getHeaders().add("x-expect-post", "true");
+        ctx.getRequest().getHeaders().remove("x-redirect");
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(responseFilter))) {
+      Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+      Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
-    @Test(groups = "standalone")
-    public void postRedirectGet303Test() throws Exception {
-        doTestPositive(303);
-    }
+        @Override
+        public Integer onCompleted(Response response) {
+          return response.getStatusCode();
+        }
 
-    @Test(groups = "standalone")
-    public void postRedirectGet301Test() throws Exception {
-        doTestPositive(301);
-    }
+        @Override
+        public void onThrowable(Throwable t) {
+          t.printStackTrace();
+          fail("Unexpected exception: " + t.getMessage(), t);
+        }
 
-    @Test(groups = "standalone")
-    public void postRedirectGet307Test() throws Exception {
-        doTestNegative(307, false);
+      });
+      int statusCode = responseFuture.get();
+      assertEquals(statusCode, 200);
     }
+  }
+
+  private void doTestPositive(final int status) throws Exception {
+
+    ResponseFilter responseFilter = new ResponseFilter() {
+      @Override
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        // pass on the x-expect-get and remove the x-redirect
+        // headers if found in the response
+        ctx.getResponseHeaders().get("x-expect-get");
+        ctx.getRequest().getHeaders().add("x-expect-get", "true");
+        ctx.getRequest().getHeaders().remove("x-redirect");
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(responseFilter))) {
+      Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+      Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
-    // --------------------------------------------------------- Private Methods
-
-    private void doTestNegative(final int status, boolean strict) throws Exception {
-
-        ResponseFilter responseFilter = new ResponseFilter() {
-            @Override
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                // pass on the x-expect-get and remove the x-redirect
-                // headers if found in the response
-                ctx.getResponseHeaders().get("x-expect-post");
-                ctx.getRequest().getHeaders().add("x-expect-post", "true");
-                ctx.getRequest().getHeaders().remove("x-redirect");
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(responseFilter))) {
-            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
-            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
-                @Override
-                public Integer onCompleted(Response response) throws Exception {
-                    return response.getStatusCode();
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    fail("Unexpected exception: " + t.getMessage(), t);
-                }
-
-            });
-            int statusCode = responseFuture.get();
-            assertEquals(statusCode, 200);
+        @Override
+        public Integer onCompleted(Response response) {
+          return response.getStatusCode();
         }
-    }
 
-    private void doTestPositive(final int status) throws Exception {
-
-        ResponseFilter responseFilter = new ResponseFilter() {
-            @Override
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                // pass on the x-expect-get and remove the x-redirect
-                // headers if found in the response
-                ctx.getResponseHeaders().get("x-expect-get");
-                ctx.getRequest().getHeaders().add("x-expect-get", "true");
-                ctx.getRequest().getHeaders().remove("x-redirect");
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(responseFilter))) {
-            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
-            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
-                @Override
-                public Integer onCompleted(Response response) throws Exception {
-                    return response.getStatusCode();
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    fail("Unexpected exception: " + t.getMessage(), t);
-                }
-
-            });
-            int statusCode = responseFuture.get();
-            assertEquals(statusCode, 200);
+        @Override
+        public void onThrowable(Throwable t) {
+          t.printStackTrace();
+          fail("Unexpected exception: " + t.getMessage(), t);
         }
+
+      });
+      int statusCode = responseFuture.get();
+      assertEquals(statusCode, 200);
     }
+  }
 
-    // ---------------------------------------------------------- Nested Classes
+  // ---------------------------------------------------------- Nested Classes
 
-    public static class PostRedirectGetHandler extends AbstractHandler {
+  public static class PostRedirectGetHandler extends AbstractHandler {
 
-        final AtomicInteger counter = new AtomicInteger();
+    final AtomicInteger counter = new AtomicInteger();
 
-        @Override
-        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
-            final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
-            if (expectGet) {
-                final String method = request.getMethod();
-                if (!"GET".equals(method)) {
-                    httpResponse.sendError(500, "Incorrect method.  Expected GET, received " + method);
-                    return;
-                }
-                httpResponse.setStatus(200);
-                httpResponse.getOutputStream().write("OK".getBytes());
-                httpResponse.getOutputStream().flush();
-                return;
-            } else if (expectPost) {
-                final String method = request.getMethod();
-                if (!"POST".equals(method)) {
-                    httpResponse.sendError(500, "Incorrect method.  Expected POST, received " + method);
-                    return;
-                }
-                httpResponse.setStatus(200);
-                httpResponse.getOutputStream().write("OK".getBytes());
-                httpResponse.getOutputStream().flush();
-                return;
-            }
-
-            String header = httpRequest.getHeader("x-redirect");
-            if (header != null) {
-                // format for header is <status code>|<location url>
-                String[] parts = header.split("@");
-                int redirectCode;
-                try {
-                    redirectCode = Integer.parseInt(parts[0]);
-                } catch (Exception ex) {
-                    ex.printStackTrace();
-                    httpResponse.sendError(500, "Unable to parse redirect code");
-                    return;
-                }
-                httpResponse.setStatus(redirectCode);
-                if (httpRequest.getHeader("x-negative") == null) {
-                    httpResponse.addHeader("x-expect-get", "true");
-                } else {
-                    httpResponse.addHeader("x-expect-post", "true");
-                }
-                httpResponse.setContentLength(0);
-                httpResponse.addHeader("Location", parts[1] + counter.getAndIncrement());
-                httpResponse.getOutputStream().flush();
-                return;
-            }
-
-            httpResponse.sendError(500);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
+    @Override
+    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
+      final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
+      if (expectGet) {
+        final String method = request.getMethod();
+        if (!"GET".equals(method)) {
+          httpResponse.sendError(500, "Incorrect method.  Expected GET, received " + method);
+          return;
+        }
+        httpResponse.setStatus(200);
+        httpResponse.getOutputStream().write("OK".getBytes());
+        httpResponse.getOutputStream().flush();
+        return;
+      } else if (expectPost) {
+        final String method = request.getMethod();
+        if (!"POST".equals(method)) {
+          httpResponse.sendError(500, "Incorrect method.  Expected POST, received " + method);
+          return;
+        }
+        httpResponse.setStatus(200);
+        httpResponse.getOutputStream().write("OK".getBytes());
+        httpResponse.getOutputStream().flush();
+        return;
+      }
+
+      String header = httpRequest.getHeader("x-redirect");
+      if (header != null) {
+        // format for header is <status code>|<location url>
+        String[] parts = header.split("@");
+        int redirectCode;
+        try {
+          redirectCode = Integer.parseInt(parts[0]);
+        } catch (Exception ex) {
+          ex.printStackTrace();
+          httpResponse.sendError(500, "Unable to parse redirect code");
+          return;
+        }
+        httpResponse.setStatus(redirectCode);
+        if (httpRequest.getHeader("x-negative") == null) {
+          httpResponse.addHeader("x-expect-get", "true");
+        } else {
+          httpResponse.addHeader("x-expect-post", "true");
         }
+        httpResponse.setContentLength(0);
+        httpResponse.addHeader("Location", parts[1] + counter.getAndIncrement());
+        httpResponse.getOutputStream().flush();
+        return;
+      }
+
+      httpResponse.sendError(500);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
deleted file mode 100644
index 3ac1f67e8..000000000
--- a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-/**
- * Tests POST request with Query String.
- * 
- * @author Hubert Iwaniuk
- */
-public class PostWithQSTest extends AbstractBasicTest {
-
-    /**
-     * POST with QS server part.
-     */
-    private class PostWithQSHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("POST".equalsIgnoreCase(request.getMethod())) {
-                String qs = request.getQueryString();
-                if (isNonEmpty(qs) && request.getContentLength() == 3) {
-                    ServletInputStream is = request.getInputStream();
-                    response.setStatus(HttpServletResponse.SC_OK);
-                    byte buf[] = new byte[is.available()];
-                    is.readLine(buf, 0, is.available());
-                    ServletOutputStream os = response.getOutputStream();
-                    os.println(new String(buf));
-                    os.flush();
-                    os.close();
-                } else {
-                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
-                }
-            } else { // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-                @Override
-                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=")) {
-                        throw new IOException(status.getUri().toUrl());
-                    }
-                    return super.onStatusReceived(status);
-                }
-
-            });
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-                @Override
-                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
-                        throw new IOException("failed to parse the query properly");
-                    }
-                    return super.onStatusReceived(status);
-                }
-
-            });
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-                @Override
-                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
-                        throw new IOException("failed to parse the query properly");
-                    }
-                    return super.onStatusReceived(status);
-                }
-
-            });
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        }
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new PostWithQSHandler();
-    }
-}
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQueryStringTest.java b/client/src/test/java/org/asynchttpclient/PostWithQueryStringTest.java
new file mode 100644
index 000000000..e1e2a7960
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/PostWithQueryStringTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * This program is licensed to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+/**
+ * Tests POST request with Query String.
+ *
+ * @author Hubert Iwaniuk
+ */
+public class PostWithQueryStringTest extends AbstractBasicTest {
+
+  @Test
+  public void postWithQueryString() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+    }
+  }
+
+  @Test
+  public void postWithNullQueryParam() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+        @Override
+        public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+          if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
+            throw new IOException("failed to parse the query properly");
+          }
+          return super.onStatusReceived(status);
+        }
+
+      });
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+    }
+  }
+
+  @Test
+  public void postWithEmptyParamsQueryString() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+        @Override
+        public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+          if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
+            throw new IOException("failed to parse the query properly");
+          }
+          return super.onStatusReceived(status);
+        }
+
+      });
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+    }
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new PostWithQueryStringHandler();
+  }
+
+  /**
+   * POST with QueryString server part.
+   */
+  private class PostWithQueryStringHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("POST".equalsIgnoreCase(request.getMethod())) {
+        String qs = request.getQueryString();
+        if (isNonEmpty(qs) && request.getContentLength() == 3) {
+          ServletInputStream is = request.getInputStream();
+          response.setStatus(HttpServletResponse.SC_OK);
+          byte buf[] = new byte[is.available()];
+          is.readLine(buf, 0, is.available());
+          ServletOutputStream os = response.getOutputStream();
+          os.println(new String(buf));
+          os.flush();
+          os.close();
+        } else {
+          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+        }
+      } else { // this handler is to handle POST request
+        response.sendError(HttpServletResponse.SC_FORBIDDEN);
+      }
+    }
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
index d724dd35b..1691e8138 100644
--- a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
+++ b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -15,11 +15,13 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
@@ -28,78 +30,76 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 /**
  * Testing query parameters support.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class QueryParametersTest extends AbstractBasicTest {
-    private class QueryStringHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("GET".equalsIgnoreCase(request.getMethod())) {
-                String qs = request.getQueryString();
-                if (isNonEmpty(qs)) {
-                    for (String qnv : qs.split("&")) {
-                        String nv[] = qnv.split("=");
-                        response.addHeader(nv[0], nv[1]);
-                    }
-                    response.setStatus(HttpServletResponse.SC_OK);
-                } else {
-                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
-                }
-            } else { // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-            r.setHandled(true);
-        }
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new QueryStringHandler();
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new QueryStringHandler();
+  @Test
+  public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("a"), "1");
+      assertEquals(resp.getHeader("b"), "2");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("a"), "1");
-            assertEquals(resp.getHeader("b"), "2");
-        }
+  @Test
+  public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
+    String URL = getTargetUrl() + "?q=";
+    String REQUEST_PARAM = "github github \ngithub";
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
+      logger.info("Executing request [{}] ...", requestUrl2);
+      Response response = client.prepareGet(requestUrl2).execute().get();
+      String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
+      assertEquals(s, REQUEST_PARAM);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
-        String URL = getTargetUrl() + "?q=";
-        String REQUEST_PARAM = "github github \ngithub";
+  @Test
+  public void urlWithColonTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      String query = "test:colon:";
+      Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
-            logger.info("Executing request [{}] ...", requestUrl2);
-            Response response = client.prepareGet(requestUrl2).execute().get();
-            String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
-            assertEquals(s, REQUEST_PARAM);
-        }
+      assertEquals(response.getHeader("q"), query);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void urlWithColonTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            String query = "test:colon:";
-            Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-            assertEquals(response.getHeader("q"), query);
+  private class QueryStringHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("GET".equalsIgnoreCase(request.getMethod())) {
+        String qs = request.getQueryString();
+        if (isNonEmpty(qs)) {
+          for (String qnv : qs.split("&")) {
+            String nv[] = qnv.split("=");
+            response.addHeader(nv[0], nv[1]);
+          }
+          response.setStatus(HttpServletResponse.SC_OK);
+        } else {
+          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
         }
+      } else { // this handler is to handle POST request
+        response.sendError(HttpServletResponse.SC_FORBIDDEN);
+      }
+      r.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RC1KTest.java b/client/src/test/java/org/asynchttpclient/RC1KTest.java
index fd2b043b4..93ac24545 100644
--- a/client/src/test/java/org/asynchttpclient/RC1KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC1KTest.java
@@ -15,126 +15,125 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 /**
  * Reverse C1K Problem test.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class RC1KTest extends AbstractBasicTest {
-    private static final int C1K = 1000;
-    private static final String ARG_HEADER = "Arg";
-    private static final int SRV_COUNT = 10;
-    protected Server[] servers = new Server[SRV_COUNT];
-    private int[] ports = new int[SRV_COUNT];
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        ports = new int[SRV_COUNT];
-        for (int i = 0; i < SRV_COUNT; i++) {
-            Server server = new Server();
-            ServerConnector connector = addHttpConnector(server);
-            server.setHandler(configureHandler());
-            server.start();
-            servers[i] = server;
-            ports[i] = connector.getLocalPort();
-        }
-        logger.info("Local HTTP servers started successfully");
+  private static final int C1K = 1000;
+  private static final String ARG_HEADER = "Arg";
+  private static final int SRV_COUNT = 10;
+  private Server[] servers = new Server[SRV_COUNT];
+  private int[] ports = new int[SRV_COUNT];
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    ports = new int[SRV_COUNT];
+    for (int i = 0; i < SRV_COUNT; i++) {
+      Server server = new Server();
+      ServerConnector connector = addHttpConnector(server);
+      server.setHandler(configureHandler());
+      server.start();
+      servers[i] = server;
+      ports[i] = connector.getLocalPort();
     }
+    logger.info("Local HTTP servers started successfully");
+  }
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        for (Server srv : servers) {
-            srv.stop();
-        }
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    for (Server srv : servers) {
+      srv.stop();
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
-            public void handle(String s, Request r, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
-                resp.setContentType("text/pain");
-                String arg = s.substring(1);
-                resp.setHeader(ARG_HEADER, arg);
-                resp.setStatus(200);
-                resp.getOutputStream().print(arg);
-                resp.getOutputStream().flush();
-                resp.getOutputStream().close();
-            }
-        };
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
+      public void handle(String s, Request r, HttpServletRequest req, HttpServletResponse resp) throws IOException {
+        resp.setContentType("text/pain");
+        String arg = s.substring(1);
+        resp.setHeader(ARG_HEADER, arg);
+        resp.setStatus(200);
+        resp.getOutputStream().print(arg);
+        resp.getOutputStream().flush();
+        resp.getOutputStream().close();
+      }
+    };
+  }
+
+  @Test(timeOut = 10 * 60 * 1000)
+  public void rc10kProblem() throws IOException, ExecutionException, InterruptedException {
+    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C1K).setKeepAlive(true))) {
+      List<Future<Integer>> resps = new ArrayList<>(C1K);
+      int i = 0;
+      while (i < C1K) {
+        resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+      }
+      i = 0;
+      for (Future<Integer> fResp : resps) {
+        Integer resp = fResp.get();
+        assertNotNull(resp);
+        assertEquals(resp.intValue(), i++);
+      }
     }
+  }
 
-    @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
-    public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C1K).setKeepAlive(true))) {
-            List<Future<Integer>> resps = new ArrayList<>(C1K);
-            int i = 0;
-            while (i < C1K) {
-                resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
-            }
-            i = 0;
-            for (Future<Integer> fResp : resps) {
-                Integer resp = fResp.get();
-                assertNotNull(resp);
-                assertEquals(resp.intValue(), i++);
-            }
-        }
-    }
-
-    private class MyAsyncHandler implements AsyncHandler<Integer> {
-        private String arg;
-        private AtomicInteger result = new AtomicInteger(-1);
+  private class MyAsyncHandler implements AsyncHandler<Integer> {
+    private String arg;
+    private AtomicInteger result = new AtomicInteger(-1);
 
-        public MyAsyncHandler(int i) {
-            arg = String.format("%d", i);
-        }
+    MyAsyncHandler(int i) {
+      arg = String.format("%d", i);
+    }
 
-        public void onThrowable(Throwable t) {
-            logger.warn("onThrowable called.", t);
-        }
+    public void onThrowable(Throwable t) {
+      logger.warn("onThrowable called.", t);
+    }
 
-        public State onBodyPartReceived(HttpResponseBodyPart event) throws Exception {
-            String s = new String(event.getBodyPartBytes());
-            result.compareAndSet(-1, new Integer(s.trim().equals("") ? "-1" : s));
-            return State.CONTINUE;
-        }
+    public State onBodyPartReceived(HttpResponseBodyPart event) {
+      String s = new String(event.getBodyPartBytes());
+      result.compareAndSet(-1, new Integer(s.trim().equals("") ? "-1" : s));
+      return State.CONTINUE;
+    }
 
-        public State onStatusReceived(HttpResponseStatus event) throws Exception {
-            assertEquals(event.getStatusCode(), 200);
-            return State.CONTINUE;
-        }
+    public State onStatusReceived(HttpResponseStatus event) {
+      assertEquals(event.getStatusCode(), 200);
+      return State.CONTINUE;
+    }
 
-        public State onHeadersReceived(HttpHeaders event) throws Exception {
-            assertEquals(event.get(ARG_HEADER), arg);
-            return State.CONTINUE;
-        }
+    public State onHeadersReceived(HttpHeaders event) {
+      assertEquals(event.get(ARG_HEADER), arg);
+      return State.CONTINUE;
+    }
 
-        public Integer onCompleted() throws Exception {
-            return result.get();
-        }
+    public Integer onCompleted() {
+      return result.get();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RealmTest.java b/client/src/test/java/org/asynchttpclient/RealmTest.java
index cb079189c..5f17a9b6f 100644
--- a/client/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/client/src/test/java/org/asynchttpclient/RealmTest.java
@@ -12,97 +12,97 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_16;
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StringUtils;
+import org.testng.annotations.Test;
 
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.StringUtils;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_16;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
 
 public class RealmTest {
-    @Test(groups = "standalone")
-    public void testClone() {
-        Realm orig = basicAuthRealm("user", "pass").setCharset(UTF_16)//
-                .setUsePreemptiveAuth(true)//
-                .setRealmName("realm")//
-                .setAlgorithm("algo").build();
+  @Test
+  public void testClone() {
+    Realm orig = basicAuthRealm("user", "pass").setCharset(UTF_16)
+            .setUsePreemptiveAuth(true)
+            .setRealmName("realm")
+            .setAlgorithm("algo").build();
 
-        Realm clone = realm(orig).build();
-        assertEquals(clone.getPrincipal(), orig.getPrincipal());
-        assertEquals(clone.getPassword(), orig.getPassword());
-        assertEquals(clone.getCharset(), orig.getCharset());
-        assertEquals(clone.isUsePreemptiveAuth(), orig.isUsePreemptiveAuth());
-        assertEquals(clone.getRealmName(), orig.getRealmName());
-        assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
-        assertEquals(clone.getScheme(), orig.getScheme());
-    }
+    Realm clone = realm(orig).build();
+    assertEquals(clone.getPrincipal(), orig.getPrincipal());
+    assertEquals(clone.getPassword(), orig.getPassword());
+    assertEquals(clone.getCharset(), orig.getCharset());
+    assertEquals(clone.isUsePreemptiveAuth(), orig.isUsePreemptiveAuth());
+    assertEquals(clone.getRealmName(), orig.getRealmName());
+    assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
+    assertEquals(clone.getScheme(), orig.getScheme());
+  }
 
-    @Test(groups = "standalone")
-    public void testOldDigestEmptyString() throws Exception {
-        testOldDigest("");
-    }
+  @Test
+  public void testOldDigestEmptyString() throws Exception {
+    testOldDigest("");
+  }
 
-    @Test(groups = "standalone")
-    public void testOldDigestNull() throws Exception {
-        testOldDigest(null);
-    }
+  @Test
+  public void testOldDigestNull() throws Exception {
+    testOldDigest(null);
+  }
 
-    private void testOldDigest(String qop) throws Exception {
-        String user = "user";
-        String pass = "pass";
-        String realm = "realm";
-        String nonce = "nonce";
-        String method = "GET";
-        Uri uri = Uri.create("http://ahc.io/foo");
-        Realm orig = digestAuthRealm(user, pass)//
-                .setNonce(nonce)//
-                .setUri(uri)//
-                .setMethodName(method)//
-                .setRealmName(realm)//
-                .setQop(qop)//
-                .build();
+  private void testOldDigest(String qop) throws Exception {
+    String user = "user";
+    String pass = "pass";
+    String realm = "realm";
+    String nonce = "nonce";
+    String method = "GET";
+    Uri uri = Uri.create("http://ahc.io/foo");
+    Realm orig = digestAuthRealm(user, pass)
+            .setNonce(nonce)
+            .setUri(uri)
+            .setMethodName(method)
+            .setRealmName(realm)
+            .setQop(qop)
+            .build();
 
-        String ha1 = getMd5(user + ":" + realm + ":" + pass);
-        String ha2 = getMd5(method + ":" + uri.getPath());
-        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
+    String ha1 = getMd5(user + ":" + realm + ":" + pass);
+    String ha2 = getMd5(method + ":" + uri.getPath());
+    String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
 
-        assertEquals(orig.getResponse(), expectedResponse);
-    }
+    assertEquals(orig.getResponse(), expectedResponse);
+  }
 
-    @Test(groups = "standalone")
-    public void testStrongDigest() throws Exception {
-        String user = "user";
-        String pass = "pass";
-        String realm = "realm";
-        String nonce = "nonce";
-        String method = "GET";
-        Uri uri = Uri.create("http://ahc.io/foo");
-        String qop = "auth";
-        Realm orig = digestAuthRealm(user, pass)//
-                .setNonce(nonce)//
-                .setUri(uri)//
-                .setMethodName(method)//
-                .setRealmName(realm)//
-                .setQop(qop)//
-                .build();
+  @Test
+  public void testStrongDigest() throws Exception {
+    String user = "user";
+    String pass = "pass";
+    String realm = "realm";
+    String nonce = "nonce";
+    String method = "GET";
+    Uri uri = Uri.create("http://ahc.io/foo");
+    String qop = "auth";
+    Realm orig = digestAuthRealm(user, pass)
+            .setNonce(nonce)
+            .setUri(uri)
+            .setMethodName(method)
+            .setRealmName(realm)
+            .setQop(qop)
+            .build();
 
-        String nc = orig.getNc();
-        String cnonce = orig.getCnonce();
-        String ha1 = getMd5(user + ":" + realm + ":" + pass);
-        String ha2 = getMd5(method + ":" + uri.getPath());
-        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
+    String nc = orig.getNc();
+    String cnonce = orig.getCnonce();
+    String ha1 = getMd5(user + ":" + realm + ":" + pass);
+    String ha2 = getMd5(method + ":" + uri.getPath());
+    String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
 
-        assertEquals(orig.getResponse(), expectedResponse);
-    }
+    assertEquals(orig.getResponse(), expectedResponse);
+  }
 
-    private String getMd5(String what) throws Exception {
-        MessageDigest md = MessageDigest.getInstance("MD5");
-        md.update(what.getBytes(StandardCharsets.ISO_8859_1));
-        byte[] hash = md.digest();
-        return StringUtils.toHexString(hash);
-    }
+  private String getMd5(String what) throws Exception {
+    MessageDigest md = MessageDigest.getInstance("MD5");
+    md.update(what.getBytes(StandardCharsets.ISO_8859_1));
+    byte[] hash = md.digest();
+    return StringUtils.toHexString(hash);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index 8de3d2b98..935c51cef 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -13,117 +13,110 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.apache.commons.io.IOUtils;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-public class RedirectBodyTest extends AbstractBasicTest {
-
-    private String receivedContentType;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
-    @BeforeMethod
-    public void setUp() throws Exception {
-        receivedContentType = null;
-    }
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
-            @Override
-            public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-                String redirectHeader = httpRequest.getHeader("X-REDIRECT");
-                if (redirectHeader != null) {
-                    httpResponse.setStatus(Integer.valueOf(redirectHeader));
-                    httpResponse.setContentLength(0);
-                    httpResponse.setHeader("Location", getTargetUrl());
-
-                } else {
-                    httpResponse.setStatus(200);
-                    int len = request.getContentLength();
-                    httpResponse.setContentLength(len);
-                    if (len > 0) {
-                        byte[] buffer = new byte[len];
-                        IOUtils.read(request.getInputStream(), buffer);
-                        httpResponse.getOutputStream().write(buffer);
-                    }
-                    receivedContentType = request.getContentType();
-                }
-                httpResponse.getOutputStream().flush();
-                httpResponse.getOutputStream().close();
-            }
-        };
-    }
+public class RedirectBodyTest extends AbstractBasicTest {
 
-    private ResponseFilter redirectOnce = new ResponseFilter() {
-        @Override
-        public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-            ctx.getRequest().getHeaders().remove("X-REDIRECT");
-            return ctx;
+  private volatile boolean redirectAlreadyPerformed;
+  private volatile String receivedContentType;
+
+  @BeforeMethod
+  public void setUp() {
+    redirectAlreadyPerformed = false;
+    receivedContentType = null;
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
+      @Override
+      public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException {
+
+        String redirectHeader = httpRequest.getHeader("X-REDIRECT");
+        if (redirectHeader != null && !redirectAlreadyPerformed) {
+          redirectAlreadyPerformed = true;
+          httpResponse.setStatus(Integer.valueOf(redirectHeader));
+          httpResponse.setContentLength(0);
+          httpResponse.setHeader(LOCATION.toString(), getTargetUrl());
+
+        } else {
+          receivedContentType = request.getContentType();
+          httpResponse.setStatus(200);
+          int len = request.getContentLength();
+          httpResponse.setContentLength(len);
+          if (len > 0) {
+            byte[] buffer = new byte[len];
+            IOUtils.read(request.getInputStream(), buffer);
+            httpResponse.getOutputStream().write(buffer);
+          }
         }
+        httpResponse.getOutputStream().flush();
+        httpResponse.getOutputStream().close();
+      }
     };
+  }
 
-    @Test(groups = "standalone")
-    public void regular301LosesBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
-            String body = "hello there";
-            String contentType = "text/plain";
+  @Test
+  public void regular301LosesBody() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      String body = "hello there";
+      String contentType = "text/plain; charset=UTF-8";
 
-            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(response.getResponseBody(), "");
-            assertNull(receivedContentType);
-        }
+      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(response.getResponseBody(), "");
+      assertNull(receivedContentType);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void regular302LosesBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
-            String body = "hello there";
-            String contentType = "text/plain";
+  @Test
+  public void regular302LosesBody() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      String body = "hello there";
+      String contentType = "text/plain; charset=UTF-8";
 
-            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(response.getResponseBody(), "");
-            assertNull(receivedContentType);
-        }
+      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(response.getResponseBody(), "");
+      assertNull(receivedContentType);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void regular302StrictKeepsBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce))) {
-            String body = "hello there";
-            String contentType = "text/plain";
+  @Test
+  public void regular302StrictKeepsBody() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true))) {
+      String body = "hello there";
+      String contentType = "text/plain; charset=UTF-8";
 
-            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(response.getResponseBody(), body);
-            assertEquals(receivedContentType, contentType);
-        }
+      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(response.getResponseBody(), body);
+      assertEquals(receivedContentType, contentType);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void regular307KeepsBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
-            String body = "hello there";
-            String contentType = "text/plain";
+  @Test
+  public void regular307KeepsBody() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      String body = "hello there";
+      String contentType = "text/plain; charset=UTF-8";
 
-            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(response.getResponseBody(), body);
-            assertEquals(receivedContentType, contentType);
-        }
+      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(response.getResponseBody(), body);
+      assertEquals(receivedContentType, contentType);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
index ce495d1b9..70a76f2b8 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
@@ -15,19 +15,6 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Date;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
@@ -35,87 +22,98 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Date;
+
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 /**
  * Test for multithreaded url fetcher calls that use two separate sets of ssl certificates. This then tests that the certificate settings do not clash (override each other),
  * resulting in the peer not authenticated exception
- * 
+ *
  * @author dominict
  */
 public class RedirectConnectionUsageTest extends AbstractBasicTest {
-    private String BASE_URL;
-
-    private String servletEndpointRedirectUrl;
-
-    @BeforeClass
-    public void setUp() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-
-        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-        context.addServlet(new ServletHolder(new MockRedirectHttpServlet()), "/redirect/*");
-        context.addServlet(new ServletHolder(new MockFullResponseHttpServlet()), "/*");
-        server.setHandler(context);
-
-        server.start();
-        port1 = connector.getLocalPort();
-
-        BASE_URL = "http://localhost" + ":" + port1;
-        servletEndpointRedirectUrl = BASE_URL + "/redirect";
-    }
-
-    /**
-     * Tests that after a redirect the final url in the response reflect the redirect
-     */
-    @Test(groups = "standalone")
-    public void testGetRedirectFinalUrl() throws Exception {
-
-        AsyncHttpClientConfig config = config()//
-                .setKeepAlive(true)//
-                .setMaxConnectionsPerHost(1)//
-                .setMaxConnections(1)//
-                .setConnectTimeout(1000)//
-                .setRequestTimeout(1000)//
-                .setFollowRedirect(true)//
-                .build();
-
-        try (AsyncHttpClient c = asyncHttpClient(config)) {
-            ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));
-            Response res = null;
-            res = response.get();
-            assertNotNull(res.getResponseBody());
-            assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
-        }
+  private String BASE_URL;
+
+  private String servletEndpointRedirectUrl;
+
+  @BeforeClass
+  public void setUp() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+
+    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+    context.addServlet(new ServletHolder(new MockRedirectHttpServlet()), "/redirect/*");
+    context.addServlet(new ServletHolder(new MockFullResponseHttpServlet()), "/*");
+    server.setHandler(context);
+
+    server.start();
+    port1 = connector.getLocalPort();
+
+    BASE_URL = "http://localhost" + ":" + port1;
+    servletEndpointRedirectUrl = BASE_URL + "/redirect";
+  }
+
+  /**
+   * Tests that after a redirect the final url in the response reflect the redirect
+   */
+  @Test
+  public void testGetRedirectFinalUrl() throws Exception {
+
+    AsyncHttpClientConfig config = config()
+            .setKeepAlive(true)
+            .setMaxConnectionsPerHost(1)
+            .setMaxConnections(1)
+            .setConnectTimeout(1000)
+            .setRequestTimeout(1000)
+            .setFollowRedirect(true)
+            .build();
+
+    try (AsyncHttpClient c = asyncHttpClient(config)) {
+      ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));
+      Response res = response.get();
+      assertNotNull(res.getResponseBody());
+      assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
     }
+  }
 
-    @SuppressWarnings("serial")
-    class MockRedirectHttpServlet extends HttpServlet {
-        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-            res.sendRedirect("/overthere");
-        }
+  @SuppressWarnings("serial")
+  class MockRedirectHttpServlet extends HttpServlet {
+    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
+      res.sendRedirect("/overthere");
     }
+  }
 
-    @SuppressWarnings("serial")
-    class MockFullResponseHttpServlet extends HttpServlet {
+  @SuppressWarnings("serial")
+  class MockFullResponseHttpServlet extends HttpServlet {
 
-        private static final String contentType = "text/xml";
-        private static final String xml = "<?xml version=\"1.0\"?><hello date=\"%s\"></hello>";
+    private static final String contentType = "text/xml";
+    private static final String xml = "<?xml version=\"1.0\"?><hello date=\"%s\"></hello>";
 
-        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-            String xmlToReturn = String.format(xml, new Object[] { new Date().toString() });
+    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
+      String xmlToReturn = String.format(xml, new Date().toString());
 
-            res.setStatus(200);
-            res.addHeader("Content-Type", contentType);
-            res.addHeader("X-Method", req.getMethod());
-            res.addHeader("MultiValue", "1");
-            res.addHeader("MultiValue", "2");
-            res.addHeader("MultiValue", "3");
+      res.setStatus(200);
+      res.addHeader("Content-Type", contentType);
+      res.addHeader("X-Method", req.getMethod());
+      res.addHeader("MultiValue", "1");
+      res.addHeader("MultiValue", "2");
+      res.addHeader("MultiValue", "3");
 
-            OutputStream os = res.getOutputStream();
+      OutputStream os = res.getOutputStream();
 
-            byte[] retVal = xmlToReturn.getBytes();
-            res.setContentLength(retVal.length);
-            os.write(retVal);
-            os.close();
-        }
+      byte[] retVal = xmlToReturn.getBytes();
+      res.setContentLength(retVal.length);
+      os.write(retVal);
+      os.close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index d978be2a5..af141a158 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -15,10 +15,17 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.uri.Uri;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.URI;
@@ -26,143 +33,136 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.uri.Uri;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 
 public class Relative302Test extends AbstractBasicTest {
-    private final AtomicBoolean isSet = new AtomicBoolean(false);
-
-    private class Relative302Handler extends AbstractHandler {
-
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            String param;
-            httpResponse.setStatus(200);
-            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-
-                if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
-                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
-                    httpResponse.setStatus(302);
-                    break;
-                }
-            }
-            httpResponse.setContentLength(0);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
+  private final AtomicBoolean isSet = new AtomicBoolean(false);
+
+  private static int getPort(Uri uri) {
+    int port = uri.getPort();
+    if (port == -1)
+      port = uri.getScheme().equals("http") ? 80 : 443;
+    return port;
+  }
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(new Relative302Handler());
+    server.start();
+    port1 = connector.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+    port2 = findFreePort();
+  }
+
+  @Test(groups = "online")
+  public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
+    redirected302Test();
+    redirected302InvalidTest();
+    absolutePathRedirectTest();
+    relativePathRedirectTest();
+  }
+
+  @Test(groups = "online", enabled = false)
+  public void redirected302Test() throws Exception {
+    isSet.getAndSet(false);
+
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+
+      String baseUrl = getBaseUrl(response.getUri());
+      assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
     }
+  }
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new Relative302Handler());
-        server.start();
-        port1 = connector.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-        port2 = findFreePort();
-    }
+  @Test(enabled = false)
+  public void redirected302InvalidTest() throws Exception {
+    isSet.getAndSet(false);
 
-    @Test(groups = "online")
-    public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
-        redirected302Test();
-        redirected302InvalidTest();
-        absolutePathRedirectTest();
-        relativePathRedirectTest();
+    Exception e = null;
+
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+    } catch (ExecutionException ex) {
+      e = ex;
     }
 
-    // @Test(groups = "online")
-    public void redirected302Test() throws Exception {
-        isSet.getAndSet(false);
+    assertNotNull(e);
+    Throwable cause = e.getCause();
+    assertTrue(cause instanceof ConnectException);
+    assertTrue(cause.getMessage().contains(":" + port2));
+  }
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
+  @Test(enabled = false)
+  public void absolutePathRedirectTest() throws Exception {
+    isSet.getAndSet(false);
 
-            String baseUrl = getBaseUrl(response.getUri());
-            assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
-        }
-    }
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      String redirectTarget = "/bar/test";
+      String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-//     @Test(groups = "standalone")
-    public void redirected302InvalidTest() throws Exception {
-        isSet.getAndSet(false);
-        
-        Exception e = null;
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getUri().toString(), destinationUrl);
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-        } catch (ExecutionException ex) {
-            e = ex;
-        }
-        
-        assertNotNull(e);
-        Throwable cause = e.getCause();
-        assertTrue(cause instanceof ConnectException);
-        assertTrue(cause.getMessage().contains(":" + port2));
+      logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
     }
+  }
 
-    // @Test(groups = "standalone")
-    public void absolutePathRedirectTest() throws Exception {
-        isSet.getAndSet(false);
+  @Test(enabled = false)
+  public void relativePathRedirectTest() throws Exception {
+    isSet.getAndSet(false);
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            String redirectTarget = "/bar/test";
-            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      String redirectTarget = "bar/test1";
+      String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getUri().toString(), destinationUrl);
+      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getUri().toString(), destinationUrl);
 
-            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        }
+      logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
     }
+  }
+
+  private String getBaseUrl(Uri uri) {
+    String url = uri.toString();
+    int port = uri.getPort();
+    if (port == -1) {
+      port = getPort(uri);
+      url = url.substring(0, url.length() - 1) + ":" + port;
+    }
+    return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+  }
 
-    // @Test(groups = "standalone")
-    public void relativePathRedirectTest() throws Exception {
-        isSet.getAndSet(false);
+  private class Relative302Handler extends AbstractHandler {
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            String redirectTarget = "bar/test1";
-            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getUri().toString(), destinationUrl);
+      String param;
+      httpResponse.setStatus(200);
+      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
 
-            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
+          httpResponse.addHeader("Location", httpRequest.getHeader(param));
+          httpResponse.setStatus(302);
+          break;
         }
+      }
+      httpResponse.setContentLength(0);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
-
-    private String getBaseUrl(Uri uri) {
-        String url = uri.toString();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url = url.substring(0, url.length() - 1) + ":" + port;
-        }
-        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
-    }
-
-    private static int getPort(Uri uri) {
-        int port = uri.getPort();
-        if (port == -1)
-            port = uri.getScheme().equals("http") ? 80 : 443;
-        return port;
-    }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
index 051867bdc..41fed53a4 100644
--- a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
+++ b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
@@ -15,165 +15,172 @@
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Collections.singletonList;
-import static org.asynchttpclient.Dsl.get;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.codec.http.cookie.DefaultCookie;
+import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ExecutionException;
+import java.util.*;
 
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Collections.singletonList;
+import static org.asynchttpclient.Dsl.get;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 public class RequestBuilderTest {
 
-    private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_*.";
-    private final static String HEX_CHARS = "0123456789ABCDEF";
-
-    @Test(groups = "standalone")
-    public void testEncodesQueryParameters() throws UnsupportedEncodingException {
-        String[] values = new String[] { "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKQLMNOPQRSTUVWXYZ", "1234567890", "1234567890", "`~!@#$%^&*()", "`~!@#$%^&*()", "_+-=,.<>/?",
-                "_+-=,.<>/?", ";:'\"[]{}\\| ", ";:'\"[]{}\\| " };
-
-        /*
-         * as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
-         * encode everything except for "safe" characters; and nothing but them.
-         * Safe includes ascii letters (upper and lower case), digits (0 - 9)
-         * and FOUR special characters: hyphen ('-'), underscore ('_'), tilde
-         * ('~') and period ('.')). Everything else must be percent-encoded,
-         * byte-by-byte, using UTF-8 encoding (meaning three-byte Unicode/UTF-8
-         * code points are encoded as three three-letter percent-encode
-         * entities).
-         */
-        for (String value : values) {
-            RequestBuilder builder = get("http://example.com/").addQueryParam("name", value);
-
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0, len = value.length(); i < len; ++i) {
-                char c = value.charAt(i);
-                if (SAFE_CHARS.indexOf(c) >= 0) {
-                    sb.append(c);
-                } else {
-                    int hi = (c >> 4);
-                    int lo = c & 0xF;
-                    sb.append('%').append(HEX_CHARS.charAt(hi)).append(HEX_CHARS.charAt(lo));
-                }
-            }
-            String expValue = sb.toString();
-            Request request = builder.build();
-            assertEquals(request.getUrl(), "http://example.com/?name=" + expValue);
+  private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_*.";
+  private final static String HEX_CHARS = "0123456789ABCDEF";
+
+  @Test
+  public void testEncodesQueryParameters() {
+    String[] values = new String[]{"abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKQLMNOPQRSTUVWXYZ", "1234567890", "1234567890", "`~!@#$%^&*()", "`~!@#$%^&*()", "_+-=,.<>/?",
+            "_+-=,.<>/?", ";:'\"[]{}\\| ", ";:'\"[]{}\\| "};
+
+    /*
+     * as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
+     * encode everything except for "safe" characters; and nothing but them.
+     * Safe includes ascii letters (upper and lower case), digits (0 - 9)
+     * and FOUR special characters: hyphen ('-'), underscore ('_'), tilde
+     * ('~') and period ('.')). Everything else must be percent-encoded,
+     * byte-by-byte, using UTF-8 encoding (meaning three-byte Unicode/UTF-8
+     * code points are encoded as three three-letter percent-encode
+     * entities).
+     */
+    for (String value : values) {
+      RequestBuilder builder = get("http://example.com/").addQueryParam("name", value);
+
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0, len = value.length(); i < len; ++i) {
+        char c = value.charAt(i);
+        if (SAFE_CHARS.indexOf(c) >= 0) {
+          sb.append(c);
+        } else {
+          int hi = (c >> 4);
+          int lo = c & 0xF;
+          sb.append('%').append(HEX_CHARS.charAt(hi)).append(HEX_CHARS.charAt(lo));
         }
+      }
+      String expValue = sb.toString();
+      Request request = builder.build();
+      assertEquals(request.getUrl(), "http://example.com/?name=" + expValue);
     }
-
-    @Test(groups = "standalone")
-    public void testChaining() throws IOException, ExecutionException, InterruptedException {
-        Request request = get("http://foo.com").addQueryParam("x", "value").build();
-
-        Request request2 = new RequestBuilder(request).build();
-
-        assertEquals(request2.getUri(), request.getUri());
-    }
-
-    @Test(groups = "standalone")
-    public void testParsesQueryParams() throws IOException, ExecutionException, InterruptedException {
-        Request request = get("http://foo.com/?param1=value1").addQueryParam("param2", "value2").build();
-
-        assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
-        List<Param> params = request.getQueryParams();
-        assertEquals(params.size(), 2);
-        assertEquals(params.get(0), new Param("param1", "value1"));
-        assertEquals(params.get(1), new Param("param2", "value2"));
-    }
-
-    @Test(groups = "standalone")
-    public void testUserProvidedRequestMethod() {
-        Request req = new RequestBuilder("ABC").setUrl("http://foo.com").build();
-        assertEquals(req.getMethod(), "ABC");
-        assertEquals(req.getUrl(), "http://foo.com");
-    }
-
-    @Test(groups = "standalone")
-    public void testPercentageEncodedUserInfo() {
-        final Request req = get("http://hello:wor%20ld@foo.com").build();
-        assertEquals(req.getMethod(), "GET");
-        assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
-    }
-
-    @Test(groups = "standalone")
-    public void testContentTypeCharsetToBodyEncoding() {
-        final Request req = get("http://localhost").setHeader("Content-Type", "application/json; charset=utf-8").build();
-        assertEquals(req.getCharset(), UTF_8);
-        final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
-        assertEquals(req2.getCharset(), UTF_8);
-    }
-    
-    @Test
-    public void testDefaultMethod() {
-        RequestBuilder requestBuilder = new RequestBuilder();
-        String defaultMethodName = HttpMethod.GET.name();
-        assertEquals(requestBuilder.method, defaultMethodName, "Default HTTP method should be " + defaultMethodName);
-    }
-
-    @Test
-    public void testSetHeaders() {
-        RequestBuilder requestBuilder = new RequestBuilder();
-        assertTrue(requestBuilder.headers.isEmpty(), "Headers should be empty by default.");
-
-        Map<CharSequence, Collection<?>> headers = new HashMap<>();
-        headers.put("Content-Type", Collections.singleton("application/json"));
-        requestBuilder.setHeaders(headers);
-        assertTrue(requestBuilder.headers.contains("Content-Type"), "headers set by setHeaders have not been set");
-        assertEquals(requestBuilder.headers.get("Content-Type"), "application/json", "header value incorrect");
-    }
-
-    public void testAddOrReplaceCookies() {
-        RequestBuilder requestBuilder = new RequestBuilder();
-        Cookie cookie = new DefaultCookie("name", "value");
-        cookie.setDomain("google.com");
-        cookie.setPath("/");
-        cookie.setMaxAge(1000);
-        cookie.setSecure(true);
-        cookie.setHttpOnly(true);
-        requestBuilder.addOrReplaceCookie(cookie);
-        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should be 1 after adding one cookie");
-        assertEquals(requestBuilder.cookies.get(0), cookie, "cookie does not match");
-
-        Cookie cookie2 = new DefaultCookie("name", "value");
-        cookie2.setDomain("google2.com");
-        cookie2.setPath("/path");
-        cookie2.setMaxAge(1001);
-        cookie2.setSecure(false);
-        cookie2.setHttpOnly(false);
-                
-        requestBuilder.addOrReplaceCookie(cookie2);
-        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should remain 1 as we just replaced a cookie with same name");
-        assertEquals(requestBuilder.cookies.get(0), cookie2, "cookie does not match");
-
-        Cookie cookie3 = new DefaultCookie("name", "value");
-        cookie3.setDomain("google.com");
-        cookie3.setPath("/");
-        cookie3.setMaxAge(1000);
-        cookie3.setSecure(true);
-        cookie3.setHttpOnly(true);
-        requestBuilder.addOrReplaceCookie(cookie3);
-        assertEquals(requestBuilder.cookies.size(), 2, "cookie size must be 2 after adding 1 more cookie i.e. cookie3");
-    }
-
-    @Test
-    public void testSettingQueryParamsBeforeUrlShouldNotProduceNPE() {
-        RequestBuilder requestBuilder = new RequestBuilder();
-        requestBuilder.setQueryParams(singletonList(new Param("key", "value")));
-        requestBuilder.setUrl("http://localhost");
-        Request request = requestBuilder.build();
-        assertEquals(request.getUrl(), "http://localhost?key=value");
-    }
+  }
+
+  @Test
+  public void testChaining() {
+    Request request = get("http://foo.com").addQueryParam("x", "value").build();
+
+    Request request2 = new RequestBuilder(request).build();
+
+    assertEquals(request2.getUri(), request.getUri());
+  }
+
+  @Test
+  public void testParsesQueryParams() {
+    Request request = get("http://foo.com/?param1=value1").addQueryParam("param2", "value2").build();
+
+    assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
+    List<Param> params = request.getQueryParams();
+    assertEquals(params.size(), 2);
+    assertEquals(params.get(0), new Param("param1", "value1"));
+    assertEquals(params.get(1), new Param("param2", "value2"));
+  }
+
+  @Test
+  public void testUserProvidedRequestMethod() {
+    Request req = new RequestBuilder("ABC").setUrl("http://foo.com").build();
+    assertEquals(req.getMethod(), "ABC");
+    assertEquals(req.getUrl(), "http://foo.com");
+  }
+
+  @Test
+  public void testPercentageEncodedUserInfo() {
+    final Request req = get("http://hello:wor%20ld@foo.com").build();
+    assertEquals(req.getMethod(), "GET");
+    assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
+  }
+
+  @Test
+  public void testContentTypeCharsetToBodyEncoding() {
+    final Request req = get("http://localhost").setHeader("Content-Type", "application/json; charset=utf-8").build();
+    assertEquals(req.getCharset(), UTF_8);
+    final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
+    assertEquals(req2.getCharset(), UTF_8);
+  }
+
+  @Test
+  public void testDefaultMethod() {
+    RequestBuilder requestBuilder = new RequestBuilder();
+    String defaultMethodName = HttpMethod.GET.name();
+    assertEquals(requestBuilder.method, defaultMethodName, "Default HTTP method should be " + defaultMethodName);
+  }
+
+  @Test
+  public void testSetHeaders() {
+    RequestBuilder requestBuilder = new RequestBuilder();
+    assertTrue(requestBuilder.headers.isEmpty(), "Headers should be empty by default.");
+
+    Map<CharSequence, Collection<?>> headers = new HashMap<>();
+    headers.put("Content-Type", Collections.singleton("application/json"));
+    requestBuilder.setHeaders(headers);
+    assertTrue(requestBuilder.headers.contains("Content-Type"), "headers set by setHeaders have not been set");
+    assertEquals(requestBuilder.headers.get("Content-Type"), "application/json", "header value incorrect");
+  }
+
+  @Test
+  public void testAddOrReplaceCookies() {
+    RequestBuilder requestBuilder = new RequestBuilder();
+    Cookie cookie = new DefaultCookie("name", "value");
+    cookie.setDomain("google.com");
+    cookie.setPath("/");
+    cookie.setMaxAge(1000);
+    cookie.setSecure(true);
+    cookie.setHttpOnly(true);
+    requestBuilder.addOrReplaceCookie(cookie);
+    assertEquals(requestBuilder.cookies.size(), 1, "cookies size should be 1 after adding one cookie");
+    assertEquals(requestBuilder.cookies.get(0), cookie, "cookie does not match");
+
+    Cookie cookie2 = new DefaultCookie("name", "value");
+    cookie2.setDomain("google2.com");
+    cookie2.setPath("/path");
+    cookie2.setMaxAge(1001);
+    cookie2.setSecure(false);
+    cookie2.setHttpOnly(false);
+
+    requestBuilder.addOrReplaceCookie(cookie2);
+    assertEquals(requestBuilder.cookies.size(), 1, "cookies size should remain 1 as we just replaced a cookie with same name");
+    assertEquals(requestBuilder.cookies.get(0), cookie2, "cookie does not match");
+
+    Cookie cookie3 = new DefaultCookie("name2", "value");
+    cookie3.setDomain("google.com");
+    cookie3.setPath("/");
+    cookie3.setMaxAge(1000);
+    cookie3.setSecure(true);
+    cookie3.setHttpOnly(true);
+    requestBuilder.addOrReplaceCookie(cookie3);
+    assertEquals(requestBuilder.cookies.size(), 2, "cookie size must be 2 after adding 1 more cookie i.e. cookie3");
+  }
+
+  @Test
+  public void testSettingQueryParamsBeforeUrlShouldNotProduceNPE() {
+    RequestBuilder requestBuilder = new RequestBuilder();
+    requestBuilder.setQueryParams(singletonList(new Param("key", "value")));
+    requestBuilder.setUrl("http://localhost");
+    Request request = requestBuilder.build();
+    assertEquals(request.getUrl(), "http://localhost?key=value");
+  }
+
+  @Test
+  public void testSettingHeadersUsingMapWithStringKeys() {
+    Map<String, List<String>> headers = new HashMap<>();
+    headers.put("X-Forwarded-For", singletonList("10.0.0.1"));
+
+    RequestBuilder requestBuilder = new RequestBuilder();
+    requestBuilder.setHeaders(headers);
+    requestBuilder.setUrl("http://localhost");
+    Request request =  requestBuilder.build();
+    assertEquals(request.getHeaders().get("X-Forwarded-For"), "10.0.0.1");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
index 826ee9b42..e7fd6dbaf 100644
--- a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
+++ b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -12,69 +12,70 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.io.OutputStream;
+import org.asynchttpclient.exception.RemotelyClosedException;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.OutputStream;
 
-import org.asynchttpclient.exception.RemotelyClosedException;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
 
 public class RetryRequestTest extends AbstractBasicTest {
-    public static class SlowAndBigHandler extends AbstractHandler {
-
-        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+  protected String getTargetUrl() {
+    return String.format("http://localhost:%d/", port1);
+  }
 
-            int load = 100;
-            httpResponse.setStatus(200);
-            httpResponse.setContentLength(load);
-            httpResponse.setContentType("application/octet-stream");
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new SlowAndBigHandler();
+  }
 
-            httpResponse.flushBuffer();
+  @Test
+  public void testMaxRetry() {
+    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
+      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
+      fail();
+    } catch (Exception t) {
+      assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
+    }
+  }
 
-            OutputStream os = httpResponse.getOutputStream();
-            for (int i = 0; i < load; i++) {
-                os.write(i % 255);
+  public static class SlowAndBigHandler extends AbstractHandler {
 
-                try {
-                    Thread.sleep(300);
-                } catch (InterruptedException ex) {
-                    // nuku
-                }
+    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-                if (i > load / 10) {
-                    httpResponse.sendError(500);
-                }
-            }
+      int load = 100;
+      httpResponse.setStatus(200);
+      httpResponse.setContentLength(load);
+      httpResponse.setContentType("application/octet-stream");
 
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
-    }
+      httpResponse.flushBuffer();
 
-    protected String getTargetUrl() {
-        return String.format("http://localhost:%d/", port1);
-    }
+      OutputStream os = httpResponse.getOutputStream();
+      for (int i = 0; i < load; i++) {
+        os.write(i % 255);
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SlowAndBigHandler();
-    }
+        try {
+          Thread.sleep(300);
+        } catch (InterruptedException ex) {
+          // nuku
+        }
 
-    @Test(groups = "standalone")
-    public void testMaxRetry() throws Exception {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
-            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
-            fail();
-        } catch (Exception t) {
-            assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
+        if (i > load / 10) {
+          httpResponse.sendError(500);
         }
+      }
+
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
index f3b68cd30..453c882af 100644
--- a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
+++ b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -13,15 +13,16 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
 import java.util.Arrays;
 import java.util.Random;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 
 /**
  * Tests configured client name is used for thread names.
@@ -30,37 +31,37 @@
  */
 public class ThreadNameTest extends AbstractBasicTest {
 
-    private static Thread[] getThreads() {
-        int count = Thread.activeCount() + 1;
-        for (;;) {
-            Thread[] threads = new Thread[count];
-            int filled = Thread.enumerate(threads);
-            if (filled < threads.length) {
-                return Arrays.copyOf(threads, filled);
-            }
+  private static Thread[] getThreads() {
+    int count = Thread.activeCount() + 1;
+    for (; ; ) {
+      Thread[] threads = new Thread[count];
+      int filled = Thread.enumerate(threads);
+      if (filled < threads.length) {
+        return Arrays.copyOf(threads, filled);
+      }
 
-            count *= 2;
-        }
+      count *= 2;
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testThreadName() throws Exception {
-        String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
-        try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
-            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
-            f.get(3, TimeUnit.SECONDS);
-
-            // We cannot assert that all threads are created with specified name,
-            // so we checking that at least one thread is.
-            boolean found = false;
-            for (Thread thread : getThreads()) {
-                if (thread.getName().startsWith(threadPoolName)) {
-                    found = true;
-                    break;
-                }
-            }
+  @Test
+  public void testThreadName() throws Exception {
+    String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
+    try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
+      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
+      f.get(3, TimeUnit.SECONDS);
 
-            Assert.assertTrue(found, "must found threads starting with random string " + threadPoolName);
+      // We cannot assert that all threads are created with specified name,
+      // so we checking that at least one thread is.
+      boolean found = false;
+      for (Thread thread : getThreads()) {
+        if (thread.getName().startsWith(threadPoolName)) {
+          found = true;
+          break;
         }
+      }
+
+      Assert.assertTrue(found, "must found threads starting with random string " + threadPoolName);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
index 16f8990bc..4130fce8f 100644
--- a/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
@@ -15,9 +15,12 @@
  */
 package org.asynchttpclient.channel;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.EventCollectingHandler.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.*;
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.test.EventCollectingHandler;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -30,266 +33,263 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.exception.TooManyConnectionsException;
-import org.asynchttpclient.test.EventCollectingHandler;
-import org.eclipse.jetty.server.ServerConnector;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.EventCollectingHandler.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.*;
 
 public class ConnectionPoolTest extends AbstractBasicTest {
 
-    @Test(groups = "standalone")
-    public void testMaxTotalConnections() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
-            String url = getTargetUrl();
-            int i;
-            Exception exception = null;
-            for (i = 0; i < 3; i++) {
-                try {
-                    logger.info("{} requesting url [{}]...", i, url);
-                    Response response = client.prepareGet(url).execute().get();
-                    logger.info("{} response [{}].", i, response);
-                } catch (Exception ex) {
-                    exception = ex;
-                }
-            }
-            assertNull(exception);
+  @Test
+  public void testMaxTotalConnections() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
+      String url = getTargetUrl();
+      int i;
+      Exception exception = null;
+      for (i = 0; i < 3; i++) {
+        try {
+          logger.info("{} requesting url [{}]...", i, url);
+          Response response = client.prepareGet(url).execute().get();
+          logger.info("{} response [{}].", i, response);
+        } catch (Exception ex) {
+          exception = ex;
         }
+      }
+      assertNull(exception);
     }
-
-    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
-    public void testMaxTotalConnectionsException() throws Throwable {
-        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
-            String url = getTargetUrl();
-
-            List<ListenableFuture<Response>> futures = new ArrayList<>();
-            for (int i = 0; i < 5; i++) {
-                logger.info("{} requesting url [{}]...", i, url);
-                futures.add(client.prepareGet(url).execute());
-            }
-
-            Exception exception = null;
-            for (ListenableFuture<Response> future : futures) {
-                try {
-                    future.get();
-                } catch (Exception ex) {
-                    exception = ex;
-                    break;
-                }
-            }
-
-            assertNotNull(exception);
-            throw exception.getCause();
+  }
+
+  @Test(expectedExceptions = TooManyConnectionsException.class)
+  public void testMaxTotalConnectionsException() throws Throwable {
+    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
+      String url = getTargetUrl();
+
+      List<ListenableFuture<Response>> futures = new ArrayList<>();
+      for (int i = 0; i < 5; i++) {
+        logger.info("{} requesting url [{}]...", i, url);
+        futures.add(client.prepareGet(url).execute());
+      }
+
+      Exception exception = null;
+      for (ListenableFuture<Response> future : futures) {
+        try {
+          future.get();
+        } catch (Exception ex) {
+          exception = ex;
+          break;
         }
+      }
+
+      assertNotNull(exception);
+      throw exception.getCause();
     }
+  }
 
-    @Test(groups = "standalone", invocationCount = 100)
-    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(2);
-
-            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<>();
-
-            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    logger.debug("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        super.onThrowable(t);
-                    } finally {
-                        l.countDown();
-                    }
-                }
-            };
-
-            client.prepareGet(getTargetUrl()).execute(handler).get();
-            server.stop();
-
-            // make sure connector will restart with the port as it's originally dynamically allocated
-            ServerConnector connector = (ServerConnector) server.getConnectors()[0];
-            connector.setPort(port1);
-
-            server.start();
-            client.prepareGet(getTargetUrl()).execute(handler);
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
+  @Test(invocationCount = 100)
+  public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
 
-            assertEquals(remoteAddresses.size(), 2);
-        }
-    }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      // Use a l in case the assert fail
+      final CountDownLatch l = new CountDownLatch(2);
 
-    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
-    public void multipleMaxConnectionOpenTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
-            String body = "hello there";
+      final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<>();
 
-            // once
-            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+      AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-            assertEquals(response.getResponseBody(), body);
+        @Override
+        public Response onCompleted(Response response) {
+          logger.debug("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
+          try {
+            assertEquals(response.getStatusCode(), 200);
+            remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
+          } finally {
+            l.countDown();
+          }
+          return response;
+        }
 
-            // twice
-            Exception exception = null;
-            try {
-                c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-                fail("Should throw exception. Too many connections issued.");
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNotNull(exception);
-            throw exception.getCause();
+        @Override
+        public void onThrowable(Throwable t) {
+          try {
+            super.onThrowable(t);
+          } finally {
+            l.countDown();
+          }
         }
-    }
+      };
 
-    @Test(groups = "standalone")
-    public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
-            String body = "hello there";
+      client.prepareGet(getTargetUrl()).execute(handler).get();
+      server.stop();
 
-            // once
-            Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+      // Jetty 9.4.8 doesn't properly stop and restart (recreates ReservedThreadExecutors on start but still point to old offers threads to old ones)
+      // instead of restarting, we create a fresh new one and have it bind on the same port
+      server = new Server();
+      ServerConnector newConnector = addHttpConnector(server);
+      // make sure connector will restart with the port as it's originally dynamically allocated
+      newConnector.setPort(port1);
+      server.setHandler(configureHandler());
+      server.start();
 
-            assertEquals(response.getResponseBody(), "foo_" + body);
+      client.prepareGet(getTargetUrl()).execute(handler);
 
-            // twice
-            Exception exception = null;
-            try {
-                response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNull(exception);
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
+      if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+        fail("Timed out");
+      }
 
-    /**
-     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
-     * 
-     * @throws Exception if something wrong happens.
-     */
-    @Test(groups = "standalone")
-    public void win7DisconnectTest() throws Exception {
-        final AtomicInteger count = new AtomicInteger(0);
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-
-                    count.incrementAndGet();
-                    StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-                    IOException t = new IOException();
-                    t.setStackTrace(new StackTraceElement[] { e });
-                    throw t;
-                }
-            };
-
-            try {
-                client.prepareGet(getTargetUrl()).execute(handler).get();
-                fail("Must have received an exception");
-            } catch (ExecutionException ex) {
-                assertNotNull(ex);
-                assertNotNull(ex.getCause());
-                assertEquals(ex.getCause().getClass(), IOException.class);
-                assertEquals(count.get(), 1);
-            }
+      assertEquals(remoteAddresses.size(), 2);
+    }
+  }
+
+  @Test(expectedExceptions = TooManyConnectionsException.class)
+  public void multipleMaxConnectionOpenTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
+      String body = "hello there";
+
+      // once
+      Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+      assertEquals(response.getResponseBody(), body);
+
+      // twice
+      Exception exception = null;
+      try {
+        c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+        fail("Should throw exception. Too many connections issued.");
+      } catch (Exception ex) {
+        ex.printStackTrace();
+        exception = ex;
+      }
+      assertNotNull(exception);
+      throw exception.getCause();
+    }
+  }
+
+  @Test
+  public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
+      String body = "hello there";
+
+      // once
+      Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+      assertEquals(response.getResponseBody(), "foo_" + body);
+
+      // twice
+      Exception exception = null;
+      try {
+        response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+      } catch (Exception ex) {
+        ex.printStackTrace();
+        exception = ex;
+      }
+      assertNull(exception);
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  /**
+   * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
+   *
+   * @throws Exception if something wrong happens.
+   */
+  @Test
+  public void win7DisconnectTest() throws Exception {
+    final AtomicInteger count = new AtomicInteger(0);
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+
+          count.incrementAndGet();
+          StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
+          IOException t = new IOException();
+          t.setStackTrace(new StackTraceElement[]{e});
+          throw t;
         }
+      };
+
+      try {
+        client.prepareGet(getTargetUrl()).execute(handler).get();
+        fail("Must have received an exception");
+      } catch (ExecutionException ex) {
+        assertNotNull(ex);
+        assertNotNull(ex.getCause());
+        assertEquals(ex.getCause().getClass(), IOException.class);
+        assertEquals(count.get(), 1);
+      }
     }
-
-    @Test(groups = "standalone")
-    public void asyncHandlerOnThrowableTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final AtomicInteger count = new AtomicInteger();
-            final String THIS_IS_NOT_FOR_YOU = "This is not for you";
-            final CountDownLatch latch = new CountDownLatch(16);
-            for (int i = 0; i < 16; i++) {
-                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        throw new Exception(THIS_IS_NOT_FOR_YOU);
-                    }
-                });
-
-                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
-                            count.incrementAndGet();
-                        }
-                    }
-
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        latch.countDown();
-                        return response;
-                    }
-                });
+  }
+
+  @Test
+  public void asyncHandlerOnThrowableTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final AtomicInteger count = new AtomicInteger();
+      final String THIS_IS_NOT_FOR_YOU = "This is not for you";
+      final CountDownLatch latch = new CountDownLatch(16);
+      for (int i = 0; i < 16; i++) {
+        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+          @Override
+          public Response onCompleted(Response response) throws Exception {
+            throw new Exception(THIS_IS_NOT_FOR_YOU);
+          }
+        });
+
+        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+          @Override
+          public void onThrowable(Throwable t) {
+            if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
+              count.incrementAndGet();
             }
-            latch.await(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals(count.get(), 0);
-        }
+          }
+
+          @Override
+          public Response onCompleted(Response response) {
+            latch.countDown();
+            return response;
+          }
+        });
+      }
+      latch.await(TIMEOUT, TimeUnit.SECONDS);
+      assertEquals(count.get(), 0);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
+  @Test
+  public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
 
-        RequestBuilder request = get(getTargetUrl()).setHeader("Connection", "close");
+    RequestBuilder request = get(getTargetUrl()).setHeader("Connection", "close");
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(6).setMaxConnectionsPerHost(3))) {
-            client.executeRequest(request).get();
-            Thread.sleep(1000);
-            client.executeRequest(request).get();
-            Thread.sleep(1000);
-            client.executeRequest(request).get();
-            Thread.sleep(1000);
-            client.executeRequest(request).get();
-        }
+    try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(6).setMaxConnectionsPerHost(3))) {
+      client.executeRequest(request).get();
+      Thread.sleep(1000);
+      client.executeRequest(request).get();
+      Thread.sleep(1000);
+      client.executeRequest(request).get();
+      Thread.sleep(1000);
+      client.executeRequest(request).get();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testPooledEventsFired() throws Exception {
-        RequestBuilder request = get("http://localhost:" + port1 + "/Test");
+  @Test
+  public void testPooledEventsFired() throws Exception {
+    RequestBuilder request = get("http://localhost:" + port1 + "/Test");
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            EventCollectingHandler firstHandler = new EventCollectingHandler();
-            client.executeRequest(request, firstHandler).get(3, TimeUnit.SECONDS);
-            firstHandler.waitForCompletion(3, TimeUnit.SECONDS);
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      EventCollectingHandler firstHandler = new EventCollectingHandler();
+      client.executeRequest(request, firstHandler).get(3, TimeUnit.SECONDS);
+      firstHandler.waitForCompletion(3, TimeUnit.SECONDS);
 
-            EventCollectingHandler secondHandler = new EventCollectingHandler();
-            client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
-            secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
+      EventCollectingHandler secondHandler = new EventCollectingHandler();
+      client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
+      secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
 
-            Object[] expectedEvents = new Object[] { CONNECTION_POOL_EVENT, CONNECTION_POOLED_EVENT, REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT,
-                    HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT };
+      Object[] expectedEvents = new Object[]{CONNECTION_POOL_EVENT, CONNECTION_POOLED_EVENT, REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT,
+              HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT};
 
-            assertEquals(secondHandler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
-        }
+      assertEquals(secondHandler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index 34c8b152b..114115af3 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -16,25 +16,7 @@
  */
 package org.asynchttpclient.channel;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
@@ -44,133 +26,146 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class MaxConnectionsInThreads extends AbstractBasicTest {
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
-    @Test(groups = "standalone")
-    public void testMaxConnectionsWithinThreads() throws Exception {
-
-        String[] urls = new String[] { getTargetUrl(), getTargetUrl() };
-
-        AsyncHttpClientConfig config = config()//
-                .setConnectTimeout(1000)//
-                .setRequestTimeout(5000)//
-                .setKeepAlive(true)//
-                .setMaxConnections(1)//
-                .setMaxConnectionsPerHost(1)//
-                .build();
-
-        final CountDownLatch inThreadsLatch = new CountDownLatch(2);
-        final AtomicInteger failedCount = new AtomicInteger();
-
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            for (final String url : urls) {
-                Thread t = new Thread() {
-                    public void run() {
-                        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-                            @Override
-                            public Response onCompleted(Response response) throws Exception {
-                                Response r = super.onCompleted(response);
-                                inThreadsLatch.countDown();
-                                return r;
-                            }
-
-                            @Override
-                            public void onThrowable(Throwable t) {
-                                super.onThrowable(t);
-                                failedCount.incrementAndGet();
-                                inThreadsLatch.countDown();
-                            }
-                        });
-                    }
-                };
-                t.start();
-            }
-
-            inThreadsLatch.await();
-
-            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from concurrent threads");
-
-            final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
-            failedCount.set(0);
-            for (final String url : urls) {
-                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        Response r = super.onCompleted(response);
-                        notInThreadsLatch.countDown();
-                        return r;
-                    }
-
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        super.onThrowable(t);
-                        failedCount.incrementAndGet();
-                        notInThreadsLatch.countDown();
-                    }
-                });
-            }
-
-            notInThreadsLatch.await();
-
-            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
-        }
-    }
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
 
-    @Override
-    @BeforeClass
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-        context.setContextPath("/");
-        server.setHandler(context);
-        context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
-
-        server.start();
-        port1 = connector.getLocalPort();
-    }
+public class MaxConnectionsInThreads extends AbstractBasicTest {
 
-    public String getTargetUrl() {
-        return "http://localhost:" + port1 + "/timeout/";
+  @Test
+  public void testMaxConnectionsWithinThreads() throws Exception {
+
+    String[] urls = new String[]{getTargetUrl(), getTargetUrl()};
+
+    AsyncHttpClientConfig config = config()
+            .setConnectTimeout(1000)
+            .setRequestTimeout(5000)
+            .setKeepAlive(true)
+            .setMaxConnections(1)
+            .setMaxConnectionsPerHost(1)
+            .build();
+
+    final CountDownLatch inThreadsLatch = new CountDownLatch(2);
+    final AtomicInteger failedCount = new AtomicInteger();
+
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      for (final String url : urls) {
+        Thread t = new Thread() {
+          public void run() {
+            client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+              @Override
+              public Response onCompleted(Response response) throws Exception {
+                Response r = super.onCompleted(response);
+                inThreadsLatch.countDown();
+                return r;
+              }
+
+              @Override
+              public void onThrowable(Throwable t) {
+                super.onThrowable(t);
+                failedCount.incrementAndGet();
+                inThreadsLatch.countDown();
+              }
+            });
+          }
+        };
+        t.start();
+      }
+
+      inThreadsLatch.await();
+
+      assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from concurrent threads");
+
+      final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
+      failedCount.set(0);
+      for (final String url : urls) {
+        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+          @Override
+          public Response onCompleted(Response response) throws Exception {
+            Response r = super.onCompleted(response);
+            notInThreadsLatch.countDown();
+            return r;
+          }
+
+          @Override
+          public void onThrowable(Throwable t) {
+            super.onThrowable(t);
+            failedCount.incrementAndGet();
+            notInThreadsLatch.countDown();
+          }
+        });
+      }
+
+      notInThreadsLatch.await();
+
+      assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
     }
-
-    @SuppressWarnings("serial")
-    public static class MockTimeoutHttpServlet extends HttpServlet {
-        private static final Logger LOGGER = LoggerFactory.getLogger(MockTimeoutHttpServlet.class);
-        private static final String contentType = "text/plain";
-        public static long DEFAULT_TIMEOUT = 2000;
-
-        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-            res.setStatus(200);
-            res.addHeader("Content-Type", contentType);
-            long sleepTime = DEFAULT_TIMEOUT;
-            try {
-                sleepTime = Integer.parseInt(req.getParameter("timeout"));
-
-            } catch (NumberFormatException e) {
-                sleepTime = DEFAULT_TIMEOUT;
-            }
-
-            try {
-                LOGGER.debug("=======================================");
-                LOGGER.debug("Servlet is sleeping for: " + sleepTime);
-                LOGGER.debug("=======================================");
-                Thread.sleep(sleepTime);
-                LOGGER.debug("=======================================");
-                LOGGER.debug("Servlet is awake for");
-                LOGGER.debug("=======================================");
-            } catch (Exception e) {
-
-            }
-
-            res.setHeader("XXX", "TripleX");
-
-            byte[] retVal = "1".getBytes();
-            OutputStream os = res.getOutputStream();
-
-            res.setContentLength(retVal.length);
-            os.write(retVal);
-            os.close();
-        }
+  }
+
+  @Override
+  @BeforeClass
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+    context.setContextPath("/");
+    server.setHandler(context);
+    context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
+
+    server.start();
+    port1 = connector.getLocalPort();
+  }
+
+  public String getTargetUrl() {
+    return "http://localhost:" + port1 + "/timeout/";
+  }
+
+  @SuppressWarnings("serial")
+  public static class MockTimeoutHttpServlet extends HttpServlet {
+    private static final Logger LOGGER = LoggerFactory.getLogger(MockTimeoutHttpServlet.class);
+    private static final String contentType = "text/plain";
+    static long DEFAULT_TIMEOUT = 2000;
+
+    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
+      res.setStatus(200);
+      res.addHeader("Content-Type", contentType);
+      long sleepTime = DEFAULT_TIMEOUT;
+      try {
+        sleepTime = Integer.parseInt(req.getParameter("timeout"));
+
+      } catch (NumberFormatException e) {
+        sleepTime = DEFAULT_TIMEOUT;
+      }
+
+      try {
+        LOGGER.debug("=======================================");
+        LOGGER.debug("Servlet is sleeping for: " + sleepTime);
+        LOGGER.debug("=======================================");
+        Thread.sleep(sleepTime);
+        LOGGER.debug("=======================================");
+        LOGGER.debug("Servlet is awake for");
+        LOGGER.debug("=======================================");
+      } catch (Exception e) {
+        //
+      }
+
+      res.setHeader("XXX", "TripleX");
+
+      byte[] retVal = "1".getBytes();
+      OutputStream os = res.getOutputStream();
+
+      res.setContentLength(retVal.length);
+      os.write(retVal);
+      os.close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 387d9caac..5992bf3ed 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -15,8 +15,9 @@
  */
 package org.asynchttpclient.channel;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertNull;
+import org.asynchttpclient.*;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -24,93 +25,88 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Response;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertNull;
 
 public class MaxTotalConnectionTest extends AbstractBasicTest {
 
-    @Test(groups = "online")
-    public void testMaxTotalConnectionsExceedingException() throws IOException {
-        String[] urls = new String[] { "http://google.com", "http://github.com/" };
-
-        AsyncHttpClientConfig config = config()//
-                .setConnectTimeout(1000)//
-                .setRequestTimeout(5000)//
-                .setKeepAlive(false)//
-                .setMaxConnections(1)//
-                .setMaxConnectionsPerHost(1)//
-                .build();
+  @Test(groups = "online")
+  public void testMaxTotalConnectionsExceedingException() throws IOException {
+    String[] urls = new String[]{"http://google.com", "http://github.com/"};
 
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            List<ListenableFuture<Response>> futures = new ArrayList<>();
-            for (String url : urls) {
-                futures.add(client.prepareGet(url).execute());
-            }
+    AsyncHttpClientConfig config = config()
+            .setConnectTimeout(1000)
+            .setRequestTimeout(5000)
+            .setKeepAlive(false)
+            .setMaxConnections(1)
+            .setMaxConnectionsPerHost(1)
+            .build();
 
-            boolean caughtError = false;
-            int i;
-            for (i = 0; i < urls.length; i++) {
-                try {
-                    futures.get(i).get();
-                } catch (Exception e) {
-                    // assert that 2nd request fails, because
-                    // maxTotalConnections=1
-                    caughtError = true;
-                    break;
-                }
-            }
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      List<ListenableFuture<Response>> futures = new ArrayList<>();
+      for (String url : urls) {
+        futures.add(client.prepareGet(url).execute());
+      }
 
-            Assert.assertEquals(1, i);
-            Assert.assertTrue(caughtError);
+      boolean caughtError = false;
+      int i;
+      for (i = 0; i < urls.length; i++) {
+        try {
+          futures.get(i).get();
+        } catch (Exception e) {
+          // assert that 2nd request fails, because
+          // maxTotalConnections=1
+          caughtError = true;
+          break;
         }
+      }
+
+      Assert.assertEquals(1, i);
+      Assert.assertTrue(caughtError);
     }
+  }
 
-    @Test(groups = "online")
-    public void testMaxTotalConnections() throws Exception {
-        String[] urls = new String[] { "http://google.com", "http://gatling.io" };
+  @Test(groups = "online")
+  public void testMaxTotalConnections() throws Exception {
+    String[] urls = new String[]{"http://google.com", "http://gatling.io"};
 
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<Throwable> ex = new AtomicReference<>();
-        final AtomicReference<String> failedUrl = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(2);
+    final AtomicReference<Throwable> ex = new AtomicReference<>();
+    final AtomicReference<String> failedUrl = new AtomicReference<>();
 
-        AsyncHttpClientConfig config = config()//
-                .setConnectTimeout(1000)//
-                .setRequestTimeout(5000)//
-                .setKeepAlive(false)//
-                .setMaxConnections(2)//
-                .setMaxConnectionsPerHost(1)//
-                .build();
+    AsyncHttpClientConfig config = config()
+            .setConnectTimeout(1000)
+            .setRequestTimeout(5000)
+            .setKeepAlive(false)
+            .setMaxConnections(2)
+            .setMaxConnectionsPerHost(1)
+            .build();
 
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            for (String url : urls) {
-                final String thisUrl = url;
-                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-                    @Override
-                    public Response onCompleted(Response response) throws Exception {
-                        Response r = super.onCompleted(response);
-                        latch.countDown();
-                        return r;
-                    }
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      for (String url : urls) {
+        final String thisUrl = url;
+        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+          @Override
+          public Response onCompleted(Response response) throws Exception {
+            Response r = super.onCompleted(response);
+            latch.countDown();
+            return r;
+          }
 
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        super.onThrowable(t);
-                        ex.set(t);
-                        failedUrl.set(thisUrl);
-                        latch.countDown();
-                    }
-                });
-            }
+          @Override
+          public void onThrowable(Throwable t) {
+            super.onThrowable(t);
+            ex.set(t);
+            failedUrl.set(thisUrl);
+            latch.countDown();
+          }
+        });
+      }
 
-            latch.await();
-            assertNull(ex.get());
-            assertNull(failedUrl.get());
-        }
+      latch.await();
+      assertNull(ex.get());
+      assertNull(failedUrl.get());
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
index becf9d249..10b36507a 100644
--- a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
+++ b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -12,9 +12,13 @@
  */
 package org.asynchttpclient.filter;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.*;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Enumeration;
@@ -23,161 +27,153 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.*;
 
 public class FilterTest extends AbstractBasicTest {
 
-    private static class BasicHandler extends AbstractHandler {
-
-        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-                httpResponse.addHeader(param, httpRequest.getHeader(param));
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new BasicHandler();
+  }
+
+  public String getTargetUrl() {
+    return String.format("http://localhost:%d/foo/test", port1);
+  }
+
+  @Test
+  public void basicTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(100)))) {
+      Response response = c.preparePost(getTargetUrl()).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new BasicHandler();
+  }
+
+  @Test
+  public void loadThrottleTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(10)))) {
+      List<Future<Response>> futures = new ArrayList<>();
+      for (int i = 0; i < 200; i++) {
+        futures.add(c.preparePost(getTargetUrl()).execute());
+      }
+
+      for (Future<Response> f : futures) {
+        Response r = f.get();
+        assertNotNull(f.get());
+        assertEquals(r.getStatusCode(), 200);
+      }
     }
-
-    public String getTargetUrl() {
-        return String.format("http://localhost:%d/foo/test", port1);
+  }
+
+  @Test
+  public void maxConnectionsText() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(0, 1000)))) {
+      c.preparePost(getTargetUrl()).execute().get();
+      fail("Should have timed out");
+    } catch (ExecutionException ex) {
+      assertTrue(ex.getCause() instanceof FilterException);
     }
-
-    @Test(groups = "standalone")
-    public void basicTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(100)))) {
-            Response response = c.preparePost(getTargetUrl()).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-        }
+  }
+
+  @Test
+  public void basicResponseFilterTest() throws Exception {
+
+    ResponseFilter responseFilter = new ResponseFilter() {
+      @Override
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+      Response response = c.preparePost(getTargetUrl()).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void loadThrottleTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(10)))) {
-            List<Future<Response>> futures = new ArrayList<>();
-            for (int i = 0; i < 200; i++) {
-                futures.add(c.preparePost(getTargetUrl()).execute());
-            }
-
-            for (Future<Response> f : futures) {
-                Response r = f.get();
-                assertNotNull(f.get());
-                assertEquals(r.getStatusCode(), 200);
-            }
-        }
-    }
+  @Test
+  public void replayResponseFilterTest() throws Exception {
 
-    @Test(groups = "standalone")
-    public void maxConnectionsText() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(0, 1000)))) {
-            c.preparePost(getTargetUrl()).execute().get();
-            fail("Should have timed out");
-        } catch (ExecutionException ex) {
-            assertTrue(ex.getCause() instanceof FilterException);
+    final AtomicBoolean replay = new AtomicBoolean(true);
+    ResponseFilter responseFilter = new ResponseFilter() {
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        if (replay.getAndSet(false)) {
+          Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
+          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
         }
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+      Response response = c.preparePost(getTargetUrl()).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("X-Replay"), "true");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void basicResponseFilterTest() throws Exception {
+  @Test
+  public void replayStatusCodeResponseFilterTest() throws Exception {
 
-        ResponseFilter responseFilter = new ResponseFilter() {
-            @Override
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-            Response response = c.preparePost(getTargetUrl()).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
+    final AtomicBoolean replay = new AtomicBoolean(true);
+    ResponseFilter responseFilter = new ResponseFilter() {
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        if (ctx.getResponseStatus() != null && ctx.getResponseStatus().getStatusCode() == 200 && replay.getAndSet(false)) {
+          Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
+          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
         }
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+      Response response = c.preparePost(getTargetUrl()).execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("X-Replay"), "true");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void replayResponseFilterTest() throws Exception {
-
-        final AtomicBoolean replay = new AtomicBoolean(true);
-        ResponseFilter responseFilter = new ResponseFilter() {
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                if (replay.getAndSet(false)) {
-                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
-                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
-                }
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-            Response response = c.preparePost(getTargetUrl()).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Replay"), "true");
-        }
-    }
+  @Test
+  public void replayHeaderResponseFilterTest() throws Exception {
 
-    @Test(groups = "standalone")
-    public void replayStatusCodeResponseFilterTest() throws Exception {
-
-        final AtomicBoolean replay = new AtomicBoolean(true);
-        ResponseFilter responseFilter = new ResponseFilter() {
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                if (ctx.getResponseStatus() != null && ctx.getResponseStatus().getStatusCode() == 200 && replay.getAndSet(false)) {
-                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
-                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
-                }
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-            Response response = c.preparePost(getTargetUrl()).execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Replay"), "true");
+    final AtomicBoolean replay = new AtomicBoolean(true);
+    ResponseFilter responseFilter = new ResponseFilter() {
+      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
+        if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().get("Ping").equals("Pong") && replay.getAndSet(false)) {
+          Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
+          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
         }
+        return ctx;
+      }
+    };
+
+    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+      Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getHeader("Ping"), "Pong");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void replayHeaderResponseFilterTest() throws Exception {
-
-        final AtomicBoolean replay = new AtomicBoolean(true);
-        ResponseFilter responseFilter = new ResponseFilter() {
-            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().get("Ping").equals("Pong") && replay.getAndSet(false)) {
-                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
-                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
-                }
-                return ctx;
-            }
-        };
-
-        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("Ping"), "Pong");
-        }
+  private static class BasicHandler extends AbstractHandler {
+
+    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      String param;
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
+        httpResponse.addHeader(param, httpRequest.getHeader(param));
+      }
+
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index 9e91261b1..db8781883 100644
--- a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -15,9 +15,13 @@
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
 import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
 import static org.apache.commons.io.IOUtils.copy;
-import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 import static org.asynchttpclient.test.TestUtils.findFreePort;
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -26,8 +30,6 @@
 import java.nio.charset.StandardCharsets;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
-
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -47,222 +49,257 @@
 
 public class BodyDeferringAsyncHandlerTest extends AbstractBasicTest {
 
-    protected static final int CONTENT_LENGTH_VALUE = 100000;
-
-    public static class SlowAndBigHandler extends AbstractHandler {
-
-        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            httpResponse.setStatus(200);
-            httpResponse.setContentLength(CONTENT_LENGTH_VALUE);
-            httpResponse.setContentType(APPLICATION_OCTET_STREAM.toString());
-
-            httpResponse.flushBuffer();
-
-            final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
-            final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
-
-            OutputStream os = httpResponse.getOutputStream();
-            for (int i = 0; i < CONTENT_LENGTH_VALUE; i++) {
-                os.write(i % 255);
-
-                if (wantSlow) {
-                    try {
-                        Thread.sleep(300);
-                    } catch (InterruptedException ex) {
-                        // nuku
-                    }
-                }
-
-                if (wantFailure) {
-                    if (i > CONTENT_LENGTH_VALUE / 2) {
-                        // kaboom
-                        // yes, response is committed, but Jetty does aborts and
-                        // drops connection
-                        httpResponse.sendError(500);
-                        break;
-                    }
-                }
-            }
-
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
+  static final int CONTENT_LENGTH_VALUE = 100000;
+
+  public AbstractHandler configureHandler() throws Exception {
+    return new SlowAndBigHandler();
+  }
+
+  private AsyncHttpClientConfig getAsyncHttpClientConfig() {
+    // for this test brevity's sake, we are limiting to 1 retries
+    return config().setMaxRequestRetry(0).setRequestTimeout(10000).build();
+  }
+
+  @Test
+  public void deferredSimple() throws IOException, ExecutionException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl());
+
+      CountingOutputStream cos = new CountingOutputStream();
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+      Future<Response> f = r.execute(bdah);
+      Response resp = bdah.getResponse();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+      // we got headers only, it's probably not all yet here (we have BIG file
+      // downloading)
+      assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
+
+      // now be polite and wait for body arrival too (otherwise we would be
+      // dropping the "line" on server)
+      f.get();
+      // it all should be here now
+      assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+    }
+  }
+
+  @Test(expectedExceptions = RemotelyClosedException.class, enabled = false)
+  public void deferredSimpleWithFailure() throws Throwable {
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+
+      CountingOutputStream cos = new CountingOutputStream();
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+      Future<Response> f = r.execute(bdah);
+      Response resp = bdah.getResponse();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+      // we got headers only, it's probably not all yet here (we have BIG file
+      // downloading)
+      assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
+
+      // now be polite and wait for body arrival too (otherwise we would be
+      // dropping the "line" on server)
+      try {
+        f.get();
+      } catch (ExecutionException e) {
+        // good
+        // it's incomplete, there was an error
+        assertNotEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+        throw e.getCause();
+      }
+    }
+  }
+
+  @Test
+  public void deferredInputStreamTrick() throws IOException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl());
+
+      PipedOutputStream pos = new PipedOutputStream();
+      PipedInputStream pis = new PipedInputStream(pos);
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+      Future<Response> f = r.execute(bdah);
+
+      BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+      Response resp = is.getAsapResponse();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+      // "consume" the body, but our code needs input stream
+      CountingOutputStream cos = new CountingOutputStream();
+      try {
+        copy(is, cos);
+      } finally {
+        is.close();
+        cos.close();
+      }
+
+      // now we don't need to be polite, since consuming and closing
+      // BodyDeferringInputStream does all.
+      // it all should be here now
+      assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+    }
+  }
+
+  @Test(expectedExceptions = RemotelyClosedException.class)
+  public void deferredInputStreamTrickWithFailure() throws Throwable {
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+      PipedOutputStream pos = new PipedOutputStream();
+      PipedInputStream pis = new PipedInputStream(pos);
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+      Future<Response> f = r.execute(bdah);
+
+      BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+      Response resp = is.getAsapResponse();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+      // "consume" the body, but our code needs input stream
+      CountingOutputStream cos = new CountingOutputStream();
+      try {
+        try {
+          copy(is, cos);
+        } finally {
+          is.close();
+          cos.close();
         }
+      } catch (IOException e) {
+        throw e.getCause();
+      }
     }
-
-    // a /dev/null but counting how many bytes it ditched
-    public static class CountingOutputStream extends OutputStream {
-        private int byteCount = 0;
-
-        @Override
-        public void write(int b) throws IOException {
-            // /dev/null
-            byteCount++;
+  }
+
+  @Test(expectedExceptions = UnsupportedOperationException.class)
+  public void deferredInputStreamTrickWithCloseConnectionAndRetry() throws Throwable {
+    try (AsyncHttpClient client = asyncHttpClient(config().setMaxRequestRetry(1).setRequestTimeout(10000).build())) {
+      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-CLOSE-CONNECTION", Boolean.TRUE.toString());
+      PipedOutputStream pos = new PipedOutputStream();
+      PipedInputStream pis = new PipedInputStream(pos);
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+      Future<Response> f = r.execute(bdah);
+
+      BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+      Response resp = is.getAsapResponse();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+      // "consume" the body, but our code needs input stream
+      CountingOutputStream cos = new CountingOutputStream();
+      try {
+        try {
+          copy(is, cos);
+        } finally {
+          is.close();
+          cos.close();
         }
-
-        public int getByteCount() {
-            return byteCount;
+      } catch (IOException e) {
+        throw e.getCause();
+      }
+    }
+  }
+
+  @Test(expectedExceptions = IOException.class)
+  public void testConnectionRefused() throws IOException, InterruptedException {
+    int newPortWithoutAnyoneListening = findFreePort();
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+
+      CountingOutputStream cos = new CountingOutputStream();
+      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+      r.execute(bdah);
+      bdah.getResponse();
+    }
+  }
+
+  @Test
+  public void testPipedStreams() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+      PipedOutputStream pout = new PipedOutputStream();
+      try (PipedInputStream pin = new PipedInputStream(pout)) {
+        BodyDeferringAsyncHandler handler = new BodyDeferringAsyncHandler(pout);
+        ListenableFuture<Response> respFut = client.prepareGet(getTargetUrl()).execute(handler);
+
+        Response resp = handler.getResponse();
+
+        if (resp.getStatusCode() == 200) {
+          try (BodyDeferringInputStream is = new BodyDeferringInputStream(respFut, handler, pin)) {
+            String body = IOUtils.toString(is, StandardCharsets.UTF_8);
+            assertTrue(body.contains("ABCDEF"));
+          }
+        } else {
+          throw new IOException("HTTP error " + resp.getStatusCode());
         }
+      }
     }
+  }
 
-    public AbstractHandler configureHandler() throws Exception {
-        return new SlowAndBigHandler();
-    }
+  public static class SlowAndBigHandler extends AbstractHandler {
 
-    public AsyncHttpClientConfig getAsyncHttpClientConfig() {
-        // for this test brevity's sake, we are limiting to 1 retries
-        return config().setMaxRequestRetry(0).setRequestTimeout(10000).build();
-    }
+    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-    @Test(groups = "standalone")
-    public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl());
-
-            CountingOutputStream cos = new CountingOutputStream();
-            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-            Future<Response> f = r.execute(bdah);
-            Response resp = bdah.getResponse();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-            // we got headers only, it's probably not all yet here (we have BIG file
-            // downloading)
-            assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
-
-            // now be polite and wait for body arrival too (otherwise we would be
-            // dropping the "line" on server)
-            f.get();
-            // it all should be here now
-            assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
-        }
-    }
+      httpResponse.setStatus(200);
+      httpResponse.setContentLength(CONTENT_LENGTH_VALUE);
+      httpResponse.setContentType(APPLICATION_OCTET_STREAM.toString());
 
-    @Test(groups = "standalone", expectedExceptions = RemotelyClosedException.class)
-    public void deferredSimpleWithFailure() throws Throwable {
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-
-            CountingOutputStream cos = new CountingOutputStream();
-            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-            Future<Response> f = r.execute(bdah);
-            Response resp = bdah.getResponse();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-            // we got headers only, it's probably not all yet here (we have BIG file
-            // downloading)
-            assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
-
-            // now be polite and wait for body arrival too (otherwise we would be
-            // dropping the "line" on server)
-            try {
-                f.get();
-            } catch (ExecutionException e) {
-                // good
-                // it's incomplete, there was an error
-                assertNotEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
-                throw e.getCause();
-            }
-        }
-    }
+      httpResponse.flushBuffer();
+
+      final boolean wantConnectionClose = httpRequest.getHeader("X-CLOSE-CONNECTION") != null;
+      final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
+      final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
 
-    @Test(groups = "standalone")
-    public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl());
-
-            PipedOutputStream pos = new PipedOutputStream();
-            PipedInputStream pis = new PipedInputStream(pos);
-            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-            Future<Response> f = r.execute(bdah);
-
-            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-            Response resp = is.getAsapResponse();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-            // "consume" the body, but our code needs input stream
-            CountingOutputStream cos = new CountingOutputStream();
-            try {
-                copy(is, cos);
-            } finally {
-                is.close();
-                cos.close();
-            }
-
-            // now we don't need to be polite, since consuming and closing
-            // BodyDeferringInputStream does all.
-            // it all should be here now
-            assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+      OutputStream os = httpResponse.getOutputStream();
+      for (int i = 0; i < CONTENT_LENGTH_VALUE; i++) {
+        os.write(i % 255);
+
+        if (wantSlow) {
+          try {
+            Thread.sleep(300);
+          } catch (InterruptedException ex) {
+            // nuku
+          }
         }
-    }
 
-    @Test(groups = "standalone", expectedExceptions = RemotelyClosedException.class)
-    public void deferredInputStreamTrickWithFailure() throws Throwable {
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-            PipedOutputStream pos = new PipedOutputStream();
-            PipedInputStream pis = new PipedInputStream(pos);
-            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-            Future<Response> f = r.execute(bdah);
-
-            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-            Response resp = is.getAsapResponse();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-            // "consume" the body, but our code needs input stream
-            CountingOutputStream cos = new CountingOutputStream();
-            try {
-                try {
-                    copy(is, cos);
-                } finally {
-                    is.close();
-                    cos.close();
-                }
-            } catch (IOException e) {
-                throw e.getCause();
-            }
+        if (i > CONTENT_LENGTH_VALUE / 2) {
+          if (wantFailure) {
+            // kaboom
+            // yes, response is committed, but Jetty does aborts and
+            // drops connection
+            httpResponse.sendError(500);
+            break;
+          } else if (wantConnectionClose) {
+            // kaboom^2
+            httpResponse.getOutputStream().close();
+          }
         }
+      }
+
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 
-    @Test(groups = "standalone", expectedExceptions = IOException.class)
-    public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        int newPortWithoutAnyoneListening = findFreePort();
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+  // a /dev/null but counting how many bytes it ditched
+  public static class CountingOutputStream extends OutputStream {
+    private int byteCount = 0;
 
-            CountingOutputStream cos = new CountingOutputStream();
-            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-            r.execute(bdah);
-            bdah.getResponse();
-        }
+    @Override
+    public void write(int b) {
+      // /dev/null
+      byteCount++;
     }
 
-    @Test(groups = "standalone")
-    public void testPipedStreams() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            PipedOutputStream pout = new PipedOutputStream();
-            try (PipedInputStream pin = new PipedInputStream(pout)) {
-                BodyDeferringAsyncHandler handler = new BodyDeferringAsyncHandler(pout);
-                ListenableFuture<Response> respFut = client.prepareGet(getTargetUrl()).execute(handler);
-
-                Response resp = handler.getResponse();
-
-                if (resp.getStatusCode() == 200) {
-                    try (BodyDeferringInputStream is = new BodyDeferringInputStream(respFut, handler, pin)) {
-                        String body = IOUtils.toString(is, StandardCharsets.UTF_8);
-                        assertTrue(body.contains("ABCDEF"));
-                    }
-                } else {
-                    throw new IOException("HTTP error " + resp.getStatusCode());
-                }
-            }
-        }
+    int getByteCount() {
+      return byteCount;
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
index fdb120d88..140159617 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
@@ -24,27 +24,27 @@
 public class MapResumableProcessor
         implements ResumableProcessor {
 
-    Map<String, Long> map = new HashMap<>();
+  private Map<String, Long> map = new HashMap<>();
 
-    public void put(String key, long transferredBytes) {
-        map.put(key, transferredBytes);
-    }
+  public void put(String key, long transferredBytes) {
+    map.put(key, transferredBytes);
+  }
 
-    public void remove(String key) {
-        map.remove(key);
-    }
+  public void remove(String key) {
+    map.remove(key);
+  }
 
-    /**
-     * NOOP
-     */
-    public void save(Map<String, Long> map) {
+  /**
+   * NOOP
+   */
+  public void save(Map<String, Long> map) {
 
-    }
+  }
 
-    /**
-     * NOOP
-     */
-    public Map<String, Long> load() {
-        return map;
-    }
+  /**
+   * NOOP
+   */
+  public Map<String, Long> load() {
+    return map;
+  }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index 9935a853e..883a2bb97 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -1,52 +1,51 @@
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0, 
- * and you may not use this file except in compliance with the Apache License Version 2.0. 
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing, 
- * software distributed under the Apache License Version 2.0 is distributed on an 
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.handler.resumable;
 
-import static org.testng.Assert.assertEquals;
-
-import org.asynchttpclient.handler.resumable.PropertiesBasedResumableProcessor;
 import org.testng.annotations.Test;
 
 import java.util.Map;
 
+import static org.testng.Assert.assertEquals;
+
 /**
  * @author Benjamin Hanzelmann
  */
 public class PropertiesBasedResumableProcesserTest {
-    
-    @Test(groups = "standalone")
-    public void testSaveLoad() throws Exception {
-        PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
-        p.put("http://localhost/test.url", 15L);
-        p.put("http://localhost/test2.url", 50L);
-        p.save(null);
-        p = new PropertiesBasedResumableProcessor();
-        Map<String, Long> m = p.load();
-        assertEquals(m.size(), 2);
-        assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
-        assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
-    }
-    
-    @Test
-    public void testRemove() {
-        PropertiesBasedResumableProcessor propertiesProcessor = new PropertiesBasedResumableProcessor();
-        propertiesProcessor.put("http://localhost/test.url", 15L);
-        propertiesProcessor.put("http://localhost/test2.url", 50L);
-        propertiesProcessor.remove("http://localhost/test.url");
-        propertiesProcessor.save(null);
-        propertiesProcessor = new PropertiesBasedResumableProcessor();
-        Map<String, Long> propertiesMap = propertiesProcessor.load();
-        assertEquals(propertiesMap.size(), 1);
-        assertEquals(propertiesMap.get("http://localhost/test2.url"), Long.valueOf(50L));
-    }
+
+  @Test
+  public void testSaveLoad() {
+    PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
+    p.put("http://localhost/test.url", 15L);
+    p.put("http://localhost/test2.url", 50L);
+    p.save(null);
+    p = new PropertiesBasedResumableProcessor();
+    Map<String, Long> m = p.load();
+    assertEquals(m.size(), 2);
+    assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
+    assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
+  }
+
+  @Test
+  public void testRemove() {
+    PropertiesBasedResumableProcessor propertiesProcessor = new PropertiesBasedResumableProcessor();
+    propertiesProcessor.put("http://localhost/test.url", 15L);
+    propertiesProcessor.put("http://localhost/test2.url", 50L);
+    propertiesProcessor.remove("http://localhost/test.url");
+    propertiesProcessor.save(null);
+    propertiesProcessor = new PropertiesBasedResumableProcessor();
+    Map<String, Long> propertiesMap = propertiesProcessor.load();
+    assertEquals(propertiesMap.size(), 1);
+    assertEquals(propertiesMap.get("http://localhost/test2.url"), Long.valueOf(50L));
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index ff762a72f..a46a424e3 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -1,195 +1,183 @@
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0, 
- * and you may not use this file except in compliance with the Apache License Version 2.0. 
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing, 
- * software distributed under the Apache License Version 2.0 is distributed on an 
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.handler.resumable;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.get;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.*;
-import static org.powermock.api.mockito.PowerMockito.mock;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.*;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.State;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
-import org.powermock.api.mockito.PowerMockito;
-import org.powermock.core.classloader.annotations.PrepareForTest;
-import org.powermock.modules.testng.PowerMockTestCase;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderNames.RANGE;
+import static org.asynchttpclient.Dsl.get;
+import static org.mockito.Mockito.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 /**
  * @author Benjamin Hanzelmann
  */
-@PrepareForTest({ HttpResponseStatus.class, State.class })
-public class ResumableAsyncHandlerTest extends PowerMockTestCase {
-    @Test
-    public void testAdjustRange() {
-        MapResumableProcessor proc = new MapResumableProcessor();
-
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(proc);
-        Request request = get("http://test/url").build();
-        Request newRequest = handler.adjustRequestRange(request);
-        assertEquals(newRequest.getUri(), request.getUri());
-        String rangeHeader = newRequest.getHeaders().get(RANGE);
-        assertNull(rangeHeader);
-
-        proc.put("http://test/url", 5000);
-        newRequest = handler.adjustRequestRange(request);
-        assertEquals(newRequest.getUri(), request.getUri());
-        rangeHeader = newRequest.getHeaders().get(RANGE);
-        assertEquals(rangeHeader, "bytes=5000-");
-    }
-
-    @Test
-    public void testOnStatusReceivedOkStatus() throws Exception {
-        MapResumableProcessor processor = new MapResumableProcessor();
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-        HttpResponseStatus responseStatus200 = mock(HttpResponseStatus.class);
-        when(responseStatus200.getStatusCode()).thenReturn(200);
-        when(responseStatus200.getUri()).thenReturn(mock(Uri.class));
-        State state = handler.onStatusReceived(responseStatus200);
-        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a OK response");
-    }
-    
-    @Test
-    public void testOnStatusReceived206Status() throws Exception {
-        MapResumableProcessor processor = new MapResumableProcessor();
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-        HttpResponseStatus responseStatus206 = mock(HttpResponseStatus.class);
-        when(responseStatus206.getStatusCode()).thenReturn(206);
-        when(responseStatus206.getUri()).thenReturn(mock(Uri.class));
-        State state = handler.onStatusReceived(responseStatus206);
-        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a 'Partial Content' response");
-    }
-    
-    @Test
-    public void testOnStatusReceivedOkStatusWithDecoratedAsyncHandler() throws Exception {
-        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-        when(mockResponseStatus.getStatusCode()).thenReturn(200);
-        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
-
-        @SuppressWarnings("unchecked")
-        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-        State mockState = mock(State.class);
-        when(decoratedAsyncHandler.onStatusReceived(mockResponseStatus)).thenReturn(mockState);
-
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-
-        State state = handler.onStatusReceived(mockResponseStatus);
-        verify(decoratedAsyncHandler).onStatusReceived(mockResponseStatus);
-        assertEquals(state, mockState, "State returned should be equal to the one returned from decoratedAsyncHandler");
-    }
-    
-    @Test
-    public void testOnStatusReceived500Status() throws Exception{
-        MapResumableProcessor processor = new MapResumableProcessor();
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-        when(mockResponseStatus.getStatusCode()).thenReturn(500);
-        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
-        State state = handler.onStatusReceived(mockResponseStatus);
-        assertEquals(state, AsyncHandler.State.ABORT, "State should be ABORT for Internal Server Error status");
-    }
-    
-    @Test
-    public void testOnBodyPartReceived() throws Exception {
-        ResumableAsyncHandler handler = new ResumableAsyncHandler();
-        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
-        ByteBuffer buffer = ByteBuffer.allocate(0);
-        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
-        State state = handler.onBodyPartReceived(bodyPart);
-        assertEquals(state, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onBodyPartReceived");
-    }
-    
-    @Test
-    public void testOnBodyPartReceivedWithResumableListenerThrowsException() throws Exception {
-        ResumableAsyncHandler handler = new ResumableAsyncHandler();
-
-        ResumableListener resumableListener = PowerMockito.mock(ResumableListener.class);
-        doThrow(new IOException()).when(resumableListener).onBytesReceived(anyObject());
-        handler.setResumableListener(resumableListener);
-
-        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-        State state = handler.onBodyPartReceived(bodyPart);
-        assertEquals(state, AsyncHandler.State.ABORT,
-                "State should be ABORT if the resumableListener threw an exception in onBodyPartReceived");
-    }
-    
-    @Test
-    public void testOnBodyPartReceivedWithDecoratedAsyncHandler() throws Exception {
-        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
-        ByteBuffer buffer = ByteBuffer.allocate(0);
-        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
-
-        @SuppressWarnings("unchecked")
-        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-        State mockState = mock(State.class);
-        when(decoratedAsyncHandler.onBodyPartReceived(bodyPart)).thenReturn(mockState);
-
-        // following is needed to set the url variable
-        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-        when(mockResponseStatus.getStatusCode()).thenReturn(200);
-        Uri mockUri = mock(Uri.class);
-        when(mockUri.toUrl()).thenReturn("http://non.null");
-        when(mockResponseStatus.getUri()).thenReturn(mockUri);
-
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-        handler.onStatusReceived(mockResponseStatus);
-
-        State state = handler.onBodyPartReceived(bodyPart);
-        assertEquals(state, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
-
-    }
-    
-    @Test
-    public void testOnHeadersReceived() throws Exception {
-        ResumableAsyncHandler handler = new ResumableAsyncHandler();
-        HttpHeaders responseHeaders = new DefaultHttpHeaders();
-        State status = handler.onHeadersReceived(responseHeaders);
-        assertEquals(status, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onHeadersReceived");
-    }
-    
-    @Test
-    public void testOnHeadersReceivedWithDecoratedAsyncHandler() throws Exception {
-        HttpHeaders responseHeaders = new DefaultHttpHeaders();
-
-        @SuppressWarnings("unchecked")
-        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-        State mockState = mock(State.class);
-        when(decoratedAsyncHandler.onHeadersReceived(responseHeaders)).thenReturn(mockState);
-
-        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-        State status = handler.onHeadersReceived(responseHeaders);
-        assertEquals(status, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
-    }
-    
-    @Test
-    public void testOnHeadersReceivedContentLengthMinus() throws Exception {
-        ResumableAsyncHandler handler = new ResumableAsyncHandler();
-        HttpHeaders responseHeaders = new DefaultHttpHeaders();
-        responseHeaders.add(CONTENT_LENGTH, -1);
-        State status = handler.onHeadersReceived(responseHeaders);
-        assertEquals(status, AsyncHandler.State.ABORT, "State should be ABORT for content length -1");
-    }
+public class ResumableAsyncHandlerTest {
+  @Test
+  public void testAdjustRange() {
+    MapResumableProcessor proc = new MapResumableProcessor();
+
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(proc);
+    Request request = get("http://test/url").build();
+    Request newRequest = handler.adjustRequestRange(request);
+    assertEquals(newRequest.getUri(), request.getUri());
+    String rangeHeader = newRequest.getHeaders().get(RANGE);
+    assertNull(rangeHeader);
+
+    proc.put("http://test/url", 5000);
+    newRequest = handler.adjustRequestRange(request);
+    assertEquals(newRequest.getUri(), request.getUri());
+    rangeHeader = newRequest.getHeaders().get(RANGE);
+    assertEquals(rangeHeader, "bytes=5000-");
+  }
+
+  @Test
+  public void testOnStatusReceivedOkStatus() throws Exception {
+    MapResumableProcessor processor = new MapResumableProcessor();
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+    HttpResponseStatus responseStatus200 = mock(HttpResponseStatus.class);
+    when(responseStatus200.getStatusCode()).thenReturn(200);
+    when(responseStatus200.getUri()).thenReturn(mock(Uri.class));
+    State state = handler.onStatusReceived(responseStatus200);
+    assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a OK response");
+  }
+
+  @Test
+  public void testOnStatusReceived206Status() throws Exception {
+    MapResumableProcessor processor = new MapResumableProcessor();
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+    HttpResponseStatus responseStatus206 = mock(HttpResponseStatus.class);
+    when(responseStatus206.getStatusCode()).thenReturn(206);
+    when(responseStatus206.getUri()).thenReturn(mock(Uri.class));
+    State state = handler.onStatusReceived(responseStatus206);
+    assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a 'Partial Content' response");
+  }
+
+  @Test
+  public void testOnStatusReceivedOkStatusWithDecoratedAsyncHandler() throws Exception {
+    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+    when(mockResponseStatus.getStatusCode()).thenReturn(200);
+    when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+
+    @SuppressWarnings("unchecked")
+    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+    when(decoratedAsyncHandler.onStatusReceived(mockResponseStatus)).thenReturn(State.CONTINUE);
+
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+
+    State state = handler.onStatusReceived(mockResponseStatus);
+    verify(decoratedAsyncHandler).onStatusReceived(mockResponseStatus);
+    assertEquals(state, State.CONTINUE, "State returned should be equal to the one returned from decoratedAsyncHandler");
+  }
+
+  @Test
+  public void testOnStatusReceived500Status() throws Exception {
+    MapResumableProcessor processor = new MapResumableProcessor();
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+    when(mockResponseStatus.getStatusCode()).thenReturn(500);
+    when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+    State state = handler.onStatusReceived(mockResponseStatus);
+    assertEquals(state, AsyncHandler.State.ABORT, "State should be ABORT for Internal Server Error status");
+  }
+
+  @Test
+  public void testOnBodyPartReceived() throws Exception {
+    ResumableAsyncHandler handler = new ResumableAsyncHandler();
+    HttpResponseBodyPart bodyPart = mock(HttpResponseBodyPart.class);
+    when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+    ByteBuffer buffer = ByteBuffer.allocate(0);
+    when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+    State state = handler.onBodyPartReceived(bodyPart);
+    assertEquals(state, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onBodyPartReceived");
+  }
+
+  @Test
+  public void testOnBodyPartReceivedWithResumableListenerThrowsException() throws Exception {
+    ResumableAsyncHandler handler = new ResumableAsyncHandler();
+
+    ResumableListener resumableListener = mock(ResumableListener.class);
+    doThrow(new IOException()).when(resumableListener).onBytesReceived(any());
+    handler.setResumableListener(resumableListener);
+
+    HttpResponseBodyPart bodyPart = mock(HttpResponseBodyPart.class);
+    State state = handler.onBodyPartReceived(bodyPart);
+    assertEquals(state, AsyncHandler.State.ABORT,
+            "State should be ABORT if the resumableListener threw an exception in onBodyPartReceived");
+  }
+
+  @Test
+  public void testOnBodyPartReceivedWithDecoratedAsyncHandler() throws Exception {
+    HttpResponseBodyPart bodyPart = mock(HttpResponseBodyPart.class);
+    when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+    ByteBuffer buffer = ByteBuffer.allocate(0);
+    when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+
+    @SuppressWarnings("unchecked")
+    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+    when(decoratedAsyncHandler.onBodyPartReceived(bodyPart)).thenReturn(State.CONTINUE);
+
+    // following is needed to set the url variable
+    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+    when(mockResponseStatus.getStatusCode()).thenReturn(200);
+    Uri uri = Uri.create("http://non.null");
+    when(mockResponseStatus.getUri()).thenReturn(uri);
+
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+    handler.onStatusReceived(mockResponseStatus);
+
+    State state = handler.onBodyPartReceived(bodyPart);
+    assertEquals(state, State.CONTINUE, "State should be equal to the state returned from decoratedAsyncHandler");
+
+  }
+
+  @Test
+  public void testOnHeadersReceived() throws Exception {
+    ResumableAsyncHandler handler = new ResumableAsyncHandler();
+    HttpHeaders responseHeaders = new DefaultHttpHeaders();
+    State status = handler.onHeadersReceived(responseHeaders);
+    assertEquals(status, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onHeadersReceived");
+  }
+
+  @Test
+  public void testOnHeadersReceivedWithDecoratedAsyncHandler() throws Exception {
+    HttpHeaders responseHeaders = new DefaultHttpHeaders();
+
+    @SuppressWarnings("unchecked")
+    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+    when(decoratedAsyncHandler.onHeadersReceived(responseHeaders)).thenReturn(State.CONTINUE);
+
+    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+    State status = handler.onHeadersReceived(responseHeaders);
+    assertEquals(status, State.CONTINUE, "State should be equal to the state returned from decoratedAsyncHandler");
+  }
+
+  @Test
+  public void testOnHeadersReceivedContentLengthMinus() throws Exception {
+    ResumableAsyncHandler handler = new ResumableAsyncHandler();
+    HttpHeaders responseHeaders = new DefaultHttpHeaders();
+    responseHeaders.add(CONTENT_LENGTH, -1);
+    State status = handler.onHeadersReceived(responseHeaders);
+    assertEquals(status, AsyncHandler.State.ABORT, "State should be ABORT for content length -1");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
index 663143371..e7f509a07 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
@@ -13,38 +13,37 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import static org.mockito.Mockito.*;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
-import org.powermock.api.mockito.PowerMockito;
-import org.testng.annotations.Test;
+import static org.mockito.Mockito.*;
 
 public class ResumableRandomAccessFileListenerTest {
 
-    @Test
-    public void testOnBytesReceivedBufferHasArray() throws IOException {
-        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
-        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
-        byte[] array = new byte[] { 1, 2, 23, 33 };
-        ByteBuffer buf = ByteBuffer.wrap(array);
-        listener.onBytesReceived(buf);
-        verify(file).write(array, 0, 4);
-    }
-
-    @Test
-    public void testOnBytesReceivedBufferHasNoArray() throws IOException {
-        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
-        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
-
-        byte[] byteArray = new byte[] { 1, 2, 23, 33 };
-        ByteBuffer buf = ByteBuffer.allocateDirect(4);
-        buf.put(byteArray);
-        buf.flip();
-        listener.onBytesReceived(buf);
-        verify(file).write(byteArray);
-    }
+  @Test
+  public void testOnBytesReceivedBufferHasArray() throws IOException {
+    RandomAccessFile file = mock(RandomAccessFile.class);
+    ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+    byte[] array = new byte[]{1, 2, 23, 33};
+    ByteBuffer buf = ByteBuffer.wrap(array);
+    listener.onBytesReceived(buf);
+    verify(file).write(array, 0, 4);
+  }
+
+  @Test
+  public void testOnBytesReceivedBufferHasNoArray() throws IOException {
+    RandomAccessFile file = mock(RandomAccessFile.class);
+    ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+
+    byte[] byteArray = new byte[]{1, 2, 23, 33};
+    ByteBuffer buf = ByteBuffer.allocateDirect(4);
+    buf.put(byteArray);
+    buf.flip();
+    listener.onBytesReceived(buf);
+    verify(file).write(byteArray);
+  }
 
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
index ac51e2a23..8a3c6e43f 100644
--- a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
@@ -12,64 +12,63 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.HttpMessage;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+
 public class EventPipelineTest extends AbstractBasicTest {
 
-    @Test(groups = "standalone")
-    public void asyncPipelineTest() throws Exception {
+  @Test
+  public void asyncPipelineTest() throws Exception {
 
-        AsyncHttpClientConfig.AdditionalChannelInitializer httpAdditionalPipelineInitializer = new AsyncHttpClientConfig.AdditionalChannelInitializer() {
-            public void initChannel(Channel channel) throws Exception {
-                channel.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
-            }
-        };
+    Consumer<Channel> httpAdditionalPipelineInitializer = channel -> channel.pipeline().addBefore("inflater",
+            "copyEncodingHeader", new CopyEncodingHandler());
 
-        try (AsyncHttpClient p = asyncHttpClient(config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
-            final CountDownLatch l = new CountDownLatch(1);
-            p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
+    try (AsyncHttpClient p = asyncHttpClient(
+            config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
+      final CountDownLatch l = new CountDownLatch(1);
+      p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+        @Override
+        public Response onCompleted(Response response) {
+          try {
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+          } finally {
+            l.countDown();
+          }
+          return response;
         }
+      }).get();
+      if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+        fail("Timeout out");
+      }
     }
+  }
 
-    private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
-        @Override
-        public void channelRead(ChannelHandlerContext ctx, Object e) {
-            if (e instanceof HttpMessage) {
-                HttpMessage m = (HttpMessage) e;
-                // for test there is no Content-Encoding header so just hard
-                // coding value
-                // for verification
-                m.headers().set("X-Original-Content-Encoding", "<original encoding>");
-            }
-            ctx.fireChannelRead(e);
-        }
+  private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object e) {
+      if (e instanceof HttpMessage) {
+        HttpMessage m = (HttpMessage) e;
+        // for test there is no Content-Encoding header so just hard
+        // coding value
+        // for verification
+        m.headers().set("X-Original-Content-Encoding", "<original encoding>");
+      }
+      ctx.fireChannelRead(e);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 12bec3449..0ce1f9535 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -12,11 +12,10 @@
  */
 package org.asynchttpclient.netty;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
+import org.testng.annotations.Test;
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -24,52 +23,54 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 public class NettyAsyncResponseTest {
 
-    @Test(groups = "standalone")
-    public void testCookieParseExpires() {
-        // e.g. "Tue, 27 Oct 2015 12:54:24 GMT";
-        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
-        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
+  @Test
+  public void testCookieParseExpires() {
+    // e.g. "Tue, 27 Oct 2015 12:54:24 GMT";
+    SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
+    sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
+
+    Date date = new Date(System.currentTimeMillis() + 60000);
+    final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-        Date date = new Date(System.currentTimeMillis() + 60000);
-        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
+    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
 
-        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+    List<Cookie> cookies = response.getCookies();
+    assertEquals(cookies.size(), 1);
 
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
+    Cookie cookie = cookies.get(0);
+    assertTrue(cookie.maxAge() >= 58 && cookie.maxAge() <= 60);
+  }
 
-        Cookie cookie = cookies.get(0);
-        assertTrue(cookie.maxAge() >= 58 && cookie.maxAge() <= 60);
-    }
+  @Test
+  public void testCookieParseMaxAge() {
+    final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
 
-    @Test(groups = "standalone")
-    public void testCookieParseMaxAge() {
-        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        
-        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
+    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+    List<Cookie> cookies = response.getCookies();
+    assertEquals(cookies.size(), 1);
 
-        Cookie cookie = cookies.get(0);
-        assertEquals(cookie.maxAge(), 60);
-    }
+    Cookie cookie = cookies.get(0);
+    assertEquals(cookie.maxAge(), 60);
+  }
 
-    @Test(groups = "standalone")
-    public void testCookieParseWeirdExpiresValue() {
-        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+  @Test
+  public void testCookieParseWeirdExpiresValue() {
+    final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
+    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
 
-        List<Cookie> cookies = response.getCookies();
-        assertEquals(cookies.size(), 1);
+    List<Cookie> cookies = response.getCookies();
+    assertEquals(cookies.size(), 1);
 
-        Cookie cookie = cookies.get(0);
-        assertEquals(cookie.maxAge(), Long.MIN_VALUE);
-    }
+    Cookie cookie = cookies.get(0);
+    assertEquals(cookie.maxAge(), Long.MIN_VALUE);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index cec2b0ef5..f1c719ef9 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -12,9 +12,18 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.AsyncContext;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -24,112 +33,98 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 
 public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
-    private static final String MSG = "Enough is enough.";
-    private static final int SLEEPTIME_MS = 1000;
+  private static final String MSG = "Enough is enough.";
+  private static final int SLEEPTIME_MS = 1000;
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new SlowHandler();
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new SlowHandler();
+  }
 
-    private class SlowHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
-                throws IOException, ServletException {
-            response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        Thread.sleep(SLEEPTIME_MS);
-                        response.getOutputStream().print(MSG);
-                        response.getOutputStream().flush();
-                        asyncContext.complete();
-                    } catch (InterruptedException e) {
-                        logger.error(e.getMessage(), e);
-                    } catch (IOException e) {
-                        logger.error(e.getMessage(), e);
-                    }
-                }
-            }).start();
-            baseRequest.setHandled(true);
-        }
-    }
+  @Test
+  public void testRequestTimeout() throws IOException {
+    final Semaphore requestThrottle = new Semaphore(1);
 
-    @Test(groups = "standalone")
-    public void testRequestTimeout() throws IOException {
-        final Semaphore requestThrottle = new Semaphore(1);
-
-        int samples = 10;
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
-            final CountDownLatch latch = new CountDownLatch(samples);
-            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
-
-            for (int i = 0; i < samples; i++) {
-                new Thread(new Runnable() {
-
-                    public void run() {
-                        try {
-                            requestThrottle.acquire();
-                            Future<Response> responseFuture = null;
-                            try {
-                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
-                                        .execute(new AsyncCompletionHandler<Response>() {
-
-                                            @Override
-                                            public Response onCompleted(Response response) throws Exception {
-                                                return response;
-                                            }
-
-                                            @Override
-                                            public void onThrowable(Throwable t) {
-                                                logger.error("onThrowable got an error", t);
-                                                try {
-                                                    Thread.sleep(100);
-                                                } catch (InterruptedException e) {
-                                                }
-                                                requestThrottle.release();
-                                            }
-                                        });
-                            } catch (Exception e) {
-                                tooManyConnections.add(e);
-                            }
-
-                            if (responseFuture != null)
-                                responseFuture.get();
-                        } catch (Exception e) {
-                        } finally {
-                            latch.countDown();
-                        }
+    int samples = 10;
 
-                    }
-                }).start();
-            }
+    try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
+      final CountDownLatch latch = new CountDownLatch(samples);
+      final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
 
+      for (int i = 0; i < samples; i++) {
+        new Thread(() -> {
+          try {
+            requestThrottle.acquire();
+            Future<Response> responseFuture = null;
             try {
-                latch.await(30, TimeUnit.SECONDS);
+              responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
+                      .execute(new AsyncCompletionHandler<Response>() {
+
+                        @Override
+                        public Response onCompleted(Response response) {
+                          return response;
+                        }
+
+                        @Override
+                        public void onThrowable(Throwable t) {
+                          logger.error("onThrowable got an error", t);
+                          try {
+                            Thread.sleep(100);
+                          } catch (InterruptedException e) {
+                            //
+                          }
+                          requestThrottle.release();
+                        }
+                      });
             } catch (Exception e) {
-                fail("failed to wait for requests to complete");
+              tooManyConnections.add(e);
             }
 
-            for (Exception e : tooManyConnections)
-                logger.error("Exception while calling execute", e);
-
-            assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
+            if (responseFuture != null)
+              responseFuture.get();
+          } catch (Exception e) {
+            //
+          } finally {
+            latch.countDown();
+          }
+        }).start();
+      }
+
+      try {
+        latch.await(30, TimeUnit.SECONDS);
+      } catch (Exception e) {
+        fail("failed to wait for requests to complete");
+      }
+
+      for (Exception e : tooManyConnections)
+        logger.error("Exception while calling execute", e);
+
+      assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
+    }
+  }
+
+  private class SlowHandler extends AbstractHandler {
+    public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
+            throws IOException, ServletException {
+      response.setStatus(HttpServletResponse.SC_OK);
+      final AsyncContext asyncContext = request.startAsync();
+      new Thread(() -> {
+        try {
+          Thread.sleep(SLEEPTIME_MS);
+          response.getOutputStream().print(MSG);
+          response.getOutputStream().flush();
+          asyncContext.complete();
+        } catch (InterruptedException | IOException e) {
+          logger.error(e.getMessage(), e);
         }
+      }).start();
+      baseRequest.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
index a453683de..f496deec2 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
@@ -13,75 +13,74 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.testng.Assert.*;
+import org.asynchttpclient.AsyncHandler;
+import org.testng.annotations.Test;
 
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 
 import static org.mockito.Mockito.*;
-
-import org.asynchttpclient.AsyncHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
 public class NettyResponseFutureTest {
 
-    @Test
-    public void testCancel() {
-        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        boolean result = nettyResponseFuture.cancel(false);
-        verify(asyncHandler).onThrowable(anyObject());
-        assertTrue(result, "Cancel should return true if the Future was cancelled successfully");
-        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
-    }
+  @Test
+  public void testCancel() {
+    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    boolean result = nettyResponseFuture.cancel(false);
+    verify(asyncHandler).onThrowable(anyObject());
+    assertTrue(result, "Cancel should return true if the Future was cancelled successfully");
+    assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+  }
 
-    @Test
-    public void testCancelOnAlreadyCancelled() {
-        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        nettyResponseFuture.cancel(false);
-        boolean result = nettyResponseFuture.cancel(false);
-        assertFalse(result, "cancel should return false for an already cancelled Future");
-        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
-    }
+  @Test
+  public void testCancelOnAlreadyCancelled() {
+    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    nettyResponseFuture.cancel(false);
+    boolean result = nettyResponseFuture.cancel(false);
+    assertFalse(result, "cancel should return false for an already cancelled Future");
+    assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+  }
 
-    @Test(expectedExceptions = CancellationException.class)
-    public void testGetContentThrowsCancellationExceptionIfCancelled() throws InterruptedException, ExecutionException {
-        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        nettyResponseFuture.cancel(false);
-        nettyResponseFuture.get();
-        fail("A CancellationException must have occurred by now as 'cancel' was called before 'get'");
-    }
+  @Test(expectedExceptions = CancellationException.class)
+  public void testGetContentThrowsCancellationExceptionIfCancelled() throws InterruptedException, ExecutionException {
+    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    nettyResponseFuture.cancel(false);
+    nettyResponseFuture.get();
+    fail("A CancellationException must have occurred by now as 'cancel' was called before 'get'");
+  }
 
-    @Test
-    public void testGet() throws Exception {
-        @SuppressWarnings("unchecked")
-        AsyncHandler<Object> asyncHandler = mock(AsyncHandler.class);
-        Object value = new Object();
-        when(asyncHandler.onCompleted()).thenReturn(value);
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        nettyResponseFuture.done();
-        Object result = nettyResponseFuture.get();
-        assertEquals(result, value, "The Future should return the value given by asyncHandler#onCompleted");
-    }
+  @Test
+  public void testGet() throws Exception {
+    @SuppressWarnings("unchecked")
+    AsyncHandler<Object> asyncHandler = mock(AsyncHandler.class);
+    Object value = new Object();
+    when(asyncHandler.onCompleted()).thenReturn(value);
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    nettyResponseFuture.done();
+    Object result = nettyResponseFuture.get();
+    assertEquals(result, value, "The Future should return the value given by asyncHandler#onCompleted");
+  }
 
-    @Test(expectedExceptions = ExecutionException.class)
-    public void testGetThrowsExceptionThrownByAsyncHandler() throws Exception {
-        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-        when(asyncHandler.onCompleted()).thenThrow(new RuntimeException());
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        nettyResponseFuture.done();
-        nettyResponseFuture.get();
-        fail("An ExecutionException must have occurred by now as asyncHandler threw an exception in 'onCompleted'");
-    }
+  @Test(expectedExceptions = ExecutionException.class)
+  public void testGetThrowsExceptionThrownByAsyncHandler() throws Exception {
+    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+    when(asyncHandler.onCompleted()).thenThrow(new RuntimeException());
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    nettyResponseFuture.done();
+    nettyResponseFuture.get();
+    fail("An ExecutionException must have occurred by now as asyncHandler threw an exception in 'onCompleted'");
+  }
 
-    @Test(expectedExceptions = ExecutionException.class)
-    public void testGetThrowsExceptionOnAbort() throws InterruptedException, ExecutionException {
-        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-        nettyResponseFuture.abort(new RuntimeException());
-        nettyResponseFuture.get();
-        fail("An ExecutionException must have occurred by now as 'abort' was called before 'get'");
-    }
+  @Test(expectedExceptions = ExecutionException.class)
+  public void testGetThrowsExceptionOnAbort() throws InterruptedException, ExecutionException {
+    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+    nettyResponseFuture.abort(new RuntimeException());
+    nettyResponseFuture.get();
+    fail("An ExecutionException must have occurred by now as 'abort' was called before 'get'");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index 863b71fe5..05fbfa78d 100644
--- a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -12,11 +12,19 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.*;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -25,185 +33,164 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.servlet.ServletContextHandler;
-import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
 
 //FIXME there's no retry actually
 public class RetryNonBlockingIssue extends AbstractBasicTest {
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-
-        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-        context.setContextPath("/");
-        context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
-        server.setHandler(context);
-        
-        server.start();
-        port1 = connector.getLocalPort();
-    }
-
-    protected String getTargetUrl() {
-        return String.format("http://localhost:%d/", port1);
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+
+    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+    context.setContextPath("/");
+    context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
+    server.setHandler(context);
+
+    server.start();
+    port1 = connector.getLocalPort();
+  }
+
+  protected String getTargetUrl() {
+    return String.format("http://localhost:%d/", port1);
+  }
+
+  private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) {
+    RequestBuilder r = get(getTargetUrl())
+            .addQueryParam(action, "1")
+            .addQueryParam("maxRequests", "" + requests)
+            .addQueryParam("id", id);
+    return client.executeRequest(r);
+  }
+
+  @Test
+  public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
+
+    AsyncHttpClientConfig config = config()
+            .setKeepAlive(true)
+            .setMaxConnections(100)
+            .setConnectTimeout(60000)
+            .setRequestTimeout(30000)
+            .build();
+
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      List<ListenableFuture<Response>> res = new ArrayList<>();
+      for (int i = 0; i < 32; i++) {
+        res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+      }
+
+      StringBuilder b = new StringBuilder();
+      for (ListenableFuture<Response> r : res) {
+        Response theres = r.get();
+        assertEquals(200, theres.getStatusCode());
+        b.append("==============\r\n")
+                .append("Response Headers\r\n");
+        HttpHeaders heads = theres.getHeaders();
+        b.append(heads).append("\r\n")
+                .append("==============\r\n");
+      }
+      System.out.println(b.toString());
+      System.out.flush();
     }
-
-    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
-        RequestBuilder r = get(getTargetUrl())//
-                .addQueryParam(action, "1")//
-                .addQueryParam("maxRequests", "" + requests)//
-                .addQueryParam("id", id);
-        return client.executeRequest(r);
+  }
+
+  @Test
+  public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
+
+    AsyncHttpClientConfig config = config()
+            .setKeepAlive(true)
+            .setMaxConnections(100)
+            .setConnectTimeout(60000)
+            .setRequestTimeout(30000)
+            .build();
+
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      List<ListenableFuture<Response>> res = new ArrayList<>();
+      for (int i = 0; i < 32; i++) {
+        res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+      }
+
+      StringBuilder b = new StringBuilder();
+      for (ListenableFuture<Response> r : res) {
+        Response theres = r.get();
+        assertEquals(theres.getStatusCode(), 200);
+        b.append("==============\r\n")
+                .append("Response Headers\r\n");
+        HttpHeaders heads = theres.getHeaders();
+        b.append(heads).append("\r\n")
+                .append("==============\r\n");
+      }
+      System.out.println(b.toString());
+      System.out.flush();
     }
-
-    /**
-     * Tests that a head request can be made
-     * 
-     * @throws IOException
-     * @throws ExecutionException
-     * @throws InterruptedException
-     */
-    @Test(groups = "standalone")
-    public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
-
-        AsyncHttpClientConfig config = config()//
-                .setKeepAlive(true)//
-                .setMaxConnections(100)//
-                .setConnectTimeout(60000)//
-                .setRequestTimeout(30000)//
-                .build();
-
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            List<ListenableFuture<Response>> res = new ArrayList<>();
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
-            }
-
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                assertEquals(200, theres.getStatusCode());
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                HttpHeaders heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-            }
-            System.out.println(b.toString());
-            System.out.flush();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
-
-        AsyncHttpClientConfig config = config()//
-                .setKeepAlive(true)//
-                .setMaxConnections(100)//
-                .setConnectTimeout(60000)//
-                .setRequestTimeout(30000)//
-                .build();
-
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            List<ListenableFuture<Response>> res = new ArrayList<>();
-            for (int i = 0; i < 32; i++) {
-                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
-            }
-
-            StringBuilder b = new StringBuilder();
-            for (ListenableFuture<Response> r : res) {
-                Response theres = r.get();
-                assertEquals(theres.getStatusCode(), 200);
-                b.append("==============\r\n");
-                b.append("Response Headers\r\n");
-                HttpHeaders heads = theres.getHeaders();
-                b.append(heads + "\r\n");
-                b.append("==============\r\n");
-            }
-            System.out.println(b.toString());
-            System.out.flush();
-        }
+  }
+
+  @SuppressWarnings("serial")
+  public class MockExceptionServlet extends HttpServlet {
+
+    private Map<String, Integer> requests = new ConcurrentHashMap<>();
+
+    private synchronized int increment(String id) {
+      int val;
+      if (requests.containsKey(id)) {
+        Integer i = requests.get(id);
+        val = i + 1;
+        requests.put(id, val);
+      } else {
+        requests.put(id, 1);
+        val = 1;
+      }
+      System.out.println("REQUESTS: " + requests);
+      return val;
     }
 
-    @SuppressWarnings("serial")
-    public class MockExceptionServlet extends HttpServlet {
-
-        private Map<String, Integer> requests = new ConcurrentHashMap<>();
-
-        private synchronized int increment(String id) {
-            int val = 0;
-            if (requests.containsKey(id)) {
-                Integer i = requests.get(id);
-                val = i + 1;
-                requests.put(id, val);
-            } else {
-                requests.put(id, 1);
-                val = 1;
-            }
-            System.out.println("REQUESTS: " + requests);
-            return val;
-        }
-
-        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-            String maxRequests = req.getParameter("maxRequests");
-            int max = 0;
-            try {
-                max = Integer.parseInt(maxRequests);
-            } catch (NumberFormatException e) {
-                max = 3;
-            }
-            String id = req.getParameter("id");
-            int requestNo = increment(id);
-            String servlet = req.getParameter("servlet");
-            String io = req.getParameter("io");
-            String error = req.getParameter("500");
-
-            if (requestNo >= max) {
-                res.setHeader("Success-On-Attempt", "" + requestNo);
-                res.setHeader("id", id);
-                if (servlet != null && servlet.trim().length() > 0)
-                    res.setHeader("type", "servlet");
-                if (error != null && error.trim().length() > 0)
-                    res.setHeader("type", "500");
-                if (io != null && io.trim().length() > 0)
-                    res.setHeader("type", "io");
-                res.setStatus(200);
-                res.setContentLength(0);
-                res.flushBuffer();
-                return;
-            }
-
-            res.setStatus(200);
-            res.setContentLength(100);
-            res.setContentType("application/octet-stream");
-            res.flushBuffer();
-
-            // error after flushing the status
-            if (servlet != null && servlet.trim().length() > 0)
-                throw new ServletException("Servlet Exception");
-
-            if (io != null && io.trim().length() > 0)
-                throw new IOException("IO Exception");
-
-            if (error != null && error.trim().length() > 0) {
-                res.sendError(500, "servlet process was 500");
-            }
-        }
+    public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+      String maxRequests = req.getParameter("maxRequests");
+      int max;
+      try {
+        max = Integer.parseInt(maxRequests);
+      } catch (NumberFormatException e) {
+        max = 3;
+      }
+      String id = req.getParameter("id");
+      int requestNo = increment(id);
+      String servlet = req.getParameter("servlet");
+      String io = req.getParameter("io");
+      String error = req.getParameter("500");
+
+      if (requestNo >= max) {
+        res.setHeader("Success-On-Attempt", "" + requestNo);
+        res.setHeader("id", id);
+        if (servlet != null && servlet.trim().length() > 0)
+          res.setHeader("type", "servlet");
+        if (error != null && error.trim().length() > 0)
+          res.setHeader("type", "500");
+        if (io != null && io.trim().length() > 0)
+          res.setHeader("type", "io");
+        res.setStatus(200);
+        res.setContentLength(0);
+        res.flushBuffer();
+        return;
+      }
+
+      res.setStatus(200);
+      res.setContentLength(100);
+      res.setContentType("application/octet-stream");
+      res.flushBuffer();
+
+      // error after flushing the status
+      if (servlet != null && servlet.trim().length() > 0)
+        throw new ServletException("Servlet Exception");
+
+      if (io != null && io.trim().length() > 0)
+        throw new IOException("IO Exception");
+
+      if (error != null && error.trim().length() > 0) {
+        res.sendError(500, "servlet process was 500");
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java b/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
index 3b18b7800..b4d904d6b 100644
--- a/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
@@ -12,39 +12,36 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.Dsl.*;
+import org.asynchttpclient.*;
+import org.testng.annotations.Test;
 
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 
 public class TimeToLiveIssue extends AbstractBasicTest {
-    @Test(enabled = false, description = "https://github.com/AsyncHttpClient/async-http-client/issues/1113")
-    public void testTTLBug() throws Throwable {
-        // The purpose of this test is to reproduce two issues:
-        // 1) Connections that are rejected by the pool are not closed and eventually use all available sockets.
-        // 2) It is possible for a connection to be closed while active by the timer task that checks for expired connections.
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setConnectionTtl(1).setPooledConnectionIdleTimeout(1))) {
-
-            for (int i = 0; i < 200000; ++i) {
-                Request request = new RequestBuilder().setUrl(String.format("http://localhost:%d/", port1)).build();
-
-                Future<Response> future = client.executeRequest(request);
-                future.get(5, TimeUnit.SECONDS);
-
-                // This is to give a chance to the timer task that removes expired connection
-                // from sometimes winning over poll for the ownership of a connection.
-                if (System.currentTimeMillis() % 100 == 0) {
-                    Thread.sleep(5);
-                }
-            }
+  @Test(enabled = false, description = "https://github.com/AsyncHttpClient/async-http-client/issues/1113")
+  public void testTTLBug() throws Throwable {
+    // The purpose of this test is to reproduce two issues:
+    // 1) Connections that are rejected by the pool are not closed and eventually use all available sockets.
+    // 2) It is possible for a connection to be closed while active by the timer task that checks for expired connections.
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setConnectionTtl(1).setPooledConnectionIdleTimeout(1))) {
+
+      for (int i = 0; i < 200000; ++i) {
+        Request request = new RequestBuilder().setUrl(String.format("http://localhost:%d/", port1)).build();
+
+        Future<Response> future = client.executeRequest(request);
+        future.get(5, TimeUnit.SECONDS);
+
+        // This is to give a chance to the timer task that removes expired connection
+        // from sometimes winning over poll for the ownership of a connection.
+        if (System.currentTimeMillis() % 100 == 0) {
+          Thread.sleep(5);
         }
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java b/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java
deleted file mode 100644
index e7475eef1..000000000
--- a/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty.channel;
-
-import java.util.concurrent.Semaphore;
-
-import org.testng.annotations.Test;
-
-import static org.testng.Assert.*;
-
-/**
- * @author Stepan Koltsov
- */
-public class NonBlockingSemaphoreTest {
-
-    private static class Mirror {
-        private final Semaphore real;
-        private final NonBlockingSemaphore nonBlocking;
-
-        public Mirror(int permits) {
-            real = new Semaphore(permits);
-            nonBlocking = new NonBlockingSemaphore(permits);
-        }
-
-        public boolean tryAcquire() {
-            boolean a = real.tryAcquire();
-            boolean b = nonBlocking.tryAcquire();
-            assertEquals(a, b);
-            return a;
-        }
-
-        public void release() {
-            real.release();
-            nonBlocking.release();
-        }
-    }
-
-    @Test
-    public void test0() {
-        Mirror mirror = new Mirror(0);
-        assertFalse(mirror.tryAcquire());
-    }
-
-    @Test
-    public void three() {
-        Mirror mirror = new Mirror(3);
-        for (int i = 0; i < 3; ++i) {
-            assertTrue(mirror.tryAcquire());
-        }
-        assertFalse(mirror.tryAcquire());
-        mirror.release();
-        assertTrue(mirror.tryAcquire());
-    }
-
-    @Test
-    public void negative() {
-        Mirror mirror = new Mirror(-1);
-        assertFalse(mirror.tryAcquire());
-        mirror.release();
-        assertFalse(mirror.tryAcquire());
-        mirror.release();
-        assertTrue(mirror.tryAcquire());
-    }
-
-}
diff --git a/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreRunner.java b/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreRunner.java
new file mode 100644
index 000000000..7bff799ce
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreRunner.java
@@ -0,0 +1,52 @@
+package org.asynchttpclient.netty.channel;
+
+class SemaphoreRunner {
+
+  final ConnectionSemaphore semaphore;
+  final Thread acquireThread;
+
+  volatile long acquireTime;
+  volatile Exception acquireException;
+
+  public SemaphoreRunner(ConnectionSemaphore semaphore, Object partitionKey) {
+    this.semaphore = semaphore;
+    this.acquireThread = new Thread(() -> {
+      long beforeAcquire = System.currentTimeMillis();
+      try {
+        semaphore.acquireChannelLock(partitionKey);
+      } catch (Exception e) {
+        acquireException = e;
+      } finally {
+        acquireTime = System.currentTimeMillis() - beforeAcquire;
+      }
+    });
+  }
+
+  public void acquire() {
+    this.acquireThread.start();
+  }
+
+  public void interrupt() {
+    this.acquireThread.interrupt();
+  }
+
+  public void await() {
+    try {
+      this.acquireThread.join();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public boolean finished() {
+    return !this.acquireThread.isAlive();
+  }
+
+  public long getAcquireTime() {
+    return acquireTime;
+  }
+
+  public Exception getAcquireException() {
+    return acquireException;
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreTest.java b/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreTest.java
new file mode 100644
index 000000000..125cd9b06
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/netty/channel/SemaphoreTest.java
@@ -0,0 +1,143 @@
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import static org.testng.AssertJUnit.*;
+
+public class SemaphoreTest {
+
+  static final int CHECK_ACQUIRE_TIME__PERMITS = 10;
+  static final int CHECK_ACQUIRE_TIME__TIMEOUT = 100;
+
+  static final int NON_DETERMINISTIC__INVOCATION_COUNT = 10;
+  static final int NON_DETERMINISTIC__SUCCESS_PERCENT = 70;
+
+  private final Object PK = new Object();
+
+  @DataProvider(name = "permitsAndRunnersCount")
+  public Object[][] permitsAndRunnersCount() {
+    Object[][] objects = new Object[100][];
+    int row = 0;
+    for (int i = 0; i < 10; i++) {
+      for (int j = 0; j < 10; j++) {
+        objects[row++] = new Object[]{i, j};
+      }
+    }
+    return objects;
+  }
+
+  @Test(timeOut = 1000, dataProvider = "permitsAndRunnersCount")
+  public void maxConnectionCheckPermitCount(int permitCount, int runnerCount) {
+    allSemaphoresCheckPermitCount(new MaxConnectionSemaphore(permitCount, 0), permitCount, runnerCount);
+  }
+
+  @Test(timeOut = 1000, dataProvider = "permitsAndRunnersCount")
+  public void perHostCheckPermitCount(int permitCount, int runnerCount) {
+    allSemaphoresCheckPermitCount(new PerHostConnectionSemaphore(permitCount, 0), permitCount, runnerCount);
+  }
+
+  @Test(timeOut = 3000, dataProvider = "permitsAndRunnersCount")
+  public void combinedCheckPermitCount(int permitCount, int runnerCount) {
+    allSemaphoresCheckPermitCount(new CombinedConnectionSemaphore(permitCount, permitCount, 0), permitCount, runnerCount);
+    allSemaphoresCheckPermitCount(new CombinedConnectionSemaphore(0, permitCount, 0), permitCount, runnerCount);
+    allSemaphoresCheckPermitCount(new CombinedConnectionSemaphore(permitCount, 0, 0), permitCount, runnerCount);
+  }
+
+  private void allSemaphoresCheckPermitCount(ConnectionSemaphore semaphore, int permitCount, int runnerCount) {
+    List<SemaphoreRunner> runners = IntStream.range(0, runnerCount)
+            .mapToObj(i -> new SemaphoreRunner(semaphore, PK))
+            .collect(Collectors.toList());
+    runners.forEach(SemaphoreRunner::acquire);
+    runners.forEach(SemaphoreRunner::await);
+
+    long tooManyConnectionsCount = runners.stream().map(SemaphoreRunner::getAcquireException)
+            .filter(Objects::nonNull)
+            .filter(e -> e instanceof IOException)
+            .count();
+
+    long acquired = runners.stream().map(SemaphoreRunner::getAcquireException)
+            .filter(Objects::isNull)
+            .count();
+
+    int expectedAcquired = permitCount > 0 ? Math.min(permitCount, runnerCount) : runnerCount;
+
+    assertEquals(expectedAcquired, acquired);
+    assertEquals(runnerCount - acquired, tooManyConnectionsCount);
+  }
+
+  @Test(timeOut = 1000, invocationCount = NON_DETERMINISTIC__INVOCATION_COUNT, successPercentage = NON_DETERMINISTIC__SUCCESS_PERCENT)
+  public void maxConnectionCheckAcquireTime() {
+    checkAcquireTime(new MaxConnectionSemaphore(CHECK_ACQUIRE_TIME__PERMITS, CHECK_ACQUIRE_TIME__TIMEOUT));
+  }
+
+  @Test(timeOut = 1000, invocationCount = NON_DETERMINISTIC__INVOCATION_COUNT, successPercentage = NON_DETERMINISTIC__SUCCESS_PERCENT)
+  public void perHostCheckAcquireTime() {
+    checkAcquireTime(new PerHostConnectionSemaphore(CHECK_ACQUIRE_TIME__PERMITS, CHECK_ACQUIRE_TIME__TIMEOUT));
+  }
+
+  @Test(timeOut = 1000, invocationCount = NON_DETERMINISTIC__INVOCATION_COUNT, successPercentage = NON_DETERMINISTIC__SUCCESS_PERCENT)
+  public void combinedCheckAcquireTime() {
+    checkAcquireTime(new CombinedConnectionSemaphore(CHECK_ACQUIRE_TIME__PERMITS,
+            CHECK_ACQUIRE_TIME__PERMITS,
+            CHECK_ACQUIRE_TIME__TIMEOUT));
+  }
+
+  private void checkAcquireTime(ConnectionSemaphore semaphore) {
+    List<SemaphoreRunner> runners = IntStream.range(0, CHECK_ACQUIRE_TIME__PERMITS * 2)
+            .mapToObj(i -> new SemaphoreRunner(semaphore, PK))
+            .collect(Collectors.toList());
+    long acquireStartTime = System.currentTimeMillis();
+    runners.forEach(SemaphoreRunner::acquire);
+    runners.forEach(SemaphoreRunner::await);
+    long timeToAcquire = System.currentTimeMillis() - acquireStartTime;
+
+    assertTrue("Semaphore acquired too soon: " + timeToAcquire+" ms",timeToAcquire >= (CHECK_ACQUIRE_TIME__TIMEOUT - 50)); //Lower Bound
+    assertTrue("Semaphore acquired too late: " + timeToAcquire+" ms",timeToAcquire <= (CHECK_ACQUIRE_TIME__TIMEOUT + 300)); //Upper Bound
+  }
+
+  @Test(timeOut = 1000)
+  public void maxConnectionCheckRelease() throws IOException {
+    checkRelease(new MaxConnectionSemaphore(1, 0));
+  }
+
+  @Test(timeOut = 1000)
+  public void perHostCheckRelease() throws IOException {
+    checkRelease(new PerHostConnectionSemaphore(1, 0));
+  }
+
+  @Test(timeOut = 1000)
+  public void combinedCheckRelease() throws IOException {
+    checkRelease(new CombinedConnectionSemaphore(1, 1, 0));
+  }
+
+  private void checkRelease(ConnectionSemaphore semaphore) throws IOException {
+    semaphore.acquireChannelLock(PK);
+    boolean tooManyCaught = false;
+    try {
+      semaphore.acquireChannelLock(PK);
+    } catch (TooManyConnectionsException | TooManyConnectionsPerHostException e) {
+      tooManyCaught = true;
+    }
+    assertTrue(tooManyCaught);
+    tooManyCaught = false;
+    semaphore.releaseChannelLock(PK);
+    try {
+      semaphore.acquireChannelLock(PK);
+    } catch (TooManyConnectionsException | TooManyConnectionsPerHostException e) {
+      tooManyCaught = true;
+    }
+    assertFalse(tooManyCaught);
+  }
+
+
+}
+
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 5f922175c..0f8fa703e 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -13,208 +13,212 @@
  */
 package org.asynchttpclient.ntlm;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.apache.commons.io.output.ByteArrayOutputStream;
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.ntlm.NtlmEngine.Type2Message;
-import org.asynchttpclient.util.Base64;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-public class NtlmTest extends AbstractBasicTest {
-
-    public static class NTLMHandler extends AbstractHandler {
-
-        @Override
-        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
-                ServletException {
-
-            String authorization = httpRequest.getHeader("Authorization");
-            if (authorization == null) {
-                httpResponse.setStatus(401);
-                httpResponse.setHeader("WWW-Authenticate", "NTLM");
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.Base64;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 
-            } else if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
-                httpResponse.setStatus(401);
-                httpResponse.setHeader("WWW-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.Dsl.get;
+import static org.asynchttpclient.Dsl.ntlmAuthRealm;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
 
-            } else if (authorization
-                    .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
-                httpResponse.setStatus(200);
-            } else {
-                httpResponse.setStatus(401);
-            }
+public class NtlmTest extends AbstractBasicTest {
 
-            httpResponse.setContentLength(0);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
+  private static byte[] longToBytes(long x) {
+    ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
+    buffer.putLong(x);
+    return buffer.array();
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new NTLMHandler();
+  }
+
+  private Realm.Builder realmBuilderBase() {
+    return ntlmAuthRealm("Zaphod", "Beeblebrox")
+            .setNtlmDomain("Ursa-Minor")
+            .setNtlmHost("LightCity");
+  }
+
+  private void ntlmAuthTest(Realm.Builder realmBuilder) throws IOException, InterruptedException, ExecutionException {
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder))) {
+      Future<Response> responseFuture = client.executeRequest(get(getTargetUrl()));
+      int status = responseFuture.get().getStatusCode();
+      Assert.assertEquals(status, 200);
     }
+  }
+
+  @Test
+  public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+    ntlmAuthTest(realmBuilderBase());
+  }
+
+  @Test
+  public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+    ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
+  }
+
+  @Test
+  public void testGenerateType1Msg() {
+    NtlmEngine engine = new NtlmEngine();
+    String message = engine.generateType1Msg();
+    assertEquals(message, "TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==", "Incorrect type1 message generated");
+  }
+
+  @Test(expectedExceptions = NtlmEngineException.class)
+  public void testGenerateType3MsgThrowsExceptionWhenChallengeTooShort() {
+    NtlmEngine engine = new NtlmEngine();
+    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.getEncoder().encodeToString("a".getBytes()));
+    fail("An NtlmEngineException must have occurred as challenge length is too short");
+  }
+
+  @Test(expectedExceptions = NtlmEngineException.class)
+  public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrectFormat() {
+    NtlmEngine engine = new NtlmEngine();
+    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.getEncoder().encodeToString("challenge".getBytes()));
+    fail("An NtlmEngineException must have occurred as challenge format is not correct");
+  }
+
+  @Test(expectedExceptions = NtlmEngineException.class)
+  public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
+    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+    buf.write(0);
+    // type 2 indicator
+    buf.write(3);
+    buf.write(0);
+    buf.write(0);
+    buf.write(0);
+    buf.write("challenge".getBytes());
+    NtlmEngine engine = new NtlmEngine();
+    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.getEncoder().encodeToString(buf.toByteArray()));
+    buf.close();
+    fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
+  }
+
+  @Test(expectedExceptions = NtlmEngineException.class)
+  public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
+    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+    buf.write(0);
+    // type 2 indicator
+    buf.write(2);
+    buf.write(0);
+    buf.write(0);
+    buf.write(0);
+
+    buf.write(longToBytes(1L)); // we want to write a Long
+
+    // flags
+    buf.write(0);// unicode support indicator
+    buf.write(0);
+    buf.write(0);
+    buf.write(0);
+
+    buf.write(longToBytes(1L));// challenge
+    NtlmEngine engine = new NtlmEngine();
+    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.getEncoder().encodeToString(buf.toByteArray()));
+    buf.close();
+    fail("An NtlmEngineException must have occurred as unicode support is not indicated");
+  }
+
+  @Test
+  public void testGenerateType2Msg() {
+    Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+    Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
+  }
+
+  @Test
+  public void testGenerateType3Msg() throws IOException {
+    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+    buf.write(0);
+    // type 2 indicator
+    buf.write(2);
+    buf.write(0);
+    buf.write(0);
+    buf.write(0);
+
+    buf.write(longToBytes(0L)); // we want to write a Long
+
+    // flags
+    buf.write(1);// unicode support indicator
+    buf.write(0);
+    buf.write(0);
+    buf.write(0);
+
+    buf.write(longToBytes(1L));// challenge
+    NtlmEngine engine = new NtlmEngine();
+    String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", 
+            Base64.getEncoder().encodeToString(buf.toByteArray()));
+    buf.close();
+    assertEquals(
+            type3Msg,
+            "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
+            "Incorrect type3 message generated");
+  }
+
+  @Test
+  public void testWriteULong() {
+    // test different combinations so that different positions in the byte array will be written
+    byte[] buffer = new byte[4];
+    NtlmEngine.writeULong(buffer, 1, 0);
+    assertEquals(buffer, new byte[]{1, 0, 0, 0}, "Unsigned long value 1 was not written correctly to the buffer");
+
+    buffer = new byte[4];
+    NtlmEngine.writeULong(buffer, 257, 0);
+    assertEquals(buffer, new byte[]{1, 1, 0, 0}, "Unsigned long value 257 was not written correctly to the buffer");
+
+    buffer = new byte[4];
+    NtlmEngine.writeULong(buffer, 16777216, 0);
+    assertEquals(buffer, new byte[]{0, 0, 0, 1}, "Unsigned long value 16777216 was not written correctly to the buffer");
+  }
+
+  public static class NTLMHandler extends AbstractHandler {
 
     @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new NTLMHandler();
-    }
-
-    private Realm.Builder realmBuilderBase() {
-        return ntlmAuthRealm("Zaphod", "Beeblebrox")//
-                .setNtlmDomain("Ursa-Minor")//
-                .setNtlmHost("LightCity");
-    }
-
-    private void ntlmAuthTest(Realm.Builder realmBuilder) throws IOException, InterruptedException, ExecutionException {
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder))) {
-            Future<Response> responseFuture = client.executeRequest(get(getTargetUrl()));
-            int status = responseFuture.get().getStatusCode();
-            Assert.assertEquals(status, 200);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
-        ntlmAuthTest(realmBuilderBase());
-    }
-
-    @Test(groups = "standalone")
-    public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
-        ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
-    }
-
-    @Test
-    public void testGenerateType1Msg() {
-        NtlmEngine engine = new NtlmEngine();
-        String message = engine.generateType1Msg();
-        assertEquals(message, "TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==", "Incorrect type1 message generated");
-    }
-
-    @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThrowsExceptionWhenChallengeTooShort() {
-        NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("a".getBytes()));
-        fail("An NtlmEngineException must have occurred as challenge length is too short");
-    }
-
-    @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrectFormat() {
-        NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("challenge".getBytes()));
-        fail("An NtlmEngineException must have occurred as challenge format is not correct");
-    }
-
-    private static byte[] longToBytes(long x) {
-        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
-        buffer.putLong(x);
-        return buffer.array();
-    }
-
-    @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
-        ByteArrayOutputStream buf = new ByteArrayOutputStream();
-        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.write(0);
-        // type 2 indicator
-        buf.write(3);
-        buf.write(0);
-        buf.write(0);
-        buf.write(0);
-        buf.write("challenge".getBytes());
-        NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-        buf.close();
-        fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
-    }
-
-    @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
-        ByteArrayOutputStream buf = new ByteArrayOutputStream();
-        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.write(0);
-        // type 2 indicator
-        buf.write(2);
-        buf.write(0);
-        buf.write(0);
-        buf.write(0);
-
-        buf.write(longToBytes(1L)); // we want to write a Long
-
-        // flags
-        buf.write(0);// unicode support indicator
-        buf.write(0);
-        buf.write(0);
-        buf.write(0);
-
-        buf.write(longToBytes(1L));// challenge
-        NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-        buf.close();
-        fail("An NtlmEngineException must have occurred as unicode support is not indicated");
-    }
-
-    @Test(groups = "standalone")
-    public void testGenerateType2Msg() {
-        Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
-        Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
-    }
-
-    @Test
-    public void testGenerateType3Msg() throws IOException {
-        ByteArrayOutputStream buf = new ByteArrayOutputStream();
-        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.write(0);
-        // type 2 indicator
-        buf.write(2);
-        buf.write(0);
-        buf.write(0);
-        buf.write(0);
-
-        buf.write(longToBytes(0L)); // we want to write a Long
-
-        // flags
-        buf.write(1);// unicode support indicator
-        buf.write(0);
-        buf.write(0);
-        buf.write(0);
-
-        buf.write(longToBytes(1L));// challenge
-        NtlmEngine engine = new NtlmEngine();
-        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-        buf.close();
-        assertEquals(
-                type3Msg,
-                "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
-                "Incorrect type3 message generated");
-    }
-
-    @Test
-    public void testWriteULong() {
-        // test different combinations so that different positions in the byte array will be written
-        byte[] buffer = new byte[4];
-        NtlmEngine.writeULong(buffer, 1, 0);
-        assertEquals(buffer, new byte[] { 1, 0, 0, 0 }, "Unsigned long value 1 was not written correctly to the buffer");
-
-        buffer = new byte[4];
-        NtlmEngine.writeULong(buffer, 257, 0);
-        assertEquals(buffer, new byte[] { 1, 1, 0, 0 }, "Unsigned long value 257 was not written correctly to the buffer");
-
-        buffer = new byte[4];
-        NtlmEngine.writeULong(buffer, 16777216, 0);
-        assertEquals(buffer, new byte[] { 0, 0, 0, 1 }, "Unsigned long value 16777216 was not written correctly to the buffer");
+    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
+            ServletException {
+
+      String authorization = httpRequest.getHeader("Authorization");
+      if (authorization == null) {
+        httpResponse.setStatus(401);
+        httpResponse.setHeader("WWW-Authenticate", "NTLM");
+
+      } else if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
+        httpResponse.setStatus(401);
+        httpResponse.setHeader("WWW-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+
+      } else if (authorization
+              .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
+        httpResponse.setStatus(200);
+      } else {
+        httpResponse.setStatus(401);
+      }
+
+      httpResponse.setContentLength(0);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
index e93f7f9dc..c129856c9 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
@@ -13,9 +13,11 @@
  */
 package org.asynchttpclient.oauth;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.util.Utf8UrlEncoder;
+import org.testng.annotations.Test;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
@@ -25,309 +27,328 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.util.Utf8UrlEncoder;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
+import static org.asynchttpclient.Dsl.get;
+import static org.asynchttpclient.Dsl.post;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 /**
  * Tests the OAuth signature behavior.
- *
+ * <p>
  * See <a href= "https://oauth.googlecode.com/svn/code/javascript/example/signature.html" >Signature Tester</a> for an online oauth signature checker.
- *
  */
 public class OAuthSignatureCalculatorTest {
-    private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
-
-    private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
-
-    public static final String TOKEN_KEY = "nnch734d00sl2jdk";
-
-    public static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
-
-    public static final String NONCE = "kllo9940pd9333jh";
-
-    final static long TIMESTAMP = 1191242096;
-
-    // sample from RFC https://tools.ietf.org/html/rfc5849#section-3.4.1
-    private void testSignatureBaseString(Request request) throws NoSuchAlgorithmException {
-        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
-                .signatureBaseString(//
-                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
-                        new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),//
-                        request,//
-                        137131201,//
-                        "7d8f3e4a").toString();
-
-        assertEquals(signatureBaseString, "POST&" //
-                + "http%3A%2F%2Fexample.com%2Frequest" //
-                + "&a2%3Dr%2520b%26"//
-                + "a3%3D2%2520q%26" + "a3%3Da%26"//
-                + "b5%3D%253D%25253D%26"//
-                + "c%2540%3D%26"//
-                + "c2%3D%26"//
-                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
-                + "oauth_nonce%3D7d8f3e4a%26"//
-                + "oauth_signature_method%3DHMAC-SHA1%26"//
-                + "oauth_timestamp%3D137131201%26"//
-                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
-                + "oauth_version%3D1.0");
-    }
-
-    // fork above test with an OAuth token that requires encoding
-    private void testSignatureBaseStringWithEncodableOAuthToken(Request request) throws NoSuchAlgorithmException {
-        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
-                .signatureBaseString(//
-                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
-                        new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),//
-                        request,//
-                        137131201,//
-                        Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
-
-        assertEquals(signatureBaseString, "POST&" //
-                + "http%3A%2F%2Fexample.com%2Frequest" //
-                + "&a2%3Dr%2520b%26"//
-                + "a3%3D2%2520q%26" + "a3%3Da%26"//
-                + "b5%3D%253D%25253D%26"//
-                + "c%2540%3D%26"//
-                + "c2%3D%26"//
-                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
-                + "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26"//
-                + "oauth_signature_method%3DHMAC-SHA1%26"//
-                + "oauth_timestamp%3D137131201%26"//
-                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
-                + "oauth_version%3D1.0");
-    }
-
-    @Test
-    public void testSignatureBaseStringWithProperlyEncodedUri() throws NoSuchAlgorithmException {
-        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
-                .addFormParam("c2", "")//
-                .addFormParam("a3", "2 q")//
-                .build();
-
-        testSignatureBaseString(request);
-        testSignatureBaseStringWithEncodableOAuthToken(request);
-    }
-
-    @Test
-    public void testSignatureBaseStringWithRawUri() throws NoSuchAlgorithmException {
-        // note: @ is legal so don't decode it into %40 because it won't be
-        // encoded back
-        // note: we don't know how to fix a = that should have been encoded as
-        // %3D but who would be stupid enough to do that?
-        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")//
-                .addFormParam("c2", "")//
-                .addFormParam("a3", "2 q")//
-                .build();
-
-        testSignatureBaseString(request);
-        testSignatureBaseStringWithEncodableOAuthToken(request);
-    }
-
-    // based on the reference test case from
-    // http://oauth.pbwiki.com/TestCases
-    @Test
-    public void testGetCalculateSignature() throws NoSuchAlgorithmException, InvalidKeyException {
-
-        Request request = get("http://photos.example.net/photos")//
-                .addQueryParam("file", "vacation.jpg")//
-                .addQueryParam("size", "original")//
-                .build();
-
-        String signature = new OAuthSignatureCalculatorInstance()//
-                .calculateSignature(new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
-                        new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
-                        request,//
-                        TIMESTAMP,//
-                        NONCE);
-
-        assertEquals(signature, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-    }
-
-    @Test
-    public void testPostCalculateSignature() throws UnsupportedEncodingException {
-        StaticOAuthSignatureCalculator calc = //
-        new StaticOAuthSignatureCalculator(//
-                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
-                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
-                NONCE,//
-                TIMESTAMP);
-
-        final Request req = post("http://photos.example.net/photos")//
-                .addFormParam("file", "vacation.jpg")//
-                .addFormParam("size", "original")//
-                .setSignatureCalculator(calc)//
-                .build();
-
-        // From the signature tester, POST should look like:
-        // normalized parameters:
-        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-        // signature base string:
-        // POST&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-        // signature: wPkvxykrw+BTdCcGqKr+3I+PsiM=
-        // header: OAuth
-        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
-
-        String authHeader = req.getHeaders().get(AUTHORIZATION);
-        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-        assertEquals(m.find(), true);
-        String encodedSig = m.group(1);
-        String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-        assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
-    }
-
-    @Test
-    public void testGetWithRequestBuilder() throws UnsupportedEncodingException {
-        StaticOAuthSignatureCalculator calc = //
-        new StaticOAuthSignatureCalculator(//
-                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
-                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
-                NONCE,//
-                TIMESTAMP);
-
-        final Request req = get("http://photos.example.net/photos")//
-                .addQueryParam("file", "vacation.jpg")//
-                .addQueryParam("size", "original")//
-                .setSignatureCalculator(calc)//
-                .build();
-
-        final List<Param> params = req.getQueryParams();
-        assertEquals(params.size(), 2);
-
-        // From the signature tester, the URL should look like:
-        // normalized parameters:
-        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-        // signature base string:
-        // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-        // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
-        // Authorization header: OAuth
-        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
-
-        String authHeader = req.getHeaders().get(AUTHORIZATION);
-        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-        assertEquals(m.find(), true);
-        String encodedSig = m.group(1);
-        String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
-    }
-
-    @Test
-    public void testGetWithRequestBuilderAndQuery() throws UnsupportedEncodingException {
-        StaticOAuthSignatureCalculator calc = //
-        new StaticOAuthSignatureCalculator(//
-                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
-                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
-                NONCE,//
-                TIMESTAMP);
-
-        final Request req = get("http://photos.example.net/photos?file=vacation.jpg&size=original")//
-                .setSignatureCalculator(calc)//
-                .build();
-
-        final List<Param> params = req.getQueryParams();
-        assertEquals(params.size(), 2);
-
-        // From the signature tester, the URL should look like:
-        // normalized parameters:
-        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-        // signature base string:
-        // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-        // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
-        // Authorization header: OAuth
-        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
-
-        String authHeader = req.getHeaders().get(AUTHORIZATION);
-        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-        assertTrue(m.find());
-        String encodedSig = m.group(1);
-        String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
-        assertEquals(
-                authHeader,
-                "OAuth oauth_consumer_key=\"dpf43f3p2l4k3l03\", oauth_token=\"nnch734d00sl2jdk\", oauth_signature_method=\"HMAC-SHA1\", oauth_signature=\"tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D\", oauth_timestamp=\"1191242096\", oauth_nonce=\"kllo9940pd9333jh\", oauth_version=\"1.0\"");
-    }
-
-    @Test
-    public void testWithNullRequestToken() throws NoSuchAlgorithmException {
-
-        final Request request = get("http://photos.example.net/photos?file=vacation.jpg&size=original").build();
-
-        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
-                .signatureBaseString(//
-                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
-                        new RequestToken(null, null),//
-                        request,//
-                        137131201,//
-                        Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
-
-        assertEquals(signatureBaseString, "GET&" + //
-                "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" + //
-                "oauth_consumer_key%3D9djdj82h48djs9d2%26" + //
-                "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26" + //
-                "oauth_signature_method%3DHMAC-SHA1%26" + //
-                "oauth_timestamp%3D137131201%26" + //
-                "oauth_version%3D1.0%26size%3Doriginal");
-    }
-
-    @Test
-    public void testWithStarQueryParameterValue() throws NoSuchAlgorithmException {
-        final Request request = get("http://term.ie/oauth/example/request_token.php?testvalue=*").build();
-
-        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
-                .signatureBaseString(//
-                        new ConsumerKey("key", "secret"),//
-                        new RequestToken(null, null),//
-                        request,//
-                        1469019732,//
-                        "6ad17f97334700f3ec2df0631d5b7511").toString();
-
-        assertEquals(signatureBaseString, "GET&" + //
-                "http%3A%2F%2Fterm.ie%2Foauth%2Fexample%2Frequest_token.php&"//
-                + "oauth_consumer_key%3Dkey%26"//
-                + "oauth_nonce%3D6ad17f97334700f3ec2df0631d5b7511%26"//
-                + "oauth_signature_method%3DHMAC-SHA1%26"//
-                + "oauth_timestamp%3D1469019732%26"//
-                + "oauth_version%3D1.0%26"//
-                + "testvalue%3D%252A");
-    }
-
-    @Test
-    public void testSignatureGenerationWithAsteriskInPath() throws InvalidKeyException, NoSuchAlgorithmException {
-        ConsumerKey consumerKey = new ConsumerKey("key", "secret");
-        RequestToken requestToken = new RequestToken(null, null);
-        String nonce = "6ad17f97334700f3ec2df0631d5b7511";
-        long timestamp = 1469019732;
-
-        final Request request = get("http://example.com/oauth/example/*path/wi*th/asterisks*").build();
-
-        String expectedSignature = "cswi/v3ZqhVkTyy5MGqW841BxDA=";
-        String actualSignature = new OAuthSignatureCalculatorInstance().calculateSignature(consumerKey, requestToken, request, timestamp, nonce);
-        assertEquals(actualSignature, expectedSignature);
-
-        String generatedAuthHeader = new OAuthSignatureCalculatorInstance().constructAuthHeader(consumerKey, requestToken, actualSignature, timestamp, nonce);
-        assertTrue(generatedAuthHeader.contains("oauth_signature=\"cswi%2Fv3ZqhVkTyy5MGqW841BxDA%3D\""));
-    }
-
-    @Test
-    public void testPercentEncodeKeyValues() throws NoSuchAlgorithmException {
-        // see https://github.com/AsyncHttpClient/async-http-client/issues/1415
-        String keyValue = "\u3b05\u000c\u375b";
-
-        ConsumerKey consumer = new ConsumerKey(keyValue, "secret");
-        RequestToken reqToken = new RequestToken(keyValue, "secret");
-        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, reqToken);
-
-        RequestBuilder reqBuilder = new RequestBuilder()
-                .setUrl("https://api.dropbox.com/1/oauth/access_token?oauth_token=%EC%AD%AE%E3%AC%82%EC%BE%B8%E7%9C%9A%E8%BD%BD%E1%94%A5%E8%AD%AF%E8%98%93%E0%B9%99%E5%9E%96%EF%92%A2%EA%BC%97%EA%90%B0%E4%8A%91%E8%97%BF%EF%A8%BB%E5%B5%B1%DA%98%E2%90%87%E2%96%96%EE%B5%B5%E7%B9%AD%E9%AD%87%E3%BE%93%E5%AF%92%EE%BC%8F%E3%A0%B2%E8%A9%AB%E1%8B%97%EC%BF%80%EA%8F%AE%ED%87%B0%E5%97%B7%E9%97%BF%E8%BF%87%E6%81%A3%E5%BB%A1%EC%86%92%E8%92%81%E2%B9%94%EB%B6%86%E9%AE%8A%E6%94%B0%EE%AC%B5%E6%A0%99%EB%8B%AD%EB%BA%81%E7%89%9F%E5%B3%B7%EA%9D%B7%EC%A4%9C%E0%BC%BA%EB%BB%B9%ED%84%A9%E8%A5%B9%E8%AF%A0%E3%AC%85%0C%E3%9D%9B%E8%B9%8B%E6%BF%8C%EB%91%98%E7%8B%B3%E7%BB%A8%E2%A7%BB%E6%A3%84%E1%AB%B2%E8%8D%93%E4%BF%98%E9%B9%B9%EF%9A%8B%E8%A5%93");
-        Request req = reqBuilder.build();
-
-        calc.calculateAndAddSignature(req, reqBuilder);
-    }
+  private static final String TOKEN_KEY = "nnch734d00sl2jdk";
+  private static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
+  private static final String NONCE = "kllo9940pd9333jh";
+  private static final long TIMESTAMP = 1191242096;
+  private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
+  private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
+
+  // sample from RFC https://tools.ietf.org/html/rfc5849#section-3.4.1
+  private void testSignatureBaseString(Request request) throws NoSuchAlgorithmException {
+    String signatureBaseString = new OAuthSignatureCalculatorInstance()
+            .signatureBaseString(//
+                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
+                    new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),
+                    request.getUri(),
+                    request.getMethod(),
+                    request.getFormParams(),
+                    request.getQueryParams(),
+                    137131201,
+                    "7d8f3e4a").toString();
+
+    assertEquals(signatureBaseString, "POST&"
+            + "http%3A%2F%2Fexample.com%2Frequest"
+            + "&a2%3Dr%2520b%26"
+            + "a3%3D2%2520q%26"
+            + "a3%3Da%26"
+            + "b5%3D%253D%25253D%26"
+            + "c%2540%3D%26"
+            + "c2%3D%26"
+            + "oauth_consumer_key%3D9djdj82h48djs9d2%26"
+            + "oauth_nonce%3D7d8f3e4a%26"
+            + "oauth_signature_method%3DHMAC-SHA1%26"
+            + "oauth_timestamp%3D137131201%26"
+            + "oauth_token%3Dkkk9d7dh3k39sjv7%26"
+            + "oauth_version%3D1.0");
+  }
+
+  // fork above test with an OAuth token that requires encoding
+  private void testSignatureBaseStringWithEncodableOAuthToken(Request request) throws NoSuchAlgorithmException {
+    String signatureBaseString = new OAuthSignatureCalculatorInstance()
+            .signatureBaseString(//
+                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
+                    new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),
+                    request.getUri(),
+                    request.getMethod(),
+                    request.getFormParams(),
+                    request.getQueryParams(),
+                    137131201,
+                    Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
+
+    assertEquals(signatureBaseString, "POST&"
+            + "http%3A%2F%2Fexample.com%2Frequest"
+            + "&a2%3Dr%2520b%26"
+            + "a3%3D2%2520q%26"
+            + "a3%3Da%26"
+            + "b5%3D%253D%25253D%26"
+            + "c%2540%3D%26"
+            + "c2%3D%26"
+            + "oauth_consumer_key%3D9djdj82h48djs9d2%26"
+            + "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26"
+            + "oauth_signature_method%3DHMAC-SHA1%26"
+            + "oauth_timestamp%3D137131201%26"
+            + "oauth_token%3Dkkk9d7dh3k39sjv7%26"
+            + "oauth_version%3D1.0");
+  }
+
+  @Test
+  public void testSignatureBaseStringWithProperlyEncodedUri() throws NoSuchAlgorithmException {
+    Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")
+            .addFormParam("c2", "")
+            .addFormParam("a3", "2 q")
+            .build();
+
+    testSignatureBaseString(request);
+    testSignatureBaseStringWithEncodableOAuthToken(request);
+  }
+
+  @Test
+  public void testSignatureBaseStringWithRawUri() throws NoSuchAlgorithmException {
+    // note: @ is legal so don't decode it into %40 because it won't be
+    // encoded back
+    // note: we don't know how to fix a = that should have been encoded as
+    // %3D but who would be stupid enough to do that?
+    Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")
+            .addFormParam("c2", "")
+            .addFormParam("a3", "2 q")
+            .build();
+
+    testSignatureBaseString(request);
+    testSignatureBaseStringWithEncodableOAuthToken(request);
+  }
+
+  // based on the reference test case from
+  // http://oauth.pbwiki.com/TestCases
+  @Test
+  public void testGetCalculateSignature() throws NoSuchAlgorithmException, InvalidKeyException {
+
+    Request request = get("http://photos.example.net/photos")
+            .addQueryParam("file", "vacation.jpg")
+            .addQueryParam("size", "original")
+            .build();
+
+    String signature = new OAuthSignatureCalculatorInstance()
+            .computeSignature(new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
+                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
+                    request.getUri(),
+                    request.getMethod(),
+                    request.getFormParams(),
+                    request.getQueryParams(),
+                    TIMESTAMP,
+                    NONCE);
+
+    assertEquals(signature, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+  }
+
+  @Test
+  public void testPostCalculateSignature() throws UnsupportedEncodingException {
+    StaticOAuthSignatureCalculator calc = //
+            new StaticOAuthSignatureCalculator(//
+                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
+                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
+                    NONCE,
+                    TIMESTAMP);
+
+    final Request req = post("http://photos.example.net/photos")
+            .addFormParam("file", "vacation.jpg")
+            .addFormParam("size", "original")
+            .setSignatureCalculator(calc)
+            .build();
+
+    // From the signature tester, POST should look like:
+    // normalized parameters:
+    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+    // signature base string:
+    // POST&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+    // signature: wPkvxykrw+BTdCcGqKr+3I+PsiM=
+    // header: OAuth
+    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
+
+    String authHeader = req.getHeaders().get(AUTHORIZATION);
+    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+    assertEquals(m.find(), true);
+    String encodedSig = m.group(1);
+    String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+    assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
+  }
+
+  @Test
+  public void testGetWithRequestBuilder() throws UnsupportedEncodingException {
+    StaticOAuthSignatureCalculator calc =
+            new StaticOAuthSignatureCalculator(
+                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
+                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
+                    NONCE,
+                    TIMESTAMP);
+
+    final Request req = get("http://photos.example.net/photos")
+            .addQueryParam("file", "vacation.jpg")
+            .addQueryParam("size", "original")
+            .setSignatureCalculator(calc)
+            .build();
+
+    final List<Param> params = req.getQueryParams();
+    assertEquals(params.size(), 2);
+
+    // From the signature tester, the URL should look like:
+    // normalized parameters:
+    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+    // signature base string:
+    // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+    // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+    // Authorization header: OAuth
+    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+    String authHeader = req.getHeaders().get(AUTHORIZATION);
+    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+    assertEquals(m.find(), true);
+    String encodedSig = m.group(1);
+    String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+    assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+    assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+  }
+
+  @Test
+  public void testGetWithRequestBuilderAndQuery() throws UnsupportedEncodingException {
+    StaticOAuthSignatureCalculator calc = //
+            new StaticOAuthSignatureCalculator(//
+                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
+                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
+                    NONCE,
+                    TIMESTAMP);
+
+    final Request req = get("http://photos.example.net/photos?file=vacation.jpg&size=original")
+            .setSignatureCalculator(calc)
+            .build();
+
+    final List<Param> params = req.getQueryParams();
+    assertEquals(params.size(), 2);
+
+    // From the signature tester, the URL should look like:
+    // normalized parameters:
+    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+    // signature base string:
+    // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+    // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+    // Authorization header: OAuth
+    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+    String authHeader = req.getHeaders().get(AUTHORIZATION);
+    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+    assertTrue(m.find());
+    String encodedSig = m.group(1);
+    String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+    assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+    assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+    assertEquals(
+            authHeader,
+            "OAuth oauth_consumer_key=\"dpf43f3p2l4k3l03\", oauth_token=\"nnch734d00sl2jdk\", oauth_signature_method=\"HMAC-SHA1\", oauth_signature=\"tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D\", oauth_timestamp=\"1191242096\", oauth_nonce=\"kllo9940pd9333jh\", oauth_version=\"1.0\"");
+  }
+
+  @Test
+  public void testWithNullRequestToken() throws NoSuchAlgorithmException {
+
+    final Request request = get("http://photos.example.net/photos?file=vacation.jpg&size=original").build();
+
+    String signatureBaseString = new OAuthSignatureCalculatorInstance()
+            .signatureBaseString(//
+                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
+                    new RequestToken(null, null),
+                    request.getUri(),
+                    request.getMethod(),
+                    request.getFormParams(),
+                    request.getQueryParams(),
+                    137131201,
+                    Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
+
+    assertEquals(signatureBaseString, "GET&" +
+            "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" +
+            "oauth_consumer_key%3D9djdj82h48djs9d2%26" +
+            "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26" +
+            "oauth_signature_method%3DHMAC-SHA1%26" +
+            "oauth_timestamp%3D137131201%26" +
+            "oauth_version%3D1.0%26size%3Doriginal");
+  }
+
+  @Test
+  public void testWithStarQueryParameterValue() throws NoSuchAlgorithmException {
+    final Request request = get("http://term.ie/oauth/example/request_token.php?testvalue=*").build();
+
+    String signatureBaseString = new OAuthSignatureCalculatorInstance()
+            .signatureBaseString(
+                    new ConsumerKey("key", "secret"),
+                    new RequestToken(null, null),
+                    request.getUri(),
+                    request.getMethod(),
+                    request.getFormParams(),
+                    request.getQueryParams(),
+                    1469019732,
+                    "6ad17f97334700f3ec2df0631d5b7511").toString();
+
+    assertEquals(signatureBaseString, "GET&" +
+            "http%3A%2F%2Fterm.ie%2Foauth%2Fexample%2Frequest_token.php&"
+            + "oauth_consumer_key%3Dkey%26"
+            + "oauth_nonce%3D6ad17f97334700f3ec2df0631d5b7511%26"
+            + "oauth_signature_method%3DHMAC-SHA1%26"
+            + "oauth_timestamp%3D1469019732%26"
+            + "oauth_version%3D1.0%26"
+            + "testvalue%3D%252A");
+  }
+
+  @Test
+  public void testSignatureGenerationWithAsteriskInPath() throws InvalidKeyException, NoSuchAlgorithmException {
+    ConsumerKey consumerKey = new ConsumerKey("key", "secret");
+    RequestToken requestToken = new RequestToken(null, null);
+    String nonce = "6ad17f97334700f3ec2df0631d5b7511";
+    long timestamp = 1469019732;
+
+    final Request request = get("http://example.com/oauth/example/*path/wi*th/asterisks*").build();
+
+    String expectedSignature = "cswi/v3ZqhVkTyy5MGqW841BxDA=";
+    String actualSignature = new OAuthSignatureCalculatorInstance().computeSignature(
+      consumerKey,
+      requestToken,
+      request.getUri(),
+      request.getMethod(),
+      request.getFormParams(),
+      request.getQueryParams(),
+      timestamp,
+      nonce);
+    assertEquals(actualSignature, expectedSignature);
+
+    String generatedAuthHeader = new OAuthSignatureCalculatorInstance().computeAuthorizationHeader(consumerKey, requestToken, actualSignature, timestamp, nonce);
+    assertTrue(generatedAuthHeader.contains("oauth_signature=\"cswi%2Fv3ZqhVkTyy5MGqW841BxDA%3D\""));
+  }
+
+  @Test
+  public void testPercentEncodeKeyValues() {
+    // see https://github.com/AsyncHttpClient/async-http-client/issues/1415
+    String keyValue = "\u3b05\u000c\u375b";
+
+    ConsumerKey consumer = new ConsumerKey(keyValue, "secret");
+    RequestToken reqToken = new RequestToken(keyValue, "secret");
+    OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, reqToken);
+
+    RequestBuilder reqBuilder = new RequestBuilder()
+            .setUrl("https://api.dropbox.com/1/oauth/access_token?oauth_token=%EC%AD%AE%E3%AC%82%EC%BE%B8%E7%9C%9A%E8%BD%BD%E1%94%A5%E8%AD%AF%E8%98%93%E0%B9%99%E5%9E%96%EF%92%A2%EA%BC%97%EA%90%B0%E4%8A%91%E8%97%BF%EF%A8%BB%E5%B5%B1%DA%98%E2%90%87%E2%96%96%EE%B5%B5%E7%B9%AD%E9%AD%87%E3%BE%93%E5%AF%92%EE%BC%8F%E3%A0%B2%E8%A9%AB%E1%8B%97%EC%BF%80%EA%8F%AE%ED%87%B0%E5%97%B7%E9%97%BF%E8%BF%87%E6%81%A3%E5%BB%A1%EC%86%92%E8%92%81%E2%B9%94%EB%B6%86%E9%AE%8A%E6%94%B0%EE%AC%B5%E6%A0%99%EB%8B%AD%EB%BA%81%E7%89%9F%E5%B3%B7%EA%9D%B7%EC%A4%9C%E0%BC%BA%EB%BB%B9%ED%84%A9%E8%A5%B9%E8%AF%A0%E3%AC%85%0C%E3%9D%9B%E8%B9%8B%E6%BF%8C%EB%91%98%E7%8B%B3%E7%BB%A8%E2%A7%BB%E6%A3%84%E1%AB%B2%E8%8D%93%E4%BF%98%E9%B9%B9%EF%9A%8B%E8%A5%93");
+    Request req = reqBuilder.build();
+
+    calc.calculateAndAddSignature(req, reqBuilder);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java b/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
index 726a6bea6..48f9acdba 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
@@ -13,33 +13,43 @@
  */
 package org.asynchttpclient.oauth;
 
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-
+import io.netty.handler.codec.http.HttpHeaderNames;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
 
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
 class StaticOAuthSignatureCalculator implements SignatureCalculator {
 
-    private final ConsumerKey consumerKey;
-    private final RequestToken requestToken;
-    private final String nonce;
-    private final long timestamp;
+  private final ConsumerKey consumerKey;
+  private final RequestToken requestToken;
+  private final String nonce;
+  private final long timestamp;
 
-    public StaticOAuthSignatureCalculator(ConsumerKey consumerKey, RequestToken requestToken, String nonce, long timestamp) {
-        this.consumerKey = consumerKey;
-        this.requestToken = requestToken;
-        this.nonce = nonce;
-        this.timestamp = timestamp;
-    }
+  StaticOAuthSignatureCalculator(ConsumerKey consumerKey, RequestToken requestToken, String nonce, long timestamp) {
+    this.consumerKey = consumerKey;
+    this.requestToken = requestToken;
+    this.nonce = nonce;
+    this.timestamp = timestamp;
+  }
 
-    @Override
-    public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
-        try {
-            new OAuthSignatureCalculatorInstance().sign(consumerKey, requestToken, request, requestBuilder, timestamp, nonce);
-        } catch (InvalidKeyException | NoSuchAlgorithmException e) {
-            throw new IllegalArgumentException(e);
-        }
+  @Override
+  public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
+    try {
+      String authorization = new OAuthSignatureCalculatorInstance().computeAuthorizationHeader(
+        consumerKey,
+        requestToken,
+        request.getUri(),
+        request.getMethod(),
+        request.getFormParams(),
+        request.getQueryParams(),
+        timestamp,
+        nonce);
+      requestBuilder.setHeader(HttpHeaderNames.AUTHORIZATION, authorization);
+    } catch (InvalidKeyException | NoSuchAlgorithmException e) {
+      throw new IllegalArgumentException(e);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
index 07fd4e080..a8a1e8d3d 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
@@ -12,15 +12,8 @@
  */
 package org.asynchttpclient.proxy;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
+import org.asynchttpclient.request.body.generator.ByteArrayBodyGenerator;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
 import org.eclipse.jetty.server.Server;
@@ -30,74 +23,110 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
+import static org.testng.Assert.assertEquals;
+
 /**
  * Proxy usage tests.
  */
 public class HttpsProxyTest extends AbstractBasicTest {
 
-    private Server server2;
-
-    public AbstractHandler configureHandler() throws Exception {
-        return new ConnectHandler();
+  private Server server2;
+
+  public AbstractHandler configureHandler() throws Exception {
+    return new ConnectHandler();
+  }
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(configureHandler());
+    server.start();
+    port1 = connector.getLocalPort();
+
+    server2 = new Server();
+    ServerConnector connector2 = addHttpsConnector(server2);
+    server2.setHandler(new EchoHandler());
+    server2.start();
+    port2 = connector2.getLocalPort();
+
+    logger.info("Local HTTP server started successfully");
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    server.stop();
+    server2.stop();
+  }
+
+  @Test
+  public void testRequestProxy() throws Exception {
+
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true))) {
+      RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
+      Response r = asyncHttpClient.executeRequest(rb.build()).get();
+      assertEquals(r.getStatusCode(), 200);
     }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(configureHandler());
-        server.start();
-        port1 = connector.getLocalPort();
-
-        server2 = new Server();
-        ServerConnector connector2 = addHttpsConnector(server2);
-        server2.setHandler(new EchoHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
-
-        logger.info("Local HTTP server started successfully");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-        server2.stop();
+  }
+
+  @Test
+  public void testConfigProxy() throws Exception {
+    AsyncHttpClientConfig config = config()
+            .setFollowRedirect(true)
+            .setProxyServer(proxyServer("localhost", port1).build())
+            .setUseInsecureTrustManager(true)
+            .build();
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
+      Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
+      assertEquals(r.getStatusCode(), 200);
     }
-
-    @Test(groups = "standalone")
-    public void testRequestProxy() throws Exception {
-
-        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
-            Response r = asyncHttpClient.executeRequest(rb.build()).get();
-            assertEquals(r.getStatusCode(), 200);
-        }
+  }
+
+  @Test
+  public void testNoDirectRequestBodyWithProxy() throws Exception {
+    AsyncHttpClientConfig config = config()
+      .setFollowRedirect(true)
+      .setProxyServer(proxyServer("localhost", port1).build())
+      .setUseInsecureTrustManager(true)
+      .build();
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
+      Response r = asyncHttpClient.executeRequest(post(getTargetUrl2()).setBody(new ByteArrayBodyGenerator(LARGE_IMAGE_BYTES))).get();
+      assertEquals(r.getStatusCode(), 200);
     }
-
-    @Test(groups = "standalone")
-    public void testConfigProxy() throws Exception {
-        AsyncHttpClientConfig config = config()//
-                .setFollowRedirect(true)//
-                .setProxyServer(proxyServer("localhost", port1).build())//
-                .setUseInsecureTrustManager(true)//
-                .build();
-        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
-            Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
-            assertEquals(r.getStatusCode(), 200);
-        }
+  }
+
+  @Test
+  public void testDecompressBodyWithProxy() throws Exception {
+    AsyncHttpClientConfig config = config()
+      .setFollowRedirect(true)
+      .setProxyServer(proxyServer("localhost", port1).build())
+      .setUseInsecureTrustManager(true)
+      .build();
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
+      String body = "hello world";
+      Response r = asyncHttpClient.executeRequest(post(getTargetUrl2())
+        .setHeader("X-COMPRESS", "true")
+        .setBody(body)).get();
+      assertEquals(r.getStatusCode(), 200);
+      assertEquals(r.getResponseBody(), body);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testPooledConnectionsWithProxy() throws Exception {
+  @Test
+  public void testPooledConnectionsWithProxy() throws Exception {
 
-        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true).setKeepAlive(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true).setKeepAlive(true))) {
+      RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
 
-            Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
-            assertEquals(r1.getStatusCode(), 200);
+      Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
+      assertEquals(r1.getStatusCode(), 200);
 
-            Response r2 = asyncHttpClient.executeRequest(rb.build()).get();
-            assertEquals(r2.getStatusCode(), 200);
-        }
+      Response r2 = asyncHttpClient.executeRequest(rb.build()).get();
+      assertEquals(r2.getStatusCode(), 200);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
index 66eb67217..60f361560 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
@@ -13,100 +13,94 @@
  */
 package org.asynchttpclient.proxy;
 
-import static org.asynchttpclient.Dsl.*;
+import org.asynchttpclient.*;
+import org.eclipse.jetty.http.HttpStatus;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.net.UnknownHostException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.http.HttpStatus;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
 
 public class NTLMProxyTest extends AbstractBasicTest {
 
-    public static class NTLMProxyHandler extends AbstractHandler {
-        
-        private AtomicInteger state = new AtomicInteger();
-
-        @Override
-        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
-                ServletException {
-            
-            String authorization = httpRequest.getHeader("Proxy-Authorization");
-
-            boolean asExpected = false;
-            
-            switch (state.getAndIncrement()) {
-                case 0:
-                    if (authorization == null) {
-                        httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
-                        httpResponse.setHeader("Proxy-Authenticate", "NTLM");
-                        asExpected = true;
-                    }
-                    break;
-                    
-                case 1:
-                    if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
-                        httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
-                        httpResponse.setHeader("Proxy-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
-                        asExpected = true;
-                    }
-                    break;
-                    
-                case 2:
-                    if (authorization
-                            .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
-                        httpResponse.setStatus(HttpStatus.OK_200);
-                        asExpected = true;
-                    }
-                    break;
-                
-                default:
-            }
-            
-            if (!asExpected) {
-                httpResponse.setStatus(HttpStatus.FORBIDDEN_403);
-            }
-            httpResponse.setContentLength(0);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new NTLMProxyHandler();
+  }
+
+  @Test
+  public void ntlmProxyTest() throws IOException, InterruptedException, ExecutionException {
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Request request = get("http://localhost").setProxyServer(ntlmProxy()).build();
+      Future<Response> responseFuture = client.executeRequest(request);
+      int status = responseFuture.get().getStatusCode();
+      Assert.assertEquals(status, 200);
     }
+  }
+
+  private ProxyServer ntlmProxy() {
+    Realm realm = ntlmAuthRealm("Zaphod", "Beeblebrox")
+            .setNtlmDomain("Ursa-Minor")
+            .setNtlmHost("LightCity")
+            .build();
+    return proxyServer("localhost", port2).setRealm(realm).build();
+  }
+
+  public static class NTLMProxyHandler extends AbstractHandler {
+
+    private AtomicInteger state = new AtomicInteger();
 
     @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new NTLMProxyHandler();
-    }
+    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
+            ServletException {
 
-    @Test(groups = "standalone")
-    public void ntlmProxyTest() throws IOException, InterruptedException, ExecutionException {
+      String authorization = httpRequest.getHeader("Proxy-Authorization");
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = get("http://localhost").setProxyServer(ntlmProxy()).build();
-            Future<Response> responseFuture = client.executeRequest(request);
-            int status = responseFuture.get().getStatusCode();
-            Assert.assertEquals(status, 200);
-        }
-    }
+      boolean asExpected = false;
+
+      switch (state.getAndIncrement()) {
+        case 0:
+          if (authorization == null) {
+            httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
+            httpResponse.setHeader("Proxy-Authenticate", "NTLM");
+            asExpected = true;
+          }
+          break;
+
+        case 1:
+          if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
+            httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
+            httpResponse.setHeader("Proxy-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+            asExpected = true;
+          }
+          break;
+
+        case 2:
+          if (authorization
+                  .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
+            httpResponse.setStatus(HttpStatus.OK_200);
+            asExpected = true;
+          }
+          break;
+
+        default:
+      }
 
-    private ProxyServer ntlmProxy() throws UnknownHostException {
-        Realm realm = ntlmAuthRealm("Zaphod", "Beeblebrox")//
-                .setNtlmDomain("Ursa-Minor")//
-                .setNtlmHost("LightCity")//
-                .build();
-        return proxyServer("localhost", port2).setRealm(realm).build();
+      if (!asExpected) {
+        httpResponse.setStatus(HttpStatus.FORBIDDEN_403);
+      }
+      httpResponse.setContentLength(0);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index d4a29e87b..0dd33ae20 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -15,17 +15,24 @@
  */
 package org.asynchttpclient.proxy;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
+import org.asynchttpclient.testserver.SocksProxy;
+import org.asynchttpclient.util.ProxyUtils;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
+import java.net.*;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.ExecutionException;
@@ -33,311 +40,318 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
-import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
-import org.asynchttpclient.util.ProxyUtils;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
 /**
  * Proxy usage tests.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class ProxyTest extends AbstractBasicTest {
-    public static class ProxyHandler extends AbstractHandler {
-        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("GET".equalsIgnoreCase(request.getMethod())) {
-                response.addHeader("target", r.getHttpURI().getPath());
-                response.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-            r.setHandled(true);
-        }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new ProxyHandler();
+  }
+
+  @Test
+  public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String target = "http://localhost:1234/";
+      Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ProxyHandler();
+  }
+
+  // @Test
+  // public void asyncDoPostProxyTest() throws Throwable {
+  // try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
+  // HttpHeaders h = new DefaultHttpHeaders();
+  // h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+  // StringBuilder sb = new StringBuilder();
+  // for (int i = 0; i < 5; i++) {
+  // sb.append("param_").append(i).append("=value_").append(i).append("&");
+  // }
+  // sb.setLength(sb.length() - 1);
+  //
+  // Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+  // @Override
+  // public Response onCompleted(Response response) throws Throwable {
+  // return response;
+  // }
+  //
+  // @Override
+  // public void onThrowable(Throwable t) {
+  // }
+  // }).get();
+  //
+  // assertEquals(response.getStatusCode(), 200);
+  // assertEquals(response.getHeader("X-" + CONTENT_TYPE), APPLICATION_X_WWW_FORM_URLENCODED);
+  // }
+  // }
+
+  @Test
+  public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
+      String target = "http://localhost:1234/";
+      Future<Response> f = client.prepareGet(target).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
     }
-
-    // @Test
-    // public void asyncDoPostProxyTest() throws Throwable {
-    // try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
-    // HttpHeaders h = new DefaultHttpHeaders();
-    // h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
-    // StringBuilder sb = new StringBuilder();
-    // for (int i = 0; i < 5; i++) {
-    // sb.append("param_").append(i).append("=value_").append(i).append("&");
-    // }
-    // sb.setLength(sb.length() - 1);
-    //
-    // Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
-    // @Override
-    // public Response onCompleted(Response response) throws Throwable {
-    // return response;
-    // }
-    //
-    // @Override
-    // public void onThrowable(Throwable t) {
-    // }
-    // }).get();
-    //
-    // assertEquals(response.getStatusCode(), 200);
-    // assertEquals(response.getHeader("X-" + CONTENT_TYPE), APPLICATION_X_WWW_FORM_URLENCODED);
-    // }
-    // }
-    
-    @Test(groups = "standalone")
-    public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://localhost:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-        }
+  }
+
+  @Test
+  public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
+      String target = "http://localhost:1234/";
+      Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
-            String target = "http://localhost:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-        }
-    }
+  @Test
+  public void testNonProxyHost() {
 
-    @Test(groups = "standalone")
-    public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
-            String target = "http://localhost:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-        }
+    // // should avoid, it's in non-proxy hosts
+    Request req = get("http://somewhere.com/foo").build();
+    ProxyServer proxyServer = proxyServer("localhost", 1234).setNonProxyHost("somewhere.com").build();
+    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+    //
+    // // should avoid, it's in non-proxy hosts (with "*")
+    req = get("http://sub.somewhere.com/foo").build();
+    proxyServer = proxyServer("localhost", 1234).setNonProxyHost("*.somewhere.com").build();
+    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+
+    // should use it
+    req = get("http://sub.somewhere.com/foo").build();
+    proxyServer = proxyServer("localhost", 1234).setNonProxyHost("*.somewhere.com").build();
+    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+  }
+
+  @Test
+  public void testNonProxyHostsRequestOverridesConfig() {
+
+    ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
+    ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
+      String target = "http://localhost:1234/";
+      client.prepareGet(target).setProxyServer(requestProxy).execute().get();
+      assertFalse(true);
+    } catch (Throwable e) {
+      assertNotNull(e.getCause());
+      assertEquals(e.getCause().getClass(), ConnectException.class);
     }
-
-    @Test(groups = "standalone")
-    public void testNonProxyHost() {
-
-        // // should avoid, it's in non-proxy hosts
-        Request req = get("http://somewhere.com/foo").build();
-        ProxyServer proxyServer = proxyServer("foo", 1234).setNonProxyHost("somewhere.com").build();
-        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
-        //
-        // // should avoid, it's in non-proxy hosts (with "*")
-        req = get("http://sub.somewhere.com/foo").build();
-        proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
-        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
-
-        // should use it
-        req = get("http://sub.somewhere.com/foo").build();
-        proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
-        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+  }
+
+  @Test
+  public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+
+    ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String target = "http://localhost:" + port1 + "/";
+      Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
     }
-
-    @Test(groups = "standalone")
-    public void testNonProxyHostsRequestOverridesConfig() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-
-        ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
-        ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
-            String target = "http://localhost:1234/";
-            client.prepareGet(target).setProxyServer(requestProxy).execute().get();
-            assertFalse(true);
-        } catch (Throwable e) {
-            assertNotNull(e.getCause());
-            assertEquals(e.getCause().getClass(), ConnectException.class);
-        }
+  }
+
+  @Test
+  public void runSequentiallyBecauseNotThreadSafe() throws Exception {
+    testProxyProperties();
+    testIgnoreProxyPropertiesByDefault();
+    testProxyActivationProperty();
+    testWildcardNonProxyHosts();
+    testUseProxySelector();
+  }
+
+  @Test(enabled = false)
+  public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    // FIXME not threadsafe!
+    Properties originalProps = new Properties();
+    originalProps.putAll(System.getProperties());
+    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+    AsyncHttpClientConfigHelper.reloadProperties();
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
+      String proxifiedtarget = "http://127.0.0.1:1234/";
+      Future<Response> f = client.prepareGet(proxifiedtarget).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
+
+      String nonProxifiedtarget = "http://localhost:1234/";
+      f = client.prepareGet(nonProxifiedtarget).execute();
+      try {
+        f.get(3, TimeUnit.SECONDS);
+        fail("should not be able to connect");
+      } catch (ExecutionException e) {
+        // ok, no proxy used
+      }
+    } finally {
+      System.setProperties(originalProps);
     }
-
-    @Test(groups = "standalone")
-    public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-
-        ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://localhost:" + port1 + "/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-        }
+  }
+
+  @Test(enabled = false)
+  public void testIgnoreProxyPropertiesByDefault() throws IOException, TimeoutException, InterruptedException {
+    // FIXME not threadsafe!
+    Properties originalProps = new Properties();
+    originalProps.putAll(System.getProperties());
+    System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
+    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+    AsyncHttpClientConfigHelper.reloadProperties();
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String target = "http://localhost:1234/";
+      Future<Response> f = client.prepareGet(target).execute();
+      try {
+        f.get(3, TimeUnit.SECONDS);
+        fail("should not be able to connect");
+      } catch (ExecutionException e) {
+        // ok, no proxy used
+      }
+    } finally {
+      System.setProperties(originalProps);
     }
-
-    @Test(groups = "standalone")
-    public void runSequentiallyBecauseNotThreadSafe() throws Exception {
-        testProxyProperties();
-        testIgnoreProxyPropertiesByDefault();
-        testProxyActivationProperty();
-        testWildcardNonProxyHosts();
-        testUseProxySelector();
-    }
-
-    // @Test(groups = "standalone")
-    public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        // FIXME not threadsafe!
-        Properties originalProps = new Properties();
-        originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-        AsyncHttpClientConfigHelper.reloadProperties();
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String proxifiedtarget = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(proxifiedtarget).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            String nonProxifiedtarget = "http://localhost:1234/";
-            f = client.prepareGet(nonProxifiedtarget).execute();
-            try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
-            }
-        } finally {
-            System.setProperties(originalProps);
-        }
+  }
+
+  @Test(enabled = false)
+  public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    // FIXME not threadsafe!
+    Properties originalProps = new Properties();
+    originalProps.putAll(System.getProperties());
+    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+    System.setProperty(AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties", "true");
+    AsyncHttpClientConfigHelper.reloadProperties();
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String proxifiedTarget = "http://127.0.0.1:1234/";
+      Future<Response> f = client.prepareGet(proxifiedTarget).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
+
+      String nonProxifiedTarget = "http://localhost:1234/";
+      f = client.prepareGet(nonProxifiedTarget).execute();
+      try {
+        f.get(3, TimeUnit.SECONDS);
+        fail("should not be able to connect");
+      } catch (ExecutionException e) {
+        // ok, no proxy used
+      }
+    } finally {
+      System.setProperties(originalProps);
     }
-
-    // @Test(groups = "standalone")
-    public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        // FIXME not threadsafe!
-        Properties originalProps = new Properties();
-        originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
-        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-        AsyncHttpClientConfigHelper.reloadProperties();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://localhost:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            try {
-                f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
-            }
-        } finally {
-            System.setProperties(originalProps);
-        }
+  }
+
+  @Test(enabled = false)
+  public void testWildcardNonProxyHosts() throws IOException, TimeoutException, InterruptedException {
+    // FIXME not threadsafe!
+    Properties originalProps = new Properties();
+    originalProps.putAll(System.getProperties());
+    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "127.*");
+    AsyncHttpClientConfigHelper.reloadProperties();
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
+      String nonProxifiedTarget = "http://127.0.0.1:1234/";
+      Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
+      try {
+        f.get(3, TimeUnit.SECONDS);
+        fail("should not be able to connect");
+      } catch (ExecutionException e) {
+        // ok, no proxy used
+      }
+    } finally {
+      System.setProperties(originalProps);
     }
-
-    @Test(groups = "standalone", enabled = false)
-    public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        // FIXME not threadsafe!
-        Properties originalProps = new Properties();
-        originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-        System.setProperty(AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties", "true");
-        AsyncHttpClientConfigHelper.reloadProperties();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            String proxifiedTarget = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            String nonProxifiedTarget = "http://localhost:1234/";
-            f = client.prepareGet(nonProxifiedTarget).execute();
-            try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
-            }
-        } finally {
-            System.setProperties(originalProps);
+  }
+
+  @Test(enabled = false)
+  public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+    ProxySelector originalProxySelector = ProxySelector.getDefault();
+    ProxySelector.setDefault(new ProxySelector() {
+      public List<Proxy> select(URI uri) {
+        if (uri.getHost().equals("127.0.0.1")) {
+          return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", port1)));
+        } else {
+          return Collections.singletonList(Proxy.NO_PROXY);
         }
+      }
+
+      public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+      }
+    });
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
+      String proxifiedTarget = "http://127.0.0.1:1234/";
+      Future<Response> f = client.prepareGet(proxifiedTarget).execute();
+      Response resp = f.get(3, TimeUnit.SECONDS);
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("target"), "/");
+
+      String nonProxifiedTarget = "http://localhost:1234/";
+      f = client.prepareGet(nonProxifiedTarget).execute();
+      try {
+        f.get(3, TimeUnit.SECONDS);
+        fail("should not be able to connect");
+      } catch (ExecutionException e) {
+        // ok, no proxy used
+      }
+    } finally {
+      // FIXME not threadsafe
+      ProxySelector.setDefault(originalProxySelector);
     }
-
-    // @Test(groups = "standalone")
-    public void testWildcardNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        // FIXME not threadsafe!
-        Properties originalProps = new Properties();
-        originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "127.*");
-        AsyncHttpClientConfigHelper.reloadProperties();
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String nonProxifiedTarget = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
-            try {
-                f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
-            }
-        } finally {
-            System.setProperties(originalProps);
-        }
+  }
+
+  @Test
+  public void runSocksProxy() throws Exception {
+    new Thread(() -> {
+      try {
+        new SocksProxy(60000);
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }).start();
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      String target = "http://localhost:" + port1 + "/";
+      Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer.Builder("localhost", 8000).setProxyType(ProxyType.SOCKS_V4)).execute();
+
+      assertEquals(200, f.get(60, TimeUnit.SECONDS).getStatusCode());
     }
-
-    // @Test(groups = "standalone")
-    public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        ProxySelector originalProxySelector = ProxySelector.getDefault();
-        ProxySelector.setDefault(new ProxySelector() {
-            public List<Proxy> select(URI uri) {
-                if (uri.getHost().equals("127.0.0.1")) {
-                    return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", port1)));
-                } else {
-                    return Arrays.asList(Proxy.NO_PROXY);
-                }
-            }
-
-            public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-            }
-        });
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
-            String proxifiedTarget = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            String nonProxifiedTarget = "http://localhost:1234/";
-            f = client.prepareGet(nonProxifiedTarget).execute();
-            try {
-                f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
-            }
-        } finally {
-            // FIXME not threadsafe
-            ProxySelector.setDefault(originalProxySelector);
-        }
+  }
+
+  public static class ProxyHandler extends AbstractHandler {
+    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("GET".equalsIgnoreCase(request.getMethod())) {
+        response.addHeader("target", r.getHttpURI().getPath());
+        response.setStatus(HttpServletResponse.SC_OK);
+      } else {
+        // this handler is to handle POST request
+        response.sendError(HttpServletResponse.SC_FORBIDDEN);
+      }
+      r.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
index cc3626360..860678b35 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
@@ -12,25 +12,11 @@
  */
 package org.asynchttpclient.reactivestreams;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
-import static org.testng.Assert.assertTrue;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-
-import java.lang.reflect.Field;
-import java.net.InetSocketAddress;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.handler.StreamedResponsePublisher;
-import org.asynchttpclient.netty.request.NettyRequest;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleStreamedAsyncHandler;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleSubscriber;
 import org.reactivestreams.Publisher;
@@ -38,150 +24,101 @@
 import org.slf4j.LoggerFactory;
 import org.testng.annotations.Test;
 
-public class FailingReactiveStreamsTest extends AbstractBasicTest {
-
-    @Test(groups = "standalone")
-    public void testRetryingOnFailingStream() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
-            final CountDownLatch streamOnHold = new CountDownLatch(1); // allows us to hold the subscriber from processing further body chunks
-            final CountDownLatch replayingRequest = new CountDownLatch(1); // allows us to block until the request is being replayed ( this is what we want to test here!)
-
-            // a ref to the publisher is needed to get a hold on the channel (if there is a better way, this should be changed)
-            final AtomicReference<StreamedResponsePublisher> publisherRef = new AtomicReference<>(null);
-
-            // executing the request
-            client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
-                    .execute(new ReplayedSimpleAsyncHandler(replayingRequest, new BlockedStreamSubscriber(streamStarted, streamOnHold)) {
-                        @Override
-                        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-                            if (!(publisher instanceof StreamedResponsePublisher)) {
-                                throw new IllegalStateException(String.format("publisher %s is expected to be an instance of %s", publisher, StreamedResponsePublisher.class));
-                            } else if (!publisherRef.compareAndSet(null, (StreamedResponsePublisher) publisher)) {
-                                // abort on retry
-                                return State.ABORT;
-                            }
-                            return super.onStream(publisher);
-                        }
-                    });
-
-            // before proceeding, wait for the subscriber to receive at least one body chunk
-            streamStarted.await();
-            // The stream has started, hence `StreamedAsyncHandler.onStream(publisher)` was called, and `publisherRef` was initialized with the `publisher` passed to `onStream`
-            assertTrue(publisherRef.get() != null, "Expected a not null publisher.");
-
-            // close the channel to emulate a connection crash while the response body chunks were being received.
-            StreamedResponsePublisher publisher = publisherRef.get();
-            final CountDownLatch channelClosed = new CountDownLatch(1);
-
-            getChannel(publisher).close().addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
-                    channelClosed.countDown();
-                }
-            });
-            streamOnHold.countDown(); // the subscriber is set free to process new incoming body chunks.
-            channelClosed.await(); // the channel is confirmed to be closed
-
-            // now we expect a new connection to be created and AHC retry logic to kick-in automatically
-            replayingRequest.await(); // wait until we are notified the request is being replayed
-
-            // Change this if there is a better way of stating the test succeeded
-            assertTrue(true);
-        }
-    }
-
-    private Channel getChannel(StreamedResponsePublisher publisher) throws Exception {
-        Field field = publisher.getClass().getDeclaredField("channel");
-        field.setAccessible(true);
-        return (Channel) field.get(publisher);
-    }
-
-    private static class BlockedStreamSubscriber extends SimpleSubscriber<HttpResponseBodyPart> {
-        private static final Logger LOGGER = LoggerFactory.getLogger(BlockedStreamSubscriber.class);
-        private final CountDownLatch streamStarted;
-        private final CountDownLatch streamOnHold;
-
-        public BlockedStreamSubscriber(CountDownLatch streamStarted, CountDownLatch streamOnHold) {
-            this.streamStarted = streamStarted;
-            this.streamOnHold = streamOnHold;
-        }
-
-        @Override
-        public void onNext(HttpResponseBodyPart t) {
-            streamStarted.countDown();
-            try {
-                streamOnHold.await();
-            } catch (InterruptedException e) {
-                LOGGER.error("`streamOnHold` latch was interrupted", e);
-            }
-            super.onNext(t);
-        }
-    }
-
-    private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler implements AsyncHandlerExtensions {
-        private final CountDownLatch replaying;
-
-        public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-            super(subscriber);
-            this.replaying = replaying;
-        }
+import java.lang.reflect.Field;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 
-        @Override
-        public void onHostnameResolutionAttempt(String name) {
-        }
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.testng.Assert.assertTrue;
 
-        @Override
-        public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-        }
+public class FailingReactiveStreamsTest extends AbstractBasicTest {
 
-        @Override
-        public void onHostnameResolutionFailure(String name, Throwable cause) {
-        }
+  @Test
+  public void testRetryingOnFailingStream() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
+      final CountDownLatch streamOnHold = new CountDownLatch(1); // allows us to hold the subscriber from processing further body chunks
+      final CountDownLatch replayingRequest = new CountDownLatch(1); // allows us to block until the request is being replayed ( this is what we want to test here!)
 
-        @Override
-        public void onTcpConnectAttempt(InetSocketAddress address) {
-        }
+      // a ref to the publisher is needed to get a hold on the channel (if there is a better way, this should be changed)
+      final AtomicReference<StreamedResponsePublisher> publisherRef = new AtomicReference<>(null);
 
-        @Override
-        public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
-        }
+      // executing the request
+      client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
+              .execute(new ReplayedSimpleAsyncHandler(replayingRequest, new BlockedStreamSubscriber(streamStarted, streamOnHold)) {
+                @Override
+                public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+                  if (!(publisher instanceof StreamedResponsePublisher)) {
+                    throw new IllegalStateException(String.format("publisher %s is expected to be an instance of %s", publisher, StreamedResponsePublisher.class));
+                  } else if (!publisherRef.compareAndSet(null, (StreamedResponsePublisher) publisher)) {
+                    // abort on retry
+                    return State.ABORT;
+                  }
+                  return super.onStream(publisher);
+                }
+              });
 
-        @Override
-        public void onTcpConnectFailure(InetSocketAddress address, Throwable cause) {
-        }
+      // before proceeding, wait for the subscriber to receive at least one body chunk
+      streamStarted.await();
+      // The stream has started, hence `StreamedAsyncHandler.onStream(publisher)` was called, and `publisherRef` was initialized with the `publisher` passed to `onStream`
+      assertTrue(publisherRef.get() != null, "Expected a not null publisher.");
 
-        @Override
-        public void onTlsHandshakeAttempt() {
-        }
+      // close the channel to emulate a connection crash while the response body chunks were being received.
+      StreamedResponsePublisher publisher = publisherRef.get();
+      final CountDownLatch channelClosed = new CountDownLatch(1);
 
-        @Override
-        public void onTlsHandshakeSuccess() {
-        }
+      getChannel(publisher).close().addListener(future-> channelClosed.countDown());
+      streamOnHold.countDown(); // the subscriber is set free to process new incoming body chunks.
+      channelClosed.await(); // the channel is confirmed to be closed
 
-        @Override
-        public void onTlsHandshakeFailure(Throwable cause) {
-        }
+      // now we expect a new connection to be created and AHC retry logic to kick-in automatically
+      replayingRequest.await(); // wait until we are notified the request is being replayed
 
-        @Override
-        public void onConnectionPoolAttempt() {
-        }
+      // Change this if there is a better way of stating the test succeeded
+      assertTrue(true);
+    }
+  }
+
+  private Channel getChannel(StreamedResponsePublisher publisher) throws Exception {
+    Field field = publisher.getClass().getDeclaredField("channel");
+    field.setAccessible(true);
+    return (Channel) field.get(publisher);
+  }
+
+  private static class BlockedStreamSubscriber extends SimpleSubscriber<HttpResponseBodyPart> {
+    private static final Logger LOGGER = LoggerFactory.getLogger(BlockedStreamSubscriber.class);
+    private final CountDownLatch streamStarted;
+    private final CountDownLatch streamOnHold;
+
+    BlockedStreamSubscriber(CountDownLatch streamStarted, CountDownLatch streamOnHold) {
+      this.streamStarted = streamStarted;
+      this.streamOnHold = streamOnHold;
+    }
 
-        @Override
-        public void onConnectionPooled(Channel connection) {
-        }
+    @Override
+    public void onNext(HttpResponseBodyPart t) {
+      streamStarted.countDown();
+      try {
+        streamOnHold.await();
+      } catch (InterruptedException e) {
+        LOGGER.error("`streamOnHold` latch was interrupted", e);
+      }
+      super.onNext(t);
+    }
+  }
 
-        @Override
-        public void onConnectionOffer(Channel connection) {
-        }
+  private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler {
+    private final CountDownLatch replaying;
 
-        @Override
-        public void onRequestSend(NettyRequest request) {
-        }
+    ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+      super(subscriber);
+      this.replaying = replaying;
+    }
 
-        @Override
-        public void onRetry() {
-            replaying.countDown();
-        }
+    @Override
+    public void onRetry() {
+      replaying.countDown();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
index 1a10e2896..47ee73f3c 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
@@ -22,38 +22,37 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.util.concurrent.Future;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public final class HttpStaticFileServer {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(HttpStaticFileServer.class);
-
-    static private EventLoopGroup bossGroup;
-    static private EventLoopGroup workerGroup;
-
-    public static void start(int port) throws Exception {
-        bossGroup = new NioEventLoopGroup(1);
-        workerGroup = new NioEventLoopGroup();
-        ServerBootstrap b = new ServerBootstrap();
-        b.group(bossGroup, workerGroup)//
-                .channel(NioServerSocketChannel.class)//
-                .handler(new LoggingHandler(LogLevel.INFO))//
-                .childHandler(new HttpStaticFileServerInitializer());
-
-        b.bind(port).sync().channel();
-        LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
-    }
-
-    public static void shutdown() {
-        Future<?> bossFuture = bossGroup.shutdownGracefully();
-        Future<?> workerFuture = workerGroup.shutdownGracefully();
-        try {
-            bossFuture.await();
-            workerFuture.await();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
+  private static final Logger LOGGER = LoggerFactory.getLogger(HttpStaticFileServer.class);
+
+  static private EventLoopGroup bossGroup;
+  static private EventLoopGroup workerGroup;
+
+  public static void start(int port) throws Exception {
+    bossGroup = new NioEventLoopGroup(1);
+    workerGroup = new NioEventLoopGroup();
+    ServerBootstrap b = new ServerBootstrap();
+    b.group(bossGroup, workerGroup)
+            .channel(NioServerSocketChannel.class)
+            .handler(new LoggingHandler(LogLevel.INFO))
+            .childHandler(new HttpStaticFileServerInitializer());
+
+    b.bind(port).sync().channel();
+    LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
+  }
+
+  public static void shutdown() {
+    Future<?> bossFuture = bossGroup.shutdownGracefully();
+    Future<?> workerFuture = workerGroup.shutdownGracefully();
+    try {
+      bossFuture.await();
+      workerFuture.await();
+    } catch (InterruptedException e) {
+      e.printStackTrace();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
index 3f8cbde6c..4e930b191 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
@@ -15,49 +15,29 @@
  */
 package org.asynchttpclient.reactivestreams;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpMethod.GET;
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelProgressiveFuture;
-import io.netty.channel.ChannelProgressiveFutureListener;
-import io.netty.channel.DefaultFileRegion;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.DefaultHttpResponse;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpChunkedInput;
-import io.netty.handler.codec.http.HttpHeaderValues;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpUtil;
-import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.channel.*;
+import io.netty.handler.codec.http.*;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedFile;
 import io.netty.util.CharsetUtil;
+import org.asynchttpclient.test.TestUtils;
 
+import javax.activation.MimetypesFileTypeMap;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.RandomAccessFile;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.Locale;
-import java.util.TimeZone;
+import java.util.*;
 import java.util.regex.Pattern;
 
-import javax.activation.MimetypesFileTypeMap;
-
-import org.asynchttpclient.test.TestUtils;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static io.netty.handler.codec.http.HttpMethod.GET;
+import static io.netty.handler.codec.http.HttpResponseStatus.*;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 
 
 /**
@@ -65,22 +45,22 @@
  * HTTP responses.  It also implements {@code 'If-Modified-Since'} header to
  * take advantage of browser cache, as described in
  * <a href="http://tools.ietf.org/html/rfc2616#section-14.25">RFC 2616</a>.
- *
+ * <p>
  * <h3>How Browser Caching Works</h3>
- *
+ * <p>
  * Web browser caching works with HTTP headers as illustrated by the following
  * sample:
  * <ol>
  * <li>Request #1 returns the content of {@code /file1.txt}.</li>
  * <li>Contents of {@code /file1.txt} is cached by the browser.</li>
  * <li>Request #2 for {@code /file1.txt} does return the contents of the
- *     file again. Rather, a 304 Not Modified is returned. This tells the
- *     browser to use the contents stored in its cache.</li>
+ * file again. Rather, a 304 Not Modified is returned. This tells the
+ * browser to use the contents stored in its cache.</li>
  * <li>The server knows the file has not been modified because the
- *     {@code If-Modified-Since} date is the same as the file's last
- *     modified date.</li>
+ * {@code If-Modified-Since} date is the same as the file's last
+ * modified date.</li>
  * </ol>
- *
+ * <p>
  * <pre>
  * Request #1 Headers
  * ===================
@@ -108,170 +88,46 @@
  */
 public class HttpStaticFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {
 
-    public static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
-    public static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
-    public static final int HTTP_CACHE_SECONDS = 60;
-
-    @Override
-    public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
-        if (!request.decoderResult().isSuccess()) {
-            sendError(ctx, BAD_REQUEST);
-            return;
-        }
-
-        if (request.method() != GET) {
-            sendError(ctx, METHOD_NOT_ALLOWED);
-            return;
-        }
-
-        final String uri = request.uri();
-        final String path = sanitizeUri(uri);
-        if (path == null) {
-            sendError(ctx, FORBIDDEN);
-            return;
-        }
-
-        File file = new File(path);
-        if (file.isHidden() || !file.exists()) {
-            sendError(ctx, NOT_FOUND);
-            return;
-        }
-
-        if (file.isDirectory()) {
-            if (uri.endsWith("/")) {
-                sendListing(ctx, file);
-            } else {
-                sendRedirect(ctx, uri + '/');
-            }
-            return;
-        }
-
-        if (!file.isFile()) {
-            sendError(ctx, FORBIDDEN);
-            return;
-        }
-
-        // Cache Validation
-        String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
-        if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
-            SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
-
-            // Only compare up to the second because the datetime format we send to the client
-            // does not have milliseconds
-            long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
-            long fileLastModifiedSeconds = file.lastModified() / 1000;
-            if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
-                sendNotModified(ctx);
-                return;
-            }
-        }
-
-        RandomAccessFile raf;
-        try {
-            raf = new RandomAccessFile(file, "r");
-        } catch (FileNotFoundException ignore) {
-            sendError(ctx, NOT_FOUND);
-            return;
-        }
-        long fileLength = raf.length();
-
-        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
-        HttpUtil.setContentLength(response, fileLength);
-        setContentTypeHeader(response, file);
-        setDateAndCacheHeaders(response, file);
-        if (HttpUtil.isKeepAlive(request)) {
-            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
-        }
-
-        // Write the initial line and the header.
-        ctx.write(response);
-
-        // Write the content.
-        ChannelFuture sendFileFuture;
-        ChannelFuture lastContentFuture;
-        if (ctx.pipeline().get(SslHandler.class) == null) {
-            sendFileFuture =
-                    ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
-            // Write the end marker.
-            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
-        } else {
-            sendFileFuture =
-                    ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),
-                            ctx.newProgressivePromise());
-            // HttpChunkedInput will write the end marker (LastHttpContent) for us.
-            lastContentFuture = sendFileFuture;
-        }
-
-        sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
-            @Override
-            public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
-                if (total < 0) { // total unknown
-                    System.err.println(future.channel() + " Transfer progress: " + progress);
-                } else {
-                    System.err.println(future.channel() + " Transfer progress: " + progress + " / " + total);
-                }
-            }
-
-            @Override
-            public void operationComplete(ChannelProgressiveFuture future) {
-                System.err.println(future.channel() + " Transfer complete.");
-            }
-        });
-
-        // Decide whether to close the connection or not.
-        if (!HttpUtil.isKeepAlive(request)) {
-            // Close the connection when the whole content is written out.
-            lastContentFuture.addListener(ChannelFutureListener.CLOSE);
-        }
+  private static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
+  private static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
+  private static final int HTTP_CACHE_SECONDS = 60;
+  private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
+  private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9.]*");
+
+  private static String sanitizeUri(String uri) {
+    // Decode the path.
+    try {
+      uri = URLDecoder.decode(uri, "UTF-8");
+    } catch (UnsupportedEncodingException e) {
+      throw new Error(e);
     }
 
-    @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
-        cause.printStackTrace();
-        if (ctx.channel().isActive()) {
-            sendError(ctx, INTERNAL_SERVER_ERROR);
-        }
+    if (uri.isEmpty() || uri.charAt(0) != '/') {
+      return null;
     }
 
-    private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
-
-    private static String sanitizeUri(String uri) {
-        // Decode the path.
-        try {
-            uri = URLDecoder.decode(uri, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            throw new Error(e);
-        }
-
-        if (uri.isEmpty() || uri.charAt(0) != '/') {
-            return null;
-        }
-
-        // Convert file separators.
-        uri = uri.replace('/', File.separatorChar);
+    // Convert file separators.
+    uri = uri.replace('/', File.separatorChar);
 
-        // Simplistic dumb security check.
-        // You will have to do something serious in the production environment.
-        if (uri.contains(File.separator + '.') ||
+    // Simplistic dumb security check.
+    // You will have to do something serious in the production environment.
+    if (uri.contains(File.separator + '.') ||
             uri.contains('.' + File.separator) ||
             uri.charAt(0) == '.' || uri.charAt(uri.length() - 1) == '.' ||
             INSECURE_URI.matcher(uri).matches()) {
-            return null;
-        }
-
-        // Convert to absolute path.
-        return TestUtils.TMP_DIR + File.separator + uri;
+      return null;
     }
 
-    private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
+    // Convert to absolute path.
+    return TestUtils.TMP_DIR + File.separator + uri;
+  }
 
-    private static void sendListing(ChannelHandlerContext ctx, File dir) {
-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
-        response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
+  private static void sendListing(ChannelHandlerContext ctx, File dir) {
+    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
+    response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
 
-        String dirPath = dir.getPath();
-        StringBuilder buf = new StringBuilder()
+    String dirPath = dir.getPath();
+    StringBuilder buf = new StringBuilder()
             .append("<!DOCTYPE html>\r\n")
             .append("<html><head><title>")
             .append("Listing of: ")
@@ -285,111 +141,227 @@ private static void sendListing(ChannelHandlerContext ctx, File dir) {
             .append("<ul>")
             .append("<li><a href=\"../\">..</a></li>\r\n");
 
-        for (File f: dir.listFiles()) {
-            if (f.isHidden() || !f.canRead()) {
-                continue;
-            }
-
-            String name = f.getName();
-            if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
-                continue;
-            }
-
-            buf.append("<li><a href=\"")
-               .append(name)
-               .append("\">")
-               .append(name)
-               .append("</a></li>\r\n");
-        }
+    for (File f : dir.listFiles()) {
+      if (f.isHidden() || !f.canRead()) {
+        continue;
+      }
+
+      String name = f.getName();
+      if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
+        continue;
+      }
+
+      buf.append("<li><a href=\"")
+              .append(name)
+              .append("\">")
+              .append(name)
+              .append("</a></li>\r\n");
+    }
+
+    buf.append("</ul></body></html>\r\n");
+    ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);
+    response.content().writeBytes(buffer);
+    buffer.release();
+
+    // Close the connection as soon as the error message is sent.
+    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+  }
+
+  private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
+    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
+    response.headers().set(LOCATION, newUri);
+
+    // Close the connection as soon as the error message is sent.
+    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+  }
+
+  private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
+    FullHttpResponse response = new DefaultFullHttpResponse(
+            HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8));
+    response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
+
+    // Close the connection as soon as the error message is sent.
+    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+  }
+
+  /**
+   * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified"
+   *
+   * @param ctx Context
+   */
+  private static void sendNotModified(ChannelHandlerContext ctx) {
+    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED);
+    setDateHeader(response);
+
+    // Close the connection as soon as the error message is sent.
+    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+  }
+
+  /**
+   * Sets the Date header for the HTTP response
+   *
+   * @param response HTTP response
+   */
+  private static void setDateHeader(FullHttpResponse response) {
+    SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+    dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
+
+    Calendar time = new GregorianCalendar();
+    response.headers().set(DATE, dateFormatter.format(time.getTime()));
+  }
+
+  /**
+   * Sets the Date and Cache headers for the HTTP Response
+   *
+   * @param response    HTTP response
+   * @param fileToCache file to extract content type
+   */
+  private static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {
+    SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+    dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
+
+    // Date header
+    Calendar time = new GregorianCalendar();
+    response.headers().set(DATE, dateFormatter.format(time.getTime()));
+
+    // Add cache headers
+    time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);
+    response.headers().set(EXPIRES, dateFormatter.format(time.getTime()));
+    response.headers().set(CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS);
+    response.headers().set(
+            LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));
+  }
+
+  /**
+   * Sets the content type header for the HTTP Response
+   *
+   * @param response HTTP response
+   * @param file     file to extract content type
+   */
+  private static void setContentTypeHeader(HttpResponse response, File file) {
+    MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
+    response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
+  }
+
+  @Override
+  public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
+    if (!request.decoderResult().isSuccess()) {
+      sendError(ctx, BAD_REQUEST);
+      return;
+    }
 
-        buf.append("</ul></body></html>\r\n");
-        ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);
-        response.content().writeBytes(buffer);
-        buffer.release();
+    if (request.method() != GET) {
+      sendError(ctx, METHOD_NOT_ALLOWED);
+      return;
+    }
 
-        // Close the connection as soon as the error message is sent.
-        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+    final String uri = request.uri();
+    final String path = sanitizeUri(uri);
+    if (path == null) {
+      sendError(ctx, FORBIDDEN);
+      return;
     }
 
-    private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
-        response.headers().set(LOCATION, newUri);
+    File file = new File(path);
+    if (file.isHidden() || !file.exists()) {
+      sendError(ctx, NOT_FOUND);
+      return;
+    }
 
-        // Close the connection as soon as the error message is sent.
-        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+    if (file.isDirectory()) {
+      if (uri.endsWith("/")) {
+        sendListing(ctx, file);
+      } else {
+        sendRedirect(ctx, uri + '/');
+      }
+      return;
     }
 
-    private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
-        FullHttpResponse response = new DefaultFullHttpResponse(
-                HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8));
-        response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
+    if (!file.isFile()) {
+      sendError(ctx, FORBIDDEN);
+      return;
+    }
 
-        // Close the connection as soon as the error message is sent.
-        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+    // Cache Validation
+    String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
+    if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
+      SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+      Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
+
+      // Only compare up to the second because the datetime format we send to the client
+      // does not have milliseconds
+      long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
+      long fileLastModifiedSeconds = file.lastModified() / 1000;
+      if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
+        sendNotModified(ctx);
+        return;
+      }
     }
 
-    /**
-     * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified"
-     *
-     * @param ctx
-     *            Context
-     */
-    private static void sendNotModified(ChannelHandlerContext ctx) {
-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED);
-        setDateHeader(response);
-
-        // Close the connection as soon as the error message is sent.
-        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
+    RandomAccessFile raf;
+    try {
+      raf = new RandomAccessFile(file, "r");
+    } catch (FileNotFoundException ignore) {
+      sendError(ctx, NOT_FOUND);
+      return;
+    }
+    long fileLength = raf.length();
+
+    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
+    HttpUtil.setContentLength(response, fileLength);
+    setContentTypeHeader(response, file);
+    setDateAndCacheHeaders(response, file);
+    if (HttpUtil.isKeepAlive(request)) {
+      response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
     }
 
-    /**
-     * Sets the Date header for the HTTP response
-     *
-     * @param response
-     *            HTTP response
-     */
-    private static void setDateHeader(FullHttpResponse response) {
-        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
-
-        Calendar time = new GregorianCalendar();
-        response.headers().set(DATE, dateFormatter.format(time.getTime()));
+    // Write the initial line and the header.
+    ctx.write(response);
+
+    // Write the content.
+    ChannelFuture sendFileFuture;
+    ChannelFuture lastContentFuture;
+    if (ctx.pipeline().get(SslHandler.class) == null) {
+      sendFileFuture =
+              ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
+      // Write the end marker.
+      lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+    } else {
+      sendFileFuture =
+              ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),
+                      ctx.newProgressivePromise());
+      // HttpChunkedInput will write the end marker (LastHttpContent) for us.
+      lastContentFuture = sendFileFuture;
     }
 
-    /**
-     * Sets the Date and Cache headers for the HTTP Response
-     *
-     * @param response
-     *            HTTP response
-     * @param fileToCache
-     *            file to extract content type
-     */
-    private static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {
-        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
-
-        // Date header
-        Calendar time = new GregorianCalendar();
-        response.headers().set(DATE, dateFormatter.format(time.getTime()));
-
-        // Add cache headers
-        time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);
-        response.headers().set(EXPIRES, dateFormatter.format(time.getTime()));
-        response.headers().set(CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS);
-        response.headers().set(
-                LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));
+    sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
+      @Override
+      public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
+        if (total < 0) { // total unknown
+          System.err.println(future.channel() + " Transfer progress: " + progress);
+        } else {
+          System.err.println(future.channel() + " Transfer progress: " + progress + " / " + total);
+        }
+      }
+
+      @Override
+      public void operationComplete(ChannelProgressiveFuture future) {
+        System.err.println(future.channel() + " Transfer complete.");
+      }
+    });
+
+    // Decide whether to close the connection or not.
+    if (!HttpUtil.isKeepAlive(request)) {
+      // Close the connection when the whole content is written out.
+      lastContentFuture.addListener(ChannelFutureListener.CLOSE);
     }
+  }
 
-    /**
-     * Sets the content type header for the HTTP Response
-     *
-     * @param response
-     *            HTTP response
-     * @param file
-     *            file to extract content type
-     */
-    private static void setContentTypeHeader(HttpResponse response, File file) {
-        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
-        response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
+  @Override
+  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+    cause.printStackTrace();
+    if (ctx.channel().isActive()) {
+      sendError(ctx, INTERNAL_SERVER_ERROR);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
index 003cd23a1..f7521811d 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
@@ -24,12 +24,12 @@
 
 public class HttpStaticFileServerInitializer extends ChannelInitializer<SocketChannel> {
 
-    @Override
-    public void initChannel(SocketChannel ch) {
-        ChannelPipeline pipeline = ch.pipeline();
-        pipeline.addLast(new HttpServerCodec());
-        pipeline.addLast(new HttpObjectAggregator(65536));
-        pipeline.addLast(new ChunkedWriteHandler());
-        pipeline.addLast(new HttpStaticFileServerHandler());
-    }
+  @Override
+  public void initChannel(SocketChannel ch) {
+    ChannelPipeline pipeline = ch.pipeline();
+    pipeline.addLast(new HttpServerCodec());
+    pipeline.addLast(new HttpObjectAggregator(65536));
+    pipeline.addLast(new ChunkedWriteHandler());
+    pipeline.addLast(new HttpStaticFileServerHandler());
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index 909ca8115..9a782bfcf 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -13,17 +13,7 @@
  */
 package org.asynchttpclient.reactivestreams;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
@@ -39,145 +29,155 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+
 public class ReactiveStreamsDownLoadTest {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsDownLoadTest.class);
-
-    private int serverPort = 8080;
-    private File largeFile;
-    private File smallFile;
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpBeforeTest() throws Exception {
-        largeFile = TestUtils.createTempFile(15 * 1024);
-        smallFile = TestUtils.createTempFile(20);
-        HttpStaticFileServer.start(serverPort);
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDown() throws Exception {
-        HttpStaticFileServer.shutdown();
-    }
-
-    @Test(groups = "standalone")
-    public void streamedResponseLargeFileTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
-            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
-            byte[] result = future.get().getBytes();
-            assertEquals(result.length, largeFile.length());
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void streamedResponseSmallFileTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
-            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
-            byte[] result = future.get().getBytes();
-            LOGGER.debug("Result file size: " + result.length);
-            assertEquals(result.length, smallFile.length());
-        }
-    }
-
-    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
-        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
-
-        public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<>());
-        }
-
-        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-            this.subscriber = subscriber;
-        }
-
-        @Override
-        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onStream");
-            publisher.subscribe(subscriber);
-            return State.CONTINUE;
-        }
-
-        @Override
-        public void onThrowable(Throwable t) {
-            throw new AssertionError(t);
-        }
-
-        @Override
-        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
-            throw new AssertionError("Should not have received body part");
-        }
-
-        @Override
-        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-            return State.CONTINUE;
-        }
-
-        @Override
-        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-            return State.CONTINUE;
-        }
-
-        @Override
-        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
-            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onSubscribe");
-            return this;
-        }
-
-        public byte[] getBytes() throws Throwable {
-            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
-            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-            for (HttpResponseBodyPart part : bodyParts) {
-                bytes.write(part.getBodyPartBytes());
-            }
-            return bytes.toByteArray();
-        }
-    }
-
-    /**
-     * Simple subscriber that requests and buffers one element at a time.
-     */
-    static protected class SimpleSubscriber<T> implements Subscriber<T> {
-        private volatile Subscription subscription;
-        private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
-        private final CountDownLatch latch = new CountDownLatch(1);
-
-        @Override
-        public void onSubscribe(Subscription subscription) {
-            LOGGER.debug("SimpleSubscriber onSubscribe");
-            this.subscription = subscription;
-            subscription.request(1);
-        }
-
-        @Override
-        public void onNext(T t) {
-            LOGGER.debug("SimpleSubscriber onNext");
-            elements.add(t);
-            subscription.request(1);
-        }
-
-        @Override
-        public void onError(Throwable error) {
-            LOGGER.error("SimpleSubscriber onError");
-            this.error = error;
-            latch.countDown();
-        }
-
-        @Override
-        public void onComplete() {
-            LOGGER.debug("SimpleSubscriber onComplete");
-            latch.countDown();
-        }
-
-        public List<T> getElements() throws Throwable {
-            latch.await();
-            if (error != null) {
-                throw error;
-            } else {
-                return elements;
-            }
-        }
+  private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsDownLoadTest.class);
+
+  private int serverPort = 8080;
+  private File largeFile;
+  private File smallFile;
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpBeforeTest() throws Exception {
+    largeFile = TestUtils.createTempFile(15 * 1024);
+    smallFile = TestUtils.createTempFile(20);
+    HttpStaticFileServer.start(serverPort);
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDown() {
+    HttpStaticFileServer.shutdown();
+  }
+
+  @Test
+  public void streamedResponseLargeFileTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
+      ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
+      byte[] result = future.get().getBytes();
+      assertEquals(result.length, largeFile.length());
+    }
+  }
+
+  @Test
+  public void streamedResponseSmallFileTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
+      ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
+      byte[] result = future.get().getBytes();
+      LOGGER.debug("Result file size: " + result.length);
+      assertEquals(result.length, smallFile.length());
+    }
+  }
+
+  static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
+    private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+
+    SimpleStreamedAsyncHandler() {
+      this(new SimpleSubscriber<>());
+    }
+
+    SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+      this.subscriber = subscriber;
+    }
+
+    @Override
+    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onStream");
+      publisher.subscribe(subscriber);
+      return State.CONTINUE;
+    }
+
+    @Override
+    public void onThrowable(Throwable t) {
+      throw new AssertionError(t);
+    }
+
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
+      throw new AssertionError("Should not have received body part");
+    }
+
+    @Override
+    public State onStatusReceived(HttpResponseStatus responseStatus) {
+      return State.CONTINUE;
+    }
+
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+      return State.CONTINUE;
+    }
+
+    @Override
+    public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onSubscribe");
+      return this;
+    }
+
+    public byte[] getBytes() throws Throwable {
+      List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+      for (HttpResponseBodyPart part : bodyParts) {
+        bytes.write(part.getBodyPartBytes());
+      }
+      return bytes.toByteArray();
+    }
+  }
+
+  /**
+   * Simple subscriber that requests and buffers one element at a time.
+   */
+  static protected class SimpleSubscriber<T> implements Subscriber<T> {
+    private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private volatile Subscription subscription;
+    private volatile Throwable error;
+
+    @Override
+    public void onSubscribe(Subscription subscription) {
+      LOGGER.debug("SimpleSubscriber onSubscribe");
+      this.subscription = subscription;
+      subscription.request(1);
+    }
+
+    @Override
+    public void onNext(T t) {
+      LOGGER.debug("SimpleSubscriber onNext");
+      elements.add(t);
+      subscription.request(1);
+    }
+
+    @Override
+    public void onError(Throwable error) {
+      LOGGER.error("SimpleSubscriber onError");
+      this.error = error;
+      latch.countDown();
+    }
+
+    @Override
+    public void onComplete() {
+      LOGGER.debug("SimpleSubscriber onComplete");
+      latch.countDown();
+    }
+
+    public List<T> getElements() throws Throwable {
+      latch.await();
+      if (error != null) {
+        throw error;
+      } else {
+        return elements;
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index c54b89180..a340f0518 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -12,521 +12,530 @@
  */
 package org.asynchttpclient.reactivestreams;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
-import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.Flowable;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-
-import javax.servlet.AsyncContext;
-import javax.servlet.ReadListener;
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.apache.catalina.Context;
 import org.apache.catalina.Wrapper;
 import org.apache.catalina.startup.Tomcat;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
 import org.asynchttpclient.test.TestUtils;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import org.reactivestreams.example.unicast.AsyncIterablePublisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.AsyncContext;
+import javax.servlet.ReadListener;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_MD5;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES_MD5;
+import static org.testng.Assert.assertEquals;
+
 public class ReactiveStreamsTest {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
-
-    public static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
-        return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
-    }
-
-    private Tomcat tomcat;
-    private int port1;
-
-    @SuppressWarnings("serial")
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-
-        String path = new File(".").getAbsolutePath() + "/target";
-
-        tomcat = new Tomcat();
-        tomcat.setHostname("localhost");
-        tomcat.setPort(0);
-        tomcat.setBaseDir(path);
-        Context ctx = tomcat.addContext("", path);
-
-        Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
-
-            @Override
-            public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
-                LOGGER.debug("Echo received request {} on path {}", httpRequest, httpRequest.getServletContext().getContextPath());
-
-                if (httpRequest.getHeader("X-HEAD") != null) {
-                    httpResponse.setContentLength(1);
-                }
-
-                if (httpRequest.getHeader("X-ISO") != null) {
-                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
-                } else {
-                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                }
-
-                if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
-                    httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-                }
-
-                Enumeration<String> e = httpRequest.getHeaderNames();
-                String headerName;
-                while (e.hasMoreElements()) {
-                    headerName = e.nextElement();
-                    if (headerName.startsWith("LockThread")) {
-                        final int sleepTime = httpRequest.getIntHeader(headerName);
-                        try {
-                            Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
-                        } catch (InterruptedException ex) {
-                        }
-                    }
-
-                    if (headerName.startsWith("X-redirect")) {
-                        httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-                        return;
-                    }
-                    httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
-                }
-
-                String pathInfo = httpRequest.getPathInfo();
-                if (pathInfo != null)
-                    httpResponse.addHeader("X-pathInfo", pathInfo);
-
-                String queryString = httpRequest.getQueryString();
-                if (queryString != null)
-                    httpResponse.addHeader("X-queryString", queryString);
-
-                httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-                Cookie[] cs = httpRequest.getCookies();
-                if (cs != null) {
-                    for (Cookie c : cs) {
-                        httpResponse.addCookie(c);
-                    }
-                }
-
-                Enumeration<String> i = httpRequest.getParameterNames();
-                if (i.hasMoreElements()) {
-                    StringBuilder requestBody = new StringBuilder();
-                    while (i.hasMoreElements()) {
-                        headerName = i.nextElement();
-                        httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
-                        requestBody.append(headerName);
-                        requestBody.append("_");
-                    }
-
-                    if (requestBody.length() > 0) {
-                        String body = requestBody.toString();
-                        httpResponse.getOutputStream().write(body.getBytes());
-                    }
-                }
-
-                final AsyncContext context = httpRequest.startAsync();
-                final ServletInputStream input = httpRequest.getInputStream();
-                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-
-                input.setReadListener(new ReadListener() {
-
-                    byte[] buffer = new byte[5 * 1024];
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        httpResponse.setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
-                        context.complete();
-                    }
-
-                    @Override
-                    public void onDataAvailable() throws IOException {
-                        int len = -1;
-                        while (input.isReady() && (len = input.read(buffer)) != -1) {
-                            baos.write(buffer, 0, len);
-                        }
-                    }
-
-                    @Override
-                    public void onAllDataRead() throws IOException {
-                        byte[] requestBodyBytes = baos.toByteArray();
-                        int total = requestBodyBytes.length;
-
-                        httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
-                        String md5 = TestUtils.md5(requestBodyBytes, 0, total);
-                        httpResponse.addHeader(CONTENT_MD5.toString(), md5);
-
-                        httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
-                        context.complete();
-                    }
-                });
-            }
-        });
-        wrapper.setAsyncSupported(true);
-        ctx.addServletMappingDecoded("/*", "webdav");
-        tomcat.start();
-        port1 = tomcat.getConnector().getLocalPort();
+  private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
+  private Tomcat tomcat;
+  private int port1;
+  private ExecutorService executor;
+    
+  private static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
+    return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
+  }
+  
+  private Publisher<ByteBuf> createAsyncPublisher(final byte[] bytes, final int chunkSize) {
+    return new AsyncIterablePublisher(new ByteBufIterable(bytes, chunkSize), executor);
+  }
+
+  private static byte[] getBytes(List<HttpResponseBodyPart> bodyParts) throws IOException {
+    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+    for (HttpResponseBodyPart part : bodyParts) {
+      bytes.write(part.getBodyPartBytes());
     }
+    return bytes.toByteArray();
+  }
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws InterruptedException, Exception {
-        tomcat.stop();
-    }
+  @SuppressWarnings("serial")
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
 
-    private String getTargetUrl() {
-        return String.format("http://localhost:%d/foo/test", port1);
-    }
+    String path = new File(".").getAbsolutePath() + "/target";
+
+    tomcat = new Tomcat();
+    tomcat.setHostname("localhost");
+    tomcat.setPort(0);
+    tomcat.setBaseDir(path);
+    Context ctx = tomcat.addContext("", path);
+
+    Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
+
+      @Override
+      public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
+              throws IOException {
+        LOGGER.debug("Echo received request {} on path {}", httpRequest,
+                httpRequest.getServletContext().getContextPath());
 
-    @Test(groups = "standalone")
-    public void testStreamingPutImage() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-            Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342)).execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        if (httpRequest.getHeader("X-HEAD") != null) {
+          httpResponse.setContentLength(1);
+        }
+
+        if (httpRequest.getHeader("X-ISO") != null) {
+          httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+        } else {
+          httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
         }
-    }
 
-    @Test(groups = "standalone")
-    public void testConnectionDoesNotGetClosed() throws Exception {
-        // test that we can stream the same request multiple times
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-            String expectedMd5 = TestUtils.md5(LARGE_IMAGE_BYTES);
-            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())//
-                    .setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))//
-                    .setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)//
-                    .setHeader("X-" + CONTENT_MD5, expectedMd5);
-
-            Response response = requestBuilder.execute().get();
-            assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
-
-            byte[] responseBody = response.getResponseBodyAsBytes();
-            responseBody = response.getResponseBodyAsBytes();
-            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-            assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
-            assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
-            assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
-
-            response = requestBuilder.execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            responseBody = response.getResponseBodyAsBytes();
-            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+        if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
+          httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+        }
 
+        Enumeration<String> e = httpRequest.getHeaderNames();
+        String headerName;
+        while (e.hasMoreElements()) {
+          headerName = e.nextElement();
+          if (headerName.startsWith("LockThread")) {
+            final int sleepTime = httpRequest.getIntHeader(headerName);
             try {
-                assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
-                assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
-                assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
-            } catch (AssertionError e) {
-                e.printStackTrace();
-                for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
-                    assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
-                }
-                throw e;
+              Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
+            } catch (InterruptedException ex) {
+              //
             }
+          }
+
+          if (headerName.startsWith("X-redirect")) {
+            httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+            return;
+          }
+          httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
         }
-    }
 
-    public static void main(String[] args) throws Exception {
-        ReactiveStreamsTest test = new ReactiveStreamsTest();
-        test.setUpGlobal();
-        try {
-            for (int i = 0; i < 1000; i++) {
-                test.testConnectionDoesNotGetClosed();
-            }
-        } finally {
-            test.tearDownGlobal();
+        String pathInfo = httpRequest.getPathInfo();
+        if (pathInfo != null)
+          httpResponse.addHeader("X-pathInfo", pathInfo);
+
+        String queryString = httpRequest.getQueryString();
+        if (queryString != null)
+          httpResponse.addHeader("X-queryString", queryString);
+
+        httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+
+        Cookie[] cs = httpRequest.getCookies();
+        if (cs != null) {
+          for (Cookie c : cs) {
+            httpResponse.addCookie(c);
+          }
         }
-    }
 
-    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
-    public void testFailingStream() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-            Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
-            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
+        Enumeration<String> i = httpRequest.getParameterNames();
+        if (i.hasMoreElements()) {
+          StringBuilder requestBody = new StringBuilder();
+          while (i.hasMoreElements()) {
+            headerName = i.nextElement();
+            httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
+            requestBody.append(headerName);
+            requestBody.append("_");
+          }
+
+          if (requestBody.length() > 0) {
+            String body = requestBody.toString();
+            httpResponse.getOutputStream().write(body.getBytes());
+          }
         }
+
+        final AsyncContext context = httpRequest.startAsync();
+        final ServletInputStream input = httpRequest.getInputStream();
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+        input.setReadListener(new ReadListener() {
+
+          byte[] buffer = new byte[5 * 1024];
+
+          @Override
+          public void onError(Throwable t) {
+            t.printStackTrace();
+            httpResponse
+                    .setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
+            context.complete();
+          }
+
+          @Override
+          public void onDataAvailable() throws IOException {
+            int len;
+            while (input.isReady() && (len = input.read(buffer)) != -1) {
+              baos.write(buffer, 0, len);
+            }
+          }
+
+          @Override
+          public void onAllDataRead() throws IOException {
+            byte[] requestBodyBytes = baos.toByteArray();
+            int total = requestBodyBytes.length;
+
+            httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
+            String md5 = TestUtils.md5(requestBodyBytes, 0, total);
+            httpResponse.addHeader(CONTENT_MD5.toString(), md5);
+
+            httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
+            context.complete();
+          }
+        });
+      }
+    });
+    wrapper.setAsyncSupported(true);
+    ctx.addServletMappingDecoded("/*", "webdav");
+    tomcat.start();
+    port1 = tomcat.getConnector().getLocalPort();
+
+    executor = Executors.newSingleThreadExecutor();
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    tomcat.stop();
+    executor.shutdown();
+  }
+
+  private String getTargetUrl() {
+    return String.format("http://localhost:%d/foo/test", port1);
+  }
+
+  @Test
+  public void testStreamingPutImage() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl()).setBody(createAsyncPublisher(LARGE_IMAGE_BYTES, 2342))
+              .execute().get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
     }
+  }
+
+  @Test
+  public void testAsyncStreamingPutImage() throws Exception {
+    // test that streaming works with a publisher that does not invoke onSubscription synchronously from subscribe
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342))
+              .execute().get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+    }
+  }
+    
+  @Test
+  public void testConnectionDoesNotGetClosed() throws Exception {
+    // test that we can stream the same request multiple times
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())
+              .setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))
+              .setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)
+              .setHeader("X-" + CONTENT_MD5, LARGE_IMAGE_BYTES_MD5);
+
+      Response response = requestBuilder.execute().get();
+      assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
+
+      byte[] responseBody = response.getResponseBodyAsBytes();
+      assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
+              LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+      assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+      assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
+      assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
+      assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
+
+      response = requestBuilder.execute().get();
+      assertEquals(response.getStatusCode(), 200);
+      responseBody = response.getResponseBodyAsBytes();
+      assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
+              LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+      assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+
+      try {
+        assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
+        assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
+        assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
+      } catch (AssertionError e) {
+        e.printStackTrace();
+        for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
+          assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
+        }
+        throw e;
+      }
+    }
+  }
 
-    @SuppressWarnings("serial")
-    private class FailedStream extends RuntimeException {
+  @Test(expectedExceptions = ExecutionException.class)
+  public void testFailingStream() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
+      client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void streamedResponseTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
+  @Test
+  public void streamedResponseTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
 
-            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
+      SimpleSubscriber<HttpResponseBodyPart> subscriber = new SimpleSubscriber<>();
+      ListenableFuture<Void> future = c.preparePost(getTargetUrl())
+              .setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
 
-            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+      // block
+      future.get();
+      assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
 
-            // Run it again to check that the pipeline is in a good state
-            future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
+      // Run it again to check that the pipeline is in a good state
+      subscriber = new SimpleSubscriber<>();
+      future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
 
-            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+      future.get();
+      assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
 
-            // Make sure a regular request still works
-            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+      // Make sure a regular request still works
+      assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
 
-        }
     }
+  }
 
-    @Test(groups = "standalone")
-    public void cancelStreamedResponseTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
+  @Test
+  public void cancelStreamedResponseTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
 
-            // Cancel immediately
-            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0)).get();
+      // Cancel immediately
+      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0))
+              .get();
 
-            // Cancel after 1 element
-            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1)).get();
+      // Cancel after 1 element
+      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1))
+              .get();
 
-            // Cancel after 10 elements
-            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10)).get();
+      // Cancel after 10 elements
+      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10))
+              .get();
 
-            // Make sure a regular request works
-            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
-        }
+      // Make sure a regular request works
+      assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
     }
+  }
 
-    static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
-        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+  static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<Void> {
+    private final Subscriber<HttpResponseBodyPart> subscriber;
 
-        public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<>());
-        }
-
-        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-            this.subscriber = subscriber;
-        }
+    SimpleStreamedAsyncHandler(Subscriber<HttpResponseBodyPart> subscriber) {
+      this.subscriber = subscriber;
+    }
 
-        @Override
-        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-            publisher.subscribe(subscriber);
-            return State.CONTINUE;
-        }
+    @Override
+    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+      publisher.subscribe(subscriber);
+      return State.CONTINUE;
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-            throw new AssertionError(t);
-        }
+    @Override
+    public void onThrowable(Throwable t) {
+      throw new AssertionError(t);
+    }
 
-        @Override
-        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            throw new AssertionError("Should not have received body part");
-        }
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
+      throw new AssertionError("Should not have received body part");
+    }
 
-        @Override
-        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public State onStatusReceived(HttpResponseStatus responseStatus) {
+      return State.CONTINUE;
+    }
 
-        @Override
-        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) {
+      return State.CONTINUE;
+    }
 
-        @Override
-        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
-            return this;
-        }
+    @Override
+    public Void onCompleted() {
+      return null;
+    }
+  }
+
+  /**
+   * Simple subscriber that requests and buffers one element at a time.
+   */
+  static class SimpleSubscriber<T> implements Subscriber<T> {
+    private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private volatile Subscription subscription;
+    private volatile Throwable error;
+
+    @Override
+    public void onSubscribe(Subscription subscription) {
+      this.subscription = subscription;
+      subscription.request(1);
+    }
 
-        public byte[] getBytes() throws Throwable {
-            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
-            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-            for (HttpResponseBodyPart part : bodyParts) {
-                bytes.write(part.getBodyPartBytes());
-            }
-            return bytes.toByteArray();
-        }
+    @Override
+    public void onNext(T t) {
+      elements.add(t);
+      subscription.request(1);
     }
 
-    /**
-     * Simple subscriber that requests and buffers one element at a time.
-     */
-    static class SimpleSubscriber<T> implements Subscriber<T> {
-        private volatile Subscription subscription;
-        private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
-        private final CountDownLatch latch = new CountDownLatch(1);
+    @Override
+    public void onError(Throwable error) {
+      this.error = error;
+      latch.countDown();
+    }
 
-        @Override
-        public void onSubscribe(Subscription subscription) {
-            this.subscription = subscription;
-            subscription.request(1);
-        }
+    @Override
+    public void onComplete() {
+      latch.countDown();
+    }
 
-        @Override
-        public void onNext(T t) {
-            elements.add(t);
-            subscription.request(1);
-        }
+    List<T> getElements() throws Throwable {
+      latch.await();
+      if (error != null) {
+        throw error;
+      } else {
+        return elements;
+      }
+    }
+  }
 
-        @Override
-        public void onError(Throwable error) {
-            this.error = error;
-            latch.countDown();
-        }
+  static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
+    private final int cancelAfter;
 
-        @Override
-        public void onComplete() {
-            latch.countDown();
-        }
+    CancellingStreamedAsyncProvider(int cancelAfter) {
+      this.cancelAfter = cancelAfter;
+    }
 
-        public List<T> getElements() throws Throwable {
-            latch.await();
-            if (error != null) {
-                throw error;
-            } else {
-                return elements;
-            }
-        }
+    @Override
+    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+      publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
+      return State.CONTINUE;
     }
 
-    static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
-        private final int cancelAfter;
+    @Override
+    public void onThrowable(Throwable t) {
+      throw new AssertionError(t);
+    }
 
-        public CancellingStreamedAsyncProvider(int cancelAfter) {
-            this.cancelAfter = cancelAfter;
-        }
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
+      throw new AssertionError("Should not have received body part");
+    }
 
-        @Override
-        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-            publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
-            return State.CONTINUE;
-        }
+    @Override
+    public State onStatusReceived(HttpResponseStatus responseStatus) {
+      return State.CONTINUE;
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-            throw new AssertionError(t);
-        }
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) {
+      return State.CONTINUE;
+    }
 
-        @Override
-        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            throw new AssertionError("Should not have received body part");
-        }
+    @Override
+    public CancellingStreamedAsyncProvider onCompleted() {
+      return this;
+    }
+  }
+
+  /**
+   * Simple subscriber that cancels after receiving n elements.
+   */
+  static class CancellingSubscriber<T> implements Subscriber<T> {
+    private final int cancelAfter;
+    private volatile Subscription subscription;
+    private AtomicInteger count = new AtomicInteger(0);
+
+    CancellingSubscriber(int cancelAfter) {
+      this.cancelAfter = cancelAfter;
+    }
 
-        @Override
-        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public void onSubscribe(Subscription subscription) {
+      this.subscription = subscription;
+      if (cancelAfter == 0) {
+        subscription.cancel();
+      } else {
+        subscription.request(1);
+      }
+    }
 
-        @Override
-        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public void onNext(T t) {
+      if (count.incrementAndGet() == cancelAfter) {
+        subscription.cancel();
+      } else {
+        subscription.request(1);
+      }
+    }
 
-        @Override
-        public CancellingStreamedAsyncProvider onCompleted() throws Exception {
-            return this;
-        }
+    @Override
+    public void onError(Throwable error) {
     }
 
-    /**
-     * Simple subscriber that cancels after receiving n elements.
-     */
-    static class CancellingSubscriber<T> implements Subscriber<T> {
-        private final int cancelAfter;
+    @Override
+    public void onComplete() {
+    }
+  }
 
-        public CancellingSubscriber(int cancelAfter) {
-            this.cancelAfter = cancelAfter;
-        }
+  static class ByteBufIterable implements Iterable<ByteBuf> {
+    private final byte[] payload;
+    private final int chunkSize;
 
-        private volatile Subscription subscription;
-        private volatile int count;
+    ByteBufIterable(byte[] payload, int chunkSize) {
+      this.payload = payload;
+      this.chunkSize = chunkSize;
+    }
 
-        @Override
-        public void onSubscribe(Subscription subscription) {
-            this.subscription = subscription;
-            if (cancelAfter == 0) {
-                subscription.cancel();
-            } else {
-                subscription.request(1);
-            }
-        }
+    @Override
+    public Iterator<ByteBuf> iterator() {
+      return new Iterator<ByteBuf>() {
+        private int currentIndex = 0;
 
         @Override
-        public void onNext(T t) {
-            count++;
-            if (count == cancelAfter) {
-                subscription.cancel();
-            } else {
-                subscription.request(1);
-            }
+        public boolean hasNext() {
+          return currentIndex != payload.length;
         }
 
         @Override
-        public void onError(Throwable error) {
+        public ByteBuf next() {
+          int thisCurrentIndex = currentIndex;
+          int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
+          currentIndex += length;
+          return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
         }
 
         @Override
-        public void onComplete() {
+        public void remove() {
+          throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
         }
+      };
     }
+  }
 
-    static class ByteBufIterable implements Iterable<ByteBuf> {
-        private final byte[] payload;
-        private final int chunkSize;
-
-        public ByteBufIterable(byte[] payload, int chunkSize) {
-            this.payload = payload;
-            this.chunkSize = chunkSize;
-        }
-
-        @Override
-        public Iterator<ByteBuf> iterator() {
-            return new Iterator<ByteBuf>() {
-                private int currentIndex = 0;
-
-                @Override
-                public boolean hasNext() {
-                    return currentIndex != payload.length;
-                }
-
-                @Override
-                public ByteBuf next() {
-                    int thisCurrentIndex = currentIndex;
-                    int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
-                    currentIndex += length;
-                    return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
-                }
-
-                @Override
-                public void remove() {
-                    throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
-                }
-            };
-        }
-    }
+  @SuppressWarnings("serial")
+  private class FailedStream extends RuntimeException {
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
index fb0d66933..89b801771 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
@@ -15,44 +15,40 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.*;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
 import java.util.concurrent.Future;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
 
 public class BodyChunkTest extends AbstractBasicTest {
 
-    private static final String MY_MESSAGE = "my message";
+  private static final String MY_MESSAGE = "my message";
 
-    @Test(groups = "standalone")
-    public void negativeContentTypeTest() throws Exception {
+  @Test
+  public void negativeContentTypeTest() throws Exception {
 
-        AsyncHttpClientConfig config = config()//
-                .setConnectTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000) // 5 minutes
-                .build();
+    AsyncHttpClientConfig config = config()
+            .setConnectTimeout(100)
+            .setMaxConnections(50)
+            .setRequestTimeout(5 * 60 * 1000) // 5 minutes
+            .build();
 
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
-            RequestBuilder requestBuilder = post(getTargetUrl())//
-                    .setHeader("Content-Type", "message/rfc822")//
-                    .setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+    try (AsyncHttpClient client = asyncHttpClient(config)) {
+      RequestBuilder requestBuilder = post(getTargetUrl())
+              .setHeader("Content-Type", "message/rfc822")
+              .setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-            Future<Response> future = client.executeRequest(requestBuilder.build());
+      Future<Response> future = client.executeRequest(requestBuilder.build());
 
-            System.out.println("waiting for response");
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBody(), MY_MESSAGE);
-        }
+      System.out.println("waiting for response");
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getResponseBody(), MY_MESSAGE);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
index 648163aaa..538488c2e 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -12,114 +12,108 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-import static org.testng.FileAssert.fail;
 import io.netty.buffer.Unpooled;
+import org.asynchttpclient.*;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
+import org.testng.annotations.Test;
 
 import java.io.BufferedInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.FileAssert.fail;
 
 public class ChunkingTest extends AbstractBasicTest {
 
-    // So we can just test the returned data is the image,
-    // and doesn't contain the chunked delimeters.
-    @Test(groups = "standalone")
-    public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
-        doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath()), 400000));
-    }
+  // So we can just test the returned data is the image,
+  // and doesn't contain the chunked delimeters.
+  @Test
+  public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
+    doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath()), 400000));
+  }
 
-    @Test(groups = "standalone")
-    public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
-        doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath())));
-    }
+  @Test
+  public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
+    doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath())));
+  }
 
-    @Test(groups = "standalone")
-    public void testDirectFileWithStreamBodyGenerator() throws Throwable {
-        doTestWithInputStreamBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
-    }
+  @Test
+  public void testDirectFileWithStreamBodyGenerator() throws Throwable {
+    doTestWithInputStreamBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
+  }
 
-    @Test(groups = "standalone")
-    public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
-        doTestWithFeedableBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
-    }
+  @Test
+  public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
+    doTestWithFeedableBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
+  }
 
-    public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
-        try {
-            try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
-                ListenableFuture<Response> responseFuture = c.executeRequest(post(getTargetUrl()).setBody(new InputStreamBodyGenerator(is)));
-                waitForAndAssertResponse(responseFuture);
-            }
-        } finally {
-            is.close();
-        }
+  private void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
+    try {
+      try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
+        ListenableFuture<Response> responseFuture = c.executeRequest(post(getTargetUrl()).setBody(new InputStreamBodyGenerator(is)));
+        waitForAndAssertResponse(responseFuture);
+      }
+    } finally {
+      is.close();
     }
+  }
 
-    public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
-        try {
-            try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
-                final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-                Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
-                ListenableFuture<Response> responseFuture = c.executeRequest(r);
-                feed(feedableBodyGenerator, is);
-                waitForAndAssertResponse(responseFuture);
-            }
-        } finally {
-            is.close();
-        }
+  private void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
+    try {
+      try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
+        final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+        Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
+        ListenableFuture<Response> responseFuture = c.executeRequest(r);
+        feed(feedableBodyGenerator, is);
+        waitForAndAssertResponse(responseFuture);
+      }
+    } finally {
+      is.close();
     }
+  }
 
-    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
-        try (InputStream inputStream = is) {
-            byte[] buffer = new byte[512];
-            for (int i = 0; (i = inputStream.read(buffer)) > -1;) {
-                byte[] chunk = new byte[i];
-                System.arraycopy(buffer, 0, chunk, 0, i);
-                feedableBodyGenerator.feed(Unpooled.wrappedBuffer(chunk), false);
-            }
-        }
-        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
-
+  private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
+    try (InputStream inputStream = is) {
+      byte[] buffer = new byte[512];
+      for (int i; (i = inputStream.read(buffer)) > -1; ) {
+        byte[] chunk = new byte[i];
+        System.arraycopy(buffer, 0, chunk, 0, i);
+        feedableBodyGenerator.feed(Unpooled.wrappedBuffer(chunk), false);
+      }
     }
+    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
 
-    private DefaultAsyncHttpClientConfig.Builder httpClientBuilder() {
-        return config()//
-                .setKeepAlive(true)//
-                .setMaxConnectionsPerHost(1)//
-                .setMaxConnections(1)//
-                .setConnectTimeout(1000)//
-                .setRequestTimeout(1000)//
-                .setFollowRedirect(true);
-    }
+  }
+
+  private DefaultAsyncHttpClientConfig.Builder httpClientBuilder() {
+    return config()
+            .setKeepAlive(true)
+            .setMaxConnectionsPerHost(1)
+            .setMaxConnections(1)
+            .setConnectTimeout(1000)
+            .setRequestTimeout(1000)
+            .setFollowRedirect(true);
+  }
 
-    private void waitForAndAssertResponse(ListenableFuture<Response> responseFuture) throws InterruptedException, java.util.concurrent.ExecutionException, IOException {
-        Response response = responseFuture.get();
-        if (500 == response.getStatusCode()) {
-            StringBuilder sb = new StringBuilder();
-            sb.append("==============\n");
-            sb.append("500 response from call\n");
-            sb.append("Headers:" + response.getHeaders() + "\n");
-            sb.append("==============\n");
-            logger.debug(sb.toString());
-            assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
-            assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
-            fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
-        } else {
-            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-        }
+  private void waitForAndAssertResponse(ListenableFuture<Response> responseFuture) throws InterruptedException, java.util.concurrent.ExecutionException {
+    Response response = responseFuture.get();
+    if (500 == response.getStatusCode()) {
+      logger.debug("==============\n" +
+              "500 response from call\n" +
+              "Headers:" + response.getHeaders() + "\n" +
+              "==============\n");
+      assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
+      assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
+      fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
+    } else {
+      assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
index 304723cfd..9c2973c8a 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
@@ -15,120 +15,113 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 
 /**
  * Tests case where response doesn't have body.
- * 
+ *
  * @author Hubert Iwaniuk
  */
 public class EmptyBodyTest extends AbstractBasicTest {
-    private class NoBodyResponseHandler extends AbstractHandler {
-        public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new NoBodyResponseHandler();
+  }
 
-            if (!req.getMethod().equalsIgnoreCase("PUT")) {
-                resp.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                resp.setStatus(204);
-            }
-            request.setHandled(true);
+  @Test
+  public void testEmptyBody() throws IOException {
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      final AtomicBoolean err = new AtomicBoolean(false);
+      final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
+      final AtomicBoolean status = new AtomicBoolean(false);
+      final AtomicInteger headers = new AtomicInteger(0);
+      final CountDownLatch latch = new CountDownLatch(1);
+      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+        public void onThrowable(Throwable t) {
+          fail("Got throwable.", t);
+          err.set(true);
         }
-    }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new NoBodyResponseHandler();
-    }
+        public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+          byte[] bytes = e.getBodyPartBytes();
 
-    @Test(groups = "standalone")
-    public void testEmptyBody() throws IOException {
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            final AtomicBoolean err = new AtomicBoolean(false);
-            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
-            final AtomicBoolean status = new AtomicBoolean(false);
-            final AtomicInteger headers = new AtomicInteger(0);
-            final CountDownLatch latch = new CountDownLatch(1);
-            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-                public void onThrowable(Throwable t) {
-                    fail("Got throwable.", t);
-                    err.set(true);
-                }
+          if (bytes.length != 0) {
+            String s = new String(bytes);
+            logger.info("got part: {}", s);
+            logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+            queue.put(s);
+          }
+          return State.CONTINUE;
+        }
 
-                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                    byte[] bytes = e.getBodyPartBytes();
+        public State onStatusReceived(HttpResponseStatus e) {
+          status.set(true);
+          return AsyncHandler.State.CONTINUE;
+        }
 
-                    if (bytes.length != 0) {
-                        String s = new String(bytes);
-                        logger.info("got part: {}", s);
-                        logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
-                        queue.put(s);
-                    }
-                    return State.CONTINUE;
-                }
+        public State onHeadersReceived(HttpHeaders e) throws Exception {
+          if (headers.incrementAndGet() == 2) {
+            throw new Exception("Analyze this.");
+          }
+          return State.CONTINUE;
+        }
 
-                public State onStatusReceived(HttpResponseStatus e) throws Exception {
-                    status.set(true);
-                    return AsyncHandler.State.CONTINUE;
-                }
+        public Object onCompleted() {
+          latch.countDown();
+          return null;
+        }
+      });
+      try {
+        assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+      } catch (InterruptedException e) {
+        fail("Interrupted.", e);
+      }
+      assertFalse(err.get());
+      assertEquals(queue.size(), 0);
+      assertTrue(status.get());
+      assertEquals(headers.get(), 1);
+    }
+  }
 
-                public State onHeadersReceived(HttpHeaders e) throws Exception {
-                    if (headers.incrementAndGet() == 2) {
-                        throw new Exception("Analyze this.");
-                    }
-                    return State.CONTINUE;
-                }
+  @Test
+  public void testPutEmptyBody() throws Exception {
+    try (AsyncHttpClient ahc = asyncHttpClient()) {
+      Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
 
-                public Object onCompleted() throws Exception {
-                    latch.countDown();
-                    return null;
-                }
-            });
-            try {
-                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-            } catch (InterruptedException e) {
-                fail("Interrupted.", e);
-            }
-            assertFalse(err.get());
-            assertEquals(queue.size(), 0);
-            assertTrue(status.get());
-            assertEquals(headers.get(), 1);
-        }
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 204);
+      assertEquals(response.getResponseBody(), "");
+      assertNotNull(response.getResponseBodyAsStream());
+      assertEquals(response.getResponseBodyAsStream().read(), -1);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testPutEmptyBody() throws Exception {
-        try (AsyncHttpClient ahc = asyncHttpClient()) {
-            Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
+  private class NoBodyResponseHandler extends AbstractHandler {
+    public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 204);
-            assertEquals(response.getResponseBody(), "");
-            assertTrue(response.getResponseBodyAsStream() instanceof InputStream);
-            assertEquals(response.getResponseBodyAsStream().read(), -1);
-        }
+      if (!req.getMethod().equalsIgnoreCase("PUT")) {
+        resp.setStatus(HttpServletResponse.SC_OK);
+      } else {
+        resp.setStatus(204);
+      }
+      request.setHandled(true);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
index 0945c2e24..06e33c95a 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
@@ -12,19 +12,6 @@
  */
 package org.asynchttpclient.request.body;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.io.File;
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
@@ -33,48 +20,61 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-public class FilePartLargeFileTest extends AbstractBasicTest {
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.IOException;
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
 
-            public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+public class FilePartLargeFileTest extends AbstractBasicTest {
 
-                ServletInputStream in = req.getInputStream();
-                byte[] b = new byte[8192];
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
 
-                int count = -1;
-                int total = 0;
-                while ((count = in.read(b)) != -1) {
-                    b = new byte[8192];
-                    total += count;
-                }
-                resp.setStatus(200);
-                resp.addHeader("X-TRANFERED", String.valueOf(total));
-                resp.getOutputStream().flush();
-                resp.getOutputStream().close();
+      public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException {
 
-                baseRequest.setHandled(true);
-            }
-        };
-    }
+        ServletInputStream in = req.getInputStream();
+        byte[] b = new byte[8192];
 
-    @Test(groups = "standalone")
-    public void testPutImageFile() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
-            assertEquals(response.getStatusCode(), 200);
+        int count;
+        int total = 0;
+        while ((count = in.read(b)) != -1) {
+          b = new byte[8192];
+          total += count;
         }
+        resp.setStatus(200);
+        resp.addHeader("X-TRANFERED", String.valueOf(total));
+        resp.getOutputStream().flush();
+        resp.getOutputStream().close();
+
+        baseRequest.setHandled(true);
+      }
+    };
+  }
+
+  @Test
+  public void testPutImageFile() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testPutLargeTextFile() throws Exception {
-        File file = createTempFile(1024 * 1024);
+  @Test
+  public void testPutLargeTextFile() throws Exception {
+    File file = createTempFile(1024 * 1024);
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/InputStreamPartLargeFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/InputStreamPartLargeFileTest.java
new file mode 100644
index 000000000..48d45341b
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/request/body/InputStreamPartLargeFileTest.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.multipart.InputStreamPart;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.*;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
+public class InputStreamPartLargeFileTest extends AbstractBasicTest {
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
+
+      public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException {
+
+        ServletInputStream in = req.getInputStream();
+        byte[] b = new byte[8192];
+
+        int count;
+        int total = 0;
+        while ((count = in.read(b)) != -1) {
+          b = new byte[8192];
+          total += count;
+        }
+        resp.setStatus(200);
+        resp.addHeader("X-TRANSFERRED", String.valueOf(total));
+        resp.getOutputStream().flush();
+        resp.getOutputStream().close();
+
+        baseRequest.setHandled(true);
+      }
+    };
+  }
+
+  @Test
+  public void testPutImageFile() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      InputStream inputStream = new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE));
+      Response response = client.preparePut(getTargetUrl()).addBodyPart(new InputStreamPart("test", inputStream, LARGE_IMAGE_FILE.getName(), LARGE_IMAGE_FILE.length(), "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testPutImageFileUnknownSize() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      InputStream inputStream = new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE));
+      Response response = client.preparePut(getTargetUrl()).addBodyPart(new InputStreamPart("test", inputStream, LARGE_IMAGE_FILE.getName(), -1, "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testPutLargeTextFile() throws Exception {
+    File file = createTempFile(1024 * 1024);
+    InputStream inputStream = new BufferedInputStream(new FileInputStream(file));
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl())
+              .addBodyPart(new InputStreamPart("test", inputStream, file.getName(), file.length(), "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testPutLargeTextFileUnknownSize() throws Exception {
+    File file = createTempFile(1024 * 1024);
+    InputStream inputStream = new BufferedInputStream(new FileInputStream(file));
+
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+      Response response = client.preparePut(getTargetUrl())
+              .addBodyPart(new InputStreamPart("test", inputStream, file.getName(), -1, "application/octet-stream", UTF_8)).execute().get();
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
index beff9d762..d7c21b618 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
@@ -15,23 +15,9 @@
  */
 package org.asynchttpclient.request.body;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
@@ -39,70 +25,83 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-public class InputStreamTest extends AbstractBasicTest {
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
 
-    private static class InputStreamHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            if ("POST".equalsIgnoreCase(request.getMethod())) {
-                byte[] bytes = new byte[3];
-                ByteArrayOutputStream bos = new ByteArrayOutputStream();
-                int read = 0;
-                while (read > -1) {
-                    read = request.getInputStream().read(bytes);
-                    if (read > 0) {
-                        bos.write(bytes, 0, read);
-                    }
-                }
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
-                response.setStatus(HttpServletResponse.SC_OK);
-                response.addHeader("X-Param", new String(bos.toByteArray()));
-            } else { // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-            response.getOutputStream().flush();
-            response.getOutputStream().close();
-        }
-    }
+public class InputStreamTest extends AbstractBasicTest {
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new InputStreamHandler();
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new InputStreamHandler();
+  }
 
-    @Test(groups = "standalone")
-    public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+  @Test
+  public void testInvalidInputStream() throws IOException, ExecutionException, InterruptedException {
 
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders().add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      HttpHeaders h = new DefaultHttpHeaders().add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
 
-            InputStream is = new InputStream() {
+      InputStream is = new InputStream() {
 
-                public int readAllowed;
+        int readAllowed;
 
-                @Override
-                public int available() {
-                    return 1; // Fake
-                }
+        @Override
+        public int available() {
+          return 1; // Fake
+        }
 
-                @Override
-                public int read() throws IOException {
-                    int fakeCount = readAllowed++;
-                    if (fakeCount == 0) {
-                        return (int) 'a';
-                    } else if (fakeCount == 1) {
-                        return (int) 'b';
-                    } else if (fakeCount == 2) {
-                        return (int) 'c';
-                    } else {
-                        return -1;
-                    }
-                }
-            };
+        @Override
+        public int read() {
+          int fakeCount = readAllowed++;
+          if (fakeCount == 0) {
+            return (int) 'a';
+          } else if (fakeCount == 1) {
+            return (int) 'b';
+          } else if (fakeCount == 2) {
+            return (int) 'c';
+          } else {
+            return -1;
+          }
+        }
+      };
 
-            Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("X-Param"), "abc");
+      Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getHeader("X-Param"), "abc");
+    }
+  }
+
+  private static class InputStreamHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if ("POST".equalsIgnoreCase(request.getMethod())) {
+        byte[] bytes = new byte[3];
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        int read = 0;
+        while (read > -1) {
+          read = request.getInputStream().read(bytes);
+          if (read > 0) {
+            bos.write(bytes, 0, read);
+          }
         }
+
+        response.setStatus(HttpServletResponse.SC_OK);
+        response.addHeader("X-Param", new String(bos.toByteArray()));
+      } else { // this handler is to handle POST request
+        response.sendError(HttpServletResponse.SC_FORBIDDEN);
+      }
+      response.getOutputStream().flush();
+      response.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
index 9dab207a4..88e371bb5 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
@@ -12,18 +12,6 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.assertEquals;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
@@ -31,45 +19,55 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
 public class PutFileTest extends AbstractBasicTest {
 
-    private void put(int fileSize) throws Exception {
-        File file = createTempFile(fileSize);
-        int timeout = (int) file.length() / 1000;
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(timeout))) {
-            Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
+  private void put(int fileSize) throws Exception {
+    File file = createTempFile(fileSize);
+    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(2000))) {
+      Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
+      assertEquals(response.getStatusCode(), 200);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testPutLargeFile() throws Exception {
-        put(1024 * 1024);
-    }
+  @Test
+  public void testPutLargeFile() throws Exception {
+    put(1024 * 1024);
+  }
 
-    @Test(groups = "standalone")
-    public void testPutSmallFile() throws Exception {
-        put(1024);
-    }
+  @Test
+  public void testPutSmallFile() throws Exception {
+    put(1024);
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new AbstractHandler() {
 
-            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
 
-                InputStream is = baseRequest.getInputStream();
-                int read = 0;
-                do {
-                    // drain upload
-                    read = is.read();
-                } while (read >= 0);
+        InputStream is = baseRequest.getInputStream();
+        int read;
+        do {
+          // drain upload
+          read = is.read();
+        } while (read >= 0);
 
-                response.setStatus(200);
-                response.getOutputStream().flush();
-                response.getOutputStream().close();
-                baseRequest.setHandled(true);
-            }
-        };
-    }
+        response.setStatus(200);
+        response.getOutputStream().flush();
+        response.getOutputStream().close();
+        baseRequest.setHandled(true);
+      }
+    };
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
index 1852a6f34..b4df376ca 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
@@ -12,11 +12,19 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.asynchttpclient.handler.TransferListener;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.util.Enumeration;
@@ -25,209 +33,201 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.handler.TransferCompletionHandler;
-import org.asynchttpclient.handler.TransferListener;
-import org.asynchttpclient.request.body.generator.FileBodyGenerator;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.*;
 
 public class TransferListenerTest extends AbstractBasicTest {
 
-    private class BasicHandler extends AbstractHandler {
-
-        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                int read = 0;
-                while (read != -1) {
-                    read = httpRequest.getInputStream().read(bytes);
-                    if (read > 0) {
-                        httpResponse.getOutputStream().write(bytes, 0, read);
-                    }
-                }
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new BasicHandler();
+  }
+
+  @Test
+  public void basicGetTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final AtomicReference<Throwable> throwable = new AtomicReference<>();
+      final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+      final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+      final AtomicReference<byte[]> bb = new AtomicReference<>();
+      final AtomicBoolean completed = new AtomicBoolean(false);
+
+      TransferCompletionHandler tl = new TransferCompletionHandler();
+      tl.addTransferListener(new TransferListener() {
+
+        public void onRequestHeadersSent(HttpHeaders headers) {
+          hSent.set(headers);
         }
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new BasicHandler();
-    }
-
-    @Test(groups = "standalone")
-    public void basicGetTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final AtomicReference<Throwable> throwable = new AtomicReference<>();
-            final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-            final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-            final AtomicReference<byte[]> bb = new AtomicReference<>();
-            final AtomicBoolean completed = new AtomicBoolean(false);
 
-            TransferCompletionHandler tl = new TransferCompletionHandler();
-            tl.addTransferListener(new TransferListener() {
-
-                public void onRequestHeadersSent(HttpHeaders headers) {
-                    hSent.set(headers);
-                }
-
-                public void onResponseHeadersReceived(HttpHeaders headers) {
-                    hRead.set(headers);
-                }
+        public void onResponseHeadersReceived(HttpHeaders headers) {
+          hRead.set(headers);
+        }
 
-                public void onBytesReceived(byte[] b) {
-                    if (b.length != 0)
-                        bb.set(b);
-                }
+        public void onBytesReceived(byte[] b) {
+          if (b.length != 0)
+            bb.set(b);
+        }
 
-                public void onBytesSent(long amount, long current, long total) {
-                }
+        public void onBytesSent(long amount, long current, long total) {
+        }
 
-                public void onRequestResponseCompleted() {
-                    completed.set(true);
-                }
+        public void onRequestResponseCompleted() {
+          completed.set(true);
+        }
 
-                public void onThrowable(Throwable t) {
-                    throwable.set(t);
-                }
-            });
+        public void onThrowable(Throwable t) {
+          throwable.set(t);
+        }
+      });
 
-            Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
+      Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertNull(bb.get());
-            assertNull(throwable.get());
-        }
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertNotNull(hRead.get());
+      assertNotNull(hSent.get());
+      assertNull(bb.get());
+      assertNull(throwable.get());
     }
+  }
 
-    @Test(groups = "standalone")
-    public void basicPutFileTest() throws Exception {
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
-        final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-        final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-        final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-        final AtomicLong bbSentLenght = new AtomicLong(0L);
+  @Test
+  public void basicPutFileTest() throws Exception {
+    final AtomicReference<Throwable> throwable = new AtomicReference<>();
+    final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+    final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+    final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+    final AtomicLong bbSentLenght = new AtomicLong(0L);
 
-        final AtomicBoolean completed = new AtomicBoolean(false);
+    final AtomicBoolean completed = new AtomicBoolean(false);
 
-        File file = createTempFile(1024 * 100 * 10);
+    File file = createTempFile(1024 * 100 * 10);
 
-        int timeout = (int) (file.length() / 1000);
+    int timeout = (int) (file.length() / 1000);
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
-            TransferCompletionHandler tl = new TransferCompletionHandler();
-            tl.addTransferListener(new TransferListener() {
+    try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
+      TransferCompletionHandler tl = new TransferCompletionHandler();
+      tl.addTransferListener(new TransferListener() {
 
-                public void onRequestHeadersSent(HttpHeaders headers) {
-                    hSent.set(headers);
-                }
+        public void onRequestHeadersSent(HttpHeaders headers) {
+          hSent.set(headers);
+        }
 
-                public void onResponseHeadersReceived(HttpHeaders headers) {
-                    hRead.set(headers);
-                }
+        public void onResponseHeadersReceived(HttpHeaders headers) {
+          hRead.set(headers);
+        }
 
-                public void onBytesReceived(byte[] b) {
-                    bbReceivedLenght.addAndGet(b.length);
-                }
+        public void onBytesReceived(byte[] b) {
+          bbReceivedLenght.addAndGet(b.length);
+        }
 
-                public void onBytesSent(long amount, long current, long total) {
-                    bbSentLenght.addAndGet(amount);
-                }
+        public void onBytesSent(long amount, long current, long total) {
+          bbSentLenght.addAndGet(amount);
+        }
 
-                public void onRequestResponseCompleted() {
-                    completed.set(true);
-                }
+        public void onRequestResponseCompleted() {
+          completed.set(true);
+        }
 
-                public void onThrowable(Throwable t) {
-                    throwable.set(t);
-                }
-            });
+        public void onThrowable(Throwable t) {
+          throwable.set(t);
+        }
+      });
 
-            Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
+      Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
-        }
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertNotNull(hRead.get());
+      assertNotNull(hSent.get());
+      assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+      assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
     }
+  }
 
-    @Test(groups = "standalone")
-    public void basicPutFileBodyGeneratorTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final AtomicReference<Throwable> throwable = new AtomicReference<>();
-            final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-            final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-            final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-            final AtomicLong bbSentLenght = new AtomicLong(0L);
+  @Test
+  public void basicPutFileBodyGeneratorTest() throws Exception {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final AtomicReference<Throwable> throwable = new AtomicReference<>();
+      final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+      final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+      final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+      final AtomicLong bbSentLenght = new AtomicLong(0L);
 
-            final AtomicBoolean completed = new AtomicBoolean(false);
+      final AtomicBoolean completed = new AtomicBoolean(false);
 
-            File file = createTempFile(1024 * 100 * 10);
+      File file = createTempFile(1024 * 100 * 10);
 
-            TransferCompletionHandler tl = new TransferCompletionHandler();
-            tl.addTransferListener(new TransferListener() {
+      TransferCompletionHandler tl = new TransferCompletionHandler();
+      tl.addTransferListener(new TransferListener() {
 
-                public void onRequestHeadersSent(HttpHeaders headers) {
-                    hSent.set(headers);
-                }
+        public void onRequestHeadersSent(HttpHeaders headers) {
+          hSent.set(headers);
+        }
 
-                public void onResponseHeadersReceived(HttpHeaders headers) {
-                    hRead.set(headers);
-                }
+        public void onResponseHeadersReceived(HttpHeaders headers) {
+          hRead.set(headers);
+        }
 
-                public void onBytesReceived(byte[] b) {
-                    bbReceivedLenght.addAndGet(b.length);
-                }
+        public void onBytesReceived(byte[] b) {
+          bbReceivedLenght.addAndGet(b.length);
+        }
 
-                public void onBytesSent(long amount, long current, long total) {
-                    bbSentLenght.addAndGet(amount);
-                }
+        public void onBytesSent(long amount, long current, long total) {
+          bbSentLenght.addAndGet(amount);
+        }
 
-                public void onRequestResponseCompleted() {
-                    completed.set(true);
-                }
+        public void onRequestResponseCompleted() {
+          completed.set(true);
+        }
 
-                public void onThrowable(Throwable t) {
-                    throwable.set(t);
-                }
-            });
+        public void onThrowable(Throwable t) {
+          throwable.set(t);
+        }
+      });
 
-            Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
+      Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
+      assertNotNull(response);
+      assertEquals(response.getStatusCode(), 200);
+      assertNotNull(hRead.get());
+      assertNotNull(hSent.get());
+      assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+      assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
+    }
+  }
+
+  private class BasicHandler extends AbstractHandler {
+
+    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      Enumeration<?> e = httpRequest.getHeaderNames();
+      String param;
+      while (e.hasMoreElements()) {
+        param = e.nextElement().toString();
+        httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+      }
+
+      int size = 10 * 1024;
+      if (httpRequest.getContentLength() > 0) {
+        size = httpRequest.getContentLength();
+      }
+      byte[] bytes = new byte[size];
+      if (bytes.length > 0) {
+        int read = 0;
+        while (read != -1) {
+          read = httpRequest.getInputStream().read(bytes);
+          if (read > 0) {
+            httpResponse.getOutputStream().write(bytes, 0, read);
+          }
         }
+      }
+
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
+      httpResponse.getOutputStream().close();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index 306ccb17a..f3e59fd55 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -12,175 +12,166 @@
  */
 package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.*;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.net.URISyntaxException;
 import java.nio.file.Files;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BasicHttpsTest;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.testng.Assert.*;
 
 /**
  * Zero copy test which use FileChannel.transfer under the hood . The same SSL test is also covered in {@link BasicHttpsTest}
  */
 public class ZeroCopyFileTest extends AbstractBasicTest {
 
-    private class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+  @Test
+  public void zeroCopyPostTest() throws IOException, ExecutionException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final AtomicBoolean headerSent = new AtomicBoolean(false);
+      final AtomicBoolean operationCompleted = new AtomicBoolean(false);
 
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes);
-            }
+      Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
 
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
+        public State onHeadersWritten() {
+          headerSent.set(true);
+          return State.CONTINUE;
         }
-    }
 
-    @Test(groups = "standalone")
-    public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final AtomicBoolean headerSent = new AtomicBoolean(false);
-            final AtomicBoolean operationCompleted = new AtomicBoolean(false);
-
-            Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
-
-                public State onHeadersWritten() {
-                    headerSent.set(true);
-                    return State.CONTINUE;
-                }
-
-                public State onContentWritten() {
-                    operationCompleted.set(true);
-                    return State.CONTINUE;
-                }
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    return response;
-                }
-            }).get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-            assertTrue(operationCompleted.get());
-            assertTrue(headerSent.get());
+        public State onContentWritten() {
+          operationCompleted.set(true);
+          return State.CONTINUE;
         }
-    }
 
-    @Test(groups = "standalone")
-    public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
-            Response resp = f.get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+        @Override
+        public Response onCompleted(Response response) {
+          return response;
         }
+      }).get();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+      assertTrue(operationCompleted.get());
+      assertTrue(headerSent.get());
     }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ZeroCopyHandler();
+  }
+
+  @Test
+  public void zeroCopyPutTest() throws IOException, ExecutionException, InterruptedException {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
+      Response resp = f.get();
+      assertNotNull(resp);
+      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
-
-    @Test(groups = "standalone")
-    public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
-                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-                    public void onThrowable(Throwable t) {
-                    }
-
-                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                        stream.write(bodyPart.getBodyPartBytes());
-                        return State.CONTINUE;
-                    }
-
-                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                        return State.CONTINUE;
-                    }
-
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        return State.CONTINUE;
-                    }
-
-                    public Response onCompleted() throws Exception {
-                        return null;
-                    }
-                }).get();
-                assertNull(resp);
-                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
-            }
-        }
+  }
+
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new ZeroCopyHandler();
+  }
+
+  @Test
+  public void zeroCopyFileTest() throws IOException, ExecutionException, InterruptedException {
+    File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+    tmp.deleteOnExit();
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
+        Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+          public void onThrowable(Throwable t) {
+          }
+
+          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            stream.write(bodyPart.getBodyPartBytes());
+            return State.CONTINUE;
+          }
+
+          public State onStatusReceived(HttpResponseStatus responseStatus) {
+            return State.CONTINUE;
+          }
+
+          public State onHeadersReceived(HttpHeaders headers) {
+            return State.CONTINUE;
+          }
+
+          public Response onCompleted() {
+            return null;
+          }
+        }).get();
+        assertNull(resp);
+        assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+      }
     }
-
-    @Test(groups = "standalone")
-    public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
-                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-                    public void onThrowable(Throwable t) {
-                    }
-
-                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                        stream.write(bodyPart.getBodyPartBytes());
-
-                        if (bodyPart.getBodyPartBytes().length == 0) {
-                            return State.ABORT;
-                        }
-
-                        return State.CONTINUE;
-                    }
-
-                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                        return State.CONTINUE;
-                    }
-
-                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-                        return State.CONTINUE;
-                    }
-
-                    public Response onCompleted() throws Exception {
-                        return null;
-                    }
-                }).get();
-                assertNull(resp);
-                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+  }
+
+  @Test
+  public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, InterruptedException {
+    File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+    tmp.deleteOnExit();
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
+        Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+          public void onThrowable(Throwable t) {
+          }
+
+          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            stream.write(bodyPart.getBodyPartBytes());
+
+            if (bodyPart.getBodyPartBytes().length == 0) {
+              return State.ABORT;
             }
-        }
+
+            return State.CONTINUE;
+          }
+
+          public State onStatusReceived(HttpResponseStatus responseStatus) {
+            return State.CONTINUE;
+          }
+
+          public State onHeadersReceived(HttpHeaders headers) {
+            return State.CONTINUE;
+          }
+
+          public Response onCompleted() {
+            return null;
+          }
+        }).get();
+        assertNull(resp);
+        assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+      }
+    }
+  }
+
+  private class ZeroCopyHandler extends AbstractHandler {
+    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+      int size = 10 * 1024;
+      if (httpRequest.getContentLength() > 0) {
+        size = httpRequest.getContentLength();
+      }
+      byte[] bytes = new byte[size];
+      if (bytes.length > 0) {
+        httpRequest.getInputStream().read(bytes);
+        httpResponse.getOutputStream().write(bytes);
+      }
+
+      httpResponse.setStatus(200);
+      httpResponse.getOutputStream().flush();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
index ed1419caf..f3ac9b1f3 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
@@ -12,72 +12,71 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.BodyState;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.Random;
 
-import org.asynchttpclient.request.body.Body;
-import org.asynchttpclient.request.body.Body.BodyState;
-import org.asynchttpclient.request.body.generator.ByteArrayBodyGenerator;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
 
 /**
  * @author Bryan Davis bpd@keynetics.com
  */
 public class ByteArrayBodyGeneratorTest {
 
-    private final Random random = new Random();
-    private final int chunkSize = 1024 * 8;
+  private final Random random = new Random();
+  private final int chunkSize = 1024 * 8;
 
-    @Test(groups = "standalone")
-    public void testSingleRead() throws IOException {
-        final int srcArraySize = chunkSize - 1;
-        final byte[] srcArray = new byte[srcArraySize];
-        random.nextBytes(srcArray);
+  @Test
+  public void testSingleRead() throws IOException {
+    final int srcArraySize = chunkSize - 1;
+    final byte[] srcArray = new byte[srcArraySize];
+    random.nextBytes(srcArray);
 
-        final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
-        final Body body = babGen.createBody();
+    final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
+    final Body body = babGen.createBody();
 
-        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
+    final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
-        try {
-            // should take 1 read to get through the srcArray
-            body.transferTo(chunkBuffer);
-            assertEquals(chunkBuffer.readableBytes(), srcArraySize, "bytes read");
-            chunkBuffer.clear();
+    try {
+      // should take 1 read to get through the srcArray
+      body.transferTo(chunkBuffer);
+      assertEquals(chunkBuffer.readableBytes(), srcArraySize, "bytes read");
+      chunkBuffer.clear();
 
-            assertEquals(body.transferTo(chunkBuffer), BodyState.STOP, "body at EOF");
-        } finally {
-            chunkBuffer.release();
-        }
+      assertEquals(body.transferTo(chunkBuffer), BodyState.STOP, "body at EOF");
+    } finally {
+      chunkBuffer.release();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testMultipleReads() throws IOException {
-        final int srcArraySize = (3 * chunkSize) + 42;
-        final byte[] srcArray = new byte[srcArraySize];
-        random.nextBytes(srcArray);
+  @Test
+  public void testMultipleReads() throws IOException {
+    final int srcArraySize = (3 * chunkSize) + 42;
+    final byte[] srcArray = new byte[srcArraySize];
+    random.nextBytes(srcArray);
 
-        final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
-        final Body body = babGen.createBody();
+    final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
+    final Body body = babGen.createBody();
 
-        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
+    final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
-        try {
-            int reads = 0;
-            int bytesRead = 0;
-            while (body.transferTo(chunkBuffer) != BodyState.STOP) {
-                reads += 1;
-                bytesRead += chunkBuffer.readableBytes();
-                chunkBuffer.clear();
-            }
-            assertEquals(reads, 4, "reads to drain generator");
-            assertEquals(bytesRead, srcArraySize, "bytes read");
-        } finally {
-            chunkBuffer.release();
-        }
+    try {
+      int reads = 0;
+      int bytesRead = 0;
+      while (body.transferTo(chunkBuffer) != BodyState.STOP) {
+        reads += 1;
+        bytesRead += chunkBuffer.readableBytes();
+        chunkBuffer.clear();
+      }
+      assertEquals(reads, 4, "reads to drain generator");
+      assertEquals(bytesRead, srcArraySize, "bytes read");
+    } finally {
+      chunkBuffer.release();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
index 463eddd9f..97bba7c09 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -13,101 +13,101 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-
 import org.asynchttpclient.request.body.Body;
 import org.asynchttpclient.request.body.Body.BodyState;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-public class FeedableBodyGeneratorTest {
-
-    private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
-    private TestFeedListener listener;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 
-    @BeforeMethod
-    public void setUp() throws Exception {
-        feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-        listener = new TestFeedListener();
-        feedableBodyGenerator.setListener(listener);
-    }
+import static org.testng.Assert.assertEquals;
 
-    @Test(groups = "standalone")
-    public void feedNotifiesListener() throws Exception {
-        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, false);
-        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
-        assertEquals(listener.getCalls(), 2);
-    }
+public class FeedableBodyGeneratorTest {
 
-    @Test(groups = "standalone")
-    public void readingBytesReturnsFedContentWithoutChunkBoundaries() throws Exception {
-        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
-
-        ByteBuf source = Unpooled.wrappedBuffer(content);
-        ByteBuf target = Unpooled.buffer(1);
-
-        try {
-            feedableBodyGenerator.feed(source, true);
-            Body body = feedableBodyGenerator.createBody();
-            assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
-            assertEquals(body.transferTo(target), BodyState.STOP);
-        } finally {
-            source.release();
-            target.release();
-        }
+  private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
+  private TestFeedListener listener;
+
+  @BeforeMethod
+  public void setUp() {
+    feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+    listener = new TestFeedListener();
+    feedableBodyGenerator.setListener(listener);
+  }
+
+  @Test
+  public void feedNotifiesListener() throws Exception {
+    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, false);
+    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
+    assertEquals(listener.getCalls(), 2);
+  }
+
+  @Test
+  public void readingBytesReturnsFedContentWithoutChunkBoundaries() throws Exception {
+    byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+
+    ByteBuf source = Unpooled.wrappedBuffer(content);
+    ByteBuf target = Unpooled.buffer(1);
+
+    try {
+      feedableBodyGenerator.feed(source, true);
+      Body body = feedableBodyGenerator.createBody();
+      assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+      assertEquals(body.transferTo(target), BodyState.STOP);
+    } finally {
+      source.release();
+      target.release();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
-        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+  @Test
+  public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
+    byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
 
-        ByteBuf source = Unpooled.wrappedBuffer(content);
-        ByteBuf target = Unpooled.buffer(1);
+    ByteBuf source = Unpooled.wrappedBuffer(content);
+    ByteBuf target = Unpooled.buffer(1);
 
-        try {
-            feedableBodyGenerator.feed(source, false);
+    try {
+      feedableBodyGenerator.feed(source, false);
 
-            Body body = feedableBodyGenerator.createBody();
-            assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
-            assertEquals(body.transferTo(target), BodyState.SUSPEND);
-        } finally {
-            source.release();
-            target.release();
-        }
+      Body body = feedableBodyGenerator.createBody();
+      assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+      assertEquals(body.transferTo(target), BodyState.SUSPEND);
+    } finally {
+      source.release();
+      target.release();
     }
-
-    private byte[] readFromBody(Body body) throws IOException {
-        ByteBuf byteBuf = Unpooled.buffer(512);
-        try {
-            body.transferTo(byteBuf);
-            byte[] readBytes = new byte[byteBuf.readableBytes()];
-            byteBuf.readBytes(readBytes);
-            return readBytes;
-        } finally {
-            byteBuf.release();
-        }
+  }
+
+  private byte[] readFromBody(Body body) throws IOException {
+    ByteBuf byteBuf = Unpooled.buffer(512);
+    try {
+      body.transferTo(byteBuf);
+      byte[] readBytes = new byte[byteBuf.readableBytes()];
+      byteBuf.readBytes(readBytes);
+      return readBytes;
+    } finally {
+      byteBuf.release();
     }
+  }
 
-    private static class TestFeedListener implements FeedListener {
+  private static class TestFeedListener implements FeedListener {
 
-        private int calls;
+    private int calls;
 
-        @Override
-        public void onContentAdded() {
-            calls++;
-        }
+    @Override
+    public void onContentAdded() {
+      calls++;
+    }
 
-        @Override
-        public void onError(Throwable t) {
-        }
+    @Override
+    public void onError(Throwable t) {
+    }
 
-        public int getCalls() {
-            return calls;
-        }
+    int getCalls() {
+      return calls;
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
index ecb24ab4e..dc6e4326d 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
@@ -13,18 +13,6 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpHeaderValues.*;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Function;
-
 import org.asynchttpclient.*;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -32,74 +20,92 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Function;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
+import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
+import static io.netty.handler.codec.http.HttpHeaderValues.CONTINUE;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.basicAuthRealm;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 public class MultipartBasicAuthTest extends AbstractBasicTest {
 
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        addBasicAuthHandler(server, configureHandler());
-        server.start();
-        port1 = connector1.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-    }
+  @BeforeClass(alwaysRun = true)
+  @Override
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    addBasicAuthHandler(server, configureHandler());
+    server.start();
+    port1 = connector1.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new BasicAuthTest.SimpleHandler();
-    }
+  @Override
+  public AbstractHandler configureHandler() throws Exception {
+    return new BasicAuthTest.SimpleHandler();
+  }
 
-    private void expectBrokenPipe(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
-        File file = createTempFile(1024 * 1024);
+  private void expectExecutionException(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Throwable {
+    File file = createTempFile(1024 * 1024);
 
-        Throwable cause = null;
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            try {
-                for (int i = 0; i < 20 && cause == null; i++) {
-                    f.apply(client.preparePut(getTargetUrl())//
-                            .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                            .execute().get();
-                }
-            } catch (ExecutionException e) {
-                cause = e.getCause();
-            }
+    ExecutionException executionException = null;
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      try {
+        for (int i = 0; i < 20; i++) {
+          f.apply(client.preparePut(getTargetUrl())
+                  .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))
+                  .execute()
+                  .get();
         }
-
-        assertTrue(cause instanceof IOException, "Expected an IOException");
+      } catch (ExecutionException e) {
+        executionException = e;
+      }
     }
 
-    @Test(groups = "standalone")
-    public void noRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb);
-    }
+    assertNotNull(executionException, "Expected ExecutionException");
+    throw executionException.getCause();
+  }
 
-    @Test(groups = "standalone")
-    public void unauthorizedNonPreemptiveRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)));
-    }
+  @Test(expectedExceptions = IOException.class)
+  public void noRealmCausesServerToCloseSocket() throws Throwable {
+    expectExecutionException(rb -> rb);
+  }
 
-    private void expectSuccess(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
-        File file = createTempFile(1024 * 1024);
+  @Test(expectedExceptions = IOException.class)
+  public void unauthorizedNonPreemptiveRealmCausesServerToCloseSocket() throws Throwable {
+    expectExecutionException(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)));
+  }
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            for (int i = 0; i < 20; i++) {
-                Response response = f.apply(client.preparePut(getTargetUrl())//
-                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                        .execute().get();
-                assertEquals(response.getStatusCode(), 200);
-                assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
-            }
-        }
-    }
+  private void expectSuccess(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
+    File file = createTempFile(1024 * 1024);
 
-    @Test(groups = "standalone")
-    public void authorizedPreemptiveRealmWorks() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true)));
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      for (int i = 0; i < 20; i++) {
+        Response response = f.apply(client.preparePut(getTargetUrl())
+                .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))
+                .execute().get();
+        assertEquals(response.getStatusCode(), 200);
+        assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
+      }
     }
+  }
 
-    @Test(groups = "standalone")
-    public void authorizedNonPreemptiveRealmWorksWithExpectContinue() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)).setHeader(EXPECT, CONTINUE));
-    }
+  @Test
+  public void authorizedPreemptiveRealmWorks() throws Exception {
+    expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true)));
+  }
+
+  @Test
+  public void authorizedNonPreemptiveRealmWorksWithExpectContinue() throws Exception {
+    expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)).setHeader(EXPECT, CONTINUE));
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 5572571ff..fc54d396a 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -13,14 +13,13 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
+import org.asynchttpclient.request.body.Body.BodyState;
+import org.testng.annotations.Test;
 
-import java.io.File;
-import java.io.IOException;
+import java.io.*;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.nio.ByteBuffer;
@@ -29,107 +28,113 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.asynchttpclient.request.body.Body.BodyState;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
 public class MultipartBodyTest {
 
-    private static final List<Part> PARTS = new ArrayList<>();
+  private static final List<Part> PARTS = new ArrayList<>();
+  private static long MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE;
 
-    static {
-        try {
-            PARTS.add(new FilePart("filePart", getTestfile()));
-        } catch (URISyntaxException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-        PARTS.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
-        PARTS.add(new StringPart("stringPart", "testString"));
+  static {
+    try {
+      PARTS.add(new FilePart("filePart", getTestfile()));
+    } catch (URISyntaxException e) {
+      throw new ExceptionInInitializerError(e);
     }
-
-    private static File getTestfile() throws URISyntaxException {
-        final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
-        final URL url = cl.getResource("textfile.txt");
-        assertNotNull(url);
-        return new File(url.toURI());
+    PARTS.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
+    PARTS.add(new StringPart("stringPart", "testString"));
+  }
+
+  static {
+    try (MultipartBody dummyBody = buildMultipart()) {
+      // separator is random
+      MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE = dummyBody.getContentLength() + 100;
     }
-
-    private static long MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE;
-
-    static {
-        try (MultipartBody dummyBody = buildMultipart()) {
-            // separator is random
-            MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE = dummyBody.getContentLength() + 100;
-        } catch (IOException e) {
-            throw new ExceptionInInitializerError(e);
-        }
+  }
+
+  private static File getTestfile() throws URISyntaxException {
+    final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
+    final URL url = cl.getResource("textfile.txt");
+    assertNotNull(url);
+    return new File(url.toURI());
+  }
+
+  private static MultipartBody buildMultipart() {
+    List<Part> parts = new ArrayList<>(PARTS);
+    try {
+      File testFile = getTestfile();
+      InputStream inputStream = new BufferedInputStream(new FileInputStream(testFile));
+      parts.add(new InputStreamPart("isPart", inputStream, testFile.getName(), testFile.length()));
+    } catch (URISyntaxException | FileNotFoundException e) {
+      throw new ExceptionInInitializerError(e);
     }
-
-    private static MultipartBody buildMultipart() {
-        return MultipartUtils.newMultipartBody(PARTS, EmptyHttpHeaders.INSTANCE);
+    return MultipartUtils.newMultipartBody(parts, EmptyHttpHeaders.INSTANCE);
+  }
+
+  private static long transferWithCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
+    long transferred = 0;
+    final ByteBuf buffer = Unpooled.buffer(bufferSize);
+    try {
+      while (multipartBody.transferTo(buffer) != BodyState.STOP) {
+        transferred += buffer.readableBytes();
+        buffer.clear();
+      }
+      return transferred;
+    } finally {
+      buffer.release();
     }
-
-    @Test
-    public void transferWithCopy() throws Exception {
-        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
-            try (MultipartBody multipartBody = buildMultipart()) {
-                long tranferred = transferWithCopy(multipartBody, bufferLength);
-                assertEquals(tranferred, multipartBody.getContentLength());
-            }
-        }
+  }
+
+  private static long transferZeroCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
+
+    final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
+    final AtomicLong transferred = new AtomicLong();
+
+    WritableByteChannel mockChannel = new WritableByteChannel() {
+      @Override
+      public boolean isOpen() {
+        return true;
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public int write(ByteBuffer src) {
+        int written = src.remaining();
+        transferred.set(transferred.get() + written);
+        src.position(src.limit());
+        return written;
+      }
+    };
+
+    while (transferred.get() < multipartBody.getContentLength()) {
+      multipartBody.transferTo(mockChannel);
+      buffer.clear();
     }
-
-    @Test
-    public void transferZeroCopy() throws Exception {
-        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
-            try (MultipartBody multipartBody = buildMultipart()) {
-                long tranferred = transferZeroCopy(multipartBody, bufferLength);
-                assertEquals(tranferred, multipartBody.getContentLength());
-            }
-        }
+    return transferred.get();
+  }
+
+  @Test
+  public void transferWithCopy() throws Exception {
+    for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+      try (MultipartBody multipartBody = buildMultipart()) {
+        long tranferred = transferWithCopy(multipartBody, bufferLength);
+        assertEquals(tranferred, multipartBody.getContentLength());
+      }
     }
-
-    private static long transferWithCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
-        long transferred = 0;
-        final ByteBuf buffer = Unpooled.buffer(bufferSize);
-        try {
-            while (multipartBody.transferTo(buffer) != BodyState.STOP) {
-                transferred += buffer.readableBytes();
-                buffer.clear();
-            }
-            return transferred;
-        } finally {
-            buffer.release();
-        }
-    }
-
-    private static long transferZeroCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
-
-        final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
-        final AtomicLong transferred = new AtomicLong();
-
-        WritableByteChannel mockChannel = new WritableByteChannel() {
-            @Override
-            public boolean isOpen() {
-                return true;
-            }
-
-            @Override
-            public void close() throws IOException {
-            }
-
-            @Override
-            public int write(ByteBuffer src) throws IOException {
-                int written = src.remaining();
-                transferred.set(transferred.get() + written);
-                src.position(src.limit());
-                return written;
-            }
-        };
-
-        while (transferred.get() < multipartBody.getContentLength()) {
-            multipartBody.transferTo(mockChannel);
-            buffer.clear();
-        }
-        return transferred.get();
+  }
+
+  @Test
+  public void transferZeroCopy() throws Exception {
+    for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+      try (MultipartBody multipartBody = buildMultipart()) {
+        long tranferred = transferZeroCopy(multipartBody, bufferLength);
+        assertEquals(tranferred, multipartBody.getContentLength());
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
index cc69fbe2d..879a40a9d 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
@@ -12,30 +12,6 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.Writer;
-import java.nio.file.Files;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.UUID;
-import java.util.zip.GZIPInputStream;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.apache.commons.fileupload.FileItemIterator;
 import org.apache.commons.fileupload.FileItemStream;
 import org.apache.commons.fileupload.FileUploadException;
@@ -46,7 +22,6 @@
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -57,327 +32,387 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.*;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.UUID;
+import java.util.zip.GZIPInputStream;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.getClasspathFile;
+import static org.testng.Assert.*;
+
 /**
  * @author dominict
  */
 public class MultipartUploadTest extends AbstractBasicTest {
-    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48,
-            58, 54, 6, 0, 0, 0 };
-
-    @BeforeClass
-    public void setUp() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-        context.addServlet(new ServletHolder(new MockMultipartUploadServlet()), "/upload/*");
-        server.setHandler(context);
-        server.start();
-        port1 = connector.getLocalPort();
-    }
-
-    /**
-     * Tests that the streaming of a file works.
-     * @throws IOException 
-     */
-    @Test(groups = "standalone")
-    public void testSendingSmallFilesAndByteArray() throws IOException {
-        String expectedContents = "filecontent: hello";
-        String expectedContents2 = "gzipcontent: hello";
-        String expectedContents3 = "filecontent: hello2";
-        String testResource1 = "textfile.txt";
-        String testResource2 = "gzip.txt.gz";
-        String testResource3 = "textfile2.txt";
-
-        File testResource1File = null;
-        try {
-            testResource1File = getClasspathFile(testResource1);
-        } catch (FileNotFoundException e) {
-            // TODO Auto-generated catch block
-            fail("unable to find " + testResource1);
-        }
 
-        File testResource2File = null;
-        try {
-            testResource2File = getClasspathFile(testResource2);
-        } catch (FileNotFoundException e) {
-            // TODO Auto-generated catch block
-            fail("unable to find " + testResource2);
-        }
+  @BeforeClass
+  public void setUp() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+    context.addServlet(new ServletHolder(new MockMultipartUploadServlet()), "/upload");
+    server.setHandler(context);
+    server.start();
+    port1 = connector.getLocalPort();
+  }
+
+  @Test
+  public void testSendingSmallFilesAndByteArray() throws Exception {
+    String expectedContents = "filecontent: hello";
+    String expectedContents2 = "gzipcontent: hello";
+    String expectedContents3 = "filecontent: hello2";
+    String testResource1 = "textfile.txt";
+    String testResource2 = "gzip.txt.gz";
+    String testResource3 = "textfile2.txt";
+
+    File testResource1File = getClasspathFile(testResource1);
+    File testResource2File = getClasspathFile(testResource2);
+    File testResource3File = getClasspathFile(testResource3);
+    InputStream inputStreamFile1 = new BufferedInputStream(new FileInputStream(testResource1File));
+    InputStream inputStreamFile2 = new BufferedInputStream(new FileInputStream(testResource2File));
+    InputStream inputStreamFile3 = new BufferedInputStream(new FileInputStream(testResource3File));
+
+    List<File> testFiles = new ArrayList<>();
+    testFiles.add(testResource1File);
+    testFiles.add(testResource2File);
+    testFiles.add(testResource3File);
+    testFiles.add(testResource3File);
+    testFiles.add(testResource2File);
+    testFiles.add(testResource1File);
+
+    List<String> expected = new ArrayList<>();
+    expected.add(expectedContents);
+    expected.add(expectedContents2);
+    expected.add(expectedContents3);
+    expected.add(expectedContents3);
+    expected.add(expectedContents2);
+    expected.add(expectedContents);
+
+    List<Boolean> gzipped = new ArrayList<>();
+    gzipped.add(false);
+    gzipped.add(true);
+    gzipped.add(false);
+    gzipped.add(false);
+    gzipped.add(true);
+    gzipped.add(false);
+
+    File tmpFile = File.createTempFile("textbytearray", ".txt");
+    try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
+      IOUtils.write(expectedContents.getBytes(UTF_8), os);
+
+      testFiles.add(tmpFile);
+      expected.add(expectedContents);
+      gzipped.add(false);
+    }
 
-        File testResource3File = null;
-        try {
-            testResource3File = getClasspathFile(testResource3);
-        } catch (FileNotFoundException e) {
-            // TODO Auto-generated catch block
-            fail("unable to find " + testResource3);
-        }
+    try (AsyncHttpClient c = asyncHttpClient(config())) {
+      Request r = post("http://localhost" + ":" + port1 + "/upload")
+              .addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8))
+              .addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null))
+              .addBodyPart(new StringPart("Name", "Dominic"))
+              .addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8))
+              .addBodyPart(new StringPart("Age", "3")).addBodyPart(new StringPart("Height", "shrimplike"))
+              .addBodyPart(new InputStreamPart("inputStream3", inputStreamFile3, testResource3File.getName(), testResource3File.length(), "text/plain", UTF_8))
+              .addBodyPart(new InputStreamPart("inputStream2", inputStreamFile2, testResource2File.getName(), testResource2File.length(), "application/x-gzip", null))
+              .addBodyPart(new StringPart("Hair", "ridiculous")).addBodyPart(new ByteArrayPart("file4",
+                      expectedContents.getBytes(UTF_8), "text/plain", UTF_8, "bytearray.txt"))
+              .addBodyPart(new InputStreamPart("inputStream1", inputStreamFile1, testResource1File.getName(), testResource1File.length(), "text/plain", UTF_8))
+              .build();
+
+      Response res = c.executeRequest(r).get();
+
+      assertEquals(res.getStatusCode(), 200);
+
+      testSentFile(expected, testFiles, res, gzipped);
+    }
+  }
 
-        List<File> testFiles = new ArrayList<>();
-        testFiles.add(testResource1File);
-        testFiles.add(testResource2File);
-        testFiles.add(testResource3File);
-
-        List<String> expected = new ArrayList<>();
-        expected.add(expectedContents);
-        expected.add(expectedContents2);
-        expected.add(expectedContents3);
-
-        List<Boolean> gzipped = new ArrayList<>();
-        gzipped.add(false);
-        gzipped.add(true);
-        gzipped.add(false);
-
-        boolean tmpFileCreated = false;
-        File tmpFile = File.createTempFile("textbytearray", ".txt");
-        try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
-            IOUtils.write(expectedContents.getBytes(UTF_8), os);
-            tmpFileCreated = true;
-
-            testFiles.add(tmpFile);
-            expected.add(expectedContents);
-            gzipped.add(false);
-
-        } catch (FileNotFoundException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        } catch (IOException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        }
+  private void sendEmptyFile0(boolean disableZeroCopy) throws Exception {
+    File file = getClasspathFile("empty.txt");
+    try (AsyncHttpClient c = asyncHttpClient(config().setDisableZeroCopy(disableZeroCopy))) {
+      Request r = post("http://localhost" + ":" + port1 + "/upload")
+              .addBodyPart(new FilePart("file", file, "text/plain", UTF_8)).build();
 
-        if (!tmpFileCreated) {
-            fail("Unable to test ByteArrayMultiPart, as unable to write to filesystem the tmp test content");
+      Response res = c.executeRequest(r).get();
+      assertEquals(res.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void sendEmptyFile() throws Exception {
+    sendEmptyFile0(true);
+  }
+
+  @Test
+  public void sendEmptyFileZeroCopy() throws Exception {
+    sendEmptyFile0(false);
+  }
+
+  private void sendEmptyFileInputStream(boolean disableZeroCopy) throws Exception {
+    File file = getClasspathFile("empty.txt");
+    try (AsyncHttpClient c = asyncHttpClient(config().setDisableZeroCopy(disableZeroCopy))) {
+      InputStream inputStream = new BufferedInputStream(new FileInputStream(file));
+      Request r = post("http://localhost" + ":" + port1 + "/upload")
+              .addBodyPart(new InputStreamPart("file", inputStream, file.getName(), file.length(), "text/plain", UTF_8)).build();
+
+      Response res = c.executeRequest(r).get();
+      assertEquals(res.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testSendEmptyFileInputStream() throws Exception {
+    sendEmptyFileInputStream(true);
+  }
+
+  @Test
+  public void testSendEmptyFileInputStreamZeroCopy() throws Exception {
+    sendEmptyFileInputStream(false);
+  }
+
+  private void sendFileInputStream(boolean useContentLength, boolean disableZeroCopy) throws Exception {
+    File file = getClasspathFile("textfile.txt");
+    try (AsyncHttpClient c = asyncHttpClient(config().setDisableZeroCopy(disableZeroCopy))) {
+      InputStream inputStream = new BufferedInputStream(new FileInputStream(file));
+      InputStreamPart part;
+      if (useContentLength) {
+        part = new InputStreamPart("file", inputStream, file.getName(), file.length());
+      } else {
+        part = new InputStreamPart("file", inputStream, file.getName());
+      }
+      Request r = post("http://localhost" + ":" + port1 + "/upload").addBodyPart(part).build();
+
+      Response res = c.executeRequest(r).get();
+      assertEquals(res.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testSendFileInputStreamUnknownContentLength() throws Exception {
+    sendFileInputStream(false, true);
+  }
+
+  @Test
+  public void testSendFileInputStreamZeroCopyUnknownContentLength() throws Exception {
+    sendFileInputStream(false, false);
+  }
+
+  @Test
+  public void testSendFileInputStreamKnownContentLength() throws Exception {
+    sendFileInputStream(true, true);
+  }
+
+  @Test
+  public void testSendFileInputStreamZeroCopyKnownContentLength() throws Exception {
+    sendFileInputStream(true, false);
+  }
+
+  /**
+   * Test that the files were sent, based on the response from the servlet
+   */
+  private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r,
+                            List<Boolean> deflate) {
+    String content = r.getResponseBody();
+    assertNotNull(content);
+    logger.debug(content);
+
+    String[] contentArray = content.split("\\|\\|");
+    // TODO: this fail on win32
+    assertEquals(contentArray.length, 2);
+
+    String tmpFiles = contentArray[1];
+    assertNotNull(tmpFiles);
+    assertTrue(tmpFiles.trim().length() > 2);
+    tmpFiles = tmpFiles.substring(1, tmpFiles.length() - 1);
+
+    String[] responseFiles = tmpFiles.split(",");
+    assertNotNull(responseFiles);
+    assertEquals(responseFiles.length, sourceFiles.size());
+
+    logger.debug(Arrays.toString(responseFiles));
+
+    int i = 0;
+    for (File sourceFile : sourceFiles) {
+
+      File tmp = null;
+      try {
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        byte[] sourceBytes;
+        try (InputStream instream = Files.newInputStream(sourceFile.toPath())) {
+          byte[] buf = new byte[8092];
+          int len;
+          while ((len = instream.read(buf)) > 0) {
+            baos.write(buf, 0, len);
+          }
+          logger.debug("================");
+          logger.debug("Length of file: " + baos.toByteArray().length);
+          logger.debug("Contents: " + Arrays.toString(baos.toByteArray()));
+          logger.debug("================");
+          System.out.flush();
+          sourceBytes = baos.toByteArray();
         }
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-
-            RequestBuilder builder = post("http://localhost" + ":" + port1 + "/upload/bob");
-            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8));
-            builder.addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null));
-            builder.addBodyPart(new StringPart("Name", "Dominic"));
-            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8));
-            builder.addBodyPart(new StringPart("Age", "3"));
-            builder.addBodyPart(new StringPart("Height", "shrimplike"));
-            builder.addBodyPart(new StringPart("Hair", "ridiculous"));
-
-            builder.addBodyPart(new ByteArrayPart("file4", expectedContents.getBytes(UTF_8), "text/plain", UTF_8, "bytearray.txt"));
-
-            Request r = builder.build();
-
-            Response res = c.executeRequest(r).get();
-
-            assertEquals(res.getStatusCode(), 200);
-
-            testSentFile(expected, testFiles, res, gzipped);
-
-        } catch (Exception e) {
-            e.printStackTrace();
-            fail("Download Exception");
-        } finally {
-            FileUtils.deleteQuietly(tmpFile);
+        tmp = new File(responseFiles[i].trim());
+        logger.debug("==============================");
+        logger.debug(tmp.getAbsolutePath());
+        logger.debug("==============================");
+        System.out.flush();
+        assertTrue(tmp.exists());
+
+        byte[] bytes;
+        try (InputStream instream = Files.newInputStream(tmp.toPath())) {
+          ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+          byte[] buf = new byte[8092];
+          int len;
+          while ((len = instream.read(buf)) > 0) {
+            baos2.write(buf, 0, len);
+          }
+          bytes = baos2.toByteArray();
+          assertEquals(bytes, sourceBytes);
         }
-    }
 
-    /**
-     * Test that the files were sent, based on the response from the servlet
-     * 
-     * @param expectedContents
-     * @param sourceFiles
-     * @param r
-     * @param deflate
-     */
-    private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r, List<Boolean> deflate) {
-        String content = r.getResponseBody();
-        assertNotNull("===>" + content);
-        logger.debug(content);
-
-        String[] contentArray = content.split("\\|\\|");
-        // TODO: this fail on win32
-        assertEquals(contentArray.length, 2);
-
-        String tmpFiles = contentArray[1];
-        assertNotNull(tmpFiles);
-        assertTrue(tmpFiles.trim().length() > 2);
-        tmpFiles = tmpFiles.substring(1, tmpFiles.length() - 1);
-
-        String[] responseFiles = tmpFiles.split(",");
-        assertNotNull(responseFiles);
-        assertEquals(responseFiles.length, sourceFiles.size());
-
-        logger.debug(Arrays.toString(responseFiles));
-
-        int i = 0;
-        for (File sourceFile : sourceFiles) {
-
-            File tmp = null;
+        if (!deflate.get(i)) {
+          String helloString = new String(bytes);
+          assertEquals(helloString, expectedContents.get(i));
+        } else {
+          try (InputStream instream = Files.newInputStream(tmp.toPath())) {
+            ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
+            GZIPInputStream deflater = new GZIPInputStream(instream);
             try {
-
-                ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                byte[] sourceBytes = null;
-                try (InputStream instream = Files.newInputStream(sourceFile.toPath())) {
-                    byte[] buf = new byte[8092];
-                    int len = 0;
-                    while ((len = instream.read(buf)) > 0) {
-                        baos.write(buf, 0, len);
-                    }
-                    logger.debug("================");
-                    logger.debug("Length of file: " + baos.toByteArray().length);
-                    logger.debug("Contents: " + Arrays.toString(baos.toByteArray()));
-                    logger.debug("================");
-                    System.out.flush();
-                    sourceBytes = baos.toByteArray();
-                }
-
-                tmp = new File(responseFiles[i].trim());
-                logger.debug("==============================");
-                logger.debug(tmp.getAbsolutePath());
-                logger.debug("==============================");
-                System.out.flush();
-                assertTrue(tmp.exists());
-
-                byte[] bytes;
-                try (InputStream instream = Files.newInputStream(tmp.toPath())) {
-                    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
-                    byte[] buf = new byte[8092];
-                    int len = 0;
-                    while ((len = instream.read(buf)) > 0) {
-                        baos2.write(buf, 0, len);
-                    }
-                    bytes = baos2.toByteArray();
-                    assertEquals(bytes, sourceBytes);
-                }
-
-
-                if (!deflate.get(i)) {
-                    String helloString = new String(bytes);
-                    assertEquals(helloString, expectedContents.get(i));
-                } else {
-                    try (InputStream instream = Files.newInputStream(tmp.toPath())) {
-                        ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
-                        GZIPInputStream deflater = new GZIPInputStream(instream);
-                        try {
-                            byte[] buf3 = new byte[8092];
-                            int len3 = 0;
-                            while ((len3 = deflater.read(buf3)) > 0) {
-                                baos3.write(buf3, 0, len3);
-                            }
-                        } finally {
-                            deflater.close();
-                        }
-    
-                        String helloString = new String(baos3.toByteArray());
-    
-                        assertEquals(expectedContents.get(i), helloString);
-                    }
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-                fail("Download Exception");
+              byte[] buf3 = new byte[8092];
+              int len3;
+              while ((len3 = deflater.read(buf3)) > 0) {
+                baos3.write(buf3, 0, len3);
+              }
             } finally {
-                if (tmp != null)
-                    FileUtils.deleteQuietly(tmp);
-                i++;
+              deflater.close();
             }
-        }
-    }
 
-    /**
-     * Takes the content that is being passed to it, and streams to a file on disk
-     * 
-     * @author dominict
-     */
-    public static class MockMultipartUploadServlet extends HttpServlet {
+            String helloString = new String(baos3.toByteArray());
 
-        private static final Logger LOGGER = LoggerFactory.getLogger(MockMultipartUploadServlet.class);
+            assertEquals(expectedContents.get(i), helloString);
+          }
+        }
+      } catch (Exception e) {
+        e.printStackTrace();
+        fail("Download Exception");
+      } finally {
+        if (tmp != null)
+          FileUtils.deleteQuietly(tmp);
+        i++;
+      }
+    }
+  }
 
-        private static final long serialVersionUID = 1L;
-        private int filesProcessed = 0;
-        private int stringsProcessed = 0;
+  /**
+   * Takes the content that is being passed to it, and streams to a file on disk
+   *
+   * @author dominict
+   */
+  public static class MockMultipartUploadServlet extends HttpServlet {
 
-        public MockMultipartUploadServlet() {
+    private static final Logger LOGGER = LoggerFactory.getLogger(MockMultipartUploadServlet.class);
 
-        }
+    private static final long serialVersionUID = 1L;
+    private int filesProcessed = 0;
+    private int stringsProcessed = 0;
 
-        public synchronized void resetFilesProcessed() {
-            filesProcessed = 0;
-        }
+    MockMultipartUploadServlet() {
 
-        private synchronized int incrementFilesProcessed() {
-            return ++filesProcessed;
+    }
 
-        }
+    synchronized void resetFilesProcessed() {
+      filesProcessed = 0;
+    }
 
-        public int getFilesProcessed() {
-            return filesProcessed;
-        }
+    private synchronized int incrementFilesProcessed() {
+      return ++filesProcessed;
+    }
 
-        public synchronized void resetStringsProcessed() {
-            stringsProcessed = 0;
-        }
+    int getFilesProcessed() {
+      return filesProcessed;
+    }
 
-        private synchronized int incrementStringsProcessed() {
-            return ++stringsProcessed;
+    synchronized void resetStringsProcessed() {
+      stringsProcessed = 0;
+    }
 
-        }
+    private synchronized int incrementStringsProcessed() {
+      return ++stringsProcessed;
 
-        public int getStringsProcessed() {
-            return stringsProcessed;
-        }
+    }
 
-        @Override
-        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-            // Check that we have a file upload request
-            boolean isMultipart = ServletFileUpload.isMultipartContent(request);
-            if (isMultipart) {
-                List<String> files = new ArrayList<>();
-                ServletFileUpload upload = new ServletFileUpload();
-                // Parse the request
-                FileItemIterator iter = null;
-                try {
-                    iter = upload.getItemIterator(request);
-                    while (iter.hasNext()) {
-                        FileItemStream item = iter.next();
-                        String name = item.getFieldName();
-                        try (InputStream stream = item.openStream()) {
-
-                            if (item.isFormField()) {
-                                LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
-                                incrementStringsProcessed();
-                            } else {
-                                LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
-                                // Process the input stream
-                                File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet", ".tmp");
-                                tmpFile.deleteOnExit();
-                                try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
-                                    byte[] buffer = new byte[4096];
-                                    int bytesRead;
-                                    while ((bytesRead = stream.read(buffer)) != -1) {
-                                        os.write(buffer, 0, bytesRead);
-                                    }
-                                    incrementFilesProcessed();
-                                    files.add(tmpFile.getAbsolutePath());
-                                }
-                            }
-                        }
-                    }
-                } catch (FileUploadException e) {
+    public int getStringsProcessed() {
+      return stringsProcessed;
+    }
 
+    @Override
+    public void service(HttpServletRequest request, HttpServletResponse response)
+            throws IOException {
+      // Check that we have a file upload request
+      boolean isMultipart = ServletFileUpload.isMultipartContent(request);
+      if (isMultipart) {
+        List<String> files = new ArrayList<>();
+        ServletFileUpload upload = new ServletFileUpload();
+        // Parse the request
+        FileItemIterator iter;
+        try {
+          iter = upload.getItemIterator(request);
+          while (iter.hasNext()) {
+            FileItemStream item = iter.next();
+            String name = item.getFieldName();
+            try (InputStream stream = item.openStream()) {
+
+              if (item.isFormField()) {
+                LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream)
+                        + " detected.");
+                incrementStringsProcessed();
+              } else {
+                LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
+                // Process the input stream
+                File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet",
+                        ".tmp");
+                tmpFile.deleteOnExit();
+                try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
+                  byte[] buffer = new byte[4096];
+                  int bytesRead;
+                  while ((bytesRead = stream.read(buffer)) != -1) {
+                    os.write(buffer, 0, bytesRead);
+                  }
+                  incrementFilesProcessed();
+                  files.add(tmpFile.getAbsolutePath());
                 }
-                try (Writer w = response.getWriter()) {
-                    w.write(Integer.toString(getFilesProcessed()));
-                    resetFilesProcessed();
-                    resetStringsProcessed();
-                    w.write("||");
-                    w.write(files.toString());
-                }
-            } else {
-                try (Writer w = response.getWriter()) {
-                    w.write(Integer.toString(getFilesProcessed()));
-                    resetFilesProcessed();
-                    resetStringsProcessed();
-                    w.write("||");
-                }
+              }
             }
+          }
+        } catch (FileUploadException e) {
+          //
+        }
+        try (Writer w = response.getWriter()) {
+          w.write(Integer.toString(getFilesProcessed()));
+          resetFilesProcessed();
+          resetStringsProcessed();
+          w.write("||");
+          w.write(files.toString());
+        }
+      } else {
+        try (Writer w = response.getWriter()) {
+          w.write(Integer.toString(getFilesProcessed()));
+          resetFilesProcessed();
+          resetStringsProcessed();
+          w.write("||");
         }
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
index 87b57bc83..b66c7975f 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -13,12 +13,15 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.request.body.multipart.*;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
+import org.asynchttpclient.test.TestUtils;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.net.URISyntaxException;
@@ -28,255 +31,245 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.commons.io.FileUtils;
-import org.asynchttpclient.request.body.multipart.FileLikePart;
-import org.asynchttpclient.request.body.multipart.MultipartBody;
-import org.asynchttpclient.request.body.multipart.MultipartUtils;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.request.body.multipart.StringPart;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
-import org.asynchttpclient.test.TestUtils;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
 
 public class MultipartPartTest {
 
-    @Test
-    public void testVisitStart() {
-        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[10])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitStart(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 12, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count plus boundary bytes count");
-        }
+  @Test
+  public void testVisitStart() {
+    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[10])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitStart(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 12, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count plus boundary bytes count");
     }
-
-    @Test
-    public void testVisitStartZeroSizedByteArray() {
-        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitStart(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count when boundary byte array is of size zero");
-        }
+  }
+
+  @Test
+  public void testVisitStartZeroSizedByteArray() {
+    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitStart(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count when boundary byte array is of size zero");
     }
-
-    @Test
-    public void testVisitDispositionHeaderWithoutFileName() {
-        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitDispositionHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length when file name is not specified");
-        }
+  }
+
+  @Test
+  public void testVisitDispositionHeaderWithoutFileName() {
+    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitDispositionHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length when file name is not specified");
     }
-
-    @Test
-    public void testVisitDispositionHeaderWithFileName() {
-        TestFileLikePart fileLikePart = new TestFileLikePart("baPart", null, null, null, null, "fileName");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitDispositionHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 68, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length + file name length when" + " both part name and file name are present");
-        }
+  }
+
+  @Test
+  public void testVisitDispositionHeaderWithFileName() {
+    TestFileLikePart fileLikePart = new TestFileLikePart("baPart", null, null, null, null, "fileName");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitDispositionHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 68, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length + file name length when" + " both part name and file name are present");
     }
-
-    @Test
-    public void testVisitDispositionHeaderWithoutName() {
-        // with fileName
-        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, null, "fileName");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitDispositionHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 53, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + file name length when part name is not specified");
-        }
+  }
+
+  @Test
+  public void testVisitDispositionHeaderWithoutName() {
+    // with fileName
+    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, null, "fileName");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitDispositionHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 53, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + file name length when part name is not specified");
     }
-
-    @Test
-    public void testVisitContentTypeHeaderWithCharset() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test", UTF_8, null, null);
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitContentTypeHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 47, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length + charset length");
-        }
+  }
+
+  @Test
+  public void testVisitContentTypeHeaderWithCharset() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test", UTF_8, null, null);
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitContentTypeHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 47, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length + charset length");
     }
-
-    @Test
-    public void testVisitContentTypeHeaderWithoutCharset() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitContentTypeHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 32, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length when charset is not specified");
-        }
+  }
+
+  @Test
+  public void testVisitContentTypeHeaderWithoutCharset() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitContentTypeHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 32, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length when charset is not specified");
     }
-
-    @Test
-    public void testVisitTransferEncodingHeader() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, "transferEncoding");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitTransferEncodingHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitTransferEncodingHeader should be equal to "
-                    + "CRLF_BYTES length + CONTENT_TRANSFER_ENCODING_BYTES length + transferEncoding length");
-        }
+  }
+
+  @Test
+  public void testVisitTransferEncodingHeader() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, "transferEncoding");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitTransferEncodingHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitTransferEncodingHeader should be equal to "
+              + "CRLF_BYTES length + CONTENT_TRANSFER_ENCODING_BYTES length + transferEncoding length");
     }
-
-    @Test
-    public void testVisitContentIdHeader() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, "contentId");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitContentIdHeader(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 23, "CounterPartVisitor count for visitContentIdHeader should be equal to"
-                    + "CRLF_BYTES length + CONTENT_ID_BYTES length + contentId length");
-        }
+  }
+
+  @Test
+  public void testVisitContentIdHeader() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, "contentId");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitContentIdHeader(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 23, "CounterPartVisitor count for visitContentIdHeader should be equal to"
+              + "CRLF_BYTES length + CONTENT_ID_BYTES length + contentId length");
     }
-
-    @Test
-    public void testVisitCustomHeadersWhenNoCustomHeaders() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null);
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitCustomHeaders(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 0, "CounterPartVisitor count for visitCustomHeaders should be zero for visitCustomHeaders "
-                    + "when there are no custom headers");
-        }
+  }
+
+  @Test
+  public void testVisitCustomHeadersWhenNoCustomHeaders() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null);
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitCustomHeaders(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 0, "CounterPartVisitor count for visitCustomHeaders should be zero for visitCustomHeaders "
+              + "when there are no custom headers");
     }
-
-    @Test
-    public void testVisitCustomHeaders() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null);
-        fileLikePart.addCustomHeader("custom-header", "header-value");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitCustomHeaders(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 29, "CounterPartVisitor count for visitCustomHeaders should include the length of the custom headers");
-        }
+  }
+
+  @Test
+  public void testVisitCustomHeaders() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null);
+    fileLikePart.addCustomHeader("custom-header", "header-value");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitCustomHeaders(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 29, "CounterPartVisitor count for visitCustomHeaders should include the length of the custom headers");
     }
-
-    @Test
-    public void testVisitEndOfHeaders() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null);
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitEndOfHeaders(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 4, "CounterPartVisitor count for visitEndOfHeaders should be equal to 4");
-        }
+  }
+
+  @Test
+  public void testVisitEndOfHeaders() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null);
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitEndOfHeaders(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 4, "CounterPartVisitor count for visitEndOfHeaders should be equal to 4");
     }
-
-    @Test
-    public void testVisitPreContent() {
-        TestFileLikePart fileLikePart = new TestFileLikePart("Name", "application/test", UTF_8, "contentId", "transferEncoding", "fileName");
-        fileLikePart.addCustomHeader("custom-header", "header-value");
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitPreContent(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 216, "CounterPartVisitor count for visitPreContent should " + "be equal to the sum of the lengths of precontent");
-        }
+  }
+
+  @Test
+  public void testVisitPreContent() {
+    TestFileLikePart fileLikePart = new TestFileLikePart("Name", "application/test", UTF_8, "contentId", "transferEncoding", "fileName");
+    fileLikePart.addCustomHeader("custom-header", "header-value");
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitPreContent(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 216, "CounterPartVisitor count for visitPreContent should " + "be equal to the sum of the lengths of precontent");
     }
-
-    @Test
-    public void testVisitPostContents() {
-        TestFileLikePart fileLikePart = new TestFileLikePart(null);
-        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-            CounterPartVisitor counterVisitor = new CounterPartVisitor();
-            multipartPart.visitPostContent(counterVisitor);
-            assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitPostContent should be equal to 2");
-        }
+  }
+
+  @Test
+  public void testVisitPostContents() {
+    TestFileLikePart fileLikePart = new TestFileLikePart(null);
+    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+      CounterPartVisitor counterVisitor = new CounterPartVisitor();
+      multipartPart.visitPostContent(counterVisitor);
+      assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitPostContent should be equal to 2");
     }
+  }
+
+  @Test
+  public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
+    String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"), UTF_8);
+
+    List<Part> parts = new ArrayList<>();
+    parts.add(new StringPart("test_sample_message.eml", text));
+
+    HttpHeaders headers = new DefaultHttpHeaders();
+    headers.set(
+            "Cookie",
+            "open-xchange-public-session-d41d8cd98f00b204e9800998ecf8427e=bfb98150b24f42bd844fc9ef2a9eaad5; open-xchange-secret-TSlq4Cm4nCBnDpBL1Px2A=9a49b76083e34c5ba2ef5c47362313fd; JSESSIONID=6883138728830405130.OX2");
+    headers.set("Content-Length", "9241");
+    headers.set("Content-Type", "multipart/form-data; boundary=5gigAKQyqDCVdlZ1fCkeLlEDDauTNoOOEhRnFg");
+    headers.set("Host", "appsuite.qa.open-xchange.com");
+    headers.set("Accept", "*/*");
+
+    String boundary = "uwyqQolZaSmme019O2kFKvAeHoC14Npp";
+
+    List<MultipartPart<? extends Part>> multipartParts = MultipartUtils.generateMultipartParts(parts, boundary.getBytes());
+    try (MultipartBody multipartBody = new MultipartBody(multipartParts, "multipart/form-data; boundary=" + boundary, boundary.getBytes())) {
+
+      ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(8 * 1024);
+      multipartBody.transferTo(byteBuf);
+      try {
+        byteBuf.toString(StandardCharsets.UTF_8);
+      } finally {
+        byteBuf.release();
+      }
+    }
+  }
 
-    @Test
-    public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
-        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"), UTF_8);
-
-        List<Part> parts = new ArrayList<>();
-        parts.add(new StringPart("test_sample_message.eml", text));
-
-        HttpHeaders headers = new DefaultHttpHeaders();
-        headers.set(
-                "Cookie",
-                "open-xchange-public-session-d41d8cd98f00b204e9800998ecf8427e=bfb98150b24f42bd844fc9ef2a9eaad5; open-xchange-secret-TSlq4Cm4nCBnDpBL1Px2A=9a49b76083e34c5ba2ef5c47362313fd; JSESSIONID=6883138728830405130.OX2");
-        headers.set("Content-Length", "9241");
-        headers.set("Content-Type", "multipart/form-data; boundary=5gigAKQyqDCVdlZ1fCkeLlEDDauTNoOOEhRnFg");
-        headers.set("Host", "appsuite.qa.open-xchange.com");
-        headers.set("Accept", "*/*");
-
-        String boundary = "uwyqQolZaSmme019O2kFKvAeHoC14Npp";
+  /**
+   * Concrete implementation of {@link FileLikePart} for use in unit tests
+   */
+  private class TestFileLikePart extends FileLikePart {
 
-        List<MultipartPart<? extends Part>> multipartParts = MultipartUtils.generateMultipartParts(parts, boundary.getBytes());
-        MultipartBody multipartBody = new MultipartBody(multipartParts, "multipart/form-data; boundary=" + boundary, boundary.getBytes());
+    TestFileLikePart(String name) {
+      this(name, null, null, null, null);
+    }
 
-        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(8 * 1024);
+    TestFileLikePart(String name, String contentType) {
+      this(name, contentType, null);
+    }
 
-        try {
-            multipartBody.transferTo(byteBuf);
-            byteBuf.toString(StandardCharsets.UTF_8);
-        } finally {
-            multipartBody.close();
-            byteBuf.release();
-        }
+    TestFileLikePart(String name, String contentType, Charset charset) {
+      this(name, contentType, charset, null);
     }
 
-    /**
-     * Concrete implementation of {@link FileLikePart} for use in unit tests
-     * 
-     */
-    private class TestFileLikePart extends FileLikePart {
+    TestFileLikePart(String name, String contentType, Charset charset, String contentId) {
+      this(name, contentType, charset, contentId, null);
+    }
 
-        public TestFileLikePart(String name) {
-            this(name, null, null, null, null);
-        }
+    TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
+      this(name, contentType, charset, contentId, transfertEncoding, null);
+    }
 
-        public TestFileLikePart(String name, String contentType) {
-            this(name, contentType, null);
-        }
+    TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding, String fileName) {
+      super(name, contentType, charset, fileName, contentId, transfertEncoding);
+    }
+  }
 
-        public TestFileLikePart(String name, String contentType, Charset charset) {
-            this(name, contentType, charset, null);
-        }
+  /**
+   * Concrete implementation of MultipartPart for use in unit tests.
+   */
+  private class TestMultipartPart extends FileLikeMultipartPart<TestFileLikePart> {
 
-        public TestFileLikePart(String name, String contentType, Charset charset, String contentId) {
-            this(name, contentType, charset, contentId, null);
-        }
+    TestMultipartPart(TestFileLikePart part, byte[] boundary) {
+      super(part, boundary);
+    }
 
-        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
-            this(name, contentType, charset, contentId, transfertEncoding, null);
-        }
+    @Override
+    protected long getContentLength() {
+      return 0;
+    }
 
-        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding, String fileName) {
-            super(name, contentType, charset, fileName, contentId, transfertEncoding);
-        }
+    @Override
+    protected long transferContentTo(ByteBuf target) {
+      return 0;
     }
 
-    /**
-     * Concrete implementation of MultipartPart for use in unit tests.
-     *
-     */
-    private class TestMultipartPart extends FileLikeMultipartPart<TestFileLikePart> {
-
-        public TestMultipartPart(TestFileLikePart part, byte[] boundary) {
-            super(part, boundary);
-        }
-
-        @Override
-        protected long getContentLength() {
-            return 0;
-        }
-
-        @Override
-        protected long transferContentTo(ByteBuf target) throws IOException {
-            return 0;
-        }
-
-        @Override
-        protected long transferContentTo(WritableByteChannel target) throws IOException {
-            return 0;
-        }
+    @Override
+    protected long transferContentTo(WritableByteChannel target) {
+      return 0;
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/spnego/SpnegoEngineTest.java b/client/src/test/java/org/asynchttpclient/spnego/SpnegoEngineTest.java
new file mode 100644
index 000000000..92ff4a4d7
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/spnego/SpnegoEngineTest.java
@@ -0,0 +1,163 @@
+package org.asynchttpclient.spnego;
+
+import org.apache.commons.io.FileUtils;
+import org.apache.kerby.kerberos.kerb.server.SimpleKdcServer;
+import org.asynchttpclient.AbstractBasicTest;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+
+public class SpnegoEngineTest extends AbstractBasicTest {
+  private static SimpleKdcServer kerbyServer;
+
+  private static String basedir;
+  private static String alice;
+  private static String bob;
+  private static File aliceKeytab;
+  private static File bobKeytab;
+  private static File loginConfig;
+
+  @BeforeClass
+  public static void startServers() throws Exception {
+    basedir = System.getProperty("basedir");
+    if (basedir == null) {
+      basedir = new File(".").getCanonicalPath();
+    }
+
+    // System.setProperty("sun.security.krb5.debug", "true");
+    System.setProperty("java.security.krb5.conf",
+        new File(basedir + File.separator + "target" + File.separator + "krb5.conf").getCanonicalPath());
+    loginConfig = new File(basedir + File.separator + "target" + File.separator + "kerberos.jaas");
+    System.setProperty("java.security.auth.login.config", loginConfig.getCanonicalPath());
+
+    kerbyServer = new SimpleKdcServer();
+
+    kerbyServer.setKdcRealm("service.ws.apache.org");
+    kerbyServer.setAllowUdp(false);
+    kerbyServer.setWorkDir(new File(basedir, "target"));
+
+    //kerbyServer.setInnerKdcImpl(new NettyKdcServerImpl(kerbyServer.getKdcSetting()));
+
+    kerbyServer.init();
+
+    // Create principals
+    alice = "alice@service.ws.apache.org";
+    bob = "bob/service.ws.apache.org@service.ws.apache.org";
+
+    kerbyServer.createPrincipal(alice, "alice");
+    kerbyServer.createPrincipal(bob, "bob");
+
+    aliceKeytab = new File(basedir + File.separator + "target" + File.separator + "alice.keytab");
+    bobKeytab = new File(basedir + File.separator + "target" + File.separator + "bob.keytab");
+    kerbyServer.exportPrincipal(alice, aliceKeytab);
+    kerbyServer.exportPrincipal(bob, bobKeytab);
+
+    kerbyServer.start();
+
+    FileUtils.copyInputStreamToFile(SpnegoEngine.class.getResourceAsStream("/kerberos.jaas"), loginConfig);
+  }
+
+  @Test
+  public void testSpnegoGenerateTokenWithUsernamePassword() throws Exception {
+    SpnegoEngine spnegoEngine = new SpnegoEngine("alice",
+        "alice",
+        "bob",
+        "service.ws.apache.org",
+        false,
+        null,
+        "alice",
+        null);
+    String token = spnegoEngine.generateToken("localhost");
+    Assert.assertNotNull(token);
+    Assert.assertTrue(token.startsWith("YII"));
+  }
+
+  @Test(expectedExceptions = SpnegoEngineException.class)
+  public void testSpnegoGenerateTokenWithUsernamePasswordFail() throws Exception {
+    SpnegoEngine spnegoEngine = new SpnegoEngine("alice",
+        "wrong password",
+        "bob",
+        "service.ws.apache.org",
+        false,
+        null,
+        "alice",
+        null);
+    spnegoEngine.generateToken("localhost");
+  }
+
+  @Test
+  public void testSpnegoGenerateTokenWithCustomLoginConfig() throws Exception {
+    Map<String, String> loginConfig = new HashMap<>();
+    loginConfig.put("useKeyTab", "true");
+    loginConfig.put("storeKey", "true");
+    loginConfig.put("refreshKrb5Config", "true");
+    loginConfig.put("keyTab", aliceKeytab.getCanonicalPath());
+    loginConfig.put("principal", alice);
+    loginConfig.put("debug", String.valueOf(true));
+    SpnegoEngine spnegoEngine = new SpnegoEngine(null,
+        null,
+        "bob",
+        "service.ws.apache.org",
+        false,
+        loginConfig,
+        null,
+        null);
+
+    String token = spnegoEngine.generateToken("localhost");
+    Assert.assertNotNull(token);
+    Assert.assertTrue(token.startsWith("YII"));
+  }
+
+  @Test
+  public void testGetCompleteServicePrincipalName() throws Exception {
+    {
+      SpnegoEngine spnegoEngine = new SpnegoEngine(null,
+          null,
+          "bob",
+          "service.ws.apache.org",
+          false,
+          null,
+          null,
+          null);
+      Assert.assertEquals("bob@service.ws.apache.org", spnegoEngine.getCompleteServicePrincipalName("localhost"));
+    }
+    {
+      SpnegoEngine spnegoEngine = new SpnegoEngine(null,
+          null,
+          null,
+          "service.ws.apache.org",
+          true,
+          null,
+          null,
+          null);
+      Assert.assertNotEquals("HTTP@localhost", spnegoEngine.getCompleteServicePrincipalName("localhost"));
+      Assert.assertTrue(spnegoEngine.getCompleteServicePrincipalName("localhost").startsWith("HTTP@"));
+    }
+    {
+      SpnegoEngine spnegoEngine = new SpnegoEngine(null,
+          null,
+          null,
+          "service.ws.apache.org",
+          false,
+          null,
+          null,
+          null);
+      Assert.assertEquals("HTTP@localhost", spnegoEngine.getCompleteServicePrincipalName("localhost"));
+    }
+  }
+
+  @AfterClass
+  public static void cleanup() throws Exception {
+    if (kerbyServer != null) {
+      kerbyServer.stop();
+    }
+    FileUtils.deleteQuietly(aliceKeytab);
+    FileUtils.deleteQuietly(bobKeytab);
+    FileUtils.deleteQuietly(loginConfig);
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
index 48744f408..682615564 100644
--- a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
@@ -13,128 +13,155 @@
  */
 package org.asynchttpclient.test;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-
-import java.io.IOException;
-import java.util.Enumeration;
+import org.apache.commons.io.IOUtils;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Enumeration;
+import java.util.zip.Deflater;
 
-import org.apache.commons.io.IOUtils;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static io.netty.handler.codec.http.HttpHeaderValues.CHUNKED;
+import static io.netty.handler.codec.http.HttpHeaderValues.DEFLATE;
 
 public class EchoHandler extends AbstractHandler {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(EchoHandler.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(EchoHandler.class);
 
-    @Override
-    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+  @Override
+  public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-        LOGGER.debug("Echo received request {} on path {}", request, pathInContext);
+    LOGGER.debug("Echo received request {} on path {}", request, pathInContext);
 
-        if (httpRequest.getHeader("X-HEAD") != null) {
-            httpResponse.setContentLength(1);
-        }
+    if (httpRequest.getHeader("X-HEAD") != null) {
+      httpResponse.setContentLength(1);
+    }
 
-        if (httpRequest.getHeader("X-ISO") != null) {
-            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
-        } else {
-            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-        }
+    if (httpRequest.getHeader("X-ISO") != null) {
+      httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+    } else {
+      httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+    }
 
-        if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
-            httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-        }
+    if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+      httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+    }
 
-        Enumeration<String> e = httpRequest.getHeaderNames();
-        String headerName;
-        while (e.hasMoreElements()) {
-            headerName = e.nextElement();
-            if (headerName.startsWith("LockThread")) {
-                final int sleepTime = httpRequest.getIntHeader(headerName);
-                try {
-                    Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
-                } catch (InterruptedException ex) {
-                }
-            }
-
-            if (headerName.startsWith("X-redirect")) {
-                httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-                return;
-            }
-            httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
+    Enumeration<String> e = httpRequest.getHeaderNames();
+    String headerName;
+    while (e.hasMoreElements()) {
+      headerName = e.nextElement();
+      if (headerName.startsWith("LockThread")) {
+        final int sleepTime = httpRequest.getIntHeader(headerName);
+        try {
+          Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
+        } catch (InterruptedException ex) {
+          //
         }
+      }
+
+      if (headerName.startsWith("X-redirect")) {
+        httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+        return;
+      }
+      if (headerName.startsWith("X-fail")) {
+        byte[] body = "custom error message".getBytes(StandardCharsets.US_ASCII);
+        httpResponse.addHeader(CONTENT_LENGTH.toString(), String.valueOf(body.length));
+        httpResponse.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);
+        httpResponse.getOutputStream().write(body);
+        httpResponse.getOutputStream().flush();
+        httpResponse.getOutputStream().close();
+        return;
+      }
+      httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
+    }
 
-        String pathInfo = httpRequest.getPathInfo();
-        if (pathInfo != null)
-            httpResponse.addHeader("X-pathInfo", pathInfo);
+    String pathInfo = httpRequest.getPathInfo();
+    if (pathInfo != null)
+      httpResponse.addHeader("X-pathInfo", pathInfo);
 
-        String queryString = httpRequest.getQueryString();
-        if (queryString != null)
-            httpResponse.addHeader("X-queryString", queryString);
+    String queryString = httpRequest.getQueryString();
+    if (queryString != null)
+      httpResponse.addHeader("X-queryString", queryString);
 
-        httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+    httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
 
-        Cookie[] cs = httpRequest.getCookies();
-        if (cs != null) {
-            for (Cookie c : cs) {
-                httpResponse.addCookie(c);
-            }
-        }
+    Cookie[] cs = httpRequest.getCookies();
+    if (cs != null) {
+      for (Cookie c : cs) {
+        httpResponse.addCookie(c);
+      }
+    }
 
-        Enumeration<String> i = httpRequest.getParameterNames();
-        if (i.hasMoreElements()) {
-            StringBuilder requestBody = new StringBuilder();
-            while (i.hasMoreElements()) {
-                headerName = i.nextElement();
-                httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
-                requestBody.append(headerName);
-                requestBody.append("_");
-            }
-
-            if (requestBody.length() > 0) {
-                String body = requestBody.toString();
-                httpResponse.getOutputStream().write(body.getBytes());
-            }
-        }
+    Enumeration<String> i = httpRequest.getParameterNames();
+    if (i.hasMoreElements()) {
+      StringBuilder requestBody = new StringBuilder();
+      while (i.hasMoreElements()) {
+        headerName = i.nextElement();
+        httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
+        requestBody.append(headerName);
+        requestBody.append("_");
+      }
+
+      if (requestBody.length() > 0) {
+        String body = requestBody.toString();
+        httpResponse.getOutputStream().write(body.getBytes());
+      }
+    }
 
-        String requestBodyLength = httpRequest.getHeader("X-" + CONTENT_LENGTH);
-
-        if (requestBodyLength != null) {
-            byte[] requestBodyBytes = IOUtils.toByteArray(httpRequest.getInputStream());
-            int total = requestBodyBytes.length;
-
-            httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
-            String md5 = TestUtils.md5(requestBodyBytes, 0, total);
-            httpResponse.addHeader(CONTENT_MD5.toString(), md5);
-
-            httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
-        } else {
-            int size = 16384;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            if (size > 0) {
-                int read = 0;
-                while (read > -1) {
-                    byte[] bytes = new byte[size];
-                    read = httpRequest.getInputStream().read(bytes);
-                    if (read > 0) {
-                        httpResponse.getOutputStream().write(bytes, 0, read);
-                    }
-                }
-            }
+    if (httpRequest.getHeader("X-COMPRESS") != null) {
+      byte[] compressed = deflate(IOUtils.toByteArray(httpRequest.getInputStream()));
+      httpResponse.addIntHeader(CONTENT_LENGTH.toString(), compressed.length);
+      httpResponse.addHeader(CONTENT_ENCODING.toString(), DEFLATE.toString());
+      httpResponse.getOutputStream().write(compressed, 0, compressed.length);
+
+    } else {
+      httpResponse.addHeader(TRANSFER_ENCODING.toString(), CHUNKED.toString());
+      int size = 16384;
+      if (httpRequest.getContentLength() > 0) {
+        size = httpRequest.getContentLength();
+      }
+      if (size > 0) {
+        int read = 0;
+        while (read > -1) {
+          byte[] bytes = new byte[size];
+          read = httpRequest.getInputStream().read(bytes);
+          if (read > 0) {
+            httpResponse.getOutputStream().write(bytes, 0, read);
+          }
         }
+      }
+    }
 
-        request.setHandled(true);
-        httpResponse.getOutputStream().flush();
-        // FIXME don't always close, depends on the test, cf ReactiveStreamsTest
-        httpResponse.getOutputStream().close();
+    request.setHandled(true);
+    httpResponse.getOutputStream().flush();
+    // FIXME don't always close, depends on the test, cf ReactiveStreamsTest
+    httpResponse.getOutputStream().close();
+  }
+
+  private static byte[] deflate(byte[] input) throws IOException {
+    Deflater compressor = new Deflater();
+    compressor.setLevel(Deflater.BEST_COMPRESSION);
+
+    compressor.setInput(input);
+    compressor.finish();
+
+    try (ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length)) {
+      byte[] buf = new byte[1024];
+      while (!compressor.finished()) {
+        int count = compressor.deflate(buf);
+        bos.write(buf, 0, count);
+      }
+      return bos.toByteArray();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
index 0e0b594ed..8047c5f84 100644
--- a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -14,7 +14,13 @@
 
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.netty.request.NettyRequest;
+import org.testng.Assert;
 
+import javax.net.ssl.SSLSession;
 import java.net.InetSocketAddress;
 import java.util.List;
 import java.util.Queue;
@@ -22,145 +28,139 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.netty.request.NettyRequest;
-import org.testng.Assert;
-
-public class EventCollectingHandler extends AsyncCompletionHandlerBase implements AsyncHandlerExtensions {
-
-    public static final String COMPLETED_EVENT = "Completed";
-    public static final String STATUS_RECEIVED_EVENT = "StatusReceived";
-    public static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
-    public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
-    public static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
-    public static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-    public static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
-    public static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
-    public static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
-    public static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
-    public static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
-    public static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
-    public static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
-    public static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
-    public static final String CONNECTION_POOL_EVENT = "ConnectionPool";
-    public static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
-    public static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
-    public static final String REQUEST_SEND_EVENT = "RequestSend";
-    public static final String RETRY_EVENT = "Retry";
-
-    public Queue<String> firedEvents = new ConcurrentLinkedQueue<>();
-    private CountDownLatch completionLatch = new CountDownLatch(1);
-
-    public void waitForCompletion(int timeout, TimeUnit unit) throws InterruptedException {
-        if (!completionLatch.await(timeout, unit)) {
-            Assert.fail("Timeout out");
-        }
-    }
-
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-        firedEvents.add(COMPLETED_EVENT);
-        try {
-            return super.onCompleted(response);
-        } finally {
-            completionLatch.countDown();
-        }
-    }
-
-    @Override
-    public State onStatusReceived(HttpResponseStatus status) throws Exception {
-        firedEvents.add(STATUS_RECEIVED_EVENT);
-        return super.onStatusReceived(status);
-    }
-
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-        firedEvents.add(HEADERS_RECEIVED_EVENT);
-        return super.onHeadersReceived(headers);
-    }
-
-    @Override
-    public State onHeadersWritten() {
-        firedEvents.add(HEADERS_WRITTEN_EVENT);
-        return super.onHeadersWritten();
-    }
-
-    @Override
-    public State onContentWritten() {
-        firedEvents.add(CONTENT_WRITTEN_EVENT);
-        return super.onContentWritten();
-    }
-
-    @Override
-    public void onTcpConnectAttempt(InetSocketAddress address) {
-        firedEvents.add(CONNECTION_OPEN_EVENT);
-    }
-
-    @Override
-    public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
-        firedEvents.add(CONNECTION_SUCCESS_EVENT);
-    }
-
-    @Override
-    public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
-        firedEvents.add(CONNECTION_FAILURE_EVENT);
-    }
-
-    @Override
-    public void onHostnameResolutionAttempt(String name) {
-        firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
-    }
-
-    @Override
-    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-        firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
-    }
-
-    @Override
-    public void onHostnameResolutionFailure(String name, Throwable cause) {
-        firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
-    }
-
-    @Override
-    public void onTlsHandshakeAttempt() {
-        firedEvents.add(TLS_HANDSHAKE_EVENT);
-    }
-
-    @Override
-    public void onTlsHandshakeSuccess() {
-        firedEvents.add(TLS_HANDSHAKE_SUCCESS_EVENT);
-    }
-
-    @Override
-    public void onTlsHandshakeFailure(Throwable cause) {
-        firedEvents.add(TLS_HANDSHAKE_FAILURE_EVENT);
-    }
-
-    @Override
-    public void onConnectionPoolAttempt() {
-        firedEvents.add(CONNECTION_POOL_EVENT);
-    }
-
-    @Override
-    public void onConnectionPooled(Channel connection) {
-        firedEvents.add(CONNECTION_POOLED_EVENT);
-    }
-
-    @Override
-    public void onConnectionOffer(Channel connection) {
-        firedEvents.add(CONNECTION_OFFER_EVENT);
-    }
-
-    @Override
-    public void onRequestSend(NettyRequest request) {
-        firedEvents.add(REQUEST_SEND_EVENT);
-    }
-
-    @Override
-    public void onRetry() {
-        firedEvents.add(RETRY_EVENT);
-    }
+public class EventCollectingHandler extends AsyncCompletionHandlerBase {
+
+  public static final String COMPLETED_EVENT = "Completed";
+  public static final String STATUS_RECEIVED_EVENT = "StatusReceived";
+  public static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
+  public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
+  private static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
+  private static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
+  private static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+  private static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+  private static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
+  private static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
+  private static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
+  private static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+  private static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+  private static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
+  public static final String CONNECTION_POOL_EVENT = "ConnectionPool";
+  public static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
+  public static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
+  public static final String REQUEST_SEND_EVENT = "RequestSend";
+  private static final String RETRY_EVENT = "Retry";
+
+  public Queue<String> firedEvents = new ConcurrentLinkedQueue<>();
+  private CountDownLatch completionLatch = new CountDownLatch(1);
+
+  public void waitForCompletion(int timeout, TimeUnit unit) throws InterruptedException {
+    if (!completionLatch.await(timeout, unit)) {
+      Assert.fail("Timeout out");
+    }
+  }
+
+  @Override
+  public Response onCompleted(Response response) throws Exception {
+    firedEvents.add(COMPLETED_EVENT);
+    try {
+      return super.onCompleted(response);
+    } finally {
+      completionLatch.countDown();
+    }
+  }
+
+  @Override
+  public State onStatusReceived(HttpResponseStatus status) throws Exception {
+    firedEvents.add(STATUS_RECEIVED_EVENT);
+    return super.onStatusReceived(status);
+  }
+
+  @Override
+  public State onHeadersReceived(HttpHeaders headers) throws Exception {
+    firedEvents.add(HEADERS_RECEIVED_EVENT);
+    return super.onHeadersReceived(headers);
+  }
+
+  @Override
+  public State onHeadersWritten() {
+    firedEvents.add(HEADERS_WRITTEN_EVENT);
+    return super.onHeadersWritten();
+  }
+
+  @Override
+  public State onContentWritten() {
+    firedEvents.add(CONTENT_WRITTEN_EVENT);
+    return super.onContentWritten();
+  }
+
+  @Override
+  public void onTcpConnectAttempt(InetSocketAddress address) {
+    firedEvents.add(CONNECTION_OPEN_EVENT);
+  }
+
+  @Override
+  public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
+    firedEvents.add(CONNECTION_SUCCESS_EVENT);
+  }
+
+  @Override
+  public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
+    firedEvents.add(CONNECTION_FAILURE_EVENT);
+  }
+
+  @Override
+  public void onHostnameResolutionAttempt(String name) {
+    firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
+  }
+
+  @Override
+  public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
+  }
+
+  @Override
+  public void onHostnameResolutionFailure(String name, Throwable cause) {
+    firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
+  }
+
+  @Override
+  public void onTlsHandshakeAttempt() {
+    firedEvents.add(TLS_HANDSHAKE_EVENT);
+  }
+
+  @Override
+  public void onTlsHandshakeSuccess(SSLSession sslSession) {
+    Assert.assertNotNull(sslSession);
+    firedEvents.add(TLS_HANDSHAKE_SUCCESS_EVENT);
+  }
+
+  @Override
+  public void onTlsHandshakeFailure(Throwable cause) {
+    firedEvents.add(TLS_HANDSHAKE_FAILURE_EVENT);
+  }
+
+  @Override
+  public void onConnectionPoolAttempt() {
+    firedEvents.add(CONNECTION_POOL_EVENT);
+  }
+
+  @Override
+  public void onConnectionPooled(Channel connection) {
+    firedEvents.add(CONNECTION_POOLED_EVENT);
+  }
+
+  @Override
+  public void onConnectionOffer(Channel connection) {
+    firedEvents.add(CONNECTION_OFFER_EVENT);
+  }
+
+  @Override
+  public void onRequestSend(NettyRequest request) {
+    firedEvents.add(REQUEST_SEND_EVENT);
+  }
+
+  @Override
+  public void onRetry() {
+    firedEvents.add(RETRY_EVENT);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java b/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
index f3994ece5..0f08ffe52 100644
--- a/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
+++ b/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
@@ -19,105 +19,105 @@
 
 public class Slf4jJuliLog implements Log {
 
-    private final Logger logger;
-
-    // just so that ServiceLoader doesn't crash, unused
-    public Slf4jJuliLog() {
-        logger = null;
-    }
-
-    // actual constructor
-    public Slf4jJuliLog(String name) {
-        logger = LoggerFactory.getLogger(name);
-    }
-
-    @Override
-    public void debug(Object arg0) {
-        logger.debug(arg0.toString());
-    }
-
-    @Override
-    public void debug(Object arg0, Throwable arg1) {
-        logger.debug(arg0.toString(), arg1);
-    }
-
-    @Override
-    public void error(Object arg0) {
-        logger.error(arg0.toString());
-    }
-
-    @Override
-    public void error(Object arg0, Throwable arg1) {
-        logger.error(arg0.toString(), arg1);
-    }
-
-    @Override
-    public void fatal(Object arg0) {
-        logger.error(arg0.toString());
-    }
-
-    @Override
-    public void fatal(Object arg0, Throwable arg1) {
-        logger.error(arg0.toString(), arg1);
-    }
-
-    @Override
-    public void info(Object arg0) {
-        logger.info(arg0.toString());
-    }
-
-    @Override
-    public void info(Object arg0, Throwable arg1) {
-        logger.info(arg0.toString(), arg1);
-    }
-
-    @Override
-    public boolean isDebugEnabled() {
-        return logger.isDebugEnabled();
-    }
-
-    @Override
-    public boolean isErrorEnabled() {
-        return logger.isErrorEnabled();
-    }
-
-    @Override
-    public boolean isFatalEnabled() {
-        return logger.isErrorEnabled();
-    }
-
-    @Override
-    public boolean isInfoEnabled() {
-        return logger.isInfoEnabled();
-    }
-
-    @Override
-    public boolean isTraceEnabled() {
-        return logger.isTraceEnabled();
-    }
-
-    @Override
-    public boolean isWarnEnabled() {
-        return logger.isWarnEnabled();
-    }
-
-    @Override
-    public void trace(Object arg0) {
-        logger.trace(arg0.toString());
-    }
-
-    @Override
-    public void trace(Object arg0, Throwable arg1) {
-        logger.trace(arg0.toString(), arg1);
-    }
-
-    @Override
-    public void warn(Object arg0) {
-        logger.warn(arg0.toString());
-    }
-
-    @Override
-    public void warn(Object arg0, Throwable arg1) {
-        logger.warn(arg0.toString(), arg1);
-    }
+  private final Logger logger;
+
+  // just so that ServiceLoader doesn't crash, unused
+  public Slf4jJuliLog() {
+    logger = null;
+  }
+
+  // actual constructor
+  public Slf4jJuliLog(String name) {
+    logger = LoggerFactory.getLogger(name);
+  }
+
+  @Override
+  public void debug(Object arg0) {
+    logger.debug(arg0.toString());
+  }
+
+  @Override
+  public void debug(Object arg0, Throwable arg1) {
+    logger.debug(arg0.toString(), arg1);
+  }
+
+  @Override
+  public void error(Object arg0) {
+    logger.error(arg0.toString());
+  }
+
+  @Override
+  public void error(Object arg0, Throwable arg1) {
+    logger.error(arg0.toString(), arg1);
+  }
+
+  @Override
+  public void fatal(Object arg0) {
+    logger.error(arg0.toString());
+  }
+
+  @Override
+  public void fatal(Object arg0, Throwable arg1) {
+    logger.error(arg0.toString(), arg1);
+  }
+
+  @Override
+  public void info(Object arg0) {
+    logger.info(arg0.toString());
+  }
+
+  @Override
+  public void info(Object arg0, Throwable arg1) {
+    logger.info(arg0.toString(), arg1);
+  }
+
+  @Override
+  public boolean isDebugEnabled() {
+    return logger.isDebugEnabled();
+  }
+
+  @Override
+  public boolean isErrorEnabled() {
+    return logger.isErrorEnabled();
+  }
+
+  @Override
+  public boolean isFatalEnabled() {
+    return logger.isErrorEnabled();
+  }
+
+  @Override
+  public boolean isInfoEnabled() {
+    return logger.isInfoEnabled();
+  }
+
+  @Override
+  public boolean isTraceEnabled() {
+    return logger.isTraceEnabled();
+  }
+
+  @Override
+  public boolean isWarnEnabled() {
+    return logger.isWarnEnabled();
+  }
+
+  @Override
+  public void trace(Object arg0) {
+    logger.trace(arg0.toString());
+  }
+
+  @Override
+  public void trace(Object arg0, Throwable arg1) {
+    logger.trace(arg0.toString(), arg1);
+  }
+
+  @Override
+  public void warn(Object arg0) {
+    logger.warn(arg0.toString());
+  }
+
+  @Override
+  public void warn(Object arg0, Throwable arg1) {
+    logger.warn(arg0.toString(), arg1);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index 90e4341ff..7d90b2c9b 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -13,10 +13,41 @@
  */
 package org.asynchttpclient.test;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SslEngineFactory;
+import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
+import org.asynchttpclient.util.MessageDigestUtils;
+import org.eclipse.jetty.security.ConstraintMapping;
+import org.eclipse.jetty.security.ConstraintSecurityHandler;
+import org.eclipse.jetty.security.HashLoginService;
+import org.eclipse.jetty.security.LoginService;
+import org.eclipse.jetty.security.authentication.BasicAuthenticator;
+import org.eclipse.jetty.security.authentication.DigestAuthenticator;
+import org.eclipse.jetty.security.authentication.LoginAuthenticator;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpConfiguration;
+import org.eclipse.jetty.server.HttpConnectionFactory;
+import org.eclipse.jetty.server.SecureRequestCustomizer;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.SslConnectionFactory;
+import org.eclipse.jetty.util.security.Constraint;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
 
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -35,6 +66,7 @@
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
+import java.util.Base64;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
@@ -42,342 +74,309 @@
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.io.FileUtils;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SslEngineFactory;
-import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
-import org.asynchttpclient.util.Base64;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.BasicAuthenticator;
-import org.eclipse.jetty.security.authentication.DigestAuthenticator;
-import org.eclipse.jetty.security.authentication.LoginAuthenticator;
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.HttpConfiguration;
-import org.eclipse.jetty.server.HttpConnectionFactory;
-import org.eclipse.jetty.server.SecureRequestCustomizer;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.SslConnectionFactory;
-import org.eclipse.jetty.util.security.Constraint;
-import org.eclipse.jetty.util.ssl.SslContextFactory;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
 
 public class TestUtils {
 
-    public final static int TIMEOUT = 30;
-    public static final String USER = "user";
-    public static final String ADMIN = "admin";
-    public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html;charset=UTF-8";
-    public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html;charset=ISO-8859-1";
-    public static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
-    public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
-    public static final File LARGE_IMAGE_FILE;
-    public static final byte[] LARGE_IMAGE_BYTES;
-    public static final File SIMPLE_TEXT_FILE;
-    public static final String SIMPLE_TEXT_FILE_STRING;
-    private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-
-    static {
-        try {
-            TMP_DIR.mkdirs();
-            TMP_DIR.deleteOnExit();
-            LARGE_IMAGE_FILE = resourceAsFile("300k.png");
-            LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
-            SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
-            SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
-        } catch (Exception e) {
-            throw new ExceptionInInitializerError(e);
-        }
+  public final static int TIMEOUT = 30;
+  public static final String USER = "user";
+  public static final String ADMIN = "admin";
+  public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html;charset=UTF-8";
+  public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html;charset=ISO-8859-1";
+  public static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
+  private static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
+  public static final File LARGE_IMAGE_FILE;
+  public static final byte[] LARGE_IMAGE_BYTES;
+  public static final String LARGE_IMAGE_BYTES_MD5;
+  public static final File SIMPLE_TEXT_FILE;
+  public static final String SIMPLE_TEXT_FILE_STRING;
+  private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
+
+  static {
+    try {
+      TMP_DIR.mkdirs();
+      TMP_DIR.deleteOnExit();
+      LARGE_IMAGE_FILE = resourceAsFile("300k.png");
+      LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
+      LARGE_IMAGE_BYTES_MD5 = TestUtils.md5(LARGE_IMAGE_BYTES);
+      SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
+      SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
+    } catch (Exception e) {
+      throw new ExceptionInInitializerError(e);
     }
+  }
 
-    public static synchronized int findFreePort() throws IOException {
-        try (ServerSocket socket = ServerSocketFactory.getDefault().createServerSocket(0)) {
-            return socket.getLocalPort();
-        }
+  public static synchronized int findFreePort() throws IOException {
+    try (ServerSocket socket = ServerSocketFactory.getDefault().createServerSocket(0)) {
+      return socket.getLocalPort();
     }
-
-    public static File resourceAsFile(String path) throws URISyntaxException, IOException {
-        ClassLoader cl = TestUtils.class.getClassLoader();
-        URI uri = cl.getResource(path).toURI();
-        if (uri.isAbsolute() && !uri.isOpaque()) {
-            return new File(uri);
-        } else {
-            File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
-            tmpFile.deleteOnExit();
-            try (InputStream is = cl.getResourceAsStream(path)) {
-                FileUtils.copyInputStreamToFile(is, tmpFile);
-                return tmpFile;
-            }
-        }
+  }
+
+  public static File resourceAsFile(String path) throws URISyntaxException, IOException {
+    ClassLoader cl = TestUtils.class.getClassLoader();
+    URI uri = cl.getResource(path).toURI();
+    if (uri.isAbsolute() && !uri.isOpaque()) {
+      return new File(uri);
+    } else {
+      File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+      tmpFile.deleteOnExit();
+      try (InputStream is = cl.getResourceAsStream(path)) {
+        FileUtils.copyInputStreamToFile(is, tmpFile);
+        return tmpFile;
+      }
     }
+  }
 
-    public static File createTempFile(int approxSize) throws IOException {
-        long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
-        tmpFile.deleteOnExit();
-        try (OutputStream out = Files.newOutputStream(tmpFile.toPath())) {
-            for (int i = 0; i < repeats; i++) {
-                out.write(PATTERN_BYTES);
-            }
+  public static File createTempFile(int approxSize) throws IOException {
+    long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
+    File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+    tmpFile.deleteOnExit();
+    try (OutputStream out = Files.newOutputStream(tmpFile.toPath())) {
+      for (int i = 0; i < repeats; i++) {
+        out.write(PATTERN_BYTES);
+      }
 
-            long expectedFileSize = PATTERN_BYTES.length * repeats;
-            assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
+      long expectedFileSize = PATTERN_BYTES.length * repeats;
+      assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
 
-            return tmpFile;
-        }
+      return tmpFile;
     }
+  }
 
-    public static ServerConnector addHttpConnector(Server server) {
-        ServerConnector connector = new ServerConnector(server);
-        server.addConnector(connector);
-        return connector;
-    }
+  public static ServerConnector addHttpConnector(Server server) {
+    ServerConnector connector = new ServerConnector(server);
+    server.addConnector(connector);
+    return connector;
+  }
 
-    public static ServerConnector addHttpsConnector(Server server) throws IOException, URISyntaxException {
+  public static ServerConnector addHttpsConnector(Server server) throws IOException, URISyntaxException {
 
-        String keyStoreFile = resourceAsFile("ssltest-keystore.jks").getAbsolutePath();
-        SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
-        sslContextFactory.setKeyStorePassword("changeit");
+    String keyStoreFile = resourceAsFile("ssltest-keystore.jks").getAbsolutePath();
+    SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
+    sslContextFactory.setKeyStorePassword("changeit");
 
-        String trustStoreFile = resourceAsFile("ssltest-cacerts.jks").getAbsolutePath();
-        sslContextFactory.setTrustStorePath(trustStoreFile);
-        sslContextFactory.setTrustStorePassword("changeit");
+    String trustStoreFile = resourceAsFile("ssltest-cacerts.jks").getAbsolutePath();
+    sslContextFactory.setTrustStorePath(trustStoreFile);
+    sslContextFactory.setTrustStorePassword("changeit");
 
-        HttpConfiguration httpsConfig = new HttpConfiguration();
-        httpsConfig.setSecureScheme("https");
-        httpsConfig.addCustomizer(new SecureRequestCustomizer());
+    HttpConfiguration httpsConfig = new HttpConfiguration();
+    httpsConfig.setSecureScheme("https");
+    httpsConfig.addCustomizer(new SecureRequestCustomizer());
 
-        ServerConnector connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, "http/1.1"), new HttpConnectionFactory(httpsConfig));
+    ServerConnector connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, "http/1.1"), new HttpConnectionFactory(httpsConfig));
 
-        server.addConnector(connector);
+    server.addConnector(connector);
 
-        return connector;
-    }
+    return connector;
+  }
 
-    public static void addBasicAuthHandler(Server server, Handler handler) {
-        addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), handler);
-    }
+  public static void addBasicAuthHandler(Server server, Handler handler) {
+    addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), handler);
+  }
 
-    public static void addDigestAuthHandler(Server server, Handler handler) {
-        addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), handler);
-    }
+  public static void addDigestAuthHandler(Server server, Handler handler) {
+    addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), handler);
+  }
 
-    private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, Handler handler) {
+  private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, Handler handler) {
 
-        server.addBean(LOGIN_SERVICE);
+    server.addBean(LOGIN_SERVICE);
 
-        Constraint constraint = new Constraint();
-        constraint.setName(auth);
-        constraint.setRoles(new String[] { USER, ADMIN });
-        constraint.setAuthenticate(true);
+    Constraint constraint = new Constraint();
+    constraint.setName(auth);
+    constraint.setRoles(new String[]{USER, ADMIN});
+    constraint.setAuthenticate(true);
 
-        ConstraintMapping mapping = new ConstraintMapping();
-        mapping.setConstraint(constraint);
-        mapping.setPathSpec("/*");
+    ConstraintMapping mapping = new ConstraintMapping();
+    mapping.setConstraint(constraint);
+    mapping.setPathSpec("/*");
 
-        Set<String> knownRoles = new HashSet<>();
-        knownRoles.add(USER);
-        knownRoles.add(ADMIN);
+    Set<String> knownRoles = new HashSet<>();
+    knownRoles.add(USER);
+    knownRoles.add(ADMIN);
 
-        List<ConstraintMapping> cm = new ArrayList<>();
-        cm.add(mapping);
+    List<ConstraintMapping> cm = new ArrayList<>();
+    cm.add(mapping);
 
-        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
-        security.setConstraintMappings(cm, knownRoles);
-        security.setAuthenticator(authenticator);
-        security.setLoginService(LOGIN_SERVICE);
-        security.setHandler(handler);
-        server.setHandler(security);
-    }
+    ConstraintSecurityHandler security = new ConstraintSecurityHandler();
+    security.setConstraintMappings(cm, knownRoles);
+    security.setAuthenticator(authenticator);
+    security.setLoginService(LOGIN_SERVICE);
+    security.setHandler(handler);
+    server.setHandler(security);
+  }
 
-    private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
-        KeyStore ks = KeyStore.getInstance("JKS");
-        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-cacerts.jks")) {
-            char[] keyStorePassword = "changeit".toCharArray();
-            ks.load(keyStoreStream, keyStorePassword);
-        }
-        assert (ks.size() > 0);
-
-        // Set up key manager factory to use our key store
-        char[] certificatePassword = "changeit".toCharArray();
-        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
-        kmf.init(ks, certificatePassword);
-
-        // Initialize the SSLContext to work with our key managers.
-        return kmf.getKeyManagers();
+  private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
+    KeyStore ks = KeyStore.getInstance("JKS");
+    try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-cacerts.jks")) {
+      char[] keyStorePassword = "changeit".toCharArray();
+      ks.load(keyStoreStream, keyStorePassword);
     }
-
-    private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
-        KeyStore ks = KeyStore.getInstance("JKS");
-        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-keystore.jks")) {
-            char[] keyStorePassword = "changeit".toCharArray();
-            ks.load(keyStoreStream, keyStorePassword);
-        }
-        assert (ks.size() > 0);
-
-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-        tmf.init(ks);
-        return tmf.getTrustManagers();
+    assert (ks.size() > 0);
+
+    // Set up key manager factory to use our key store
+    char[] certificatePassword = "changeit".toCharArray();
+    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
+    kmf.init(ks, certificatePassword);
+
+    // Initialize the SSLContext to work with our key managers.
+    return kmf.getKeyManagers();
+  }
+
+  private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
+    KeyStore ks = KeyStore.getInstance("JKS");
+    try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-keystore.jks")) {
+      char[] keyStorePassword = "changeit".toCharArray();
+      ks.load(keyStoreStream, keyStorePassword);
     }
+    assert (ks.size() > 0);
 
-    public static SslEngineFactory createSslEngineFactory() throws SSLException {
-        return createSslEngineFactory(new AtomicBoolean(true));
-    }
+    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+    tmf.init(ks);
+    return tmf.getTrustManagers();
+  }
 
-    public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) throws SSLException {
+  public static SslEngineFactory createSslEngineFactory() {
+    return createSslEngineFactory(new AtomicBoolean(true));
+  }
 
-        try {
-            KeyManager[] keyManagers = createKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[] { dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0]) };
-            SecureRandom secureRandom = new SecureRandom();
+  public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) {
 
-            SSLContext sslContext = SSLContext.getInstance("TLS");
-            sslContext.init(keyManagers, trustManagers, secureRandom);
+    try {
+      KeyManager[] keyManagers = createKeyManagers();
+      TrustManager[] trustManagers = new TrustManager[]{dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0])};
+      SecureRandom secureRandom = new SecureRandom();
 
-            return new JsseSslEngineFactory(sslContext);
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(keyManagers, trustManagers, secureRandom);
 
-        } catch (Exception e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
+      return new JsseSslEngineFactory(sslContext);
 
-    public static class DummyTrustManager implements X509TrustManager {
-
-        private final X509TrustManager tm;
-        private final AtomicBoolean trust;
-
-        public DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
-            this.trust = trust;
-            this.tm = tm;
-        }
-
-        @Override
-        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            tm.checkClientTrusted(chain, authType);
-        }
-
-        @Override
-        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-            if (!trust.get()) {
-                throw new CertificateException("Server certificate not trusted.");
-            }
-            tm.checkServerTrusted(chain, authType);
-        }
-
-        @Override
-        public X509Certificate[] getAcceptedIssuers() {
-            return tm.getAcceptedIssuers();
-        }
+    } catch (Exception e) {
+      throw new ExceptionInInitializerError(e);
     }
+  }
 
-    private static TrustManager dummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
-        return new DummyTrustManager(trust, tm);
+  private static TrustManager dummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+    return new DummyTrustManager(trust, tm);
 
-    }
+  }
 
-    public static File getClasspathFile(String file) throws FileNotFoundException {
-        ClassLoader cl = null;
-        try {
-            cl = Thread.currentThread().getContextClassLoader();
-        } catch (Throwable ex) {
-        }
-        if (cl == null) {
-            cl = TestUtils.class.getClassLoader();
-        }
-        URL resourceUrl = cl.getResource(file);
-
-        try {
-            return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
-        } catch (URISyntaxException e) {
-            throw new FileNotFoundException(file);
-        }
+  public static File getClasspathFile(String file) throws FileNotFoundException {
+    ClassLoader cl = null;
+    try {
+      cl = Thread.currentThread().getContextClassLoader();
+    } catch (Throwable ex) {
+      //
     }
+    if (cl == null) {
+      cl = TestUtils.class.getClassLoader();
+    }
+    URL resourceUrl = cl.getResource(file);
 
-    public static void assertContentTypesEquals(String actual, String expected) {
-        assertEquals(actual.replace("; ", "").toLowerCase(Locale.ENGLISH), expected.replace("; ", "").toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+    try {
+      return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
+    } catch (URISyntaxException e) {
+      throw new FileNotFoundException(file);
+    }
+  }
+
+  public static void assertContentTypesEquals(String actual, String expected) {
+    assertEquals(actual.replace("; ", "").toLowerCase(Locale.ENGLISH), expected.replace("; ", "").toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+  }
+
+  public static void writeResponseBody(HttpServletResponse response, String body) {
+    response.setContentLength(body.length());
+    try {
+      response.getOutputStream().print(body);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public static String md5(byte[] bytes) {
+    return md5(bytes, 0, bytes.length);
+  }
+
+  public static String md5(byte[] bytes, int offset, int len) {
+    try {
+      MessageDigest md = MessageDigestUtils.pooledMd5MessageDigest();
+      md.update(bytes, offset, len);
+      return Base64.getEncoder().encodeToString(md.digest());
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+  }
+
+  public static class DummyTrustManager implements X509TrustManager {
+
+    private final X509TrustManager tm;
+    private final AtomicBoolean trust;
 
-    public static String getLocalhostIp() {
-        return "127.0.0.1";
+    DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+      this.trust = trust;
+      this.tm = tm;
     }
 
-    public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+    @Override
+    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+      tm.checkClientTrusted(chain, authType);
+    }
 
-        @Override
-        public Response onCompleted(Response response) throws Exception {
-            return response;
-        }
+    @Override
+    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+      if (!trust.get()) {
+        throw new CertificateException("Server certificate not trusted.");
+      }
+      tm.checkServerTrusted(chain, authType);
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-            fail("Unexpected exception: " + t.getMessage(), t);
-        }
+    @Override
+    public X509Certificate[] getAcceptedIssuers() {
+      return tm.getAcceptedIssuers();
     }
+  }
 
-    public static class AsyncHandlerAdapter implements AsyncHandler<String> {
+  public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
 
-        @Override
-        public void onThrowable(Throwable t) {
-            fail("Unexpected exception", t);
-        }
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+      return response;
+    }
 
-        @Override
-        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public void onThrowable(Throwable t) {
+      fail("Unexpected exception: " + t.getMessage(), t);
+    }
+  }
 
-        @Override
-        public State onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
-            return State.CONTINUE;
-        }
+  public static class AsyncHandlerAdapter implements AsyncHandler<String> {
 
-        @Override
-        public State onHeadersReceived(final HttpHeaders headers) throws Exception {
-            return State.CONTINUE;
-        }
+    @Override
+    public void onThrowable(Throwable t) {
+      fail("Unexpected exception", t);
+    }
 
-        @Override
-        public String onCompleted() throws Exception {
-            return "";
-        }
+    @Override
+    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+      return State.CONTINUE;
     }
 
-    public static void writeResponseBody(HttpServletResponse response, String body) {
-        response.setContentLength(body.length());
-        try {
-            response.getOutputStream().print(body);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
+    @Override
+    public State onStatusReceived(final HttpResponseStatus responseStatus) {
+      return State.CONTINUE;
     }
 
-    public static String md5(byte[] bytes) {
-        return md5(bytes, 0, bytes.length);
+    @Override
+    public State onHeadersReceived(final HttpHeaders headers) throws Exception {
+      return State.CONTINUE;
     }
 
-    public static String md5(byte[] bytes, int offset, int len) {
-        try {
-            MessageDigest md = MessageDigest.getInstance("MD5");
-            md.update(bytes, offset, len);
-            return Base64.encode(md.digest());
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
+    @Override
+    public String onCompleted() throws Exception {
+      return "";
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
index 06c65487f..9b74656b5 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
@@ -13,256 +13,250 @@
  */
 package org.asynchttpclient.testserver;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
-import static org.asynchttpclient.test.TestUtils.*;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.Closeable;
 import java.io.IOException;
+import java.net.URLEncoder;
+import java.nio.charset.StandardCharsets;
 import java.util.Enumeration;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
+import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
+import static org.asynchttpclient.test.TestUtils.*;
 
 public class HttpServer implements Closeable {
 
-    private int httpPort;
-    private int httpsPort;
-    private Server server;
-    private final ConcurrentLinkedQueue<Handler> handlers = new ConcurrentLinkedQueue<>();
+  private final ConcurrentLinkedQueue<Handler> handlers = new ConcurrentLinkedQueue<>();
+  private int httpPort;
+  private int httpsPort;
+  private Server server;
 
-    @FunctionalInterface
-    public interface HttpServletResponseConsumer {
+  public HttpServer() {
+  }
 
-        void apply(HttpServletResponse response) throws IOException, ServletException;
-    }
+  public HttpServer(int httpPort, int httpsPort) {
+    this.httpPort = httpPort;
+    this.httpsPort = httpsPort;
+  }
+
+  public void start() throws Exception {
+    server = new Server();
 
-    public HttpServer() {
+    ServerConnector httpConnector = addHttpConnector(server);
+    if (httpPort != 0) {
+      httpConnector.setPort(httpPort);
     }
 
-    public HttpServer(int httpPort, int httpsPort) {
-        this.httpPort = httpPort;
-        this.httpsPort = httpsPort;
+    server.setHandler(new QueueHandler());
+    ServerConnector httpsConnector = addHttpsConnector(server);
+    if (httpsPort != 0) {
+      httpsConnector.setPort(httpsPort);
     }
 
-    public void start() throws Exception {
-        server = new Server();
+    server.start();
+
+    httpPort = httpConnector.getLocalPort();
+    httpsPort = httpsConnector.getLocalPort();
+  }
+
+  public void enqueue(Handler handler) {
+    handlers.offer(handler);
+  }
+
+  public void enqueueOk() {
+    enqueueResponse(response -> response.setStatus(200));
+  }
+
+  public void enqueueResponse(HttpServletResponseConsumer c) {
+    handlers.offer(new ConsumerHandler(c));
+  }
+
+  public void enqueueEcho() {
+    handlers.offer(new EchoHandler());
+  }
+
+  public void enqueueRedirect(int status, String location) {
+    enqueueResponse(response -> {
+      response.setStatus(status);
+      response.setHeader(LOCATION.toString(), location);
+    });
+  }
+
+  public int getHttpPort() {
+    return httpPort;
+  }
+
+  public int getsHttpPort() {
+    return httpsPort;
+  }
+
+  public String getHttpUrl() {
+    return "http://localhost:" + httpPort;
+  }
+
+  public String getHttpsUrl() {
+    return "https://localhost:" + httpsPort;
+  }
+
+  public void reset() {
+    handlers.clear();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (server != null) {
+      try {
+        server.stop();
+      } catch (Exception e) {
+        throw new IOException(e);
+      }
+    }
+  }
 
-        ServerConnector httpConnector = addHttpConnector(server);
-        if (httpPort != 0) {
-            httpConnector.setPort(httpPort);
-        }
+  @FunctionalInterface
+  public interface HttpServletResponseConsumer {
 
-        server.setHandler(new QueueHandler());
-        ServerConnector httpsConnector = addHttpsConnector(server);
-        if (httpsPort != 0) {
-            httpsConnector.setPort(httpsPort);
-        }
+    void apply(HttpServletResponse response) throws IOException, ServletException;
+  }
 
-        server.start();
+  public static abstract class AutoFlushHandler extends AbstractHandler {
 
-        httpPort = httpConnector.getLocalPort();
-        httpsPort = httpsConnector.getLocalPort();
-    }
+    private final boolean closeAfterResponse;
 
-    public void enqueue(Handler handler) {
-        handlers.offer(handler);
+    AutoFlushHandler() {
+      this(false);
     }
 
-    public void enqueueOk() {
-        enqueueResponse(response -> response.setStatus(200));
+    AutoFlushHandler(boolean closeAfterResponse) {
+      this.closeAfterResponse = closeAfterResponse;
     }
 
-    public void enqueueResponse(HttpServletResponseConsumer c) {
-        handlers.offer(new ConsumerHandler(c));
+    @Override
+    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      handle0(target, baseRequest, request, response);
+      response.getOutputStream().flush();
+      if (closeAfterResponse) {
+        response.getOutputStream().close();
+      }
     }
 
-    public void enqueueEcho() {
-        handlers.offer(new EchoHandler());
-    }
+    protected abstract void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
+  }
 
-    public void enqueueRedirect(int status, String location) {
-        enqueueResponse(response -> {
-            response.setStatus(status);
-            response.setHeader(LOCATION.toString(), location);
-        });
-    }
+  private static class ConsumerHandler extends AutoFlushHandler {
 
-    public int getHttpPort() {
-        return httpPort;
-    }
+    private final HttpServletResponseConsumer c;
 
-    public int getsHttpPort() {
-        return httpsPort;
+    ConsumerHandler(HttpServletResponseConsumer c) {
+      this(c, false);
     }
 
-    public String getHttpUrl() {
-        return "http://localhost:" + httpPort;
+    ConsumerHandler(HttpServletResponseConsumer c, boolean closeAfterResponse) {
+      super(closeAfterResponse);
+      this.c = c;
     }
 
-    public String getHttpsUrl() {
-        return "https://localhost:" + httpsPort;
+    @Override
+    protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      c.apply(response);
     }
+  }
 
-    public void reset() {
-        handlers.clear();
-    }
+  public static class EchoHandler extends AutoFlushHandler {
 
     @Override
-    public void close() throws IOException {
-        if (server != null) {
-            try {
-                server.stop();
-            } catch (Exception e) {
-                throw new IOException(e);
-            }
+    protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+      String delay = request.getHeader("X-Delay");
+      if (delay != null) {
+        try {
+          Thread.sleep(Long.parseLong(delay));
+        } catch (NumberFormatException | InterruptedException e1) {
+          throw new ServletException(e1);
         }
-    }
+      }
 
-    private class QueueHandler extends AbstractHandler {
+      response.setStatus(200);
 
-        @Override
-        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+      if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+        response.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+      }
 
-            Handler handler = HttpServer.this.handlers.poll();
-            if (handler == null) {
-                response.sendError(500, "No handler enqueued");
-                response.getOutputStream().flush();
-                response.getOutputStream().close();
+      response.setContentType(request.getHeader("X-IsoCharset") != null ? TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET : TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
 
-            } else {
-                handler.handle(target, baseRequest, request, response);
-            }
-        }
-    }
+      response.addHeader("X-ClientPort", String.valueOf(request.getRemotePort()));
 
-    public static abstract class AutoFlushHandler extends AbstractHandler {
+      String pathInfo = request.getPathInfo();
+      if (pathInfo != null)
+        response.addHeader("X-PathInfo", pathInfo);
 
-        private final boolean closeAfterResponse;
+      String queryString = request.getQueryString();
+      if (queryString != null)
+        response.addHeader("X-QueryString", queryString);
 
-        public AutoFlushHandler() {
-            this(false);
-        }
+      Enumeration<String> headerNames = request.getHeaderNames();
+      while (headerNames.hasMoreElements()) {
+        String headerName = headerNames.nextElement();
+        response.addHeader("X-" + headerName, request.getHeader(headerName));
+      }
 
-        public AutoFlushHandler(boolean closeAfterResponse) {
-            this.closeAfterResponse = closeAfterResponse;
-        }
+      StringBuilder requestBody = new StringBuilder();
+      for (Entry<String, String[]> e : baseRequest.getParameterMap().entrySet()) {
+        response.addHeader("X-" + e.getKey(), URLEncoder.encode(e.getValue()[0], StandardCharsets.UTF_8.name()));
+      }
 
-        @Override
-        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            handle0(target, baseRequest, request, response);
-            response.getOutputStream().flush();
-            if (closeAfterResponse) {
-                response.getOutputStream().close();
-            }
+      Cookie[] cs = request.getCookies();
+      if (cs != null) {
+        for (Cookie c : cs) {
+          response.addCookie(c);
         }
-
-        protected abstract void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
+      }
+
+      if (requestBody.length() > 0) {
+        response.getOutputStream().write(requestBody.toString().getBytes());
+      }
+
+      int size = 16384;
+      if (request.getContentLength() > 0) {
+        size = request.getContentLength();
+      }
+      if (size > 0) {
+        int read = 0;
+        while (read > -1) {
+          byte[] bytes = new byte[size];
+          read = request.getInputStream().read(bytes);
+          if (read > 0) {
+            response.getOutputStream().write(bytes, 0, read);
+          }
+        }
+      }
     }
+  }
 
-    private static class ConsumerHandler extends AutoFlushHandler {
-
-        private final HttpServletResponseConsumer c;
-
-        public ConsumerHandler(HttpServletResponseConsumer c) {
-            this(c, false);
-        }
+  private class QueueHandler extends AbstractHandler {
 
-        public ConsumerHandler(HttpServletResponseConsumer c, boolean closeAfterResponse) {
-            super(closeAfterResponse);
-            this.c = c;
-        }
+    @Override
+    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-        @Override
-        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-            c.apply(response);
-        }
-    }
+      Handler handler = HttpServer.this.handlers.poll();
+      if (handler == null) {
+        response.sendError(500, "No handler enqueued");
+        response.getOutputStream().flush();
+        response.getOutputStream().close();
 
-    public static class EchoHandler extends AutoFlushHandler {
-
-        @Override
-        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-
-            String delay = request.getHeader("X-Delay");
-            if (delay != null) {
-                try {
-                    Thread.sleep(Long.parseLong(delay));
-                } catch (NumberFormatException | InterruptedException e1) {
-                    throw new ServletException(e1);
-                }
-            }
-
-            response.setStatus(200);
-
-            if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
-                response.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-            }
-
-            response.setContentType(request.getHeader("X-IsoCharset") != null ? TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET : TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-
-            response.addHeader("X-ClientPort", String.valueOf(request.getRemotePort()));
-
-            String pathInfo = request.getPathInfo();
-            if (pathInfo != null)
-                response.addHeader("X-PathInfo", pathInfo);
-
-            String queryString = request.getQueryString();
-            if (queryString != null)
-                response.addHeader("X-QueryString", queryString);
-
-            Enumeration<String> headerNames = request.getHeaderNames();
-            while (headerNames.hasMoreElements()) {
-                String headerName = headerNames.nextElement();
-                response.addHeader("X-" + headerName, request.getHeader(headerName));
-            }
-
-            for (Entry<String, String[]> e : baseRequest.getParameterMap().entrySet()) {
-                response.addHeader("X-" + e.getKey(), e.getValue()[0]);
-            }
-
-            Cookie[] cs = request.getCookies();
-            if (cs != null) {
-                for (Cookie c : cs) {
-                    response.addCookie(c);
-                }
-            }
-
-            Enumeration<String> parameterNames = request.getParameterNames();
-            StringBuilder requestBody = new StringBuilder();
-            while (parameterNames.hasMoreElements()) {
-                String param = parameterNames.nextElement();
-                response.addHeader("X-" + param, request.getParameter(param));
-                requestBody.append(param);
-                requestBody.append("_");
-            }
-            if (requestBody.length() > 0) {
-                response.getOutputStream().write(requestBody.toString().getBytes());
-            }
-
-            int size = 16384;
-            if (request.getContentLength() > 0) {
-                size = request.getContentLength();
-            }
-            if (size > 0) {
-                int read = 0;
-                while (read > -1) {
-                    byte[] bytes = new byte[size];
-                    read = request.getInputStream().read(bytes);
-                    if (read > 0) {
-                        response.getOutputStream().write(bytes, 0, read);
-                    }
-                }
-            }
-        }
+      } else {
+        handler.handle(target, baseRequest, request, response);
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
index edabb46bc..20c8b3f47 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
@@ -13,93 +13,87 @@
  */
 package org.asynchttpclient.testserver;
 
-import static org.asynchttpclient.Dsl.*;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public abstract class HttpTest {
-    
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    protected static final String COMPLETED_EVENT = "Completed";
-    protected static final String STATUS_RECEIVED_EVENT = "StatusReceived";
-    protected static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
-    protected static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
-    protected static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
-    protected static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-    protected static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
-    protected static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
-    protected static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
-    protected static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
-    protected static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
-    protected static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
-    protected static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
-    protected static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
-    protected static final String CONNECTION_POOL_EVENT = "ConnectionPool";
-    protected static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
-    protected static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
-    protected static final String REQUEST_SEND_EVENT = "RequestSend";
-    protected static final String RETRY_EVENT = "Retry";
-
-    @FunctionalInterface
-    protected interface ClientFunction {
-        void apply(AsyncHttpClient client) throws Throwable;
-    }
-
-    @FunctionalInterface
-    protected interface ServerFunction {
-        void apply(HttpServer server) throws Throwable;
-    }
-
-    protected static class ClientTestBody {
-
-        private final AsyncHttpClientConfig config;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
 
-        private ClientTestBody(AsyncHttpClientConfig config) {
-            this.config = config;
-        }
+public abstract class HttpTest {
 
-        public void run(ClientFunction f) throws Throwable {
-            try (AsyncHttpClient client = asyncHttpClient(config)) {
-                f.apply(client);
-            }
-        }
+  protected static final String COMPLETED_EVENT = "Completed";
+  protected static final String STATUS_RECEIVED_EVENT = "StatusReceived";
+  protected static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
+  protected static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
+  protected static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
+  protected static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+  protected static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+  protected static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
+  protected static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+  protected static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+  protected static final String CONNECTION_POOL_EVENT = "ConnectionPool";
+  protected static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
+  protected static final String REQUEST_SEND_EVENT = "RequestSend";
+  protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+  protected ClientTestBody withClient() {
+    return withClient(config().setMaxRedirects(0));
+  }
+
+  protected ClientTestBody withClient(DefaultAsyncHttpClientConfig.Builder builder) {
+    return withClient(builder.build());
+  }
+
+  private ClientTestBody withClient(AsyncHttpClientConfig config) {
+    return new ClientTestBody(config);
+  }
+
+  protected ServerTestBody withServer(HttpServer server) {
+    return new ServerTestBody(server);
+  }
+
+  @FunctionalInterface
+  protected interface ClientFunction {
+    void apply(AsyncHttpClient client) throws Throwable;
+  }
+
+  @FunctionalInterface
+  protected interface ServerFunction {
+    void apply(HttpServer server) throws Throwable;
+  }
+
+  protected static class ClientTestBody {
+
+    private final AsyncHttpClientConfig config;
+
+    private ClientTestBody(AsyncHttpClientConfig config) {
+      this.config = config;
     }
 
-    protected static class ServerTestBody {
-
-        private final HttpServer server;
-
-        private ServerTestBody(HttpServer server) {
-            this.server = server;
-        }
-
-        public void run(ServerFunction f) throws Throwable {
-            try {
-                f.apply(server);
-            } finally {
-                server.reset();
-            }
-        }
+    public void run(ClientFunction f) throws Throwable {
+      try (AsyncHttpClient client = asyncHttpClient(config)) {
+        f.apply(client);
+      }
     }
+  }
 
-    protected ClientTestBody withClient() {
-        return withClient(config().setMaxRedirects(0));
-    }
+  protected static class ServerTestBody {
 
-    protected ClientTestBody withClient(DefaultAsyncHttpClientConfig.Builder builder) {
-        return withClient(builder.build());
-    }
+    private final HttpServer server;
 
-    protected ClientTestBody withClient(AsyncHttpClientConfig config) {
-        return new ClientTestBody(config);
+    private ServerTestBody(HttpServer server) {
+      this.server = server;
     }
 
-    protected ServerTestBody withServer(HttpServer server) {
-        return new ServerTestBody(server);
+    public void run(ServerFunction f) throws Throwable {
+      try {
+        f.apply(server);
+      } finally {
+        server.reset();
+      }
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java b/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java
new file mode 100644
index 000000000..1d3fab069
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java
@@ -0,0 +1,188 @@
+/*
+ * SOCKS Proxy in JAVA
+ * By Gareth Owen
+ * drgowen@gmail.com
+ * MIT Licence
+ */
+
+package org.asynchttpclient.testserver;
+
+// NOTES : LISTENS ON PORT 8000
+
+import java.io.*;
+import java.net.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.util.ArrayList;
+import java.util.Set;
+
+public class SocksProxy {
+
+  private static ArrayList<SocksClient> clients = new ArrayList<>();
+
+  public SocksProxy(int runningTime) throws IOException {
+    ServerSocketChannel socks = ServerSocketChannel.open();
+    socks.socket().bind(new InetSocketAddress(8000));
+    socks.configureBlocking(false);
+    Selector select = Selector.open();
+    socks.register(select, SelectionKey.OP_ACCEPT);
+
+    int lastClients = clients.size();
+    // select loop
+    for (long end = System.currentTimeMillis() + runningTime; System.currentTimeMillis() < end; ) {
+      select.select(5000);
+
+      Set<SelectionKey> keys = select.selectedKeys();
+      for (SelectionKey k : keys) {
+
+        if (!k.isValid())
+          continue;
+
+        // new connection?
+        if (k.isAcceptable() && k.channel() == socks) {
+          // server socket
+          SocketChannel csock = socks.accept();
+          if (csock == null)
+            continue;
+          addClient(csock);
+          csock.register(select, SelectionKey.OP_READ);
+        } else if (k.isReadable()) {
+          // new data on a client/remote socket
+          for (int i = 0; i < clients.size(); i++) {
+            SocksClient cl = clients.get(i);
+            try {
+              if (k.channel() == cl.client) // from client (e.g. socks client)
+                cl.newClientData(select);
+              else if (k.channel() == cl.remote) {  // from server client is connected to (e.g. website)
+                cl.newRemoteData();
+              }
+            } catch (IOException e) { // error occurred - remove client
+              cl.client.close();
+              if (cl.remote != null)
+                cl.remote.close();
+              k.cancel();
+              clients.remove(cl);
+            }
+
+          }
+        }
+      }
+
+      // client timeout check
+      for (int i = 0; i < clients.size(); i++) {
+        SocksClient cl = clients.get(i);
+        if ((System.currentTimeMillis() - cl.lastData) > 30000L) {
+          cl.client.close();
+          if (cl.remote != null)
+            cl.remote.close();
+          clients.remove(cl);
+        }
+      }
+      if (clients.size() != lastClients) {
+        System.out.println(clients.size());
+        lastClients = clients.size();
+      }
+    }
+  }
+
+  // utility function
+  private void addClient(SocketChannel s) {
+    SocksClient cl;
+    try {
+      cl = new SocksClient(s);
+    } catch (IOException e) {
+      e.printStackTrace();
+      return;
+    }
+    clients.add(cl);
+  }
+
+  // socks client class - one per client connection
+  class SocksClient {
+    SocketChannel client, remote;
+    boolean connected;
+    long lastData;
+
+    SocksClient(SocketChannel c) throws IOException {
+      client = c;
+      client.configureBlocking(false);
+      lastData = System.currentTimeMillis();
+    }
+
+    void newRemoteData() throws IOException {
+      ByteBuffer buf = ByteBuffer.allocate(1024);
+      if (remote.read(buf) == -1)
+        throw new IOException("disconnected");
+      lastData = System.currentTimeMillis();
+      buf.flip();
+      client.write(buf);
+    }
+
+    void newClientData(Selector selector) throws IOException {
+      if (!connected) {
+        ByteBuffer inbuf = ByteBuffer.allocate(512);
+        if (client.read(inbuf) < 1)
+          return;
+        inbuf.flip();
+
+        // read socks header
+        int ver = inbuf.get();
+        if (ver != 4) {
+          throw new IOException("incorrect version" + ver);
+        }
+        int cmd = inbuf.get();
+
+        // check supported command
+        if (cmd != 1) {
+          throw new IOException("incorrect version");
+        }
+
+        final int port = inbuf.getShort() & 0xffff;
+
+        final byte ip[] = new byte[4];
+        // fetch IP
+        inbuf.get(ip);
+
+        InetAddress remoteAddr = InetAddress.getByAddress(ip);
+
+        while ((inbuf.get()) != 0); // username
+
+        // hostname provided, not IP
+        if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] != 0) { // host provided
+          StringBuilder host = new StringBuilder();
+          byte b;
+          while ((b = inbuf.get()) != 0) {
+            host.append(b);
+          }
+          remoteAddr = InetAddress.getByName(host.toString());
+          System.out.println(host.toString() + remoteAddr);
+        }
+
+        remote = SocketChannel.open(new InetSocketAddress(remoteAddr, port));
+
+        ByteBuffer out = ByteBuffer.allocate(20);
+        out.put((byte) 0);
+        out.put((byte) (remote.isConnected() ? 0x5a : 0x5b));
+        out.putShort((short) port);
+        out.put(remoteAddr.getAddress());
+        out.flip();
+        client.write(out);
+
+        if (!remote.isConnected())
+          throw new IOException("connect failed");
+
+        remote.configureBlocking(false);
+        remote.register(selector, SelectionKey.OP_READ);
+
+        connected = true;
+      } else {
+        ByteBuffer buf = ByteBuffer.allocate(1024);
+        if (client.read(buf) == -1)
+          throw new IOException("disconnected");
+        lastData = System.currentTimeMillis();
+        buf.flip();
+        remote.write(buf);
+      }
+    }
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
index 8b1fe2166..164e8030a 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
@@ -13,111 +13,110 @@
  */
 package org.asynchttpclient.uri;
 
-import static org.testng.Assert.*;
+import org.testng.annotations.Test;
 
-import java.net.MalformedURLException;
 import java.net.URI;
 
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
 
 public class UriParserTest {
 
-    private static void assertUriEquals(UriParser parser, URI uri) {
-        assertEquals(parser.scheme, uri.getScheme());
-        assertEquals(parser.userInfo, uri.getUserInfo());
-        assertEquals(parser.host, uri.getHost());
-        assertEquals(parser.port, uri.getPort());
-        assertEquals(parser.path, uri.getPath());
-        assertEquals(parser.query, uri.getQuery());
-    }
-
-    private static void validateAgainstAbsoluteURI(String url) throws MalformedURLException {
-        UriParser parser = new UriParser();
-        parser.parse(null, url);
-        assertUriEquals(parser, URI.create(url));
-    }
-
-    @Test
-    public void testUrlWithPathAndQuery() throws MalformedURLException {
-        validateAgainstAbsoluteURI("http://example.com:8080/test?q=1");
-    }
-
-    @Test
-    public void testFragmentTryingToTrickAuthorityAsBasicAuthCredentials() throws MalformedURLException {
-        validateAgainstAbsoluteURI("http://1.2.3.4:81#@5.6.7.8:82/aaa/b?q=xxx");
-    }
-
-    @Test
-    public void testUrlHasLeadingAndTrailingWhiteSpace() {
-        UriParser parser = new UriParser();
-        String url = "  http://user@example.com:8080/test?q=1  ";
-        parser.parse(null, url);
-        assertUriEquals(parser, URI.create(url.trim()));
-    }
-
-    private static void validateAgainstRelativeURI(Uri uriContext, String urlContext, String url) {
-        UriParser parser = new UriParser();
-        parser.parse(uriContext, url);
-        assertUriEquals(parser, URI.create(urlContext).resolve(URI.create(url)));
-    }
-
-    @Test
-    public void testResolveAbsoluteUriAgainstContext() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "");
-        validateAgainstRelativeURI(context, "https://example.com:80/path", "http://example.com/path");
-    }
-
-    @Test
-    public void testRootRelativePath() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativeUrl");
-    }
-
-    @Test
-    public void testCurrentDirRelativePath() {
-        Uri context = new Uri("https", null, "example.com", 80, "/foo/bar", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/foo/bar?q=2", "relativeUrl");
-    }
-
-    @Test
-    public void testFragmentOnly() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "#test");
-    }
-
-    @Test
-    public void testRelativeUrlWithQuery() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativePath?q=3");
-    }
-
-    @Test
-    public void testRelativeUrlWithQueryOnly() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "?q=3");
-    }
-
-    @Test
-    public void testRelativeURLWithDots() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/./url");
-    }
-
-    @Test
-    public void testRelativeURLWithTwoEmbeddedDots() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/../url");
-    }
-
-    @Test
-    public void testRelativeURLWithTwoTrailingDots() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/..");
-    }
-
-    @Test
-    public void testRelativeURLWithOneTrailingDot() {
-        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/.");
-    }
+  private static void assertUriEquals(UriParser parser, URI uri) {
+    assertEquals(parser.scheme, uri.getScheme());
+    assertEquals(parser.userInfo, uri.getUserInfo());
+    assertEquals(parser.host, uri.getHost());
+    assertEquals(parser.port, uri.getPort());
+    assertEquals(parser.path, uri.getPath());
+    assertEquals(parser.query, uri.getQuery());
+  }
+
+  private static void validateAgainstAbsoluteURI(String url) {
+    UriParser parser = new UriParser();
+    parser.parse(null, url);
+    assertUriEquals(parser, URI.create(url));
+  }
+
+  private static void validateAgainstRelativeURI(Uri uriContext, String urlContext, String url) {
+    UriParser parser = new UriParser();
+    parser.parse(uriContext, url);
+    assertUriEquals(parser, URI.create(urlContext).resolve(URI.create(url)));
+  }
+
+  @Test
+  public void testUrlWithPathAndQuery() {
+    validateAgainstAbsoluteURI("http://example.com:8080/test?q=1");
+  }
+
+  @Test
+  public void testFragmentTryingToTrickAuthorityAsBasicAuthCredentials() {
+    validateAgainstAbsoluteURI("http://1.2.3.4:81#@5.6.7.8:82/aaa/b?q=xxx");
+  }
+
+  @Test
+  public void testUrlHasLeadingAndTrailingWhiteSpace() {
+    UriParser parser = new UriParser();
+    String url = "  http://user@example.com:8080/test?q=1  ";
+    parser.parse(null, url);
+    assertUriEquals(parser, URI.create(url.trim()));
+  }
+
+  @Test
+  public void testResolveAbsoluteUriAgainstContext() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path", "http://example.com/path");
+  }
+
+  @Test
+  public void testRootRelativePath() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativeUrl");
+  }
+
+  @Test
+  public void testCurrentDirRelativePath() {
+    Uri context = new Uri("https", null, "example.com", 80, "/foo/bar", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/foo/bar?q=2", "relativeUrl");
+  }
+
+  @Test
+  public void testFragmentOnly() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "#test");
+  }
+
+  @Test
+  public void testRelativeUrlWithQuery() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativePath?q=3");
+  }
+
+  @Test
+  public void testRelativeUrlWithQueryOnly() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "?q=3");
+  }
+
+  @Test
+  public void testRelativeURLWithDots() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/./url");
+  }
+
+  @Test
+  public void testRelativeURLWithTwoEmbeddedDots() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/../url");
+  }
+
+  @Test
+  public void testRelativeURLWithTwoTrailingDots() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/..");
+  }
+
+  @Test
+  public void testRelativeURLWithOneTrailingDot() {
+    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2", null);
+    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/.");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriTest.java b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
index 2cf79e2c0..7ead2a652 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -12,261 +12,336 @@
  */
 package org.asynchttpclient.uri;
 
-import static org.testng.Assert.*;
+import org.testng.annotations.Test;
 
-import java.net.MalformedURLException;
 import java.net.URI;
 
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
 public class UriTest {
 
-    private static void assertUriEquals(Uri uri, URI javaUri) {
-        assertEquals(uri.getScheme(), uri.getScheme());
-        assertEquals(uri.getUserInfo(), uri.getUserInfo());
-        assertEquals(uri.getHost(), uri.getHost());
-        assertEquals(uri.getPort(), uri.getPort());
-        assertEquals(uri.getPath(), uri.getPath());
-        assertEquals(uri.getQuery(), uri.getQuery());
-    }
-
-    private static void validateAgainstAbsoluteURI(String url) throws MalformedURLException {
-        assertUriEquals(Uri.create(url), URI.create(url));
-    }
-
-    private static void validateAgainstRelativeURI(String context, String url) throws MalformedURLException {
-        assertUriEquals(Uri.create(Uri.create(context), url), URI.create(context).resolve(URI.create(url)));
-    }
-
-    @Test
-    public void testSimpleParsing() throws MalformedURLException {
-        validateAgainstAbsoluteURI("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testRootRelativeURIWithRootContext() throws MalformedURLException {
-        validateAgainstRelativeURI("https://graph.facebook.com", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testRootRelativeURIWithNonRootContext() throws MalformedURLException {
-        validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testNonRootRelativeURIWithNonRootContext() throws MalformedURLException {
-        validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testNonRootRelativeURIWithRootContext() throws MalformedURLException {
-        validateAgainstRelativeURI("https://graph.facebook.com", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testAbsoluteURIWithContext() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/foo/bar",
-                "https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-    }
-
-    @Test
-    public void testRelativeUriWithDots() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2/", "../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithDotsAboveRoot() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1", "../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithAbsoluteDots() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/", "/../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDots() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2/", "../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDotsAboveRoot() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2", "../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithAbsoluteConsecutiveDots() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2/", "/../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDotsFromRoot() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/", "../../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDotsFromRootResource() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1", "../../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDotsFromSubrootResource() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2", "../../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1/level2/level3", "../../../other/content/img.png");
-    }
-
-    @Test
-    public void testRelativeUriWithNoScheme() throws MalformedURLException {
-        validateAgainstRelativeURI("https://hello.com/level1", "//world.org/content/img.png");
-    }
-
-    @Test
-    public void testCreateAndToUrl() {
-        String url = "https://hello.com/level1/level2/level3";
-        Uri uri = Uri.create(url);
-        assertEquals(uri.toUrl(), url, "url used to create uri and url returned from toUrl do not match");
-    }
-
-    @Test
-    public void testToUrlWithUserInfoPortPathAndQuery() {
-        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-        assertEquals(uri.toUrl(), "http://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
-    }
-
-    @Test
-    public void testQueryWithNonRootPath() {
-        Uri uri = Uri.create("http://hello.com/foo?query=value");
-        assertEquals(uri.getPath(), "/foo");
-        assertEquals(uri.getQuery(), "query=value");
-    }
-
-    @Test
-    public void testQueryWithNonRootPathAndTrailingSlash() {
-        Uri uri = Uri.create("http://hello.com/foo/?query=value");
-        assertEquals(uri.getPath(), "/foo/");
-        assertEquals(uri.getQuery(), "query=value");
-    }
-
-    @Test
-    public void testQueryWithRootPath() {
-        Uri uri = Uri.create("http://hello.com?query=value");
-        assertEquals(uri.getPath(), "");
-        assertEquals(uri.getQuery(), "query=value");
-    }
-
-    @Test
-    public void testQueryWithRootPathAndTrailingSlash() {
-        Uri uri = Uri.create("http://hello.com/?query=value");
-        assertEquals(uri.getPath(), "/");
-        assertEquals(uri.getQuery(), "query=value");
-    }
-
-    @Test
-    public void testWithNewScheme() {
-        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-        Uri newUri = uri.withNewScheme("https");
-        assertEquals(newUri.getScheme(), "https");
-        assertEquals(newUri.toUrl(), "https://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
-    }
-
-    @Test
-    public void testWithNewQuery() {
-        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-        Uri newUri = uri.withNewQuery("query2=10&query3=20");
-        assertEquals(newUri.getQuery(), "query2=10&query3=20");
-        assertEquals(newUri.toUrl(), "http://user@example.com:44/path/path2?query2=10&query3=20", "toUrl returned incorrect url");
-    }
-
-    @Test
-    public void testToRelativeUrl() {
-        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-        String relativeUrl = uri.toRelativeUrl();
-        assertEquals(relativeUrl, "/path/path2?query=4", "toRelativeUrl returned incorrect url");
-    }
-
-    @Test
-    public void testToRelativeUrlWithEmptyPath() {
-        Uri uri = new Uri("http", "user", "example.com", 44, null, "query=4");
-        String relativeUrl = uri.toRelativeUrl();
-        assertEquals(relativeUrl, "/?query=4", "toRelativeUrl returned incorrect url");
-    }
-
-    @Test
-    public void testGetSchemeDefaultPortHttpScheme() {
-        String url = "https://hello.com/level1/level2/level3";
-        Uri uri = Uri.create(url);
-        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for https url");
-
-        String url2 = "http://hello.com/level1/level2/level3";
-        Uri uri2 = Uri.create(url2);
-        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for http url");
-    }
-
-    @Test
-    public void testGetSchemeDefaultPortWebSocketScheme() {
-        String url = "wss://hello.com/level1/level2/level3";
-        Uri uri = Uri.create(url);
-        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for wss url");
-
-        String url2 = "ws://hello.com/level1/level2/level3";
-        Uri uri2 = Uri.create(url2);
-        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for ws url");
-    }
-
-    @Test
-    public void testGetExplicitPort() {
-        String url = "http://hello.com/level1/level2/level3";
-        Uri uri = Uri.create(url);
-        assertEquals(uri.getExplicitPort(), 80, "getExplicitPort should return port 80 for http url when port is not specified in url");
-
-        String url2 = "http://hello.com:8080/level1/level2/level3";
-        Uri uri2 = Uri.create(url2);
-        assertEquals(uri2.getExplicitPort(), 8080, "getExplicitPort should return the port given in the url");
-    }
-
-    @Test
-    public void testEquals() {
-        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
-        Uri createdUri = Uri.create(url);
-        Uri constructedUri = new Uri("http", "user", "hello.com", 8080, "/level1/level2/level3", "q=1");
-        assertTrue(createdUri.equals(constructedUri), "The equals method returned false for two equal urls");
-    }
-
-    @Test
-    public void testIsWebsocket() {
-        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
-        Uri uri = Uri.create(url);
-        assertFalse(uri.isWebSocket(), "isWebSocket should return false for http url");
-
-        url = "https://user@hello.com:8080/level1/level2/level3?q=1";
-        uri = Uri.create(url);
-        assertFalse(uri.isWebSocket(), "isWebSocket should return false for https url");
-
-        url = "ws://user@hello.com:8080/level1/level2/level3?q=1";
-        uri = Uri.create(url);
-        assertTrue(uri.isWebSocket(), "isWebSocket should return true for ws url");
-
-        url = "wss://user@hello.com:8080/level1/level2/level3?q=1";
-        uri = Uri.create(url);
-        assertTrue(uri.isWebSocket(), "isWebSocket should return true for wss url");
-    }
-
-    @Test
-    public void creatingUriWithDefinedSchemeAndHostWorks() {
-        Uri.create("http://localhost");
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void creatingUriWithMissingSchemeThrowsIllegalArgumentException() {
-        Uri.create("localhost");
-    }
-
-    @Test(expectedExceptions = IllegalArgumentException.class)
-    public void creatingUriWithMissingHostThrowsIllegalArgumentException() {
-        Uri.create("http://");
-    }
+  private static void assertUriEquals(Uri uri, URI javaUri) {
+    assertEquals(uri.getScheme(), javaUri.getScheme());
+    assertEquals(uri.getUserInfo(), javaUri.getUserInfo());
+    assertEquals(uri.getHost(), javaUri.getHost());
+    assertEquals(uri.getPort(), javaUri.getPort());
+    assertEquals(uri.getPath(), javaUri.getPath());
+    assertEquals(uri.getQuery(), javaUri.getQuery());
+  }
+
+  private static void validateAgainstAbsoluteURI(String url) {
+    assertUriEquals(Uri.create(url), URI.create(url));
+  }
+
+  private static void validateAgainstRelativeURI(String context, String url) {
+    assertUriEquals(Uri.create(Uri.create(context), url), URI.create(context).resolve(URI.create(url)));
+  }
+
+  @Test
+  public void testSimpleParsing() {
+    validateAgainstAbsoluteURI("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test
+  public void testRootRelativeURIWithRootContext() {
+    validateAgainstRelativeURI("https://graph.facebook.com", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test
+  public void testRootRelativeURIWithNonRootContext() {
+    validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test
+  public void testNonRootRelativeURIWithNonRootContext() {
+    validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test(enabled = false)
+  // FIXME weird: java.net.URI#getPath return "750198471659552/accounts/test-users" without a "/"?!
+  public void testNonRootRelativeURIWithRootContext() {
+    validateAgainstRelativeURI("https://graph.facebook.com", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test
+  public void testAbsoluteURIWithContext() {
+    validateAgainstRelativeURI("https://hello.com/foo/bar",
+            "https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+  }
+
+  @Test
+  public void testRelativeUriWithDots() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2/", "../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithDotsAboveRoot() {
+    validateAgainstRelativeURI("https://hello.com/level1", "../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithAbsoluteDots() {
+    validateAgainstRelativeURI("https://hello.com/level1/", "/../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDots() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2/", "../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDotsAboveRoot() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2", "../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithAbsoluteConsecutiveDots() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2/", "/../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDotsFromRoot() {
+    validateAgainstRelativeURI("https://hello.com/", "../../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDotsFromRootResource() {
+    validateAgainstRelativeURI("https://hello.com/level1", "../../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDotsFromSubrootResource() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2", "../../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() {
+    validateAgainstRelativeURI("https://hello.com/level1/level2/level3", "../../../other/content/img.png");
+  }
+
+  @Test
+  public void testRelativeUriWithNoScheme() {
+    validateAgainstRelativeURI("https://hello.com/level1", "//world.org/content/img.png");
+  }
+
+  @Test
+  public void testCreateAndToUrl() {
+    String url = "https://hello.com/level1/level2/level3";
+    Uri uri = Uri.create(url);
+    assertEquals(uri.toUrl(), url, "url used to create uri and url returned from toUrl do not match");
+  }
+
+  @Test
+  public void testToUrlWithUserInfoPortPathAndQuery() {
+    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4", null);
+    assertEquals(uri.toUrl(), "http://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+  }
+
+  @Test
+  public void testQueryWithNonRootPath() {
+    Uri uri = Uri.create("http://hello.com/foo?query=value");
+    assertEquals(uri.getPath(), "/foo");
+    assertEquals(uri.getQuery(), "query=value");
+  }
+
+  @Test
+  public void testQueryWithNonRootPathAndTrailingSlash() {
+    Uri uri = Uri.create("http://hello.com/foo/?query=value");
+    assertEquals(uri.getPath(), "/foo/");
+    assertEquals(uri.getQuery(), "query=value");
+  }
+
+  @Test
+  public void testQueryWithRootPath() {
+    Uri uri = Uri.create("http://hello.com?query=value");
+    assertEquals(uri.getPath(), "");
+    assertEquals(uri.getQuery(), "query=value");
+  }
+
+  @Test
+  public void testQueryWithRootPathAndTrailingSlash() {
+    Uri uri = Uri.create("http://hello.com/?query=value");
+    assertEquals(uri.getPath(), "/");
+    assertEquals(uri.getQuery(), "query=value");
+  }
+
+  @Test
+  public void testWithNewScheme() {
+    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4", null);
+    Uri newUri = uri.withNewScheme("https");
+    assertEquals(newUri.getScheme(), "https");
+    assertEquals(newUri.toUrl(), "https://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+  }
+
+  @Test
+  public void testWithNewQuery() {
+    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4", null);
+    Uri newUri = uri.withNewQuery("query2=10&query3=20");
+    assertEquals(newUri.getQuery(), "query2=10&query3=20");
+    assertEquals(newUri.toUrl(), "http://user@example.com:44/path/path2?query2=10&query3=20", "toUrl returned incorrect url");
+  }
+
+  @Test
+  public void testToRelativeUrl() {
+    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4", null);
+    String relativeUrl = uri.toRelativeUrl();
+    assertEquals(relativeUrl, "/path/path2?query=4", "toRelativeUrl returned incorrect url");
+  }
+
+  @Test
+  public void testToRelativeUrlWithEmptyPath() {
+    Uri uri = new Uri("http", "user", "example.com", 44, null, "query=4", null);
+    String relativeUrl = uri.toRelativeUrl();
+    assertEquals(relativeUrl, "/?query=4", "toRelativeUrl returned incorrect url");
+  }
+
+  @Test
+  public void testGetSchemeDefaultPortHttpScheme() {
+    String url = "https://hello.com/level1/level2/level3";
+    Uri uri = Uri.create(url);
+    assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for https url");
+
+    String url2 = "http://hello.com/level1/level2/level3";
+    Uri uri2 = Uri.create(url2);
+    assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for http url");
+  }
+
+  @Test
+  public void testGetSchemeDefaultPortWebSocketScheme() {
+    String url = "wss://hello.com/level1/level2/level3";
+    Uri uri = Uri.create(url);
+    assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for wss url");
+
+    String url2 = "ws://hello.com/level1/level2/level3";
+    Uri uri2 = Uri.create(url2);
+    assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for ws url");
+  }
+
+  @Test
+  public void testGetExplicitPort() {
+    String url = "http://hello.com/level1/level2/level3";
+    Uri uri = Uri.create(url);
+    assertEquals(uri.getExplicitPort(), 80, "getExplicitPort should return port 80 for http url when port is not specified in url");
+
+    String url2 = "http://hello.com:8080/level1/level2/level3";
+    Uri uri2 = Uri.create(url2);
+    assertEquals(uri2.getExplicitPort(), 8080, "getExplicitPort should return the port given in the url");
+  }
+
+  @Test
+  public void testEquals() {
+    String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+    Uri createdUri = Uri.create(url);
+    Uri constructedUri = new Uri("http", "user", "hello.com", 8080, "/level1/level2/level3", "q=1", null);
+    assertTrue(createdUri.equals(constructedUri), "The equals method returned false for two equal urls");
+  }
+
+  @Test
+  void testFragment() {
+    String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+    String fragment = "foo";
+    String urlWithFragment = url + "#" + fragment;
+    Uri uri = Uri.create(urlWithFragment);
+    assertEquals(fragment, uri.getFragment(), "Fragment should be extracted");
+    assertEquals(uri.toUrl(), url, "toUrl should return without fragment");
+    assertEquals(uri.toFullUrl(), urlWithFragment, "toFullUrl should return with fragment");
+  }
+
+  @Test
+  void testRelativeFragment() {
+    Uri uri = Uri.create(Uri.create("http://user@hello.com:8080"), "/level1/level2/level3?q=1#foo");
+    assertEquals("foo", uri.getFragment(), "fragment should be kept when computing a relative url");
+  }
+
+  @Test
+  public void testIsWebsocket() {
+    String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+    Uri uri = Uri.create(url);
+    assertFalse(uri.isWebSocket(), "isWebSocket should return false for http url");
+
+    url = "https://user@hello.com:8080/level1/level2/level3?q=1";
+    uri = Uri.create(url);
+    assertFalse(uri.isWebSocket(), "isWebSocket should return false for https url");
+
+    url = "ws://user@hello.com:8080/level1/level2/level3?q=1";
+    uri = Uri.create(url);
+    assertTrue(uri.isWebSocket(), "isWebSocket should return true for ws url");
+
+    url = "wss://user@hello.com:8080/level1/level2/level3?q=1";
+    uri = Uri.create(url);
+    assertTrue(uri.isWebSocket(), "isWebSocket should return true for wss url");
+  }
+
+  @Test
+  public void creatingUriWithDefinedSchemeAndHostWorks() {
+    Uri.create("http://localhost");
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void creatingUriWithMissingSchemeThrowsIllegalArgumentException() {
+    Uri.create("localhost");
+  }
+
+  @Test(expectedExceptions = IllegalArgumentException.class)
+  public void creatingUriWithMissingHostThrowsIllegalArgumentException() {
+    Uri.create("http://");
+  }
+
+  @Test
+  public void testGetAuthority() {
+    Uri uri = Uri.create("http://stackoverflow.com/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    assertEquals(uri.getAuthority(), "stackoverflow.com:80", "Incorrect authority returned from getAuthority");
+  }
+
+  @Test
+  public void testGetAuthorityWithPortInUrl() {
+    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    assertEquals(uri.getAuthority(), "stackoverflow.com:8443", "Incorrect authority returned from getAuthority");
+  }
+
+  @Test
+  public void testGetBaseUrl() {
+    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    assertEquals(uri.getBaseUrl(), "http://stackoverflow.com:8443", "Incorrect base URL returned from getBaseURL");
+  }
+
+  @Test
+  public void testIsSameBaseUrlReturnsFalseWhenPortDifferent() {
+    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    Uri uri2 = Uri.create("http://stackoverflow.com:8442/questions/1057564/pretty-git-branch-graphs");
+    assertFalse(uri1.isSameBase(uri2), "Base URLs should be different, but true was returned from isSameBase");
+  }
+
+  @Test
+  public void testIsSameBaseUrlReturnsFalseWhenSchemeDifferent() {
+    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    Uri uri2 = Uri.create("ws://stackoverflow.com:8443/questions/1057564/pretty-git-branch-graphs");
+    assertFalse(uri1.isSameBase(uri2), "Base URLs should be different, but true was returned from isSameBase");
+  }
+
+  @Test
+  public void testIsSameBaseUrlReturnsFalseWhenHostDifferent() {
+    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    Uri uri2 = Uri.create("http://example.com:8443/questions/1057564/pretty-git-branch-graphs");
+    assertFalse(uri1.isSameBase(uri2), "Base URLs should be different, but true was returned from isSameBase");
+  }
+
+  @Test
+  public void testIsSameBaseUrlReturnsTrueWhenOneUriHasDefaultPort() {
+    Uri uri1 = Uri.create("http://stackoverflow.com:80/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    Uri uri2 = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+    assertTrue(uri1.isSameBase(uri2), "Base URLs should be same, but false was returned from isSameBase");
+  }
+
+  @Test
+  public void testGetPathWhenPathIsNonEmpty() {
+    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+    assertEquals(uri.getNonEmptyPath(), "/questions/17814461/jacoco-maven-testng-0-test-coverage", "Incorrect path returned from getNonEmptyPath");
+  }
+
+  @Test
+  public void testGetPathWhenPathIsEmpty() {
+    Uri uri = Uri.create("http://stackoverflow.com");
+    assertEquals(uri.getNonEmptyPath(), "/", "Incorrect path returned from getNonEmptyPath");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
index 1e99c3b8b..aa9235101 100644
--- a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
+++ b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
@@ -13,18 +13,8 @@
  */
 package org.asynchttpclient.util;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.testng.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-
-import java.net.URLEncoder;
-import java.nio.ByteBuffer;
-import java.nio.charset.CharacterCodingException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-
 import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.asynchttpclient.Dsl;
 import org.asynchttpclient.Param;
@@ -33,200 +23,144 @@
 import org.asynchttpclient.uri.Uri;
 import org.testng.annotations.Test;
 
-public class HttpUtilsTest {
-
-    @Test
-    public void testGetAuthority() {
-        Uri uri = Uri.create("http://stackoverflow.com/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        String authority = HttpUtils.getAuthority(uri);
-        assertEquals(authority, "stackoverflow.com:80", "Incorrect authority returned from getAuthority");
-    }
-
-    @Test
-    public void testGetAuthorityWithPortInUrl() {
-        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        String authority = HttpUtils.getAuthority(uri);
-        assertEquals(authority, "stackoverflow.com:8443", "Incorrect authority returned from getAuthority");
-    }
-
-    @Test
-    public void testGetBaseUrl() {
-        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        String baseUrl = HttpUtils.getBaseUrl(uri);
-        assertEquals(baseUrl, "http://stackoverflow.com:8443", "Incorrect base URL returned from getBaseURL");
-    }
-
-    @Test
-    public void testIsSameBaseUrlReturnsFalseWhenPortDifferent() {
-        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        Uri uri2 = Uri.create("http://stackoverflow.com:8442/questions/1057564/pretty-git-branch-graphs");
-        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-    }
-
-    @Test
-    public void testIsSameBaseUrlReturnsFalseWhenSchemeDifferent() {
-        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        Uri uri2 = Uri.create("ws://stackoverflow.com:8443/questions/1057564/pretty-git-branch-graphs");
-        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-    }
-
-    @Test
-    public void testIsSameBaseUrlReturnsFalseWhenHostDifferent() {
-        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        Uri uri2 = Uri.create("http://example.com:8443/questions/1057564/pretty-git-branch-graphs");
-        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-    }
-
-    @Test
-    public void testGetPathWhenPathIsNonEmpty() {
-        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        String path = HttpUtils.getNonEmptyPath(uri);
-        assertEquals(path, "/questions/17814461/jacoco-maven-testng-0-test-coverage", "Incorrect path returned from getNonEmptyPath");
-    }
-
-    @Test
-    public void testGetPathWhenPathIsEmpty() {
-        Uri uri = Uri.create("http://stackoverflow.com");
-        String path = HttpUtils.getNonEmptyPath(uri);
-        assertEquals(path, "/", "Incorrect path returned from getNonEmptyPath");
-    }
-
-    @Test
-    public void testIsSameBaseUrlReturnsTrueWhenOneUriHasDefaultPort() {
-        Uri uri1 = Uri.create("http://stackoverflow.com:80/questions/17814461/jacoco-maven-testng-0-test-coverage");
-        Uri uri2 = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-        assertTrue(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be same, but false was returned from isSameBase");
-    }
-
-    @Test
-    public void testParseCharsetWithoutQuotes() {
-        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=utf-8");
-        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
-    }
-
-    @Test
-    public void testParseCharsetWithSingleQuotes() {
-        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset='utf-8'");
-        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
-    }
-
-    @Test
-    public void testParseCharsetWithDoubleQuotes() {
-        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=\"utf-8\"");
-        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
-    }
-
-    @Test
-    public void testParseCharsetReturnsNullWhenNoCharset() {
-        Charset charset = HttpUtils.parseCharset("Content-type: application/json");
-        assertNull(charset, "parseCharset should return null when charset is not specified in header value");
-    }
-
-    @Test
-    public void testGetHostHeaderNoVirtualHost() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs").build();
-        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-        String hostHeader = HttpUtils.hostHeader(request, uri);
-        assertEquals(hostHeader, "stackoverflow.com", "Incorrect hostHeader returned");
-    }
-
-    @Test
-    public void testGetHostHeaderHasVirtualHost() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
-        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-        String hostHeader = HttpUtils.hostHeader(request, uri);
-        assertEquals(hostHeader, "example.com", "Incorrect hostHeader returned");
-    }
-
-    @Test
-    public void testDefaultFollowRedirect() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
-        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
-        boolean followRedirect = HttpUtils.followRedirect(config, request);
-        assertFalse(followRedirect, "Default value of redirect should be false");
-    }
-
-    @Test
-    public void testGetFollowRedirectInRequest() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(true).build();
-        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
-        boolean followRedirect = HttpUtils.followRedirect(config, request);
-        assertTrue(followRedirect, "Follow redirect must be true as set in the request");
-    }
-
-    @Test
-    public void testGetFollowRedirectInConfig() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").build();
-        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        boolean followRedirect = HttpUtils.followRedirect(config, request);
-        assertTrue(followRedirect, "Follow redirect should be equal to value specified in config when not specified in request");
-    }
-
-    @Test
-    public void testGetFollowRedirectPriorityGivenToRequest() {
-        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(false).build();
-        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        boolean followRedirect = HttpUtils.followRedirect(config, request);
-        assertFalse(followRedirect, "Follow redirect value set in request should be given priority");
-    }
-
-    private void formUrlEncoding(Charset charset) throws Exception {
-        String key = "key";
-        String value = "中文";
-        List<Param> params = new ArrayList<>();
-        params.add(new Param(key, value));
-        ByteBuffer ahcBytes = HttpUtils.urlEncodeFormParams(params, charset);
-        String ahcString = toUsAsciiString(ahcBytes);
-        String jdkString = key + "=" + URLEncoder.encode(value, charset.name());
-        assertEquals(ahcString, jdkString);
-    }
-
-    @Test
-    public void formUrlEncodingShouldSupportUtf8Charset() throws Exception {
-        formUrlEncoding(UTF_8);
-    }
-
-    @Test
-    public void formUrlEncodingShouldSupportNonUtf8Charset() throws Exception {
-        formUrlEncoding(Charset.forName("GBK"));
-    }
-
-    private static String toUsAsciiString(ByteBuffer buf) throws CharacterCodingException {
-        ByteBuf bb = Unpooled.wrappedBuffer(buf);
-        try {
-            return ByteBufUtils.byteBuf2String(US_ASCII, bb);
-        } finally {
-            bb.release();
-        }
-    }
-
-    @Test
-    public void computeOriginForPlainUriWithImplicitPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com/bar")), "http://foo.com");
-    }
-
-    @Test
-    public void computeOriginForPlainUriWithDefaultPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:80/bar")), "http://foo.com");
-    }
-
-    @Test
-    public void computeOriginForPlainUriWithNonDefaultPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:81/bar")), "http://foo.com:81");
-    }
+import java.net.URLEncoder;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
 
-    @Test
-    public void computeOriginForSecuredUriWithImplicitPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com/bar")), "https://foo.com");
-    }
+import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_JSON;
+import static java.nio.charset.StandardCharsets.*;
+import static org.testng.Assert.*;
 
-    @Test
-    public void computeOriginForSecuredUriWithDefaultPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:443/bar")), "https://foo.com");
-    }
+public class HttpUtilsTest {
 
-    @Test
-    public void computeOriginForSecuredUriWithNonDefaultPort() {
-        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:444/bar")), "https://foo.com:444");
-    }
+  private static String toUsAsciiString(ByteBuffer buf) {
+    ByteBuf bb = Unpooled.wrappedBuffer(buf);
+    try {
+      return ByteBufUtils.byteBuf2String(US_ASCII, bb);
+    } finally {
+      bb.release();
+    }
+  }
+
+  @Test
+  public void testExtractCharsetWithoutQuotes() {
+    Charset charset = HttpUtils.extractContentTypeCharsetAttribute("text/html; charset=iso-8859-1");
+    assertEquals(charset, ISO_8859_1);
+  }
+
+  @Test
+  public void testExtractCharsetWithSingleQuotes() {
+    Charset charset = HttpUtils.extractContentTypeCharsetAttribute("text/html; charset='iso-8859-1'");
+    assertEquals(charset, ISO_8859_1);
+  }
+
+  @Test
+  public void testExtractCharsetWithDoubleQuotes() {
+    Charset charset = HttpUtils.extractContentTypeCharsetAttribute("text/html; charset=\"iso-8859-1\"");
+    assertEquals(charset, ISO_8859_1);
+  }
+
+  @Test
+  public void testExtractCharsetWithDoubleQuotesAndSpaces() {
+    Charset charset = HttpUtils.extractContentTypeCharsetAttribute("text/html; charset= \"iso-8859-1\" ");
+    assertEquals(charset, ISO_8859_1);
+  }
+
+  @Test
+  public void testExtractCharsetFallsBackToUtf8() {
+    Charset charset = HttpUtils.extractContentTypeCharsetAttribute(APPLICATION_JSON.toString());
+    assertNull(charset);
+  }
+
+  @Test
+  public void testGetHostHeader() {
+    Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+    String hostHeader = HttpUtils.hostHeader(uri);
+    assertEquals(hostHeader, "stackoverflow.com", "Incorrect hostHeader returned");
+  }
+
+  @Test
+  public void testDefaultFollowRedirect() {
+    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
+    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+    boolean followRedirect = HttpUtils.followRedirect(config, request);
+    assertFalse(followRedirect, "Default value of redirect should be false");
+  }
+
+  @Test
+  public void testGetFollowRedirectInRequest() {
+    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(true).build();
+    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+    boolean followRedirect = HttpUtils.followRedirect(config, request);
+    assertTrue(followRedirect, "Follow redirect must be true as set in the request");
+  }
+
+  @Test
+  public void testGetFollowRedirectInConfig() {
+    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").build();
+    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+    boolean followRedirect = HttpUtils.followRedirect(config, request);
+    assertTrue(followRedirect, "Follow redirect should be equal to value specified in config when not specified in request");
+  }
+
+  @Test
+  public void testGetFollowRedirectPriorityGivenToRequest() {
+    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(false).build();
+    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+    boolean followRedirect = HttpUtils.followRedirect(config, request);
+    assertFalse(followRedirect, "Follow redirect value set in request should be given priority");
+  }
+
+  private void formUrlEncoding(Charset charset) throws Exception {
+    String key = "key";
+    String value = "中文";
+    List<Param> params = new ArrayList<>();
+    params.add(new Param(key, value));
+    ByteBuffer ahcBytes = HttpUtils.urlEncodeFormParams(params, charset);
+    String ahcString = toUsAsciiString(ahcBytes);
+    String jdkString = key + "=" + URLEncoder.encode(value, charset.name());
+    assertEquals(ahcString, jdkString);
+  }
+
+  @Test
+  public void formUrlEncodingShouldSupportUtf8Charset() throws Exception {
+    formUrlEncoding(UTF_8);
+  }
+
+  @Test
+  public void formUrlEncodingShouldSupportNonUtf8Charset() throws Exception {
+    formUrlEncoding(Charset.forName("GBK"));
+  }
+
+  @Test
+  public void computeOriginForPlainUriWithImplicitPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("ws://foo.com/bar")), "http://foo.com");
+  }
+
+  @Test
+  public void computeOriginForPlainUriWithDefaultPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("ws://foo.com:80/bar")), "http://foo.com");
+  }
+
+  @Test
+  public void computeOriginForPlainUriWithNonDefaultPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("ws://foo.com:81/bar")), "http://foo.com:81");
+  }
+
+  @Test
+  public void computeOriginForSecuredUriWithImplicitPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("wss://foo.com/bar")), "https://foo.com");
+  }
+
+  @Test
+  public void computeOriginForSecuredUriWithDefaultPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("wss://foo.com:443/bar")), "https://foo.com");
+  }
+
+  @Test
+  public void computeOriginForSecuredUriWithNonDefaultPort() {
+    assertEquals(HttpUtils.originHeader(Uri.create("wss://foo.com:444/bar")), "https://foo.com:444");
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java b/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
deleted file mode 100644
index acdcf78ab..000000000
--- a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.util;
-
-import static org.testng.Assert.assertEquals;
-
-import org.testng.annotations.Test;
-
-public class TestUTF8UrlCodec {
-    @Test(groups = "standalone")
-    public void testBasics() {
-        assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
-        assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
-        assertEquals(Utf8UrlEncoder.encodeQueryElement("a+b"), "a%2Bb");
-    }
-
-    @Test(groups = "standalone")
-    public void testPercentageEncoding() {
-        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foobar"), "foobar");
-        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo*bar"), "foo%2Abar");
-        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo~b_ar"), "foo~b_ar");
-    }
-
-}
diff --git a/client/src/test/java/org/asynchttpclient/util/Utf8UrlEncoderTest.java b/client/src/test/java/org/asynchttpclient/util/Utf8UrlEncoderTest.java
new file mode 100644
index 000000000..044e9f286
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/util/Utf8UrlEncoderTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertEquals;
+
+public class Utf8UrlEncoderTest {
+  @Test
+  public void testBasics() {
+    assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
+    assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
+    assertEquals(Utf8UrlEncoder.encodeQueryElement("a+b"), "a%2Bb");
+  }
+
+  @Test
+  public void testPercentageEncoding() {
+    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foobar"), "foobar");
+    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo*bar"), "foo%2Abar");
+    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo~b_ar"), "foo~b_ar");
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java b/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
index d06090c06..adc12655e 100644
--- a/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
+++ b/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
@@ -12,18 +12,6 @@
  */
 package org.asynchttpclient.webdav;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.concurrent.ExecutionException;
-
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-
 import org.apache.catalina.Context;
 import org.apache.catalina.servlets.WebdavServlet;
 import org.apache.catalina.startup.Tomcat;
@@ -36,154 +24,166 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import java.io.File;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.concurrent.ExecutionException;
+
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
 public class WebdavTest {
 
-    private Tomcat tomcat;
-    private int port1;
-
-    @SuppressWarnings("serial")
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-
-        String path = new File(".").getAbsolutePath() + "/target";
-
-        tomcat = new Tomcat();
-        tomcat.setHostname("localhost");
-        tomcat.setPort(0);
-        tomcat.setBaseDir(path);
-        Context ctx = tomcat.addContext("", path);
-
-        Tomcat.addServlet(ctx, "webdav", new WebdavServlet() {
-            @Override
-            public void init(ServletConfig config) throws ServletException {
-
-                super.init(new ServletConfig() {
-
-                    @Override
-                    public String getServletName() {
-                        return config.getServletName();
-                    }
-
-                    @Override
-                    public ServletContext getServletContext() {
-                        return config.getServletContext();
-                    }
-
-                    @Override
-                    public Enumeration<String> getInitParameterNames() {
-                        // FIXME
-                        return config.getInitParameterNames();
-                    }
-
-                    @Override
-                    public String getInitParameter(String name) {
-                        switch (name) {
-                        case "readonly":
-                            return "false";
-                        case "listings":
-                            return "true";
-                        default:
-                            return config.getInitParameter(name);
-                        }
-                    }
-                });
+  private Tomcat tomcat;
+  private int port1;
+
+  @SuppressWarnings("serial")
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+
+    String path = new File(".").getAbsolutePath() + "/target";
+
+    tomcat = new Tomcat();
+    tomcat.setHostname("localhost");
+    tomcat.setPort(0);
+    tomcat.setBaseDir(path);
+    Context ctx = tomcat.addContext("", path);
+
+    Tomcat.addServlet(ctx, "webdav", new WebdavServlet() {
+      @Override
+      public void init(ServletConfig config) throws ServletException {
+
+        super.init(new ServletConfig() {
+
+          @Override
+          public String getServletName() {
+            return config.getServletName();
+          }
+
+          @Override
+          public ServletContext getServletContext() {
+            return config.getServletContext();
+          }
+
+          @Override
+          public Enumeration<String> getInitParameterNames() {
+            // FIXME
+            return config.getInitParameterNames();
+          }
+
+          @Override
+          public String getInitParameter(String name) {
+            switch (name) {
+              case "readonly":
+                return "false";
+              case "listings":
+                return "true";
+              default:
+                return config.getInitParameter(name);
             }
-
+          }
         });
-        ctx.addServletMappingDecoded("/*", "webdav");
-        tomcat.start();
-        port1 = tomcat.getConnector().getLocalPort();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws InterruptedException, Exception {
-        tomcat.stop();
-    }
-
-    private String getTargetUrl() {
-        return String.format("http://localhost:%s/folder1", port1);
-    }
-
-    @AfterMethod(alwaysRun = true)
-    public void clean() throws InterruptedException, Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.executeRequest(delete(getTargetUrl())).get();
-        }
+      }
+
+    });
+    ctx.addServletMappingDecoded("/*", "webdav");
+    tomcat.start();
+    port1 = tomcat.getConnector().getLocalPort();
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    tomcat.stop();
+  }
+
+  private String getTargetUrl() {
+    return String.format("http://localhost:%s/folder1", port1);
+  }
+
+  @AfterMethod(alwaysRun = true)
+  public void clean() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      c.executeRequest(delete(getTargetUrl())).get();
     }
-
-    @Test(groups = "standalone")
-    public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-            Response response = c.executeRequest(mkcolRequest).get();
-            assertEquals(response.getStatusCode(), 201);
-        }
+  }
+
+  @Test
+  public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+      Response response = c.executeRequest(mkcolRequest).get();
+      assertEquals(response.getStatusCode(), 201);
     }
-
-    @Test(groups = "standalone")
-    public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
-            Response response = c.executeRequest(mkcolRequest).get();
-            assertEquals(response.getStatusCode(), 409);
-        }
+  }
+
+  @Test
+  public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
+      Response response = c.executeRequest(mkcolRequest).get();
+      assertEquals(response.getStatusCode(), 409);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-            Response response = c.executeRequest(propFindRequest).get();
+  @Test
+  public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+      Response response = c.executeRequest(propFindRequest).get();
 
-            assertEquals(response.getStatusCode(), 404);
-        }
+      assertEquals(response.getStatusCode(), 404);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-            Response response = c.executeRequest(mkcolRequest).get();
-            assertEquals(response.getStatusCode(), 201);
+  @Test
+  public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+      Response response = c.executeRequest(mkcolRequest).get();
+      assertEquals(response.getStatusCode(), 201);
 
-            Request putRequest = put(getTargetUrl() + "/Test.txt").setBody("this is a test").build();
-            response = c.executeRequest(putRequest).get();
-            assertEquals(response.getStatusCode(), 201);
+      Request putRequest = put(getTargetUrl() + "/Test.txt").setBody("this is a test").build();
+      response = c.executeRequest(putRequest).get();
+      assertEquals(response.getStatusCode(), 201);
 
-            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl() + "/Test.txt").build();
-            response = c.executeRequest(propFindRequest).get();
+      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl() + "/Test.txt").build();
+      response = c.executeRequest(propFindRequest).get();
 
-            assertEquals(response.getStatusCode(), 207);
-            assertTrue(response.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
-        }
+      assertEquals(response.getStatusCode(), 207);
+      assertTrue(response.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
     }
+  }
+
+  @Test
+  public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+      Response response = c.executeRequest(mkcolRequest).get();
+      assertEquals(response.getStatusCode(), 201);
+
+      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+      WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onThrowable(Throwable t) {
+
+          t.printStackTrace();
+        }
 
-    @Test(groups = "standalone")
-    public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-            Response response = c.executeRequest(mkcolRequest).get();
-            assertEquals(response.getStatusCode(), 201);
-
-            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-            WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
-                /**
-                 * {@inheritDoc}
-                 */
-                @Override
-                public void onThrowable(Throwable t) {
-
-                    t.printStackTrace();
-                }
-
-                @Override
-                public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
-                    return response;
-                }
-            }).get();
-
-            assertEquals(webDavResponse.getStatusCode(), 207);
-            assertTrue(webDavResponse.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
+        @Override
+        public WebDavResponse onCompleted(WebDavResponse response) {
+          return response;
         }
+      }).get();
+
+      assertEquals(webDavResponse.getStatusCode(), 207);
+      assertTrue(webDavResponse.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
index a0296bb53..a6c98565c 100644
--- a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
@@ -12,8 +12,6 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -21,30 +19,32 @@
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.BeforeClass;
 
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+
 public abstract class AbstractBasicWebSocketTest extends AbstractBasicTest {
 
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(configureHandler());
-        server.start();
-        port1 = connector.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-    }
+  @BeforeClass(alwaysRun = true)
+  @Override
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(configureHandler());
+    server.start();
+    port1 = connector.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
+
+  protected String getTargetUrl() {
+    return String.format("ws://localhost:%d/", port1);
+  }
 
-    protected String getTargetUrl() {
-        return String.format("ws://localhost:%d/", port1);
-    }
-    
-    @Override
-    public WebSocketHandler configureHandler() {
-        return new WebSocketHandler() {
-            @Override
-            public void configure(WebSocketServletFactory factory) {
-                factory.register(EchoSocket.class);
-            }
-        };
-    }
+  @Override
+  public WebSocketHandler configureHandler() {
+    return new WebSocketHandler() {
+      @Override
+      public void configure(WebSocketServletFactory factory) {
+        factory.register(EchoWebSocket.class);
+      }
+    };
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
index 313113f0a..ef624af59 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
@@ -12,188 +12,199 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 import java.nio.charset.StandardCharsets;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertEquals;
 
 public class ByteMessageTest extends AbstractBasicWebSocketTest {
-    
-    private static final byte[] ECHO_BYTES = "ECHO".getBytes(StandardCharsets.UTF_8);
-
-    @Test(groups = "standalone")
-    public void echoByte() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<byte[]> text = new AtomicReference<>(new byte[0]);
-
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-                
-                @Override
-                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-                    text.set(frame);
-                    latch.countDown();
-                }
-            }).build()).get();
-
-            websocket.sendBinaryFrame(ECHO_BYTES);
-
-            latch.await();
-            assertEquals(text.get(), ECHO_BYTES);
+
+  private static final byte[] ECHO_BYTES = "ECHO".getBytes(StandardCharsets.UTF_8);
+
+  private void echoByte0(boolean enableCompression) throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setEnablewebSocketCompression(enableCompression))) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<byte[]> receivedBytes = new AtomicReference<>(new byte[0]);
+
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
+
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
         }
+
+        @Override
+        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+          receivedBytes.set(frame);
+          latch.countDown();
+        }
+      }).build()).get();
+
+      websocket.sendBinaryFrame(ECHO_BYTES);
+
+      latch.await();
+      assertEquals(receivedBytes.get(), ECHO_BYTES);
     }
+  }
+
+  @Test
+  public void echoByte() throws Exception {
+    echoByte0(false);
+  }
+
+  @Test
+  public void echoByteCompressed() throws Exception {
+    echoByte0(true);
+  }
+
+  @Test
+  public void echoTwoMessagesTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(2);
+      final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-    @Test(groups = "standalone")
-    public void echoTwoMessagesTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-
-                @Override
-                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-                    if (text.get() == null) {
-                        text.set(frame);
-                    } else {
-                        byte[] n = new byte[text.get().length + frame.length];
-                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
-                        text.set(n);
-                    }
-                    latch.countDown();
-                }
-
-            }).build()).get();
-
-            websocket.sendBinaryFrame(ECHO_BYTES);
-            websocket.sendBinaryFrame(ECHO_BYTES);
-
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO".getBytes());
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
         }
+
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+
+        @Override
+        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+          if (text.get() == null) {
+            text.set(frame);
+          } else {
+            byte[] n = new byte[text.get().length + frame.length];
+            System.arraycopy(text.get(), 0, n, 0, text.get().length);
+            System.arraycopy(frame, 0, n, text.get().length, frame.length);
+            text.set(n);
+          }
+          latch.countDown();
+        }
+
+      }).build()).get();
+
+      websocket.sendBinaryFrame(ECHO_BYTES);
+      websocket.sendBinaryFrame(ECHO_BYTES);
+
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
+  }
+
+  @Test
+  public void echoOnOpenMessagesTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(2);
+      final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(WebSocket websocket) {
+          websocket.sendBinaryFrame(ECHO_BYTES);
+          websocket.sendBinaryFrame(ECHO_BYTES);
+        }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-    @Test
-    public void echoOnOpenMessagesTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                    websocket.sendBinaryFrame(ECHO_BYTES);
-                    websocket.sendBinaryFrame(ECHO_BYTES);
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-
-                @Override
-                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-                    if (text.get() == null) {
-                        text.set(frame);
-                    } else {
-                        byte[] n = new byte[text.get().length + frame.length];
-                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
-                        text.set(n);
-                    }
-                    latch.countDown();
-                }
-
-            }).build()).get();
-
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO".getBytes());
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
         }
+
+        @Override
+        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+          if (text.get() == null) {
+            text.set(frame);
+          } else {
+            byte[] n = new byte[text.get().length + frame.length];
+            System.arraycopy(text.get(), 0, n, 0, text.get().length);
+            System.arraycopy(frame, 0, n, text.get().length, frame.length);
+            text.set(n);
+          }
+          latch.countDown();
+        }
+
+      }).build()).get();
+
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
+  }
 
-    public void echoFragments() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-
-                @Override
-                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-                    if (text.get() == null) {
-                        text.set(frame);
-                    } else {
-                        byte[] n = new byte[text.get().length + frame.length];
-                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
-                        text.set(n);
-                    }
-                    latch.countDown();
-                }
-
-            }).build()).get();
-            websocket.sendBinaryFrame(ECHO_BYTES, false, 0);
-            websocket.sendBinaryFrame(ECHO_BYTES, true, 0);
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO".getBytes());
+  @Test
+  public void echoFragments() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(WebSocket websocket) {
         }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
+
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+
+        @Override
+        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+          if (text.get() == null) {
+            text.set(frame);
+          } else {
+            byte[] n = new byte[text.get().length + frame.length];
+            System.arraycopy(text.get(), 0, n, 0, text.get().length);
+            System.arraycopy(frame, 0, n, text.get().length, frame.length);
+            text.set(n);
+          }
+          latch.countDown();
+        }
+
+      }).build()).get();
+      websocket.sendBinaryFrame(ECHO_BYTES, false, 0);
+      websocket.sendContinuationFrame(ECHO_BYTES, true, 0);
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 3a602783f..52aaefc3a 100644
--- a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -12,56 +12,54 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
 
 public class CloseCodeReasonMessageTest extends AbstractBasicWebSocketTest {
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onCloseWithCode() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+  @Test(timeOut = 60000)
+  public void onCloseWithCode() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
-            websocket.sendCloseFrame();
+      websocket.sendCloseFrame();
 
-            latch.await();
-            assertTrue(text.get().startsWith("1000"), "Expected a 1000 code but got " + text.get());
-        }
+      latch.await();
+      assertTrue(text.get().startsWith("1000"), "Expected a 1000 code but got " + text.get());
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onCloseWithCodeServerClose() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+  @Test(timeOut = 60000)
+  public void onCloseWithCodeServerClose() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
-            latch.await();
-            assertEquals(text.get(), "1001-Idle Timeout");
-        }
+      latch.await();
+      assertEquals(text.get(), "1001-Idle Timeout");
     }
+  }
 
-    public final static class Listener implements WebSocketListener {
-
-        final CountDownLatch latch;
-        final AtomicReference<String> text;
-
-        public Listener(CountDownLatch latch, AtomicReference<String> text) {
-            this.latch = latch;
-            this.text = text;
-        }
+  @Test(groups = "online", timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void getWebSocketThrowsException() throws Throwable {
+    final CountDownLatch latch = new CountDownLatch(1);
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
         @Override
         public void onOpen(WebSocket websocket) {
@@ -69,96 +67,100 @@ public void onOpen(WebSocket websocket) {
 
         @Override
         public void onClose(WebSocket websocket, int code, String reason) {
-            text.set(code + "-" + reason);
-            latch.countDown();
         }
 
         @Override
         public void onError(Throwable t) {
-            t.printStackTrace();
-            latch.countDown();
+          latch.countDown();
         }
+      }).build()).get();
     }
 
-    @Test(groups = "online", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void getWebSocketThrowsException() throws Throwable {
-        final CountDownLatch latch = new CountDownLatch(1);
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-                
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    latch.countDown();
-                }
-            }).build()).get();
+    latch.await();
+  }
+
+  @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalArgumentException.class)
+  public void wrongStatusCode() throws Throwable {
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<Throwable> throwable = new AtomicReference<>();
+
+      client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(org.asynchttpclient.ws.WebSocket websocket) {
         }
 
-        latch.await();
-    }
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+        }
 
-    @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalArgumentException.class)
-    public void wrongStatusCode() throws Throwable {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        @Override
+        public void onError(Throwable t) {
+          throwable.set(t);
+          latch.countDown();
+        }
+      }).build());
 
-            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      latch.await();
+      assertNotNull(throwable.get());
+      throw throwable.get();
+    }
+  }
 
-                @Override
-                public void onOpen(org.asynchttpclient.ws.WebSocket websocket) {
-                }
+  @Test(groups = "online", timeOut = 60000, expectedExceptions = IOException.class)
+  public void wrongProtocolCode() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<Throwable> throwable = new AtomicReference<>();
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                }
+      c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onError(Throwable t) {
-                    throwable.set(t);
-                    latch.countDown();
-                }
-            }).build());
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+        }
 
-            latch.await();
-            assertNotNull(throwable.get());
-            throw throwable.get();
+        @Override
+        public void onError(Throwable t) {
+          throwable.set(t);
+          latch.countDown();
         }
+      }).build());
+
+      latch.await();
+      assertNotNull(throwable.get());
+      throw throwable.get();
     }
+  }
 
-    @Test(groups = "online", timeOut = 60000, expectedExceptions = IOException.class)
-    public void wrongProtocolCode() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+  public final static class Listener implements WebSocketListener {
 
-            c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+    final CountDownLatch latch;
+    final AtomicReference<String> text;
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+    Listener(CountDownLatch latch, AtomicReference<String> text) {
+      this.latch = latch;
+      this.text = text;
+    }
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                }
+    @Override
+    public void onOpen(WebSocket websocket) {
+    }
 
-                @Override
-                public void onError(Throwable t) {
-                    throwable.set(t);
-                    latch.countDown();
-                }
-            }).build());
+    @Override
+    public void onClose(WebSocket websocket, int code, String reason) {
+      text.set(code + "-" + reason);
+      latch.countDown();
+    }
 
-            latch.await();
-            assertNotNull(throwable.get());
-            throw throwable.get();
-        }
+    @Override
+    public void onError(Throwable t) {
+      t.printStackTrace();
+      latch.countDown();
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java b/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
deleted file mode 100644
index e239e2a64..000000000
--- a/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.ws;
-
-import org.eclipse.jetty.websocket.api.Session;
-import org.eclipse.jetty.websocket.api.WebSocketAdapter;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-public class EchoSocket extends WebSocketAdapter {
-
-    @Override
-    public void onWebSocketConnect(Session sess) {
-        super.onWebSocketConnect(sess);
-        sess.setIdleTimeout(10000);
-    }
-
-    @Override
-    public void onWebSocketClose(int statusCode, String reason) {
-        getSession().close();
-        super.onWebSocketClose(statusCode, reason);
-    }
-
-    @Override
-    public void onWebSocketBinary(byte[] payload, int offset, int len) {
-        if (isNotConnected()) {
-            return;
-        }
-        try {
-            getRemote().sendBytes(ByteBuffer.wrap(payload, offset, len));
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public void onWebSocketText(String message) {
-        if (isNotConnected()) {
-            return;
-        }
-        try {
-            if (message.equals("CLOSE"))
-                getSession().close();
-            else
-                getRemote().sendString(message);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-}
diff --git a/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java b/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java
new file mode 100644
index 000000000..2ffeaa4ab
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.ws;
+
+import org.eclipse.jetty.websocket.api.Session;
+import org.eclipse.jetty.websocket.api.WebSocketAdapter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+public class EchoWebSocket extends WebSocketAdapter {
+
+  private static final Logger LOGGER = LoggerFactory.getLogger(EchoWebSocket.class);
+
+  @Override
+  public void onWebSocketConnect(Session sess) {
+    super.onWebSocketConnect(sess);
+    sess.setIdleTimeout(10000);
+  }
+
+  @Override
+  public void onWebSocketClose(int statusCode, String reason) {
+    getSession().close();
+    super.onWebSocketClose(statusCode, reason);
+  }
+
+  @Override
+  public void onWebSocketBinary(byte[] payload, int offset, int len) {
+    if (isNotConnected()) {
+      return;
+    }
+    try {
+      LOGGER.debug("Received binary frame of size {}: {}", len, new String(payload, offset, len, UTF_8));
+      getRemote().sendBytes(ByteBuffer.wrap(payload, offset, len));
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+
+  @Override
+  public void onWebSocketText(String message) {
+    if (isNotConnected()) {
+      return;
+    }
+
+    if (message.equals("CLOSE")) {
+      getSession().close();
+      return;
+    }
+
+    try {
+      LOGGER.debug("Received text frame of size: {}", message);
+      getRemote().sendString(message);
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+  }
+}
diff --git a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index ba2d7f01d..55b058a93 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -12,13 +12,6 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.eclipse.jetty.proxy.ConnectHandler;
@@ -27,86 +20,94 @@
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
+import static org.testng.Assert.assertEquals;
+
 /**
  * Proxy usage tests.
  */
 public class ProxyTunnellingTest extends AbstractBasicWebSocketTest {
 
-    private Server server2;
+  private Server server2;
 
-    public void setUpServers(boolean targetHttps) throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new ConnectHandler());
-        server.start();
-        port1 = connector.getLocalPort();
+  private void setUpServers(boolean targetHttps) throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(new ConnectHandler());
+    server.start();
+    port1 = connector.getLocalPort();
 
-        server2 = new Server();
-        @SuppressWarnings("resource")
-        ServerConnector connector2 = targetHttps ? addHttpsConnector(server2) : addHttpConnector(server2);
-        server2.setHandler(configureHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
+    server2 = new Server();
+    @SuppressWarnings("resource")
+    ServerConnector connector2 = targetHttps ? addHttpsConnector(server2) : addHttpConnector(server2);
+    server2.setHandler(configureHandler());
+    server2.start();
+    port2 = connector2.getLocalPort();
 
-        logger.info("Local HTTP server started successfully");
-    }
+    logger.info("Local HTTP server started successfully");
+  }
 
-    @AfterMethod(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-        server2.stop();
-    }
+  @AfterMethod(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    server.stop();
+    server2.stop();
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void echoWSText() throws Exception {
-        runTest(false);
-    }
+  @Test(timeOut = 60000)
+  public void echoWSText() throws Exception {
+    runTest(false);
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void echoWSSText() throws Exception {
-        runTest(true);
-    }
+  @Test(timeOut = 60000)
+  public void echoWSSText() throws Exception {
+    runTest(true);
+  }
 
-    private void runTest(boolean secure) throws Exception {
+  private void runTest(boolean secure) throws Exception {
 
-        setUpServers(secure);
+    setUpServers(secure);
 
-        String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
+    String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
 
-        // CONNECT happens over HTTP, not HTTPS
-        ProxyServer ps = proxyServer("localhost", port1).build();
-        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setUseInsecureTrustManager(true))) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+    // CONNECT happens over HTTP, not HTTPS
+    ProxyServer ps = proxyServer("localhost", port1).build();
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setUseInsecureTrustManager(true))) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(payload);
-                    latch.countDown();
-                }
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(payload);
+          latch.countDown();
+        }
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
 
-            websocket.sendTextFrame("ECHO");
+      websocket.sendTextFrame("ECHO");
 
-            latch.await();
-            assertEquals(text.get(), "ECHO");
-        }
+      latch.await();
+      assertEquals(text.get(), "ECHO");
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index 763848cc1..fd949fa25 100644
--- a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -13,18 +13,6 @@
 
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -34,66 +22,77 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
+
 public class RedirectTest extends AbstractBasicWebSocketTest {
 
-    @BeforeClass
-    @Override
-    public void setUpGlobal() throws Exception {
-
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        ServerConnector connector2 = addHttpConnector(server);
-
-        HandlerList list = new HandlerList();
-        list.addHandler(new AbstractHandler() {
-            @Override
-            public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
-                if (request.getLocalPort() == port2) {
-                    httpServletResponse.sendRedirect(getTargetUrl());
-                }
-            }
-        });
-        list.addHandler(configureHandler());
-        server.setHandler(list);
-
-        server.start();
-        port1 = connector1.getLocalPort();
-        port2 = connector2.getLocalPort();
-        logger.info("Local HTTP server started successfully");
-    }
+  @BeforeClass
+  @Override
+  public void setUpGlobal() throws Exception {
+
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    ServerConnector connector2 = addHttpConnector(server);
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void testRedirectToWSResource() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
-
-            WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                    text.set("OnOpen");
-                    latch.countDown();
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
-
-            latch.await();
-            assertEquals(text.get(), "OnOpen");
-            websocket.sendCloseFrame();
+    HandlerList list = new HandlerList();
+    list.addHandler(new AbstractHandler() {
+      @Override
+      public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException {
+        if (request.getLocalPort() == port2) {
+          httpServletResponse.sendRedirect(getTargetUrl());
+        }
+      }
+    });
+    list.addHandler(configureHandler());
+    server.setHandler(list);
+
+    server.start();
+    port1 = connector1.getLocalPort();
+    port2 = connector2.getLocalPort();
+    logger.info("Local HTTP server started successfully");
+  }
+
+  @Test(timeOut = 60000)
+  public void testRedirectToWSResource() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
+
+      WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+        @Override
+        public void onOpen(WebSocket websocket) {
+          text.set("OnOpen");
+          latch.countDown();
+        }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
         }
-    }
 
-    private String getRedirectURL() {
-        return String.format("ws://localhost:%d/", port2);
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
+
+      latch.await();
+      assertEquals(text.get(), "OnOpen");
+      websocket.sendCloseFrame();
     }
+  }
+
+  private String getRedirectURL() {
+    return String.format("ws://localhost:%d/", port2);
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
index 2da22ec79..d3249944d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
@@ -12,341 +12,344 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 import java.net.UnknownHostException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 
 public class TextMessageTest extends AbstractBasicWebSocketTest {
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onOpen() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
-
-            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+  @Test(timeOut = 60000)
+  public void onOpen() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                    text.set("OnOpen");
-                    latch.countDown();
-                }
+      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                }
+        @Override
+        public void onOpen(WebSocket websocket) {
+          text.set("OnOpen");
+          latch.countDown();
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+        }
 
-            latch.await();
-            assertEquals(text.get(), "OnOpen");
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
         }
+      }).build()).get();
+
+      latch.await();
+      assertEquals(text.get(), "OnOpen");
+    }
+  }
+
+  @Test(timeOut = 60000)
+  public void onEmptyListenerTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      WebSocket websocket = null;
+      try {
+        websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+      } catch (Throwable t) {
+        fail();
+      }
+      assertTrue(websocket != null);
     }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = UnknownHostException.class)
+  public void onFailureTest() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
+    } catch (ExecutionException e) {
+      throw e.getCause();
+    }
+  }
+
+  @Test(timeOut = 60000)
+  public void onTimeoutCloseTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
+
+      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onEmptyListenerTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            WebSocket websocket = null;
-            try {
-                websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
-            } catch (Throwable t) {
-                fail();
-            }
-            assertTrue(websocket != null);
+        @Override
+        public void onOpen(WebSocket websocket) {
         }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          text.set("OnClose");
+          latch.countDown();
+        }
+
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
+
+      latch.await();
+      assertEquals(text.get(), "OnClose");
     }
+  }
+
+  @Test(timeOut = 60000)
+  public void onClose() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
+
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = UnknownHostException.class)
-    public void onFailureTest() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
-        } catch (ExecutionException e) {
-            throw e.getCause();
+        @Override
+        public void onOpen(WebSocket websocket) {
         }
+
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          text.set("OnClose");
+          latch.countDown();
+        }
+
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
+
+      websocket.sendCloseFrame();
+
+      latch.await();
+      assertEquals(text.get(), "OnClose");
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onTimeoutCloseTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+  @Test(timeOut = 60000)
+  public void echoText() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(payload);
+          latch.countDown();
+        }
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    text.set("OnClose");
-                    latch.countDown();
-                }
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-            latch.await();
-            assertEquals(text.get(), "OnClose");
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
         }
+      }).build()).get();
+
+      websocket.sendTextFrame("ECHO");
+
+      latch.await();
+      assertEquals(text.get(), "ECHO");
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void onClose() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+  @Test(timeOut = 60000)
+  public void echoDoubleListenerText() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(2);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(payload);
+          latch.countDown();
+        }
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    text.set("OnClose");
-                    latch.countDown();
-                }
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-            websocket.sendCloseFrame();
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).addWebSocketListener(new WebSocketListener() {
 
-            latch.await();
-            assertEquals(text.get(), "OnClose");
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(text.get() + payload);
+          latch.countDown();
         }
-    }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void echoText() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(payload);
-                    latch.countDown();
-                }
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+      websocket.sendTextFrame("ECHO");
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO");
+    }
+  }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+  @Test
+  public void echoTwoMessagesTest() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(2);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            websocket.sendTextFrame("ECHO");
+      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-            latch.await();
-            assertEquals(text.get(), "ECHO");
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(text.get() + payload);
+          latch.countDown();
         }
-    }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void echoDoubleListenerText() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<String> text = new AtomicReference<>("");
-
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(payload);
-                    latch.countDown();
-                }
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(text.get() + payload);
-                    latch.countDown();
-                }
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
-
-            websocket.sendTextFrame("ECHO");
-
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO");
+        @Override
+        public void onOpen(WebSocket websocket) {
+          websocket.sendTextFrame("ECHO");
+          websocket.sendTextFrame("ECHO");
         }
-    }
 
-    @Test(groups = "standalone")
-    public void echoTwoMessagesTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<String> text = new AtomicReference<>("");
-
-            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(text.get() + payload);
-                    latch.countDown();
-                }
-
-                @Override
-                public void onOpen(WebSocket websocket) {
-                    websocket.sendTextFrame("ECHO");
-                    websocket.sendTextFrame("ECHO");
-                }
-
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
-
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
-
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO");
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
         }
-    }
 
-    public void echoFragments() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
+        }
+      }).build()).get();
 
-            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO");
+    }
+  }
 
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(payload);
-                    latch.countDown();
-                }
+  @Test
+  public void echoFragments() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch latch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    latch.countDown();
-                }
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(payload);
+          latch.countDown();
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    latch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-            websocket.sendTextFrame("ECHO", false, 0);
-            websocket.sendTextFrame("ECHO", true, 0);
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          latch.countDown();
+        }
 
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO");
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          latch.countDown();
         }
+      }).build()).get();
+
+      websocket.sendTextFrame("ECHO", false, 0);
+      websocket.sendContinuationFrame("ECHO", true, 0);
+
+      latch.await();
+      assertEquals(text.get(), "ECHOECHO");
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void echoTextAndThenClose() throws Throwable {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch textLatch = new CountDownLatch(1);
-            final CountDownLatch closeLatch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<>("");
+  @Test(timeOut = 60000)
+  public void echoTextAndThenClose() throws Throwable {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      final CountDownLatch textLatch = new CountDownLatch(1);
+      final CountDownLatch closeLatch = new CountDownLatch(1);
+      final AtomicReference<String> text = new AtomicReference<>("");
 
-            final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+      final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                @Override
-                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-                    text.set(text.get() + payload);
-                    textLatch.countDown();
-                }
+        @Override
+        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+          text.set(text.get() + payload);
+          textLatch.countDown();
+        }
 
-                @Override
-                public void onOpen(WebSocket websocket) {
-                }
+        @Override
+        public void onOpen(WebSocket websocket) {
+        }
 
-                @Override
-                public void onClose(WebSocket websocket, int code, String reason) {
-                    closeLatch.countDown();
-                }
+        @Override
+        public void onClose(WebSocket websocket, int code, String reason) {
+          closeLatch.countDown();
+        }
 
-                @Override
-                public void onError(Throwable t) {
-                    t.printStackTrace();
-                    closeLatch.countDown();
-                }
-            }).build()).get();
+        @Override
+        public void onError(Throwable t) {
+          t.printStackTrace();
+          closeLatch.countDown();
+        }
+      }).build()).get();
 
-            websocket.sendTextFrame("ECHO");
-            textLatch.await();
+      websocket.sendTextFrame("ECHO");
+      textLatch.await();
 
-            websocket.sendTextFrame("CLOSE");
-            closeLatch.await();
+      websocket.sendTextFrame("CLOSE");
+      closeLatch.await();
 
-            assertEquals(text.get(), "ECHO");
-        }
+      assertEquals(text.get(), "ECHO");
     }
+  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java b/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
index 90253fbd8..a3b0ac53a 100644
--- a/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
@@ -13,156 +13,156 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
+import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.eclipse.jetty.websocket.server.WebSocketHandler;
-import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 
 public class WebSocketWriteFutureTest extends AbstractBasicWebSocketTest {
 
-    @Override
-    public WebSocketHandler configureHandler() {
-        return new WebSocketHandler() {
-            @Override
-            public void configure(WebSocketServletFactory factory) {
-                factory.register(EchoSocket.class);
-            }
-        };
+  @Override
+  public WebSocketHandler configureHandler() {
+    return new WebSocketHandler() {
+      @Override
+      public void configure(WebSocketServletFactory factory) {
+        factory.register(EchoWebSocket.class);
+      }
+    };
+  }
+
+  @Test(timeOut = 60000)
+  public void sendTextMessage() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", timeOut = 60000)
-    public void sendTextMessage() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void sendTextMessageExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void sendTextMessageExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
-        }
+  @Test(timeOut = 60000)
+  public void sendByteMessage() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", timeOut = 60000)
-    public void sendByteMessage() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void sendByteMessageExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void sendByteMessageExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
-        }
+  @Test(timeOut = 60000)
+  public void sendPingMessage() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", timeOut = 60000)
-    public void sendPingMessage() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
-        }
-    }
-
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void sendPingMessageExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void sendPingMessageExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void sendPongMessage() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendPongFrame("PONG".getBytes()).get(10, TimeUnit.SECONDS);
-        }
+  @Test(timeOut = 60000)
+  public void sendPongMessage() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendPongFrame("PONG".getBytes()).get(10, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void sendPongMessageExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendPongFrame("PONG".getBytes()).get(1, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void sendPongMessageExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendPongFrame("PONG".getBytes()).get(1, TimeUnit.SECONDS);
     }
+  }
 
-    @Test(groups = "standalone", timeOut = 60000)
-    public void streamBytes() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
-        }
+  @Test(timeOut = 60000)
+  public void streamBytes() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
-    public void streamBytesExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
+  public void streamBytesExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void streamText() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            getWebSocket(c).sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
-        }
+  @Test
+  public void streamText() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      getWebSocket(c).sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
     }
-
-    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
-    public void streamTextExpectFailure() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            CountDownLatch closeLatch = new CountDownLatch(1);
-            WebSocket websocket = getWebSocket(c, closeLatch);
-            websocket.sendCloseFrame();
-            closeLatch.await(1, TimeUnit.SECONDS);
-            websocket.sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
-        }
+  }
+
+  @Test(expectedExceptions = ExecutionException.class)
+  public void streamTextExpectFailure() throws Exception {
+    try (AsyncHttpClient c = asyncHttpClient()) {
+      CountDownLatch closeLatch = new CountDownLatch(1);
+      WebSocket websocket = getWebSocket(c, closeLatch);
+      websocket.sendCloseFrame();
+      closeLatch.await(1, TimeUnit.SECONDS);
+      websocket.sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
     }
+  }
 
-    private WebSocket getWebSocket(final AsyncHttpClient c) throws Exception {
-        return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
-    }
+  private WebSocket getWebSocket(final AsyncHttpClient c) throws Exception {
+    return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+  }
 
-    private WebSocket getWebSocket(final AsyncHttpClient c, CountDownLatch closeLatch) throws Exception {
-        return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+  private WebSocket getWebSocket(final AsyncHttpClient c, CountDownLatch closeLatch) throws Exception {
+    return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-            @Override
-            public void onOpen(WebSocket websocket) {
-            }
+      @Override
+      public void onOpen(WebSocket websocket) {
+      }
 
-            @Override
-            public void onError(Throwable t) {
-            }
+      @Override
+      public void onError(Throwable t) {
+      }
 
-            @Override
-            public void onClose(WebSocket websocket, int code, String reason) {
-                closeLatch.countDown();
-            }
-        }).build()).get();
-    }
+      @Override
+      public void onClose(WebSocket websocket, int code, String reason) {
+        closeLatch.countDown();
+      }
+    }).build()).get();
+  }
 }
diff --git a/client/src/test/resources/empty.txt b/client/src/test/resources/empty.txt
new file mode 100644
index 000000000..e69de29bb
diff --git a/client/src/test/resources/kerberos.jaas b/client/src/test/resources/kerberos.jaas
new file mode 100644
index 000000000..cd5b316bf
--- /dev/null
+++ b/client/src/test/resources/kerberos.jaas
@@ -0,0 +1,8 @@
+
+alice {
+    com.sun.security.auth.module.Krb5LoginModule required refreshKrb5Config=true useKeyTab=false principal="alice";
+};
+
+bob {
+    com.sun.security.auth.module.Krb5LoginModule required refreshKrb5Config=true useKeyTab=false storeKey=true principal="bob/service.ws.apache.org";
+};
diff --git a/client/src/test/resources/logback-test.xml b/client/src/test/resources/logback-test.xml
index 0126d3538..8a4aafcd9 100644
--- a/client/src/test/resources/logback-test.xml
+++ b/client/src/test/resources/logback-test.xml
@@ -1,14 +1,14 @@
 <configuration>
-	<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
-		<layout class="ch.qos.logback.classic.PatternLayout">
-			<Pattern>%d [%thread] %level %logger - %m%n</Pattern>
-		</layout>
-	</appender>
+  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
+    <layout class="ch.qos.logback.classic.PatternLayout">
+      <Pattern>%d [%thread] %level %logger - %m%n</Pattern>
+    </layout>
+  </appender>
 
-	<logger name="org.eclipse" level="INFO" />
-	<logger name="org.apache" level="INFO" />
+  <logger name="org.eclipse" level="INFO"/>
+  <logger name="org.apache" level="INFO"/>
 
-	<root level="DEBUG">
-		<appender-ref ref="CONSOLE" />
-	</root>
+  <root level="DEBUG">
+    <appender-ref ref="CONSOLE"/>
+  </root>
 </configuration>
diff --git a/example/pom.xml b/example/pom.xml
index 1e1eacaee..9b01614c7 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -1,21 +1,21 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-project</artifactId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-example</artifactId>
-    <name>Asynchronous Http Client Example</name>
-    <packaging>jar</packaging>
-    <description>
-        The Async Http Client example.
-    </description>
-    <dependencies>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-    </dependencies>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-project</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client-example</artifactId>
+  <name>Asynchronous Http Client Example</name>
+  <packaging>jar</packaging>
+  <description>
+    The Async Http Client example.
+  </description>
+  <dependencies>
+    <dependency>
+      <groupId>org.asynchttpclient</groupId>
+      <artifactId>async-http-client</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
index 172876113..f8a5eb1c0 100644
--- a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
+++ b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
@@ -24,15 +24,15 @@
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 
 public class CompletableFutures {
-    public static void main(String[] args) throws IOException {
-        try(AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
-            asyncHttpClient
-                    .prepareGet("http://www.example.com/")
-                    .execute()
-                    .toCompletableFuture()
-                    .thenApply(Response::getResponseBody)
-                    .thenAccept(System.out::println)
-                    .join();
-        }
+  public static void main(String[] args) throws IOException {
+    try (AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
+      asyncHttpClient
+              .prepareGet("http://www.example.com/")
+              .execute()
+              .toCompletableFuture()
+              .thenApply(Response::getResponseBody)
+              .thenAccept(System.out::println)
+              .join();
     }
+  }
 }
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 76c56ec76..19868a8d0 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -1,21 +1,21 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-extras-guava</artifactId>
-    <name>Asynchronous Http Client Guava Extras</name>
-    <description>
-        The Async Http Client Guava Extras.
-    </description>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client-extras-guava</artifactId>
+  <name>Asynchronous Http Client Guava Extras</name>
+  <description>
+    The Async Http Client Guava Extras.
+  </description>
 
-    <dependencies>
-        <dependency>
-            <groupId>com.google.guava</groupId>
-            <artifactId>guava</artifactId>
-            <version>14.0.1</version>
-        </dependency>
-    </dependencies>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>14.0.1</version>
+    </dependency>
+  </dependencies>
 </project>
\ No newline at end of file
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
index 50807a4f4..5138a224e 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
@@ -21,38 +21,38 @@
 
 public final class ListenableFutureAdapter {
 
-    /**
-     * @param future an AHC ListenableFuture
-     * @param <V> the Future's value type
-     * @return a Guava ListenableFuture
-     */
-    public static <V> com.google.common.util.concurrent.ListenableFuture<V> asGuavaFuture(final ListenableFuture<V> future) {
-
-        return new com.google.common.util.concurrent.ListenableFuture<V>() {
-
-            public boolean cancel(boolean mayInterruptIfRunning) {
-                return future.cancel(mayInterruptIfRunning);
-            }
-
-            public V get() throws InterruptedException, ExecutionException {
-                return future.get();
-            }
-
-            public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-                return future.get(timeout, unit);
-            }
-
-            public boolean isCancelled() {
-                return future.isCancelled();
-            }
-
-            public boolean isDone() {
-                return future.isDone();
-            }
-
-            public void addListener(final Runnable runnable, final Executor executor) {
-                future.addListener(runnable, executor);
-            }
-        };
-    }
+  /**
+   * @param future an AHC ListenableFuture
+   * @param <V>    the Future's value type
+   * @return a Guava ListenableFuture
+   */
+  public static <V> com.google.common.util.concurrent.ListenableFuture<V> asGuavaFuture(final ListenableFuture<V> future) {
+
+    return new com.google.common.util.concurrent.ListenableFuture<V>() {
+
+      public boolean cancel(boolean mayInterruptIfRunning) {
+        return future.cancel(mayInterruptIfRunning);
+      }
+
+      public V get() throws InterruptedException, ExecutionException {
+        return future.get();
+      }
+
+      public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+        return future.get(timeout, unit);
+      }
+
+      public boolean isCancelled() {
+        return future.isCancelled();
+      }
+
+      public boolean isDone() {
+        return future.isDone();
+      }
+
+      public void addListener(final Runnable runnable, final Executor executor) {
+        future.addListener(runnable, executor);
+      }
+    };
+  }
 }
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
index 3da30e110..102b03df8 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -1,15 +1,10 @@
 package org.asynchttpclient.extras.guava;
 
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.ReleasePermitOnComplete;
-import org.asynchttpclient.filter.RequestFilter;
-import org.asynchttpclient.filter.ThrottleRequestFilter;
+import com.google.common.util.concurrent.RateLimiter;
+import org.asynchttpclient.filter.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.util.concurrent.RateLimiter;
-
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
@@ -17,79 +12,79 @@
  * A {@link org.asynchttpclient.filter.RequestFilter} that extends the capability of
  * {@link ThrottleRequestFilter} by allowing rate limiting per second in addition to the
  * number of concurrent connections.
- * 
- *  The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For 
- *  example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
- *  it will only spend another 500 ms waiting for the rate limiter.
+ * <p>
+ * The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For
+ * example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
+ * it will only spend another 500 ms waiting for the rate limiter.
  */
 public class RateLimitedThrottleRequestFilter implements RequestFilter {
-    private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
-    private final Semaphore available;
-    private final int maxWaitMs;
-    private final RateLimiter rateLimiter;
-
-    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
-        this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
-    }
-
-    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
-        this.maxWaitMs = maxWaitMs;
-        this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
-        available = new Semaphore(maxConnections, true);
+  private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
+  private final Semaphore available;
+  private final int maxWaitMs;
+  private final RateLimiter rateLimiter;
+
+  public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
+    this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
+  }
+
+  public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
+    this.maxWaitMs = maxWaitMs;
+    this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
+    available = new Semaphore(maxConnections, true);
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+    try {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Current Throttling Status {}", available.availablePermits());
+      }
+
+      long startOfWait = System.currentTimeMillis();
+      attemptConcurrencyPermitAcquistion(ctx);
+
+      attemptRateLimitedPermitAcquistion(ctx, startOfWait);
+    } catch (InterruptedException e) {
+      throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-        try {
-            if (logger.isDebugEnabled()) {
-                logger.debug("Current Throttling Status {}", available.availablePermits());
-            }
+    return new FilterContext.FilterContextBuilder<>(ctx)
+            .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
+            .build();
+  }
 
-            long startOfWait = System.currentTimeMillis();
-            attemptConcurrencyPermitAcquistion(ctx);
+  private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
+    long wait = getMillisRemainingInMaxWait(startOfWait);
 
-            attemptRateLimitedPermitAcquistion(ctx, startOfWait);
-        } catch (InterruptedException e) {
-            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
-        }
-
-        return new FilterContext.FilterContextBuilder<>(ctx)
-              .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
-              .build();
+    if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
+      throw new FilterException(String.format("Wait for rate limit exceeded during processing Request %s with AsyncHandler %s",
+              ctx.getRequest(), ctx.getAsyncHandler()));
     }
+  }
 
-    private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
-        long wait = getMillisRemainingInMaxWait(startOfWait);
-
-        if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
-            throw new FilterException(String.format("Wait for rate limit exceeded during processing Request %s with AsyncHandler %s",
-                    ctx.getRequest(), ctx.getAsyncHandler()));
-        }
+  private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException, FilterException {
+    if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
+      throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
+              ctx.getAsyncHandler()));
     }
-
-    private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException, FilterException {
-        if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
-            throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
-                    ctx.getAsyncHandler()));
-        }
+  }
+
+  private long getMillisRemainingInMaxWait(long startOfWait) {
+    int MINUTE_IN_MILLIS = 60000;
+    long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
+    long nonNegativeDuration = Math.max(durationLeft, 0);
+
+    // have to reduce the duration because there is a boundary case inside the Guava
+    // rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
+    // limiter's internal calculations can exceed Long.MAX_VALUE resulting in a
+    // negative number which causes the tryAcquire() method to fail unexpectedly
+    if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
+      return nonNegativeDuration - MINUTE_IN_MILLIS;
     }
 
-    private long getMillisRemainingInMaxWait(long startOfWait) {
-        int MINUTE_IN_MILLIS = 60000;
-        long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
-        long nonNegativeDuration = Math.max(durationLeft, 0);
-
-        // have to reduce the duration because there is a boundary case inside the Guava
-        // rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
-        // limiter's internal calculations can exceed Long.MAX_VALUE resulting in a 
-        // negative number which causes the tryAcquire() method to fail unexpectedly
-        if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
-            return nonNegativeDuration - MINUTE_IN_MILLIS;
-        }
-
-        return nonNegativeDuration;
-    }
+    return nonNegativeDuration;
+  }
 }
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 1734d2b3d..f761ef198 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,16 +18,16 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.1.0-SNAPSHOT</version>
+    <version>2.8.2-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
   <description>The Async Http Client jDeffered Extras.</description>
   <dependencies>
-        <dependency>
-            <groupId>org.jdeferred</groupId>
-            <artifactId>jdeferred-core</artifactId>
-            <version>1.2.4</version>
-        </dependency>
-    </dependencies>
+    <dependency>
+      <groupId>org.jdeferred</groupId>
+      <artifactId>jdeferred-core</artifactId>
+      <version>1.2.6</version>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
index ce4500799..968a5bd01 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,45 +15,41 @@
  */
 package org.asynchttpclient.extras.jdeferred;
 
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
 import org.jdeferred.Promise;
 import org.jdeferred.impl.DeferredObject;
 
 import java.io.IOException;
 
 public class AsyncHttpDeferredObject extends DeferredObject<Response, Throwable, HttpProgress> {
-    public AsyncHttpDeferredObject(BoundRequestBuilder builder) throws IOException {
-        builder.execute(new AsyncCompletionHandler<Void>() {
-            @Override
-            public Void onCompleted(Response response) throws Exception {
-                AsyncHttpDeferredObject.this.resolve(response);
-                return null;
-            }
+  public AsyncHttpDeferredObject(BoundRequestBuilder builder) {
+    builder.execute(new AsyncCompletionHandler<Void>() {
+      @Override
+      public Void onCompleted(Response response) {
+        AsyncHttpDeferredObject.this.resolve(response);
+        return null;
+      }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                AsyncHttpDeferredObject.this.reject(t);
-            }
+      @Override
+      public void onThrowable(Throwable t) {
+        AsyncHttpDeferredObject.this.reject(t);
+      }
 
-            @Override
-            public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
-                AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
-                return super.onContentWriteProgress(amount, current, total);
-            }
+      @Override
+      public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
+        AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
+        return super.onContentWriteProgress(amount, current, total);
+      }
 
-            @Override
-            public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
-                return super.onBodyPartReceived(content);
-            }
-        });
-    }
+      @Override
+      public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+        AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
+        return super.onBodyPartReceived(content);
+      }
+    });
+  }
 
-    public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) throws IOException {
-        return new AsyncHttpDeferredObject(builder).promise();
-    }
+  public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) {
+    return new AsyncHttpDeferredObject(builder).promise();
+  }
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
index b07a76d3f..13fd1d3c7 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,30 +16,30 @@
 package org.asynchttpclient.extras.jdeferred;
 
 public class ContentWriteProgress implements HttpProgress {
-    private final long amount;
-    private final long current;
-    private final long total;
+  private final long amount;
+  private final long current;
+  private final long total;
 
-    public ContentWriteProgress(long amount, long current, long total) {
-        this.amount = amount;
-        this.current = current;
-        this.total = total;
-    }
+  public ContentWriteProgress(long amount, long current, long total) {
+    this.amount = amount;
+    this.current = current;
+    this.total = total;
+  }
 
-    public long getAmount() {
-        return amount;
-    }
+  public long getAmount() {
+    return amount;
+  }
 
-    public long getCurrent() {
-        return current;
-    }
+  public long getCurrent() {
+    return current;
+  }
 
-    public long getTotal() {
-        return total;
-    }
+  public long getTotal() {
+    return total;
+  }
 
-    @Override
-    public String toString() {
-        return "ContentWriteProgress [amount=" + amount + ", current=" + current + ", total=" + total + "]";
-    }
+  @Override
+  public String toString() {
+    return "ContentWriteProgress [amount=" + amount + ", current=" + current + ", total=" + total + "]";
+  }
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
index 8ff478856..d757d6422 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
index 7137c5469..6263812d5 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,18 +18,18 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 
 public class HttpResponseBodyPartProgress implements HttpProgress {
-    private final HttpResponseBodyPart part;
+  private final HttpResponseBodyPart part;
 
-    public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
-        this.part = part;
-    }
+  public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
+    this.part = part;
+  }
 
-    public HttpResponseBodyPart getPart() {
-        return part;
-    }
+  public HttpResponseBodyPart getPart() {
+    return part;
+  }
 
-    @Override
-    public String toString() {
-        return "HttpResponseBodyPartProgress [part=" + part + "]";
-    }
+  @Override
+  public String toString() {
+    return "HttpResponseBodyPartProgress [part=" + part + "]";
+  }
 }
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
index f684b7666..c9fd72521 100644
--- a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
+++ b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,13 +15,6 @@
  */
 package org.asynchttpclient.extra;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.extras.jdeferred.AsyncHttpDeferredObject;
@@ -32,68 +25,76 @@
 import org.jdeferred.impl.DefaultDeferredManager;
 import org.jdeferred.multiple.MultipleResults;
 
-public class AsyncHttpTest {
-    protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
-    public void testPromiseAdapter() throws IOException {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicInteger successCount = new AtomicInteger();
-        final AtomicInteger progressCount = new AtomicInteger();
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-            p1.done(new DoneCallback<Response>() {
-                @Override
-                public void onDone(Response response) {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        successCount.incrementAndGet();
-                    } finally {
-                        latch.countDown();
-                    }
-                }
-            }).progress(new ProgressCallback<HttpProgress>() {
+public class AsyncHttpTest {
+  protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
 
-                @Override
-                public void onProgress(HttpProgress progress) {
-                    progressCount.incrementAndGet();
-                }
-            });
+  public void testPromiseAdapter() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicInteger successCount = new AtomicInteger();
+    final AtomicInteger progressCount = new AtomicInteger();
 
-            latch.await();
-            assertTrue(progressCount.get() > 0);
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
+      p1.done(new DoneCallback<Response>() {
+        @Override
+        public void onDone(Response response) {
+          try {
+            assertEquals(response.getStatusCode(), 200);
+            successCount.incrementAndGet();
+          } finally {
+            latch.countDown();
+          }
         }
-    }
+      }).progress(new ProgressCallback<HttpProgress>() {
 
-    public void testMultiplePromiseAdapter() throws IOException {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicInteger successCount = new AtomicInteger();
+        @Override
+        public void onProgress(HttpProgress progress) {
+          progressCount.incrementAndGet();
+        }
+      });
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-            Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
-            AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
+      latch.await();
+      assertTrue(progressCount.get() > 0);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  public void testMultiplePromiseAdapter() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicInteger successCount = new AtomicInteger();
 
-            deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
-                @Override
-                public void onDone(MultipleResults result) {
-                    try {
-                        assertEquals(result.size(), 3);
-                        assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
-                        assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
-                        assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
-                        successCount.incrementAndGet();
-                    } finally {
-                        latch.countDown();
-                    }
-                }
-            });
-            latch.await();
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
+      Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
+      AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
 
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
+      deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
+        @Override
+        public void onDone(MultipleResults result) {
+          try {
+            assertEquals(result.size(), 3);
+            assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
+            assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
+            assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
+            successCount.incrementAndGet();
+          } finally {
+            latch.countDown();
+          }
         }
+      });
+      latch.await();
+
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
     }
+  }
 }
diff --git a/extras/pom.xml b/extras/pom.xml
index 63af14a83..dfc199fd1 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -1,39 +1,40 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-project</artifactId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <name>Asynchronous Http Client Extras Parent</name>
-    <packaging>pom</packaging>
-    <description>
-        The Async Http Client extras library parent.
-    </description>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-project</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client-extras-parent</artifactId>
+  <name>Asynchronous Http Client Extras Parent</name>
+  <packaging>pom</packaging>
+  <description>
+    The Async Http Client extras library parent.
+  </description>
 
-    <modules>
-        <module>guava</module>
-        <module>jdeferred</module>
-        <module>registry</module>
-        <module>rxjava</module>
-        <module>rxjava2</module>
-        <module>simple</module>
-        <module>retrofit2</module>
-    </modules>
+  <modules>
+    <module>guava</module>
+    <module>jdeferred</module>
+    <module>registry</module>
+    <module>rxjava</module>
+    <module>rxjava2</module>
+    <module>simple</module>
+    <module>retrofit2</module>
+    <module>typesafeconfig</module>
+  </modules>
 
-    <dependencies>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-            <classifier>tests</classifier>
-        </dependency>
-    </dependencies>
+  <dependencies>
+    <dependency>
+      <groupId>org.asynchttpclient</groupId>
+      <artifactId>async-http-client</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.asynchttpclient</groupId>
+      <artifactId>async-http-client</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+      <classifier>tests</classifier>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 49d0318db..ef075a21c 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -1,13 +1,13 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<parent>
-		<groupId>org.asynchttpclient</groupId>
-		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.1.0-SNAPSHOT</version>
-	</parent>
-	<modelVersion>4.0.0</modelVersion>
-	<artifactId>async-http-client-extras-registry</artifactId>
-	<name>Asynchronous Http Client Registry Extras</name>
-	<description>
-        The Async Http Client Registry Extras.
-    </description>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client-extras-registry</artifactId>
+  <name>Asynchronous Http Client Registry Extras</name>
+  <description>
+    The Async Http Client Registry Extras.
+  </description>
 </project>
\ No newline at end of file
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 941208730..1d56b3b96 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,19 +12,18 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-
-import java.lang.reflect.Constructor;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.lang.reflect.Constructor;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+
 /**
  * The AsyncHttpClientFactory returns back an instance of AsyncHttpClient. The
  * actual instance is determined by the system property
@@ -40,51 +39,51 @@
  */
 public class AsyncHttpClientFactory {
 
-    private static Class<AsyncHttpClient> asyncHttpClientImplClass = null;
-    private static volatile boolean instantiated = false;
-    public static final Logger logger = LoggerFactory.getLogger(AsyncHttpClientFactory.class);
-    private static Lock lock = new ReentrantLock();
+  public static final Logger logger = LoggerFactory.getLogger(AsyncHttpClientFactory.class);
+  private static Class<AsyncHttpClient> asyncHttpClientImplClass = null;
+  private static volatile boolean instantiated = false;
+  private static Lock lock = new ReentrantLock();
 
-    public static AsyncHttpClient getAsyncHttpClient() {
+  public static AsyncHttpClient getAsyncHttpClient() {
 
-        try {
-            if (attemptInstantiation())
-                return asyncHttpClientImplClass.newInstance();
-        } catch (InstantiationException e) {
-            throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
-                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
-        } catch (IllegalAccessException e) {
-            throw new AsyncHttpClientImplException("Unable to find the class specified by system property : "
-                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
-        }
-        return asyncHttpClient();
+    try {
+      if (attemptInstantiation())
+        return asyncHttpClientImplClass.newInstance();
+    } catch (InstantiationException e) {
+      throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
+              + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+    } catch (IllegalAccessException e) {
+      throw new AsyncHttpClientImplException("Unable to find the class specified by system property : "
+              + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
     }
+    return asyncHttpClient();
+  }
 
-    public static AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (attemptInstantiation()) {
-            try {
-                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpClientConfig.class);
-                return constructor.newInstance(config);
-            } catch (Exception e) {
-                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
-                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
-            }
-        }
-        return asyncHttpClient(config);
+  public static AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+    if (attemptInstantiation()) {
+      try {
+        Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpClientConfig.class);
+        return constructor.newInstance(config);
+      } catch (Exception e) {
+        throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+      }
     }
+    return asyncHttpClient(config);
+  }
 
-    private static boolean attemptInstantiation() {
+  private static boolean attemptInstantiation() {
+    if (!instantiated) {
+      lock.lock();
+      try {
         if (!instantiated) {
-            lock.lock();
-            try {
-                if (!instantiated) {
-                    asyncHttpClientImplClass = AsyncImplHelper.getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-                    instantiated = true;
-                }
-            } finally {
-                lock.unlock();
-            }
+          asyncHttpClientImplClass = AsyncImplHelper.getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+          instantiated = true;
         }
-        return asyncHttpClientImplClass != null;
+      } finally {
+        lock.unlock();
+      }
     }
+    return asyncHttpClientImplClass != null;
+  }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
index f59bf0698..1f57f95c6 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -15,11 +15,11 @@
 @SuppressWarnings("serial")
 public class AsyncHttpClientImplException extends RuntimeException {
 
-    public AsyncHttpClientImplException(String msg) {
-        super(msg);
-    }
+  public AsyncHttpClientImplException(String msg) {
+    super(msg);
+  }
 
-    public AsyncHttpClientImplException(String msg, Exception e) {
-        super(msg, e);
-    }
+  public AsyncHttpClientImplException(String msg, Exception e) {
+    super(msg, e);
+  }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
index 60fa3170d..99279b52e 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -18,64 +18,64 @@
 
 public interface AsyncHttpClientRegistry {
 
-    /**
-     * Returns back the AsyncHttpClient associated with this name
-     * 
-     * @param name the name of the client instance in the registry
-     * @return the client
-     */
-    AsyncHttpClient get(String name);
+  /**
+   * Returns back the AsyncHttpClient associated with this name
+   *
+   * @param name the name of the client instance in the registry
+   * @return the client
+   */
+  AsyncHttpClient get(String name);
 
-    /**
-     * Registers this instance of AsyncHttpClient with this name and returns
-     * back a null if an instance with the same name never existed but will return back the
-     * previous instance if there was another instance registered with the same
-     * name and has been replaced by this one.
-     * 
-     * @param name the name of the client instance in the registry
-     * @param client the client instance
-     * @return the previous instance
-     */
-    AsyncHttpClient addOrReplace(String name, AsyncHttpClient client);
+  /**
+   * Registers this instance of AsyncHttpClient with this name and returns
+   * back a null if an instance with the same name never existed but will return back the
+   * previous instance if there was another instance registered with the same
+   * name and has been replaced by this one.
+   *
+   * @param name   the name of the client instance in the registry
+   * @param client the client instance
+   * @return the previous instance
+   */
+  AsyncHttpClient addOrReplace(String name, AsyncHttpClient client);
 
-    /**
-     * Will register only if an instance with this name doesn't exist and if it
-     * does exist will not replace this instance and will return false. Use it in the 
-     * following way:
-     * <blockquote><pre>
-     *      AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();      
-     *      if(!AsyncHttpClientRegistryImpl.getInstance().registerIfNew(“MyAHC”,ahc)){
-     *          //An instance with this name is already registered so close ahc 
-     *          ahc.close(); 
-     *          //and do necessary cleanup
-     *      }
-     * </pre></blockquote>
-     * 
-     * @param name the name of the client instance in the registry
-     * @param client the client instance
-     * @return true is the client was indeed registered
-     */
+  /**
+   * Will register only if an instance with this name doesn't exist and if it
+   * does exist will not replace this instance and will return false. Use it in the
+   * following way:
+   * <blockquote><pre>
+   *      AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
+   *      if(!AsyncHttpClientRegistryImpl.getInstance().registerIfNew(“MyAHC”,ahc)){
+   *          //An instance with this name is already registered so close ahc
+   *          ahc.close();
+   *          //and do necessary cleanup
+   *      }
+   * </pre></blockquote>
+   *
+   * @param name   the name of the client instance in the registry
+   * @param client the client instance
+   * @return true is the client was indeed registered
+   */
 
-    boolean registerIfNew(String name, AsyncHttpClient client);
+  boolean registerIfNew(String name, AsyncHttpClient client);
 
-    /**
-     * Remove the instance associate with this name
-     * 
-     * @param name the name of the client instance in the registry
-     * @return true is the client was indeed unregistered
-     */
+  /**
+   * Remove the instance associate with this name
+   *
+   * @param name the name of the client instance in the registry
+   * @return true is the client was indeed unregistered
+   */
 
-    boolean unregister(String name);
+  boolean unregister(String name);
 
-    /**
-     * @return all registered names
-     */
+  /**
+   * @return all registered names
+   */
 
-    Set<String> getAllRegisteredNames();
+  Set<String> getAllRegisteredNames();
 
-    /**
-     * Removes all instances from this registry.
-     */
+  /**
+   * Removes all instances from this registry.
+   */
 
-    void clearAllInstances();
+  void clearAllInstances();
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index f252a8e8d..48f72f881 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -22,97 +22,98 @@
 
 public class AsyncHttpClientRegistryImpl implements AsyncHttpClientRegistry {
 
-    private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<>();
-    private static volatile AsyncHttpClientRegistry _instance;
-    private static Lock lock = new ReentrantLock();
+  private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<>();
+  private static volatile AsyncHttpClientRegistry _instance;
+  private static Lock lock = new ReentrantLock();
 
-    /**
-     * Returns a singleton instance of AsyncHttpClientRegistry
-     * @return the current instance
-     */
-    public static AsyncHttpClientRegistry getInstance() {
+  /**
+   * Returns a singleton instance of AsyncHttpClientRegistry
+   *
+   * @return the current instance
+   */
+  public static AsyncHttpClientRegistry getInstance() {
+    if (_instance == null) {
+      lock.lock();
+      try {
         if (_instance == null) {
-            lock.lock();
-            try {
-                if (_instance == null) {
-                    Class<?> asyncHttpClientRegistryImplClass = AsyncImplHelper
-                            .getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-                    if (asyncHttpClientRegistryImplClass != null)
-                        _instance = (AsyncHttpClientRegistry) asyncHttpClientRegistryImplClass.newInstance();
-                    else
-                        _instance = new AsyncHttpClientRegistryImpl();
-                }
-            } catch (InstantiationException | IllegalAccessException e) {
-                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
-            } finally {
-                lock.unlock();
-            }
+          Class<?> asyncHttpClientRegistryImplClass = AsyncImplHelper
+                  .getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+          if (asyncHttpClientRegistryImplClass != null)
+            _instance = (AsyncHttpClientRegistry) asyncHttpClientRegistryImplClass.newInstance();
+          else
+            _instance = new AsyncHttpClientRegistryImpl();
         }
-        return _instance;
+      } catch (InstantiationException | IllegalAccessException e) {
+        throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
+      } finally {
+        lock.unlock();
+      }
     }
+    return _instance;
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.asynchttpclient.IAsyncHttpClientRegistry#get(java.lang.String)
-     */
-    @Override
-    public AsyncHttpClient get(String clientName) {
-        return asyncHttpClientMap.get(clientName);
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.asynchttpclient.IAsyncHttpClientRegistry#get(java.lang.String)
+   */
+  @Override
+  public AsyncHttpClient get(String clientName) {
+    return asyncHttpClientMap.get(clientName);
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.asynchttpclient.IAsyncHttpClientRegistry#register(java.lang.String,
-     * org.asynchttpclient.AsyncHttpClient)
-     */
-    @Override
-    public AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc) {
-        return asyncHttpClientMap.put(name, ahc);
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see
+   * org.asynchttpclient.IAsyncHttpClientRegistry#register(java.lang.String,
+   * org.asynchttpclient.AsyncHttpClient)
+   */
+  @Override
+  public AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc) {
+    return asyncHttpClientMap.put(name, ahc);
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.asynchttpclient.IAsyncHttpClientRegistry#registerIfNew(java.lang.
-     * String, org.asynchttpclient.AsyncHttpClient)
-     */
-    @Override
-    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
-        return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see
+   * org.asynchttpclient.IAsyncHttpClientRegistry#registerIfNew(java.lang.
+   * String, org.asynchttpclient.AsyncHttpClient)
+   */
+  @Override
+  public boolean registerIfNew(String name, AsyncHttpClient ahc) {
+    return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.asynchttpclient.IAsyncHttpClientRegistry#unRegister(java.lang.String)
-     */
-    @Override
-    public boolean unregister(String name) {
-        return asyncHttpClientMap.remove(name) != null;
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see
+   * org.asynchttpclient.IAsyncHttpClientRegistry#unRegister(java.lang.String)
+   */
+  @Override
+  public boolean unregister(String name) {
+    return asyncHttpClientMap.remove(name) != null;
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.asynchttpclient.IAsyncHttpClientRegistry#getAllRegisteredNames()
-     */
-    @Override
-    public Set<String> getAllRegisteredNames() {
-        return asyncHttpClientMap.keySet();
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.asynchttpclient.IAsyncHttpClientRegistry#getAllRegisteredNames()
+   */
+  @Override
+  public Set<String> getAllRegisteredNames() {
+    return asyncHttpClientMap.keySet();
+  }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.asynchttpclient.IAsyncHttpClientRegistry#clearAllInstances()
-     */
-    @Override
-    public void clearAllInstances() {
-        asyncHttpClientMap.clear();
-    }
+  /*
+   * (non-Javadoc)
+   *
+   * @see org.asynchttpclient.IAsyncHttpClientRegistry#clearAllInstances()
+   */
+  @Override
+  public void clearAllInstances() {
+    asyncHttpClientMap.clear();
+  }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
index a918bffdc..1099da6bf 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,44 +21,43 @@
 
 public class AsyncImplHelper {
 
-    public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
-    public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
+  public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
+  public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
 
-    /*
-     * Returns the class specified by either a system property or a properties
-     * file as the class to instantiated for the AsyncHttpClient. Returns null
-     * if property is not found and throws an AsyncHttpClientImplException if
-     * the specified class couldn't be created.
-     */
-    public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
-        String asyncHttpClientImplClassName = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(propertyName);
-        if (asyncHttpClientImplClassName != null) {
-            Class<AsyncHttpClient> asyncHttpClientImplClass = AsyncImplHelper.getClass(asyncHttpClientImplClassName);
-            return asyncHttpClientImplClass;
-        }
-        return null;
+  /*
+   * Returns the class specified by either a system property or a properties
+   * file as the class to instantiated for the AsyncHttpClient. Returns null
+   * if property is not found and throws an AsyncHttpClientImplException if
+   * the specified class couldn't be created.
+   */
+  public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
+    String asyncHttpClientImplClassName = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(propertyName);
+    if (asyncHttpClientImplClassName != null) {
+      return AsyncImplHelper.getClass(asyncHttpClientImplClassName);
     }
+    return null;
+  }
 
-    private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<AsyncHttpClient>>() {
-                @SuppressWarnings("unchecked")
-                public Class<AsyncHttpClient> run() throws ClassNotFoundException {
-                    ClassLoader cl = Thread.currentThread().getContextClassLoader();
-                    if (cl != null)
-                        try {
-                            return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
-                        } catch (ClassNotFoundException e) {
-                            AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName + " in thread context classpath " + "checking system class path next",
-                                    e);
-                        }
+  private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
+    try {
+      return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<AsyncHttpClient>>() {
+        @SuppressWarnings("unchecked")
+        public Class<AsyncHttpClient> run() throws ClassNotFoundException {
+          ClassLoader cl = Thread.currentThread().getContextClassLoader();
+          if (cl != null)
+            try {
+              return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+            } catch (ClassNotFoundException e) {
+              AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName + " in thread context classpath " + "checking system class path next",
+                      e);
+            }
 
-                    cl = ClassLoader.getSystemClassLoader();
-                    return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : " + e.getMessage(), e);
+          cl = ClassLoader.getSystemClassLoader();
+          return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
         }
+      });
+    } catch (PrivilegedActionException e) {
+      throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : " + e.getMessage(), e);
     }
+  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
index bf2b166d0..e9b3320a9 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,17 +12,12 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-
 import junit.extensions.PA;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.DefaultAsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.asynchttpclient.test.EchoHandler;
-import static org.asynchttpclient.test.TestUtils.*;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.testng.Assert;
@@ -31,185 +26,190 @@
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-public abstract class AbstractAsyncHttpClientFactoryTest {
-
-    public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
-    public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
-    public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
-
-    private Server server;
-    private int port;
-
-    @BeforeMethod
-    public void setUp() {
-        PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
-        PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-        AsyncHttpClientConfigHelper.reloadProperties();
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpBeforeTest() throws Exception {
-        server = new Server();
-        ServerConnector connector = addHttpConnector(server);
-        server.setHandler(new EchoHandler());
-        server.start();
-        port = connector.getLocalPort();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDown() throws Exception {
-        setUp();
-        if (server != null)
-            server.stop();
-    }
-
-    /**
-     * If the property is not found via the system property or properties file the default instance of AsyncHttpClient should be returned.
-     */
-    // ================================================================================================================
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClient() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfig() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProvider() throws Exception {
-        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-            assertClientWorks(asyncHttpClient);
-        }
-    }
-
-    // ==================================================================================================================================
-
-    /**
-     * If the class is specified via a system property then that class should be returned
-     */
-    // ===================================================================================================================================
-    @Test(groups = "standalone")
-    public void testFactoryWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfigWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProviderWithSystemProperty() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-        }
-    }
-
-    // ===================================================================================================================================
-
-    /**
-     * If any of the constructors of the class fail then a AsyncHttpClientException is thrown.
-     */
-    // ===================================================================================================================================
-    @Test(groups = "standalone", expectedExceptions = BadAsyncHttpClientException.class)
-    public void testFactoryWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            assertException(e);
-        }
-        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            assertException(e);
-        }
-        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
 
-    // ===================================================================================================================================
-
-    /*
-     * If the system property exists instantiate the class else if the class is not found throw an AsyncHttpClientException.
-     */
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testFactoryWithNonExistentAsyncHttpClient() throws IOException {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        }
-        Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
 
-    /**
-     * If property is specified but the class can’t be created or found for any reason subsequent calls should throw an AsyncClientException.
-     */
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testRepeatedCallsToBadAsyncHttpClient() throws IOException {
-        boolean exceptionCaught = false;
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            exceptionCaught = true;
-        }
-        Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
-        exceptionCaught = false;
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            //
-        } catch (AsyncHttpClientImplException e) {
-            exceptionCaught = true;
-        }
-        Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
-    }
-
-    private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
-        Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-    }
+public abstract class AbstractAsyncHttpClientFactoryTest {
 
-    private void assertException(AsyncHttpClientImplException e) {
-        InvocationTargetException t = (InvocationTargetException) e.getCause();
-        Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
-    }
+  public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
+  public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
+  public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
+
+  private Server server;
+  private int port;
+
+  @BeforeMethod
+  public void setUp() {
+    PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
+    PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
+    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+    AsyncHttpClientConfigHelper.reloadProperties();
+  }
+
+  @BeforeClass(alwaysRun = true)
+  public void setUpBeforeTest() throws Exception {
+    server = new Server();
+    ServerConnector connector = addHttpConnector(server);
+    server.setHandler(new EchoHandler());
+    server.start();
+    port = connector.getLocalPort();
+  }
+
+  @AfterClass(alwaysRun = true)
+  public void tearDown() throws Exception {
+    setUp();
+    if (server != null)
+      server.stop();
+  }
+
+  /**
+   * If the property is not found via the system property or properties file the default instance of AsyncHttpClient should be returned.
+   */
+  // ================================================================================================================
+  @Test
+  public void testGetAsyncHttpClient() throws Exception {
+    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+      assertClientWorks(asyncHttpClient);
+    }
+  }
+
+  @Test
+  public void testGetAsyncHttpClientConfig() throws Exception {
+    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+      assertClientWorks(asyncHttpClient);
+    }
+  }
+
+  @Test
+  public void testGetAsyncHttpClientProvider() throws Exception {
+    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+      assertClientWorks(asyncHttpClient);
+    }
+  }
+
+  // ==================================================================================================================================
+
+  /**
+   * If the class is specified via a system property then that class should be returned
+   */
+  // ===================================================================================================================================
+  @Test
+  public void testFactoryWithSystemProperty() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+    }
+  }
+
+  @Test
+  public void testGetAsyncHttpClientConfigWithSystemProperty() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+    }
+  }
+
+  @Test
+  public void testGetAsyncHttpClientProviderWithSystemProperty() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+    }
+  }
+
+  // ===================================================================================================================================
+
+  /**
+   * If any of the constructors of the class fail then a AsyncHttpClientException is thrown.
+   */
+  // ===================================================================================================================================
+  @Test(expectedExceptions = BadAsyncHttpClientException.class)
+  public void testFactoryWithBadAsyncHttpClient() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
+    }
+  }
+
+  @Test
+  public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      //
+    } catch (AsyncHttpClientImplException e) {
+      assertException(e);
+    }
+    // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+  }
+
+  @Test
+  public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      //
+    } catch (AsyncHttpClientImplException e) {
+      assertException(e);
+    }
+    // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+  }
+
+  // ===================================================================================================================================
+
+  /*
+   * If the system property exists instantiate the class else if the class is not found throw an AsyncHttpClientException.
+   */
+  @Test(expectedExceptions = AsyncHttpClientImplException.class)
+  public void testFactoryWithNonExistentAsyncHttpClient() throws IOException {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      //
+    }
+    Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+  }
+
+  /**
+   * If property is specified but the class can’t be created or found for any reason subsequent calls should throw an AsyncClientException.
+   */
+  @Test(expectedExceptions = AsyncHttpClientImplException.class)
+  public void testRepeatedCallsToBadAsyncHttpClient() throws IOException {
+    boolean exceptionCaught = false;
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      //
+    } catch (AsyncHttpClientImplException e) {
+      exceptionCaught = true;
+    }
+    Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
+    exceptionCaught = false;
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      //
+    } catch (AsyncHttpClientImplException e) {
+      exceptionCaught = true;
+    }
+    Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
+  }
+
+  private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
+    Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
+    Assert.assertEquals(200, response.getStatusCode());
+  }
+
+  private void assertException(AsyncHttpClientImplException e) {
+    InvocationTargetException t = (InvocationTargetException) e.getCause();
+    Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
+  }
 
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
index e546c6899..eeebabc7b 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,118 +12,113 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import java.io.IOException;
-
+import junit.extensions.PA;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
-import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
-import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-import org.asynchttpclient.extras.registry.AsyncImplHelper;
 import org.testng.Assert;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import junit.extensions.PA;
+import java.io.IOException;
 
 public class AsyncHttpClientRegistryTest {
 
-    private static final String TEST_AHC = "testAhc";
-
-    @BeforeMethod
-    public void setUp() {
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-        PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
-    }
-
-    @BeforeClass
-    public void setUpBeforeTest() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
-    }
-
-    @AfterClass
-    public void tearDown() {
-        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-    }
-
-    @Test(groups = "standalone")
-    public void testGetAndRegister() throws IOException {
-        try(AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-            Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-        }
+  private static final String TEST_AHC = "testAhc";
+
+  @BeforeMethod
+  public void setUp() {
+    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+    PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
+  }
+
+  @BeforeClass
+  public void setUpBeforeTest() {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
+  }
+
+  @AfterClass
+  public void tearDown() {
+    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+  }
+
+  @Test
+  public void testGetAndRegister() throws IOException {
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+      Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
     }
-
-    @Test(groups = "standalone")
-    public void testDeRegister() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-            Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-        }
+  }
+
+  @Test
+  public void testDeRegister() throws IOException {
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
+      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+      Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
+      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
     }
-
-    @Test(groups = "standalone")
-    public void testRegisterIfNew() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-                Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
-                Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
-                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
-            }
-        }
+  }
+
+  @Test
+  public void testRegisterIfNew() throws IOException {
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+        Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
+        Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
+      }
     }
-
-    @Test(groups = "standalone")
-    public void testClearAllInstances() throws IOException {
-        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                try (AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
-                    Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-                    AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-                    Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
-                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
-                }
-            }
+  }
+
+  @Test
+  public void testClearAllInstances() throws IOException {
+    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+      try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+        try (AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
+          Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+          AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+          Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
+          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
         }
+      }
     }
-
-    @Test(groups = "standalone")
-    public void testCustomAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
-        AsyncHttpClientConfigHelper.reloadProperties();
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testNonExistentAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance();
-        Assert.fail("Should never have reached here");
-    }
-
-    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
-    public void testBadAsyncHttpClientRegistry() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
-        AsyncHttpClientConfigHelper.reloadProperties();
-        AsyncHttpClientRegistryImpl.getInstance();
-        Assert.fail("Should never have reached here");
-    }
+  }
+
+  @Test
+  public void testCustomAsyncHttpClientRegistry() {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
+    AsyncHttpClientConfigHelper.reloadProperties();
+    Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
+  }
+
+  @Test(expectedExceptions = AsyncHttpClientImplException.class)
+  public void testNonExistentAsyncHttpClientRegistry() {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    AsyncHttpClientRegistryImpl.getInstance();
+    Assert.fail("Should never have reached here");
+  }
+
+  @Test(expectedExceptions = AsyncHttpClientImplException.class)
+  public void testBadAsyncHttpClientRegistry() {
+    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
+    AsyncHttpClientConfigHelper.reloadProperties();
+    AsyncHttpClientRegistryImpl.getInstance();
+    Assert.fail("Should never have reached here");
+  }
 
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
index 713887c98..275d8fe7e 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,135 +12,131 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import java.util.function.Predicate;
+import org.asynchttpclient.*;
 
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.ClientStats;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SignatureCalculator;
+import java.util.function.Predicate;
 
 public class BadAsyncHttpClient implements AsyncHttpClient {
 
-    public BadAsyncHttpClient() {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    public BadAsyncHttpClient(AsyncHttpClientConfig config) {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-        throw new BadAsyncHttpClientException("Because I am bad!!");
-    }
-
-    @Override
-    public void close() {
-
-    }
-
-    @Override
-    public boolean isClosed() {
-        return false;
-    }
-
-    @Override
-    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareGet(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareConnect(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareOptions(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareHead(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePost(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePut(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareDelete(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePatch(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareTrace(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public ClientStats getClientStats() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public AsyncHttpClientConfig getConfig() {
-        return null;
-    }
+  public BadAsyncHttpClient() {
+    throw new BadAsyncHttpClientException("Because I am bad!!");
+  }
+
+  public BadAsyncHttpClient(AsyncHttpClientConfig config) {
+    throw new BadAsyncHttpClientException("Because I am bad!!");
+  }
+
+  public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+    throw new BadAsyncHttpClientException("Because I am bad!!");
+  }
+
+  @Override
+  public void close() {
+
+  }
+
+  @Override
+  public boolean isClosed() {
+    return false;
+  }
+
+  @Override
+  public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepare(String method, String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareGet(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareConnect(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareOptions(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareHead(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePost(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePut(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareDelete(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePatch(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareTrace(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(Request request) {
+    return null;
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+    return null;
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(Request request) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+    return null;
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+    return null;
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+    return null;
+  }
+
+  @Override
+  public ClientStats getClientStats() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public AsyncHttpClientConfig getConfig() {
+    return null;
+  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
index 1aca098e8..cf5009c40 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,12 +12,10 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
-
 @SuppressWarnings("serial")
 public class BadAsyncHttpClientException extends AsyncHttpClientImplException {
 
-    public BadAsyncHttpClientException(String msg) {
-        super(msg);
-    }
+  public BadAsyncHttpClientException(String msg) {
+    super(msg);
+  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
index b3d853de3..4a32bf217 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,11 +12,9 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-
 public class BadAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
 
-    private BadAsyncHttpClientRegistry() {
-        throw new RuntimeException("I am bad");
-    }
+  private BadAsyncHttpClientRegistry() {
+    throw new RuntimeException("I am bad");
+  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
index 0e61c109f..5786e370d 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,131 +12,127 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import java.util.function.Predicate;
+import org.asynchttpclient.*;
 
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.ClientStats;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SignatureCalculator;
+import java.util.function.Predicate;
 
 public class TestAsyncHttpClient implements AsyncHttpClient {
 
-    public TestAsyncHttpClient() {
-    }
-
-    public TestAsyncHttpClient(AsyncHttpClientConfig config) {
-    }
-
-    public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-    }
-
-    @Override
-    public void close() {
-    }
-
-    @Override
-    public boolean isClosed() {
-        return false;
-    }
-
-    @Override
-    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareGet(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareConnect(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareOptions(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareHead(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePost(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePut(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareDelete(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder preparePatch(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareTrace(String url) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(Request request) {
-        return null;
-    }
-
-    @Override
-    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-        return null;
-    }
-
-    @Override
-    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-        return null;
-    }
-
-    @Override
-    public ClientStats getClientStats() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public AsyncHttpClientConfig getConfig() {
-        return null;
-    }
+  public TestAsyncHttpClient() {
+  }
+
+  public TestAsyncHttpClient(AsyncHttpClientConfig config) {
+  }
+
+  public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+  }
+
+  @Override
+  public void close() {
+  }
+
+  @Override
+  public boolean isClosed() {
+    return false;
+  }
+
+  @Override
+  public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepare(String method, String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareGet(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareConnect(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareOptions(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareHead(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePost(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePut(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareDelete(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder preparePatch(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareTrace(String url) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(Request request) {
+    return null;
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+    return null;
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(Request request) {
+    return null;
+  }
+
+  @Override
+  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+    return null;
+  }
+
+  @Override
+  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+    return null;
+  }
+
+  @Override
+  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+    return null;
+  }
+
+  @Override
+  public ClientStats getClientStats() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public AsyncHttpClientConfig getConfig() {
+    return null;
+  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
index b9410737d..c17734d97 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,8 +12,6 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
-
 public class TestAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
 
 }
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index 27e88741a..dc7ca941b 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -1,62 +1,62 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <parent>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-
-    <artifactId>async-http-client-extras-retrofit2</artifactId>
-    <name>Asynchronous Http Client Retrofit2 Extras</name>
-    <description>The Async Http Client Retrofit2 Extras.</description>
-
-    <properties>
-      <retrofit2.version>2.3.0</retrofit2.version>
-      <lombok.version>1.16.18</lombok.version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>org.projectlombok</groupId>
-            <artifactId>lombok</artifactId>
-            <version>${lombok.version}</version>
-            <scope>provided</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.squareup.retrofit2</groupId>
-            <artifactId>retrofit</artifactId>
-            <version>${retrofit2.version}</version>
-        </dependency>
-
-        <!-- for tests -->
-        <dependency>
-            <groupId>com.squareup.retrofit2</groupId>
-            <artifactId>converter-scalars</artifactId>
-            <version>${retrofit2.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.squareup.retrofit2</groupId>
-            <artifactId>converter-jackson</artifactId>
-            <version>${retrofit2.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.squareup.retrofit2</groupId>
-            <artifactId>adapter-rxjava</artifactId>
-            <version>${retrofit2.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>com.squareup.retrofit2</groupId>
-            <artifactId>adapter-rxjava2</artifactId>
-            <version>${retrofit2.version}</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>async-http-client-extras-retrofit2</artifactId>
+  <name>Asynchronous Http Client Retrofit2 Extras</name>
+  <description>The Async Http Client Retrofit2 Extras.</description>
+
+  <properties>
+    <retrofit2.version>2.5.0</retrofit2.version>
+    <lombok.version>1.18.6</lombok.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.projectlombok</groupId>
+      <artifactId>lombok</artifactId>
+      <version>${lombok.version}</version>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.squareup.retrofit2</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${retrofit2.version}</version>
+    </dependency>
+
+    <!-- for tests -->
+    <dependency>
+      <groupId>com.squareup.retrofit2</groupId>
+      <artifactId>converter-scalars</artifactId>
+      <version>${retrofit2.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.squareup.retrofit2</groupId>
+      <artifactId>converter-jackson</artifactId>
+      <version>${retrofit2.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.squareup.retrofit2</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${retrofit2.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.squareup.retrofit2</groupId>
+      <artifactId>adapter-rxjava2</artifactId>
+      <version>${retrofit2.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
index 2dde47813..bbd760187 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
@@ -12,23 +12,12 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
-import lombok.AccessLevel;
-import lombok.Builder;
-import lombok.Getter;
-import lombok.NonNull;
-import lombok.Singular;
-import lombok.SneakyThrows;
-import lombok.Value;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import lombok.*;
 import lombok.extern.slf4j.Slf4j;
-import lombok.val;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.MediaType;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
+import okhttp3.*;
 import okio.Buffer;
+import okio.Timeout;
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.RequestBuilder;
@@ -41,6 +30,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
+import java.util.function.Supplier;
 
 /**
  * {@link AsyncHttpClient} <a href="http://square.github.io/retrofit/">Retrofit2</a> {@link okhttp3.Call}
@@ -50,277 +40,299 @@
 @Builder(toBuilder = true)
 @Slf4j
 class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
-    /**
-     * Default {@link #execute()} timeout in milliseconds (value: <b>{@value}</b>)
-     *
-     * @see #execute()
-     * @see #executeTimeoutMillis
-     */
-    public static final long DEFAULT_EXECUTE_TIMEOUT_MILLIS = 30_000;
-
-    /**
-     * HttpClient instance.
-     */
-    @NonNull
-    AsyncHttpClient httpClient;
-
-    /**
-     * {@link #execute()} response timeout in milliseconds.
-     */
-    @Builder.Default
-    long executeTimeoutMillis = DEFAULT_EXECUTE_TIMEOUT_MILLIS;
-
-    /**
-     * Retrofit request.
-     */
-    @NonNull
-    @Getter(AccessLevel.NONE)
-    Request request;
-
-    /**
-     * List of consumers that get called just before actual async-http-client request is being built.
-     */
-    @Singular("requestCustomizer")
-    List<Consumer<RequestBuilder>> requestCustomizers;
-
-    /**
-     * List of consumers that get called just before actual HTTP request is being fired.
-     */
-    @Singular("onRequestStart")
-    List<Consumer<Request>> onRequestStart;
-
-    /**
-     * List of consumers that get called when HTTP request finishes with an exception.
-     */
-    @Singular("onRequestFailure")
-    List<Consumer<Throwable>> onRequestFailure;
-
-    /**
-     * List of consumers that get called when HTTP request finishes successfully.
-     */
-    @Singular("onRequestSuccess")
-    List<Consumer<Response>> onRequestSuccess;
-
-    /**
-     * Tells whether call has been executed.
-     *
-     * @see #isExecuted()
-     * @see #isCanceled()
-     */
-    private final AtomicReference<CompletableFuture<Response>> futureRef = new AtomicReference<>();
-
-    @Override
-    public Request request() {
-        return request;
+  private static final ResponseBody EMPTY_BODY = ResponseBody.create(null, "");
+
+  /**
+   * Tells whether call has been executed.
+   *
+   * @see #isExecuted()
+   * @see #isCanceled()
+   */
+  private final AtomicReference<CompletableFuture<Response>> futureRef = new AtomicReference<>();
+
+  /**
+   * {@link AsyncHttpClient} supplier
+   */
+  @NonNull
+  Supplier<AsyncHttpClient> httpClientSupplier;
+
+  /**
+   * Retrofit request.
+   */
+  @NonNull
+  @Getter(AccessLevel.NONE)
+  Request request;
+
+  /**
+   * List of consumers that get called just before actual async-http-client request is being built.
+   */
+  @Singular("requestCustomizer")
+  List<Consumer<RequestBuilder>> requestCustomizers;
+
+  /**
+   * List of consumers that get called just before actual HTTP request is being fired.
+   */
+  @Singular("onRequestStart")
+  List<Consumer<Request>> onRequestStart;
+
+  /**
+   * List of consumers that get called when HTTP request finishes with an exception.
+   */
+  @Singular("onRequestFailure")
+  List<Consumer<Throwable>> onRequestFailure;
+
+  /**
+   * List of consumers that get called when HTTP request finishes successfully.
+   */
+  @Singular("onRequestSuccess")
+  List<Consumer<Response>> onRequestSuccess;
+
+  /**
+   * Safely runs specified consumer.
+   *
+   * @param consumer consumer (may be null)
+   * @param argument consumer argument
+   * @param <T>      consumer type.
+   */
+  protected static <T> void runConsumer(Consumer<T> consumer, T argument) {
+    try {
+      if (consumer != null) {
+        consumer.accept(argument);
+      }
+    } catch (Exception e) {
+      log.error("Exception while running consumer {}: {}", consumer, e.getMessage(), e);
     }
-
-    @Override
-    public Response execute() throws IOException {
-        try {
-            return executeHttpRequest().get(getExecuteTimeoutMillis(), TimeUnit.MILLISECONDS);
-        } catch (ExecutionException e) {
-            throw toIOException(e.getCause());
-        } catch (Exception e) {
-            throw toIOException(e);
-        }
+  }
+
+  /**
+   * Safely runs multiple consumers.
+   *
+   * @param consumers collection of consumers (may be null)
+   * @param argument  consumer argument
+   * @param <T>       consumer type.
+   */
+  protected static <T> void runConsumers(Collection<Consumer<T>> consumers, T argument) {
+    if (consumers == null || consumers.isEmpty()) {
+      return;
     }
-
-    @Override
-    public void enqueue(Callback responseCallback) {
-        executeHttpRequest()
-                .thenApply(response -> handleResponse(response, responseCallback))
-                .exceptionally(throwable -> handleException(throwable, responseCallback));
+    consumers.forEach(consumer -> runConsumer(consumer, argument));
+  }
+
+  @Override
+  public Request request() {
+    return request;
+  }
+
+  @Override
+  public Response execute() throws IOException {
+    try {
+      return executeHttpRequest().get(getRequestTimeoutMillis(), TimeUnit.MILLISECONDS);
+    } catch (ExecutionException e) {
+      throw toIOException(e.getCause());
+    } catch (Exception e) {
+      throw toIOException(e);
     }
-
-    @Override
-    public void cancel() {
-        val future = futureRef.get();
-        if (future != null) {
-            if (!future.cancel(true)) {
-                log.warn("Cannot cancel future: {}", future);
-            }
-        }
+  }
+
+  @Override
+  public void enqueue(Callback responseCallback) {
+    executeHttpRequest()
+            .thenApply(response -> handleResponse(response, responseCallback))
+            .exceptionally(throwable -> handleException(throwable, responseCallback));
+  }
+
+  @Override
+  public void cancel() {
+    val future = futureRef.get();
+    if (future != null && !future.isDone()) {
+      if (!future.cancel(true)) {
+        log.warn("Cannot cancel future: {}", future);
+      }
     }
-
-    @Override
-    public boolean isExecuted() {
-        val future = futureRef.get();
-        return future != null && future.isDone();
+  }
+
+  @Override
+  public boolean isExecuted() {
+    val future = futureRef.get();
+    return future != null && future.isDone();
+  }
+
+  @Override
+  public boolean isCanceled() {
+    val future = futureRef.get();
+    return future != null && future.isCancelled();
+  }
+
+  @Override
+  public Timeout timeout() {
+    return new Timeout().timeout(getRequestTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * Returns HTTP request timeout in milliseconds, retrieved from http client configuration.
+   *
+   * @return request timeout in milliseconds.
+   */
+  protected long getRequestTimeoutMillis() {
+    return Math.abs(getHttpClient().getConfig().getRequestTimeout());
+  }
+
+  @Override
+  public Call clone() {
+    return toBuilder().build();
+  }
+
+  protected <T> T handleException(Throwable throwable, Callback responseCallback) {
+    try {
+      if (responseCallback != null) {
+        responseCallback.onFailure(this, toIOException(throwable));
+      }
+    } catch (Exception e) {
+      log.error("Exception while executing onFailure() on {}: {}", responseCallback, e.getMessage(), e);
     }
-
-    @Override
-    public boolean isCanceled() {
-        val future = futureRef.get();
-        return future != null && future.isCancelled();
+    return null;
+  }
+
+  protected Response handleResponse(Response response, Callback responseCallback) {
+    try {
+      if (responseCallback != null) {
+        responseCallback.onResponse(this, response);
+      }
+    } catch (Exception e) {
+      log.error("Exception while executing onResponse() on {}: {}", responseCallback, e.getMessage(), e);
     }
+    return response;
+  }
 
-    @Override
-    public Call clone() {
-        return toBuilder().build();
+  protected CompletableFuture<Response> executeHttpRequest() {
+    if (futureRef.get() != null) {
+      throwAlreadyExecuted();
     }
 
-    protected <T> T handleException(Throwable throwable, Callback responseCallback) {
-        try {
-            if (responseCallback != null) {
-                responseCallback.onFailure(this, toIOException(throwable));
-            }
-        } catch (Exception e) {
-            log.error("Exception while executing onFailure() on {}: {}", responseCallback, e.getMessage(), e);
-        }
-        return null;
+    // create future and try to store it into atomic reference
+    val future = new CompletableFuture<Response>();
+    if (!futureRef.compareAndSet(null, future)) {
+      throwAlreadyExecuted();
     }
 
-    protected Response handleResponse(Response response, Callback responseCallback) {
-        try {
-            if (responseCallback != null) {
-                responseCallback.onResponse(this, response);
-            }
-        } catch (Exception e) {
-            log.error("Exception while executing onResponse() on {}: {}", responseCallback, e.getMessage(), e);
-        }
-        return response;
+    // create request
+    val asyncHttpClientRequest = createRequest(request());
+
+    // execute the request.
+    val me = this;
+    runConsumers(this.onRequestStart, this.request);
+    getHttpClient().executeRequest(asyncHttpClientRequest, new AsyncCompletionHandler<Response>() {
+      @Override
+      public void onThrowable(Throwable t) {
+        runConsumers(me.onRequestFailure, t);
+        future.completeExceptionally(t);
+      }
+
+      @Override
+      public Response onCompleted(org.asynchttpclient.Response response) {
+        val okHttpResponse = toOkhttpResponse(response);
+        runConsumers(me.onRequestSuccess, okHttpResponse);
+        future.complete(okHttpResponse);
+        return okHttpResponse;
+      }
+    });
+
+    return future;
+  }
+
+  /**
+   * Returns HTTP client.
+   *
+   * @return http client
+   * @throws IllegalArgumentException if {@link #httpClientSupplier} returned {@code null}.
+   */
+  protected AsyncHttpClient getHttpClient() {
+    val httpClient = httpClientSupplier.get();
+    if (httpClient == null) {
+      throw new IllegalStateException("Async HTTP client instance supplier " + httpClientSupplier + " returned null.");
     }
-
-    protected CompletableFuture<Response> executeHttpRequest() {
-        if (futureRef.get() != null) {
-            throwAlreadyExecuted();
-        }
-
-        // create future and try to store it into atomic reference
-        val future = new CompletableFuture<Response>();
-        if (!futureRef.compareAndSet(null, future)) {
-            throwAlreadyExecuted();
-        }
-
-        // create request
-        val asyncHttpClientRequest = createRequest(request());
-
-        // execute the request.
-        val me = this;
-        runConsumers(this.onRequestStart, this.request);
-        getHttpClient().executeRequest(asyncHttpClientRequest, new AsyncCompletionHandler<Response>() {
-            @Override
-            public void onThrowable(Throwable t) {
-                runConsumers(me.onRequestFailure, t);
-                future.completeExceptionally(t);
-            }
-
-            @Override
-            public Response onCompleted(org.asynchttpclient.Response response) throws Exception {
-                val okHttpResponse = toOkhttpResponse(response);
-                runConsumers(me.onRequestSuccess, okHttpResponse);
-                future.complete(okHttpResponse);
-                return okHttpResponse;
-            }
-        });
-
-        return future;
+    return httpClient;
+  }
+
+  /**
+   * Converts async-http-client response to okhttp response.
+   *
+   * @param asyncHttpClientResponse async-http-client response
+   * @return okhttp response.
+   * @throws NullPointerException in case of null arguments
+   */
+  private Response toOkhttpResponse(org.asynchttpclient.Response asyncHttpClientResponse) {
+    // status code
+    val rspBuilder = new Response.Builder()
+            .request(request())
+            .protocol(Protocol.HTTP_1_1)
+            .code(asyncHttpClientResponse.getStatusCode())
+            .message(asyncHttpClientResponse.getStatusText());
+
+    // headers
+    if (asyncHttpClientResponse.hasResponseHeaders()) {
+      asyncHttpClientResponse.getHeaders().forEach(e -> rspBuilder.header(e.getKey(), e.getValue()));
     }
 
-    /**
-     * Converts async-http-client response to okhttp response.
-     *
-     * @param asyncHttpClientResponse async-http-client response
-     * @return okhttp response.
-     * @throws NullPointerException in case of null arguments
-     */
-    private Response toOkhttpResponse(org.asynchttpclient.Response asyncHttpClientResponse) {
-        // status code
-        val rspBuilder = new Response.Builder()
-                .request(request())
-                .protocol(Protocol.HTTP_1_1)
-                .code(asyncHttpClientResponse.getStatusCode())
-                .message(asyncHttpClientResponse.getStatusText());
-
-        // headers
-        if (asyncHttpClientResponse.hasResponseHeaders()) {
-            asyncHttpClientResponse.getHeaders().forEach(e -> rspBuilder.header(e.getKey(), e.getValue()));
-        }
-
-        // body
-        if (asyncHttpClientResponse.hasResponseBody()) {
-            val contentType = MediaType.parse(asyncHttpClientResponse.getContentType());
-            val okHttpBody = ResponseBody.create(contentType, asyncHttpClientResponse.getResponseBodyAsBytes());
-            rspBuilder.body(okHttpBody);
-        }
-
-        return rspBuilder.build();
+    // body
+    if (asyncHttpClientResponse.hasResponseBody()) {
+      val contentType = asyncHttpClientResponse.getContentType() == null
+              ? null : MediaType.parse(asyncHttpClientResponse.getContentType());
+      val okHttpBody = ResponseBody.create(contentType, asyncHttpClientResponse.getResponseBodyAsBytes());
+      rspBuilder.body(okHttpBody);
+    } else {
+      rspBuilder.body(EMPTY_BODY);
     }
 
-    protected IOException toIOException(@NonNull Throwable exception) {
-        if (exception instanceof IOException) {
-            return (IOException) exception;
-        } else {
-            val message = (exception.getMessage() == null) ? exception.toString() : exception.getMessage();
-            return new IOException(message, exception);
-        }
-    }
+    return rspBuilder.build();
+  }
 
-    /**
-     * Converts retrofit request to async-http-client request.
-     *
-     * @param request retrofit request
-     * @return async-http-client request.
-     */
-    @SneakyThrows
-    protected org.asynchttpclient.Request createRequest(@NonNull Request request) {
-        // create async-http-client request builder
-        val requestBuilder = new RequestBuilder(request.method());
-
-        // request uri
-        requestBuilder.setUrl(request.url().toString());
-
-        // set headers
-        val headers = request.headers();
-        headers.names().forEach(name -> requestBuilder.setHeader(name, headers.values(name)));
-
-        // set request body
-        val body = request.body();
-        if (body != null && body.contentLength() > 0) {
-            // write body to buffer
-            val okioBuffer = new Buffer();
-            body.writeTo(okioBuffer);
-            requestBuilder.setBody(okioBuffer.readByteArray());
-        }
-
-        // customize the request builder (external customizer can change the request url for example)
-        runConsumers(this.requestCustomizers, requestBuilder);
-
-        return requestBuilder.build();
+  protected IOException toIOException(@NonNull Throwable exception) {
+    if (exception instanceof IOException) {
+      return (IOException) exception;
+    } else {
+      val message = (exception.getMessage() == null) ? exception.toString() : exception.getMessage();
+      return new IOException(message, exception);
     }
-
-    /**
-     * Safely runs specified consumer.
-     *
-     * @param consumer consumer (may be null)
-     * @param argument consumer argument
-     * @param <T>      consumer type.
-     */
-    protected static <T> void runConsumer(Consumer<T> consumer, T argument) {
-        try {
-            if (consumer != null) {
-                consumer.accept(argument);
-            }
-        } catch (Exception e) {
-            log.error("Exception while running consumer {}: {}", consumer, e.getMessage(), e);
-        }
+  }
+
+  /**
+   * Converts retrofit request to async-http-client request.
+   *
+   * @param request retrofit request
+   * @return async-http-client request.
+   */
+  @SneakyThrows
+  protected org.asynchttpclient.Request createRequest(@NonNull Request request) {
+    // create async-http-client request builder
+    val requestBuilder = new RequestBuilder(request.method());
+
+    // request uri
+    requestBuilder.setUrl(request.url().toString());
+
+    // set headers
+    val headers = request.headers();
+    headers.names().forEach(name -> requestBuilder.setHeader(name, headers.values(name)));
+
+    // set request body
+    val body = request.body();
+    if (body != null && body.contentLength() > 0) {
+      if (body.contentType() != null) {
+        requestBuilder.setHeader(HttpHeaderNames.CONTENT_TYPE, body.contentType().toString());
+      }
+      // write body to buffer
+      val okioBuffer = new Buffer();
+      body.writeTo(okioBuffer);
+      requestBuilder.setBody(okioBuffer.readByteArray());
     }
 
-    /**
-     * Safely runs multiple consumers.
-     *
-     * @param consumers collection of consumers (may be null)
-     * @param argument  consumer argument
-     * @param <T>       consumer type.
-     */
-    protected static <T> void runConsumers(Collection<Consumer<T>> consumers, T argument) {
-        if (consumers == null || consumers.isEmpty()) {
-            return;
-        }
-        consumers.forEach(consumer -> runConsumer(consumer, argument));
-    }
+    // customize the request builder (external customizer can change the request url for example)
+    runConsumers(this.requestCustomizers, requestBuilder);
 
-    private void throwAlreadyExecuted() {
-        throw new IllegalStateException("This call has already been executed.");
-    }
+    return requestBuilder.build();
+  }
+
+  private void throwAlreadyExecuted() {
+    throw new IllegalStateException("This call has already been executed.");
+  }
 }
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
index 0376628b7..0077cd32e 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
@@ -12,48 +12,79 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
-import lombok.Builder;
-import lombok.NonNull;
-import lombok.Singular;
-import lombok.Value;
-import lombok.val;
+import lombok.*;
 import okhttp3.Call;
 import okhttp3.Request;
 import org.asynchttpclient.AsyncHttpClient;
 
 import java.util.List;
 import java.util.function.Consumer;
+import java.util.function.Supplier;
 
 import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.runConsumers;
 
 /**
- * {@link AsyncHttpClient} implementation of Retrofit2 {@link Call.Factory}
+ * {@link AsyncHttpClient} implementation of <a href="http://square.github.io/retrofit/">Retrofit2</a>
+ * {@link Call.Factory}.
  */
 @Value
 @Builder(toBuilder = true)
 public class AsyncHttpClientCallFactory implements Call.Factory {
+  /**
+   * Supplier of {@link AsyncHttpClient}.
+   */
+  @NonNull
+  @Getter(AccessLevel.NONE)
+  Supplier<AsyncHttpClient> httpClientSupplier;
+
+  /**
+   * List of {@link Call} builder customizers that are invoked just before creating it.
+   */
+  @Singular("callCustomizer")
+  @Getter(AccessLevel.PACKAGE)
+  List<Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder>> callCustomizers;
+
+  @Override
+  public Call newCall(Request request) {
+    val callBuilder = AsyncHttpClientCall.builder()
+            .httpClientSupplier(httpClientSupplier)
+            .request(request);
+
+    // customize builder before creating a call
+    runConsumers(this.callCustomizers, callBuilder);
+
+    // create a call
+    return callBuilder.build();
+  }
+
+  /**
+   * Returns {@link AsyncHttpClient} from {@link #httpClientSupplier}.
+   *
+   * @return http client.
+   */
+  AsyncHttpClient getHttpClient() {
+    return httpClientSupplier.get();
+  }
+
+  /**
+   * Builder for {@link AsyncHttpClientCallFactory}.
+   */
+  public static class AsyncHttpClientCallFactoryBuilder {
     /**
-     * {@link AsyncHttpClient} in use.
+     * {@link AsyncHttpClient} supplier that returns http client to be used to execute HTTP requests.
      */
-    @NonNull
-    AsyncHttpClient httpClient;
+    private Supplier<AsyncHttpClient> httpClientSupplier;
 
     /**
-     * List of {@link Call} builder customizers that are invoked just before creating it.
+     * Sets concrete http client to be used by the factory to execute HTTP requests. Invocation of this method
+     * overrides any previous http client supplier set by {@link #httpClientSupplier(Supplier)}!
+     *
+     * @param httpClient http client
+     * @return reference to itself.
+     * @see #httpClientSupplier(Supplier)
      */
-    @Singular("callCustomizer")
-    List<Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder>> callCustomizers;
-
-    @Override
-    public Call newCall(Request request) {
-        val callBuilder = AsyncHttpClientCall.builder()
-                .httpClient(httpClient)
-                .request(request);
-
-        // customize builder before creating a call
-        runConsumers(this.callCustomizers, callBuilder);
-
-        // create a call
-        return callBuilder.build();
+    public AsyncHttpClientCallFactoryBuilder httpClient(@NonNull AsyncHttpClient httpClient) {
+      return httpClientSupplier(() -> httpClient);
     }
-}
+  }
+}
\ No newline at end of file
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
index 58eef1c91..864931a58 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
@@ -14,143 +14,213 @@
 
 import lombok.extern.slf4j.Slf4j;
 import lombok.val;
+import okhttp3.MediaType;
 import okhttp3.Request;
+import okhttp3.RequestBody;
 import okhttp3.Response;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.RequestBuilder;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
+import java.util.Objects;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCallTest.REQUEST;
 import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCallTest.createConsumer;
 import static org.mockito.Mockito.mock;
 import static org.testng.Assert.*;
 
 @Slf4j
 public class AsyncHttpClientCallFactoryTest {
-    @Test
-    void newCallShouldProduceExpectedResult() {
-        // given
-        val request = new Request.Builder().url("http://www.google.com/").build();
-        val httpClient = mock(AsyncHttpClient.class);
-
-        Consumer<Request> onRequestStart = createConsumer(new AtomicInteger());
-        Consumer<Throwable> onRequestFailure = createConsumer(new AtomicInteger());
-        Consumer<Response> onRequestSuccess = createConsumer(new AtomicInteger());
-        Consumer<RequestBuilder> requestCustomizer = createConsumer(new AtomicInteger());
-
-        // first call customizer
-        val customizer1Called = new AtomicInteger();
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer1 = builder -> {
-            builder.onRequestStart(onRequestStart)
-                    .onRequestFailure(onRequestFailure)
-                    .onRequestSuccess(onRequestSuccess);
-            customizer1Called.incrementAndGet();
-        };
-
-        // first call customizer
-        val customizer2Called = new AtomicInteger();
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer2 = builder -> {
-            builder.requestCustomizer(requestCustomizer);
-            customizer2Called.incrementAndGet();
-        };
-
-        // when: create call factory
-        val factory = AsyncHttpClientCallFactory.builder()
-                .httpClient(httpClient)
-                .callCustomizer(callBuilderConsumer1)
-                .callCustomizer(callBuilderConsumer2)
-                .build();
-
-        // then
-        assertTrue(factory.getHttpClient() == httpClient);
-        assertTrue(factory.getCallCustomizers().size() == 2);
-        assertTrue(customizer1Called.get() == 0);
-        assertTrue(customizer2Called.get() == 0);
-
-        // when
-        val call = (AsyncHttpClientCall) factory.newCall(request);
-
-        // then
-        assertNotNull(call);
-        assertTrue(customizer1Called.get() == 1);
-        assertTrue(customizer2Called.get() == 1);
-
-        assertTrue(call.request() == request);
-        assertTrue(call.getHttpClient() == httpClient);
-
-        assertEquals(call.getOnRequestStart().get(0), onRequestStart);
-        assertEquals(call.getOnRequestFailure().get(0), onRequestFailure);
-        assertEquals(call.getOnRequestSuccess().get(0), onRequestSuccess);
-        assertEquals(call.getRequestCustomizers().get(0), requestCustomizer);
-    }
-
-    @Test
-    void shouldApplyAllConsumersToCallBeingConstructed() throws IOException {
-        // given
-        val httpClient = mock(AsyncHttpClient.class);
-
-        val rewriteUrl = "http://foo.bar.com/";
-        val headerName = "X-Header";
-        val headerValue = UUID.randomUUID().toString();
-
-        val numCustomized = new AtomicInteger();
-        val numRequestStart = new AtomicInteger();
-        val numRequestSuccess = new AtomicInteger();
-        val numRequestFailure = new AtomicInteger();
-
-        Consumer<RequestBuilder> requestCustomizer = requestBuilder -> {
-            requestBuilder.setUrl(rewriteUrl)
-                    .setHeader(headerName, headerValue);
-            numCustomized.incrementAndGet();
-        };
-
-        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callCustomizer = callBuilder -> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json");
+  private static final String JSON_BODY = "{\"foo\": \"bar\"}";
+  private static final RequestBody BODY = RequestBody.create(MEDIA_TYPE, JSON_BODY);
+  private static final String URL = "http://localhost:11000/foo/bar?a=b&c=d";
+  private static final Request REQUEST = new Request.Builder()
+          .post(BODY)
+          .addHeader("X-Foo", "Bar")
+          .url(URL)
+          .build();
+  @Test
+  void newCallShouldProduceExpectedResult() {
+    // given
+    val request = new Request.Builder().url("http://www.google.com/").build();
+    val httpClient = mock(AsyncHttpClient.class);
+
+    Consumer<Request> onRequestStart = createConsumer(new AtomicInteger());
+    Consumer<Throwable> onRequestFailure = createConsumer(new AtomicInteger());
+    Consumer<Response> onRequestSuccess = createConsumer(new AtomicInteger());
+    Consumer<RequestBuilder> requestCustomizer = createConsumer(new AtomicInteger());
+
+    // first call customizer
+    val customizer1Called = new AtomicInteger();
+    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer1 = builder -> {
+      builder.onRequestStart(onRequestStart)
+              .onRequestFailure(onRequestFailure)
+              .onRequestSuccess(onRequestSuccess);
+      customizer1Called.incrementAndGet();
+    };
+
+    // first call customizer
+    val customizer2Called = new AtomicInteger();
+    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer2 = builder -> {
+      builder.requestCustomizer(requestCustomizer);
+      customizer2Called.incrementAndGet();
+    };
+
+    // when: create call factory
+    val factory = AsyncHttpClientCallFactory.builder()
+            .httpClient(httpClient)
+            .callCustomizer(callBuilderConsumer1)
+            .callCustomizer(callBuilderConsumer2)
+            .build();
+
+    // then
+    assertTrue(factory.getHttpClient() == httpClient);
+    assertTrue(factory.getCallCustomizers().size() == 2);
+    assertTrue(customizer1Called.get() == 0);
+    assertTrue(customizer2Called.get() == 0);
+
+    // when
+    val call = (AsyncHttpClientCall) factory.newCall(request);
+
+    // then
+    assertNotNull(call);
+    assertTrue(customizer1Called.get() == 1);
+    assertTrue(customizer2Called.get() == 1);
+
+    assertTrue(call.request() == request);
+    assertTrue(call.getHttpClient() == httpClient);
+
+    assertEquals(call.getOnRequestStart().get(0), onRequestStart);
+    assertEquals(call.getOnRequestFailure().get(0), onRequestFailure);
+    assertEquals(call.getOnRequestSuccess().get(0), onRequestSuccess);
+    assertEquals(call.getRequestCustomizers().get(0), requestCustomizer);
+  }
+
+  @Test
+  void shouldApplyAllConsumersToCallBeingConstructed() {
+    // given
+    val httpClient = mock(AsyncHttpClient.class);
+
+    val rewriteUrl = "http://foo.bar.com/";
+    val headerName = "X-Header";
+    val headerValue = UUID.randomUUID().toString();
+
+    val numCustomized = new AtomicInteger();
+    val numRequestStart = new AtomicInteger();
+    val numRequestSuccess = new AtomicInteger();
+    val numRequestFailure = new AtomicInteger();
+
+    Consumer<RequestBuilder> requestCustomizer = requestBuilder -> {
+      requestBuilder.setUrl(rewriteUrl)
+              .setHeader(headerName, headerValue);
+      numCustomized.incrementAndGet();
+    };
+
+    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callCustomizer = callBuilder ->
             callBuilder
                     .requestCustomizer(requestCustomizer)
                     .requestCustomizer(rb -> log.warn("I'm customizing: {}", rb))
                     .onRequestSuccess(createConsumer(numRequestSuccess))
                     .onRequestFailure(createConsumer(numRequestFailure))
                     .onRequestStart(createConsumer(numRequestStart));
-        };
-
-        // create factory
-        val factory = AsyncHttpClientCallFactory.builder()
-                .callCustomizer(callCustomizer)
-                .httpClient(httpClient)
-                .build();
-
-        // when
-        val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
-        val callRequest = call.createRequest(call.request());
-
-        // then
-        assertTrue(numCustomized.get() == 1);
-        assertTrue(numRequestStart.get() == 0);
-        assertTrue(numRequestSuccess.get() == 0);
-        assertTrue(numRequestFailure.get() == 0);
-
-        // let's see whether request customizers did their job
-        // final async-http-client request should have modified URL and one
-        // additional header value.
-        assertEquals(callRequest.getUrl(), rewriteUrl);
-        assertEquals(callRequest.getHeaders().get(headerName), headerValue);
-
-        // final call should have additional consumers set
-        assertNotNull(call.getOnRequestStart());
-        assertTrue(call.getOnRequestStart().size() == 1);
-
-        assertNotNull(call.getOnRequestSuccess());
-        assertTrue(call.getOnRequestSuccess().size() == 1);
-
-        assertNotNull(call.getOnRequestFailure());
-        assertTrue(call.getOnRequestFailure().size() == 1);
-
-        assertNotNull(call.getRequestCustomizers());
-        assertTrue(call.getRequestCustomizers().size() == 2);
-    }
+
+    // create factory
+    val factory = AsyncHttpClientCallFactory.builder()
+            .callCustomizer(callCustomizer)
+            .httpClient(httpClient)
+            .build();
+
+    // when
+    val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
+    val callRequest = call.createRequest(call.request());
+
+    // then
+    assertTrue(numCustomized.get() == 1);
+    assertTrue(numRequestStart.get() == 0);
+    assertTrue(numRequestSuccess.get() == 0);
+    assertTrue(numRequestFailure.get() == 0);
+
+    // let's see whether request customizers did their job
+    // final async-http-client request should have modified URL and one
+    // additional header value.
+    assertEquals(callRequest.getUrl(), rewriteUrl);
+    assertEquals(callRequest.getHeaders().get(headerName), headerValue);
+
+    // final call should have additional consumers set
+    assertNotNull(call.getOnRequestStart());
+    assertTrue(call.getOnRequestStart().size() == 1);
+
+    assertNotNull(call.getOnRequestSuccess());
+    assertTrue(call.getOnRequestSuccess().size() == 1);
+
+    assertNotNull(call.getOnRequestFailure());
+    assertTrue(call.getOnRequestFailure().size() == 1);
+
+    assertNotNull(call.getRequestCustomizers());
+    assertTrue(call.getRequestCustomizers().size() == 2);
+  }
+
+  @Test(expectedExceptions = NullPointerException.class,
+          expectedExceptionsMessageRegExp = "httpClientSupplier is marked @NonNull but is null")
+  void shouldThrowISEIfHttpClientIsNotDefined() {
+    // given
+    val factory = AsyncHttpClientCallFactory.builder()
+            .build();
+
+    // when
+    val httpClient = factory.getHttpClient();
+
+    // then
+    assertNull(httpClient);
+  }
+
+  @Test
+  void shouldUseHttpClientInstanceIfSupplierIsNotAvailable() {
+    // given
+    val httpClient = mock(AsyncHttpClient.class);
+
+    val factory = AsyncHttpClientCallFactory.builder()
+            .httpClient(httpClient)
+            .build();
+
+    // when
+    val usedHttpClient = factory.getHttpClient();
+
+    // then
+    assertTrue(usedHttpClient == httpClient);
+
+    // when
+    val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
+
+    // then: call should contain correct http client
+    assertTrue(call.getHttpClient()== httpClient);
+  }
+
+  @Test
+  void shouldPreferHttpClientSupplierOverHttpClient() {
+    // given
+    val httpClientA = mock(AsyncHttpClient.class);
+    val httpClientB = mock(AsyncHttpClient.class);
+
+    val factory = AsyncHttpClientCallFactory.builder()
+            .httpClient(httpClientA)
+            .httpClientSupplier(() -> httpClientB)
+            .build();
+
+    // when
+    val usedHttpClient = factory.getHttpClient();
+
+    // then
+    assertTrue(usedHttpClient == httpClientB);
+
+    // when: try to create new call
+    val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
+
+    // then: call should contain correct http client
+    assertNotNull(call);
+    assertTrue(call.getHttpClient() == httpClientB);
+  }
 }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
index 1bfd81151..e655ed73f 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
@@ -12,33 +12,57 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.*;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.*;
-import static org.testng.Assert.assertTrue;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
+import lombok.*;
+import lombok.extern.slf4j.Slf4j;
+import okhttp3.*;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.mockito.ArgumentCaptor;
+import org.testng.Assert;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
+import java.util.function.Supplier;
 
-import lombok.val;
-import okhttp3.Request;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
-import org.testng.Assert;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.runConsumer;
+import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.runConsumers;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
 
+@Slf4j
 public class AsyncHttpClientCallTest {
     static final Request REQUEST = new Request.Builder().url("http://www.google.com/").build();
+    static final DefaultAsyncHttpClientConfig DEFAULT_AHC_CONFIG = new DefaultAsyncHttpClientConfig.Builder()
+            .setRequestTimeout(1_000)
+            .build();
+
+    private AsyncHttpClient httpClient;
+    private Supplier<AsyncHttpClient> httpClientSupplier = () -> httpClient;
+
+    @BeforeMethod
+    void setup() {
+      httpClient = mock(AsyncHttpClient.class);
+      when(httpClient.getConfig()).thenReturn(DEFAULT_AHC_CONFIG);
+    }
 
     @Test(expectedExceptions = NullPointerException.class, dataProvider = "first")
     void builderShouldThrowInCaseOfMissingProperties(AsyncHttpClientCall.AsyncHttpClientCallBuilder builder) {
@@ -47,12 +71,10 @@ void builderShouldThrowInCaseOfMissingProperties(AsyncHttpClientCall.AsyncHttpCl
 
     @DataProvider(name = "first")
     Object[][] dataProviderFirst() {
-        val httpClient = mock(AsyncHttpClient.class);
-
         return new Object[][]{
                 {AsyncHttpClientCall.builder()},
                 {AsyncHttpClientCall.builder().request(REQUEST)},
-                {AsyncHttpClientCall.builder().httpClient(httpClient)}
+                {AsyncHttpClientCall.builder().httpClientSupplier(httpClientSupplier)}
         };
     }
 
@@ -70,7 +92,7 @@ void shouldInvokeConsumersOnEachExecution(Consumer<AsyncCompletionHandler<?>> ha
         val numRequestCustomizer = new AtomicInteger();
 
         // prepare http client mock
-        val httpClient = mock(AsyncHttpClient.class);
+        this.httpClient = mock(AsyncHttpClient.class);
 
         val mockRequest = mock(org.asynchttpclient.Request.class);
         when(mockRequest.getHeaders()).thenReturn(EmptyHttpHeaders.INSTANCE);
@@ -80,20 +102,19 @@ void shouldInvokeConsumersOnEachExecution(Consumer<AsyncCompletionHandler<?>> ha
 
         when(httpClient.executeRequest((org.asynchttpclient.Request) any(), any())).then(invocationOnMock -> {
             @SuppressWarnings("rawtypes")
-            val handler = invocationOnMock.getArgumentAt(1, AsyncCompletionHandler.class);
+            AsyncCompletionHandler<?> handler = invocationOnMock.getArgument(1);
             handlerConsumer.accept(handler);
             return null;
         });
 
         // create call instance
         val call = AsyncHttpClientCall.builder()
-                .httpClient(httpClient)
+                .httpClientSupplier(httpClientSupplier)
                 .request(REQUEST)
                 .onRequestStart(e -> numStarted.incrementAndGet())
                 .onRequestFailure(t -> numFailed.incrementAndGet())
                 .onRequestSuccess(r -> numOk.incrementAndGet())
                 .requestCustomizer(rb -> numRequestCustomizer.incrementAndGet())
-                .executeTimeoutMillis(1000)
                 .build();
 
         // when
@@ -156,7 +177,7 @@ void shouldInvokeConsumersOnEachExecution(Consumer<AsyncCompletionHandler<?>> ha
     void toIOExceptionShouldProduceExpectedResult(Throwable exception) {
         // given
         val call = AsyncHttpClientCall.builder()
-                .httpClient(mock(AsyncHttpClient.class))
+                .httpClientSupplier(httpClientSupplier)
                 .request(REQUEST)
                 .build();
 
@@ -225,6 +246,169 @@ void toIOExceptionShouldProduceExpectedResult(Throwable exception) {
         };
     }
 
+    @Test
+    public void contentTypeHeaderIsPassedInRequest() throws Exception {
+        Request request = requestWithBody();
+
+        ArgumentCaptor<org.asynchttpclient.Request> capture = ArgumentCaptor.forClass(org.asynchttpclient.Request.class);
+
+        givenResponseIsProduced(httpClient, aResponse());
+
+        whenRequestIsMade(httpClient, request);
+
+        verify(httpClient).executeRequest(capture.capture(), any());
+
+        org.asynchttpclient.Request ahcRequest = capture.getValue();
+
+        assertTrue(ahcRequest.getHeaders().containsValue("accept", "application/vnd.hal+json", true),
+                "Accept header not found");
+        assertEquals(ahcRequest.getHeaders().get("content-type"), "application/json",
+                "Content-Type header not found");
+    }
+
+    @Test
+    public void contenTypeIsOptionalInResponse() throws Exception {
+        givenResponseIsProduced(httpClient, responseWithBody(null, "test"));
+
+        okhttp3.Response response = whenRequestIsMade(httpClient, REQUEST);
+
+        assertEquals(response.code(), 200);
+        assertEquals(response.header("Server"), "nginx");
+        assertEquals(response.body().contentType(), null);
+        assertEquals(response.body().string(), "test");
+    }
+
+    @Test
+    public void contentTypeIsProperlyParsedIfPresent() throws Exception {
+        givenResponseIsProduced(httpClient, responseWithBody("text/plain", "test"));
+
+        okhttp3.Response response = whenRequestIsMade(httpClient, REQUEST);
+
+        assertEquals(response.code(), 200);
+        assertEquals(response.header("Server"), "nginx");
+        assertEquals(response.body().contentType(), MediaType.parse("text/plain"));
+        assertEquals(response.body().string(), "test");
+
+    }
+
+    @Test
+    public void bodyIsNotNullInResponse() throws Exception {
+        givenResponseIsProduced(httpClient, responseWithNoBody());
+
+        okhttp3.Response response = whenRequestIsMade(httpClient, REQUEST);
+
+        assertEquals(response.code(), 200);
+        assertEquals(response.header("Server"), "nginx");
+        assertNotEquals(response.body(), null);
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class, expectedExceptionsMessageRegExp = ".*returned null.")
+    void getHttpClientShouldThrowISEIfSupplierReturnsNull() {
+      // given:
+      val call = AsyncHttpClientCall.builder()
+              .httpClientSupplier(() -> null)
+              .request(requestWithBody())
+              .build();
+
+      // when: should throw ISE
+      call.getHttpClient();
+    }
+
+    @Test
+    void shouldReturnTimeoutSpecifiedInAHCInstanceConfig() {
+        // given:
+        val cfgBuilder = new DefaultAsyncHttpClientConfig.Builder();
+        AsyncHttpClientConfig config = null;
+
+        // and: setup call
+        val call = AsyncHttpClientCall.builder()
+                .httpClientSupplier(httpClientSupplier)
+                .request(requestWithBody())
+                .build();
+
+        // when: set read timeout to 5s, req timeout to 6s
+        config = cfgBuilder.setReadTimeout((int) SECONDS.toMillis(5))
+                .setRequestTimeout((int) SECONDS.toMillis(6))
+                .build();
+        when(httpClient.getConfig()).thenReturn(config);
+
+        // then: expect request timeout
+        assertEquals(call.getRequestTimeoutMillis(), SECONDS.toMillis(6));
+        assertEquals(call.timeout().timeoutNanos(), SECONDS.toNanos(6));
+
+        // when: set read timeout to 10 seconds, req timeout to 7s
+        config = cfgBuilder.setReadTimeout((int) SECONDS.toMillis(10))
+                .setRequestTimeout((int) SECONDS.toMillis(7))
+                .build();
+        when(httpClient.getConfig()).thenReturn(config);
+
+        // then: expect request timeout
+        assertEquals(call.getRequestTimeoutMillis(), SECONDS.toMillis(7));
+        assertEquals(call.timeout().timeoutNanos(), SECONDS.toNanos(7));
+
+        // when: set request timeout to a negative value, just for fun.
+        config = cfgBuilder.setRequestTimeout(-1000)
+                .setReadTimeout(2000)
+                .build();
+
+        when(httpClient.getConfig()).thenReturn(config);
+
+        // then: expect request timeout, but as positive value
+        assertEquals(call.getRequestTimeoutMillis(), SECONDS.toMillis(1));
+        assertEquals(call.timeout().timeoutNanos(), SECONDS.toNanos(1));
+    }
+
+    private void givenResponseIsProduced(AsyncHttpClient client, Response response) {
+        when(client.executeRequest(any(org.asynchttpclient.Request.class), any())).thenAnswer(invocation -> {
+            AsyncCompletionHandler<Response> handler = invocation.getArgument(1);
+            handler.onCompleted(response);
+            return null;
+        });
+    }
+
+    private okhttp3.Response whenRequestIsMade(AsyncHttpClient client, Request request) throws IOException {
+        return AsyncHttpClientCall.builder()
+                .httpClientSupplier(() -> client)
+                .request(request)
+                .build()
+                .execute();
+    }
+
+    private Request requestWithBody() {
+        return new Request.Builder()
+                .post(RequestBody.create(MediaType.parse("application/json"), "{\"hello\":\"world\"}".getBytes(StandardCharsets.UTF_8)))
+                .url("http://example.org/resource")
+                .addHeader("Accept", "application/vnd.hal+json")
+                .build();
+    }
+
+    private Response aResponse() {
+        Response response = mock(Response.class);
+        when(response.getStatusCode()).thenReturn(200);
+        when(response.getStatusText()).thenReturn("OK");
+        when(response.hasResponseHeaders()).thenReturn(true);
+        when(response.getHeaders()).thenReturn(new DefaultHttpHeaders()
+                .add("Server", "nginx")
+        );
+        when(response.hasResponseBody()).thenReturn(false);
+        return response;
+    }
+
+    private Response responseWithBody(String contentType, String content) {
+        Response response = aResponse();
+        when(response.hasResponseBody()).thenReturn(true);
+        when(response.getContentType()).thenReturn(contentType);
+        when(response.getResponseBodyAsBytes()).thenReturn(content.getBytes(StandardCharsets.UTF_8));
+        return response;
+    }
+
+    private Response responseWithNoBody() {
+        Response response = aResponse();
+        when(response.hasResponseBody()).thenReturn(false);
+        when(response.getContentType()).thenReturn(null);
+        return response;
+    }
+
     private void doThrow(String message) {
         throw new RuntimeException(message);
     }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
index d370e38c9..151c54c6c 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
@@ -20,11 +20,7 @@
 import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.asynchttpclient.testserver.HttpServer;
 import org.asynchttpclient.testserver.HttpTest;
-import org.testng.annotations.AfterSuite;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.BeforeTest;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
+import org.testng.annotations.*;
 import retrofit2.HttpException;
 import retrofit2.Retrofit;
 import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
@@ -43,7 +39,6 @@
 
 import static org.asynchttpclient.extras.retrofit.TestServices.Contributor;
 import static org.testng.Assert.*;
-import static org.testng.AssertJUnit.assertEquals;
 
 /**
  * All tests in this test suite are disabled, because they call functionality of github service that is
@@ -51,393 +46,390 @@
  */
 @Slf4j
 public class AsyncHttpRetrofitIntegrationTest extends HttpTest {
-    private static final ObjectMapper objectMapper = new ObjectMapper();
-    private static final String OWNER = "AsyncHttpClient";
-    private static final String REPO = "async-http-client";
-
-    private static final AsyncHttpClient httpClient = createHttpClient();
-    private static HttpServer server;
-
-    private List<Contributor> expectedContributors;
-
-    private static AsyncHttpClient createHttpClient() {
-        val config = new DefaultAsyncHttpClientConfig.Builder()
-                .setCompressionEnforced(true)
-                .setTcpNoDelay(true)
-                .setKeepAlive(true)
-                .setPooledConnectionIdleTimeout(120_000)
-                .setFollowRedirect(true)
-                .setMaxRedirects(5)
-                .build();
-
-        return new DefaultAsyncHttpClient(config);
-    }
-
-    @BeforeClass
-    public static void start() throws Throwable {
-        server = new HttpServer();
-        server.start();
-    }
-
-    @BeforeTest
-    void before() {
-        this.expectedContributors = generateContributors();
-    }
-
-    @AfterSuite
-    void cleanup() throws IOException {
-        httpClient.close();
-    }
-
-    // begin: synchronous execution
-    @Test
-    public void testSynchronousService_OK() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_OK_WithBadEncoding() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_FAIL() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then:
-        assertNull(resultRef.get());
-    }
-
-    @Test
-    public void testSynchronousService_NOT_FOUND() throws Throwable {
-        // given
-        val service = synchronousSetup();
-
-        // when:
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            val contributors = service.contributors(OWNER, REPO).execute().body();
-            log.info("contributors: {}", contributors);
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then:
-        assertNull(resultRef.get());
-    }
-
-    private TestServices.GithubSync synchronousSetup() {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .callFactory(callFactory)
-                .build();
-        val service = retrofit.create(TestServices.GithubSync.class);
-        return service;
-    }
-    // end: synchronous execution
-
-    // begin: rxjava 1.x
-    @Test(dataProvider = "testRxJava1Service")
-    public void testRxJava1Service_OK(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava1Service")
-    public void testRxJava1Service_OK_WithBadEncoding(RxJavaCallAdapterFactory rxJavaCallAdapterFactory)
-            throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava1Service", expectedExceptions = HttpException.class,
-            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-    public void testRxJava1Service_HTTP_500(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    @Test(dataProvider = "testRxJava1Service",
-            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-    public void testRxJava1Service_NOT_FOUND(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava1Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    private TestServices.GithubRxJava1 rxjava1Setup(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .addCallAdapterFactory(rxJavaCallAdapterFactory)
-                .callFactory(callFactory)
-                .build();
-        return retrofit.create(TestServices.GithubRxJava1.class);
-    }
-
-    @DataProvider(name = "testRxJava1Service")
-    Object[][] testRxJava1Service_DataProvider() {
-        return new Object[][]{
-                {RxJavaCallAdapterFactory.create()},
-                {RxJavaCallAdapterFactory.createAsync()},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io())},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.computation())},
-                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.trampoline())},
-        };
-    }
-    // end: rxjava 1.x
-
-    // begin: rxjava 2.x
-    @Test(dataProvider = "testRxJava2Service")
-    public void testRxJava2Service_OK(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributors(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava2Service")
-    public void testRxJava2Service_OK_WithBadEncoding(RxJava2CallAdapterFactory rxJavaCallAdapterFactory)
-            throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-
-        // then
-        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-    }
-
-    @Test(dataProvider = "testRxJava2Service", expectedExceptions = HttpException.class,
-            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-    public void testRxJava2Service_HTTP_500(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    @Test(dataProvider = "testRxJava2Service",
-            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-    public void testRxJava2Service_NOT_FOUND(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-        // given
-        val service = rxjava2Setup(rxJavaCallAdapterFactory);
-        val expectedContributors = generateContributors();
-
-        // when
-        val resultRef = new AtomicReference<List<Contributor>>();
-        withServer(server).run(srv -> {
-            configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-            // execute retrofit request
-            val contributors = service.contributors(OWNER, REPO).blockingGet();
-            resultRef.compareAndSet(null, contributors);
-        });
-    }
-
-    private TestServices.GithubRxJava2 rxjava2Setup(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) {
-        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-        val retrofit = createRetrofitBuilder()
-                .addCallAdapterFactory(rxJavaCallAdapterFactory)
-                .callFactory(callFactory)
-                .build();
-        return retrofit.create(TestServices.GithubRxJava2.class);
-    }
-
-    @DataProvider(name = "testRxJava2Service")
-    Object[][] testRxJava2Service_DataProvider() {
-        return new Object[][]{
-                {RxJava2CallAdapterFactory.create()},
-                {RxJava2CallAdapterFactory.createAsync()},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.io())},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.computation())},
-                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.trampoline())},
-        };
-    }
-    // end: rxjava 2.x
-
-    private Retrofit.Builder createRetrofitBuilder() {
-        return new Retrofit.Builder()
-                .addConverterFactory(ScalarsConverterFactory.create())
-                .addConverterFactory(JacksonConverterFactory.create(objectMapper))
-                .validateEagerly(true)
-                .baseUrl(server.getHttpUrl());
-    }
-
-    /**
-     * Asserts contributors.
-     *
-     * @param expected expected list of contributors
-     * @param actual   actual retrieved list of contributors.
-     */
-    private void assertContributors(Collection<Contributor> expected, Collection<Contributor> actual) {
-        assertNotNull(actual, "Retrieved contributors should not be null.");
-        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-        assertTrue(expected.size() == actual.size());
-        assertEquals(expected, actual);
-    }
-
-    private void assertContributorsWithWrongCharset(List<Contributor> expected, List<Contributor> actual) {
-        assertNotNull(actual, "Retrieved contributors should not be null.");
-        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-        assertTrue(expected.size() == actual.size());
-
-        // first and second element should have different logins due to problems with decoding utf8 to us-ascii
-        assertNotEquals(expected.get(0).getLogin(), actual.get(0).getLogin());
-        assertEquals(expected.get(0).getContributions(), actual.get(0).getContributions());
-
-        assertNotEquals(expected.get(1).getLogin(), actual.get(1).getLogin());
-        assertEquals(expected.get(1).getContributions(), actual.get(1).getContributions());
-
-        // other elements should be equal
-        for (int i = 2; i < expected.size(); i++) {
-            assertEquals(expected.get(i), actual.get(i));
-        }
-    }
-
-    private List<Contributor> generateContributors() {
-        val list = new ArrayList<Contributor>();
-
-        list.add(new Contributor(UUID.randomUUID() + ": čćžšđ", 100));
-        list.add(new Contributor(UUID.randomUUID() + ": ČĆŽŠĐ", 200));
-
-        IntStream.range(0, (int) (Math.random() * 100)).forEach(i -> {
-            list.add(new Contributor(UUID.randomUUID().toString(), (int) (Math.random() * 500)));
-        });
-
-        return list;
-    }
-
-    private HttpServer configureTestServer(HttpServer server, int status,
-                                           Collection<Contributor> contributors,
-                                           String charset) {
-        server.enqueueResponse(response -> {
-            response.setStatus(status);
-            if (status == 200) {
-                response.setHeader("Content-Type", "application/json; charset=" + charset);
-                response.getOutputStream().write(objectMapper.writeValueAsBytes(contributors));
-            } else {
-                response.setHeader("Content-Type", "text/plain");
-                val errorMsg = "This is an " + status + " error";
-                response.getOutputStream().write(errorMsg.getBytes());
-            }
-        });
-
-        return server;
+  private static final ObjectMapper objectMapper = new ObjectMapper();
+  private static final String OWNER = "AsyncHttpClient";
+  private static final String REPO = "async-http-client";
+
+  private static final AsyncHttpClient httpClient = createHttpClient();
+  private static HttpServer server;
+
+  private List<Contributor> expectedContributors;
+
+  private static AsyncHttpClient createHttpClient() {
+    val config = new DefaultAsyncHttpClientConfig.Builder()
+            .setCompressionEnforced(true)
+            .setTcpNoDelay(true)
+            .setKeepAlive(true)
+            .setPooledConnectionIdleTimeout(120_000)
+            .setFollowRedirect(true)
+            .setMaxRedirects(5)
+            .build();
+
+    return new DefaultAsyncHttpClient(config);
+  }
+
+  @BeforeClass
+  public static void start() throws Throwable {
+    server = new HttpServer();
+    server.start();
+  }
+
+  @BeforeTest
+  void before() {
+    this.expectedContributors = generateContributors();
+  }
+
+  @AfterSuite
+  void cleanup() throws IOException {
+    httpClient.close();
+  }
+
+  // begin: synchronous execution
+  @Test
+  public void testSynchronousService_OK() throws Throwable {
+    // given
+    val service = synchronousSetup();
+
+    // when:
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+      val contributors = service.contributors(OWNER, REPO).execute().body();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributors(expectedContributors, resultRef.get());
+  }
+
+  @Test
+  public void testSynchronousService_OK_WithBadEncoding() throws Throwable {
+    // given
+    val service = synchronousSetup();
+
+    // when:
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+      val contributors = service.contributors(OWNER, REPO).execute().body();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+  }
+
+  @Test
+  public void testSynchronousService_FAIL() throws Throwable {
+    // given
+    val service = synchronousSetup();
+
+    // when:
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+      val contributors = service.contributors(OWNER, REPO).execute().body();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then:
+    assertNull(resultRef.get());
+  }
+
+  @Test
+  public void testSynchronousService_NOT_FOUND() throws Throwable {
+    // given
+    val service = synchronousSetup();
+
+    // when:
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+      val contributors = service.contributors(OWNER, REPO).execute().body();
+      log.info("contributors: {}", contributors);
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then:
+    assertNull(resultRef.get());
+  }
+
+  private TestServices.GithubSync synchronousSetup() {
+    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+    val retrofit = createRetrofitBuilder()
+            .callFactory(callFactory)
+            .build();
+    return retrofit.create(TestServices.GithubSync.class);
+  }
+  // end: synchronous execution
+
+  // begin: rxjava 1.x
+  @Test(dataProvider = "testRxJava1Service")
+  public void testRxJava1Service_OK(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava1Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributors(expectedContributors, resultRef.get());
+  }
+
+  @Test(dataProvider = "testRxJava1Service")
+  public void testRxJava1Service_OK_WithBadEncoding(RxJavaCallAdapterFactory rxJavaCallAdapterFactory)
+          throws Throwable {
+    // given
+    val service = rxjava1Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+  }
+
+  @Test(dataProvider = "testRxJava1Service", expectedExceptions = HttpException.class,
+          expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
+  public void testRxJava1Service_HTTP_500(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava1Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+      resultRef.compareAndSet(null, contributors);
+    });
+  }
+
+  @Test(dataProvider = "testRxJava1Service",
+          expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
+  public void testRxJava1Service_NOT_FOUND(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava1Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+      resultRef.compareAndSet(null, contributors);
+    });
+  }
+
+  private TestServices.GithubRxJava1 rxjava1Setup(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) {
+    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+    val retrofit = createRetrofitBuilder()
+            .addCallAdapterFactory(rxJavaCallAdapterFactory)
+            .callFactory(callFactory)
+            .build();
+    return retrofit.create(TestServices.GithubRxJava1.class);
+  }
+
+  @DataProvider(name = "testRxJava1Service")
+  Object[][] testRxJava1Service_DataProvider() {
+    return new Object[][]{
+            {RxJavaCallAdapterFactory.create()},
+            {RxJavaCallAdapterFactory.createAsync()},
+            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io())},
+            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.computation())},
+            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.trampoline())},
+    };
+  }
+  // end: rxjava 1.x
+
+  // begin: rxjava 2.x
+  @Test(dataProvider = "testRxJava2Service")
+  public void testRxJava2Service_OK(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava2Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).blockingGet();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributors(expectedContributors, resultRef.get());
+  }
+
+  @Test(dataProvider = "testRxJava2Service")
+  public void testRxJava2Service_OK_WithBadEncoding(RxJava2CallAdapterFactory rxJavaCallAdapterFactory)
+          throws Throwable {
+    // given
+    val service = rxjava2Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).blockingGet();
+      resultRef.compareAndSet(null, contributors);
+    });
+
+    // then
+    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+  }
+
+  @Test(dataProvider = "testRxJava2Service", expectedExceptions = HttpException.class,
+          expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
+  public void testRxJava2Service_HTTP_500(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava2Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).blockingGet();
+      resultRef.compareAndSet(null, contributors);
+    });
+  }
+
+  @Test(dataProvider = "testRxJava2Service",
+          expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
+  public void testRxJava2Service_NOT_FOUND(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+    // given
+    val service = rxjava2Setup(rxJavaCallAdapterFactory);
+    val expectedContributors = generateContributors();
+
+    // when
+    val resultRef = new AtomicReference<List<Contributor>>();
+    withServer(server).run(srv -> {
+      configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+      // execute retrofit request
+      val contributors = service.contributors(OWNER, REPO).blockingGet();
+      resultRef.compareAndSet(null, contributors);
+    });
+  }
+
+  private TestServices.GithubRxJava2 rxjava2Setup(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) {
+    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+    val retrofit = createRetrofitBuilder()
+            .addCallAdapterFactory(rxJavaCallAdapterFactory)
+            .callFactory(callFactory)
+            .build();
+    return retrofit.create(TestServices.GithubRxJava2.class);
+  }
+
+  @DataProvider(name = "testRxJava2Service")
+  Object[][] testRxJava2Service_DataProvider() {
+    return new Object[][]{
+            {RxJava2CallAdapterFactory.create()},
+            {RxJava2CallAdapterFactory.createAsync()},
+            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.io())},
+            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.computation())},
+            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.trampoline())},
+    };
+  }
+  // end: rxjava 2.x
+
+  private Retrofit.Builder createRetrofitBuilder() {
+    return new Retrofit.Builder()
+            .addConverterFactory(ScalarsConverterFactory.create())
+            .addConverterFactory(JacksonConverterFactory.create(objectMapper))
+            .validateEagerly(true)
+            .baseUrl(server.getHttpUrl());
+  }
+
+  /**
+   * Asserts contributors.
+   *
+   * @param expected expected list of contributors
+   * @param actual   actual retrieved list of contributors.
+   */
+  private void assertContributors(Collection<Contributor> expected, Collection<Contributor> actual) {
+    assertNotNull(actual, "Retrieved contributors should not be null.");
+    log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
+    assertTrue(expected.size() == actual.size());
+    assertEquals(expected, actual);
+  }
+
+  private void assertContributorsWithWrongCharset(List<Contributor> expected, List<Contributor> actual) {
+    assertNotNull(actual, "Retrieved contributors should not be null.");
+    log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
+    assertTrue(expected.size() == actual.size());
+
+    // first and second element should have different logins due to problems with decoding utf8 to us-ascii
+    assertNotEquals(expected.get(0).getLogin(), actual.get(0).getLogin());
+    assertEquals(expected.get(0).getContributions(), actual.get(0).getContributions());
+
+    assertNotEquals(expected.get(1).getLogin(), actual.get(1).getLogin());
+    assertEquals(expected.get(1).getContributions(), actual.get(1).getContributions());
+
+    // other elements should be equal
+    for (int i = 2; i < expected.size(); i++) {
+      assertEquals(expected.get(i), actual.get(i));
     }
+  }
+
+  private List<Contributor> generateContributors() {
+    val list = new ArrayList<Contributor>();
+
+    list.add(new Contributor(UUID.randomUUID() + ": čćžšđ", 100));
+    list.add(new Contributor(UUID.randomUUID() + ": ČĆŽŠĐ", 200));
+
+    IntStream
+            .range(0, (int) (Math.random() * 100))
+            .forEach(i -> list.add(new Contributor(UUID.randomUUID().toString(), (int) (Math.random() * 500))));
+
+    return list;
+  }
+
+  private void configureTestServer(HttpServer server, int status,
+                                         Collection<Contributor> contributors,
+                                         String charset) {
+    server.enqueueResponse(response -> {
+      response.setStatus(status);
+      if (status == 200) {
+        response.setHeader("Content-Type", "application/json; charset=" + charset);
+        response.getOutputStream().write(objectMapper.writeValueAsBytes(contributors));
+      } else {
+        response.setHeader("Content-Type", "text/plain");
+        val errorMsg = "This is an " + status + " error";
+        response.getOutputStream().write(errorMsg.getBytes());
+      }
+    });
+  }
 }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
index 6e0939dba..cb8872acb 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
@@ -13,8 +13,7 @@
 package org.asynchttpclient.extras.retrofit;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
-import lombok.NonNull;
-import lombok.Value;
+import lombok.*;
 import retrofit2.Call;
 import retrofit2.http.GET;
 import retrofit2.http.Path;
@@ -26,39 +25,41 @@
 /**
  * Github DTOs and services.
  */
-public class TestServices {
-    @Value
-    @JsonIgnoreProperties(ignoreUnknown = true)
-    public static class Contributor implements Serializable {
-        private static final long serialVersionUID = 1;
+class TestServices {
+  /**
+   * Synchronous interface
+   */
+  public interface GithubSync {
+    @GET("/repos/{owner}/{repo}/contributors")
+    Call<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+  }
 
-        @NonNull
-        String login;
+  /**
+   * RxJava 1.x reactive interface
+   */
+  public interface GithubRxJava1 {
+    @GET("/repos/{owner}/{repo}/contributors")
+    Observable<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+  }
 
-        int contributions;
-    }
+  /**
+   * RxJava 2.x reactive interface
+   */
+  public interface GithubRxJava2 {
+    @GET("/repos/{owner}/{repo}/contributors")
+    io.reactivex.Single<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+  }
 
-    /**
-     * Synchronous interface
-     */
-    public interface GithubSync {
-        @GET("/repos/{owner}/{repo}/contributors")
-        Call<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
+  @Data
+  @NoArgsConstructor
+  @AllArgsConstructor
+  @JsonIgnoreProperties(ignoreUnknown = true)
+  static class Contributor implements Serializable {
+    private static final long serialVersionUID = 1;
 
-    /**
-     * RxJava 1.x reactive interface
-     */
-    public interface GithubRxJava1 {
-        @GET("/repos/{owner}/{repo}/contributors")
-        Observable<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
+    @NonNull
+    String login;
 
-    /**
-     * RxJava 2.x reactive interface
-     */
-    public interface GithubRxJava2 {
-        @GET("/repos/{owner}/{repo}/contributors")
-        io.reactivex.Single<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-    }
+    int contributions;
+  }
 }
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 7c77178cc..51e936f05 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <artifactId>async-http-client-extras-rxjava</artifactId>
-    <name>Asynchronous Http Client RxJava Extras</name>
-    <description>The Async Http Client RxJava Extras.</description>
-    <dependencies>
-        <dependency>
-            <groupId>io.reactivex</groupId>
-            <artifactId>rxjava</artifactId>
-        </dependency>
-    </dependencies>
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <artifactId>async-http-client-extras-rxjava</artifactId>
+  <name>Asynchronous Http Client RxJava Extras</name>
+  <description>The Async Http Client RxJava Extras.</description>
+  <dependencies>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
index 91865432e..6fb1713f7 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
@@ -22,63 +22,63 @@
 
 /**
  * Provide RxJava support for executing requests. Request can be subscribed to and manipulated as needed.
- * 
+ *
  * @see <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>
  */
 public class AsyncHttpObservable {
 
-    /**
-     * Observe a request execution and emit the response to the observer.
-     *
-     * @param supplier the supplier
-     * @return The cold observable (must be subscribed to in order to execute).
-     */
-    public static Observable<Response> toObservable(final Func0<BoundRequestBuilder> supplier) {
+  /**
+   * Observe a request execution and emit the response to the observer.
+   *
+   * @param supplier the supplier
+   * @return The cold observable (must be subscribed to in order to execute).
+   */
+  public static Observable<Response> toObservable(final Func0<BoundRequestBuilder> supplier) {
 
-        //Get the builder from the function
-        final BoundRequestBuilder builder = supplier.call();
+    //Get the builder from the function
+    final BoundRequestBuilder builder = supplier.call();
 
-        //create the observable from scratch
-        return Observable.unsafeCreate(new Observable.OnSubscribe<Response>() {
+    //create the observable from scratch
+    return Observable.unsafeCreate(new Observable.OnSubscribe<Response>() {
 
-            @Override
-            public void call(final Subscriber<? super Response> subscriber) {
-                try {
-                    AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {
+      @Override
+      public void call(final Subscriber<? super Response> subscriber) {
+        try {
+          AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {
 
-                        @Override
-                        public Void onCompleted(Response response) throws Exception {
-                            subscriber.onNext(response);
-                            subscriber.onCompleted();
-                            return null;
-                        }
+            @Override
+            public Void onCompleted(Response response) throws Exception {
+              subscriber.onNext(response);
+              subscriber.onCompleted();
+              return null;
+            }
 
-                        @Override
-                        public void onThrowable(Throwable t) {
-                            subscriber.onError(t);
-                        }
-                    };
-                    //execute the request
-                    builder.execute(handler);
-                } catch (Throwable t) {
-                    subscriber.onError(t);
-                }
+            @Override
+            public void onThrowable(Throwable t) {
+              subscriber.onError(t);
             }
-        });
-    }
+          };
+          //execute the request
+          builder.execute(handler);
+        } catch (Throwable t) {
+          subscriber.onError(t);
+        }
+      }
+    });
+  }
 
-    /**
-     * Observe a request execution and emit the response to the observer.
-     *
-     * @param supplier teh supplier
-     * @return The hot observable (eagerly executes).
-     */
-    public static Observable<Response> observe(final Func0<BoundRequestBuilder> supplier) {
-        //use a ReplaySubject to buffer the eagerly subscribed-to Observable
-        ReplaySubject<Response> subject = ReplaySubject.create();
-        //eagerly kick off subscription
-        toObservable(supplier).subscribe(subject);
-        //return the subject that can be subscribed to later while the execution has already started
-        return subject;
-    }
+  /**
+   * Observe a request execution and emit the response to the observer.
+   *
+   * @param supplier teh supplier
+   * @return The hot observable (eagerly executes).
+   */
+  public static Observable<Response> observe(final Func0<BoundRequestBuilder> supplier) {
+    //use a ReplaySubject to buffer the eagerly subscribed-to Observable
+    ReplaySubject<Response> subject = ReplaySubject.create();
+    //eagerly kick off subscription
+    toObservable(supplier).subscribe(subject);
+    //return the subject that can be subscribed to later while the execution has already started
+    return subject;
+  }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
index c1a7099db..eeae82f28 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
@@ -20,10 +20,10 @@
 @SuppressWarnings("serial")
 public class UnsubscribedException extends CancellationException {
 
-    public UnsubscribedException() {
-    }
+  public UnsubscribedException() {
+  }
 
-    public UnsubscribedException(final Throwable cause) {
-        initCause(cause);
-    }
+  public UnsubscribedException(final Throwable cause) {
+    initCause(cause);
+  }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
index dfdd87a09..bea48961e 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
@@ -13,31 +13,30 @@
 package org.asynchttpclient.extras.rxjava.single;
 
 import org.asynchttpclient.handler.ProgressAsyncHandler;
-
 import rx.SingleSubscriber;
 
 abstract class AbstractProgressSingleSubscriberBridge<T> extends AbstractSingleSubscriberBridge<T> implements ProgressAsyncHandler<Void> {
 
-    protected AbstractProgressSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
-        super(subscriber);
-    }
+  protected AbstractProgressSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
+    super(subscriber);
+  }
 
-    @Override
-    public State onHeadersWritten() {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersWritten();
-    }
+  @Override
+  public State onHeadersWritten() {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersWritten();
+  }
 
-    @Override
-    public State onContentWritten() {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onContentWritten();
-    }
+  @Override
+  public State onContentWritten() {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onContentWritten();
+  }
 
-    @Override
-    public State onContentWriteProgress(long amount, long current, long total) {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onContentWriteProgress(amount, current, total);
-    }
+  @Override
+  public State onContentWriteProgress(long amount, long current, long total) {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onContentWriteProgress(amount, current, total);
+  }
 
-    @Override
-    protected abstract ProgressAsyncHandler<? extends T> delegate();
+  @Override
+  protected abstract ProgressAsyncHandler<? extends T> delegate();
 
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
index c64c3ceb4..bb6749fee 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
@@ -12,110 +12,109 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import static java.util.Objects.requireNonNull;
 import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava.UnsubscribedException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
 import rx.SingleSubscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
 
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static java.util.Objects.requireNonNull;
+
 abstract class AbstractSingleSubscriberBridge<T> implements AsyncHandler<Void> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractSingleSubscriberBridge.class);
+  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractSingleSubscriberBridge.class);
 
-    protected final SingleSubscriber<T> subscriber;
+  protected final SingleSubscriber<T> subscriber;
 
-    private final AtomicBoolean delegateTerminated = new AtomicBoolean();
+  private final AtomicBoolean delegateTerminated = new AtomicBoolean();
 
-    protected AbstractSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
-        this.subscriber = requireNonNull(subscriber);
-    }
+  protected AbstractSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
+    this.subscriber = requireNonNull(subscriber);
+  }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onBodyPartReceived(content);
-    }
+  @Override
+  public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onBodyPartReceived(content);
+  }
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus status) throws Exception {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onStatusReceived(status);
-    }
+  @Override
+  public State onStatusReceived(HttpResponseStatus status) throws Exception {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onStatusReceived(status);
+  }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersReceived(headers);
+  @Override
+  public State onHeadersReceived(HttpHeaders headers) throws Exception {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersReceived(headers);
+  }
+
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+    return subscriber.isUnsubscribed() ? abort() : delegate().onTrailingHeadersReceived(headers);
+  }
+
+  @Override
+  public Void onCompleted() {
+    if (delegateTerminated.getAndSet(true)) {
+      return null;
     }
 
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        return subscriber.isUnsubscribed() ? abort() : delegate().onTrailingHeadersReceived(headers);
+    final T result;
+    try {
+      result = delegate().onCompleted();
+    } catch (final Throwable t) {
+      emitOnError(t);
+      return null;
     }
 
-    @Override
-    public Void onCompleted() {
-        if (delegateTerminated.getAndSet(true)) {
-            return null;
-        }
-
-        final T result;
-        try {
-            result = delegate().onCompleted();
-        } catch (final Throwable t) {
-            emitOnError(t);
-            return null;
-        }
-
-        if (!subscriber.isUnsubscribed()) {
-            subscriber.onSuccess(result);
-        }
-
-        return null;
+    if (!subscriber.isUnsubscribed()) {
+      subscriber.onSuccess(result);
     }
 
-    @Override
-    public void onThrowable(Throwable t) {
-        if (delegateTerminated.getAndSet(true)) {
-            return;
-        }
+    return null;
+  }
 
-        Throwable error = t;
-        try {
-            delegate().onThrowable(t);
-        } catch (final Throwable x) {
-            error = new CompositeException(Arrays.asList(t, x));
-        }
+  @Override
+  public void onThrowable(Throwable t) {
+    if (delegateTerminated.getAndSet(true)) {
+      return;
+    }
 
-        emitOnError(error);
+    Throwable error = t;
+    try {
+      delegate().onThrowable(t);
+    } catch (final Throwable x) {
+      error = new CompositeException(Arrays.asList(t, x));
     }
 
-    protected AsyncHandler.State abort() {
-        if (!delegateTerminated.getAndSet(true)) {
-            // send a terminal event to the delegate
-            // e.g. to trigger cleanup logic
-            delegate().onThrowable(new UnsubscribedException());
-        }
+    emitOnError(error);
+  }
 
-        return State.ABORT;
+  protected AsyncHandler.State abort() {
+    if (!delegateTerminated.getAndSet(true)) {
+      // send a terminal event to the delegate
+      // e.g. to trigger cleanup logic
+      delegate().onThrowable(new UnsubscribedException());
     }
 
-    protected abstract AsyncHandler<? extends T> delegate();
+    return State.ABORT;
+  }
+
+  protected abstract AsyncHandler<? extends T> delegate();
 
-    private void emitOnError(Throwable error) {
-        Exceptions.throwIfFatal(error);
-        if (!subscriber.isUnsubscribed()) {
-            subscriber.onError(error);
-        } else {
-            LOGGER.debug("Not propagating onError after unsubscription: {}", error.getMessage(), error);
-        }
+  private void emitOnError(Throwable error) {
+    Exceptions.throwIfFatal(error);
+    if (!subscriber.isUnsubscribed()) {
+      subscriber.onError(error);
+    } else {
+      LOGGER.debug("Not propagating onError after unsubscription: {}", error.getMessage(), error);
     }
+  }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
index 4e95aab84..e52fbcf89 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
@@ -12,130 +12,122 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import static java.util.Objects.requireNonNull;
-
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
-
-import java.util.concurrent.Future;
-
 import rx.Single;
 import rx.SingleSubscriber;
 import rx.functions.Func0;
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
 
+import java.util.concurrent.Future;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Wraps HTTP requests into RxJava {@code Single} instances.
  *
  * @see <a href="https://github.com/ReactiveX/RxJava">https://github.com/
- *      ReactiveX/RxJava</a>
+ * ReactiveX/RxJava</a>
  */
 public final class AsyncHttpSingle {
 
-    /**
-     * Emits the responses to HTTP requests obtained from {@code builder}.
-     *
-     * @param builder used to build the HTTP request that is to be executed
-     * @return a {@code Single} that executes new requests on subscription
-     *         obtained from {@code builder} on subscription and that emits the
-     *         response
-     *
-     * @throws NullPointerException if {@code builder} is {@code null}
-     */
-    public static Single<Response> create(BoundRequestBuilder builder) {
-        requireNonNull(builder);
-        return create(builder::execute, AsyncCompletionHandlerBase::new);
-    }
+  private AsyncHttpSingle() {
+    throw new AssertionError("No instances for you!");
+  }
 
-    /**
-     * Emits the responses to HTTP requests obtained by calling
-     * {@code requestTemplate}.
-     *
-     * @param requestTemplate called to start the HTTP request with an
-     *            {@code AysncHandler} that builds the HTTP response and
-     *            propagates results to the returned {@code Single}. The
-     *            {@code Future} that is returned by {@code requestTemplate}
-     *            will be used to cancel the request when the {@code Single} is
-     *            unsubscribed.
-     *
-     * @return a {@code Single} that executes new requests on subscription by
-     *         calling {@code requestTemplate} and that emits the response
-     *
-     * @throws NullPointerException if {@code requestTemplate} is {@code null}
-     */
-    public static Single<Response> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate) {
-        return create(requestTemplate, AsyncCompletionHandlerBase::new);
-    }
+  /**
+   * Emits the responses to HTTP requests obtained from {@code builder}.
+   *
+   * @param builder used to build the HTTP request that is to be executed
+   * @return a {@code Single} that executes new requests on subscription
+   * obtained from {@code builder} on subscription and that emits the
+   * response
+   * @throws NullPointerException if {@code builder} is {@code null}
+   */
+  public static Single<Response> create(BoundRequestBuilder builder) {
+    requireNonNull(builder);
+    return create(builder::execute, AsyncCompletionHandlerBase::new);
+  }
 
-    /**
-     * Emits the results of {@code AsyncHandlers} obtained from
-     * {@code handlerSupplier} for HTTP requests obtained from {@code builder}.
-     *
-     * @param builder used to build the HTTP request that is to be executed
-     * @param handlerSupplier supplies the desired {@code AsyncHandler}
-     *            instances that are used to produce results
-     *
-     * @return a {@code Single} that executes new requests on subscription
-     *         obtained from {@code builder} and that emits the result of the
-     *         {@code AsyncHandler} obtained from {@code handlerSupplier}
-     *
-     * @throws NullPointerException if at least one of the parameters is
-     *             {@code null}
-     */
-    public static <T> Single<T> create(BoundRequestBuilder builder, Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
-        requireNonNull(builder);
-        return create(builder::execute, handlerSupplier);
-    }
+  /**
+   * Emits the responses to HTTP requests obtained by calling
+   * {@code requestTemplate}.
+   *
+   * @param requestTemplate called to start the HTTP request with an
+   *                        {@code AysncHandler} that builds the HTTP response and
+   *                        propagates results to the returned {@code Single}. The
+   *                        {@code Future} that is returned by {@code requestTemplate}
+   *                        will be used to cancel the request when the {@code Single} is
+   *                        unsubscribed.
+   * @return a {@code Single} that executes new requests on subscription by
+   * calling {@code requestTemplate} and that emits the response
+   * @throws NullPointerException if {@code requestTemplate} is {@code null}
+   */
+  public static Single<Response> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate) {
+    return create(requestTemplate, AsyncCompletionHandlerBase::new);
+  }
 
-    /**
-     * Emits the results of {@code AsyncHandlers} obtained from
-     * {@code handlerSupplier} for HTTP requests obtained obtained by calling
-     * {@code requestTemplate}.
-     *
-     * @param requestTemplate called to start the HTTP request with an
-     *            {@code AysncHandler} that builds the HTTP response and
-     *            propagates results to the returned {@code Single}.  The
-     *            {@code Future} that is returned by {@code requestTemplate}
-     *            will be used to cancel the request when the {@code Single} is
-     *            unsubscribed.
-     * @param handlerSupplier supplies the desired {@code AsyncHandler}
-     *            instances that are used to produce results
-     *
-     * @return a {@code Single} that executes new requests on subscription by
-     *         calling {@code requestTemplate} and that emits the results
-     *         produced by the {@code AsyncHandlers} supplied by
-     *         {@code handlerSupplier}
-     *
-     * @throws NullPointerException if at least one of the parameters is
-     *             {@code null}
-     */
-    public static <T> Single<T> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate,
-            Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
+  /**
+   * Emits the results of {@code AsyncHandlers} obtained from
+   * {@code handlerSupplier} for HTTP requests obtained from {@code builder}.
+   *
+   * @param builder         used to build the HTTP request that is to be executed
+   * @param handlerSupplier supplies the desired {@code AsyncHandler}
+   *                        instances that are used to produce results
+   * @return a {@code Single} that executes new requests on subscription
+   * obtained from {@code builder} and that emits the result of the
+   * {@code AsyncHandler} obtained from {@code handlerSupplier}
+   * @throws NullPointerException if at least one of the parameters is
+   *                              {@code null}
+   */
+  public static <T> Single<T> create(BoundRequestBuilder builder, Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
+    requireNonNull(builder);
+    return create(builder::execute, handlerSupplier);
+  }
 
-        requireNonNull(requestTemplate);
-        requireNonNull(handlerSupplier);
+  /**
+   * Emits the results of {@code AsyncHandlers} obtained from
+   * {@code handlerSupplier} for HTTP requests obtained obtained by calling
+   * {@code requestTemplate}.
+   *
+   * @param requestTemplate called to start the HTTP request with an
+   *                        {@code AysncHandler} that builds the HTTP response and
+   *                        propagates results to the returned {@code Single}.  The
+   *                        {@code Future} that is returned by {@code requestTemplate}
+   *                        will be used to cancel the request when the {@code Single} is
+   *                        unsubscribed.
+   * @param handlerSupplier supplies the desired {@code AsyncHandler}
+   *                        instances that are used to produce results
+   * @return a {@code Single} that executes new requests on subscription by
+   * calling {@code requestTemplate} and that emits the results
+   * produced by the {@code AsyncHandlers} supplied by
+   * {@code handlerSupplier}
+   * @throws NullPointerException if at least one of the parameters is
+   *                              {@code null}
+   */
+  public static <T> Single<T> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate,
+                                     Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
 
-        return Single.create(subscriber -> {
-            final AsyncHandler<?> bridge = createBridge(subscriber, handlerSupplier.call());
-            final Future<?> responseFuture = requestTemplate.call(bridge);
-            subscriber.add(Subscriptions.from(responseFuture));
-        });
-    }
+    requireNonNull(requestTemplate);
+    requireNonNull(handlerSupplier);
 
-    static <T> AsyncHandler<?> createBridge(SingleSubscriber<? super T> subscriber, AsyncHandler<? extends T> handler) {
+    return Single.create(subscriber -> {
+      final AsyncHandler<?> bridge = createBridge(subscriber, handlerSupplier.call());
+      final Future<?> responseFuture = requestTemplate.call(bridge);
+      subscriber.add(Subscriptions.from(responseFuture));
+    });
+  }
 
-        if (handler instanceof ProgressAsyncHandler) {
-            return new ProgressAsyncSingleSubscriberBridge<>(subscriber, (ProgressAsyncHandler<? extends T>) handler);
-        }
+  static <T> AsyncHandler<?> createBridge(SingleSubscriber<? super T> subscriber, AsyncHandler<? extends T> handler) {
 
-        return new AsyncSingleSubscriberBridge<>(subscriber, handler);
+    if (handler instanceof ProgressAsyncHandler) {
+      return new ProgressAsyncSingleSubscriberBridge<>(subscriber, (ProgressAsyncHandler<? extends T>) handler);
     }
 
-    private AsyncHttpSingle() {
-        throw new AssertionError("No instances for you!");
-    }
+    return new AsyncSingleSubscriberBridge<>(subscriber, handler);
+  }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
index 4d3889710..ccef13e9d 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
@@ -12,24 +12,23 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import static java.util.Objects.requireNonNull;
-
 import org.asynchttpclient.AsyncHandler;
-
 import rx.SingleSubscriber;
 
+import static java.util.Objects.requireNonNull;
+
 final class AsyncSingleSubscriberBridge<T> extends AbstractSingleSubscriberBridge<T> {
 
-    private final AsyncHandler<? extends T> delegate;
+  private final AsyncHandler<? extends T> delegate;
 
-    public AsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, AsyncHandler<? extends T> delegate) {
-        super(subscriber);
-        this.delegate = requireNonNull(delegate);
-    }
+  public AsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, AsyncHandler<? extends T> delegate) {
+    super(subscriber);
+    this.delegate = requireNonNull(delegate);
+  }
 
-    @Override
-    protected AsyncHandler<? extends T> delegate() {
-        return delegate;
-    }
+  @Override
+  protected AsyncHandler<? extends T> delegate() {
+    return delegate;
+  }
 
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
index 78d0948df..3a1ffda2c 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
@@ -12,24 +12,23 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import static java.util.Objects.requireNonNull;
-
 import org.asynchttpclient.handler.ProgressAsyncHandler;
-
 import rx.SingleSubscriber;
 
+import static java.util.Objects.requireNonNull;
+
 final class ProgressAsyncSingleSubscriberBridge<T> extends AbstractProgressSingleSubscriberBridge<T> {
 
-    private final ProgressAsyncHandler<? extends T> delegate;
+  private final ProgressAsyncHandler<? extends T> delegate;
 
-    public ProgressAsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, ProgressAsyncHandler<? extends T> delegate) {
-        super(subscriber);
-        this.delegate = requireNonNull(delegate);
-    }
+  public ProgressAsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, ProgressAsyncHandler<? extends T> delegate) {
+    super(subscriber);
+    this.delegate = requireNonNull(delegate);
+  }
 
-    @Override
-    protected ProgressAsyncHandler<? extends T> delegate() {
-        return delegate;
-    }
+  @Override
+  protected ProgressAsyncHandler<? extends T> delegate() {
+    return delegate;
+  }
 
 }
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
index b97993dc5..8adbecd3a 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -12,122 +12,122 @@
  */
 package org.asynchttpclient.extras.rxjava;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
-
-import java.util.List;
-
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
-
 import rx.Observable;
 import rx.observers.TestSubscriber;
 
+import java.util.List;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
 public class AsyncHttpObservableTest {
 
-    @Test(groups = "standalone")
-    public void testToObservableNoError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
+  @Test
+  public void testToObservableNoError() {
+    final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 200);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io"));
+      o1.subscribe(tester);
+      tester.awaitTerminalEvent();
+      tester.assertTerminalEvent();
+      tester.assertNoErrors();
+      tester.assertCompleted();
+      List<Response> responses = tester.getOnNextEvents();
+      assertNotNull(responses);
+      assertEquals(responses.size(), 1);
+      assertEquals(responses.get(0).getStatusCode(), 200);
+    } catch (Exception e) {
+      Thread.currentThread().interrupt();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testToObservableError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
+  @Test
+  public void testToObservableError() {
+    final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io/ttfn"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 404);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io/ttfn"));
+      o1.subscribe(tester);
+      tester.awaitTerminalEvent();
+      tester.assertTerminalEvent();
+      tester.assertNoErrors();
+      tester.assertCompleted();
+      List<Response> responses = tester.getOnNextEvents();
+      assertNotNull(responses);
+      assertEquals(responses.size(), 1);
+      assertEquals(responses.get(0).getStatusCode(), 404);
+    } catch (Exception e) {
+      Thread.currentThread().interrupt();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testObserveNoError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
+  @Test
+  public void testObserveNoError() {
+    final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 200);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+      o1.subscribe(tester);
+      tester.awaitTerminalEvent();
+      tester.assertTerminalEvent();
+      tester.assertNoErrors();
+      tester.assertCompleted();
+      List<Response> responses = tester.getOnNextEvents();
+      assertNotNull(responses);
+      assertEquals(responses.size(), 1);
+      assertEquals(responses.get(0).getStatusCode(), 200);
+    } catch (Exception e) {
+      Thread.currentThread().interrupt();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testObserveError() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
+  @Test
+  public void testObserveError() {
+    final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io/ttfn"));
-            o1.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 1);
-            assertEquals(responses.get(0).getStatusCode(), 404);
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io/ttfn"));
+      o1.subscribe(tester);
+      tester.awaitTerminalEvent();
+      tester.assertTerminalEvent();
+      tester.assertNoErrors();
+      tester.assertCompleted();
+      List<Response> responses = tester.getOnNextEvents();
+      assertNotNull(responses);
+      assertEquals(responses.size(), 1);
+      assertEquals(responses.get(0).getStatusCode(), 404);
+    } catch (Exception e) {
+      Thread.currentThread().interrupt();
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testObserveMultiple() {
-        final TestSubscriber<Response> tester = new TestSubscriber<>();
+  @Test
+  public void testObserveMultiple() {
+    final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
-            Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
-            Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
-            Observable<Response> all = Observable.merge(o1, o2, o3);
-            all.subscribe(tester);
-            tester.awaitTerminalEvent();
-            tester.assertTerminalEvent();
-            tester.assertNoErrors();
-            tester.assertCompleted();
-            List<Response> responses = tester.getOnNextEvents();
-            assertNotNull(responses);
-            assertEquals(responses.size(), 3);
-            for (Response response : responses) {
-                assertEquals(response.getStatusCode(), 200);
-            }
-        } catch (Exception e) {
-            Thread.currentThread().interrupt();
-        }
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+      Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
+      Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
+      Observable<Response> all = Observable.merge(o1, o2, o3);
+      all.subscribe(tester);
+      tester.awaitTerminalEvent();
+      tester.assertTerminalEvent();
+      tester.assertNoErrors();
+      tester.assertCompleted();
+      List<Response> responses = tester.getOnNextEvents();
+      assertNotNull(responses);
+      assertEquals(responses.size(), 3);
+      for (Response response : responses) {
+        assertEquals(response.getStatusCode(), 200);
+      }
+    } catch (Exception e) {
+      Thread.currentThread().interrupt();
     }
+  }
 }
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
index f7f5f9b62..018da8044 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
@@ -12,317 +12,295 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static org.testng.Assert.assertEquals;
-
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
 import org.asynchttpclient.extras.rxjava.UnsubscribedException;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.mockito.InOrder;
 import org.testng.annotations.Test;
+import rx.Single;
+import rx.exceptions.CompositeException;
+import rx.observers.TestSubscriber;
 
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
 
-import rx.Single;
-import rx.exceptions.CompositeException;
-import rx.observers.TestSubscriber;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Mockito.*;
+import static org.testng.Assert.assertEquals;
 
 public class AsyncHttpSingleTest {
 
-    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
-    public void testFailsOnNullRequest() {
-        AsyncHttpSingle.create((BoundRequestBuilder) null);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
-    public void testFailsOnNullHandlerSupplier() {
-        AsyncHttpSingle.create(mock(BoundRequestBuilder.class), null);
-    }
-
-    @Test(groups = "standalone")
-    public void testSuccessfulCompletion() throws Exception {
+  @Test(expectedExceptions = {NullPointerException.class})
+  public void testFailsOnNullRequest() {
+    AsyncHttpSingle.create((BoundRequestBuilder) null);
+  }
 
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
+  @Test(expectedExceptions = {NullPointerException.class})
+  public void testFailsOnNullHandlerSupplier() {
+    AsyncHttpSingle.create(mock(BoundRequestBuilder.class), null);
+  }
 
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
+  @Test
+  public void testSuccessfulCompletion() throws Exception {
 
-                bridge.onStatusReceived(null);
-                verify(handler).onStatusReceived(null);
+    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+    when(handler.onCompleted()).thenReturn(handler);
 
-                bridge.onHeadersReceived(null);
-                verify(handler).onHeadersReceived(null);
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      try {
+        assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
 
-                bridge.onBodyPartReceived(null);
-                verify(handler).onBodyPartReceived(null);
+        bridge.onStatusReceived(null);
+        verify(handler).onStatusReceived(null);
 
-                bridge.onTrailingHeadersReceived(null);
-                verify(handler).onTrailingHeadersReceived(null);
+        bridge.onHeadersReceived(null);
+        verify(handler).onHeadersReceived(null);
 
-                bridge.onCompleted();
-                verify(handler).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
+        bridge.onBodyPartReceived(null);
+        verify(handler).onBodyPartReceived(null);
 
-            return mock(Future.class);
-        } , () -> handler);
+        bridge.onTrailingHeadersReceived(null);
+        verify(handler).onTrailingHeadersReceived(null);
 
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        verifyNoMoreInteractions(handler);
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(handler);
-    }
-
-    @Test(groups = "standalone")
-    public void testSuccessfulCompletionWithProgress() throws Exception {
-
-        @SuppressWarnings("unchecked")
-        final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
-        final InOrder inOrder = inOrder(handler);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
-
-                final ProgressAsyncHandler<?> progressBridge = (ProgressAsyncHandler<?>) bridge;
-
-                progressBridge.onHeadersWritten();
-                inOrder.verify(handler).onHeadersWritten();
-
-                progressBridge.onContentWriteProgress(60, 40, 100);
-                inOrder.verify(handler).onContentWriteProgress(60, 40, 100);
-
-                progressBridge.onContentWritten();
-                inOrder.verify(handler).onContentWritten();
-
-                progressBridge.onStatusReceived(null);
-                inOrder.verify(handler).onStatusReceived(null);
-
-                progressBridge.onHeadersReceived(null);
-                inOrder.verify(handler).onHeadersReceived(null);
+        bridge.onCompleted();
+        verify(handler).onCompleted();
+      } catch (final Throwable t) {
+        bridge.onThrowable(t);
+      }
 
-                progressBridge.onBodyPartReceived(null);
-                inOrder.verify(handler).onBodyPartReceived(null);
+      return mock(Future.class);
+    }, () -> handler);
 
-                bridge.onTrailingHeadersReceived(null);
-                verify(handler).onTrailingHeadersReceived(null);
+    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+    underTest.subscribe(subscriber);
 
-                progressBridge.onCompleted();
-                inOrder.verify(handler).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
+    verifyNoMoreInteractions(handler);
 
-            return mock(Future.class);
-        } , () -> handler);
+    subscriber.awaitTerminalEvent();
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoErrors();
+    subscriber.assertCompleted();
+    subscriber.assertValue(handler);
+  }
 
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
+  @Test
+  public void testSuccessfulCompletionWithProgress() throws Exception {
 
-        inOrder.verifyNoMoreInteractions();
+    @SuppressWarnings("unchecked") final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
+    when(handler.onCompleted()).thenReturn(handler);
+    final InOrder inOrder = inOrder(handler);
 
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(handler);
-    }
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      try {
+        assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
 
-    @Test(groups = "standalone")
-    public void testNewRequestForEachSubscription() throws Exception {
-        final BoundRequestBuilder builder = mock(BoundRequestBuilder.class);
+        final ProgressAsyncHandler<?> progressBridge = (ProgressAsyncHandler<?>) bridge;
 
-        final Single<?> underTest = AsyncHttpSingle.create(builder);
-        underTest.subscribe(new TestSubscriber<>());
-        underTest.subscribe(new TestSubscriber<>());
+        progressBridge.onHeadersWritten();
+        inOrder.verify(handler).onHeadersWritten();
 
-        verify(builder, times(2)).execute(any());
-        verifyNoMoreInteractions(builder);
-    }
+        progressBridge.onContentWriteProgress(60, 40, 100);
+        inOrder.verify(handler).onContentWriteProgress(60, 40, 100);
 
-    @Test(groups = "standalone")
-    public void testErrorPropagation() throws Exception {
+        progressBridge.onContentWritten();
+        inOrder.verify(handler).onContentWritten();
 
-        final RuntimeException expectedException = new RuntimeException("expected");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenReturn(handler);
-        final InOrder inOrder = inOrder(handler);
+        progressBridge.onStatusReceived(null);
+        inOrder.verify(handler).onStatusReceived(null);
 
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onStatusReceived(null);
-                inOrder.verify(handler).onStatusReceived(null);
+        progressBridge.onHeadersReceived(null);
+        inOrder.verify(handler).onHeadersReceived(null);
 
-                bridge.onHeadersReceived(null);
-                inOrder.verify(handler).onHeadersReceived(null);
+        progressBridge.onBodyPartReceived(null);
+        inOrder.verify(handler).onBodyPartReceived(null);
 
-                bridge.onBodyPartReceived(null);
-                inOrder.verify(handler).onBodyPartReceived(null);
+        bridge.onTrailingHeadersReceived(null);
+        verify(handler).onTrailingHeadersReceived(null);
 
-                bridge.onThrowable(expectedException);
-                inOrder.verify(handler).onThrowable(expectedException);
+        progressBridge.onCompleted();
+        inOrder.verify(handler).onCompleted();
+      } catch (final Throwable t) {
+        bridge.onThrowable(t);
+      }
 
-                // test that no further events are invoked after terminal events
-                bridge.onCompleted();
-                inOrder.verify(handler, never()).onCompleted();
-            } catch (final Throwable t) {
-                bridge.onThrowable(t);
-            }
+      return mock(Future.class);
+    }, () -> handler);
 
-            return mock(Future.class);
-        } , () -> handler);
+    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+    underTest.subscribe(subscriber);
 
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
+    inOrder.verifyNoMoreInteractions();
 
-        inOrder.verifyNoMoreInteractions();
+    subscriber.awaitTerminalEvent();
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoErrors();
+    subscriber.assertCompleted();
+    subscriber.assertValue(handler);
+  }
 
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-        subscriber.assertError(expectedException);
-    }
+  @Test
+  public void testNewRequestForEachSubscription() {
+    final BoundRequestBuilder builder = mock(BoundRequestBuilder.class);
 
-    @Test(groups = "standalone")
-    public void testErrorInOnCompletedPropagation() throws Exception {
+    final Single<?> underTest = AsyncHttpSingle.create(builder);
+    underTest.subscribe(new TestSubscriber<>());
+    underTest.subscribe(new TestSubscriber<>());
 
-        final RuntimeException expectedException = new RuntimeException("expected");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        when(handler.onCompleted()).thenThrow(expectedException);
+    verify(builder, times(2)).execute(any());
+    verifyNoMoreInteractions(builder);
+  }
 
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onCompleted();
-                return mock(Future.class);
-            } catch (final Throwable t) {
-                throw new AssertionError(t);
-            }
-        } , () -> handler);
+  @Test
+  public void testErrorPropagation() throws Exception {
 
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
+    final RuntimeException expectedException = new RuntimeException("expected");
+    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+    when(handler.onCompleted()).thenReturn(handler);
+    final InOrder inOrder = inOrder(handler);
 
-        verify(handler).onCompleted();
-        verifyNoMoreInteractions(handler);
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      try {
+        bridge.onStatusReceived(null);
+        inOrder.verify(handler).onStatusReceived(null);
 
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-        subscriber.assertError(expectedException);
+        bridge.onHeadersReceived(null);
+        inOrder.verify(handler).onHeadersReceived(null);
+
+        bridge.onBodyPartReceived(null);
+        inOrder.verify(handler).onBodyPartReceived(null);
+
+        bridge.onThrowable(expectedException);
+        inOrder.verify(handler).onThrowable(expectedException);
+
+        // test that no further events are invoked after terminal events
+        bridge.onCompleted();
+        inOrder.verify(handler, never()).onCompleted();
+      } catch (final Throwable t) {
+        bridge.onThrowable(t);
+      }
+
+      return mock(Future.class);
+    }, () -> handler);
+
+    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+    underTest.subscribe(subscriber);
+
+    inOrder.verifyNoMoreInteractions();
+
+    subscriber.awaitTerminalEvent();
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoValues();
+    subscriber.assertError(expectedException);
+  }
+
+  @Test
+  public void testErrorInOnCompletedPropagation() throws Exception {
+
+    final RuntimeException expectedException = new RuntimeException("expected");
+    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+    when(handler.onCompleted()).thenThrow(expectedException);
+
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      try {
+        bridge.onCompleted();
+        return mock(Future.class);
+      } catch (final Throwable t) {
+        throw new AssertionError(t);
+      }
+    }, () -> handler);
+
+    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+    underTest.subscribe(subscriber);
+
+    verify(handler).onCompleted();
+    verifyNoMoreInteractions(handler);
+
+    subscriber.awaitTerminalEvent();
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoValues();
+    subscriber.assertError(expectedException);
+  }
+
+  @Test
+  public void testErrorInOnThrowablePropagation() {
+
+    final RuntimeException processingException = new RuntimeException("processing");
+    final RuntimeException thrownException = new RuntimeException("thrown");
+    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+    doThrow(thrownException).when(handler).onThrowable(processingException);
+
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      try {
+        bridge.onThrowable(processingException);
+        return mock(Future.class);
+      } catch (final Throwable t) {
+        throw new AssertionError(t);
+      }
+    }, () -> handler);
+
+    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+    underTest.subscribe(subscriber);
+
+    verify(handler).onThrowable(processingException);
+    verifyNoMoreInteractions(handler);
+
+    subscriber.awaitTerminalEvent();
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoValues();
+
+    final List<Throwable> errorEvents = subscriber.getOnErrorEvents();
+    assertEquals(errorEvents.size(), 1);
+    assertThat(errorEvents.get(0), is(instanceOf(CompositeException.class)));
+    final CompositeException error = (CompositeException) errorEvents.get(0);
+    assertEquals(error.getExceptions(), Arrays.asList(processingException, thrownException));
+  }
+
+  @Test
+  public void testAbort() throws Exception {
+    final TestSubscriber<Response> subscriber = new TestSubscriber<>();
+
+    try (AsyncHttpClient client = asyncHttpClient()) {
+      final Single<Response> underTest = AsyncHttpSingle.create(client.prepareGet("http://gatling.io"),
+              () -> new AsyncCompletionHandlerBase() {
+                @Override
+                public State onStatusReceived(HttpResponseStatus status) {
+                  return State.ABORT;
+                }
+              });
+
+      underTest.subscribe(subscriber);
+      subscriber.awaitTerminalEvent();
     }
 
-    @Test(groups = "standalone")
-    public void testErrorInOnThrowablePropagation() throws Exception {
-
-        final RuntimeException processingException = new RuntimeException("processing");
-        final RuntimeException thrownException = new RuntimeException("thrown");
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        doThrow(thrownException).when(handler).onThrowable(processingException);
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            try {
-                bridge.onThrowable(processingException);
-                return mock(Future.class);
-            } catch (final Throwable t) {
-                throw new AssertionError(t);
-            }
-        } , () -> handler);
-
-        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-        underTest.subscribe(subscriber);
-
-        verify(handler).onThrowable(processingException);
-        verifyNoMoreInteractions(handler);
-
-        subscriber.awaitTerminalEvent();
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoValues();
-
-        final List<Throwable> errorEvents = subscriber.getOnErrorEvents();
-        assertEquals(errorEvents.size(), 1);
-        assertThat(errorEvents.get(0), is(instanceOf(CompositeException.class)));
-        final CompositeException error = (CompositeException) errorEvents.get(0);
-        assertEquals(error.getExceptions(), Arrays.asList(processingException, thrownException));
-    }
-
-    @Test(groups = "standalone")
-    public void testAbort() throws Exception {
-        final TestSubscriber<Response> subscriber = new TestSubscriber<>();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final Single<Response> underTest = AsyncHttpSingle.create(client.prepareGet("http://gatling.io"),
-                    () -> new AsyncCompletionHandlerBase() {
-                        @Override
-                        public State onStatusReceived(HttpResponseStatus status) {
-                            return State.ABORT;
-                        }
-                    });
-
-            underTest.subscribe(subscriber);
-            subscriber.awaitTerminalEvent();
-        }
-
-        subscriber.assertTerminalEvent();
-        subscriber.assertNoErrors();
-        subscriber.assertCompleted();
-        subscriber.assertValue(null);
-    }
-
-    @Test(groups = "standalone")
-    public void testUnsubscribe() throws Exception {
-        @SuppressWarnings("unchecked")
-        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-        final Future<?> future = mock(Future.class);
-        final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
-
-        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-            bridgeRef.set(bridge);
-            return future;
-        } , () -> handler);
-
-        underTest.subscribe().unsubscribe();
-        verify(future).cancel(true);
-        verifyZeroInteractions(handler);
-
-        assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
-        verify(handler).onThrowable(isA(UnsubscribedException.class));
-        verifyNoMoreInteractions(handler);
-    }
+    subscriber.assertTerminalEvent();
+    subscriber.assertNoErrors();
+    subscriber.assertCompleted();
+    subscriber.assertValue(null);
+  }
+
+  @Test
+  public void testUnsubscribe() throws Exception {
+    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+    final Future<?> future = mock(Future.class);
+    final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
+
+    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+      bridgeRef.set(bridge);
+      return future;
+    }, () -> handler);
+
+    underTest.subscribe().unsubscribe();
+    verify(future).cancel(true);
+    verifyZeroInteractions(handler);
+
+    assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
+    verify(handler).onThrowable(isA(UnsubscribedException.class));
+    verifyNoMoreInteractions(handler);
+  }
 }
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 434e67a95..59543cf26 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <artifactId>async-http-client-extras-rxjava2</artifactId>
-    <name>Asynchronous Http Client RxJava2 Extras</name>
-    <description>The Async Http Client RxJava2 Extras.</description>
-    <dependencies>
-        <dependency>
-            <groupId>io.reactivex.rxjava2</groupId>
-            <artifactId>rxjava</artifactId>
-        </dependency>
-    </dependencies>
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <artifactId>async-http-client-extras-rxjava2</artifactId>
+  <name>Asynchronous Http Client RxJava2 Extras</name>
+  <description>The Async Http Client RxJava2 Extras.</description>
+  <dependencies>
+    <dependency>
+      <groupId>io.reactivex.rxjava2</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
index 9f154bf6c..d582e3f9b 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
@@ -13,11 +13,9 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
-import static java.util.Objects.requireNonNull;
-
-import java.util.concurrent.Future;
-import java.util.function.Supplier;
-
+import io.reactivex.Maybe;
+import io.reactivex.MaybeEmitter;
+import io.reactivex.disposables.Disposables;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
@@ -25,63 +23,56 @@
 import org.asynchttpclient.extras.rxjava2.maybe.ProgressAsyncMaybeEmitterBridge;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
-import io.reactivex.Maybe;
-import io.reactivex.MaybeEmitter;
-import io.reactivex.disposables.Disposables;
+import java.util.concurrent.Future;
+import java.util.function.Supplier;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Straight forward default implementation of the {@code RxHttpClient} interface.
  */
 public class DefaultRxHttpClient implements RxHttpClient {
 
-    private final AsyncHttpClient asyncHttpClient;
+  private final AsyncHttpClient asyncHttpClient;
 
-    /**
-     * Returns a new {@code DefaultRxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
-     *
-     * @param asyncHttpClient
-     *            the Async HTTP Client instance to be used
-     *
-     * @throws NullPointerException
-     *             if {@code asyncHttpClient} is {@code null}
-     */
-    public DefaultRxHttpClient(AsyncHttpClient asyncHttpClient) {
-        this.asyncHttpClient = requireNonNull(asyncHttpClient);
-    }
-
-    @Override
-    public <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier) {
-        requireNonNull(request);
-        requireNonNull(handlerSupplier);
+  /**
+   * Returns a new {@code DefaultRxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
+   *
+   * @param asyncHttpClient the Async HTTP Client instance to be used
+   * @throws NullPointerException if {@code asyncHttpClient} is {@code null}
+   */
+  public DefaultRxHttpClient(AsyncHttpClient asyncHttpClient) {
+    this.asyncHttpClient = requireNonNull(asyncHttpClient);
+  }
 
-        return Maybe.create(emitter -> {
-            final AsyncHandler<?> bridge = createBridge(emitter, handlerSupplier.get());
-            final Future<?> responseFuture = asyncHttpClient.executeRequest(request, bridge);
-            emitter.setDisposable(Disposables.fromFuture(responseFuture));
-        });
-    }
+  @Override
+  public <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier) {
+    requireNonNull(request);
+    requireNonNull(handlerSupplier);
 
-    /**
-     * Creates an {@code AsyncHandler} that bridges events from the given {@code handler} to the given {@code emitter}
-     * and cancellation/disposal in the other direction.
-     *
-     * @param <T>
-     *            the result type produced by {@code handler} and emitted by {@code emitter}
-     *
-     * @param emitter
-     *            the RxJava emitter instance that receives results upon completion and will be queried for disposal
-     *            during event processing
-     * @param handler
-     *            the {@code AsyncHandler} instance that receives downstream events and produces the result that will be
-     *            emitted upon request completion
-     *
-     * @return the bridge handler
-     */
-    protected <T> AsyncHandler<?> createBridge(MaybeEmitter<T> emitter, AsyncHandler<T> handler) {
-        if (handler instanceof ProgressAsyncHandler) {
-            return new ProgressAsyncMaybeEmitterBridge<>(emitter, (ProgressAsyncHandler<? extends T>) handler);
-        }
+    return Maybe.create(emitter -> {
+      final AsyncHandler<?> bridge = createBridge(emitter, handlerSupplier.get());
+      final Future<?> responseFuture = asyncHttpClient.executeRequest(request, bridge);
+      emitter.setDisposable(Disposables.fromFuture(responseFuture));
+    });
+  }
 
-        return new MaybeAsyncHandlerBridge<>(emitter, handler);
+  /**
+   * Creates an {@code AsyncHandler} that bridges events from the given {@code handler} to the given {@code emitter}
+   * and cancellation/disposal in the other direction.
+   *
+   * @param <T>     the result type produced by {@code handler} and emitted by {@code emitter}
+   * @param emitter the RxJava emitter instance that receives results upon completion and will be queried for disposal
+   *                during event processing
+   * @param handler the {@code AsyncHandler} instance that receives downstream events and produces the result that will be
+   *                emitted upon request completion
+   * @return the bridge handler
+   */
+  protected <T> AsyncHandler<?> createBridge(MaybeEmitter<T> emitter, AsyncHandler<T> handler) {
+    if (handler instanceof ProgressAsyncHandler) {
+      return new ProgressAsyncMaybeEmitterBridge<>(emitter, (ProgressAsyncHandler<? extends T>) handler);
     }
+
+    return new MaybeAsyncHandlerBridge<>(emitter, handler);
+  }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
index 8113d12e8..dfaaf2cf8 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
@@ -19,9 +19,9 @@
  * Indicates that the HTTP request has been disposed asynchronously via RxJava.
  */
 public class DisposedException extends CancellationException {
-    private static final long serialVersionUID = -5885577182105850384L;
+  private static final long serialVersionUID = -5885577182105850384L;
 
-    public DisposedException(String message) {
-        super(message);
-    }
+  public DisposedException(String message) {
+    super(message);
+  }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
index 766de8a76..bf2fa3916 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
@@ -13,15 +13,10 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
-import java.util.function.Supplier;
-
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-
 import io.reactivex.Maybe;
+import org.asynchttpclient.*;
+
+import java.util.function.Supplier;
 
 /**
  * Prepares HTTP requests by wrapping them into RxJava 2 {@code Maybe} instances.
@@ -30,55 +25,40 @@
  */
 public interface RxHttpClient {
 
-    /**
-     * Returns a new {@code RxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
-     *
-     * @param asyncHttpClient
-     *            the Async HTTP Client instance to be used
-     *
-     * @return a new {@code RxHttpClient} instance
-     *
-     * @throws NullPointerException
-     *             if {@code asyncHttpClient} is {@code null}
-     */
-    static RxHttpClient create(AsyncHttpClient asyncHttpClient) {
-        return new DefaultRxHttpClient(asyncHttpClient);
-    }
+  /**
+   * Returns a new {@code RxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
+   *
+   * @param asyncHttpClient the Async HTTP Client instance to be used
+   * @return a new {@code RxHttpClient} instance
+   * @throws NullPointerException if {@code asyncHttpClient} is {@code null}
+   */
+  static RxHttpClient create(AsyncHttpClient asyncHttpClient) {
+    return new DefaultRxHttpClient(asyncHttpClient);
+  }
 
-    /**
-     * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
-     * be executed and its response will be emitted.
-     *
-     * @param request
-     *            the request that is to be executed
-     *
-     * @return a {@code Maybe} that executes {@code request} upon subscription and emits the response
-     *
-     * @throws NullPointerException
-     *             if {@code request} is {@code null}
-     */
-    default Maybe<Response> prepare(Request request) {
-        return prepare(request, AsyncCompletionHandlerBase::new);
-    }
+  /**
+   * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
+   * be executed and its response will be emitted.
+   *
+   * @param request the request that is to be executed
+   * @return a {@code Maybe} that executes {@code request} upon subscription and emits the response
+   * @throws NullPointerException if {@code request} is {@code null}
+   */
+  default Maybe<Response> prepare(Request request) {
+    return prepare(request, AsyncCompletionHandlerBase::new);
+  }
 
-    /**
-     * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
-     * be executed and the results of {@code AsyncHandlers} obtained from {@code handlerSupplier} will be emitted.
-     *
-     * @param <T>
-     *            the result type produced by handlers produced by {@code handlerSupplier} and emitted by the returned
-     *            {@code Maybe} instance
-     *
-     * @param request
-     *            the request that is to be executed
-     * @param handlerSupplier
-     *            supplies the desired {@code AsyncHandler} instances that are used to produce results
-     *
-     * @return a {@code Maybe} that executes {@code request} upon subscription and that emits the results produced by
-     *         the supplied handers
-     *
-     * @throws NullPointerException
-     *             if at least one of the parameters is {@code null}
-     */
-    <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier);
+  /**
+   * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
+   * be executed and the results of {@code AsyncHandlers} obtained from {@code handlerSupplier} will be emitted.
+   *
+   * @param <T>             the result type produced by handlers produced by {@code handlerSupplier} and emitted by the returned
+   *                        {@code Maybe} instance
+   * @param request         the request that is to be executed
+   * @param handlerSupplier supplies the desired {@code AsyncHandler} instances that are used to produce results
+   * @return a {@code Maybe} that executes {@code request} upon subscription and that emits the results produced by
+   * the supplied handers
+   * @throws NullPointerException if at least one of the parameters is {@code null}
+   */
+  <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier);
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
index 6386442aa..bf366f820 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
@@ -13,15 +13,10 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import static java.util.Objects.requireNonNull;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.exceptions.Exceptions;
-
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
@@ -29,160 +24,164 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Abstract base class that bridges events between the {@code Maybe} reactive base type and {@code AsyncHandlers}.
- *
+ * <p>
  * When an event is received, it's first checked if the Rx stream has been disposed asynchronously. If so, request
  * processing is {@linkplain #disposed() aborted}, otherwise, the event is forwarded to the {@linkplain #delegate()
  * wrapped handler}.
- *
+ * <p>
  * When the request is {@link AsyncHandler#onCompleted() completed}, the result produced by the wrapped instance is
  * forwarded to the {@code Maybe}: If the result is {@code null}, {@link MaybeEmitter#onComplete()} is invoked,
  * {@link MaybeEmitter#onSuccess(Object)} otherwise.
- *
+ * <p>
  * Any errors during request processing are forwarded via {@link MaybeEmitter#onError(Throwable)}.
  *
- * @param <T>
- *            the result type produced by the wrapped {@code AsyncHandler} and emitted via RxJava
+ * @param <T> the result type produced by the wrapped {@code AsyncHandler} and emitted via RxJava
  */
 public abstract class AbstractMaybeAsyncHandlerBridge<T> implements AsyncHandler<Void> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMaybeAsyncHandlerBridge.class);
-
-    private static volatile DisposedException sharedDisposed;
-
-    /**
-     * The Rx callback object that receives downstream events and will be queried for its
-     * {@link MaybeEmitter#isDisposed() disposed state} when Async HTTP Client callbacks are invoked.
-     */
-    protected final MaybeEmitter<T> emitter;
-
-    /**
-     * Indicates if the delegate has already received a terminal event.
-     */
-    private final AtomicBoolean delegateTerminated = new AtomicBoolean();
-
-    protected AbstractMaybeAsyncHandlerBridge(MaybeEmitter<T> emitter) {
-        this.emitter = requireNonNull(emitter);
-    }
-
-    @Override
-    public final State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-        return emitter.isDisposed() ? disposed() : delegate().onBodyPartReceived(content);
+  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMaybeAsyncHandlerBridge.class);
+
+  private static volatile DisposedException sharedDisposed;
+
+  /**
+   * The Rx callback object that receives downstream events and will be queried for its
+   * {@link MaybeEmitter#isDisposed() disposed state} when Async HTTP Client callbacks are invoked.
+   */
+  protected final MaybeEmitter<T> emitter;
+
+  /**
+   * Indicates if the delegate has already received a terminal event.
+   */
+  private final AtomicBoolean delegateTerminated = new AtomicBoolean();
+
+  protected AbstractMaybeAsyncHandlerBridge(MaybeEmitter<T> emitter) {
+    this.emitter = requireNonNull(emitter);
+  }
+
+  @Override
+  public final State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+    return emitter.isDisposed() ? disposed() : delegate().onBodyPartReceived(content);
+  }
+
+  @Override
+  public final State onStatusReceived(HttpResponseStatus status) throws Exception {
+    return emitter.isDisposed() ? disposed() : delegate().onStatusReceived(status);
+  }
+
+  @Override
+  public final State onHeadersReceived(HttpHeaders headers) throws Exception {
+    return emitter.isDisposed() ? disposed() : delegate().onHeadersReceived(headers);
+  }
+
+  @Override
+  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+    return emitter.isDisposed() ? disposed() : delegate().onTrailingHeadersReceived(headers);
+  }
+
+  /**
+   * {@inheritDoc}
+   * <p>
+   * <p>
+   * The value returned by the wrapped {@code AsyncHandler} won't be returned by this method, but emtited via RxJava.
+   * </p>
+   *
+   * @return always {@code null}
+   */
+  @Override
+  public final Void onCompleted() {
+    if (delegateTerminated.getAndSet(true)) {
+      return null;
     }
 
-    @Override
-    public final State onStatusReceived(HttpResponseStatus status) throws Exception {
-        return emitter.isDisposed() ? disposed() : delegate().onStatusReceived(status);
+    final T result;
+    try {
+      result = delegate().onCompleted();
+    } catch (final Throwable t) {
+      emitOnError(t);
+      return null;
     }
 
-    @Override
-    public final State onHeadersReceived(HttpHeaders headers) throws Exception {
-        return emitter.isDisposed() ? disposed() : delegate().onHeadersReceived(headers);
+    if (!emitter.isDisposed()) {
+      if (result == null) {
+        emitter.onComplete();
+      } else {
+        emitter.onSuccess(result);
+      }
     }
 
-    @Override
-    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-        return emitter.isDisposed() ? disposed() : delegate().onTrailingHeadersReceived(headers);
+    return null;
+  }
+
+  /**
+   * {@inheritDoc}
+   * <p>
+   * <p>
+   * The exception will first be propagated to the wrapped {@code AsyncHandler}, then emitted via RxJava. If the
+   * invocation of the delegate itself throws an exception, both the original exception and the follow-up exception
+   * will be wrapped into RxJava's {@code CompositeException} and then be emitted.
+   * </p>
+   */
+  @Override
+  public final void onThrowable(Throwable t) {
+    if (delegateTerminated.getAndSet(true)) {
+      return;
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * <p>
-     * The value returned by the wrapped {@code AsyncHandler} won't be returned by this method, but emtited via RxJava.
-     * </p>
-     *
-     * @return always {@code null}
-     */
-    @Override
-    public final Void onCompleted() {
-        if (delegateTerminated.getAndSet(true)) {
-            return null;
-        }
-
-        final T result;
-        try {
-            result = delegate().onCompleted();
-        } catch (final Throwable t) {
-            emitOnError(t);
-            return null;
-        }
-
-        if (!emitter.isDisposed()) {
-            if (result == null) {
-                emitter.onComplete();
-            } else {
-                emitter.onSuccess(result);
-            }
-        }
-
-        return null;
+    Throwable error = t;
+    try {
+      delegate().onThrowable(t);
+    } catch (final Throwable x) {
+      error = new CompositeException(Arrays.asList(t, x));
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * <p>
-     * The exception will first be propagated to the wrapped {@code AsyncHandler}, then emitted via RxJava. If the
-     * invocation of the delegate itself throws an exception, both the original exception and the follow-up exception
-     * will be wrapped into RxJava's {@code CompositeException} and then be emitted.
-     * </p>
-     */
-    @Override
-    public final void onThrowable(Throwable t) {
-        if (delegateTerminated.getAndSet(true)) {
-            return;
+    emitOnError(error);
+  }
+
+  /**
+   * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
+   * the {@link #delegate() delegate} didn't already receive a terminal event,
+   * {@code AsyncHandler#onThrowable(Throwable) onThrowable} will be called with a {@link DisposedException}.
+   *
+   * @return always {@link State#ABORT}
+   */
+  protected final AsyncHandler.State disposed() {
+    if (!delegateTerminated.getAndSet(true)) {
+
+      DisposedException disposed = sharedDisposed;
+      if (disposed == null) {
+        disposed = new DisposedException("Subscription has been disposed.");
+        final StackTraceElement[] stackTrace = disposed.getStackTrace();
+        if (stackTrace.length > 0) {
+          disposed.setStackTrace(new StackTraceElement[]{stackTrace[0]});
         }
 
-        Throwable error = t;
-        try {
-            delegate().onThrowable(t);
-        } catch (final Throwable x) {
-            error = new CompositeException(Arrays.asList(t, x));
-        }
+        sharedDisposed = disposed;
+      }
 
-        emitOnError(error);
+      delegate().onThrowable(disposed);
     }
 
-    /**
-     * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
-     * the {@link #delegate() delegate} didn't already receive a terminal event,
-     * {@code AsyncHandler#onThrowable(Throwable) onThrowable} will be called with a {@link DisposedException}.
-     *
-     * @return always {@link State#ABORT}
-     */
-    protected final AsyncHandler.State disposed() {
-        if (!delegateTerminated.getAndSet(true)) {
-
-            DisposedException disposed = sharedDisposed;
-            if (disposed == null) {
-                disposed = new DisposedException("Subscription has been disposed.");
-                final StackTraceElement[] stackTrace = disposed.getStackTrace();
-                if (stackTrace.length > 0) {
-                    disposed.setStackTrace(new StackTraceElement[] { stackTrace[0] });
-                }
-
-                sharedDisposed = disposed;
-            }
-
-            delegate().onThrowable(disposed);
-        }
+    return State.ABORT;
+  }
 
-        return State.ABORT;
-    }
+  /**
+   * @return the wrapped {@code AsyncHandler} instance to which calls are delegated
+   */
+  protected abstract AsyncHandler<? extends T> delegate();
 
-    /**
-     * @return the wrapped {@code AsyncHandler} instance to which calls are delegated
-     */
-    protected abstract AsyncHandler<? extends T> delegate();
-
-    private void emitOnError(Throwable error) {
-        Exceptions.throwIfFatal(error);
-        if (!emitter.isDisposed()) {
-            emitter.onError(error);
-        } else {
-            LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
-        }
+  private void emitOnError(Throwable error) {
+    Exceptions.throwIfFatal(error);
+    if (!emitter.isDisposed()) {
+      emitter.onError(error);
+    } else {
+      LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
     }
+  }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
index c68a10c38..db41d1b8b 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
@@ -13,39 +13,37 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-
 import io.reactivex.MaybeEmitter;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
 
 /**
  * An extension to {@code AbstractMaybeAsyncHandlerBridge} for {@code ProgressAsyncHandlers}.
  *
- * @param <T>
- *            the result type produced by the wrapped {@code ProgressAsyncHandler} and emitted via RxJava
+ * @param <T> the result type produced by the wrapped {@code ProgressAsyncHandler} and emitted via RxJava
  */
 public abstract class AbstractMaybeProgressAsyncHandlerBridge<T> extends AbstractMaybeAsyncHandlerBridge<T>
         implements ProgressAsyncHandler<Void> {
 
-    protected AbstractMaybeProgressAsyncHandlerBridge(MaybeEmitter<T> emitter) {
-        super(emitter);
-    }
+  protected AbstractMaybeProgressAsyncHandlerBridge(MaybeEmitter<T> emitter) {
+    super(emitter);
+  }
 
-    @Override
-    public final State onHeadersWritten() {
-        return emitter.isDisposed() ? disposed() : delegate().onHeadersWritten();
-    }
+  @Override
+  public final State onHeadersWritten() {
+    return emitter.isDisposed() ? disposed() : delegate().onHeadersWritten();
+  }
 
-    @Override
-    public final State onContentWritten() {
-        return emitter.isDisposed() ? disposed() : delegate().onContentWritten();
-    }
+  @Override
+  public final State onContentWritten() {
+    return emitter.isDisposed() ? disposed() : delegate().onContentWritten();
+  }
 
-    @Override
-    public final State onContentWriteProgress(long amount, long current, long total) {
-        return emitter.isDisposed() ? disposed() : delegate().onContentWriteProgress(amount, current, total);
-    }
+  @Override
+  public final State onContentWriteProgress(long amount, long current, long total) {
+    return emitter.isDisposed() ? disposed() : delegate().onContentWriteProgress(amount, current, total);
+  }
 
-    @Override
-    protected abstract ProgressAsyncHandler<? extends T> delegate();
+  @Override
+  protected abstract ProgressAsyncHandler<? extends T> delegate();
 
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
index b4af729aa..d8b7e3efe 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
@@ -13,23 +13,22 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import static java.util.Objects.requireNonNull;
-
+import io.reactivex.MaybeEmitter;
 import org.asynchttpclient.AsyncHandler;
 
-import io.reactivex.MaybeEmitter;
+import static java.util.Objects.requireNonNull;
 
 public final class MaybeAsyncHandlerBridge<T> extends AbstractMaybeAsyncHandlerBridge<T> {
 
-    private final AsyncHandler<? extends T> delegate;
+  private final AsyncHandler<? extends T> delegate;
 
-    public MaybeAsyncHandlerBridge(MaybeEmitter<T> emitter, AsyncHandler<? extends T> delegate) {
-        super(emitter);
-        this.delegate = requireNonNull(delegate);
-    }
+  public MaybeAsyncHandlerBridge(MaybeEmitter<T> emitter, AsyncHandler<? extends T> delegate) {
+    super(emitter);
+    this.delegate = requireNonNull(delegate);
+  }
 
-    @Override
-    protected AsyncHandler<? extends T> delegate() {
-        return delegate;
-    }
+  @Override
+  protected AsyncHandler<? extends T> delegate() {
+    return delegate;
+  }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
index 4e54a823d..0b0881d5a 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
@@ -13,23 +13,22 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import static java.util.Objects.requireNonNull;
-
+import io.reactivex.MaybeEmitter;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
-import io.reactivex.MaybeEmitter;
+import static java.util.Objects.requireNonNull;
 
 public final class ProgressAsyncMaybeEmitterBridge<T> extends AbstractMaybeProgressAsyncHandlerBridge<T> {
 
-    private final ProgressAsyncHandler<? extends T> delegate;
+  private final ProgressAsyncHandler<? extends T> delegate;
 
-    public ProgressAsyncMaybeEmitterBridge(MaybeEmitter<T> emitter, ProgressAsyncHandler<? extends T> delegate) {
-        super(emitter);
-        this.delegate = requireNonNull(delegate);
-    }
+  public ProgressAsyncMaybeEmitterBridge(MaybeEmitter<T> emitter, ProgressAsyncHandler<? extends T> delegate) {
+    super(emitter);
+    this.delegate = requireNonNull(delegate);
+  }
 
-    @Override
-    protected ProgressAsyncHandler<? extends T> delegate() {
-        return delegate;
-    }
+  @Override
+  protected ProgressAsyncHandler<? extends T> delegate() {
+    return delegate;
+  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
index 77f055373..198f4749f 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
@@ -13,6 +13,19 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
+import io.reactivex.Maybe;
+import io.reactivex.observers.TestObserver;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.mockito.*;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import java.util.function.Supplier;
+
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
@@ -26,143 +39,127 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
-import java.util.function.Supplier;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.InjectMocks;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-import io.reactivex.Maybe;
-import io.reactivex.observers.TestObserver;
 
 public class DefaultRxHttpClientTest {
 
-    @Mock
-    private AsyncHttpClient asyncHttpClient;
-
-    @Mock
-    private Request request;
-
-    @Mock
-    private Supplier<AsyncHandler<Object>> handlerSupplier;
-
-    @Mock
-    private AsyncHandler<Object> handler;
-
-    @Mock
-    private ProgressAsyncHandler<Object> progressHandler;
-
-    @Captor
-    private ArgumentCaptor<AsyncHandler<Object>> handlerCaptor;
-
-    @Mock
-    private ListenableFuture<Object> resposeFuture;
-
-    @InjectMocks
-    private DefaultRxHttpClient underTest;
-
-    @BeforeMethod(groups = "standalone")
-    public void initializeTest() {
-        underTest = null; // we want a fresh instance for each test
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullClient() {
-        new DefaultRxHttpClient(null);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullRequest() {
-        underTest.prepare(null, handlerSupplier);
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void rejectsNullHandlerSupplier() {
-        underTest.prepare(request, null);
-    }
-
-    @Test(groups = "standalone")
-    public void emitsNullPointerExceptionWhenNullHandlerIsSupplied() {
-        // given
-        given(handlerSupplier.get()).willReturn(null);
-        final TestObserver<Object> subscriber = new TestObserver<>();
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe(subscriber);
-
-        // then
-        subscriber.assertTerminated();
-        subscriber.assertNoValues();
-        subscriber.assertError(NullPointerException.class);
-        then(handlerSupplier).should().get();
-        verifyNoMoreInteractions(handlerSupplier);
-    }
-
-    @Test(groups = "standalone")
-    public void usesVanillaAsyncHandler() throws Exception {
-        // given
-        given(handlerSupplier.get()).willReturn(handler);
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
-    }
-
-    @Test(groups = "standalone")
-    public void usesProgressAsyncHandler() throws Exception {
-        given(handlerSupplier.get()).willReturn(progressHandler);
-
-        // when
-        underTest.prepare(request, handlerSupplier).subscribe();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
-    }
-
-    @Test(groups = "standalone")
-    public void callsSupplierForEachSubscription() throws Exception {
-        // given
-        given(handlerSupplier.get()).willReturn(handler);
-        final Maybe<Object> prepared = underTest.prepare(request, handlerSupplier);
-
-        // when
-        prepared.subscribe();
-        prepared.subscribe();
-
-        // then
-        then(handlerSupplier).should(times(2)).get();
-    }
-
-    @Test(groups = "standalone")
-    public void cancelsResponseFutureOnDispose() throws Exception {
-        given(handlerSupplier.get()).willReturn(handler);
-        given(asyncHttpClient.executeRequest(eq(request), any())).willReturn(resposeFuture);
-
-        /* when */ underTest.prepare(request, handlerSupplier).subscribe().dispose();
-
-        // then
-        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-        then(resposeFuture).should().cancel(true);
-        verifyZeroInteractions(handler);
-        assertThat(bridge.onStatusReceived(null), is(AsyncHandler.State.ABORT));
-        verify(handler).onThrowable(isA(DisposedException.class));
-        verifyNoMoreInteractions(handler);
-    }
+  @Mock
+  private AsyncHttpClient asyncHttpClient;
+
+  @Mock
+  private Request request;
+
+  @Mock
+  private Supplier<AsyncHandler<Object>> handlerSupplier;
+
+  @Mock
+  private AsyncHandler<Object> handler;
+
+  @Mock
+  private ProgressAsyncHandler<Object> progressHandler;
+
+  @Captor
+  private ArgumentCaptor<AsyncHandler<Object>> handlerCaptor;
+
+  @Mock
+  private ListenableFuture<Object> resposeFuture;
+
+  @InjectMocks
+  private DefaultRxHttpClient underTest;
+
+  @BeforeMethod
+  public void initializeTest() {
+    underTest = null; // we want a fresh instance for each test
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test(expectedExceptions = NullPointerException.class)
+  public void rejectsNullClient() {
+    new DefaultRxHttpClient(null);
+  }
+
+  @Test(expectedExceptions = NullPointerException.class)
+  public void rejectsNullRequest() {
+    underTest.prepare(null, handlerSupplier);
+  }
+
+  @Test(expectedExceptions = NullPointerException.class)
+  public void rejectsNullHandlerSupplier() {
+    underTest.prepare(request, null);
+  }
+
+  @Test
+  public void emitsNullPointerExceptionWhenNullHandlerIsSupplied() {
+    // given
+    given(handlerSupplier.get()).willReturn(null);
+    final TestObserver<Object> subscriber = new TestObserver<>();
+
+    // when
+    underTest.prepare(request, handlerSupplier).subscribe(subscriber);
+
+    // then
+    subscriber.assertTerminated();
+    subscriber.assertNoValues();
+    subscriber.assertError(NullPointerException.class);
+    then(handlerSupplier).should().get();
+    verifyNoMoreInteractions(handlerSupplier);
+  }
+
+  @Test
+  public void usesVanillaAsyncHandler() {
+    // given
+    given(handlerSupplier.get()).willReturn(handler);
+
+    // when
+    underTest.prepare(request, handlerSupplier).subscribe();
+
+    // then
+    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+    assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
+  }
+
+  @Test
+  public void usesProgressAsyncHandler() {
+    given(handlerSupplier.get()).willReturn(progressHandler);
+
+    // when
+    underTest.prepare(request, handlerSupplier).subscribe();
+
+    // then
+    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+    assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
+  }
+
+  @Test
+  public void callsSupplierForEachSubscription() {
+    // given
+    given(handlerSupplier.get()).willReturn(handler);
+    final Maybe<Object> prepared = underTest.prepare(request, handlerSupplier);
+
+    // when
+    prepared.subscribe();
+    prepared.subscribe();
+
+    // then
+    then(handlerSupplier).should(times(2)).get();
+  }
+
+  @Test
+  public void cancelsResponseFutureOnDispose() throws Exception {
+    given(handlerSupplier.get()).willReturn(handler);
+    given(asyncHttpClient.executeRequest(eq(request), any())).willReturn(resposeFuture);
+
+    /* when */
+    underTest.prepare(request, handlerSupplier).subscribe().dispose();
+
+    // then
+    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+    then(resposeFuture).should().cancel(true);
+    verifyZeroInteractions(handler);
+    assertThat(bridge.onStatusReceived(null), is(AsyncHandler.State.ABORT));
+    verify(handler).onThrowable(isA(DisposedException.class));
+    verifyNoMoreInteractions(handler);
+  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
index 5c67bc1ce..b8a9b3b4e 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
@@ -13,234 +13,255 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.sameInstance;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Callable;
-
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
+import org.mockito.*;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-public class AbstractMaybeAsyncHandlerBridgeTest {
-
-    @Mock
-    MaybeEmitter<Object> emitter;
-
-    @Mock
-    AsyncHandler<Object> delegate;
-
-    @Mock
-    private HttpResponseStatus status;
-
-    @Mock
-    private HttpHeaders headers;
-
-    @Mock
-    private HttpResponseBodyPart bodyPart;
-
-    @Captor
-    private ArgumentCaptor<Throwable> throwable;
-
-    private AbstractMaybeAsyncHandlerBridge<Object> underTest;
-
-    @BeforeMethod
-    public void initializeTest() {
-        MockitoAnnotations.initMocks(this);
-        underTest = new UnderTest();
-    }
-
-    @Test
-    public void forwardsEvents() throws Exception {
-        given(delegate.onCompleted()).willReturn(this);
-
-        /* when */ underTest.onStatusReceived(status);
-        then(delegate).should().onStatusReceived(status);
-
-        /* when */ underTest.onHeadersReceived(headers);
-        then(delegate).should().onHeadersReceived(headers);
-
-        /* when */ underTest.onBodyPartReceived(bodyPart);
-        /* when */ underTest.onBodyPartReceived(bodyPart);
-        then(delegate).should(times(2)).onBodyPartReceived(bodyPart);
-
-        /* when */ underTest.onTrailingHeadersReceived(headers);
-        then(delegate).should().onTrailingHeadersReceived(headers);
-
-        /* when */ underTest.onCompleted();
-        then(delegate).should().onCompleted();
-        then(emitter).should().onSuccess(this);
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
-
-    @Test
-    public void wontCallOnCompleteTwice() throws Exception {
-        InOrder inOrder = Mockito.inOrder(emitter);
-
-        /* when */ underTest.onCompleted();
-        /* then */ inOrder.verify(emitter).onComplete();
-
-        /* when */ underTest.onCompleted();
-        /* then */ inOrder.verify(emitter, never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnErrorTwice() throws Exception {
-        InOrder inOrder = Mockito.inOrder(emitter);
-
-        /* when */ underTest.onThrowable(null);
-        /* then */ inOrder.verify(emitter).onError(null);
-
-        /* when */ underTest.onThrowable(new RuntimeException("unwanted"));
-        /* then */ inOrder.verify(emitter, never()).onError(any());
-    }
-
-    @Test
-    public void wontCallOnErrorAfterOnComplete() throws Exception {
-        /* when */ underTest.onCompleted();
-        then(emitter).should().onComplete();
-
-        /* when */ underTest.onThrowable(null);
-        then(emitter).should(never()).onError(any());
-    }
-
-    @Test
-    public void wontCallOnCompleteAfterOnError() throws Exception {
-        /* when */ underTest.onThrowable(null);
-        then(emitter).should().onError(null);
-
-        /* when */ underTest.onCompleted();
-        then(emitter).should(never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnCompleteAfterDisposal() throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-        /* when */ underTest.onCompleted();
-        /* then */ verify(emitter, never()).onComplete();
-    }
-
-    @Test
-    public void wontCallOnErrorAfterDisposal() throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-        /* when */ underTest.onThrowable(new RuntimeException("ignored"));
-        /* then */ verify(emitter, never()).onError(any());
-    }
-
-    @Test
-    public void handlesExceptionsWhileCompleting() throws Exception {
-        /* given */ final Throwable x = new RuntimeException("mocked error in delegate onCompleted()");
-        given(delegate.onCompleted()).willThrow(x);
-        /* when */ underTest.onCompleted();
-        then(emitter).should().onError(x);
-    }
-
-    @Test
-    public void handlesExceptionsWhileFailing() throws Exception {
-        // given
-        final Throwable initial = new RuntimeException("mocked error for onThrowable()");
-        final Throwable followup = new RuntimeException("mocked error in delegate onThrowable()");
-        willThrow(followup).given(delegate).onThrowable(initial);
-
-        /* when */ underTest.onThrowable(initial);
-
-        // then
-        then(emitter).should().onError(throwable.capture());
-        final Throwable thrown = throwable.getValue();
-        assertThat(thrown, is(instanceOf(CompositeException.class)));
-        assertThat(((CompositeException) thrown).getExceptions(), is(Arrays.asList(initial, followup)));
-    }
-
-    @Test
-    public void cachesDisposedException() throws Exception {
-        // when
-        new UnderTest().disposed();
-        new UnderTest().disposed();
-
-        // then
-        then(delegate).should(times(2)).onThrowable(throwable.capture());
-        final List<Throwable> errors = throwable.getAllValues();
-        final Throwable firstError = errors.get(0), secondError = errors.get(1);
-        assertThat(secondError, is(sameInstance(firstError)));
-        final StackTraceElement[] stackTrace = firstError.getStackTrace();
-        assertThat(stackTrace.length, is(1));
-        assertThat(stackTrace[0].getClassName(), is(AbstractMaybeAsyncHandlerBridge.class.getName()));
-        assertThat(stackTrace[0].getMethodName(), is("disposed"));
-    }
-
-    @DataProvider
-    public Object[][] httpEvents() {
-        return new Object[][] { //
-                { named("onStatusReceived", () -> underTest.onStatusReceived(status)) }, //
-                { named("onHeadersReceived", () -> underTest.onHeadersReceived(headers)) }, //
-                { named("onBodyPartReceived", () -> underTest.onBodyPartReceived(bodyPart)) }, //
-                { named("onTrailingHeadersReceived", () -> underTest.onTrailingHeadersReceived(headers)) }, //
-        };
-    }
-
-    @Test(dataProvider = "httpEvents")
-    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-
-        /* when */ final AsyncHandler.State firstState = httpEvent.call();
-        /* then */ assertThat(firstState, is(State.ABORT));
-        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Callable;
 
-        /* when */ final AsyncHandler.State secondState = httpEvent.call();
-        /* then */ assertThat(secondState, is(State.ABORT));
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.BDDMockito.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
-    private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
-        UnderTest() {
-            super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
-        }
+public class AbstractMaybeAsyncHandlerBridgeTest {
 
-        @Override
-        protected AsyncHandler<? extends Object> delegate() {
-            return delegate;
-        }
+  @Mock
+  MaybeEmitter<Object> emitter;
+
+  @Mock
+  AsyncHandler<Object> delegate;
+
+  @Mock
+  private HttpResponseStatus status;
+
+  @Mock
+  private HttpHeaders headers;
+
+  @Mock
+  private HttpResponseBodyPart bodyPart;
+
+  @Captor
+  private ArgumentCaptor<Throwable> throwable;
+
+  private AbstractMaybeAsyncHandlerBridge<Object> underTest;
+
+  private static <T> Callable<T> named(String name, Callable<T> callable) {
+    return new Callable<T>() {
+      @Override
+      public String toString() {
+        return name;
+      }
+
+      @Override
+      public T call() throws Exception {
+        return callable.call();
+      }
+    };
+  }
+
+  @BeforeMethod
+  public void initializeTest() {
+    MockitoAnnotations.initMocks(this);
+    underTest = new UnderTest();
+  }
+
+  @Test
+  public void forwardsEvents() throws Exception {
+    given(delegate.onCompleted()).willReturn(this);
+
+    /* when */
+    underTest.onStatusReceived(status);
+    then(delegate).should().onStatusReceived(status);
+
+    /* when */
+    underTest.onHeadersReceived(headers);
+    then(delegate).should().onHeadersReceived(headers);
+
+    /* when */
+    underTest.onBodyPartReceived(bodyPart);
+    /* when */
+    underTest.onBodyPartReceived(bodyPart);
+    then(delegate).should(times(2)).onBodyPartReceived(bodyPart);
+
+    /* when */
+    underTest.onTrailingHeadersReceived(headers);
+    then(delegate).should().onTrailingHeadersReceived(headers);
+
+    /* when */
+    underTest.onCompleted();
+    then(delegate).should().onCompleted();
+    then(emitter).should().onSuccess(this);
+    /* then */
+    verifyNoMoreInteractions(delegate);
+  }
+
+  @Test
+  public void wontCallOnCompleteTwice() {
+    InOrder inOrder = Mockito.inOrder(emitter);
+
+    /* when */
+    underTest.onCompleted();
+    /* then */
+    inOrder.verify(emitter).onComplete();
+
+    /* when */
+    underTest.onCompleted();
+    /* then */
+    inOrder.verify(emitter, never()).onComplete();
+  }
+
+  @Test
+  public void wontCallOnErrorTwice() {
+    InOrder inOrder = Mockito.inOrder(emitter);
+
+    /* when */
+    underTest.onThrowable(null);
+    /* then */
+    inOrder.verify(emitter).onError(null);
+
+    /* when */
+    underTest.onThrowable(new RuntimeException("unwanted"));
+    /* then */
+    inOrder.verify(emitter, never()).onError(any());
+  }
+
+  @Test
+  public void wontCallOnErrorAfterOnComplete() {
+    /* when */
+    underTest.onCompleted();
+    then(emitter).should().onComplete();
+
+    /* when */
+    underTest.onThrowable(null);
+    then(emitter).should(never()).onError(any());
+  }
+
+  @Test
+  public void wontCallOnCompleteAfterOnError() {
+    /* when */
+    underTest.onThrowable(null);
+    then(emitter).should().onError(null);
+
+    /* when */
+    underTest.onCompleted();
+    then(emitter).should(never()).onComplete();
+  }
+
+  @Test
+  public void wontCallOnCompleteAfterDisposal() {
+    given(emitter.isDisposed()).willReturn(true);
+    /* when */
+    underTest.onCompleted();
+    /* then */
+    verify(emitter, never()).onComplete();
+  }
+
+  @Test
+  public void wontCallOnErrorAfterDisposal() {
+    given(emitter.isDisposed()).willReturn(true);
+    /* when */
+    underTest.onThrowable(new RuntimeException("ignored"));
+    /* then */
+    verify(emitter, never()).onError(any());
+  }
+
+  @Test
+  public void handlesExceptionsWhileCompleting() throws Exception {
+    /* given */
+    final Throwable x = new RuntimeException("mocked error in delegate onCompleted()");
+    given(delegate.onCompleted()).willThrow(x);
+    /* when */
+    underTest.onCompleted();
+    then(emitter).should().onError(x);
+  }
+
+  @Test
+  public void handlesExceptionsWhileFailing() {
+    // given
+    final Throwable initial = new RuntimeException("mocked error for onThrowable()");
+    final Throwable followup = new RuntimeException("mocked error in delegate onThrowable()");
+    willThrow(followup).given(delegate).onThrowable(initial);
+
+    /* when */
+    underTest.onThrowable(initial);
+
+    // then
+    then(emitter).should().onError(throwable.capture());
+    final Throwable thrown = throwable.getValue();
+    assertThat(thrown, is(instanceOf(CompositeException.class)));
+    assertThat(((CompositeException) thrown).getExceptions(), is(Arrays.asList(initial, followup)));
+  }
+
+  @Test
+  public void cachesDisposedException() {
+    // when
+    new UnderTest().disposed();
+    new UnderTest().disposed();
+
+    // then
+    then(delegate).should(times(2)).onThrowable(throwable.capture());
+    final List<Throwable> errors = throwable.getAllValues();
+    final Throwable firstError = errors.get(0), secondError = errors.get(1);
+    assertThat(secondError, is(sameInstance(firstError)));
+    final StackTraceElement[] stackTrace = firstError.getStackTrace();
+    assertThat(stackTrace.length, is(1));
+    assertThat(stackTrace[0].getClassName(), is(AbstractMaybeAsyncHandlerBridge.class.getName()));
+    assertThat(stackTrace[0].getMethodName(), is("disposed"));
+  }
+
+  @DataProvider
+  public Object[][] httpEvents() {
+    return new Object[][]{
+            {named("onStatusReceived", () -> underTest.onStatusReceived(status))},
+            {named("onHeadersReceived", () -> underTest.onHeadersReceived(headers))},
+            {named("onBodyPartReceived", () -> underTest.onBodyPartReceived(bodyPart))},
+            {named("onTrailingHeadersReceived", () -> underTest.onTrailingHeadersReceived(headers))},
+    };
+  }
+
+  @Test(dataProvider = "httpEvents")
+  public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
+    given(emitter.isDisposed()).willReturn(true);
+
+    /* when */
+    final AsyncHandler.State firstState = httpEvent.call();
+    /* then */
+    assertThat(firstState, is(State.ABORT));
+    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+    /* when */
+    final AsyncHandler.State secondState = httpEvent.call();
+    /* then */
+    assertThat(secondState, is(State.ABORT));
+    /* then */
+    verifyNoMoreInteractions(delegate);
+  }
+
+  private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
+    UnderTest() {
+      super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
     }
 
-    private static <T> Callable<T> named(String name, Callable<T> callable) {
-        return new Callable<T>() {
-            @Override
-            public String toString() {
-                return name;
-            }
-
-            @Override
-            public T call() throws Exception {
-                return callable.call();
-            }
-        };
+    @Override
+    protected AsyncHandler<?> delegate() {
+      return delegate;
     }
+  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
index 5f33906e5..53cc4940c 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
@@ -13,16 +13,7 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-
-import java.util.concurrent.Callable;
-
+import io.reactivex.MaybeEmitter;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
@@ -33,81 +24,96 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import io.reactivex.MaybeEmitter;
-
-public class AbstractMaybeProgressAsyncHandlerBridgeTest {
-
-    @Mock
-    MaybeEmitter<Object> emitter;
-
-    @Mock
-    ProgressAsyncHandler<? extends Object> delegate;
-
-    private AbstractMaybeProgressAsyncHandlerBridge<Object> underTest;
-
-    @BeforeMethod
-    public void initializeTest() {
-        MockitoAnnotations.initMocks(this);
-        underTest = new UnderTest();
-    }
-
-    @Test
-    public void forwardsEvents() throws Exception {
-        /* when */ underTest.onHeadersWritten();
-        then(delegate).should().onHeadersWritten();
-
-        /* when */ underTest.onContentWriteProgress(40, 60, 100);
-        then(delegate).should().onContentWriteProgress(40, 60, 100);
-
-        /* when */ underTest.onContentWritten();
-        then(delegate).should().onContentWritten();
-    }
-
-    @DataProvider
-    public Object[][] httpEvents() {
-        return new Object[][] { //
-                { named("onHeadersWritten", () -> underTest.onHeadersWritten()) }, //
-                { named("onContentWriteProgress", () -> underTest.onContentWriteProgress(40, 60, 100)) }, //
-                { named("onContentWritten", () -> underTest.onContentWritten()) }, //
-        };
-    }
-
-    @Test(dataProvider = "httpEvents")
-    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-        given(emitter.isDisposed()).willReturn(true);
-
-        /* when */ final AsyncHandler.State firstState = httpEvent.call();
-        /* then */ assertThat(firstState, is(State.ABORT));
-        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
-
-        /* when */ final AsyncHandler.State secondState = httpEvent.call();
-        /* then */ assertThat(secondState, is(State.ABORT));
-        /* then */ verifyNoMoreInteractions(delegate);
-    }
+import java.util.concurrent.Callable;
 
-    private final class UnderTest extends AbstractMaybeProgressAsyncHandlerBridge<Object> {
-        UnderTest() {
-            super(AbstractMaybeProgressAsyncHandlerBridgeTest.this.emitter);
-        }
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.then;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
-        @Override
-        protected ProgressAsyncHandler<? extends Object> delegate() {
-            return delegate;
-        }
+public class AbstractMaybeProgressAsyncHandlerBridgeTest {
 
+  @Mock
+  MaybeEmitter<Object> emitter;
+
+  @Mock
+  ProgressAsyncHandler<? extends Object> delegate;
+
+  private AbstractMaybeProgressAsyncHandlerBridge<Object> underTest;
+
+  private static <T> Callable<T> named(String name, Callable<T> callable) {
+    return new Callable<T>() {
+      @Override
+      public String toString() {
+        return name;
+      }
+
+      @Override
+      public T call() throws Exception {
+        return callable.call();
+      }
+    };
+  }
+
+  @BeforeMethod
+  public void initializeTest() {
+    MockitoAnnotations.initMocks(this);
+    underTest = new UnderTest();
+  }
+
+  @Test
+  public void forwardsEvents() {
+    /* when */
+    underTest.onHeadersWritten();
+    then(delegate).should().onHeadersWritten();
+
+    /* when */
+    underTest.onContentWriteProgress(40, 60, 100);
+    then(delegate).should().onContentWriteProgress(40, 60, 100);
+
+    /* when */
+    underTest.onContentWritten();
+    then(delegate).should().onContentWritten();
+  }
+
+  @DataProvider
+  public Object[][] httpEvents() {
+    return new Object[][]{
+            {named("onHeadersWritten", () -> underTest.onHeadersWritten())},
+            {named("onContentWriteProgress", () -> underTest.onContentWriteProgress(40, 60, 100))},
+            {named("onContentWritten", () -> underTest.onContentWritten())},
+    };
+  }
+
+  @Test(dataProvider = "httpEvents")
+  public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
+    given(emitter.isDisposed()).willReturn(true);
+
+    /* when */
+    final AsyncHandler.State firstState = httpEvent.call();
+    /* then */
+    assertThat(firstState, is(State.ABORT));
+    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+    /* when */
+    final AsyncHandler.State secondState = httpEvent.call();
+    /* then */
+    assertThat(secondState, is(State.ABORT));
+    /* then */
+    verifyNoMoreInteractions(delegate);
+  }
+
+  private final class UnderTest extends AbstractMaybeProgressAsyncHandlerBridge<Object> {
+    UnderTest() {
+      super(AbstractMaybeProgressAsyncHandlerBridgeTest.this.emitter);
     }
 
-    private static <T> Callable<T> named(String name, Callable<T> callable) {
-        return new Callable<T>() {
-            @Override
-            public String toString() {
-                return name;
-            }
-
-            @Override
-            public T call() throws Exception {
-                return callable.call();
-            }
-        };
+    @Override
+    protected ProgressAsyncHandler<?> delegate() {
+      return delegate;
     }
+  }
 }
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 5d4306d00..0a782de77 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -1,11 +1,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-SNAPSHOT</version>
-    </parent>
-    <artifactId>async-http-client-extras-simple</artifactId>
-    <name>Asynchronous Http Simple Client</name>
-    <description>The Async Http Simple Client.</description>
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <artifactId>async-http-client-extras-simple</artifactId>
+  <name>Asynchronous Http Simple Client</name>
+  <description>The Async Http Simple Client.</description>
 </project>
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
index 81cfd7745..8ca877d33 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
@@ -12,41 +12,41 @@
  */
 package org.asynchttpclient.extras.simple;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /**
  * An {@link Appendable} customer for {@link ByteBuffer}
  */
 public class AppendableBodyConsumer implements BodyConsumer {
 
-    private final Appendable appendable;
-    private final Charset charset;
-
-    public AppendableBodyConsumer(Appendable appendable, Charset charset) {
-        this.appendable = appendable;
-        this.charset = charset;
-    }
-
-    public AppendableBodyConsumer(Appendable appendable) {
-        this.appendable = appendable;
-        this.charset = UTF_8;
-    }
-
-    @Override
-    public void consume(ByteBuffer byteBuffer) throws IOException {
-        appendable
-                .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), charset));
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (appendable instanceof Closeable) {
-            Closeable.class.cast(appendable).close();
-        }
+  private final Appendable appendable;
+  private final Charset charset;
+
+  public AppendableBodyConsumer(Appendable appendable, Charset charset) {
+    this.appendable = appendable;
+    this.charset = charset;
+  }
+
+  public AppendableBodyConsumer(Appendable appendable) {
+    this.appendable = appendable;
+    this.charset = UTF_8;
+  }
+
+  @Override
+  public void consume(ByteBuffer byteBuffer) throws IOException {
+    appendable
+            .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), charset));
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (appendable instanceof Closeable) {
+      Closeable.class.cast(appendable).close();
     }
+  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
index 3b12e5a0e..f900b4e57 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
@@ -22,11 +22,11 @@
  */
 public interface BodyConsumer extends Closeable {
 
-    /**
-     * Consume the received bytes.
-     *
-     * @param byteBuffer a {@link ByteBuffer} representation of the response's chunk.
-     * @throws IOException IO exception
-     */
-    void consume(ByteBuffer byteBuffer) throws IOException;
+  /**
+   * Consume the received bytes.
+   *
+   * @param byteBuffer a {@link ByteBuffer} representation of the response's chunk.
+   * @throws IOException IO exception
+   */
+  void consume(ByteBuffer byteBuffer) throws IOException;
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
index 427ff8b01..1dfdd38a9 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
@@ -20,25 +20,25 @@
  */
 public class ByteBufferBodyConsumer implements BodyConsumer {
 
-    private final ByteBuffer byteBuffer;
+  private final ByteBuffer byteBuffer;
 
-    public ByteBufferBodyConsumer(ByteBuffer byteBuffer) {
-        this.byteBuffer = byteBuffer;
-    }
+  public ByteBufferBodyConsumer(ByteBuffer byteBuffer) {
+    this.byteBuffer = byteBuffer;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void consume(ByteBuffer byteBuffer) throws IOException {
-        byteBuffer.put(byteBuffer);
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void consume(ByteBuffer byteBuffer) throws IOException {
+    byteBuffer.put(byteBuffer);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() throws IOException {
-        byteBuffer.flip();
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void close() throws IOException {
+    byteBuffer.flip();
+  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
index 5a51e5e99..14fe594a2 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
@@ -21,42 +21,42 @@
  */
 public class FileBodyConsumer implements ResumableBodyConsumer {
 
-    private final RandomAccessFile file;
-
-    public FileBodyConsumer(RandomAccessFile file) {
-        this.file = file;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void consume(ByteBuffer byteBuffer) throws IOException {
-        // TODO: Channel.transferFrom may be a good idea to investigate.
-        file.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() throws IOException {
-        file.close();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long getTransferredBytes() throws IOException {
-        return file.length();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void resume() throws IOException {
-        file.seek(getTransferredBytes());
-    }
+  private final RandomAccessFile file;
+
+  public FileBodyConsumer(RandomAccessFile file) {
+    this.file = file;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void consume(ByteBuffer byteBuffer) throws IOException {
+    // TODO: Channel.transferFrom may be a good idea to investigate.
+    file.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void close() throws IOException {
+    file.close();
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public long getTransferredBytes() throws IOException {
+    return file.length();
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void resume() throws IOException {
+    file.seek(getTransferredBytes());
+  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
index 297a68714..dc871d376 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
@@ -21,25 +21,25 @@
  */
 public class OutputStreamBodyConsumer implements BodyConsumer {
 
-    private final OutputStream outputStream;
+  private final OutputStream outputStream;
 
-    public OutputStreamBodyConsumer(OutputStream outputStream) {
-        this.outputStream = outputStream;
-    }
+  public OutputStreamBodyConsumer(OutputStream outputStream) {
+    this.outputStream = outputStream;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void consume(ByteBuffer byteBuffer) throws IOException {
-        outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void consume(ByteBuffer byteBuffer) throws IOException {
+    outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() throws IOException {
-        outputStream.close();
-    }
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void close() throws IOException {
+    outputStream.close();
+  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
index 459e73641..46048fca9 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
@@ -1,15 +1,15 @@
 /*
-* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
-*
-* This program is licensed to you under the Apache License Version 2.0,
-* and you may not use this file except in compliance with the Apache License Version 2.0.
-* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the Apache License Version 2.0 is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
-*/
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 
 package org.asynchttpclient.extras.simple;
 
@@ -20,18 +20,18 @@
  */
 public interface ResumableBodyConsumer extends BodyConsumer {
 
-    /**
-     * Prepare this consumer to resume a download, for example by seeking to the end of the underlying file.
-     *
-     * @throws IOException IO exception
-     */
-    void resume() throws IOException;
+  /**
+   * Prepare this consumer to resume a download, for example by seeking to the end of the underlying file.
+   *
+   * @throws IOException IO exception
+   */
+  void resume() throws IOException;
 
-    /**
-     * Get the previously transferred bytes, for example the current file size.
-     *
-     *@return the number of tranferred bytes
-     * @throws IOException IO exception
-     */
-    long getTransferredBytes() throws IOException;
+  /**
+   * Get the previously transferred bytes, for example the current file size.
+   *
+   * @return the number of tranferred bytes
+   * @throws IOException IO exception
+   */
+  long getTransferredBytes() throws IOException;
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
index 8b5e0f106..774becc15 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
@@ -3,18 +3,17 @@
 /*
  * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0, 
- * and you may not use this file except in compliance with the Apache License Version 2.0. 
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing, 
- * software distributed under the Apache License Version 2.0 is distributed on an 
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
 import io.netty.handler.codec.http.HttpHeaders;
-
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -28,54 +27,54 @@
  */
 public interface SimpleAHCTransferListener {
 
-    /**
-     * This method is called after the connection status is received.
-     *
-     * @param uri        the uri
-     * @param statusCode the received status code.
-     * @param statusText the received status text.
-     */
-    void onStatus(Uri uri, int statusCode, String statusText);
+  /**
+   * This method is called after the connection status is received.
+   *
+   * @param uri        the uri
+   * @param statusCode the received status code.
+   * @param statusText the received status text.
+   */
+  void onStatus(Uri uri, int statusCode, String statusText);
 
-    /**
-     * This method is called after the response headers are received.
-     *
-     * @param uri     the uri
-     * @param headers the received headers, never {@code null}.
-     */
-    void onHeaders(Uri uri, HttpHeaders headers);
+  /**
+   * This method is called after the response headers are received.
+   *
+   * @param uri     the uri
+   * @param headers the received headers, never {@code null}.
+   */
+  void onHeaders(Uri uri, HttpHeaders headers);
 
-    /**
-     * This method is called when bytes of the responses body are received.
-     *
-     * @param uri     the uri
-     * @param amount  the number of transferred bytes so far.
-     * @param current the number of transferred bytes since the last call to this
-     *                method.
-     * @param total   the total number of bytes to be transferred. This is taken
-     *                from the Content-Length-header and may be unspecified (-1).
-     */
-    void onBytesReceived(Uri uri, long amount, long current, long total);
+  /**
+   * This method is called when bytes of the responses body are received.
+   *
+   * @param uri     the uri
+   * @param amount  the number of transferred bytes so far.
+   * @param current the number of transferred bytes since the last call to this
+   *                method.
+   * @param total   the total number of bytes to be transferred. This is taken
+   *                from the Content-Length-header and may be unspecified (-1).
+   */
+  void onBytesReceived(Uri uri, long amount, long current, long total);
 
-    /**
-     * This method is called when bytes are sent.
-     *
-     * @param uri     the uri
-     * @param amount  the number of transferred bytes so far.
-     * @param current the number of transferred bytes since the last call to this
-     *                method.
-     * @param total   the total number of bytes to be transferred. This is taken
-     *                from the Content-Length-header and may be unspecified (-1).
-     */
-    void onBytesSent(Uri uri, long amount, long current, long total);
+  /**
+   * This method is called when bytes are sent.
+   *
+   * @param uri     the uri
+   * @param amount  the number of transferred bytes so far.
+   * @param current the number of transferred bytes since the last call to this
+   *                method.
+   * @param total   the total number of bytes to be transferred. This is taken
+   *                from the Content-Length-header and may be unspecified (-1).
+   */
+  void onBytesSent(Uri uri, long amount, long current, long total);
 
-    /**
-     * This method is called when the request is completed.
-     *
-     * @param uri        the uri
-     * @param statusCode the received status code.
-     * @param statusText the received status text.
-     */
-    void onCompleted(Uri uri, int statusCode, String statusText);
+  /**
+   * This method is called when the request is completed.
+   *
+   * @param uri        the uri
+   * @param statusCode the received status code.
+   * @param statusText the received status text.
+   */
+  void onCompleted(Uri uri, int statusCode, String statusText);
 }
 
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index 60c1e62eb..8d5bf18af 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -12,12 +12,18 @@
  */
 package org.asynchttpclient.extras.simple;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.MiscUtils.*;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.ssl.SslContext;
+import org.asynchttpclient.*;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -27,27 +33,10 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.DefaultAsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Realm.AuthScheme;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SslEngineFactory;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
-import org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
 
 /**
  * Simple implementation of {@link AsyncHttpClient} and it's related builders ({@link AsyncHttpClientConfig},
@@ -63,788 +52,788 @@
  * .setRequestTimeout(5 * 60 * 1000)
  * .setUrl(getTargetUrl())
  * .setHeader("Content-Type", "text/html").build();
- * 
+ *
  * StringBuilder s = new StringBuilder();
  * Future&lt;Response&gt; future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
  * </pre></blockquote>
  * or
  * <blockquote><pre>
  * public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
- * 
+ *
  * SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
  * .setUrl(getTargetUrl())
  * .build();
- * 
+ *
  * ByteArrayOutputStream o = new ByteArrayOutputStream(10);
  * Future&lt;Response&gt; future = client.post(new FileBodyGenerator(myFile), new OutputStreamBodyConsumer(o));
  * </pre></blockquote>
  */
 public class SimpleAsyncHttpClient implements Closeable {
 
-    private final AsyncHttpClientConfig config;
-    private final RequestBuilder requestBuilder;
-    private AsyncHttpClient asyncHttpClient;
-    private final ThrowableHandler defaultThrowableHandler;
-    private final boolean resumeEnabled;
-    private final ErrorDocumentBehaviour errorDocumentBehaviour;
-    private final SimpleAHCTransferListener listener;
-    private final boolean derived;
+  private final AsyncHttpClientConfig config;
+  private final RequestBuilder requestBuilder;
+  private final ThrowableHandler defaultThrowableHandler;
+  private final boolean resumeEnabled;
+  private final ErrorDocumentBehaviour errorDocumentBehaviour;
+  private final SimpleAHCTransferListener listener;
+  private final boolean derived;
+  private AsyncHttpClient asyncHttpClient;
+
+  private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
+                                ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
+    this.config = config;
+    this.requestBuilder = requestBuilder;
+    this.defaultThrowableHandler = defaultThrowableHandler;
+    this.resumeEnabled = resumeEnabled;
+    this.errorDocumentBehaviour = errorDocumentBehaviour;
+    this.asyncHttpClient = ahc;
+    this.listener = listener;
+
+    this.derived = ahc != null;
+  }
+
+  public Future<Response> post(Part... parts) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+
+    for (Part part : parts) {
+      r.addBodyPart(part);
+    }
+
+    return execute(r, null, null);
+  }
+
+  public Future<Response> post(BodyConsumer consumer, Part... parts) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+
+    for (Part part : parts) {
+      r.addBodyPart(part);
+    }
+
+    return execute(r, consumer, null);
+  }
+
+  public Future<Response> post(BodyGenerator bodyGenerator) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+    r.setBody(bodyGenerator);
+    return execute(r, null, null);
+  }
+
+  public Future<Response> post(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+    r.setBody(bodyGenerator);
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+    r.setBody(bodyGenerator);
+    return execute(r, bodyConsumer, null);
+  }
+
+  public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+          throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+    r.setBody(bodyGenerator);
+    return execute(r, bodyConsumer, throwableHandler);
+  }
+
+  public Future<Response> put(Part... parts) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+
+    for (Part part : parts) {
+      r.addBodyPart(part);
+    }
+
+    return execute(r, null, null);
+  }
+
+  public Future<Response> put(BodyConsumer consumer, Part... parts) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("POST");
+
+    for (Part part : parts) {
+      r.addBodyPart(part);
+    }
+
+    return execute(r, consumer, null);
+  }
+
+  public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("PUT");
+    r.setBody(bodyGenerator);
+    return execute(r, bodyConsumer, null);
+  }
+
+  public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+          throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("PUT");
+    r.setBody(bodyGenerator);
+    return execute(r, bodyConsumer, throwableHandler);
+  }
+
+  public Future<Response> put(BodyGenerator bodyGenerator) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("PUT");
+    r.setBody(bodyGenerator);
+    return execute(r, null, null);
+  }
+
+  public Future<Response> put(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("PUT");
+    r.setBody(bodyGenerator);
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> get() throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    return execute(r, null, null);
+  }
+
+  public Future<Response> get(ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> get(BodyConsumer bodyConsumer) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    return execute(r, bodyConsumer, null);
+  }
+
+  public Future<Response> get(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    return execute(r, bodyConsumer, throwableHandler);
+  }
+
+  public Future<Response> delete() throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("DELETE");
+    return execute(r, null, null);
+  }
+
+  public Future<Response> delete(ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("DELETE");
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> delete(BodyConsumer bodyConsumer) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("DELETE");
+    return execute(r, bodyConsumer, null);
+  }
+
+  public Future<Response> delete(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("DELETE");
+    return execute(r, bodyConsumer, throwableHandler);
+  }
+
+  public Future<Response> head() throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("HEAD");
+    return execute(r, null, null);
+  }
+
+  public Future<Response> head(ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("HEAD");
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> options() throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("OPTIONS");
+    return execute(r, null, null);
+  }
+
+  public Future<Response> options(ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("OPTIONS");
+    return execute(r, null, throwableHandler);
+  }
+
+  public Future<Response> options(BodyConsumer bodyConsumer) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("OPTIONS");
+    return execute(r, bodyConsumer, null);
+  }
+
+  public Future<Response> options(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    RequestBuilder r = rebuildRequest(requestBuilder.build());
+    r.setMethod("OPTIONS");
+    return execute(r, bodyConsumer, throwableHandler);
+  }
+
+  private RequestBuilder rebuildRequest(Request rb) {
+    return new RequestBuilder(rb);
+  }
+
+  private Future<Response> execute(RequestBuilder rb, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+    if (throwableHandler == null) {
+      throwableHandler = defaultThrowableHandler;
+    }
+
+    Request request = rb.build();
+    ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour,
+            request.getUri(), listener);
+
+    if (resumeEnabled && request.getMethod().equals("GET") && bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
+      ResumableBodyConsumer fileBodyConsumer = (ResumableBodyConsumer) bodyConsumer;
+      long length = fileBodyConsumer.getTransferredBytes();
+      fileBodyConsumer.resume();
+      handler = new ResumableBodyConsumerAsyncHandler(length, handler);
+    }
+
+    return getAsyncHttpClient().executeRequest(request, handler);
+  }
+
+  private AsyncHttpClient getAsyncHttpClient() {
+    synchronized (config) {
+      if (asyncHttpClient == null) {
+        asyncHttpClient = asyncHttpClient(config);
+      }
+    }
+    return asyncHttpClient;
+  }
+
+  /**
+   * Close the underlying AsyncHttpClient for this instance.
+   * <br>
+   * If this instance is derived from another instance, this method does
+   * nothing as the client instance is managed by the original
+   * SimpleAsyncHttpClient.
+   *
+   * @see #derive()
+   * @see AsyncHttpClient#close()
+   */
+  public void close() throws IOException {
+    if (!derived && asyncHttpClient != null) {
+      asyncHttpClient.close();
+    }
+  }
+
+  /**
+   * Returns a Builder for a derived SimpleAsyncHttpClient that uses the same
+   * instance of {@link AsyncHttpClient} to execute requests.
+   * <br>
+   * The original SimpleAsyncHttpClient is responsible for managing the
+   * underlying AsyncHttpClient. For the derived instance, {@link #close()} is
+   * a NOOP. If the original SimpleAsyncHttpClient is closed, all derived
+   * instances become invalid.
+   *
+   * @return a Builder for a derived SimpleAsyncHttpClient that uses the same
+   * instance of {@link AsyncHttpClient} to execute requests, never
+   * {@code null}.
+   */
+  public DerivedBuilder derive() {
+    return new Builder(this);
+  }
+
+  public enum ErrorDocumentBehaviour {
+    /**
+     * Write error documents as usual via
+     * {@link BodyConsumer#consume(java.nio.ByteBuffer)}.
+     */
+    WRITE,
 
-    private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
-            ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
-        this.config = config;
-        this.requestBuilder = requestBuilder;
-        this.defaultThrowableHandler = defaultThrowableHandler;
-        this.resumeEnabled = resumeEnabled;
-        this.errorDocumentBehaviour = errorDocumentBehaviour;
-        this.asyncHttpClient = ahc;
-        this.listener = listener;
+    /**
+     * Accumulate error documents in memory but do not consume.
+     */
+    ACCUMULATE,
 
-        this.derived = ahc != null;
-    }
+    /**
+     * Omit error documents. An error document will neither be available in
+     * the response nor written via a {@link BodyConsumer}.
+     */
+    OMIT
+  }
 
-    public Future<Response> post(Part... parts) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
+  /**
+   * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
+   *
+   * @see SimpleAsyncHttpClient#derive()
+   */
+  /**
+   * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
+   *
+   * @see SimpleAsyncHttpClient#derive()
+   */
+  public interface DerivedBuilder {
 
-        for (Part part : parts) {
-            r.addBodyPart(part);
-        }
+    DerivedBuilder setFollowRedirect(boolean followRedirect);
 
-        return execute(r, null, null);
-    }
+    DerivedBuilder setVirtualHost(String virtualHost);
 
-    public Future<Response> post(BodyConsumer consumer, Part... parts) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
+    DerivedBuilder setUrl(String url);
 
-        for (Part part : parts) {
-            r.addBodyPart(part);
-        }
+    DerivedBuilder setFormParams(List<Param> params);
 
-        return execute(r, consumer, null);
-    }
+    DerivedBuilder setFormParams(Map<String, List<String>> params);
+
+    DerivedBuilder setHeaders(Map<? extends CharSequence, Collection<?>> headers);
+
+    DerivedBuilder setHeaders(HttpHeaders headers);
 
-    public Future<Response> post(BodyGenerator bodyGenerator) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
-        r.setBody(bodyGenerator);
-        return execute(r, null, null);
+    DerivedBuilder setHeader(CharSequence name, Object value);
+
+    DerivedBuilder addQueryParam(String name, String value);
+
+    DerivedBuilder addFormParam(String key, String value);
+
+    DerivedBuilder addHeader(CharSequence name, Object value);
+
+    DerivedBuilder addCookie(Cookie cookie);
+
+    DerivedBuilder addBodyPart(Part part);
+
+    DerivedBuilder setResumableDownload(boolean resume);
+
+    SimpleAsyncHttpClient build();
+  }
+
+  public final static class Builder implements DerivedBuilder {
+
+    private final RequestBuilder requestBuilder;
+    private final DefaultAsyncHttpClientConfig.Builder configBuilder = config();
+    private Realm.Builder realmBuilder = null;
+    private Realm.AuthScheme proxyAuthScheme;
+    private String proxyHost = null;
+    private String proxyPrincipal = null;
+    private String proxyPassword = null;
+    private int proxyPort = 80;
+    private ThrowableHandler defaultThrowableHandler = null;
+    private boolean enableResumableDownload = false;
+    private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
+    private AsyncHttpClient ahc = null;
+    private SimpleAHCTransferListener listener = null;
+
+    public Builder() {
+      requestBuilder = new RequestBuilder("GET", false);
     }
 
-    public Future<Response> post(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
-        r.setBody(bodyGenerator);
-        return execute(r, null, throwableHandler);
+    private Builder(SimpleAsyncHttpClient client) {
+      this.requestBuilder = new RequestBuilder(client.requestBuilder.build());
+      this.defaultThrowableHandler = client.defaultThrowableHandler;
+      this.errorDocumentBehaviour = client.errorDocumentBehaviour;
+      this.enableResumableDownload = client.resumeEnabled;
+      this.ahc = client.getAsyncHttpClient();
+      this.listener = client.listener;
     }
 
-    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
-        r.setBody(bodyGenerator);
-        return execute(r, bodyConsumer, null);
+    public Builder addBodyPart(Part part) {
+      requestBuilder.addBodyPart(part);
+      return this;
     }
 
-    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
-            throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
-        r.setBody(bodyGenerator);
-        return execute(r, bodyConsumer, throwableHandler);
+    public Builder addCookie(Cookie cookie) {
+      requestBuilder.addCookie(cookie);
+      return this;
     }
 
-    public Future<Response> put(Part... parts) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
+    public Builder addHeader(CharSequence name, Object value) {
+      requestBuilder.addHeader(name, value);
+      return this;
+    }
 
-        for (Part part : parts) {
-            r.addBodyPart(part);
-        }
+    public Builder addFormParam(String key, String value) {
+      requestBuilder.addFormParam(key, value);
+      return this;
+    }
 
-        return execute(r, null, null);
+    public Builder addQueryParam(String name, String value) {
+      requestBuilder.addQueryParam(name, value);
+      return this;
     }
 
-    public Future<Response> put(BodyConsumer consumer, Part... parts) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("POST");
+    public Builder setHeader(CharSequence name, Object value) {
+      requestBuilder.setHeader(name, value);
+      return this;
+    }
 
-        for (Part part : parts) {
-            r.addBodyPart(part);
-        }
+    public Builder setHeaders(HttpHeaders headers) {
+      requestBuilder.setHeaders(headers);
+      return this;
+    }
 
-        return execute(r, consumer, null);
+    public Builder setHeaders(Map<? extends CharSequence, Collection<?>> headers) {
+      requestBuilder.setHeaders(headers);
+      return this;
     }
 
-    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("PUT");
-        r.setBody(bodyGenerator);
-        return execute(r, bodyConsumer, null);
+    public Builder setFormParams(Map<String, List<String>> parameters) {
+      requestBuilder.setFormParams(parameters);
+      return this;
     }
 
-    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
-            throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("PUT");
-        r.setBody(bodyGenerator);
-        return execute(r, bodyConsumer, throwableHandler);
+    public Builder setFormParams(List<Param> params) {
+      requestBuilder.setFormParams(params);
+      return this;
     }
 
-    public Future<Response> put(BodyGenerator bodyGenerator) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("PUT");
-        r.setBody(bodyGenerator);
-        return execute(r, null, null);
+    public Builder setUrl(String url) {
+      requestBuilder.setUrl(url);
+      return this;
     }
 
-    public Future<Response> put(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("PUT");
-        r.setBody(bodyGenerator);
-        return execute(r, null, throwableHandler);
+    public Builder setVirtualHost(String virtualHost) {
+      requestBuilder.setVirtualHost(virtualHost);
+      return this;
     }
 
-    public Future<Response> get() throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        return execute(r, null, null);
+    public Builder setFollowRedirect(boolean followRedirect) {
+      requestBuilder.setFollowRedirect(followRedirect);
+      return this;
     }
 
-    public Future<Response> get(ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        return execute(r, null, throwableHandler);
+    public Builder setMaxConnections(int defaultMaxConnections) {
+      configBuilder.setMaxConnections(defaultMaxConnections);
+      return this;
     }
 
-    public Future<Response> get(BodyConsumer bodyConsumer) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        return execute(r, bodyConsumer, null);
+    public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
+      configBuilder.setMaxConnectionsPerHost(defaultMaxConnectionsPerHost);
+      return this;
     }
 
-    public Future<Response> get(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        return execute(r, bodyConsumer, throwableHandler);
+    public Builder setConnectTimeout(int connectTimeuot) {
+      configBuilder.setConnectTimeout(connectTimeuot);
+      return this;
     }
 
-    public Future<Response> delete() throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("DELETE");
-        return execute(r, null, null);
+    public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+      configBuilder.setPooledConnectionIdleTimeout(pooledConnectionIdleTimeout);
+      return this;
     }
 
-    public Future<Response> delete(ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("DELETE");
-        return execute(r, null, throwableHandler);
+    public Builder setRequestTimeout(int defaultRequestTimeout) {
+      configBuilder.setRequestTimeout(defaultRequestTimeout);
+      return this;
     }
 
-    public Future<Response> delete(BodyConsumer bodyConsumer) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("DELETE");
-        return execute(r, bodyConsumer, null);
+    public Builder setMaxRedirects(int maxRedirects) {
+      configBuilder.setMaxRedirects(maxRedirects);
+      return this;
     }
 
-    public Future<Response> delete(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("DELETE");
-        return execute(r, bodyConsumer, throwableHandler);
+    public Builder setCompressionEnforced(boolean compressionEnforced) {
+      configBuilder.setCompressionEnforced(compressionEnforced);
+      return this;
     }
 
-    public Future<Response> head() throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("HEAD");
-        return execute(r, null, null);
+    public Builder setUserAgent(String userAgent) {
+      configBuilder.setUserAgent(userAgent);
+      return this;
     }
 
-    public Future<Response> head(ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("HEAD");
-        return execute(r, null, throwableHandler);
+    public Builder setKeepAlive(boolean allowPoolingConnections) {
+      configBuilder.setKeepAlive(allowPoolingConnections);
+      return this;
     }
 
-    public Future<Response> options() throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("OPTIONS");
-        return execute(r, null, null);
+    public Builder setThreadFactory(ThreadFactory threadFactory) {
+      configBuilder.setThreadFactory(threadFactory);
+      return this;
     }
 
-    public Future<Response> options(ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("OPTIONS");
-        return execute(r, null, throwableHandler);
+    public Builder setSslContext(SslContext sslContext) {
+      configBuilder.setSslContext(sslContext);
+      return this;
     }
 
-    public Future<Response> options(BodyConsumer bodyConsumer) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("OPTIONS");
-        return execute(r, bodyConsumer, null);
+    public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+      configBuilder.setSslEngineFactory(sslEngineFactory);
+      return this;
     }
 
-    public Future<Response> options(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-        RequestBuilder r = rebuildRequest(requestBuilder.build());
-        r.setMethod("OPTIONS");
-        return execute(r, bodyConsumer, throwableHandler);
+    public Builder setRealm(Realm realm) {
+      configBuilder.setRealm(realm);
+      return this;
     }
 
-    private RequestBuilder rebuildRequest(Request rb) {
-        return new RequestBuilder(rb);
+    public Builder setProxyAuthScheme(Realm.AuthScheme proxyAuthScheme) {
+      this.proxyAuthScheme = proxyAuthScheme;
+      return this;
     }
 
-    private Future<Response> execute(RequestBuilder rb, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-        if (throwableHandler == null) {
-            throwableHandler = defaultThrowableHandler;
-        }
+    public Builder setProxyHost(String host) {
+      this.proxyHost = host;
+      return this;
+    }
 
-        Request request = rb.build();
-        ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour,
-                request.getUri(), listener);
+    public Builder setProxyPrincipal(String principal) {
+      this.proxyPrincipal = principal;
+      return this;
+    }
 
-        if (resumeEnabled && request.getMethod().equals("GET") && bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
-            ResumableBodyConsumer fileBodyConsumer = (ResumableBodyConsumer) bodyConsumer;
-            long length = fileBodyConsumer.getTransferredBytes();
-            fileBodyConsumer.resume();
-            handler = new ResumableBodyConsumerAsyncHandler(length, handler);
-        }
+    public Builder setProxyPassword(String password) {
+      this.proxyPassword = password;
+      return this;
+    }
 
-        return getAsyncHttpClient().executeRequest(request, handler);
+    public Builder setProxyPort(int port) {
+      this.proxyPort = port;
+      return this;
     }
 
-    private AsyncHttpClient getAsyncHttpClient() {
-        synchronized (config) {
-            if (asyncHttpClient == null) {
-                asyncHttpClient = asyncHttpClient(config);
-            }
-        }
-        return asyncHttpClient;
+    public Builder setDefaultThrowableHandler(ThrowableHandler throwableHandler) {
+      this.defaultThrowableHandler = throwableHandler;
+      return this;
     }
 
     /**
-     * Close the underlying AsyncHttpClient for this instance.
-     * <br>
-     * If this instance is derived from another instance, this method does
-     * nothing as the client instance is managed by the original
-     * SimpleAsyncHttpClient.
+     * This setting controls whether an error document should be written via
+     * the {@link BodyConsumer} after an error status code was received (e.g.
+     * 404). Default is {@link ErrorDocumentBehaviour#WRITE}.
      *
-     * @see #derive()
-     * @see AsyncHttpClient#close()
+     * @param behaviour the behaviour
+     * @return this
      */
-    public void close() throws IOException {
-        if (!derived && asyncHttpClient != null) {
-            asyncHttpClient.close();
-        }
+    public Builder setErrorDocumentBehaviour(ErrorDocumentBehaviour behaviour) {
+      this.errorDocumentBehaviour = behaviour;
+      return this;
     }
 
     /**
-     * Returns a Builder for a derived SimpleAsyncHttpClient that uses the same
-     * instance of {@link AsyncHttpClient} to execute requests.
-     * <br>
-     * The original SimpleAsyncHttpClient is responsible for managing the
-     * underlying AsyncHttpClient. For the derived instance, {@link #close()} is
-     * a NOOP. If the original SimpleAsyncHttpClient is closed, all derived
-     * instances become invalid.
-     *
-     * @return a Builder for a derived SimpleAsyncHttpClient that uses the same
-     *         instance of {@link AsyncHttpClient} to execute requests, never
-     *         {@code null}.
+     * Enable resumable downloads for the SimpleAHC. Resuming downloads will only work for GET requests
+     * with an instance of {@link ResumableBodyConsumer}.
      */
-    public DerivedBuilder derive() {
-        return new Builder(this);
-    }
-
-    public enum ErrorDocumentBehaviour {
-        /**
-         * Write error documents as usual via
-         * {@link BodyConsumer#consume(java.nio.ByteBuffer)}.
-         */
-        WRITE,
-
-        /**
-         * Accumulate error documents in memory but do not consume.
-         */
-        ACCUMULATE,
-
-        /**
-         * Omit error documents. An error document will neither be available in
-         * the response nor written via a {@link BodyConsumer}.
-         */
-        OMIT
+    @Override
+    public Builder setResumableDownload(boolean enableResumableDownload) {
+      this.enableResumableDownload = enableResumableDownload;
+      return this;
     }
 
     /**
-     * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
+     * Set the listener to notify about connection progress.
      *
-     * @see SimpleAsyncHttpClient#derive()
+     * @param listener a listener
+     * @return this
      */
+    public Builder setListener(SimpleAHCTransferListener listener) {
+      this.listener = listener;
+      return this;
+    }
+
     /**
-     * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
+     * Set the number of time a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
      *
-     * @see SimpleAsyncHttpClient#derive()
+     * @param maxRequestRetry the number of time a request will be retried
+     * @return this
      */
-    public interface DerivedBuilder {
-
-        DerivedBuilder setFollowRedirect(boolean followRedirect);
-
-        DerivedBuilder setVirtualHost(String virtualHost);
-
-        DerivedBuilder setUrl(String url);
-
-        DerivedBuilder setFormParams(List<Param> params);
-
-        DerivedBuilder setFormParams(Map<String, List<String>> params);
-
-        DerivedBuilder setHeaders(Map<CharSequence, Collection<?>> headers);
-
-        DerivedBuilder setHeaders(HttpHeaders headers);
-
-        DerivedBuilder setHeader(CharSequence name, Object value);
-
-        DerivedBuilder addQueryParam(String name, String value);
-
-        DerivedBuilder addFormParam(String key, String value);
-
-        DerivedBuilder addHeader(CharSequence name, Object value);
-
-        DerivedBuilder addCookie(Cookie cookie);
-
-        DerivedBuilder addBodyPart(Part part);
-
-        DerivedBuilder setResumableDownload(boolean resume);
-
-        SimpleAsyncHttpClient build();
+    public Builder setMaxRequestRetry(int maxRequestRetry) {
+      configBuilder.setMaxRequestRetry(maxRequestRetry);
+      return this;
     }
 
-    public final static class Builder implements DerivedBuilder {
-
-        private final RequestBuilder requestBuilder;
-        private final DefaultAsyncHttpClientConfig.Builder configBuilder = config();
-        private Realm.Builder realmBuilder = null;
-        private Realm.AuthScheme proxyAuthScheme;
-        private String proxyHost = null;
-        private String proxyPrincipal = null;
-        private String proxyPassword = null;
-        private int proxyPort = 80;
-        private ThrowableHandler defaultThrowableHandler = null;
-        private boolean enableResumableDownload = false;
-        private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
-        private AsyncHttpClient ahc = null;
-        private SimpleAHCTransferListener listener = null;
-
-        public Builder() {
-            requestBuilder = new RequestBuilder("GET", false);
-        }
-
-        private Builder(SimpleAsyncHttpClient client) {
-            this.requestBuilder = new RequestBuilder(client.requestBuilder.build());
-            this.defaultThrowableHandler = client.defaultThrowableHandler;
-            this.errorDocumentBehaviour = client.errorDocumentBehaviour;
-            this.enableResumableDownload = client.resumeEnabled;
-            this.ahc = client.getAsyncHttpClient();
-            this.listener = client.listener;
-        }
-
-        public Builder addBodyPart(Part part) {
-            requestBuilder.addBodyPart(part);
-            return this;
-        }
-
-        public Builder addCookie(Cookie cookie) {
-            requestBuilder.addCookie(cookie);
-            return this;
-        }
-
-        public Builder addHeader(CharSequence name, Object value) {
-            requestBuilder.addHeader(name, value);
-            return this;
-        }
-
-        public Builder addFormParam(String key, String value) {
-            requestBuilder.addFormParam(key, value);
-            return this;
-        }
-
-        public Builder addQueryParam(String name, String value) {
-            requestBuilder.addQueryParam(name, value);
-            return this;
-        }
-
-        public Builder setHeader(CharSequence name, Object value) {
-            requestBuilder.setHeader(name, value);
-            return this;
-        }
-
-        public Builder setHeaders(HttpHeaders headers) {
-            requestBuilder.setHeaders(headers);
-            return this;
-        }
-
-        public Builder setHeaders(Map<CharSequence, Collection<?>> headers) {
-            requestBuilder.setHeaders(headers);
-            return this;
-        }
-
-        public Builder setFormParams(Map<String, List<String>> parameters) {
-            requestBuilder.setFormParams(parameters);
-            return this;
-        }
-
-        public Builder setFormParams(List<Param> params) {
-            requestBuilder.setFormParams(params);
-            return this;
-        }
-
-        public Builder setUrl(String url) {
-            requestBuilder.setUrl(url);
-            return this;
-        }
-
-        public Builder setVirtualHost(String virtualHost) {
-            requestBuilder.setVirtualHost(virtualHost);
-            return this;
-        }
-
-        public Builder setFollowRedirect(boolean followRedirect) {
-            requestBuilder.setFollowRedirect(followRedirect);
-            return this;
-        }
-
-        public Builder setMaxConnections(int defaultMaxConnections) {
-            configBuilder.setMaxConnections(defaultMaxConnections);
-            return this;
-        }
-
-        public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
-            configBuilder.setMaxConnectionsPerHost(defaultMaxConnectionsPerHost);
-            return this;
-        }
-
-        public Builder setConnectTimeout(int connectTimeuot) {
-            configBuilder.setConnectTimeout(connectTimeuot);
-            return this;
-        }
-
-        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
-            configBuilder.setPooledConnectionIdleTimeout(pooledConnectionIdleTimeout);
-            return this;
-        }
-
-        public Builder setRequestTimeout(int defaultRequestTimeout) {
-            configBuilder.setRequestTimeout(defaultRequestTimeout);
-            return this;
-        }
-
-        public Builder setMaxRedirects(int maxRedirects) {
-            configBuilder.setMaxRedirects(maxRedirects);
-            return this;
-        }
-
-        public Builder setCompressionEnforced(boolean compressionEnforced) {
-            configBuilder.setCompressionEnforced(compressionEnforced);
-            return this;
-        }
-
-        public Builder setUserAgent(String userAgent) {
-            configBuilder.setUserAgent(userAgent);
-            return this;
-        }
-
-        public Builder setKeepAlive(boolean allowPoolingConnections) {
-            configBuilder.setKeepAlive(allowPoolingConnections);
-            return this;
-        }
-
-        public Builder setThreadFactory(ThreadFactory threadFactory) {
-            configBuilder.setThreadFactory(threadFactory);
-            return this;
-        }
-
-        public Builder setSslContext(SslContext sslContext) {
-            configBuilder.setSslContext(sslContext);
-            return this;
-        }
-        
-        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
-            configBuilder.setSslEngineFactory(sslEngineFactory);
-            return this;
-        }
-
-        public Builder setRealm(Realm realm) {
-            configBuilder.setRealm(realm);
-            return this;
-        }
-
-        public Builder setProxyAuthScheme(Realm.AuthScheme proxyAuthScheme) {
-            this.proxyAuthScheme = proxyAuthScheme;
-            return this;
-        }
-
-        public Builder setProxyHost(String host) {
-            this.proxyHost = host;
-            return this;
-        }
-
-        public Builder setProxyPrincipal(String principal) {
-            this.proxyPrincipal = principal;
-            return this;
-        }
-
-        public Builder setProxyPassword(String password) {
-            this.proxyPassword = password;
-            return this;
-        }
-
-        public Builder setProxyPort(int port) {
-            this.proxyPort = port;
-            return this;
-        }
-
-        public Builder setDefaultThrowableHandler(ThrowableHandler throwableHandler) {
-            this.defaultThrowableHandler = throwableHandler;
-            return this;
-        }
+    public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+      configBuilder.setUseInsecureTrustManager(acceptAnyCertificate);
+      return this;
+    }
 
-        /**
-         * This setting controls whether an error document should be written via
-         * the {@link BodyConsumer} after an error status code was received (e.g.
-         * 404). Default is {@link ErrorDocumentBehaviour#WRITE}.
-         * 
-         * @param behaviour the behaviour
-         * @return this
-         */
-        public Builder setErrorDocumentBehaviour(ErrorDocumentBehaviour behaviour) {
-            this.errorDocumentBehaviour = behaviour;
-            return this;
-        }
+    public SimpleAsyncHttpClient build() {
 
-        /**
-         * Enable resumable downloads for the SimpleAHC. Resuming downloads will only work for GET requests
-         * with an instance of {@link ResumableBodyConsumer}.
-         */
-        @Override
-        public Builder setResumableDownload(boolean enableResumableDownload) {
-            this.enableResumableDownload = enableResumableDownload;
-            return this;
-        }
+      if (realmBuilder != null) {
+        configBuilder.setRealm(realmBuilder.build());
+      }
 
-        /**
-         * Set the listener to notify about connection progress.
-         * 
-         * @param listener a listener
-         * @return this
-         */
-        public Builder setListener(SimpleAHCTransferListener listener) {
-            this.listener = listener;
-            return this;
+      if (proxyHost != null) {
+        Realm realm = null;
+        if (proxyPrincipal != null) {
+          AuthScheme proxyAuthScheme = withDefault(this.proxyAuthScheme, AuthScheme.BASIC);
+          realm = realm(proxyAuthScheme, proxyPrincipal, proxyPassword).build();
         }
 
-        /**
-         * Set the number of time a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
-         *
-         * @param maxRequestRetry the number of time a request will be retried
-         * @return this
-         */
-        public Builder setMaxRequestRetry(int maxRequestRetry) {
-            configBuilder.setMaxRequestRetry(maxRequestRetry);
-            return this;
-        }
+        configBuilder.setProxyServer(proxyServer(proxyHost, proxyPort).setRealm(realm).build());
+      }
 
-        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
-            configBuilder.setUseInsecureTrustManager(acceptAnyCertificate);
-            return this;
-        }
+      configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
 
-        public SimpleAsyncHttpClient build() {
+      SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
+              errorDocumentBehaviour, enableResumableDownload, ahc, listener);
 
-            if (realmBuilder != null) {
-                configBuilder.setRealm(realmBuilder.build());
-            }
+      return sc;
+    }
+  }
 
-            if (proxyHost != null) {
-                Realm realm = null;
-                if (proxyPrincipal != null) {
-                    AuthScheme proxyAuthScheme = withDefault(this.proxyAuthScheme, AuthScheme.BASIC);
-                    realm = realm(proxyAuthScheme, proxyPrincipal, proxyPassword).build();
-                }
+  private final static class ResumableBodyConsumerAsyncHandler extends ResumableAsyncHandler implements ProgressAsyncHandler<Response> {
 
-                configBuilder.setProxyServer(proxyServer(proxyHost, proxyPort).setRealm(realm).build());
-            }
+    private final ProgressAsyncHandler<Response> delegate;
 
-            configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
+    public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHandler<Response> delegate) {
+      super(byteTransferred, delegate);
+      this.delegate = delegate;
+    }
 
-            SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
-                    errorDocumentBehaviour, enableResumableDownload, ahc, listener);
+    public AsyncHandler.State onHeadersWritten() {
+      return delegate.onHeadersWritten();
+    }
 
-            return sc;
-        }
+    public AsyncHandler.State onContentWritten() {
+      return delegate.onContentWritten();
     }
 
-    private final static class ResumableBodyConsumerAsyncHandler extends ResumableAsyncHandler implements ProgressAsyncHandler<Response> {
+    public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
+      return delegate.onContentWriteProgress(amount, current, total);
+    }
+  }
 
-        private final ProgressAsyncHandler<Response> delegate;
+  private final static class BodyConsumerAsyncHandler extends AsyncCompletionHandlerBase {
 
-        public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHandler<Response> delegate) {
-            super(byteTransferred, delegate);
-            this.delegate = delegate;
-        }
+    private final BodyConsumer bodyConsumer;
+    private final ThrowableHandler exceptionHandler;
+    private final ErrorDocumentBehaviour errorDocumentBehaviour;
+    private final Uri uri;
+    private final SimpleAHCTransferListener listener;
 
-        public AsyncHandler.State onHeadersWritten() {
-            return delegate.onHeadersWritten();
-        }
+    private boolean accumulateBody = false;
+    private boolean omitBody = false;
+    private int amount = 0;
+    private long total = -1;
 
-        public AsyncHandler.State onContentWritten() {
-            return delegate.onContentWritten();
-        }
+    public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler,
+                                    ErrorDocumentBehaviour errorDocumentBehaviour, Uri uri, SimpleAHCTransferListener listener) {
+      this.bodyConsumer = bodyConsumer;
+      this.exceptionHandler = exceptionHandler;
+      this.errorDocumentBehaviour = errorDocumentBehaviour;
+      this.uri = uri;
+      this.listener = listener;
+    }
 
-        public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
-            return delegate.onContentWriteProgress(amount, current, total);
+    @Override
+    public void onThrowable(Throwable t) {
+      try {
+        if (exceptionHandler != null) {
+          exceptionHandler.onThrowable(t);
+        } else {
+          super.onThrowable(t);
         }
+      } finally {
+        closeConsumer();
+      }
     }
 
-    private final static class BodyConsumerAsyncHandler extends AsyncCompletionHandlerBase {
-
-        private final BodyConsumer bodyConsumer;
-        private final ThrowableHandler exceptionHandler;
-        private final ErrorDocumentBehaviour errorDocumentBehaviour;
-        private final Uri uri;
-        private final SimpleAHCTransferListener listener;
-
-        private boolean accumulateBody = false;
-        private boolean omitBody = false;
-        private int amount = 0;
-        private long total = -1;
-
-        public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler,
-                ErrorDocumentBehaviour errorDocumentBehaviour, Uri uri, SimpleAHCTransferListener listener) {
-            this.bodyConsumer = bodyConsumer;
-            this.exceptionHandler = exceptionHandler;
-            this.errorDocumentBehaviour = errorDocumentBehaviour;
-            this.uri = uri;
-            this.listener = listener;
-        }
+    /**
+     * {@inheritDoc}
+     */
+    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+      fireReceived(content);
+      if (omitBody) {
+        return State.CONTINUE;
+      }
 
-        @Override
-        public void onThrowable(Throwable t) {
-            try {
-                if (exceptionHandler != null) {
-                    exceptionHandler.onThrowable(t);
-                } else {
-                    super.onThrowable(t);
-                }
-            } finally {
-                closeConsumer();
-            }
-        }
+      if (!accumulateBody && bodyConsumer != null) {
+        bodyConsumer.consume(content.getBodyByteBuffer());
+      } else {
+        return super.onBodyPartReceived(content);
+      }
+      return State.CONTINUE;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-            fireReceived(content);
-            if (omitBody) {
-                return State.CONTINUE;
-            }
-
-            if (!accumulateBody && bodyConsumer != null) {
-                bodyConsumer.consume(content.getBodyByteBuffer());
-            } else {
-                return super.onBodyPartReceived(content);
-            }
-            return State.CONTINUE;
-        }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+      fireCompleted(response);
+      closeConsumer();
+      return super.onCompleted(response);
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Response onCompleted(Response response) throws Exception {
-            fireCompleted(response);
-            closeConsumer();
-            return super.onCompleted(response);
-        }
+    private void closeConsumer() {
+      if (bodyConsumer != null)
+        closeSilently(bodyConsumer);
+    }
 
-        private void closeConsumer() {
-            if (bodyConsumer != null)
-                closeSilently(bodyConsumer);
-        }
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+      fireStatus(status);
 
-        @Override
-        public State onStatusReceived(HttpResponseStatus status) throws Exception {
-            fireStatus(status);
-
-            if (isErrorStatus(status)) {
-                switch (errorDocumentBehaviour) {
-                case ACCUMULATE:
-                    accumulateBody = true;
-                    break;
-                case OMIT:
-                    omitBody = true;
-                    break;
-                default:
-                    break;
-                }
-            }
-            return super.onStatusReceived(status);
+      if (isErrorStatus(status)) {
+        switch (errorDocumentBehaviour) {
+          case ACCUMULATE:
+            accumulateBody = true;
+            break;
+          case OMIT:
+            omitBody = true;
+            break;
+          default:
+            break;
         }
+      }
+      return super.onStatusReceived(status);
+    }
 
-        private boolean isErrorStatus(HttpResponseStatus status) {
-            return status.getStatusCode() >= 400;
-        }
+    private boolean isErrorStatus(HttpResponseStatus status) {
+      return status.getStatusCode() >= 400;
+    }
 
-        @Override
-        public State onHeadersReceived(HttpHeaders headers) throws Exception {
-            calculateTotal(headers);
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+      calculateTotal(headers);
 
-            fireHeaders(headers);
+      fireHeaders(headers);
 
-            return super.onHeadersReceived(headers);
-        }
+      return super.onHeadersReceived(headers);
+    }
 
-        private void calculateTotal(HttpHeaders headers) {
-            String length = headers.get(CONTENT_LENGTH);
+    private void calculateTotal(HttpHeaders headers) {
+      String length = headers.get(CONTENT_LENGTH);
 
-            try {
-                total = Integer.valueOf(length);
-            } catch (Exception e) {
-                total = -1;
-            }
-        }
+      try {
+        total = Integer.valueOf(length);
+      } catch (Exception e) {
+        total = -1;
+      }
+    }
 
-        @Override
-        public State onContentWriteProgress(long amount, long current, long total) {
-            fireSent(uri, amount, current, total);
-            return super.onContentWriteProgress(amount, current, total);
-        }
+    @Override
+    public State onContentWriteProgress(long amount, long current, long total) {
+      fireSent(uri, amount, current, total);
+      return super.onContentWriteProgress(amount, current, total);
+    }
 
-        private void fireStatus(HttpResponseStatus status) {
-            if (listener != null) {
-                listener.onStatus(uri, status.getStatusCode(), status.getStatusText());
-            }
-        }
+    private void fireStatus(HttpResponseStatus status) {
+      if (listener != null) {
+        listener.onStatus(uri, status.getStatusCode(), status.getStatusText());
+      }
+    }
 
-        private void fireReceived(HttpResponseBodyPart content) {
-            int remaining = content.getBodyByteBuffer().remaining();
+    private void fireReceived(HttpResponseBodyPart content) {
+      int remaining = content.getBodyByteBuffer().remaining();
 
-            amount += remaining;
+      amount += remaining;
 
-            if (listener != null) {
-                listener.onBytesReceived(uri, amount, remaining, total);
-            }
-        }
+      if (listener != null) {
+        listener.onBytesReceived(uri, amount, remaining, total);
+      }
+    }
 
-        private void fireHeaders(HttpHeaders headers) {
-            if (listener != null) {
-                listener.onHeaders(uri, headers);
-            }
-        }
+    private void fireHeaders(HttpHeaders headers) {
+      if (listener != null) {
+        listener.onHeaders(uri, headers);
+      }
+    }
 
-        private void fireSent(Uri uri, long amount, long current, long total) {
-            if (listener != null) {
-                listener.onBytesSent(uri, amount, current, total);
-            }
-        }
+    private void fireSent(Uri uri, long amount, long current, long total) {
+      if (listener != null) {
+        listener.onBytesSent(uri, amount, current, total);
+      }
+    }
 
-        private void fireCompleted(Response response) {
-            if (listener != null) {
-                listener.onCompleted(uri, response.getStatusCode(), response.getStatusText());
-            }
-        }
+    private void fireCompleted(Response response) {
+      if (listener != null) {
+        listener.onCompleted(uri, response.getStatusCode(), response.getStatusText());
+      }
     }
+  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
index 50d7671c0..c0956e93c 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
@@ -1,15 +1,15 @@
 /*
-* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
-*
-* This program is licensed to you under the Apache License Version 2.0,
-* and you may not use this file except in compliance with the Apache License Version 2.0.
-* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the Apache License Version 2.0 is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
-*/
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 
 package org.asynchttpclient.extras.simple;
 
@@ -19,5 +19,5 @@
  */
 public interface ThrowableHandler {
 
-    void onThrowable(Throwable t);
+  void onThrowable(Throwable t);
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
index 80cd0e97c..4567b38c3 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
@@ -1,12 +1,5 @@
 package org.asynchttpclient.extras.simple;
 
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.test.EchoHandler;
@@ -18,51 +11,59 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
+import static org.testng.Assert.assertEquals;
+
 public class HttpsProxyTest extends AbstractBasicTest {
 
-    private Server server2;
+  private Server server2;
 
-    public AbstractHandler configureHandler() throws Exception {
-        return new ConnectHandler();
-    }
+  public AbstractHandler configureHandler() {
+    return new ConnectHandler();
+  }
 
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        server = new Server();
-        ServerConnector connector1 = addHttpConnector(server);
-        server.setHandler(configureHandler());
-        server.start();
-        port1 = connector1.getLocalPort();
+  @BeforeClass(alwaysRun = true)
+  public void setUpGlobal() throws Exception {
+    server = new Server();
+    ServerConnector connector1 = addHttpConnector(server);
+    server.setHandler(configureHandler());
+    server.start();
+    port1 = connector1.getLocalPort();
 
-        server2 = new Server();
-        ServerConnector connector2 = addHttpsConnector(server2);
-        server2.setHandler(new EchoHandler());
-        server2.start();
-        port2 = connector2.getLocalPort();
+    server2 = new Server();
+    ServerConnector connector2 = addHttpsConnector(server2);
+    server2.setHandler(new EchoHandler());
+    server2.start();
+    port2 = connector2.getLocalPort();
 
-        logger.info("Local HTTP server started successfully");
-    }
+    logger.info("Local HTTP server started successfully");
+  }
 
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        server.stop();
-        server2.stop();
-    }
+  @AfterClass(alwaysRun = true)
+  public void tearDownGlobal() throws Exception {
+    server.stop();
+    server2.stop();
+  }
 
-    @Test(groups = "online")
-    public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+  @Test
+  public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException {
 
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setProxyHost("localhost")//
-                .setProxyPort(port1)//
-                .setFollowRedirect(true)//
-                .setUrl(getTargetUrl2())//
-                .setAcceptAnyCertificate(true)//
-                .setHeader("Content-Type", "text/html")//
-                .build()) {
-            Response r = client.get().get();
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setProxyHost("localhost")
+            .setProxyPort(port1)
+            .setFollowRedirect(true)
+            .setUrl(getTargetUrl2())
+            .setAcceptAnyCertificate(true)
+            .setHeader("Content-Type", "text/html")
+            .build()) {
+      Response r = client.get().get();
 
-            assertEquals(r.getStatusCode(), 200);
-        }
+      assertEquals(r.getStatusCode(), 200);
     }
+  }
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
index f2ca7f76c..a9c628389 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
@@ -12,69 +12,68 @@
  */
 package org.asynchttpclient.extras.simple;
 
-import static org.testng.Assert.*;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.concurrent.Future;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.extras.simple.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.concurrent.Future;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
 /**
  * @author Benjamin Hanzelmann
- * 
  */
 public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
-    
-    @Test(groups = "standalone")
-    public void testAccumulateErrorBody() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl() + "/nonexistent")//
-                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
-            System.out.println("waiting for response");
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 404);
-            assertEquals(o.toString(), "");
-            assertTrue(response.getResponseBody().startsWith("<html>"));
-        }
+  @Test
+  public void testAccumulateErrorBody() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setUrl(getTargetUrl() + "/nonexistent")
+            .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+      Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+
+      System.out.println("waiting for response");
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 404);
+      assertEquals(o.toString(), "");
+      assertTrue(response.getResponseBody().startsWith("<html>"));
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testOmitErrorBody() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl() + "/nonexistent")//
-                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+  @Test
+  public void testOmitErrorBody() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setUrl(getTargetUrl() + "/nonexistent")
+            .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+      Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
-            System.out.println("waiting for response");
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 404);
-            assertEquals(o.toString(), "");
-            assertEquals(response.getResponseBody(), "");
-        }
+      System.out.println("waiting for response");
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 404);
+      assertEquals(o.toString(), "");
+      assertEquals(response.getResponseBody(), "");
     }
+  }
 
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new AbstractHandler() {
+  @Override
+  public AbstractHandler configureHandler() {
+    return new AbstractHandler() {
 
-            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-                response.sendError(404);
-                baseRequest.setHandled(true);
-            }
-        };
-    }
+      public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
+        response.sendError(404);
+        baseRequest.setHandled(true);
+      }
+    };
+  }
 
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
index b02b8c2f1..42ca1d7a7 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
@@ -12,9 +12,14 @@
  */
 package org.asynchttpclient.extras.simple;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -25,297 +30,292 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.request.body.generator.FileBodyGenerator;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.multipart.ByteArrayPart;
-import org.asynchttpclient.uri.Uri;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.*;
 
 public class SimpleAsyncHttpClientTest extends AbstractBasicTest {
 
-    private final static String MY_MESSAGE = "my message";
+  private final static String MY_MESSAGE = "my message";
 
-    @Test(groups = "standalone")
-    public void inputStreamBodyConsumerTest() throws Exception {
+  @Test
+  public void inputStreamBodyConsumerTest() throws Exception {
 
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setPooledConnectionIdleTimeout(100)
+            .setMaxConnections(50)
+            .setRequestTimeout(5 * 60 * 1000)
+            .setUrl(getTargetUrl())
+            .setHeader("Content-Type", "text/html").build()) {
+      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBody(), MY_MESSAGE);
-        }
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(response.getResponseBody(), MY_MESSAGE);
     }
-
-    @Test(groups = "standalone")
-    public void stringBuilderBodyConsumerTest() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            StringBuilder s = new StringBuilder();
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
-
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(s.toString(), MY_MESSAGE);
-        }
+  }
+
+  @Test
+  public void stringBuilderBodyConsumerTest() throws Exception {
+
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setPooledConnectionIdleTimeout(100)
+            .setMaxConnections(50)
+            .setRequestTimeout(5 * 60 * 1000)
+            .setUrl(getTargetUrl())
+            .setHeader("Content-Type", "text/html").build()) {
+      StringBuilder s = new StringBuilder();
+      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(s.toString(), MY_MESSAGE);
     }
+  }
+
+  @Test
+  public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
+
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setPooledConnectionIdleTimeout(100).setMaxConnections(50)
+            .setRequestTimeout(5 * 60 * 1000)
+            .setUrl(getTargetUrl())
+            .setHeader("Content-Type", "text/html").build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(o.toString(), MY_MESSAGE);
+    }
+  }
 
-    @Test(groups = "standalone")
-    public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
+  @Test
+  public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100).setMaxConnections(50)//
-                .setRequestTimeout(5 * 60 * 1000)//
-                .setUrl(getTargetUrl())//
-                .setHeader("Content-Type", "text/html").build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        }
+      Response response = future.get();
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(o.toString(), MY_MESSAGE);
     }
+  }
+
+  /**
+   * See https://issues.sonatype.org/browse/AHC-5
+   */
+  @Test
+  public void testPutZeroBytesFileTest() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setPooledConnectionIdleTimeout(100)
+            .setMaxConnections(50)
+            .setRequestTimeout(5 * 1000)
+            .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")
+            .setHeader("Content-Type", "text/plain").build()) {
+      File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
+      tmpfile.deleteOnExit();
+
+      Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
+
+      System.out.println("waiting for response");
+      Response response = future.get();
+
+      tmpfile.delete();
+
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  @Test
+  public void testDerive() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
+      try (SimpleAsyncHttpClient derived = client.derive().build()) {
+        assertNotSame(derived, client);
+      }
+    }
+  }
 
-    @Test(groups = "standalone")
-    public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
+  @Test
+  public void testDeriveOverrideURL() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+      InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+      OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        }
-    }
+      try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
+        Future<Response> future = derived.post(generator, consumer);
 
-    /**
-     * See https://issues.sonatype.org/browse/AHC-5
-     */
-    @Test(groups = "standalone", enabled = true)
-    public void testPutZeroBytesFileTest() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setPooledConnectionIdleTimeout(100)//
-                .setMaxConnections(50)//
-                .setRequestTimeout(5 * 1000)//
-                .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")//
-                .setHeader("Content-Type", "text/plain").build()) {
-            File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
-            tmpfile.deleteOnExit();
+        Response response = future.get();
+        assertEquals(response.getStatusCode(), 200);
+        assertEquals(o.toString(), MY_MESSAGE);
+      }
+    }
+  }
 
-            Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
+  @Test
+  public void testSimpleTransferListener() throws Exception {
 
-            System.out.println("waiting for response");
-            Response response = future.get();
+    final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
 
-            tmpfile.delete();
+    SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
 
-            assertEquals(response.getStatusCode(), 200);
+      public void onStatus(Uri uri, int statusCode, String statusText) {
+        try {
+          assertEquals(statusCode, 200);
+          assertEquals(uri.toUrl(), getTargetUrl());
+        } catch (Error e) {
+          errors.add(e);
+          throw e;
         }
-    }
-
-    @Test(groups = "standalone")
-    public void testDerive() throws Exception {
-        try(SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-            try(SimpleAsyncHttpClient derived = client.derive().build()) {
-                assertNotSame(derived, client);
-            }
+      }
+
+      public void onHeaders(Uri uri, HttpHeaders headers) {
+        try {
+          assertEquals(uri.toUrl(), getTargetUrl());
+          assertNotNull(headers);
+          assertTrue(!headers.isEmpty());
+          assertEquals(headers.get("X-Custom"), "custom");
+        } catch (Error e) {
+          errors.add(e);
+          throw e;
         }
-    }
+      }
+
+      public void onCompleted(Uri uri, int statusCode, String statusText) {
+        try {
+          assertEquals(statusCode, 200);
+          assertEquals(uri.toUrl(), getTargetUrl());
+        } catch (Error e) {
+          errors.add(e);
+          throw e;
+        }
+      }
+
+      public void onBytesSent(Uri uri, long amount, long current, long total) {
+        try {
+          assertEquals(uri.toUrl(), getTargetUrl());
+          // FIXME Netty bug, see
+          // https://github.com/netty/netty/issues/1855
+          // assertEquals(total, MY_MESSAGE.getBytes().length);
+        } catch (Error e) {
+          errors.add(e);
+          throw e;
+        }
+      }
+
+      public void onBytesReceived(Uri uri, long amount, long current, long total) {
+        try {
+          assertEquals(uri.toUrl(), getTargetUrl());
+          assertEquals(total, -1);
+        } catch (Error e) {
+          errors.add(e);
+          throw e;
+        }
+      }
+    };
 
-    @Test(groups = "standalone")
-    public void testDeriveOverrideURL() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
+            .setUrl(getTargetUrl())
+            .setHeader("Custom", "custom")
+            .setListener(listener).build()) {
+      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+      InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+      OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-            try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
-                Future<Response> future = derived.post(generator, consumer);
+      Future<Response> future = client.post(generator, consumer);
 
-                Response response = future.get();
-                assertEquals(response.getStatusCode(), 200);
-                assertEquals(o.toString(), MY_MESSAGE);
-            }
-        }
-    }
+      Response response = future.get();
 
-    @Test(groups = "standalone")
-    public void testSimpleTransferListener() throws Exception {
-
-        final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
-
-        SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
-
-            public void onStatus(Uri uri, int statusCode, String statusText) {
-                try {
-                    assertEquals(statusCode, 200);
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onHeaders(Uri uri, HttpHeaders headers) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    assertNotNull(headers);
-                    assertTrue(!headers.isEmpty());
-                    assertEquals(headers.get("X-Custom"), "custom");
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onCompleted(Uri uri, int statusCode, String statusText) {
-                try {
-                    assertEquals(statusCode, 200);
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onBytesSent(Uri uri, long amount, long current, long total) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    // FIXME Netty bug, see
-                    // https://github.com/netty/netty/issues/1855
-                    // assertEquals(total, MY_MESSAGE.getBytes().length);
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-
-            public void onBytesReceived(Uri uri, long amount, long current, long total) {
-                try {
-                    assertEquals(uri.toUrl(), getTargetUrl());
-                    assertEquals(total, -1);
-                } catch (Error e) {
-                    errors.add(e);
-                    throw e;
-                }
-            }
-        };
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setUrl(getTargetUrl())//
-                .setHeader("Custom", "custom")//
-                .setListener(listener).build()) {
-            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-
-            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
-
-            Future<Response> future = client.post(generator, consumer);
-
-            Response response = future.get();
-
-            if (!errors.isEmpty()) {
-                for (Error e : errors) {
-                    e.printStackTrace();
-                }
-                throw errors.get(0);
-            }
-
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
+      if (!errors.isEmpty()) {
+        for (Error e : errors) {
+          e.printStackTrace();
         }
-    }
+        throw errors.get(0);
+      }
 
-    @Test(groups = "standalone")
-    public void testNullUrl() throws Exception {
-
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-            assertTrue(true);
-        }
+      assertEquals(response.getStatusCode(), 200);
+      assertEquals(o.toString(), MY_MESSAGE);
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testCloseDerivedValidMaster() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-            try (SimpleAsyncHttpClient derived = client.derive().build()) {
-                derived.get().get();
-            }
+  @Test
+  public void testNullUrl() throws Exception {
 
-            Response response = client.get().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
+      assertTrue(true);
     }
+  }
 
-    @Test(groups = "standalone", expectedExceptions = IllegalStateException.class)
-    public void testCloseMasterInvalidDerived() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-        try (SimpleAsyncHttpClient derived = client.derive().build()) {
-            client.close();
-            
-            try {
-                derived.get().get();
-                fail("Expected closed AHC");
-            } catch (ExecutionException e) {
-                throw e.getCause();
-            }
-        }
+  @Test
+  public void testCloseDerivedValidMaster() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
+      try (SimpleAsyncHttpClient derived = client.derive().build()) {
+        derived.get().get();
+      }
 
+      Response response = client.get().get();
+      assertEquals(response.getStatusCode(), 200);
+    }
+  }
+
+  @Test(expectedExceptions = IllegalStateException.class)
+  public void testCloseMasterInvalidDerived() throws Throwable {
+    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
+    try (SimpleAsyncHttpClient derived = client.derive().build()) {
+      client.close();
+
+      try {
+        derived.get().get();
+        fail("Expected closed AHC");
+      } catch (ExecutionException e) {
+        throw e.getCause();
+      }
     }
 
-    @Test(groups = "standalone")
-    public void testMultiPartPut() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
+  }
 
-            String body = response.getResponseBody();
-            String contentType = response.getHeader("X-Content-Type");
+  @Test
+  public void testMultiPartPut() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+      Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
-            assertTrue(contentType.contains("multipart/form-data"));
+      String body = response.getResponseBody();
+      String contentType = response.getHeader("X-Content-Type");
 
-            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+      assertTrue(contentType.contains("multipart/form-data"));
 
-            assertTrue(body.startsWith("--" + boundary));
-            assertTrue(body.trim().endsWith("--" + boundary + "--"));
-            assertTrue(body.contains("Content-Disposition:"));
-            assertTrue(body.contains("Content-Type: application/test"));
-            assertTrue(body.contains("name=\"baPart"));
-            assertTrue(body.contains("filename=\"fileName"));
-        }
+      String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+
+      assertTrue(body.startsWith("--" + boundary));
+      assertTrue(body.trim().endsWith("--" + boundary + "--"));
+      assertTrue(body.contains("Content-Disposition:"));
+      assertTrue(body.contains("Content-Type: application/test"));
+      assertTrue(body.contains("name=\"baPart"));
+      assertTrue(body.contains("filename=\"fileName"));
     }
+  }
 
-    @Test(groups = "standalone")
-    public void testMultiPartPost() throws Exception {
-        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
+  @Test
+  public void testMultiPartPost() throws Exception {
+    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+      Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
-            String body = response.getResponseBody();
-            String contentType = response.getHeader("X-Content-Type");
+      String body = response.getResponseBody();
+      String contentType = response.getHeader("X-Content-Type");
 
-            assertTrue(contentType.contains("multipart/form-data"));
+      assertTrue(contentType.contains("multipart/form-data"));
 
-            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+      String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
 
-            assertTrue(body.startsWith("--" + boundary));
-            assertTrue(body.trim().endsWith("--" + boundary + "--"));
-            assertTrue(body.contains("Content-Disposition:"));
-            assertTrue(body.contains("Content-Type: application/test"));
-            assertTrue(body.contains("name=\"baPart"));
-            assertTrue(body.contains("filename=\"fileName"));
-        }
+      assertTrue(body.startsWith("--" + boundary));
+      assertTrue(body.trim().endsWith("--" + boundary + "--"));
+      assertTrue(body.contains("Content-Disposition:"));
+      assertTrue(body.contains("Content-Type: application/test"));
+      assertTrue(body.contains("name=\"baPart"));
+      assertTrue(body.contains("filename=\"fileName"));
     }
+  }
 }
diff --git a/extras/typesafeconfig/README.md b/extras/typesafeconfig/README.md
new file mode 100644
index 000000000..dcc29dc26
--- /dev/null
+++ b/extras/typesafeconfig/README.md
@@ -0,0 +1,34 @@
+# Async-http-client and Typesafe Config integration
+
+An `AsyncHttpClientConfig` implementation integrating [Typesafe Config][1] with Async Http Client.
+## Download
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+
+```xml
+<dependency>
+  <groupId>org.asynchttpclient</groupId>
+  <artifactId>async-http-client-extras-typesafe-config</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+
+or [Gradle][3]:
+
+```groovy
+compile "org.asynchttpclient:async-http-client-extras-typesafe-config:latest.version"
+```
+
+ [1]: https://github.com/lightbend/config
+ [2]: https://search.maven.org/remote_content?g=org.asynchttpclient&a=async-http-client-extras-typesafe-config&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.asynchttpclient%22%20a%3A%22async-http-client-extras-typesafe-config%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+
+## Example usage
+
+```java
+// creating async-http-client with Typesafe config
+com.typesafe.config.Config config = ...
+AsyncHttpClientTypesafeConfig ahcConfig = new AsyncHttpClientTypesafeConfig(config);
+AsyncHttpClient client = new DefaultAsyncHttpClient(ahcConfig);
+```
diff --git a/extras/typesafeconfig/pom.xml b/extras/typesafeconfig/pom.xml
new file mode 100644
index 000000000..af0986dd8
--- /dev/null
+++ b/extras/typesafeconfig/pom.xml
@@ -0,0 +1,25 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>async-http-client-extras-typesafe-config</artifactId>
+  <name>Asynchronous Http Client Typesafe Config Extras</name>
+  <description>The Async Http Client Typesafe Config Extras.</description>
+
+  <properties>
+    <typesafeconfig.version>1.3.3</typesafeconfig.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.typesafe</groupId>
+      <artifactId>config</artifactId>
+      <version>${typesafeconfig.version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java b/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java
new file mode 100644
index 000000000..55c88ab25
--- /dev/null
+++ b/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.typesafeconfig;
+
+import com.typesafe.config.Config;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.ssl.SslContext;
+import io.netty.util.Timer;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.SslEngineFactory;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
+import org.asynchttpclient.channel.KeepAliveStrategy;
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.cookie.CookieStore;
+import org.asynchttpclient.cookie.ThreadSafeCookieStore;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.netty.channel.ConnectionSemaphoreFactory;
+import org.asynchttpclient.proxy.ProxyServerSelector;
+
+import java.util.*;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
+
+public class AsyncHttpClientTypesafeConfig implements AsyncHttpClientConfig {
+
+  private final Config config;
+
+  public AsyncHttpClientTypesafeConfig(Config config) {
+    this.config = config;
+  }
+
+  @Override
+  public String getAhcVersion() {
+    return AsyncHttpClientConfigDefaults.AHC_VERSION;
+  }
+
+  @Override
+  public String getThreadPoolName() {
+    return getStringOpt(THREAD_POOL_NAME_CONFIG).orElse(defaultThreadPoolName());
+  }
+
+  @Override
+  public int getMaxConnections() {
+    return getIntegerOpt(MAX_CONNECTIONS_CONFIG).orElse(defaultMaxConnections());
+  }
+
+  @Override
+  public int getMaxConnectionsPerHost() {
+    return getIntegerOpt(MAX_CONNECTIONS_PER_HOST_CONFIG).orElse(defaultMaxConnectionsPerHost());
+  }
+
+  @Override
+  public int getAcquireFreeChannelTimeout() {
+    return getIntegerOpt(ACQUIRE_FREE_CHANNEL_TIMEOUT).orElse(defaultAcquireFreeChannelTimeout());
+  }
+
+  @Override
+  public int getConnectTimeout() {
+    return getIntegerOpt(CONNECTION_TIMEOUT_CONFIG).orElse(defaultConnectTimeout());
+  }
+
+  @Override
+  public int getReadTimeout() {
+    return getIntegerOpt(READ_TIMEOUT_CONFIG).orElse(defaultReadTimeout());
+  }
+
+  @Override
+  public int getPooledConnectionIdleTimeout() {
+    return getIntegerOpt(POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG).orElse(defaultPooledConnectionIdleTimeout());
+  }
+
+  @Override
+  public int getConnectionPoolCleanerPeriod() {
+    return getIntegerOpt(CONNECTION_POOL_CLEANER_PERIOD_CONFIG).orElse(defaultConnectionPoolCleanerPeriod());
+  }
+
+  @Override
+  public int getRequestTimeout() {
+    return getIntegerOpt(REQUEST_TIMEOUT_CONFIG).orElse(defaultRequestTimeout());
+  }
+
+  @Override
+  public boolean isFollowRedirect() {
+    return getBooleanOpt(FOLLOW_REDIRECT_CONFIG).orElse(defaultFollowRedirect());
+  }
+
+  @Override
+  public int getMaxRedirects() {
+    return getIntegerOpt(MAX_REDIRECTS_CONFIG).orElse(defaultMaxRedirects());
+  }
+
+  @Override
+  public boolean isKeepAlive() {
+    return getBooleanOpt(KEEP_ALIVE_CONFIG).orElse(defaultKeepAlive());
+  }
+
+  @Override
+  public String getUserAgent() {
+    return getStringOpt(USER_AGENT_CONFIG).orElse(defaultUserAgent());
+  }
+
+  @Override
+  public boolean isCompressionEnforced() {
+    return getBooleanOpt(COMPRESSION_ENFORCED_CONFIG).orElse(defaultCompressionEnforced());
+  }
+
+  @Override
+  public ThreadFactory getThreadFactory() {
+    return null;
+  }
+
+  @Override
+  public ProxyServerSelector getProxyServerSelector() {
+    return ProxyServerSelector.NO_PROXY_SELECTOR;
+  }
+
+  @Override
+  public SslContext getSslContext() {
+    return null;
+  }
+
+  @Override
+  public Realm getRealm() {
+    return null;
+  }
+
+  @Override
+  public List<RequestFilter> getRequestFilters() {
+    return new LinkedList<>();
+  }
+
+  @Override
+  public List<ResponseFilter> getResponseFilters() {
+    return new LinkedList<>();
+  }
+
+  @Override
+  public List<IOExceptionFilter> getIoExceptionFilters() {
+    return new LinkedList<>();
+  }
+
+  @Override
+  public CookieStore getCookieStore() {
+    return new ThreadSafeCookieStore();
+  }
+
+  @Override
+  public int getMaxRequestRetry() {
+    return getIntegerOpt(MAX_REQUEST_RETRY_CONFIG).orElse(defaultMaxRequestRetry());
+  }
+
+  @Override
+  public boolean isDisableUrlEncodingForBoundRequests() {
+    return getBooleanOpt(DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG).orElse(defaultDisableUrlEncodingForBoundRequests());
+  }
+
+  @Override
+  public boolean isUseLaxCookieEncoder() {
+    return getBooleanOpt(USE_LAX_COOKIE_ENCODER_CONFIG).orElse(defaultUseLaxCookieEncoder());
+  }
+
+  @Override
+  public boolean isStrict302Handling() {
+    return getBooleanOpt(STRICT_302_HANDLING_CONFIG).orElse(defaultStrict302Handling());
+  }
+
+  @Override
+  public int getConnectionTtl() {
+    return getIntegerOpt(CONNECTION_TTL_CONFIG).orElse(defaultConnectionTtl());
+  }
+
+  @Override
+  public boolean isUseOpenSsl() {
+    return getBooleanOpt(USE_OPEN_SSL_CONFIG).orElse(defaultUseOpenSsl());
+  }
+
+  @Override
+  public boolean isUseInsecureTrustManager() {
+    return getBooleanOpt(USE_INSECURE_TRUST_MANAGER_CONFIG).orElse(defaultUseInsecureTrustManager());
+  }
+
+  @Override
+  public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
+    return getBooleanOpt(DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG).orElse(defaultDisableHttpsEndpointIdentificationAlgorithm());
+  }
+
+  @Override
+  public String[] getEnabledProtocols() {
+    return getListOpt(ENABLED_PROTOCOLS_CONFIG).map(list -> list.toArray(new String[0])).orElse(defaultEnabledProtocols());
+  }
+
+  @Override
+  public String[] getEnabledCipherSuites() {
+    return getListOpt(ENABLED_CIPHER_SUITES_CONFIG).map(list -> list.toArray(new String[0])).orElse(defaultEnabledCipherSuites());
+  }
+
+  @Override
+  public boolean isFilterInsecureCipherSuites() {
+    return getBooleanOpt(FILTER_INSECURE_CIPHER_SUITES_CONFIG).orElse(defaultFilterInsecureCipherSuites());
+  }
+
+  @Override
+  public int getSslSessionCacheSize() {
+    return getIntegerOpt(SSL_SESSION_CACHE_SIZE_CONFIG).orElse(defaultSslSessionCacheSize());
+  }
+
+  @Override
+  public int getSslSessionTimeout() {
+    return getIntegerOpt(SSL_SESSION_TIMEOUT_CONFIG).orElse(defaultSslSessionTimeout());
+  }
+
+  @Override
+  public int getHttpClientCodecMaxInitialLineLength() {
+    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG).orElse(defaultHttpClientCodecMaxInitialLineLength());
+  }
+
+  @Override
+  public int getHttpClientCodecMaxHeaderSize() {
+    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG).orElse(defaultHttpClientCodecMaxHeaderSize());
+  }
+
+  @Override
+  public int getHttpClientCodecMaxChunkSize() {
+    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG).orElse(defaultHttpClientCodecMaxChunkSize());
+  }
+
+  @Override
+  public int getHttpClientCodecInitialBufferSize() {
+    return getIntegerOpt(HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG).orElse(defaultHttpClientCodecInitialBufferSize());
+  }
+
+  @Override
+  public boolean isDisableZeroCopy() {
+    return getBooleanOpt(DISABLE_ZERO_COPY_CONFIG).orElse(defaultDisableZeroCopy());
+  }
+
+  @Override
+  public int getHandshakeTimeout() {
+    return getIntegerOpt(HANDSHAKE_TIMEOUT_CONFIG).orElse(defaultHandshakeTimeout());
+  }
+
+  @Override
+  public SslEngineFactory getSslEngineFactory() {
+    return null;
+  }
+
+  @Override
+  public int getChunkedFileChunkSize() {
+    return getIntegerOpt(CHUNKED_FILE_CHUNK_SIZE_CONFIG).orElse(defaultChunkedFileChunkSize());
+  }
+
+  @Override
+  public int getWebSocketMaxBufferSize() {
+    return getIntegerOpt(WEBSOCKET_MAX_BUFFER_SIZE_CONFIG).orElse(defaultWebSocketMaxBufferSize());
+  }
+
+  @Override
+  public int getWebSocketMaxFrameSize() {
+    return getIntegerOpt(WEBSOCKET_MAX_FRAME_SIZE_CONFIG).orElse(defaultWebSocketMaxFrameSize());
+  }
+
+  @Override
+  public boolean isKeepEncodingHeader() {
+    return getBooleanOpt(KEEP_ENCODING_HEADER_CONFIG).orElse(defaultKeepEncodingHeader());
+  }
+
+  @Override
+  public int getShutdownQuietPeriod() {
+    return getIntegerOpt(SHUTDOWN_QUIET_PERIOD_CONFIG).orElse(defaultShutdownQuietPeriod());
+  }
+
+  @Override
+  public int getShutdownTimeout() {
+    return getIntegerOpt(SHUTDOWN_TIMEOUT_CONFIG).orElse(defaultShutdownTimeout());
+  }
+
+  @Override
+  public Map<ChannelOption<Object>, Object> getChannelOptions() {
+    return Collections.emptyMap();
+  }
+
+  @Override
+  public EventLoopGroup getEventLoopGroup() {
+    return null;
+  }
+
+  @Override
+  public boolean isUseNativeTransport() {
+    return getBooleanOpt(USE_NATIVE_TRANSPORT_CONFIG).orElse(defaultUseNativeTransport());
+  }
+
+  @Override
+  public Consumer<Channel> getHttpAdditionalChannelInitializer() {
+    return null;
+  }
+
+  @Override
+  public Consumer<Channel> getWsAdditionalChannelInitializer() {
+    return null;
+  }
+
+  @Override
+  public ResponseBodyPartFactory getResponseBodyPartFactory() {
+    return ResponseBodyPartFactory.EAGER;
+  }
+
+  @Override
+  public ChannelPool getChannelPool() {
+    return null;
+  }
+
+  @Override
+  public ConnectionSemaphoreFactory getConnectionSemaphoreFactory() {
+    return null;
+  }
+
+  @Override
+  public Timer getNettyTimer() {
+    return null;
+  }
+
+  @Override
+  public KeepAliveStrategy getKeepAliveStrategy() {
+    return new DefaultKeepAliveStrategy();
+  }
+
+  @Override
+  public boolean isValidateResponseHeaders() {
+    return getBooleanOpt(VALIDATE_RESPONSE_HEADERS_CONFIG).orElse(defaultValidateResponseHeaders());
+  }
+
+  @Override
+  public boolean isAggregateWebSocketFrameFragments() {
+    return getBooleanOpt(AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG).orElse(defaultAggregateWebSocketFrameFragments());
+  }
+
+  @Override
+  public boolean isEnableWebSocketCompression() {
+    return getBooleanOpt(ENABLE_WEBSOCKET_COMPRESSION_CONFIG).orElse(defaultEnableWebSocketCompression());
+  }
+
+  @Override
+  public boolean isTcpNoDelay() {
+    return getBooleanOpt(TCP_NO_DELAY_CONFIG).orElse(defaultTcpNoDelay());
+  }
+
+  @Override
+  public boolean isSoReuseAddress() {
+    return getBooleanOpt(SO_REUSE_ADDRESS_CONFIG).orElse(defaultSoReuseAddress());
+  }
+
+  @Override
+  public int getSoLinger() {
+    return getIntegerOpt(SO_LINGER_CONFIG).orElse(defaultSoLinger());
+  }
+
+  @Override
+  public int getSoSndBuf() {
+    return getIntegerOpt(SO_SND_BUF_CONFIG).orElse(defaultSoSndBuf());
+  }
+
+  @Override
+  public int getSoRcvBuf() {
+    return getIntegerOpt(SO_RCV_BUF_CONFIG).orElse(defaultSoRcvBuf());
+  }
+
+  @Override
+  public ByteBufAllocator getAllocator() {
+    return null;
+  }
+
+  @Override
+  public int getIoThreadsCount() {
+    return getIntegerOpt(IO_THREADS_COUNT_CONFIG).orElse(defaultIoThreadsCount());
+  }
+
+  private Optional<String> getStringOpt(String key) {
+    return getOpt(config::getString, key);
+  }
+
+  private Optional<Boolean> getBooleanOpt(String key) {
+    return getOpt(config::getBoolean, key);
+  }
+
+  private Optional<Integer> getIntegerOpt(String key) {
+    return getOpt(config::getInt, key);
+  }
+
+  private Optional<List<String>> getListOpt(String key) {
+    return getOpt(config::getStringList, key);
+  }
+
+  private <T> Optional<T> getOpt(Function<String, T> func, String key) {
+    return config.hasPath(key)
+            ? Optional.ofNullable(func.apply(key))
+            : Optional.empty();
+  }
+}
diff --git a/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java b/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java
new file mode 100644
index 000000000..1decc7749
--- /dev/null
+++ b/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.typesafeconfig;
+
+import com.typesafe.config.ConfigFactory;
+import com.typesafe.config.ConfigValue;
+import com.typesafe.config.ConfigValueFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.function.Function;
+
+@Test
+public class AsyncHttpClientTypesafeConfigTest {
+
+  public void testThreadPoolName() {
+    test(AsyncHttpClientTypesafeConfig::getThreadPoolName, "threadPoolName", "MyHttpClient", "AsyncHttpClient");
+  }
+
+  public void testMaxTotalConnections() {
+    test(AsyncHttpClientTypesafeConfig::getMaxConnections, "maxConnections", 100, -1);
+  }
+
+  public void testMaxConnectionPerHost() {
+    test(AsyncHttpClientTypesafeConfig::getMaxConnectionsPerHost, "maxConnectionsPerHost", 100, -1);
+  }
+
+  public void testConnectTimeOut() {
+    test(AsyncHttpClientTypesafeConfig::getConnectTimeout, "connectTimeout", 100, 5 * 1000);
+  }
+
+  public void testPooledConnectionIdleTimeout() {
+    test(AsyncHttpClientTypesafeConfig::getPooledConnectionIdleTimeout, "pooledConnectionIdleTimeout", 200, 6 * 10000);
+  }
+
+  public void testReadTimeout() {
+    test(AsyncHttpClientTypesafeConfig::getReadTimeout, "readTimeout", 100, 60 * 1000);
+  }
+
+  public void testRequestTimeout() {
+    test(AsyncHttpClientTypesafeConfig::getRequestTimeout, "requestTimeout", 200, 6 * 10000);
+  }
+
+  public void testConnectionTtl() {
+    test(AsyncHttpClientTypesafeConfig::getConnectionTtl, "connectionTtl", 100, -1);
+  }
+
+  public void testFollowRedirect() {
+    test(AsyncHttpClientTypesafeConfig::isFollowRedirect, "followRedirect", true, false);
+  }
+
+  public void testMaxRedirects() {
+    test(AsyncHttpClientTypesafeConfig::getMaxRedirects, "maxRedirects", 100, 5);
+  }
+
+  public void testCompressionEnforced() {
+    test(AsyncHttpClientTypesafeConfig::isCompressionEnforced, "compressionEnforced", true, false);
+  }
+
+  public void testStrict302Handling() {
+    test(AsyncHttpClientTypesafeConfig::isStrict302Handling, "strict302Handling", true, false);
+  }
+
+  public void testAllowPoolingConnection() {
+    test(AsyncHttpClientTypesafeConfig::isKeepAlive, "keepAlive", false, true);
+  }
+
+  public void testMaxRequestRetry() {
+    test(AsyncHttpClientTypesafeConfig::getMaxRequestRetry, "maxRequestRetry", 100, 5);
+  }
+
+  public void testDisableUrlEncodingForBoundRequests() {
+    test(AsyncHttpClientTypesafeConfig::isDisableUrlEncodingForBoundRequests, "disableUrlEncodingForBoundRequests", true, false);
+  }
+
+  public void testUseInsecureTrustManager() {
+    test(AsyncHttpClientTypesafeConfig::isUseInsecureTrustManager, "useInsecureTrustManager", true, false);
+  }
+
+  public void testEnabledProtocols() {
+    test(AsyncHttpClientTypesafeConfig::getEnabledProtocols,
+        "enabledProtocols",
+        new String[]{"TLSv1.2", "TLSv1.1"},
+        new String[]{"TLSv1.2", "TLSv1.1", "TLSv1"},
+        Optional.of(obj -> ConfigValueFactory.fromIterable(Arrays.asList(obj)))
+    );
+  }
+
+  private <T> void test(Function<AsyncHttpClientTypesafeConfig, T> func,
+                        String configKey,
+                        T value,
+                        T defaultValue) {
+    test(func, configKey, value, defaultValue, Optional.empty());
+  }
+
+  private <T> void test(Function<AsyncHttpClientTypesafeConfig, T> func,
+                        String configKey,
+                        T value,
+                        T defaultValue,
+                        Optional<Function<T, ConfigValue>> toConfigValue) {
+    AsyncHttpClientTypesafeConfig defaultConfig = new AsyncHttpClientTypesafeConfig(ConfigFactory.empty());
+    Assert.assertEquals(func.apply(defaultConfig), defaultValue);
+
+    AsyncHttpClientTypesafeConfig config = new AsyncHttpClientTypesafeConfig(
+        ConfigFactory.empty().withValue(configKey, toConfigValue.orElse(ConfigValueFactory::fromAnyRef).apply(value))
+    );
+    Assert.assertEquals(func.apply(config), value);
+  }
+}
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
index 29815a010..22f562c7f 100644
--- a/netty-utils/pom.xml
+++ b/netty-utils/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<parent>
-		<groupId>org.asynchttpclient</groupId>
-		<artifactId>async-http-client-project</artifactId>
-		<version>2.1.0-SNAPSHOT</version>
-	</parent>
-	<modelVersion>4.0.0</modelVersion>
-	<artifactId>async-http-client-netty-utils</artifactId>
-	<name>Asynchronous Http Client Netty Utils</name>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>async-http-client-project</artifactId>
+    <version>2.8.2-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>async-http-client-netty-utils</artifactId>
+  <name>Asynchronous Http Client Netty Utils</name>
 
-	<dependencies>
-		<dependency>
-			<groupId>io.netty</groupId>
-			<artifactId>netty-buffer</artifactId>
-		</dependency>
-	</dependencies>
+  <dependencies>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-buffer</artifactId>
+    </dependency>
+  </dependencies>
 </project>
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
index f64f62e99..b95829ebf 100755
--- a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
@@ -13,60 +13,148 @@
  */
 package org.asynchttpclient.netty.util;
 
-import static java.nio.charset.StandardCharsets.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.CharsetUtil;
 
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CoderResult;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.netty.util.Utf8ByteBufCharsetDecoder.*;
 
 public final class ByteBufUtils {
 
-    private ByteBufUtils() {
-    }
+  private static final char[] EMPTY_CHARS = new char[0];
+  private static final ThreadLocal<CharBuffer> CHAR_BUFFERS = ThreadLocal.withInitial(() -> CharBuffer.allocate(1024));
 
-    public static boolean isUtf8OrUsAscii(Charset charset) {
-        return charset.equals(UTF_8) || charset.equals(US_ASCII);
+  private ByteBufUtils() {
+  }
+
+  public static byte[] byteBuf2Bytes(ByteBuf buf) {
+    int readable = buf.readableBytes();
+    int readerIndex = buf.readerIndex();
+    if (buf.hasArray()) {
+      byte[] array = buf.array();
+      if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+        return array;
+      }
     }
+    byte[] array = new byte[readable];
+    buf.getBytes(readerIndex, array);
+    return array;
+  }
+
+  public static String byteBuf2String(Charset charset, ByteBuf buf) {
+    return isUtf8OrUsAscii(charset) ? decodeUtf8(buf) : buf.toString(charset);
+  }
+
+  public static String byteBuf2String(Charset charset, ByteBuf... bufs) {
+    return isUtf8OrUsAscii(charset) ? decodeUtf8(bufs) : byteBuf2String0(charset, bufs);
+  }
+
+  public static char[] byteBuf2Chars(Charset charset, ByteBuf buf) {
+    return isUtf8OrUsAscii(charset) ? decodeUtf8Chars(buf) : decodeChars(buf, charset);
+  }
 
-    public static String byteBuf2StringDefault(Charset charset, ByteBuf... bufs) {
+  public static char[] byteBuf2Chars(Charset charset, ByteBuf... bufs) {
+    return isUtf8OrUsAscii(charset) ? decodeUtf8Chars(bufs) : byteBuf2Chars0(charset, bufs);
+  }
 
-        if (bufs.length == 1) {
-            return bufs[0].toString(charset);
-        }
+  private static boolean isUtf8OrUsAscii(Charset charset) {
+    return charset.equals(UTF_8) || charset.equals(US_ASCII);
+  }
 
-        for (ByteBuf buf : bufs) {
-            buf.retain();
-        }
+  private static char[] decodeChars(ByteBuf src, Charset charset) {
+    int readerIndex = src.readerIndex();
+    int len = src.readableBytes();
 
-        ByteBuf composite = Unpooled.wrappedBuffer(bufs);
+    if (len == 0) {
+      return EMPTY_CHARS;
+    }
+    final CharsetDecoder decoder = CharsetUtil.decoder(charset);
+    final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());
+    CharBuffer dst = CHAR_BUFFERS.get();
+    if (dst.length() < maxLength) {
+      dst = CharBuffer.allocate(maxLength);
+      CHAR_BUFFERS.set(dst);
+    } else {
+      dst.clear();
+    }
+    if (src.nioBufferCount() == 1) {
+      // Use internalNioBuffer(...) to reduce object creation.
+      decode(decoder, src.internalNioBuffer(readerIndex, len), dst);
+    } else {
+      // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers
+      // are both backed by a byte array.
+      ByteBuf buffer = src.alloc().heapBuffer(len);
+      try {
+        buffer.writeBytes(src, readerIndex, len);
+        // Use internalNioBuffer(...) to reduce object creation.
+        decode(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);
+      } finally {
+        // Release the temporary buffer again.
+        buffer.release();
+      }
+    }
+    dst.flip();
+    return toCharArray(dst);
+  }
 
-        try {
-            return composite.toString(charset);
-        } finally {
-            composite.release();
-        }
+  static String byteBuf2String0(Charset charset, ByteBuf... bufs) {
+    if (bufs.length == 1) {
+      return bufs[0].toString(charset);
+    }
+    ByteBuf composite = composite(bufs);
+    try {
+      return composite.toString(charset);
+    } finally {
+      composite.release();
     }
+  }
 
-    public static String byteBuf2String(Charset charset, ByteBuf buf) throws CharacterCodingException {
-        return isUtf8OrUsAscii(charset) ? Utf8ByteBufCharsetDecoder.decodeUtf8(buf) : buf.toString(charset);
+  static char[] byteBuf2Chars0(Charset charset, ByteBuf... bufs) {
+    if (bufs.length == 1) {
+      return decodeChars(bufs[0], charset);
     }
+    ByteBuf composite = composite(bufs);
+    try {
+      return decodeChars(composite, charset);
+    } finally {
+      composite.release();
+    }
+  }
 
-    public static String byteBuf2String(Charset charset, ByteBuf... bufs) throws CharacterCodingException {
-        return isUtf8OrUsAscii(charset) ? Utf8ByteBufCharsetDecoder.decodeUtf8(bufs) : byteBuf2StringDefault(charset, bufs);
+  private static ByteBuf composite(ByteBuf[] bufs) {
+    for (ByteBuf buf : bufs) {
+      buf.retain();
     }
+    return Unpooled.wrappedBuffer(bufs);
+  }
 
-    public static byte[] byteBuf2Bytes(ByteBuf buf) {
-        int readable = buf.readableBytes();
-        int readerIndex = buf.readerIndex();
-        if (buf.hasArray()) {
-            byte[] array = buf.array();
-            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-                return array;
-            }
-        }
-        byte[] array = new byte[readable];
-        buf.getBytes(readerIndex, array);
-        return array;
+  private static void decode(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {
+    try {
+      CoderResult cr = decoder.decode(src, dst, true);
+      if (!cr.isUnderflow()) {
+        cr.throwException();
+      }
+      cr = decoder.flush(dst);
+      if (!cr.isUnderflow()) {
+        cr.throwException();
+      }
+    } catch (CharacterCodingException x) {
+      throw new IllegalStateException(x);
     }
+  }
+
+  static char[] toCharArray(CharBuffer charBuffer) {
+    char[] chars = new char[charBuffer.remaining()];
+    charBuffer.get(chars);
+    return chars;
+  }
 }
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
index ae0331fd2..561fbd8e3 100644
--- a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
@@ -13,7 +13,6 @@
  */
 package org.asynchttpclient.netty.util;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
@@ -22,17 +21,22 @@
 import java.nio.charset.CoderResult;
 import java.nio.charset.CodingErrorAction;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.netty.util.ByteBufUtils.*;
+
 public class Utf8ByteBufCharsetDecoder {
 
   private static final int INITIAL_CHAR_BUFFER_SIZE = 1024;
   private static final int UTF_8_MAX_BYTES_PER_CHAR = 4;
   private static final char INVALID_CHAR_REPLACEMENT = '�';
 
-  private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = new ThreadLocal<Utf8ByteBufCharsetDecoder>() {
-    protected Utf8ByteBufCharsetDecoder initialValue() {
-      return new Utf8ByteBufCharsetDecoder();
-    }
-  };
+  private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = ThreadLocal.withInitial(Utf8ByteBufCharsetDecoder::new);
+  private final CharsetDecoder decoder = configureReplaceCodingErrorActions(UTF_8.newDecoder());
+  protected CharBuffer charBuffer = allocateCharBuffer(INITIAL_CHAR_BUFFER_SIZE);
+  private ByteBuffer splitCharBuffer = ByteBuffer.allocate(UTF_8_MAX_BYTES_PER_CHAR);
+  private int totalSize = 0;
+  private int totalNioBuffers = 0;
+  private boolean withoutArray = false;
 
   private static Utf8ByteBufCharsetDecoder pooledDecoder() {
     Utf8ByteBufCharsetDecoder decoder = POOL.get();
@@ -48,35 +52,16 @@ public static String decodeUtf8(ByteBuf... bufs) {
     return pooledDecoder().decode(bufs);
   }
 
-  private static CharsetDecoder configureReplaceCodingErrorActions(CharsetDecoder decoder) {
-    return decoder.onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
+  public static char[] decodeUtf8Chars(ByteBuf buf) {
+    return pooledDecoder().decodeChars(buf);
   }
 
-  private final CharsetDecoder decoder = configureReplaceCodingErrorActions(UTF_8.newDecoder());
-  protected CharBuffer charBuffer = allocateCharBuffer(INITIAL_CHAR_BUFFER_SIZE);
-  private ByteBuffer splitCharBuffer = ByteBuffer.allocate(UTF_8_MAX_BYTES_PER_CHAR);
-
-  protected CharBuffer allocateCharBuffer(int l) {
-    return CharBuffer.allocate(l);
+  public static char[] decodeUtf8Chars(ByteBuf... bufs) {
+    return pooledDecoder().decodeChars(bufs);
   }
 
-  private void ensureCapacity(int l) {
-    if (charBuffer.position() == 0) {
-      if (charBuffer.capacity() < l) {
-        charBuffer = allocateCharBuffer(l);
-      }
-    } else if (charBuffer.remaining() < l) {
-      CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
-      charBuffer.flip();
-      newCharBuffer.put(charBuffer);
-      charBuffer = newCharBuffer;
-    }
-  }
-
-  public void reset() {
-    configureReplaceCodingErrorActions(decoder.reset());
-    charBuffer.clear();
-    splitCharBuffer.clear();
+  private static CharsetDecoder configureReplaceCodingErrorActions(CharsetDecoder decoder) {
+    return decoder.onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
   }
 
   private static int moreThanOneByteCharSize(byte firstByte) {
@@ -104,6 +89,32 @@ private static boolean isContinuation(byte b) {
     return b >> 6 == -2;
   }
 
+  protected CharBuffer allocateCharBuffer(int l) {
+    return CharBuffer.allocate(l);
+  }
+
+  protected void ensureCapacity(int l) {
+    if (charBuffer.position() == 0) {
+      if (charBuffer.capacity() < l) {
+        charBuffer = allocateCharBuffer(l);
+      }
+    } else if (charBuffer.remaining() < l) {
+      CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
+      charBuffer.flip();
+      newCharBuffer.put(charBuffer);
+      charBuffer = newCharBuffer;
+    }
+  }
+
+  public void reset() {
+    configureReplaceCodingErrorActions(decoder.reset());
+    charBuffer.clear();
+    splitCharBuffer.clear();
+    totalSize = 0;
+    totalNioBuffers = 0;
+    withoutArray = false;
+  }
+
   private boolean stashContinuationBytes(ByteBuffer nioBuffer, int missingBytes) {
     for (int i = 0; i < missingBytes; i++) {
       byte b = nioBuffer.get();
@@ -165,14 +176,14 @@ protected void decodePartial(ByteBuffer nioBuffer, boolean endOfInput) {
     }
   }
 
-  private void decode(ByteBuffer[] nioBuffers, int length) {
+  private void decode(ByteBuffer[] nioBuffers) {
     int count = nioBuffers.length;
     for (int i = 0; i < count; i++) {
       decodePartial(nioBuffers[i].duplicate(), i == count - 1);
     }
   }
 
-  private void decodeSingleNioBuffer(ByteBuffer nioBuffer, int length) {
+  private void decodeSingleNioBuffer(ByteBuffer nioBuffer) {
     decoder.decode(nioBuffer, charBuffer, true);
   }
 
@@ -180,27 +191,72 @@ public String decode(ByteBuf buf) {
     if (buf.isDirect()) {
       return buf.toString(UTF_8);
     }
+    decodeHeap0(buf);
+    return charBuffer.toString();
+  }
+
+  public char[] decodeChars(ByteBuf buf) {
+    if (buf.isDirect()) {
+      return buf.toString(UTF_8).toCharArray();
+    }
+    decodeHeap0(buf);
+    return toCharArray(charBuffer);
+  }
+
+  public String decode(ByteBuf... bufs) {
+    if (bufs.length == 1) {
+      return decode(bufs[0]);
+    }
 
+    inspectByteBufs(bufs);
+    if (withoutArray) {
+      return ByteBufUtils.byteBuf2String0(UTF_8, bufs);
+    } else {
+      decodeHeap0(bufs);
+      return charBuffer.toString();
+    }
+  }
+
+  public char[] decodeChars(ByteBuf... bufs) {
+    if (bufs.length == 1) {
+      return decodeChars(bufs[0]);
+    }
+
+    inspectByteBufs(bufs);
+    if (withoutArray) {
+      return ByteBufUtils.byteBuf2Chars0(UTF_8, bufs);
+    } else {
+      decodeHeap0(bufs);
+      return toCharArray(charBuffer);
+    }
+  }
+
+  private void decodeHeap0(ByteBuf buf) {
     int length = buf.readableBytes();
     ensureCapacity(length);
 
     if (buf.nioBufferCount() == 1) {
-      decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate(), length);
+      decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate());
     } else {
-      decode(buf.nioBuffers(), buf.readableBytes());
+      decode(buf.nioBuffers());
     }
-
-    return charBuffer.flip().toString();
+    charBuffer.flip();
   }
 
-  public String decode(ByteBuf... bufs) {
-    if (bufs.length == 1) {
-      return decode(bufs[0]);
+  private void decodeHeap0(ByteBuf[] bufs) {
+    ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
+    int i = 0;
+    for (ByteBuf buf : bufs) {
+      for (ByteBuffer nioBuffer : buf.nioBuffers()) {
+        nioBuffers[i++] = nioBuffer;
+      }
     }
+    ensureCapacity(totalSize);
+    decode(nioBuffers);
+    charBuffer.flip();
+  }
 
-    int totalSize = 0;
-    int totalNioBuffers = 0;
-    boolean withoutArray = false;
+  private void inspectByteBufs(ByteBuf[] bufs) {
     for (ByteBuf buf : bufs) {
       if (!buf.hasArray()) {
         withoutArray = true;
@@ -209,23 +265,5 @@ public String decode(ByteBuf... bufs) {
       totalSize += buf.readableBytes();
       totalNioBuffers += buf.nioBufferCount();
     }
-
-    if (withoutArray) {
-      return ByteBufUtils.byteBuf2StringDefault(UTF_8, bufs);
-
-    } else {
-      ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
-      int i = 0;
-      for (ByteBuf buf : bufs) {
-        for (ByteBuffer nioBuffer : buf.nioBuffers()) {
-          nioBuffers[i++] = nioBuffer;
-        }
-      }
-
-      ensureCapacity(totalSize);
-      decode(nioBuffers, totalSize);
-
-      return charBuffer.flip().toString();
-    }
   }
 }
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
index 7f7d6ac60..cc326364b 100644
--- a/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
@@ -13,86 +13,85 @@
  */
 package org.asynchttpclient.netty.util;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.testng.Assert.*;
-
-import java.util.Arrays;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-
 import org.testng.annotations.Test;
 
+import java.util.Arrays;
+
+import static java.nio.charset.StandardCharsets.*;
+import static org.testng.Assert.*;
+
 public class Utf8ByteBufCharsetDecoderTest {
 
-    @Test
-    public void testByteBuf2BytesHasBackingArray() {
-        byte[] inputBytes = "testdata".getBytes(US_ASCII);
-        ByteBuf buf = Unpooled.wrappedBuffer(inputBytes);
-        try {
-            byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
-            assertEquals(output, inputBytes);
-        } finally {
-            buf.release();
-        }
+  @Test
+  public void testByteBuf2BytesHasBackingArray() {
+    byte[] inputBytes = "testdata".getBytes(US_ASCII);
+    ByteBuf buf = Unpooled.wrappedBuffer(inputBytes);
+    try {
+      byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
+      assertEquals(output, inputBytes);
+    } finally {
+      buf.release();
     }
+  }
 
-    @Test
-    public void testByteBuf2BytesNoBackingArray() {
-        byte[] inputBytes = "testdata".getBytes(US_ASCII);
-        ByteBuf buf = Unpooled.directBuffer();
-        try {
-            buf.writeBytes(inputBytes);
-            byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
-            assertEquals(output, inputBytes);
-        } finally {
-            buf.release();
-        }
+  @Test
+  public void testByteBuf2BytesNoBackingArray() {
+    byte[] inputBytes = "testdata".getBytes(US_ASCII);
+    ByteBuf buf = Unpooled.directBuffer();
+    try {
+      buf.writeBytes(inputBytes);
+      byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
+      assertEquals(output, inputBytes);
+    } finally {
+      buf.release();
     }
+  }
 
-    @Test
-    public void byteBufs2StringShouldBeAbleToDealWithCharsWithVariableBytesLength() throws Exception {
-        String inputString = "°ä–";
-        byte[] inputBytes = inputString.getBytes(UTF_8);
+  @Test
+  public void byteBufs2StringShouldBeAbleToDealWithCharsWithVariableBytesLength() throws Exception {
+    String inputString = "°ä–";
+    byte[] inputBytes = inputString.getBytes(UTF_8);
 
-        for (int i = 1; i < inputBytes.length - 1; i++) {
-            ByteBuf buf1 = Unpooled.wrappedBuffer(inputBytes, 0, i);
-            ByteBuf buf2 = Unpooled.wrappedBuffer(inputBytes, i, inputBytes.length - i);
-            try {
-                String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
-                assertEquals(s, inputString);
-            } finally {
-                buf1.release();
-                buf2.release();
-            }
-        }
+    for (int i = 1; i < inputBytes.length - 1; i++) {
+      ByteBuf buf1 = Unpooled.wrappedBuffer(inputBytes, 0, i);
+      ByteBuf buf2 = Unpooled.wrappedBuffer(inputBytes, i, inputBytes.length - i);
+      try {
+        String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
+        assertEquals(s, inputString);
+      } finally {
+        buf1.release();
+        buf2.release();
+      }
     }
+  }
 
-    @Test
-    public void byteBufs2StringShouldBeAbleToDealWithBrokenCharsTheSameWayAsJavaImpl() throws Exception {
-        String inputString = "foo 加特林岩石 bar";
-        byte[] inputBytes = inputString.getBytes(UTF_8);
+  @Test
+  public void byteBufs2StringShouldBeAbleToDealWithBrokenCharsTheSameWayAsJavaImpl() throws Exception {
+    String inputString = "foo 加特林岩石 bar";
+    byte[] inputBytes = inputString.getBytes(UTF_8);
 
-        int droppedBytes = 1;
+    int droppedBytes = 1;
 
-        for (int i = 1; i < inputBytes.length - 1 - droppedBytes; i++) {
-            byte[] part1 = Arrays.copyOfRange(inputBytes, 0, i);
-            byte[] part2 = Arrays.copyOfRange(inputBytes, i + droppedBytes, inputBytes.length);
-            byte[] merged = new byte[part1.length + part2.length];
-            System.arraycopy(part1, 0, merged, 0, part1.length);
-            System.arraycopy(part2, 0, merged, part1.length, part2.length);
+    for (int i = 1; i < inputBytes.length - 1 - droppedBytes; i++) {
+      byte[] part1 = Arrays.copyOfRange(inputBytes, 0, i);
+      byte[] part2 = Arrays.copyOfRange(inputBytes, i + droppedBytes, inputBytes.length);
+      byte[] merged = new byte[part1.length + part2.length];
+      System.arraycopy(part1, 0, merged, 0, part1.length);
+      System.arraycopy(part2, 0, merged, part1.length, part2.length);
 
-            ByteBuf buf1 = Unpooled.wrappedBuffer(part1);
-            ByteBuf buf2 = Unpooled.wrappedBuffer(part2);
-            try {
-                String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
-                String javaString = new String(merged, UTF_8);
-                assertNotEquals(s, inputString);
-                assertEquals(s, javaString);
-            } finally {
-                buf1.release();
-                buf2.release();
-            }
-        }
+      ByteBuf buf1 = Unpooled.wrappedBuffer(part1);
+      ByteBuf buf2 = Unpooled.wrappedBuffer(part2);
+      try {
+        String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
+        String javaString = new String(merged, UTF_8);
+        assertNotEquals(s, inputString);
+        assertEquals(s, javaString);
+      } finally {
+        buf1.release();
+        buf2.release();
+      }
     }
+  }
 }
diff --git a/pom.xml b/pom.xml
index b1a66bff4..fbd0450c7 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,400 +1,448 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<parent>
-		<groupId>org.sonatype.oss</groupId>
-		<artifactId>oss-parent</artifactId>
-		<version>9</version>
-	</parent>
-	<modelVersion>4.0.0</modelVersion>
-	<groupId>org.asynchttpclient</groupId>
-	<artifactId>async-http-client-project</artifactId>
-	<name>Asynchronous Http Client Project</name>
-	<version>2.1.0-SNAPSHOT</version>
-	<packaging>pom</packaging>
-	<description>
-        The Async Http Client (AHC) library's purpose is to allow Java
-        applications to easily execute HTTP requests and
-        asynchronously process the response.
-    </description>
-	<url>http://github.com/AsyncHttpClient/async-http-client</url>
-	<scm>
-		<url>https://github.com/AsyncHttpClient/async-http-client</url>
-		<connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</connection>
-		<developerConnection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</developerConnection>
-	</scm>
-	<issueManagement>
-		<system>jira</system>
-		<url>https://issues.sonatype.org/browse/AHC</url>
-	</issueManagement>
-	<mailingLists>
-		<mailingList>
-			<name>asynchttpclient</name>
-			<archive>http://groups.google.com/group/asynchttpclient/topics</archive>
-			<subscribe>http://groups.google.com/group/asynchttpclient/subscribe</subscribe>
-			<unsubscribe>http://groups.google.com/group/asynchttpclient/subscribe</unsubscribe>
-			<post>asynchttpclient@googlegroups.com</post>
-		</mailingList>
-	</mailingLists>
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>9</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>org.asynchttpclient</groupId>
+  <artifactId>async-http-client-project</artifactId>
+  <name>Asynchronous Http Client Project</name>
+  <version>2.8.2-SNAPSHOT</version>
+  <packaging>pom</packaging>
+  <description>
+    The Async Http Client (AHC) library's purpose is to allow Java
+    applications to easily execute HTTP requests and
+    asynchronously process the response.
+  </description>
+  <url>http://github.com/AsyncHttpClient/async-http-client</url>
+  <scm>
+    <url>https://github.com/AsyncHttpClient/async-http-client</url>
+    <connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</connection>
+    <developerConnection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</developerConnection>
+  </scm>
+  <issueManagement>
+    <system>jira</system>
+    <url>https://issues.sonatype.org/browse/AHC</url>
+  </issueManagement>
+  <mailingLists>
+    <mailingList>
+      <name>asynchttpclient</name>
+      <archive>http://groups.google.com/group/asynchttpclient/topics</archive>
+      <subscribe>http://groups.google.com/group/asynchttpclient/subscribe</subscribe>
+      <unsubscribe>http://groups.google.com/group/asynchttpclient/subscribe</unsubscribe>
+      <post>asynchttpclient@googlegroups.com</post>
+    </mailingList>
+  </mailingLists>
 
-	<prerequisites>
-		<maven>3.0.0</maven>
-	</prerequisites>
-	<developers>
-		<developer>
-			<id>slandelle</id>
-			<name>Stephane Landelle</name>
-			<email>slandelle@gatling.io</email>
-		</developer>
-	</developers>
-	<licenses>
-		<license>
-			<name>Apache License 2.0</name>
-			<url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
-			<distribution>repo</distribution>
-		</license>
-	</licenses>
-	<build>
-		<resources>
-			<resource>
-				<filtering>true</filtering>
-				<directory>src/main/resources/</directory>
-			</resource>
-		</resources>
-		<extensions>
-			<!-- Enabling the use of SSH -->
-			<extension>
-				<groupId>org.apache.maven.wagon</groupId>
-				<artifactId>wagon-ssh-external</artifactId>
-				<version>1.0-beta-6</version>
-			</extension>
-			<extension>
-				<groupId>org.apache.maven.scm</groupId>
-				<artifactId>maven-scm-provider-gitexe</artifactId>
-				<version>1.6</version>
-			</extension>
-			<extension>
-				<groupId>org.apache.maven.scm</groupId>
-				<artifactId>maven-scm-manager-plexus</artifactId>
-				<version>1.6</version>
-			</extension>
-		</extensions>
-		<defaultGoal>install</defaultGoal>
-		<plugins>
-			<plugin>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<version>3.6.1</version>
-				<configuration>
-					<source>${source.property}</source>
-					<target>${target.property}</target>
-					<maxmem>1024m</maxmem>
-				</configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-surefire-plugin</artifactId>
-				<version>2.19.1</version>
-				<configuration>
-					<redirectTestOutputToFile>${surefire.redirectTestOutputToFile}</redirectTestOutputToFile>
-					<systemPropertyVariables>
-						<org.asynchttpclient.shutdownQuietPeriod>10</org.asynchttpclient.shutdownQuietPeriod>
-						<org.asynchttpclient.shutdownTimeout>100</org.asynchttpclient.shutdownTimeout>
-						<sun.net.spi.nameservice.nameservers>8.8.8.8</sun.net.spi.nameservice.nameservers>
-						<sun.net.spi.nameservice.provider.1>dns,sun</sun.net.spi.nameservice.provider.1>
-					</systemPropertyVariables>
-				</configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-enforcer-plugin</artifactId>
-				<version>1.4.1</version>
-				<executions>
-					<execution>
-						<id>enforce-versions</id>
-						<goals>
-							<goal>enforce</goal>
-						</goals>
-						<configuration>
-							<rules>
-								<requireJavaVersion>
-									<version>${source.property}</version>
-								</requireJavaVersion>
-							</rules>
-						</configuration>
-					</execution>
-				</executions>
-			</plugin>
-			<plugin>
-				<artifactId>maven-resources-plugin</artifactId>
-				<version>3.0.2</version>
-				<configuration>
-					<encoding>UTF-8</encoding>
-				</configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-release-plugin</artifactId>
-				<configuration>
-					<autoVersionSubmodules>true</autoVersionSubmodules>
-				</configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-jar-plugin</artifactId>
-				<version>3.0.2</version>
-			</plugin>
-			<plugin>
-				<artifactId>maven-source-plugin</artifactId>
-				<version>3.0.1</version>
-				<executions>
-					<execution>
-						<id>attach-sources</id>
-						<phase>verify</phase>
-						<goals>
-							<goal>jar-no-fork</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-		<pluginManagement>
-			<plugins>
-				<plugin>
-					<artifactId>maven-javadoc-plugin</artifactId>
-					<version>2.10.4</version>
-				</plugin>
-			</plugins>
-		</pluginManagement>
-	</build>
-	<profiles>
-		<profile>
-			<id>release-sign-artifacts</id>
-			<activation>
-				<property>
-					<name>performRelease</name>
-					<value>true</value>
-				</property>
-			</activation>
-			<build>
-				<plugins>
-					<plugin>
-						<artifactId>maven-gpg-plugin</artifactId>
-						<executions>
-							<execution>
-								<id>sign-artifacts</id>
-								<phase>verify</phase>
-								<goals>
-									<goal>sign</goal>
-								</goals>
-							</execution>
-						</executions>
-					</plugin>
-				</plugins>
-			</build>
-		</profile>
-		<profile>
-			<id>test-output</id>
-			<properties>
-				<surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
-			</properties>
-		</profile>
-	</profiles>
-	<distributionManagement>
-		<repository>
-			<id>sonatype-nexus-staging</id>
-			<name>Sonatype Release</name>
-			<url>http://oss.sonatype.org/service/local/staging/deploy/maven2
-            </url>
-		</repository>
-		<snapshotRepository>
-			<id>sonatype-nexus-snapshots</id>
-			<name>sonatype-nexus-snapshots</name>
-			<url>${distMgmtSnapshotsUrl}</url>
-		</snapshotRepository>
-	</distributionManagement>
-	<modules>
-		<module>netty-utils</module>
-		<module>client</module>
-		<module>extras</module>
-		<module>example</module>
-	</modules>
-	<dependencyManagement>
-		<dependencies>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-buffer</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-codec-http</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-codec</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-common</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-transport</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-handler</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-resolver-dns</artifactId>
-				<version>${netty.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.netty</groupId>
-				<artifactId>netty-transport-native-epoll</artifactId>
-				<classifier>linux-x86_64</classifier>
-				<version>${netty.version}</version>
-				<optional>true</optional>
-			</dependency>
-			<dependency>
-				<groupId>org.reactivestreams</groupId>
-				<artifactId>reactive-streams</artifactId>
-				<version>${reactive-streams.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>com.typesafe.netty</groupId>
-				<artifactId>netty-reactive-streams</artifactId>
-				<version>${netty-reactive-streams.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.reactivex</groupId>
-				<artifactId>rxjava</artifactId>
-				<version>${rxjava.version}</version>
-			</dependency>
-			<dependency>
-				<groupId>io.reactivex.rxjava2</groupId>
-				<artifactId>rxjava</artifactId>
-				<version>${rxjava2.version}</version>
-			</dependency>
-		</dependencies>
-	</dependencyManagement>
-	<dependencies>
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>slf4j-api</artifactId>
-			<version>${slf4j.version}</version>
-		</dependency>
-		<!-- Test dependencies -->
-		<dependency>
-			<groupId>ch.qos.logback</groupId>
-			<artifactId>logback-classic</artifactId>
-			<version>${logback.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.testng</groupId>
-			<artifactId>testng</artifactId>
-			<version>${testng.version}</version>
-			<scope>test</scope>
-			<exclusions>
-				<exclusion>
-					<groupId>org.beanshell</groupId>
-					<artifactId>bsh</artifactId>
-				</exclusion>
-			</exclusions>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty</groupId>
-			<artifactId>jetty-servlet</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty</groupId>
-			<artifactId>jetty-servlets</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty</groupId>
-			<artifactId>jetty-security</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty</groupId>
-			<artifactId>jetty-proxy</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty.websocket</groupId>
-			<artifactId>websocket-server</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.eclipse.jetty.websocket</groupId>
-			<artifactId>websocket-servlet</artifactId>
-			<version>${jetty.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.apache.tomcat.embed</groupId>
-			<artifactId>tomcat-embed-core</artifactId>
-			<version>${tomcat.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>commons-io</groupId>
-			<artifactId>commons-io</artifactId>
-			<version>${commons-io.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>commons-fileupload</groupId>
-			<artifactId>commons-fileupload</artifactId>
-			<version>${commons-fileupload.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>com.e-movimento.tinytools</groupId>
-			<artifactId>privilegedaccessor</artifactId>
-			<version>${privilegedaccessor.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.powermock</groupId>
-			<artifactId>powermock-module-testng</artifactId>
-			<version>${powermock.version}</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.powermock</groupId>
-			<artifactId>powermock-api-mockito</artifactId>
-			<version>${powermock.version}</version>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
-	<properties>
-		<distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
-		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
-		<source.property>1.8</source.property>
-		<target.property>1.8</target.property>
-		<netty.version>4.1.16.Final</netty.version>
-		<slf4j.version>1.7.25</slf4j.version>
-		<reactive-streams.version>1.0.0</reactive-streams.version>
-		<netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
-		<rxjava.version>1.3.2</rxjava.version>
-		<rxjava2.version>2.1.4</rxjava2.version>
-		<logback.version>1.2.3</logback.version>
-		<testng.version>6.11</testng.version>
-		<jetty.version>9.4.7.v20170914</jetty.version>
-		<tomcat.version>8.5.21</tomcat.version>
-		<commons-io.version>2.5</commons-io.version>
-		<commons-fileupload.version>1.3.3</commons-fileupload.version>
-		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-		<powermock.version>1.6.6</powermock.version>
-	</properties>
+  <prerequisites>
+    <maven>3.0.0</maven>
+  </prerequisites>
+  <developers>
+    <developer>
+      <id>slandelle</id>
+      <name>Stephane Landelle</name>
+      <email>slandelle@gatling.io</email>
+    </developer>
+  </developers>
+  <licenses>
+    <license>
+      <name>Apache License 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
+      <distribution>repo</distribution>
+    </license>
+  </licenses>
+  <build>
+    <resources>
+      <resource>
+        <filtering>true</filtering>
+        <directory>src/main/resources/</directory>
+      </resource>
+    </resources>
+    <extensions>
+      <!-- Enabling the use of SSH -->
+      <extension>
+        <groupId>org.apache.maven.wagon</groupId>
+        <artifactId>wagon-ssh-external</artifactId>
+        <version>1.0-beta-6</version>
+      </extension>
+      <extension>
+        <groupId>org.apache.maven.scm</groupId>
+        <artifactId>maven-scm-provider-gitexe</artifactId>
+        <version>1.6</version>
+      </extension>
+      <extension>
+        <groupId>org.apache.maven.scm</groupId>
+        <artifactId>maven-scm-manager-plexus</artifactId>
+        <version>1.6</version>
+      </extension>
+    </extensions>
+    <defaultGoal>install</defaultGoal>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.6.1</version>
+        <configuration>
+          <source>${source.property}</source>
+          <target>${target.property}</target>
+          <maxmem>1024m</maxmem>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <version>2.19.1</version>
+        <configuration>
+          <redirectTestOutputToFile>${surefire.redirectTestOutputToFile}</redirectTestOutputToFile>
+          <systemPropertyVariables>
+            <org.asynchttpclient.shutdownQuietPeriod>10</org.asynchttpclient.shutdownQuietPeriod>
+            <org.asynchttpclient.shutdownTimeout>100</org.asynchttpclient.shutdownTimeout>
+            <sun.net.spi.nameservice.nameservers>8.8.8.8</sun.net.spi.nameservice.nameservers>
+            <sun.net.spi.nameservice.provider.1>dns,sun</sun.net.spi.nameservice.provider.1>
+          </systemPropertyVariables>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-enforcer-plugin</artifactId>
+        <version>1.4.1</version>
+        <executions>
+          <execution>
+            <id>enforce-versions</id>
+            <goals>
+              <goal>enforce</goal>
+            </goals>
+            <configuration>
+              <rules>
+                <requireJavaVersion>
+                  <version>${source.property}</version>
+                </requireJavaVersion>
+              </rules>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <artifactId>maven-resources-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <encoding>UTF-8</encoding>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-release-plugin</artifactId>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+      </plugin>
+      <plugin>
+        <artifactId>maven-source-plugin</artifactId>
+        <version>3.0.1</version>
+        <executions>
+          <execution>
+            <id>attach-sources</id>
+            <phase>verify</phase>
+            <goals>
+              <goal>jar-no-fork</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
+        <version>3.0.1</version>
+        <extensions>true</extensions>
+        <configuration>
+          <manifestLocation>META-INF</manifestLocation>
+          <instructions>
+            <Bundle-Version>$(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))</Bundle-Version>
+            <Bundle-Vendor>The AsyncHttpClient Project</Bundle-Vendor>
+            <Import-Package>javax.activation;version="[1.1,2)", *</Import-Package>
+          </instructions>
+        </configuration>
+        <executions>
+          <execution>
+            <id>osgi-bundle</id>
+            <phase>package</phase>
+            <goals>
+              <goal>bundle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>3.0.1</version>
+        <configuration>
+          <doclint>none</doclint>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <profiles>
+    <profile>
+      <id>release-sign-artifacts</id>
+      <activation>
+        <property>
+          <name>performRelease</name>
+          <value>true</value>
+        </property>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-gpg-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>sign-artifacts</id>
+                <phase>verify</phase>
+                <goals>
+                  <goal>sign</goal>
+                </goals>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+    <profile>
+      <id>test-output</id>
+      <properties>
+        <surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
+      </properties>
+    </profile>
+  </profiles>
+  <distributionManagement>
+    <snapshotRepository>
+      <id>sonatype-nexus-staging</id>
+      <url>https://oss.sonatype.org/content/repositories/snapshots</url>
+    </snapshotRepository>
+    <repository>
+      <id>sonatype-nexus-staging</id>
+      <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
+    </repository>
+  </distributionManagement>
+  <modules>
+    <module>netty-utils</module>
+    <module>client</module>
+    <module>extras</module>
+    <module>example</module>
+  </modules>
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-buffer</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-codec-http</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-codec</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-codec-socks</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-handler-proxy</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-common</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-transport</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-handler</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-resolver-dns</artifactId>
+        <version>${netty.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-transport-native-epoll</artifactId>
+        <classifier>linux-x86_64</classifier>
+        <version>${netty.version}</version>
+        <optional>true</optional>
+      </dependency>
+      <dependency>
+        <groupId>org.reactivestreams</groupId>
+        <artifactId>reactive-streams</artifactId>
+        <version>${reactive-streams.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.reactivestreams</groupId>
+        <artifactId>reactive-streams-examples</artifactId>
+        <version>${reactive-streams.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.typesafe.netty</groupId>
+        <artifactId>netty-reactive-streams</artifactId>
+        <version>${netty-reactive-streams.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.reactivex</groupId>
+        <artifactId>rxjava</artifactId>
+        <version>${rxjava.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>io.reactivex.rxjava2</groupId>
+        <artifactId>rxjava</artifactId>
+        <version>${rxjava2.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.kerby</groupId>
+        <artifactId>kerb-simplekdc</artifactId>
+        <version>${kerby.version}</version>
+        <scope>test</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+  <dependencies>
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
+      <version>${slf4j.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.sun.activation</groupId>
+      <artifactId>javax.activation</artifactId>
+      <version>${activation.version}</version>
+    </dependency>
+    <!-- Test dependencies -->
+    <dependency>
+      <groupId>ch.qos.logback</groupId>
+      <artifactId>logback-classic</artifactId>
+      <version>${logback.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.testng</groupId>
+      <artifactId>testng</artifactId>
+      <version>${testng.version}</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <groupId>org.beanshell</groupId>
+          <artifactId>bsh</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty</groupId>
+      <artifactId>jetty-servlet</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty</groupId>
+      <artifactId>jetty-servlets</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty</groupId>
+      <artifactId>jetty-security</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty</groupId>
+      <artifactId>jetty-proxy</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty.websocket</groupId>
+      <artifactId>websocket-server</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty.websocket</groupId>
+      <artifactId>websocket-servlet</artifactId>
+      <version>${jetty.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.tomcat.embed</groupId>
+      <artifactId>tomcat-embed-core</artifactId>
+      <version>${tomcat.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>${commons-io.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>commons-fileupload</groupId>
+      <artifactId>commons-fileupload</artifactId>
+      <version>${commons-fileupload.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.e-movimento.tinytools</groupId>
+      <artifactId>privilegedaccessor</artifactId>
+      <version>${privilegedaccessor.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <version>${mockito.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.hamcrest</groupId>
+      <artifactId>hamcrest</artifactId>
+      <version>${hamcrest.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <properties>
+    <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
+    <source.property>1.8</source.property>
+    <target.property>1.8</target.property>
+    <netty.version>4.1.33.Final</netty.version>
+    <slf4j.version>1.7.25</slf4j.version>
+    <reactive-streams.version>1.0.2</reactive-streams.version>
+    <activation.version>1.2.0</activation.version>
+    <netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
+    <rxjava.version>1.3.8</rxjava.version>
+    <rxjava2.version>2.2.5</rxjava2.version>
+    <logback.version>1.2.3</logback.version>
+    <testng.version>6.13.1</testng.version>
+    <jetty.version>9.4.14.v20181114</jetty.version>
+    <tomcat.version>9.0.14</tomcat.version>
+    <commons-io.version>2.6</commons-io.version>
+    <commons-fileupload.version>1.3.3</commons-fileupload.version>
+    <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
+    <mockito.version>2.23.4</mockito.version>
+    <hamcrest.version>2.1</hamcrest.version>
+    <kerby.version>1.1.1</kerby.version>
+  </properties>
 </project>
