diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/BlockingConnectionSemaphoreFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/BlockingConnectionSemaphoreFactory.java
new file mode 100644
index 000000000..384f67b96
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/BlockingConnectionSemaphoreFactory.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class BlockingConnectionSemaphoreFactory implements ConnectionSemaphoreFactory {
+
+  public ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
+    ConnectionSemaphore semaphore = new NoopConnectionSemaphore();
+    if (config.getMaxConnections() > 0) {
+      semaphore = new MaxConnectionBlockingSemaphore(config.getMaxConnections());
+    }
+    if (config.getMaxConnectionsPerHost() > 0) {
+      semaphore = new PerHostConnectionBlockingSemaphore(config.getMaxConnectionsPerHost(), semaphore);
+    }
+    return semaphore;
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/BlockingSemaphoreInfinite.java b/client/src/main/java/org/asynchttpclient/netty/channel/BlockingSemaphoreInfinite.java
new file mode 100644
index 000000000..97701b930
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/BlockingSemaphoreInfinite.java
@@ -0,0 +1,97 @@
+package org.asynchttpclient.netty.channel;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A java.util.concurrent.Semaphore that always has Integer.Integer.MAX_VALUE free permits
+ *
+ * @author Alex Maltinsky
+ */
+public class BlockingSemaphoreInfinite extends Semaphore {
+
+  public static final BlockingSemaphoreInfinite INSTANCE = new BlockingSemaphoreInfinite();
+  private static final long serialVersionUID = 1L;
+
+  private BlockingSemaphoreInfinite() {
+    super(Integer.MAX_VALUE);
+  }
+
+  @Override
+  public void acquire() {
+    // NO-OP
+  }
+
+  @Override
+  public void acquireUninterruptibly() {
+    // NO-OP
+  }
+
+  @Override
+  public boolean tryAcquire() {
+    return true;
+  }
+
+  @Override
+  public boolean tryAcquire(long timeout, TimeUnit unit) {
+    return true;
+  }
+
+  @Override
+  public void release() {
+    // NO-OP
+  }
+
+  @Override
+  public void acquire(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public void acquireUninterruptibly(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public boolean tryAcquire(int permits) {
+    return true;
+  }
+
+  @Override
+  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
+    return true;
+  }
+
+  @Override
+  public void release(int permits) {
+    // NO-OP
+  }
+
+  @Override
+  public int availablePermits() {
+    return Integer.MAX_VALUE;
+  }
+
+  @Override
+  public int drainPermits() {
+    return Integer.MAX_VALUE;
+  }
+
+  @Override
+  protected void reducePermits(int reduction) {
+    // NO-OP
+  }
+
+  @Override
+  public boolean isFair() {
+    return true;
+  }
+
+  @Override
+  protected Collection<Thread> getQueuedThreads() {
+    return Collections.emptyList();
+  }
+}
+
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionBlockingSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionBlockingSemaphore.java
new file mode 100644
index 000000000..a5699df6e
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/MaxConnectionBlockingSemaphore.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import java.util.concurrent.Semaphore;
+
+/**
+ * A blocking connection semaphore based on a plain java Semaphore
+ *
+ * @author Alex Maltinsky
+ */
+public class MaxConnectionBlockingSemaphore implements ConnectionSemaphore {
+
+  private final Semaphore freeChannels;
+
+  MaxConnectionBlockingSemaphore(int maxConnections) {
+    this.freeChannels = maxConnections > 0 ? new Semaphore(maxConnections) : BlockingSemaphoreInfinite.INSTANCE;
+  }
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) {
+    try {
+      this.freeChannels.acquire();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+    this.freeChannels.release();
+  }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionBlockingSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionBlockingSemaphore.java
new file mode 100644
index 000000000..8cbf90333
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/PerHostConnectionBlockingSemaphore.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+
+import java.io.IOException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Semaphore;
+
+/**
+ * A blocking per-host connections limiter
+ *
+ * @author Alex Maltinsky
+ */
+public class PerHostConnectionBlockingSemaphore implements ConnectionSemaphore {
+
+  private final ConnectionSemaphore globalSemaphore;
+
+  private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
+  private final int maxConnectionsPerHost;
+
+  PerHostConnectionBlockingSemaphore(int maxConnectionsPerHost, ConnectionSemaphore globalSemaphore) {
+    this.globalSemaphore = globalSemaphore;
+    this.maxConnectionsPerHost = maxConnectionsPerHost;
+  }
+
+  @Override
+  public void acquireChannelLock(Object partitionKey) throws IOException {
+    globalSemaphore.acquireChannelLock(partitionKey);
+
+    try {
+      getFreeConnectionsForHost(partitionKey).acquire();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void releaseChannelLock(Object partitionKey) {
+    globalSemaphore.releaseChannelLock(partitionKey);
+    getFreeConnectionsForHost(partitionKey).release();
+  }
+
+  private Semaphore getFreeConnectionsForHost(Object partitionKey) {
+    return maxConnectionsPerHost > 0 ?
+            freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new Semaphore(maxConnectionsPerHost)) :
+            BlockingSemaphoreInfinite.INSTANCE;
+  }
+}
