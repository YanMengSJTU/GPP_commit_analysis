diff --git a/LICENSE-2.0.txt b/LICENSE-2.0.txt
deleted file mode 100644
index d64569567..000000000
--- a/LICENSE-2.0.txt
+++ /dev/null
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 000000000..41caa5b6f
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,13 @@
+Copyright 2014-2016 AsyncHttpClient Project
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/README.md b/README.md
index cbd817f13..2201260e9 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@ Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on tw
 The Async Http Client library's purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
 The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
 
-I's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
+It's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
 
 Latest `version`: [![Maven][mavenImg]][mavenLink]
 
@@ -67,6 +67,26 @@ asyncHttpClient.prepareGet("http://www.example.com/").execute(new AsyncCompletio
 
 (this will also fully read `Response` in memory before calling `onCompleted`)
 
+Alternatively you may use continuations (through Java 8 class `CompletableFuture<T>`) to accomplish asynchronous (non-blocking) solution. The equivalent continuation approach to the previous example is:
+
+```java
+import static org.asynchttpclient.Dsl.*;
+
+import org.asynchttpclient.*;
+import java.util.concurrent.CompletableFuture;
+
+AsyncHttpClient asyncHttpClient = asyncHttpClient();
+CompletableFuture<Response> promise = asyncHttpClient
+            .prepareGet("http://www.example.com/")
+            .execute()
+            .toCompletableFuture()
+            .exceptionally(t -> { /* Something wrong happened... */  } )
+            .thenApply(resp -> { /*  Do something with the Response */ return resp; });
+promise.join(); // wait for completion
+```
+
+You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
+
 You can also mix Future with AsyncHandler to only retrieve part of the asynchronous response
 
 ```java
@@ -97,10 +117,12 @@ which is something you want to do for large responses: this way you can process
  You have full control on the Response life cycle, so you can decide at any moment to stop processing what the server is sending back:
 
 ```java
+import static org.asynchttpclient.Dsl.*;
+
 import org.asynchttpclient.*;
 import java.util.concurrent.Future;
 
-AsyncHttpClient c = new DefaultAsyncHttpClient();
+AsyncHttpClient c = asyncHttpClient();
 Future<String> f = c.prepareGet("http://www.example.com/").execute(new AsyncHandler<String>() {
     private ByteArrayOutputStream bytes = new ByteArrayOutputStream();
 
diff --git a/client/pom.xml b/client/pom.xml
index b2047fc41..4fdaf851a 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.11-SNAPSHOT</version>
+		<version>2.0.24-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
@@ -25,6 +25,11 @@
 	</build>
 
 	<dependencies>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>async-http-client-netty-utils</artifactId>
+			<version>${project.version}</version>
+		</dependency>
 		<dependency>
 			<groupId>io.netty</groupId>
 			<artifactId>netty-codec-http</artifactId>
@@ -47,12 +52,12 @@
 		<dependency>
 			<groupId>com.typesafe.netty</groupId>
 			<artifactId>netty-reactive-streams</artifactId>
-			<version>1.0.6</version>
+			<version>1.0.8</version>
 		</dependency>
 		<dependency>
 			<groupId>org.javassist</groupId>
 			<artifactId>javassist</artifactId>
-			<version>3.20.0-GA</version>
+			<version>3.21.0-GA</version>
 		</dependency>
 	</dependencies>
 </project>
diff --git a/client/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java b/client/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
new file mode 100644
index 000000000..3cfadcb0d
--- /dev/null
+++ b/client/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.ReferenceCountUtil;
+
+import java.util.List;
+
+/**
+ * Decodes the content of the received {@link HttpRequest} and {@link HttpContent}.
+ * The original content is replaced with the new content decoded by the
+ * {@link EmbeddedChannel}, which is created by {@link #newContentDecoder(String)}.
+ * Once decoding is finished, the value of the <tt>'Content-Encoding'</tt>
+ * header is set to the target content encoding, as returned by {@link #getTargetContentEncoding(String)}.
+ * Also, the <tt>'Content-Length'</tt> header is updated to the length of the
+ * decoded content.  If the content encoding of the original is not supported
+ * by the decoder, {@link #newContentDecoder(String)} should return {@code null}
+ * so that no decoding occurs (i.e. pass-through).
+ * <p>
+ * Please note that this is an abstract class.  You have to extend this class
+ * and implement {@link #newContentDecoder(String)} properly to make this class
+ * functional.  For example, refer to the source code of {@link HttpContentDecompressor}.
+ * <p>
+ * This handler must be placed after {@link HttpObjectDecoder} in the pipeline
+ * so that this handler can intercept HTTP requests after {@link HttpObjectDecoder}
+ * converts {@link ByteBuf}s into HTTP requests.
+ */
+public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObject> {
+
+    protected ChannelHandlerContext ctx;
+    private EmbeddedChannel decoder;
+    private boolean continueResponse;
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
+        if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
+
+            if (!(msg instanceof LastHttpContent)) {
+                continueResponse = true;
+            }
+            // 100-continue response must be passed through.
+            out.add(ReferenceCountUtil.retain(msg));
+            return;
+        }
+
+        if (continueResponse) {
+            if (msg instanceof LastHttpContent) {
+                continueResponse = false;
+            }
+            // 100-continue response must be passed through.
+            out.add(ReferenceCountUtil.retain(msg));
+            return;
+        }
+
+        if (msg instanceof HttpMessage) {
+            cleanup();
+            final HttpMessage message = (HttpMessage) msg;
+            final HttpHeaders headers = message.headers();
+
+            // Determine the content encoding.
+            String contentEncoding = headers.get(HttpHeaders.Names.CONTENT_ENCODING);
+            if (contentEncoding != null) {
+                contentEncoding = contentEncoding.trim();
+            } else {
+                contentEncoding = HttpHeaders.Values.IDENTITY;
+            }
+            decoder = newContentDecoder(contentEncoding);
+
+            if (decoder == null) {
+                if (message instanceof HttpContent) {
+                    ((HttpContent) message).retain();
+                }
+                out.add(message);
+                return;
+            }
+
+            // Remove content-length header:
+            // the correct value can be set only after all chunks are processed/decoded.
+            // If buffering is not an issue, add HttpObjectAggregator down the chain, it will set the header.
+            // Otherwise, rely on LastHttpContent message.
+            if (headers.contains(HttpHeaders.Names.CONTENT_LENGTH)) {
+                headers.remove(HttpHeaders.Names.CONTENT_LENGTH);
+                headers.set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            }
+
+            // set new content encoding,
+            CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);
+            if (HttpHeaders.Values.IDENTITY.equals(targetContentEncoding)) {
+                // Do NOT set the 'Content-Encoding' header if the target encoding is 'identity'
+                // as per: http://tools.ietf.org/html/rfc2616#section-14.11
+                headers.remove(HttpHeaders.Names.CONTENT_ENCODING);
+            } else {
+                headers.set(HttpHeaders.Names.CONTENT_ENCODING, targetContentEncoding);
+            }
+
+            if (message instanceof HttpContent) {
+                // If message is a full request or response object (headers + data), don't copy data part into out.
+                // Output headers only; data part will be decoded below.
+                // Note: "copy" object must not be an instance of LastHttpContent class,
+                // as this would (erroneously) indicate the end of the HttpMessage to other handlers.
+                HttpMessage copy;
+                if (message instanceof HttpRequest) {
+                    HttpRequest r = (HttpRequest) message; // HttpRequest or FullHttpRequest
+                    copy = new DefaultHttpRequest(r.getProtocolVersion(), r.getMethod(), r.getUri());
+                } else if (message instanceof HttpResponse) {
+                    HttpResponse r = (HttpResponse) message; // HttpResponse or FullHttpResponse
+                    copy = new DefaultHttpResponse(r.getProtocolVersion(), r.getStatus());
+                } else {
+                    throw new CodecException("Object of class " + message.getClass().getName() +
+                                             " is not a HttpRequest or HttpResponse");
+                }
+                copy.headers().set(message.headers());
+                copy.setDecoderResult(message.getDecoderResult());
+                out.add(copy);
+            } else {
+                out.add(message);
+            }
+        }
+
+        if (msg instanceof HttpContent) {
+            final HttpContent c = (HttpContent) msg;
+            if (decoder == null) {
+                out.add(c.retain());
+            } else {
+                decodeContent(c, out);
+            }
+        }
+    }
+
+    private void decodeContent(HttpContent c, List<Object> out) {
+        ByteBuf content = c.content();
+
+        decode(content, out);
+
+        if (c instanceof LastHttpContent) {
+            finishDecode(out);
+
+            LastHttpContent last = (LastHttpContent) c;
+            // Generate an additional chunk if the decoder produced
+            // the last product on closure,
+            HttpHeaders headers = last.trailingHeaders();
+            if (headers.isEmpty()) {
+                out.add(LastHttpContent.EMPTY_LAST_CONTENT);
+            } else {
+                out.add(new ComposedLastHttpContent(headers));
+            }
+        }
+    }
+
+    /**
+     * Returns a new {@link EmbeddedChannel} that decodes the HTTP message
+     * content encoded in the specified <tt>contentEncoding</tt>.
+     *
+     * @param contentEncoding the value of the {@code "Content-Encoding"} header
+     * @return a new {@link EmbeddedChannel} if the specified encoding is supported.
+     *         {@code null} otherwise (alternatively, you can throw an exception
+     *         to block unknown encoding).
+     */
+    protected abstract EmbeddedChannel newContentDecoder(String contentEncoding) throws Exception;
+
+    /**
+     * Returns the expected content encoding of the decoded content.
+     * This getMethod returns {@code "identity"} by default, which is the case for
+     * most decoders.
+     *
+     * @param contentEncoding the value of the {@code "Content-Encoding"} header
+     * @return the expected content encoding of the new content
+     */
+    protected String getTargetContentEncoding(
+            @SuppressWarnings("UnusedParameters") String contentEncoding) throws Exception {
+        return HttpHeaders.Values.IDENTITY;
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        cleanup();
+        super.handlerRemoved(ctx);
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        cleanup();
+        super.channelInactive(ctx);
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        this.ctx = ctx;
+        super.handlerAdded(ctx);
+    }
+
+    private void cleanup() {
+        if (decoder != null) {
+            // Clean-up the previous decoder if not cleaned up correctly.
+            if (decoder.finish()) {
+                for (;;) {
+                    ByteBuf buf = (ByteBuf) decoder.readInbound();
+                    if (buf == null) {
+                        break;
+                    }
+                    // Release the buffer
+                    buf.release();
+                }
+            }
+            decoder = null;
+        }
+    }
+
+    private void decode(ByteBuf in, List<Object> out) {
+        // call retain here as it will call release after its written to the channel
+        decoder.writeInbound(in.retain());
+        fetchDecoderOutput(out);
+    }
+
+    private void finishDecode(List<Object> out) {
+        if (decoder.finish()) {
+            fetchDecoderOutput(out);
+        }
+        decoder = null;
+    }
+
+    private void fetchDecoderOutput(List<Object> out) {
+        for (;;) {
+            ByteBuf buf = (ByteBuf) decoder.readInbound();
+            if (buf == null) {
+                break;
+            }
+            if (!buf.isReadable()) {
+                buf.release();
+                continue;
+            }
+            out.add(new DefaultHttpContent(buf));
+        }
+    }
+}
diff --git a/client/src/main/java/io/netty/handler/ssl/NettySslPackageAccessor.java b/client/src/main/java/io/netty/handler/ssl/NettySslPackageAccessor.java
new file mode 100644
index 000000000..4ebec47b8
--- /dev/null
+++ b/client/src/main/java/io/netty/handler/ssl/NettySslPackageAccessor.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package io.netty.handler.ssl;
+
+import java.util.Set;
+
+public final class NettySslPackageAccessor {
+
+    private NettySslPackageAccessor() {
+    }
+    
+    public static Set<String> jdkSupportedCipherSuites() {
+        return JdkSslContext.SUPPORTED_CIPHERS;
+    }
+}
diff --git a/client/src/main/java/io/netty/util/internal/MacAddressUtil.java b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
index 858368d6d..7c68bf5cc 100644
--- a/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
+++ b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
@@ -53,7 +53,7 @@
         InetAddress bestInetAddr = NetUtil.LOCALHOST4;
 
         // Retrieve the list of available network interfaces.
-        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();
+        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<>();
         try {
             for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {
                 NetworkInterface iface = i.nextElement();
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHandler.java b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
index 99ff74271..0b00cc179 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -40,6 +40,10 @@
  *   client.prepareGet("http://...").execute(ah);
  * </pre></blockquote>
  * It is recommended to create a new instance instead.
+ * 
+ * Do NOT perform any blocking operation in there, typically trying to send another request and call get() on its future.
+ * There's a chance you might end up in a dead lock.
+ * If you really to perform blocking operation, executed it in a different dedicated thread pool.
  *
  * @param <T> Type of object returned by the {@link java.util.concurrent.Future#get}
  */
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 3349b1ce3..31888cdd7 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -1,6 +1,20 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
@@ -70,6 +84,11 @@
      */
     int getPooledConnectionIdleTimeout();
 
+    /**
+     * @return the period in millis to clean the pool of dead and idle connections.
+     */
+    int getConnectionPoolCleanerPeriod();
+
     /**
      * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
      *
@@ -267,7 +286,9 @@
 
     int getSoRcvBuf();
 
-    boolean isUsePooledMemory();
+    ByteBufAllocator getAllocator();
+
+    int getIoThreadsCount();
 
     interface AdditionalChannelInitializer {
 
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 246fdea21..db884e55a 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -17,6 +17,7 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import io.netty.channel.EventLoopGroup;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
 
@@ -32,6 +33,9 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+/**
+ * Default and threadsafe implementation of {@link AsyncHttpClient}.
+ */
 public class DefaultAsyncHttpClient implements AsyncHttpClient {
 
     private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
@@ -247,6 +251,10 @@ public ChannelPool getChannelPool() {
         return channelManager.getChannelPool();
     }
 
+    public EventLoopGroup getEventLoopGroup() {
+        return channelManager.getEventLoopGroup();
+    }
+
     protected BoundRequestBuilder requestBuilder(String method, String url) {
         return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
     }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index cc5c5a89f..abae34762 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -16,6 +16,7 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.handler.ssl.SslContext;
@@ -85,6 +86,7 @@
     // keep-alive
     private final boolean keepAlive;
     private final int pooledConnectionIdleTimeout;
+    private final int connectionPoolCleanerPeriod;
     private final int connectionTtl;
     private final int maxConnections;
     private final int maxConnectionsPerHost;
@@ -118,7 +120,7 @@
     private final Map<ChannelOption<Object>, Object> channelOptions;
     private final EventLoopGroup eventLoopGroup;
     private final boolean useNativeTransport;
-    private final boolean usePooledMemory;
+    private final ByteBufAllocator allocator;
     private final boolean tcpNoDelay;
     private final boolean soReuseAddress;
     private final int soLinger;
@@ -129,6 +131,7 @@
     private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
     private final AdditionalChannelInitializer wsAdditionalChannelInitializer;
     private final ResponseBodyPartFactory responseBodyPartFactory;
+    private final int ioThreadsCount;
 
     private DefaultAsyncHttpClientConfig(//
             // http
@@ -155,6 +158,7 @@ private DefaultAsyncHttpClientConfig(//
             // keep-alive
             boolean keepAlive,//
             int pooledConnectionIdleTimeout,//
+            int connectionPoolCleanerPeriod,//
             int connectionTtl,//
             int maxConnections,//
             int maxConnectionsPerHost,//
@@ -195,12 +199,13 @@ private DefaultAsyncHttpClientConfig(//
             Map<ChannelOption<Object>, Object> channelOptions,//
             EventLoopGroup eventLoopGroup,//
             boolean useNativeTransport,//
-            boolean usePooledMemory,//
+            ByteBufAllocator allocator,//
             Timer nettyTimer,//
             ThreadFactory threadFactory,//
             AdditionalChannelInitializer httpAdditionalChannelInitializer,//
             AdditionalChannelInitializer wsAdditionalChannelInitializer,//
-            ResponseBodyPartFactory responseBodyPartFactory) {
+            ResponseBodyPartFactory responseBodyPartFactory,//
+            int ioThreadsCount) {
 
         // http
         this.followRedirect = followRedirect;
@@ -226,6 +231,7 @@ private DefaultAsyncHttpClientConfig(//
         // keep-alive
         this.keepAlive = keepAlive;
         this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+        this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
         this.connectionTtl = connectionTtl;
         this.maxConnections = maxConnections;
         this.maxConnectionsPerHost = maxConnectionsPerHost;
@@ -266,12 +272,13 @@ private DefaultAsyncHttpClientConfig(//
         this.channelOptions = channelOptions;
         this.eventLoopGroup = eventLoopGroup;
         this.useNativeTransport = useNativeTransport;
-        this.usePooledMemory = usePooledMemory;
+        this.allocator = allocator;
         this.nettyTimer = nettyTimer;
         this.threadFactory = threadFactory;
         this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
         this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
         this.responseBodyPartFactory = responseBodyPartFactory;
+        this.ioThreadsCount = ioThreadsCount;
     }
 
     @Override
@@ -373,6 +380,11 @@ public int getPooledConnectionIdleTimeout() {
         return pooledConnectionIdleTimeout;
     }
 
+    @Override
+    public int getConnectionPoolCleanerPeriod() {
+        return connectionPoolCleanerPeriod;
+    }
+
     @Override
     public int getConnectionTtl() {
         return connectionTtl;
@@ -543,8 +555,8 @@ public boolean isUseNativeTransport() {
     }
 
     @Override
-    public boolean isUsePooledMemory() {
-        return usePooledMemory;
+    public ByteBufAllocator getAllocator() {
+        return allocator;
     }
 
     @Override
@@ -572,6 +584,11 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         return responseBodyPartFactory;
     }
 
+    @Override
+    public int getIoThreadsCount() {
+        return ioThreadsCount;
+    }
+
     /**
      * Builder for an {@link AsyncHttpClient}
      */
@@ -603,6 +620,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         // keep-alive
         private boolean keepAlive = defaultKeepAlive();
         private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+        private int connectionPoolCleanerPeriod = defaultConnectionPoolCleanerPeriod();
         private int connectionTtl = defaultConnectionTtl();
         private int maxConnections = defaultMaxConnections();
         private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
@@ -614,7 +632,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
         private int handshakeTimeout = defaultHandshakeTimeout();
         private String[] enabledProtocols = defaultEnabledProtocols();
-        private String[] enabledCipherSuites;
+        private String[] enabledCipherSuites = defaultEnabledCipherSuites();
         private int sslSessionCacheSize = defaultSslSessionCacheSize();
         private int sslSessionTimeout = defaultSslSessionTimeout();
         private SslContext sslContext;
@@ -641,7 +659,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
         private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
         private boolean useNativeTransport = defaultUseNativeTransport();
-        private boolean usePooledMemory = defaultUsePooledMemory();
+        private ByteBufAllocator allocator;
         private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
         private EventLoopGroup eventLoopGroup;
         private Timer nettyTimer;
@@ -649,6 +667,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private AdditionalChannelInitializer httpAdditionalChannelInitializer;
         private AdditionalChannelInitializer wsAdditionalChannelInitializer;
         private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
+        private int ioThreadsCount = defaultIoThreadsCount();
 
         public Builder() {
         }
@@ -716,12 +735,13 @@ public Builder(AsyncHttpClientConfig config) {
             channelOptions.putAll(config.getChannelOptions());
             eventLoopGroup = config.getEventLoopGroup();
             useNativeTransport = config.isUseNativeTransport();
-            usePooledMemory = config.isUsePooledMemory();
+            allocator = config.getAllocator();
             nettyTimer = config.getNettyTimer();
             threadFactory = config.getThreadFactory();
             httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
             wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
             responseBodyPartFactory = config.getResponseBodyPartFactory();
+            ioThreadsCount = config.getIoThreadsCount();
         }
 
         // http
@@ -791,13 +811,12 @@ public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
         }
 
         public Builder setProxyServer(ProxyServer proxyServer) {
-            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
+            this.proxyServerSelector = uri -> proxyServer;
             return this;
         }
 
         public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServerBuilder.build());
-            return this;
+            return setProxyServer(proxyServerBuilder.build());
         }
 
         public Builder setUseProxySelector(boolean useProxySelector) {
@@ -1027,8 +1046,8 @@ public Builder setUseNativeTransport(boolean useNativeTransport) {
             return this;
         }
 
-        public Builder setUsePooledMemory(boolean usePooledMemory) {
-            this.usePooledMemory = usePooledMemory;
+        public Builder setAllocator(ByteBufAllocator allocator) {
+            this.allocator = allocator;
             return this;
         }
 
@@ -1057,6 +1076,11 @@ public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPa
             return this;
         }
 
+        public Builder setIoThreadsCount(int ioThreadsCount) {
+            this.ioThreadsCount = ioThreadsCount;
+            return this;
+        }
+
         private ProxyServerSelector resolveProxyServerSelector() {
             if (proxyServerSelector != null)
                 return proxyServerSelector;
@@ -1092,6 +1116,7 @@ public DefaultAsyncHttpClientConfig build() {
                     shutdownTimeout, //
                     keepAlive, //
                     pooledConnectionIdleTimeout, //
+                    connectionPoolCleanerPeriod, //
                     connectionTtl, //
                     maxConnections, //
                     maxConnectionsPerHost, //
@@ -1124,12 +1149,13 @@ public DefaultAsyncHttpClientConfig build() {
                     channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
                     eventLoopGroup, //
                     useNativeTransport, //
-                    usePooledMemory, //
+                    allocator, //
                     nettyTimer, //
                     threadFactory, //
                     httpAdditionalChannelInitializer, //
                     wsAdditionalChannelInitializer, //
-                    responseBodyPartFactory);
+                    responseBodyPartFactory, //
+                    ioThreadsCount);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index 9f02e5dc6..1adb25cd5 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -99,4 +99,12 @@ public final Uri getUri() {
      *         if asynchronous provider is unable to provide the local address
      */
     public abstract SocketAddress getLocalAddress();
+
+    /**
+     * Code followed by text.
+     */
+    @Override
+    public String toString() {
+        return getStatusCode() + " " + getStatusText();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ListenableFuture.java b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
index 80d659d4c..46a0a261e 100755
--- a/client/src/main/java/org/asynchttpclient/ListenableFuture.java
+++ b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -67,6 +67,9 @@
      * to the executor} for execution when the {@code Future}'s computation is
      * {@linkplain Future#isDone() complete}.
      * <br>
+     * Executor can be <code>null</code>, in that case executor will be executed
+     * in the thread where completion happens.
+     * <br>
      * There is no guaranteed ordering of execution of listeners, they may get
      * called in the order they were added and they may get called out of order,
      * but any listener added through this method is guaranteed to be called once
@@ -131,7 +134,11 @@ public void touch() {
 
         @Override
         public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
-            exec.execute(listener);
+            if (exec != null) {
+                exec.execute(listener);
+            } else {
+                listener.run();
+            }
             return this;
         }
         
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 5fca54eb5..6c5e5f775 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -60,7 +60,7 @@
 
     public enum AuthScheme {
 
-        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS;
+        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
     }
 
     private Realm(AuthScheme scheme,//
@@ -475,9 +475,9 @@ private void newResponse(MessageDigest md) {
 
         private static String toHexString(byte[] data) {
             StringBuilder buffer = StringUtils.stringBuilder();
-            for (int i = 0; i < data.length; i++) {
-                buffer.append(Integer.toHexString((data[i] & 0xf0) >>> 4));
-                buffer.append(Integer.toHexString(data[i] & 0x0f));
+            for (byte aData : data) {
+                buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
+                buffer.append(Integer.toHexString(aData & 0x0f));
             }
             return buffer.toString();
         }
diff --git a/client/src/main/java/org/asynchttpclient/Request.java b/client/src/main/java/org/asynchttpclient/Request.java
index ae378cdbc..2a821309b 100644
--- a/client/src/main/java/org/asynchttpclient/Request.java
+++ b/client/src/main/java/org/asynchttpclient/Request.java
@@ -36,166 +36,145 @@
 /**
  * The Request class can be used to construct HTTP request:
  * <blockquote><pre>
- *   Request r = new RequestBuilder().setUrl("url")
- *                      .setRealm((new Realm.RealmBuilder()).setPrincipal(user)
- *                      .setPassword(admin)
- *                      .setRealmName("MyRealm")
- *                      .setScheme(Realm.AuthScheme.DIGEST).build());
+ *   Request r = new RequestBuilder()
+ *      .setUrl("url")
+ *      .setRealm(
+ *          new Realm.Builder("principal", "password")
+ *              .setRealmName("MyRealm")
+ *              .setScheme(Realm.AuthScheme.BASIC)
+ *      ).build();
  * </pre></blockquote>
  */
 public interface Request {
 
     /**
-     * Return the request's method name (GET, POST, etc.)
-     *
-     * @return the request's method name (GET, POST, etc.)
+     * @return the request's HTTP method (GET, POST, etc.)
      */
     String getMethod();
 
+    /**
+     * 
+     * @return the uri
+     */
     Uri getUri();
 
+    /**
+     * @return the url (the uri's String form)
+     */
     String getUrl();
 
     /**
-     * Return the InetAddress to override
-     *
-     * @return the InetAddress
+     * @return the InetAddress to be used to bypass uri's hostname resolution
      */
     InetAddress getAddress();
 
+    /**
+     * @return the local address to bind from
+     */
     InetAddress getLocalAddress();
 
     /**
-     * Return the current set of Headers.
-     *
-     * @return a {@link HttpHeaders} contains headers.
+     * @return the HTTP headers
      */
     HttpHeaders getHeaders();
 
     /**
-     * Return cookies.
-     *
-     * @return an unmodifiable Collection of Cookies
+     * @return the HTTP cookies
      */
     List<Cookie> getCookies();
 
     /**
-     * Return the current request's body as a byte array
-     *
-     * @return a byte array of the current request's body.
+     * @return the request's body byte array (only non null if it was set this way)
      */
     byte[] getByteData();
 
     /**
-     * @return the current request's body as a composite of byte arrays
+     * @return the request's body array of byte arrays (only non null if it was set this way)
      */
     List<byte[]> getCompositeByteData();
     
     /**
-     * Return the current request's body as a string
-     *
-     * @return an String representation of the current request's body.
+     * @return the request's body string (only non null if it was set this way)
      */
     String getStringData();
 
     /**
-     * Return the current request's body as a ByteBuffer
-     * 
-     * @return a ByteBuffer
+     * @return the request's body ByteBuffer (only non null if it was set this way)
      */
     ByteBuffer getByteBufferData();
 
     /**
-     * Return the current request's body as an InputStream
-     *
-     * @return an InputStream representation of the current request's body.
+     * @return the request's body InputStream (only non null if it was set this way)
      */
     InputStream getStreamData();
 
     /**
-     * Return the current request's body generator.
-     *
-     * @return A generator for the request body.
+     * @return the request's body BodyGenerator (only non null if it was set this way)
      */
     BodyGenerator getBodyGenerator();
 
     /**
-     * Return the current form parameters.
-     *
-     * @return the form parameters.
+     * @return the request's form parameters
      */
     List<Param> getFormParams();
 
     /**
-     * Return the current {@link Part}
-     *
-     * @return the current {@link Part}
+     * @return the multipart parts
      */
     List<Part> getBodyParts();
 
     /**
-     * Return the virtual host value.
-     *
-     * @return the virtual host value.
+     * @return the virtual host to connect to
      */
     String getVirtualHost();
 
     /**
-     * Return the query params.
-     *
-     * @return the query parameters
+     * @return the query params resolved from the url/uri
      */
     List<Param> getQueryParams();
 
     /**
-     * Return the {@link ProxyServer}
-     *
-     * @return the {@link ProxyServer}
+     * @return the proxy server to be used to perform this request (overrides the one defined in config)
      */
     ProxyServer getProxyServer();
 
     /**
-     * Return the {@link Realm}
-     *
-     * @return the {@link Realm}
+     * @return the realm to be used to perform this request (overrides the one defined in config)
      */
     Realm getRealm();
 
     /**
-     * Return the {@link File} to upload.
-     *
-     * @return the {@link File} to upload.
+     * @return the file to be uploaded
      */
     File getFile();
 
     /**
-     * Return follow redirect
-     *
-     * @return {@link Boolean#TRUE} to follow redirect, {@link Boolean#FALSE} if NOT to follow whatever the client config, null otherwise.
+     * @return if this request is to follow redirects. Non null values means "override config value".
      */
     Boolean getFollowRedirect();
 
     /**
-     * Overrides the config default value
-     * @return the request timeout
+     * @return the request timeout. Non zero values means "override config value".
      */
     int getRequestTimeout();
 
     /**
-     * Return the HTTP Range header value, or
-     *
      * @return the range header value, or 0 is not set.
      */
     long getRangeOffset();
 
     /**
-     * Return the charset value used when decoding the request's body.
-     *
      * @return the charset value used when decoding the request's body.
      */
     Charset getCharset();
 
+    /**
+     * @return the strategy to compute ChannelPool's keys
+     */
     ChannelPoolPartitioning getChannelPoolPartitioning();
 
+    /**
+     * @return the NameResolver to be used to resolve hostnams's IP
+     */
     NameResolver<InetAddress> getNameResolver();
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index 0beba8b25..0af80b936 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -168,11 +168,48 @@ public T setVirtualHost(String virtualHost) {
         return asDerivedType();
     }
 
+    /**
+     * Remove all added headers
+     *
+     * @return {@code this}
+     */
+    public T clearHeaders() {
+        this.headers.clear();
+        return asDerivedType();
+    }
+
+    /**
+     * Set uni-value header for the request
+     *
+     * @param name header name
+     * @param value header value to set
+     * @return {@code this}
+     */
     public T setHeader(CharSequence name, String value) {
         this.headers.set(name, value);
         return asDerivedType();
     }
 
+    /**
+     * Set multi-values header for the request
+     *
+     * @param name header name
+     * @param values {@code Iterable} with multiple header values to set
+     * @return {@code this}
+     */
+    public T setHeader(CharSequence name, Iterable<String> values) {
+        this.headers.set(name, values);
+        return asDerivedType();
+    }
+
+    /**
+     * Add a header value for the request. If a header with {@code name} was setup for this request already -
+     * call will add one more header value and convert it to multi-value header
+     *
+     * @param name header name
+     * @param value header value to add
+     * @return {@code this}
+     */
     public T addHeader(CharSequence name, String value) {
         if (value == null) {
             LOGGER.warn("Value was null, set to \"\"");
@@ -183,6 +220,19 @@ public T addHeader(CharSequence name, String value) {
         return asDerivedType();
     }
 
+    /**
+     * Add header values for the request. If a header with {@code name} was setup for this request already -
+     * call will add more header values and convert it to multi-value header
+     *
+     * @param name header name
+     * @param values {@code Iterable} with multiple header values to add
+     * @return {@code}
+     */
+    public T addHeader(CharSequence name, Iterable<String> values) {
+        this.headers.add(name, values);
+        return asDerivedType();
+    }
+
     public T setHeaders(HttpHeaders headers) {
         if (headers == null)
             this.headers.clear();
@@ -191,13 +241,32 @@ public T setHeaders(HttpHeaders headers) {
         return asDerivedType();
     }
 
-    public T setHeaders(Map<String, Collection<String>> headers) {
-        this.headers.clear();
+    /**
+     * Set request headers using a map {@code headers} of pair (Header name, Header values)
+     * This method could be used to setup multi-valued headers
+     *
+     * @param headers map of header names as the map keys and header values {@link Iterable} as the map values
+     * @return {@code this}
+     */
+    public T setHeaders(Map<String, ? extends Iterable<String>> headers) {
+        clearHeaders();
         if (headers != null) {
-            for (Map.Entry<String, Collection<String>> entry : headers.entrySet()) {
-                String headerName = entry.getKey();
-                this.headers.add(headerName, entry.getValue());
-            }
+            headers.forEach((name, values) -> this.headers.add(name, values));
+        }
+        return asDerivedType();
+    }
+
+    /**
+     * Set single-value request headers using a map {@code headers} of pairs (Header name, Header value).
+     * To set headers with multiple values use {@link #setHeaders(Map)}
+     *
+     * @param headers map of header names as the map keys and header values as the map values
+     * @return {@code this}
+     */
+    public T setSingleHeaders(Map<String, String> headers) {
+        clearHeaders();
+        if (headers != null) {
+            headers.forEach((name, value) -> this.headers.add(name, value));
         }
         return asDerivedType();
     }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index 1d2c06fee..482ed0d45 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -12,6 +12,11 @@
  */
 package org.asynchttpclient.config;
 
+import io.netty.handler.ssl.NettySslPackageAccessor;
+
+import java.util.Arrays;
+import java.util.Set;
+
 public final class AsyncHttpClientConfigDefaults {
 
     private AsyncHttpClientConfigDefaults() {
@@ -39,6 +44,10 @@ public static int defaultPooledConnectionIdleTimeout() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "pooledConnectionIdleTimeout");
     }
 
+    public static int defaultConnectionPoolCleanerPeriod() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionPoolCleanerPeriod");
+    }
+
     public static int defaultReadTimeout() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "readTimeout");
     }
@@ -70,6 +79,12 @@ public static String defaultUserAgent() {
     public static String[] defaultEnabledProtocols() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledProtocols");
     }
+    
+    public static String[] defaultEnabledCipherSuites() {
+        String[] defaultEnabledCipherSuites = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledCipherSuites");
+        Set<String> supportedCipherSuites = NettySslPackageAccessor.jdkSupportedCipherSuites();
+        return Arrays.stream(defaultEnabledCipherSuites).filter(supportedCipherSuites::contains).toArray(String[]::new);
+    }
 
     public static boolean defaultUseProxySelector() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxySelector");
@@ -183,7 +198,7 @@ public static boolean defaultUseNativeTransport() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
     }
 
-    public static boolean defaultUsePooledMemory() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "usePooledMemory");
+    public static int defaultIoThreadsCount() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "ioThreadsCount");
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index b2f3c5ea1..314986a19 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -33,7 +33,7 @@ public static void reloadProperties() {
         public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
         public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
 
-        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<String, String>();
+        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
         private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES);
         private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES);
 
@@ -65,9 +65,9 @@ public String getString(String key) {
             return propsCache.computeIfAbsent(key, k -> {
                 String value = System.getProperty(k);
                 if (value == null)
-                    value = (String) customProperties.getProperty(k);
+                    value = customProperties.getProperty(k);
                 if (value == null)
-                    value = (String) defaultProperties.getProperty(k);
+                    value = defaultProperties.getProperty(k);
                 return value;
             });
         }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
index 74896bca5..01bc6caf1 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -63,8 +63,7 @@ public static String encode(Collection<Cookie> cookies) {
         } else {
             Cookie[] cookiesSorted = cookies.toArray(new Cookie[cookies.size()]);
             Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);
-            for (int i = 0; i < cookiesSorted.length; i++) {
-                Cookie cookie = cookiesSorted[i];
+            for (Cookie cookie : cookiesSorted) {
                 if (cookie != null) {
                     add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
                 }
diff --git a/client/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java b/client/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java
deleted file mode 100644
index 36837187f..000000000
--- a/client/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-/*
- * Copyright (C) 2007 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.asynchttpclient.future;
-
-import java.util.concurrent.Executor;
-
-import org.asynchttpclient.ListenableFuture;
-
-/**
- * An abstract base implementation of the listener support provided by {@link ListenableFuture}. This class uses an {@link ExecutionList} to guarantee that all registered listeners
- * will be executed. Listener/Executor pairs are stored in the execution list and executed in the order in which they were added, but because of thread scheduling issues there is
- * no guarantee that the JVM will execute them in order. In addition, listeners added after the task is complete will be executed immediately, even if some previously added
- * listeners have not yet been executed.
- *
- * @author Sven Mawson
- * @since 1
- */
-public abstract class AbstractListenableFuture<V> implements ListenableFuture<V> {
-
-    private volatile boolean hasRun;
-    private volatile boolean executionListInitialized;
-    private volatile ExecutionList executionList;
-
-    private ExecutionList executionList() {
-        ExecutionList localExecutionList = executionList;
-        if (localExecutionList == null) {
-            synchronized (this) {
-                localExecutionList = executionList;
-                if (localExecutionList == null) {
-                    localExecutionList = new ExecutionList();
-                    executionList = localExecutionList;
-                    executionListInitialized = true;
-                }
-            }
-        }
-        return localExecutionList;
-    }
-
-    @Override
-    public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
-        executionList().add(listener, exec);
-        if (hasRun) {
-            runListeners();
-        }
-        return this;
-    }
-
-    /**
-     * Execute the execution list.
-     */
-    protected void runListeners() {
-        hasRun = true;
-        if (executionListInitialized) {
-            executionList().execute();
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/future/ExecutionList.java b/client/src/main/java/org/asynchttpclient/future/ExecutionList.java
deleted file mode 100644
index a844cace4..000000000
--- a/client/src/main/java/org/asynchttpclient/future/ExecutionList.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2007 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.asynchttpclient.future;
-
-import static org.asynchttpclient.util.Assertions.*;
-
-import java.util.concurrent.Executor;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * A support class for {@code ListenableFuture} implementations to manage their listeners. An instance contains a list of listeners, each with an associated {@code Executor}, and
- * guarantees that every {@code Runnable} that is {@linkplain #add added} will be executed after {@link #execute()} is called. Any {@code Runnable} added after the call to
- * {@code execute} is still guaranteed to execute. There is no guarantee, however, that listeners will be executed in the order that they are added.
- *
- * <p>
- * Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an
- * exception thrown by a directExecutor direct execution) will be caught and logged.
- *
- * @author Nishant Thakkar
- * @author Sven Mawson
- * @since 1.0
- */
-public final class ExecutionList {
-    // Logger to log exceptions caught when running runnables.
-    static final Logger log = Logger.getLogger(ExecutionList.class.getName());
-
-    /**
-     * The runnable, executor pairs to execute. This acts as a stack threaded through the {@link RunnableExecutorPair#next} field.
-     */
-    private RunnableExecutorPair runnables;
-    private boolean executed;
-
-    /** Creates a new, empty {@link ExecutionList}. */
-    public ExecutionList() {
-    }
-
-    // Adds the {@code Runnable} and accompanying {@code Executor} to the list of listeners to execute. If execution has already begun, the listener is executed immediately.
-    // When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See the discussion in the {@link org.asynchttpclient.ListenableFuture#addListener
-    // ListenableFuture.addListener} documentation.
-    public void add(Runnable runnable, Executor executor) {
-        // Fail fast on a null. We throw NPE here because the contract of Executor states that it
-        // throws NPE on null listener, so we propagate that contract up into the add method as well.
-        assertNotNull(runnable, "runnable");
-        assertNotNull(executor, "executor");
-
-        // Lock while we check state. We must maintain the lock while adding the new pair so that
-        // another thread can't run the list out from under us. We only add to the list if we have not
-        // yet started execution.
-        synchronized (this) {
-            if (!executed) {
-                runnables = new RunnableExecutorPair(runnable, executor, runnables);
-                return;
-            }
-        }
-        // Execute the runnable immediately. Because of scheduling this may end up getting called before
-        // some of the previously added runnables, but we're OK with that. If we want to change the
-        // contract to guarantee ordering among runnables we'd have to modify the logic here to allow
-        // it.
-        executeListener(runnable, executor);
-    }
-
-    /**
-     * Runs this execution list, executing all existing pairs in the order they were added. However, note that listeners added after this point may be executed before those
-     * previously added, and note that the execution order of all listeners is ultimately chosen by the implementations of the supplied executors.
-     *
-     * <p>
-     * This method is idempotent. Calling it several times in parallel is semantically equivalent to calling it exactly once.
-     *
-     * @since 10.0 (present in 1.0 as {@code run})
-     */
-    public void execute() {
-        // Lock while we update our state so the add method above will finish adding any listeners
-        // before we start to run them.
-        RunnableExecutorPair list;
-        synchronized (this) {
-            if (executed) {
-                return;
-            }
-            executed = true;
-            list = runnables;
-            runnables = null; // allow GC to free listeners even if this stays around for a while.
-        }
-        // If we succeeded then list holds all the runnables we to execute. The pairs in the stack are
-        // in the opposite order from how they were added so we need to reverse the list to fulfill our
-        // contract.
-        // This is somewhat annoying, but turns out to be very fast in practice. Alternatively, we
-        // could drop the contract on the method that enforces this queue like behavior since depending
-        // on it is likely to be a bug anyway.
-
-        // N.B. All writes to the list and the next pointers must have happened before the above
-        // synchronized block, so we can iterate the list without the lock held here.
-        RunnableExecutorPair reversedList = null;
-        while (list != null) {
-            RunnableExecutorPair tmp = list;
-            list = list.next;
-            tmp.next = reversedList;
-            reversedList = tmp;
-        }
-        while (reversedList != null) {
-            executeListener(reversedList.runnable, reversedList.executor);
-            reversedList = reversedList.next;
-        }
-    }
-
-    /**
-     * Submits the given runnable to the given {@link Executor} catching and logging all {@linkplain RuntimeException runtime exceptions} thrown by the executor.
-     */
-    private static void executeListener(Runnable runnable, Executor executor) {
-        try {
-            executor.execute(runnable);
-        } catch (RuntimeException e) {
-            // Log it and keep going, bad runnable and/or executor. Don't punish the other runnables if
-            // we're given a bad one. We only catch RuntimeException because we want Errors to propagate
-            // up.
-            log.log(Level.SEVERE, "RuntimeException while executing runnable " + runnable + " with executor " + executor, e);
-        }
-    }
-
-    private static final class RunnableExecutorPair {
-        final Runnable runnable;
-        final Executor executor;
-        RunnableExecutorPair next;
-
-        RunnableExecutorPair(Runnable runnable, Executor executor, RunnableExecutorPair next) {
-            this.runnable = runnable;
-            this.executor = executor;
-            this.next = next;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index f8020d260..49450e12f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,7 +12,7 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.util.ByteBufUtils.byteBuf2Bytes;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index 02159fb85..61a1aea83 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -17,7 +17,7 @@
 import java.nio.ByteBuffer;
 
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.util.ByteBufUtils;
+import org.asynchttpclient.netty.util.ByteBufUtils;
 
 /**
  * A callback class used when an HTTP response body is received.
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 1b6889c5d..7dc74dd05 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -14,27 +14,23 @@
 package org.asynchttpclient.netty;
 
 import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import static org.asynchttpclient.util.MiscUtils.getCause;
 import static io.netty.util.internal.PlatformDependent.*;
 import io.netty.channel.Channel;
 
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
-import org.asynchttpclient.future.AbstractListenableFuture;
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequest;
@@ -49,40 +45,42 @@
  * 
  * @param <V> the result type
  */
-public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+public final class NettyResponseFuture<V> implements ListenableFuture<V> {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
 
     private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> REDIRECT_COUNT_UPDATER = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "redirectCount");
     private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> CURRENT_RETRY_UPDATER = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "currentRetry");
-    @SuppressWarnings("rawtypes")
-    // FIXME see https://github.com/netty/netty/pull/4669
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> CONTENT_UPDATER = newAtomicReferenceFieldUpdater(NettyResponseFuture.class, "content");
-    @SuppressWarnings("rawtypes")
-    // FIXME see https://github.com/netty/netty/pull/4669
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, ExecutionException> EX_EX_UPDATER = newAtomicReferenceFieldUpdater(NettyResponseFuture.class, "exEx");
 
     private final long start = unpreciseMillisTime();
     private final ChannelPoolPartitioning connectionPoolPartitioning;
     private final ProxyServer proxyServer;
     private final int maxRetry;
-    private final CountDownLatch latch = new CountDownLatch(1);
+    private final CompletableFuture<V> future = new CompletableFuture<>();
 
     // state mutated from outside the event loop
     // TODO check if they are indeed mutated outside the event loop
-    private final AtomicBoolean isDone = new AtomicBoolean(false);
-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
-    private final AtomicBoolean inAuth = new AtomicBoolean(false);
-    private final AtomicBoolean inProxyAuth = new AtomicBoolean(false);
-    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
-    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
+    private volatile int isDone = 0;
+    private volatile int isCancelled = 0;
+    private volatile int inAuth = 0;
+    private volatile int inProxyAuth = 0;
+    private volatile int statusReceived = 0;
+    @SuppressWarnings("unused")
+    private volatile int contentProcessed = 0;
+    @SuppressWarnings("unused")
+    private volatile int onThrowableCalled = 0;
+
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> isDoneField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "isDone");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> isCancelledField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "isCancelled");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> inAuthField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "inAuth");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> inProxyAuthField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "inProxyAuth");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> statusReceivedField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "statusReceived");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> contentProcessedField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "contentProcessed");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> onThrowableCalledField = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "onThrowableCalled");
 
     // volatile where we need CAS ops
     private volatile int redirectCount = 0;
     private volatile int currentRetry = 0;
-    private volatile V content;
-    private volatile ExecutionException exEx;
 
     // volatile where we don't need CAS ops
     private volatile long touch = unpreciseMillisTime();
@@ -96,7 +94,7 @@
     private Request currentRequest;
     private NettyRequest nettyRequest;
     private AsyncHandler<V> asyncHandler;
-    private boolean streamWasAlreadyConsumed;
+    private boolean streamAlreadyConsumed;
     private boolean reuseChannel;
     private boolean headersAlreadyWrittenOnContinue;
     private boolean dontWriteBodyBecauseExpectContinue;
@@ -124,19 +122,19 @@ public NettyResponseFuture(Request originalRequest,//
 
     @Override
     public boolean isDone() {
-        return isDone.get() || isCancelled();
+        return isDone != 0 || isCancelled();
     }
 
     @Override
     public boolean isCancelled() {
-        return isCancelled.get();
+        return isCancelled != 0;
     }
 
     @Override
     public boolean cancel(boolean force) {
         cancelTimeouts();
 
-        if (isCancelled.getAndSet(true))
+        if (isCancelledField.getAndSet(this, 1) != 0)
             return false;
 
         // cancel could happen before channel was attached
@@ -145,64 +143,58 @@ public boolean cancel(boolean force) {
             Channels.silentlyCloseChannel(channel);
         }
 
-        if (!onThrowableCalled.getAndSet(true)) {
+        if (onThrowableCalledField.getAndSet(this, 1) == 0) {
             try {
                 asyncHandler.onThrowable(new CancellationException());
             } catch (Throwable t) {
                 LOGGER.warn("cancel", t);
             }
         }
-        latch.countDown();
-        runListeners();
+
+        future.cancel(false);
         return true;
     }
 
     @Override
     public V get() throws InterruptedException, ExecutionException {
-        latch.await();
-        return getContent();
+        return future.get();
     }
 
     @Override
     public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
-        if (!latch.await(l, tu))
-            throw new TimeoutException();
-        return getContent();
+        return future.get(l, tu);
     }
 
     private V getContent() throws ExecutionException {
+        if (future.isDone()) {
+            try {
+                return future.get();
+            } catch (InterruptedException e) {
+                throw new RuntimeException("unreachable", e);
+            }
+        }
 
-        if (isCancelled())
-            throw new CancellationException();
-
-        ExecutionException e = EX_EX_UPDATER.get(this);
-        if (e != null)
-            throw e;
-
-        @SuppressWarnings("unchecked")
-        V update = (V) CONTENT_UPDATER.get(this);
         // No more retry
         CURRENT_RETRY_UPDATER.set(this, maxRetry);
-        if (!contentProcessed.getAndSet(true)) {
+        if (contentProcessedField.getAndSet(this, 1) == 0) {
             try {
-                update = asyncHandler.onCompleted();
+                future.complete(asyncHandler.onCompleted());
             } catch (Throwable ex) {
-                if (!onThrowableCalled.getAndSet(true)) {
+                if (onThrowableCalledField.getAndSet(this, 1) == 0) {
                     try {
                         try {
                             asyncHandler.onThrowable(ex);
                         } catch (Throwable t) {
                             LOGGER.debug("asyncHandler.onThrowable", t);
                         }
-                        throw new RuntimeException(ex);
                     } finally {
                         cancelTimeouts();
                     }
                 }
+                future.completeExceptionally(ex);
             }
-            CONTENT_UPDATER.compareAndSet(this, null, update);
         }
-        return update;
+        return future.getNow(null);
     }
 
     // org.asynchttpclient.ListenableFuture
@@ -211,7 +203,7 @@ private boolean terminateAndExit() {
         cancelTimeouts();
         this.channel = null;
         this.reuseChannel = false;
-        return isDone.getAndSet(true) || isCancelled.get();
+        return isDoneField.getAndSet(this, 1) != 0 || isCancelled != 0;
     }
 
     public final void done() {
@@ -221,35 +213,30 @@ public final void done() {
 
         try {
             getContent();
+        } catch (ExecutionException ignored) {
 
-        } catch (ExecutionException t) {
-            return;
         } catch (RuntimeException t) {
-            EX_EX_UPDATER.compareAndSet(this, null, new ExecutionException(getCause(t)));
-
-        } finally {
-            latch.countDown();
+            future.completeExceptionally(t);
+        } catch (Throwable t) {
+            future.completeExceptionally(t);
+            throw t;
         }
-
-        runListeners();
     }
 
     public final void abort(final Throwable t) {
 
-        EX_EX_UPDATER.compareAndSet(this, null, new ExecutionException(t));
+        future.completeExceptionally(t);
 
         if (terminateAndExit())
             return;
 
-        if (onThrowableCalled.compareAndSet(false, true)) {
+        if (onThrowableCalledField.compareAndSet(this, 0, 1)) {
             try {
                 asyncHandler.onThrowable(t);
             } catch (Throwable te) {
                 LOGGER.debug("asyncHandler.onThrowable", te);
             }
         }
-        latch.countDown();
-        runListeners();
     }
 
     @Override
@@ -258,27 +245,14 @@ public void touch() {
     }
 
     @Override
-    public CompletableFuture<V> toCompletableFuture() {
-        CompletableFuture<V> completable = new CompletableFuture<>();
-        addListener(new Runnable() {
-            @Override
-            @SuppressWarnings("unchecked")
-            public void run() {
-                ExecutionException e = EX_EX_UPDATER.get(NettyResponseFuture.this);
-                if (e != null)
-                    completable.completeExceptionally(e.getCause());
-                else
-                    completable.complete((V) CONTENT_UPDATER.get(NettyResponseFuture.this));
-            }
-
-        }, new Executor() {
-            @Override
-            public void execute(Runnable command) {
-                command.run();
-            }
-        });
+    public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
+        future.whenCompleteAsync((r, v) -> listener.run(), exec);
+        return this;
+    }
 
-        return completable;
+    @Override
+    public CompletableFuture<V> toCompletableFuture() {
+        return future;
     }
 
     // INTERNAL
@@ -346,12 +320,28 @@ public TimeoutsHolder getTimeoutsHolder() {
         return timeoutsHolder;
     }
 
-    public AtomicBoolean getInAuth() {
-        return inAuth;
+    public boolean isInAuth() {
+        return inAuth != 0;
+    }
+
+    public void setInAuth(boolean inAuth) {
+        this.inAuth = inAuth ? 1 : 0;
+    }
+
+    public boolean isAndSetInAuth(boolean set) {
+        return inAuthField.getAndSet(this, set ? 1 : 0) != 0;
+    }
+
+    public boolean isInProxyAuth() {
+        return inProxyAuth != 0;
+    }
+
+    public void setInProxyAuth(boolean inProxyAuth) {
+        this.inProxyAuth = inProxyAuth ? 1 : 0;
     }
 
-    public AtomicBoolean getInProxyAuth() {
-        return inProxyAuth;
+    public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
+        return inProxyAuthField.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
     }
 
     public ChannelState getChannelState() {
@@ -362,16 +352,16 @@ public void setChannelState(ChannelState channelState) {
         this.channelState = channelState;
     }
 
-    public boolean getAndSetStatusReceived(boolean sr) {
-        return statusReceived.getAndSet(sr);
+    public boolean isAndSetStatusReceived(boolean sr) {
+        return statusReceivedField.getAndSet(this, sr ? 1 : 0) != 0;
     }
 
-    public boolean isStreamWasAlreadyConsumed() {
-        return streamWasAlreadyConsumed;
+    public boolean isStreamConsumed() {
+        return streamAlreadyConsumed;
     }
 
-    public void setStreamWasAlreadyConsumed(boolean streamWasAlreadyConsumed) {
-        this.streamWasAlreadyConsumed = streamWasAlreadyConsumed;
+    public void setStreamConsumed(boolean streamConsumed) {
+        this.streamAlreadyConsumed = streamConsumed;
     }
 
     public long getLastTouch() {
@@ -421,7 +411,7 @@ public Channel channel() {
         return channel;
     }
 
-    public boolean reuseChannel() {
+    public boolean isReuseChannel() {
         return reuseChannel;
     }
 
@@ -443,8 +433,8 @@ public void setCurrentRequest(Request currentRequest) {
      * 
      * @return true if that {@link Future} cannot be recovered.
      */
-    public boolean canBeReplayed() {
-        return !isDone() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && !inAuth.get() && !inProxyAuth.get();
+    public boolean isReplayPossible() {
+        return !isDone() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && inAuth == 0 && inProxyAuth == 0;
     }
 
     public long getStart() {
@@ -479,10 +469,9 @@ public String toString() {
                 ",\n\tisCancelled=" + isCancelled + //
                 ",\n\tasyncHandler=" + asyncHandler + //
                 ",\n\tnettyRequest=" + nettyRequest + //
-                ",\n\tcontent=" + content + //
+                ",\n\tfuture=" + future + //
                 ",\n\turi=" + getUri() + //
                 ",\n\tkeepAlive=" + keepAlive + //
-                ",\n\texEx=" + exEx + //
                 ",\n\tredirectCount=" + redirectCount + //
                 ",\n\ttimeoutsHolder=" + timeoutsHolder + //
                 ",\n\tinAuth=" + inAuth + //
diff --git a/client/src/main/java/org/asynchttpclient/netty/Callback.java b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
similarity index 88%
rename from client/src/main/java/org/asynchttpclient/netty/Callback.java
rename to client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
index 2e4393f85..0f1df7e51 100644
--- a/client/src/main/java/org/asynchttpclient/netty/Callback.java
+++ b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
@@ -12,12 +12,11 @@
  */
 package org.asynchttpclient.netty;
 
-
-public abstract class Callback {
+public abstract class OnLastHttpContentCallback {
 
     protected final NettyResponseFuture<?> future;
 
-    public Callback(NettyResponseFuture<?> future) {
+    public OnLastHttpContentCallback(NettyResponseFuture<?> future) {
         this.future = future;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 277a87150..bdd559ef4 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -16,8 +16,7 @@
 import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ChannelFactory;
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
@@ -60,7 +59,7 @@
 import org.asynchttpclient.exception.TooManyConnectionsException;
 import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
 import org.asynchttpclient.netty.handler.HttpHandler;
@@ -99,12 +98,12 @@
     private final IOException tooManyConnectionsPerHost;
 
     private final ChannelPool channelPool;
+    private final ChannelGroup openChannels;
+    private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();
     private final boolean maxTotalConnectionsEnabled;
     private final Semaphore freeChannels;
-    private final ChannelGroup openChannels;
     private final boolean maxConnectionsPerHostEnabled;
     private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
-    private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();
 
     private AsyncHttpClientHandler wsHandler;
 
@@ -167,11 +166,11 @@ public boolean remove(Object o) {
         ChannelFactory<? extends Channel> channelFactory;
         if (allowReleaseEventLoopGroup) {
             if (config.isUseNativeTransport()) {
-                eventLoopGroup = newEpollEventLoopGroup(threadFactory);
+                eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);
                 channelFactory = getEpollSocketChannelFactory();
 
             } else {
-                eventLoopGroup = new NioEventLoopGroup(0, threadFactory);
+                eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), threadFactory);
                 channelFactory = NioSocketChannelFactory.INSTANCE;
             }
 
@@ -197,8 +196,7 @@ public boolean remove(Object o) {
     private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
         @SuppressWarnings("deprecation")
         Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory).group(eventLoopGroup)//
-                // default to PooledByteBufAllocator
-                .option(ChannelOption.ALLOCATOR, config.isUsePooledMemory() ? PooledByteBufAllocator.DEFAULT : UnpooledByteBufAllocator.DEFAULT)//
+                .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)//
                 .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())//
                 .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//
                 .option(ChannelOption.AUTO_CLOSE, false);
@@ -226,10 +224,10 @@ private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory,
         return bootstrap;
     }
 
-    private EventLoopGroup newEpollEventLoopGroup(ThreadFactory threadFactory) {
+    private EventLoopGroup newEpollEventLoopGroup(int ioThreadsCount, ThreadFactory threadFactory) {
         try {
             Class<?> epollEventLoopGroupClass = Class.forName("io.netty.channel.epoll.EpollEventLoopGroup");
-            return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(0, threadFactory);
+            return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(ioThreadsCount, threadFactory);
         } catch (Exception e) {
             throw new IllegalArgumentException(e);
         }
@@ -342,7 +340,7 @@ private boolean tryAcquirePerHost(Object partitionKey) {
         return !maxConnectionsPerHostEnabled || getFreeConnectionsForHost(partitionKey).tryAcquire();
     }
 
-    public void preemptChannel(Object partitionKey) throws IOException {
+    public void acquireChannelLock(Object partitionKey) throws IOException {
         if (!channelPool.isOpen())
             throw PoolAlreadyClosedException.INSTANCE;
         if (!tryAcquireGlobal())
@@ -369,14 +367,13 @@ public void close() {
     }
 
     public void closeChannel(Channel channel) {
-
         LOGGER.debug("Closing Channel {} ", channel);
         Channels.setDiscard(channel);
         removeAll(channel);
         Channels.silentlyCloseChannel(channel);
     }
 
-    public void abortChannelPreemption(Object partitionKey) {
+    public void releaseChannelLock(Object partitionKey) {
         if (maxTotalConnectionsEnabled)
             freeChannels.release();
         if (maxConnectionsPerHostEnabled)
@@ -467,9 +464,9 @@ public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
         pipeline.remove(HTTP_CLIENT_CODEC);
     }
 
-    public final Callback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+    public final OnLastHttpContentCallback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
 
-        return new Callback(future) {
+        return new OnLastHttpContentCallback(future) {
             public void call() {
                 tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
             }
@@ -487,4 +484,8 @@ public void drainChannelAndOffer(final Channel channel, final NettyResponseFutur
     public ChannelPool getChannelPool() {
         return channelPool;
     }
+
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 5be13db17..2c76a78d9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -13,6 +13,8 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelId;
 import io.netty.channel.DefaultChannelId;
@@ -29,6 +31,7 @@
 
     private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
     private static final AttributeKey<ChannelId> CHANNEL_ID_ATTRIBUTE = AttributeKey.valueOf("channelId");
+    private static final AttributeKey<AtomicBoolean> INACTIVE_TOKEN_ATTRIBUTE = AttributeKey.valueOf("inactiveToken");
 
     public static Object getAttribute(Channel channel) {
         Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
@@ -46,6 +49,14 @@ public static void setDiscard(Channel channel) {
     public static boolean isChannelValid(Channel channel) {
         return channel != null && channel.isActive();
     }
+    
+    public static void setInactiveToken(Channel channel) {
+        channel.attr(INACTIVE_TOKEN_ATTRIBUTE).set(new AtomicBoolean(true));
+    }
+    
+    public static boolean getInactiveToken(Channel channel) {
+        return channel != null && channel.attr(INACTIVE_TOKEN_ATTRIBUTE).get().getAndSet(false);
+    }
 
     public static ChannelId getChannelId(Channel channel) {
         Attribute<ChannelId> attr = channel.attr(CHANNEL_ID_ATTRIBUTE);
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index a6b6acee6..878db3a29 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -54,7 +54,8 @@
     public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
         this(config.getPooledConnectionIdleTimeout(),//
                 config.getConnectionTtl(),//
-                hashedWheelTimer);
+                hashedWheelTimer,//
+                config.getConnectionPoolCleanerPeriod());
     }
 
     private ChannelId channelId(Channel channel) {
@@ -63,18 +64,21 @@ private ChannelId channelId(Channel channel) {
 
     public DefaultChannelPool(int maxIdleTime,//
             int connectionTtl,//
-            Timer nettyTimer) {
+            Timer nettyTimer,//
+            int cleanerPeriod) {
         this(maxIdleTime,//
                 connectionTtl,//
                 PoolLeaseStrategy.LIFO,//
-                nettyTimer);
+                nettyTimer,//
+                cleanerPeriod);
     }
 
     public DefaultChannelPool(int maxIdleTime,//
             int connectionTtl,//
             PoolLeaseStrategy poolLeaseStrategy,//
-            Timer nettyTimer) {
-        this.maxIdleTime = (int) maxIdleTime;
+            Timer nettyTimer,//
+            int cleanerPeriod) {
+        this.maxIdleTime = maxIdleTime;
         this.connectionTtl = connectionTtl;
         connectionTtlEnabled = connectionTtl > 0;
         channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
@@ -82,7 +86,7 @@ public DefaultChannelPool(int maxIdleTime,//
         maxIdleTimeEnabled = maxIdleTime > 0;
         this.poolLeaseStrategy = poolLeaseStrategy;
 
-        cleanerPeriod = Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Long.MAX_VALUE);
+        this.cleanerPeriod = Math.min(cleanerPeriod, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));
 
         if (connectionTtlEnabled || maxIdleTimeEnabled)
             scheduleNewIdleChannelDetector(new IdleChannelDetector());
@@ -153,7 +157,7 @@ private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
                 if (isIdleTimeoutExpired(idleChannel, now) || isRemotelyClosed(idleChannel.channel) || isTtlExpired(idleChannel.channel, now)) {
                     LOGGER.debug("Adding Candidate expired Channel {}", idleChannel.channel);
                     if (idleTimeoutChannels == null)
-                        idleTimeoutChannels = new ArrayList<>();
+                        idleTimeoutChannels = new ArrayList<>(1);
                     idleTimeoutChannels.add(idleChannel);
                 }
             }
@@ -161,9 +165,9 @@ private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
             return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
         }
 
-        private final List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+        private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
 
-            // lazy create, only if we have a non-closeable channel
+            // lazy create, only if we hit a non-closeable channel
             List<IdleChannel> closedChannels = null;
             for (int i = 0; i < candidates.size(); i++) {
                 // We call takeOwnership here to avoid closing a channel that has just been taken out
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 073132d43..066dbf35a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -60,7 +60,7 @@ public NettyConnectListener(NettyResponseFuture<T> future,//
 
     public void abortChannelPreemption(Channel channel) {
         if (channelPreempted) {
-            channelManager.abortChannelPreemption(partitionKey);
+            channelManager.releaseChannelLock(partitionKey);
         }
 
         Channels.silentlyCloseChannel(channel);
@@ -95,6 +95,8 @@ private void writeRequest(Channel channel) {
 
     public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
 
+        Channels.setInactiveToken(channel);
+
         TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();
 
         if (futureIsAlreadyCancelled(channel)) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index ca00f7a4e..e1195f4db 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -29,7 +29,7 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.exception.ChannelClosedException;
-import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.DiscardEvent;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -67,23 +67,17 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
         Object attribute = Channels.getAttribute(channel);
 
         try {
-            if (attribute instanceof Callback) {
-                Callback ac = (Callback) attribute;
-                if (msg instanceof LastHttpContent) {
-                    ac.call();
-                } else if (!(msg instanceof HttpContent)) {
-                    logger.info("Received unexpected message while expecting a chunk: " + msg);
-                    ac.call();
-                    Channels.setDiscard(channel);
-                }
+            if (attribute instanceof OnLastHttpContentCallback && msg instanceof LastHttpContent) {
+                ((OnLastHttpContentCallback) attribute).call();
 
             } else if (attribute instanceof NettyResponseFuture) {
                 NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.touch();
                 handleRead(channel, future, msg);
 
             } else if (attribute instanceof StreamedResponsePublisher) {
-
                 StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
+                publisher.future().touch();
 
                 if (msg instanceof HttpContent) {
                     ByteBuf content = ((HttpContent) msg).content();
@@ -126,12 +120,6 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         Channel channel = ctx.channel();
         channelManager.removeAll(channel);
 
-        try {
-            super.channelInactive(ctx);
-        } catch (Exception ex) {
-            logger.trace("super.channelClosed", ex);
-        }
-
         Object attribute = Channels.getAttribute(channel);
         logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
         if (attribute instanceof StreamedResponsePublisher) {
@@ -139,13 +127,13 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             // logic can kick-in
             attribute = ((StreamedResponsePublisher) attribute).future();
         }
-        if (attribute instanceof Callback) {
-            Callback callback = (Callback) attribute;
+        if (attribute instanceof OnLastHttpContentCallback) {
+            OnLastHttpContentCallback callback = (OnLastHttpContentCallback) attribute;
             Channels.setAttribute(channel, callback.future());
             callback.call();
 
         } else if (attribute instanceof NettyResponseFuture<?>) {
-            NettyResponseFuture<?> future = NettyResponseFuture.class.cast(attribute);
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
             future.touch();
 
             if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
@@ -198,8 +186,8 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
                     future.pendingException = cause;
                     return;
                 }
-            } else if (attribute instanceof Callback) {
-                future = Callback.class.cast(attribute).future();
+            } else if (attribute instanceof OnLastHttpContentCallback) {
+                future = OnLastHttpContentCallback.class.cast(attribute).future();
             }
         } catch (Throwable t) {
             cause = t;
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 1cfe1ca79..caf457942 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -86,7 +86,7 @@ private boolean exitAfterHandlingStatus(//
             HttpResponse response, AsyncHandler<?> handler,//
             NettyResponseStatus status,//
             HttpRequest httpRequest) throws IOException, Exception {
-        return !future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE;
+        return !future.isAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE;
     }
 
     private boolean exitAfterHandlingHeaders(//
@@ -162,8 +162,6 @@ private void handleChunk(HttpContent chunk,//
     @Override
     public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
 
-        future.touch();
-
         // future is already done because of an exception or a timeout
         if (future.isDone()) {
             // FIXME isn't the channel already properly closed?
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 8c82a90fc..c97665b35 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -15,7 +15,6 @@
 
 import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
 import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -33,10 +32,9 @@
 
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.NettyResponseStatus;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -54,7 +52,7 @@ public WebSocketHandler(AsyncHttpClientConfig config,//
         super(config, channelManager, requestSender);
     }
 
-    private class UpgradeCallback extends Callback {
+    private class UpgradeCallback extends OnLastHttpContentCallback {
 
         private final Channel channel;
         private final HttpResponse response;
@@ -77,7 +75,7 @@ public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpRespo
         private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
             if (!h.touchSuccess()) {
                 try {
-                    h.onSuccess(new NettyWebSocket(channel, responseHeaders.getHeaders(), config));
+                    h.onSuccess(new NettyWebSocket(channel, responseHeaders.getHeaders()));
                 } catch (Exception ex) {
                     logger.warn("onSuccess unexpected exception", ex);
                 }
@@ -168,7 +166,7 @@ public void run() {
                         } finally {
                             frame.release();
                         }
-                    };
+                    }
                 };
                 handler.bufferFrame(bufferedFrame);
             }
@@ -178,33 +176,29 @@ public void run() {
     }
 
     private void handleFrame(Channel channel, WebSocketFrame frame, WebSocketUpgradeHandler handler, NettyWebSocket webSocket) throws Exception {
-        if (frame instanceof CloseWebSocketFrame) {
+        if (frame instanceof TextWebSocketFrame) {
+            webSocket.onTextFrame((TextWebSocketFrame) frame);
+
+        } else if (frame instanceof BinaryWebSocketFrame) {
+            webSocket.onBinaryFrame((BinaryWebSocketFrame) frame);
+
+        } else if (frame instanceof CloseWebSocketFrame) {
             Channels.setDiscard(channel);
             CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
             webSocket.onClose(closeFrame.statusCode(), closeFrame.reasonText());
             Channels.silentlyCloseChannel(channel);
-        } else {
-            ByteBuf buf = frame.content();
-            if (buf != null && buf.readableBytes() > 0) {
-                HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
-                handler.onBodyPartReceived(part);
-
-                if (frame instanceof BinaryWebSocketFrame) {
-                    webSocket.onBinaryFragment(part);
-                } else if (frame instanceof TextWebSocketFrame) {
-                    webSocket.onTextFragment(part);
-                } else if (frame instanceof PingWebSocketFrame) {
-                    webSocket.onPing(part);
-                } else if (frame instanceof PongWebSocketFrame) {
-                    webSocket.onPong(part);
-                }
-            }
+
+        } else if (frame instanceof PingWebSocketFrame) {
+            webSocket.onPing((PingWebSocketFrame) frame);
+
+        } else if (frame instanceof PongWebSocketFrame) {
+            webSocket.onPong((PongWebSocketFrame) frame);
         }
     }
 
     @Override
     public void handleException(NettyResponseFuture<?> future, Throwable e) {
-        logger.warn("onError {}", e);
+        logger.warn("onError", e);
 
         try {
             WebSocketUpgradeHandler h = (WebSocketUpgradeHandler) future.getAsyncHandler();
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
index c4a654d17..189aedf5f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
@@ -17,7 +17,7 @@
 
 import java.io.IOException;
 
-import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
@@ -34,7 +34,7 @@ public boolean exitAfterHandling100(final Channel channel, final NettyResponseFu
         future.setHeadersAlreadyWrittenOnContinue(true);
         future.setDontWriteBodyBecauseExpectContinue(false);
         // directly send the body
-        Channels.setAttribute(channel, new Callback(future) {
+        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
             @Override
             public void call() throws IOException {
                 Channels.setAttribute(channel, future);
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
index 31e741239..a6711d42f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
@@ -60,7 +60,7 @@ public boolean exitAfterHandling407(//
             ProxyServer proxyServer,//
             HttpRequest httpRequest) {
 
-        if (future.getInProxyAuth().getAndSet(true)) {
+        if (future.isAndSetInProxyAuth(true)) {
             LOGGER.info("Can't handle 407 as auth was already performed");
             return false;
         }
@@ -68,7 +68,7 @@ public boolean exitAfterHandling407(//
         Realm proxyRealm = future.getProxyRealm();
 
         if (proxyRealm == null) {
-            LOGGER.info("Can't handle 407 as there's no proxyRealm");
+            LOGGER.debug("Can't handle 407 as there's no proxyRealm");
             return false;
         }
 
@@ -210,7 +210,7 @@ private void ntlmProxyChallenge(String authenticateHeader,//
             // FIXME we might want to filter current NTLM and add (leave other
             // Authorization headers untouched)
             requestHeaders.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-            future.getInProxyAuth().set(false);
+            future.setInProxyAuth(false);
 
         } else {
             String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index 5ed705096..57b7f8efc 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -79,8 +79,8 @@ public boolean exitAfterHandlingRedirect(//
 
             } else {
                 // We must allow auth handling again.
-                future.getInAuth().set(false);
-                future.getInProxyAuth().set(false);
+                future.setInAuth(false);
+                future.setInProxyAuth(false);
 
                 String originalMethod = request.getMethod();
                 boolean switchToGet = !originalMethod.equals(GET)
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
index bd9ba2982..16b06162e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
@@ -64,11 +64,11 @@ public boolean exitAfterHandling401(//
             HttpRequest httpRequest) {
 
         if (realm == null) {
-            LOGGER.info("Can't handle 401 as there's no realm");
+            LOGGER.debug("Can't handle 401 as there's no realm");
             return false;
         }
 
-        if (future.getInAuth().getAndSet(true)) {
+        if (future.isAndSetInAuth(true)) {
             LOGGER.info("Can't handle 401 as auth was already performed");
             return false;
         }
@@ -195,7 +195,7 @@ private void ntlmChallenge(String authenticateHeader,//
             // FIXME we might want to filter current NTLM and add (leave other
             // Authorization headers untouched)
             requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
-            future.getInAuth().set(false);
+            future.setInAuth(false);
 
         } else {
             String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 26bd81e57..2540eb2fb 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -19,6 +19,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.List;
+import java.util.concurrent.RejectedExecutionException;
 
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -66,8 +67,7 @@ public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> con
 
         try {
             connect0(bootstrap, connectListener, remoteAddress);
-        } catch (Throwable e) {
-            // workaround for https://github.com/netty/netty/issues/5387
+        } catch (RejectedExecutionException e) {
             if (clientState.isClosed()) {
                 connectListener.onFailure(null, e);
             } else {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 421cb2966..7b0f472e1 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -20,6 +20,7 @@
 import static org.asynchttpclient.util.MiscUtils.*;
 import static org.asynchttpclient.ws.WebSocketUtils.getKey;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -102,7 +103,8 @@ private NettyBody body(Request request, boolean connect) {
                 nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
 
             } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
-                nettyBody = new NettyInputStreamBody(InputStreamBodyGenerator.class.cast(request.getBodyGenerator()).getInputStream());
+                InputStreamBodyGenerator inStreamGenerator = InputStreamBodyGenerator.class.cast(request.getBodyGenerator());
+                nettyBody = new NettyInputStreamBody(inStreamGenerator.getInputStream(), inStreamGenerator.getContentLength());
 
             } else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator) {
                 ReactiveStreamsBodyGenerator reactiveStreamsBodyGenerator = (ReactiveStreamsBodyGenerator)request.getBodyGenerator();
@@ -147,7 +149,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
             nettyRequest = new NettyRequest(httpRequest, null);
 
         } else if (body == null) {
-            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri);
+            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.EMPTY_BUFFER);
             nettyRequest = new NettyRequest(httpRequest, null);
 
         } else {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 97a9e6702..cbc7842fc 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -46,7 +46,7 @@
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.handler.TransferCompletionHandler;
-import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -85,7 +85,7 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
     public <T> ListenableFuture<T> sendRequest(final Request request,//
             final AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
-            boolean reclaimCache) {
+            boolean performingNextRequest) {
 
         if (isClosed())
             throw new IllegalStateException("Closed");
@@ -98,13 +98,13 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
         if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))
             if (future != null && future.isConnectAllowed())
                 // SSL proxy or websocket: CONNECT for sure
-                return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, true);
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, true);
             else
                 // CONNECT will depend if we can pool or connection or if we have to open a new one
-                return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, proxyServer);
+                return sendRequestThroughSslProxy(request, asyncHandler, future, performingNextRequest, proxyServer);
         else
             // no CONNECT for sure
-            return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, false);
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);
     }
 
     private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
@@ -122,7 +122,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
             Request request,//
             AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
-            boolean reclaimCache,//
+            boolean performingNextRequest,//
             ProxyServer proxyServer,//
             boolean forceConnect) {
 
@@ -133,7 +133,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
         if (Channels.isChannelValid(channel))
             return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
         else
-            return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, reclaimCache);
+            return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
     /**
@@ -144,7 +144,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
             Request request,//
             AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
-            boolean reclaimCache,//
+            boolean performingNextRequest,//
             ProxyServer proxyServer) {
 
         NettyResponseFuture<T> newFuture = null;
@@ -164,7 +164,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
         }
 
         newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
-        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, reclaimCache);
+        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
     private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
@@ -203,7 +203,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
 
     private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
 
-        if (future != null && future.reuseChannel() && Channels.isChannelValid(future.channel()))
+        if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel()))
             return future.channel();
         else
             return pollPooledChannel(request, proxyServer, asyncHandler);
@@ -244,7 +244,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
             ProxyServer proxy,//
             NettyResponseFuture<T> future,//
             AsyncHandler<T> asyncHandler,//
-            boolean reclaimCache) {
+            boolean performingNextRequest) {
 
         // some headers are only set when performing the first request
         HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
@@ -253,8 +253,8 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
         requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
 
-        future.getInAuth().set(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
-        future.getInProxyAuth().set(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
+        future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
+        future.setInProxyAuth(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
 
         // Do not throw an exception when we need an extra connection for a redirect
         // FIXME why? This violate the max connection per host handling, right?
@@ -262,14 +262,15 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
 
         Object partitionKey = future.getPartitionKey();
 
-        final boolean channelPreempted = !reclaimCache;
+        // we disable channelPreemption when performing next requests
+        final boolean acquireChannelLock = !performingNextRequest;
 
         try {
             // Do not throw an exception when we need an extra connection for a
             // redirect.
-            if (channelPreempted) {
+            if (acquireChannelLock) {
                 // if there's an exception here, channel wasn't preempted and resolve won't happen
-                channelManager.preemptChannel(partitionKey);
+                channelManager.acquireChannelLock(partitionKey);
             }
         } catch (Throwable t) {
             abort(null, future, getCause(t));
@@ -284,19 +285,19 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
 
                     @Override
                     protected void onSuccess(List<InetSocketAddress> addresses) {
-                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, channelPreempted, partitionKey);
+                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, acquireChannelLock, partitionKey);
                         NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);
                         if (!future.isDone()) {
                             connector.connect(bootstrap, connectListener);
-                        } else if (channelPreempted) {
-                            channelManager.abortChannelPreemption(partitionKey);
+                        } else if (acquireChannelLock) {
+                            channelManager.releaseChannelLock(partitionKey);
                         }
                     }
 
                     @Override
                     protected void onFailure(Throwable cause) {
-                        if (channelPreempted) {
-                            channelManager.abortChannelPreemption(partitionKey);
+                        if (acquireChannelLock) {
+                            channelManager.releaseChannelLock(partitionKey);
                         }
                         abort(null, future, getCause(cause));
                     }
@@ -405,12 +406,14 @@ public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
     }
 
     public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
-        if (future.isDone()) {
-            channelManager.closeChannel(channel);
-        } else if (future.incrementRetryAndCheck() && retry(future)) {
-            future.pendingException = null;
-        } else {
-            abort(channel, future, future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
+        if (Channels.getInactiveToken(channel)) {
+            if (future.isDone()) {
+                channelManager.closeChannel(channel);
+            } else if (future.incrementRetryAndCheck() && retry(future)) {
+                future.pendingException = null;
+            } else {
+                abort(channel, future, future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
+            }
         }
     }
 
@@ -419,10 +422,9 @@ public boolean retry(NettyResponseFuture<?> future) {
         if (isClosed())
             return false;
 
-        if (future.canBeReplayed()) {
-            // FIXME should we set future.setReuseChannel(false); ?
+        if (future.isReplayPossible()) {
             future.setChannelState(ChannelState.RECONNECTED);
-            future.getAndSetStatusReceived(false);
+            future.isAndSetStatusReceived(false);
 
             LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
             if (future.getAsyncHandler() instanceof AsyncHandlerExtensions) {
@@ -458,7 +460,7 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
             }
         }
 
-        if (fc.replayRequest() && future.incrementRetryAndCheck() && future.canBeReplayed()) {
+        if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
             replayRequest(future, fc, channel);
             replayed = true;
         }
@@ -466,12 +468,6 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
     }
 
     public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
-        // remove attribute in case the channel gets closed so it doesn't try to recover the previous future
-        Channel channel = future.channel();
-        if (channel != null) {
-            // channel can be null when it was closed by the server before it could be set
-            Channels.setAttribute(channel, null);
-        }
         sendRequest(request, future.getAsyncHandler(), future, true);
     }
 
@@ -523,17 +519,12 @@ public boolean isClosed() {
         return clientState.isClosed();
     }
 
-    public final Callback newExecuteNextRequestCallback(final NettyResponseFuture<?> future, final Request nextRequest) {
-
-        return new Callback(future) {
+    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
+        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
             @Override
             public void call() {
                 sendNextRequest(nextRequest, future);
             }
-        };
-    }
-
-    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
-        Channels.setAttribute(channel, newExecuteNextRequestCallback(future, nextRequest));
+        });
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
index 9ba2cefa6..74c748f6e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
@@ -67,7 +67,7 @@ protected void operationComplete(Channel channel, Throwable cause) {
              * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
              * causing unpredictable behavior.
              */
-            boolean startPublishing = !future.getInAuth().get() && !future.getInProxyAuth().get();
+            boolean startPublishing = !future.isInAuth() && !future.isInProxyAuth();
             if (startPublishing) {
                 
                 if (notifyHeaders) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 581d2b85a..3a47562e0 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -15,7 +15,6 @@
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedWriteHandler;
@@ -83,13 +82,13 @@ public void onError(Throwable t) {
             }
         }
 
-        ChannelFuture writeFuture = channel.write(msg, channel.newProgressivePromise());
-        writeFuture.addListener(new WriteProgressListener(future, false, getContentLength()) {
-            public void operationComplete(ChannelProgressiveFuture cf) {
-                closeSilently(body);
-                super.operationComplete(cf);
-            }
-        });
+        channel.write(msg, channel.newProgressivePromise())//
+                .addListener(new WriteProgressListener(future, false, getContentLength()) {
+                    public void operationComplete(ChannelProgressiveFuture cf) {
+                        closeSilently(body);
+                        super.operationComplete(cf);
+                    }
+                });
         channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
index 1e0019d3c..02b46fdf6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
@@ -33,9 +33,15 @@
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
 
     private final InputStream inputStream;
+    private final long contentLength;
 
     public NettyInputStreamBody(InputStream inputStream) {
+        this(inputStream, -1L);
+    }
+
+    public NettyInputStreamBody(InputStream inputStream, long contentLength) {
         this.inputStream = inputStream;
+        this.contentLength = contentLength;
     }
 
     public InputStream getInputStream() {
@@ -44,7 +50,7 @@ public InputStream getInputStream() {
 
     @Override
     public long getContentLength() {
-        return -1L;
+        return contentLength;
     }
 
     @Override
@@ -56,7 +62,7 @@ public String getContentType() {
     public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
         final InputStream is = inputStream;
 
-        if (future.isStreamWasAlreadyConsumed()) {
+        if (future.isStreamConsumed()) {
             if (is.markSupported())
                 is.reset();
             else {
@@ -64,7 +70,7 @@ public void write(Channel channel, NettyResponseFuture<?> future) throws IOExcep
                 return;
             }
         } else {
-            future.setStreamWasAlreadyConsumed(true);
+            future.setStreamConsumed(true);
         }
 
         channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
index 96224694d..e37bcfa24 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -59,10 +59,10 @@ public String getContentType() {
 
     @Override
     public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        if (future.isStreamWasAlreadyConsumed()) {
+        if (future.isStreamConsumed()) {
             LOGGER.warn("Stream has already been consumed and cannot be reset");
         } else {
-            future.setStreamWasAlreadyConsumed(true);
+            future.setStreamConsumed(true);
             NettySubscriber subscriber = new NettySubscriber(channel, future);
             channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
             publisher.subscribe(new SubscriberAdapter(subscriber));
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
index 672a82c96..b467fd71c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
@@ -17,7 +17,6 @@
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.SslProvider;
-import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLException;
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/InsecureTrustManagerFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/InsecureTrustManagerFactory.java
new file mode 100644
index 000000000..6adefbc85
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/InsecureTrustManagerFactory.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.netty.ssl;
+
+import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
+import io.netty.util.internal.EmptyArrays;
+
+import java.net.Socket;
+import java.security.KeyStore;
+import java.security.cert.X509Certificate;
+
+import javax.net.ssl.ManagerFactoryParameters;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509ExtendedTrustManager;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+//TODO: Replace this with Netty's InsecureTrustManager once it creates X509ExtendedTrustManager.
+//
+// When a server mandates the authentication of a client certificate, JDK internally wraps a TrustManager
+// with AbstractTrustManagerWrapper unless it extends X509ExtendedTrustManager. AbstractTrustManagerWrapper
+// performs an additional check (DN comparison), making InsecureTrustManager not insecure enough.
+//
+// To work around this problem, we forked Netty's InsecureTrustManagerFactory and made its TrustManager
+// implementation extend X509ExtendedTrustManager instead of X509TrustManager.
+// see https://github.com/netty/netty/issues/5910
+public final class InsecureTrustManagerFactory extends SimpleTrustManagerFactory {
+
+    private static final Logger logger = LoggerFactory.getLogger(InsecureTrustManagerFactory.class);
+
+    public static final TrustManagerFactory INSTANCE = new InsecureTrustManagerFactory();
+
+    private static final TrustManager tm = new X509ExtendedTrustManager() {
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String s) {
+            log("client", chain);
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String s, Socket socket) {
+            log("client", chain);
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String s, SSLEngine sslEngine) {
+            log("client", chain);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String s) {
+            log("server", chain);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String s, Socket socket) {
+            log("server", chain);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String s, SSLEngine sslEngine) {
+            log("server", chain);
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return EmptyArrays.EMPTY_X509_CERTIFICATES;
+        }
+
+        private void log(String type, X509Certificate[] chain) {
+            logger.debug("Accepting a {} certificate: {}", type, chain[0].getSubjectDN());
+        }
+    };
+
+    private InsecureTrustManagerFactory() {
+    }
+
+    @Override
+    protected void engineInit(KeyStore keyStore) throws Exception {
+    }
+
+    @Override
+    protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception {
+    }
+
+    @Override
+    protected TrustManager[] engineGetTrustManagers() {
+        return new TrustManager[] { tm };
+    }
+}
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
index 3b2fd1bce..77e409dd7 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
@@ -25,11 +25,9 @@
 
     protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
         sslEngine.setUseClientMode(true);
-        if (!config.isAcceptAnyCertificate()) {
-            SSLParameters params = sslEngine.getSSLParameters();
-            params.setEndpointIdentificationAlgorithm("HTTPS");
-            sslEngine.setSSLParameters(params);
-        }
+        SSLParameters params = sslEngine.getSSLParameters();
+        params.setEndpointIdentificationAlgorithm("HTTPS");
+        sslEngine.setSSLParameters(params);
 
         if (isNonEmpty(config.getEnabledProtocols()))
             sslEngine.setEnabledProtocols(config.getEnabledProtocols());
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 7f3aae98a..0bd249049 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -27,7 +27,7 @@ public ReadTimeoutTimerTask(//
             NettyResponseFuture<?> nettyResponseFuture,//
             NettyRequestSender requestSender,//
             TimeoutsHolder timeoutsHolder,//
-            long readTimeout) {
+            int readTimeout) {
         super(nettyResponseFuture, requestSender, timeoutsHolder);
         this.readTimeout = readTimeout;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index 2546b6914..d108deea4 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -27,7 +27,7 @@ public RequestTimeoutTimerTask(//
             NettyResponseFuture<?> nettyResponseFuture,//
             NettyRequestSender requestSender,//
             TimeoutsHolder timeoutsHolder,//
-            long requestTimeout) {
+            int requestTimeout) {
         super(nettyResponseFuture, requestSender, timeoutsHolder);
         this.requestTimeout = requestTimeout;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index 66a1a9077..c2903056a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -15,6 +15,7 @@
 
 import static io.netty.buffer.Unpooled.wrappedBuffer;
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
@@ -23,24 +24,18 @@
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.net.SocketAddress;
-import java.util.ArrayList;
+import java.nio.charset.CharacterCodingException;
 import java.util.Collection;
-import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.netty.util.ByteBufUtils;
 import org.asynchttpclient.ws.WebSocket;
-import org.asynchttpclient.ws.WebSocketByteFragmentListener;
 import org.asynchttpclient.ws.WebSocketByteListener;
 import org.asynchttpclient.ws.WebSocketCloseCodeReasonListener;
 import org.asynchttpclient.ws.WebSocketListener;
 import org.asynchttpclient.ws.WebSocketPingListener;
 import org.asynchttpclient.ws.WebSocketPongListener;
-import org.asynchttpclient.ws.WebSocketTextFragmentListener;
 import org.asynchttpclient.ws.WebSocketTextListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -52,21 +47,17 @@
     protected final Channel channel;
     protected final HttpHeaders upgradeHeaders;
     protected final Collection<WebSocketListener> listeners;
-    protected final int maxBufferSize;
-    private int bufferSize;
-    private List<byte[]> _fragments;
     private volatile boolean interestedInByteMessages;
     private volatile boolean interestedInTextMessages;
 
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, AsyncHttpClientConfig config) {
-        this(channel, upgradeHeaders, config, new ConcurrentLinkedQueue<WebSocketListener>());
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
+        this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
     }
 
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, AsyncHttpClientConfig config, Collection<WebSocketListener> listeners) {
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
         this.channel = channel;
         this.upgradeHeaders = upgradeHeaders;
         this.listeners = listeners;
-        maxBufferSize = config.getWebSocketMaxBufferSize();
     }
 
     @Override
@@ -207,28 +198,6 @@ public WebSocket removeWebSocketListener(WebSocketListener l) {
         return this;
     }
 
-    private List<byte[]> fragments() {
-        if (_fragments == null)
-            _fragments = new ArrayList<>(2);
-        return _fragments;
-    }
-
-    private void bufferFragment(byte[] buffer) {
-        bufferSize += buffer.length;
-        if (bufferSize > maxBufferSize) {
-            onError(new Exception("Exceeded Netty Web Socket maximum buffer size of " + maxBufferSize));
-            reset();
-            close();
-        } else {
-            fragments().add(buffer);
-        }
-    }
-
-    private void reset() {
-        fragments().clear();
-        bufferSize = 0;
-    }
-
     private void notifyByteListeners(byte[] message) {
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketByteListener)
@@ -236,89 +205,42 @@ private void notifyByteListeners(byte[] message) {
         }
     }
 
-    private void notifyTextListeners(byte[] bytes) {
-        String message = new String(bytes, UTF_8);
+    private void notifyTextListeners(String message) {
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketTextListener)
                 WebSocketTextListener.class.cast(listener).onMessage(message);
         }
     }
 
-    public void onBinaryFragment(HttpResponseBodyPart part) {
-
-        for (WebSocketListener listener : listeners) {
-            if (listener instanceof WebSocketByteFragmentListener)
-                WebSocketByteFragmentListener.class.cast(listener).onFragment(part);
-        }
-
+    public void onBinaryFrame(BinaryWebSocketFrame frame) {
         if (interestedInByteMessages) {
-            byte[] fragment = part.getBodyPartBytes();
-
-            if (part.isLast()) {
-                if (bufferSize == 0) {
-                    notifyByteListeners(fragment);
-
-                } else {
-                    bufferFragment(fragment);
-                    notifyByteListeners(fragmentsBytes());
-                }
-
-                reset();
-
-            } else
-                bufferFragment(fragment);
+            notifyByteListeners(byteBuf2Bytes(frame.content()));
         }
     }
 
-    private byte[] fragmentsBytes() {
-        ByteArrayOutputStream os = new ByteArrayOutputStream(bufferSize);
-        for (byte[] bytes : _fragments)
+    public void onTextFrame(TextWebSocketFrame frame) {
+        if (interestedInTextMessages) {
             try {
-                os.write(bytes);
-            } catch (IOException e) {
-                // yeah, right
+                notifyTextListeners(ByteBufUtils.byteBuf2String(UTF_8, frame.content()));
+            } catch (CharacterCodingException e) {
+                throw new IllegalStateException(e);
             }
-        return os.toByteArray();
-    }
-
-    public void onTextFragment(HttpResponseBodyPart part) {
-        for (WebSocketListener listener : listeners) {
-            if (listener instanceof WebSocketTextFragmentListener)
-                WebSocketTextFragmentListener.class.cast(listener).onFragment(part);
-        }
-
-        if (interestedInTextMessages) {
-            byte[] fragment = part.getBodyPartBytes();
-
-            if (part.isLast()) {
-                if (bufferSize == 0) {
-                    notifyTextListeners(fragment);
-
-                } else {
-                    bufferFragment(fragment);
-                    notifyTextListeners(fragmentsBytes());
-                }
-
-                reset();
-
-            } else
-                bufferFragment(fragment);
         }
     }
 
-    public void onPing(HttpResponseBodyPart part) {
+    public void onPing(PingWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketPingListener)
-                // bytes are cached in the part
-                WebSocketPingListener.class.cast(listener).onPing(part.getBodyPartBytes());
+                WebSocketPingListener.class.cast(listener).onPing(bytes);
         }
     }
 
-    public void onPong(HttpResponseBodyPart part) {
+    public void onPong(PongWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketPongListener)
-                // bytes are cached in the part
-                WebSocketPongListener.class.cast(listener).onPong(part.getBodyPartBytes());
+                WebSocketPongListener.class.cast(listener).onPong(bytes);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index f0e00ac70..ceea1971a 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -1,18 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
  *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.oauth;
 
@@ -24,6 +21,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ThreadLocalRandom;
+import java.util.regex.Pattern;
 
 import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
@@ -35,12 +33,9 @@
 import org.asynchttpclient.util.Utf8UrlEncoder;
 
 /**
- * Simple OAuth signature calculator that can used for constructing client signatures
- * for accessing services that use OAuth for authorization.
- * <br>
- * Supports most common signature inclusion and calculation methods: HMAC-SHA1 for
- * calculation, and Header inclusion as inclusion method. Nonce generation uses
- * simple random numbers with base64 encoding.
+ * Simple OAuth signature calculator that can used for constructing client signatures for accessing services that use OAuth for authorization. <br>
+ * Supports most common signature inclusion and calculation methods: HMAC-SHA1 for calculation, and Header inclusion as inclusion method. Nonce generation uses simple random
+ * numbers with base64 encoding.
  *
  * @author tatu (tatu.saloranta@iki.fi)
  */
@@ -72,7 +67,7 @@
 
     /**
      * @param consumerAuth Consumer key to use for signature calculation
-     * @param userAuth     Request/access token to use for signature calculation
+     * @param userAuth Request/access token to use for signature calculation
      */
     public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth) {
         mac = new ThreadSafeHMAC(consumerAuth, userAuth);
@@ -84,47 +79,16 @@ public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth)
     public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
         String nonce = generateNonce();
         long timestamp = generateTimestamp();
-        String signature = calculateSignature(request.getMethod(), request.getUri(), timestamp, nonce, request.getFormParams(), request.getQueryParams());
+        String signature = calculateSignature(request, timestamp, nonce);
         String headerValue = constructAuthHeader(signature, nonce, timestamp);
         requestBuilder.setHeader(HEADER_AUTHORIZATION, headerValue);
     }
 
-    private String baseUrl(Uri uri) {
-        /* 07-Oct-2010, tatu: URL may contain default port number; if so, need to extract
-         *   from base URL.
-         */
-        String scheme = uri.getScheme();
-
-        StringBuilder sb = StringUtils.stringBuilder();
-        sb.append(scheme).append("://").append(uri.getHost());
-        
-        int port = uri.getPort();
-        if (scheme.equals("http")) {
-            if (port == 80)
-                port = -1;
-        } else if (scheme.equals("https")) {
-            if (port == 443)
-                port = -1;
-        }
-
-        if (port != -1)
-            sb.append(':').append(port);
-
-        if (isNonEmpty(uri.getPath()))
-            sb.append(uri.getPath());
-        
-        return sb.toString();
-    }
-
     private String encodedParams(long oauthTimestamp, String nonce, List<Param> formParams, List<Param> queryParams) {
         /**
-         * List of all query and form parameters added to this request; needed
-         * for calculating request signature
+         * List of all query and form parameters added to this request; needed for calculating request signature
          */
-        int allParametersSize = 5
-                + (userAuth.getKey() != null ? 1 : 0)
-                + (formParams != null ? formParams.size() : 0)
-                + (queryParams != null ? queryParams.size() : 0);
+        int allParametersSize = 5 + (userAuth.getKey() != null ? 1 : 0) + (formParams != null ? formParams.size() : 0) + (queryParams != null ? queryParams.size() : 0);
         OAuthParameterSet allParameters = new OAuthParameterSet(allParametersSize);
 
         // start with standard OAuth parameters we need
@@ -145,47 +109,72 @@ private String encodedParams(long oauthTimestamp, String nonce, List<Param> form
         }
         if (queryParams != null) {
             for (Param param : queryParams) {
-             // queryParams are already encoded
-                allParameters.add(param.getName(), param.getValue());
+                // queryParams are already form-url-encoded
+                // but OAuth1 uses RFC3986_UNRESERVED_CHARS so * and + have to be encoded
+                allParameters.add(percentEncodeAlreadyFormUrlEncoded(param.getName()), percentEncodeAlreadyFormUrlEncoded(param.getValue()));
             }
         }
         return allParameters.sortAndConcat();
     }
 
-    StringBuilder signatureBaseString(String method, Uri uri, long oauthTimestamp, String nonce,
-                                     List<Param> formParams, List<Param> queryParams) {
-        
+    private String baseUrl(Uri uri) {
+        /*
+         * 07-Oct-2010, tatu: URL may contain default port number; if so, need to remove from base URL.
+         */
+        String scheme = uri.getScheme();
+
+        StringBuilder sb = StringUtils.stringBuilder();
+        sb.append(scheme).append("://").append(uri.getHost());
+
+        int port = uri.getPort();
+        if (scheme.equals("http")) {
+            if (port == 80)
+                port = -1;
+        } else if (scheme.equals("https")) {
+            if (port == 443)
+                port = -1;
+        }
+
+        if (port != -1)
+            sb.append(':').append(port);
+
+        if (isNonEmpty(uri.getPath()))
+            sb.append(uri.getPath());
+
+        return sb.toString();
+    }
+
+    private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
+    private static final Pattern PLUS_CHAR_PATTERN = Pattern.compile("+", Pattern.LITERAL);
+    private static final Pattern ENCODED_TILDE_PATTERN = Pattern.compile("%7E", Pattern.LITERAL);
+
+    private String percentEncodeAlreadyFormUrlEncoded(String s) {
+        s = STAR_CHAR_PATTERN.matcher(s).replaceAll("%2A");
+        s = PLUS_CHAR_PATTERN.matcher(s).replaceAll("%20");
+        s = ENCODED_TILDE_PATTERN.matcher(s).replaceAll("~");
+        return s;
+    }
+
+    StringBuilder signatureBaseString(Request request, long oauthTimestamp, String nonce) {
+
         // beware: must generate first as we're using pooled StringBuilder
-        String baseUrl = baseUrl(uri);
-        String encodedParams = encodedParams(oauthTimestamp, nonce, formParams, queryParams);
+        String baseUrl = baseUrl(request.getUri());
+        String encodedParams = encodedParams(oauthTimestamp, nonce, request.getFormParams(), request.getQueryParams());
 
         StringBuilder sb = StringUtils.stringBuilder();
-        sb.append(method); // POST / GET etc (nothing to URL encode)
+        sb.append(request.getMethod()); // POST / GET etc (nothing to URL encode)
         sb.append('&');
         Utf8UrlEncoder.encodeAndAppendQueryElement(sb, baseUrl);
 
-
         // and all that needs to be URL encoded (... again!)
         sb.append('&');
         Utf8UrlEncoder.encodeAndAppendQueryElement(sb, encodedParams);
         return sb;
     }
-    
-    /**
-     * Method for calculating OAuth signature using HMAC/SHA-1 method.
-     * 
-     * @param method the request methode
-     * @param uri the request Uri
-     * @param oauthTimestamp the timestamp
-     * @param nonce the nonce
-     * @param formParams the formParams
-     * @param queryParams the query params
-     * @return the signature
-     */
-    public String calculateSignature(String method, Uri uri, long oauthTimestamp, String nonce,
-                                     List<Param> formParams, List<Param> queryParams) {
 
-        StringBuilder sb = signatureBaseString(method, uri, oauthTimestamp, nonce, formParams, queryParams);
+    String calculateSignature(Request request, long oauthTimestamp, String nonce) {
+
+        StringBuilder sb = signatureBaseString(request, oauthTimestamp, nonce);
 
         ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
         byte[] rawSignature = mac.digest(rawBase);
@@ -225,16 +214,13 @@ protected String generateNonce() {
         ThreadLocalRandom.current().nextBytes(nonceBuffer);
         // let's use base64 encoding over hex, slightly more compact than hex or decimals
         return Base64.encode(nonceBuffer);
-//      return String.valueOf(Math.abs(random.nextLong()));
+        // return String.valueOf(Math.abs(random.nextLong()));
     }
 
     /**
-     * Container for parameters used for calculating OAuth signature.
-     * About the only confusing aspect is that of whether entries are to be sorted
-     * before encoded or vice versa: if my reading is correct, encoding is to occur
-     * first, then sorting; although this should rarely matter (since sorting is primary
-     * by key, which usually has nothing to encode)... of course, rarely means that
-     * when it would occur it'd be harder to track down.
+     * Container for parameters used for calculating OAuth signature. About the only confusing aspect is that of whether entries are to be sorted before encoded or vice versa: if
+     * my reading is correct, encoding is to occur first, then sorting; although this should rarely matter (since sorting is primary by key, which usually has nothing to encode)...
+     * of course, rarely means that when it would occur it'd be harder to track down.
      */
     final static class OAuthParameterSet {
         private final ArrayList<Parameter> allParameters;
@@ -269,6 +255,7 @@ public String sortAndConcat() {
      * Helper class for sorting query and form parameters that we need
      */
     final static class Parameter implements Comparable<Parameter> {
+
         private final String key, value;
 
         public Parameter(String key, String value) {
@@ -300,13 +287,17 @@ public String toString() {
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
+            if (this == o)
+                return true;
+            if (o == null || getClass() != o.getClass())
+                return false;
 
             Parameter parameter = (Parameter) o;
 
-            if (!key.equals(parameter.key)) return false;
-            if (!value.equals(parameter.value)) return false;
+            if (!key.equals(parameter.key))
+                return false;
+            if (!value.equals(parameter.value))
+                return false;
 
             return true;
         }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index d9926534c..62e5a5393 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -127,7 +127,7 @@ public Builder setRealm(Realm.Builder realm) {
 
         public Builder setNonProxyHost(String nonProxyHost) {
             if (nonProxyHosts == null)
-                nonProxyHosts = new ArrayList<String>(1);
+                nonProxyHosts = new ArrayList<>(1);
             nonProxyHosts.add(nonProxyHost);
             return this;
         }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
index dc93a979c..359878b48 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
@@ -18,10 +18,5 @@
     /**
      * A selector that always selects no proxy.
      */
-    ProxyServerSelector NO_PROXY_SELECTOR = new ProxyServerSelector() {
-        @Override
-        public ProxyServer select(Uri uri) {
-            return null;
-        }
-    };
+    ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/Body.java b/client/src/main/java/org/asynchttpclient/request/body/Body.java
index b31185a52..66a588739 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/Body.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -38,7 +38,7 @@
         /**
          * There's nothing to read and input has to stop
          */
-        STOP;
+        STOP
     }
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
index ad7057139..155bd0764 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
@@ -32,34 +32,46 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
     private final InputStream inputStream;
+    private final long contentLength;
 
     public InputStreamBodyGenerator(InputStream inputStream) {
+        this(inputStream, -1L);
+    }
+
+    public InputStreamBodyGenerator(InputStream inputStream, long contentLength) {
         this.inputStream = inputStream;
+        this.contentLength = contentLength;
     }
 
     public InputStream getInputStream() {
         return inputStream;
     }
 
+    public long getContentLength() {
+        return contentLength;
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
     public Body createBody() {
-        return new InputStreamBody(inputStream);
+        return new InputStreamBody(inputStream, contentLength);
     }
 
     private class InputStreamBody implements Body {
 
         private final InputStream inputStream;
+        private final long contentLength;
         private byte[] chunk;
 
-        private InputStreamBody(InputStream inputStream) {
+        private InputStreamBody(InputStream inputStream, long contentLength) {
             this.inputStream = inputStream;
+            this.contentLength = contentLength;
         }
 
         public long getContentLength() {
-            return -1L;
+            return contentLength;
         }
 
         public BodyState transferTo(ByteBuf target) throws IOException {
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index 2c3ad83a5..6ca56cba2 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -73,7 +73,7 @@ public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders reque
     }
 
     public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
-        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<MultipartPart<? extends Part>>(parts.size());
+        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
         for (Part part : parts) {
             if (part instanceof FilePart) {
                 multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index b5db7a06c..ba487476c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -113,7 +113,7 @@ public void setDispositionType(String dispositionType) {
 
     public void addCustomHeader(String name, String value) {
         if (customHeaders == null) {
-            customHeaders = new ArrayList<Param>(2);
+            customHeaders = new ArrayList<>(2);
         }
         customHeaders.add(new Param(name, value));
     }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
index 4584dc64b..8f9d61081 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -205,7 +205,7 @@ protected long transfer(ByteBuf source, WritableByteChannel target, MultipartSta
 
         int transferred = 0;
         if (target instanceof GatheringByteChannel) {
-            transferred = source.readBytes((GatheringByteChannel) target, (int) source.readableBytes());
+            transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
         } else {
             for (ByteBuffer byteBuffer : source.nioBuffers()) {
                 int len = byteBuffer.remaining();
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
index df7b96950..6a44deac1 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
@@ -21,5 +21,5 @@
 
     POST_CONTENT,
 
-    DONE;
+    DONE
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index 205bc4bbe..53d97051a 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -81,7 +81,7 @@ public static SpnegoEngine instance() {
     public String generateToken(String server) throws SpnegoEngineException {
         GSSContext gssContext = null;
         byte[] token = null; // base64 decoded challenge
-        Oid negotiationOid = null;
+        Oid negotiationOid;
 
         try {
             log.debug("init {}", server);
@@ -152,7 +152,7 @@ public String generateToken(String server) throws SpnegoEngineException {
 
             gssContext.dispose();
 
-            String tokenstr = new String(Base64.encode(token));
+            String tokenstr = Base64.encode(token);
             log.debug("Sending response '{}' back to the server", tokenstr);
 
             return tokenstr;
diff --git a/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
deleted file mode 100755
index 3ebebc85f..000000000
--- a/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import io.netty.buffer.ByteBuf;
-
-import java.io.UTFDataFormatException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.CharacterCodingException;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.StandardCharsets;
-import java.util.List;
-
-public final class ByteBufUtils {
-
-    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-
-    private ByteBufUtils() {
-    }
-
-    public static String byteBuf2String(ByteBuf buf, Charset charset) throws UTFDataFormatException, IndexOutOfBoundsException, CharacterCodingException {
-
-        int byteLen = buf.readableBytes();
-
-        if (charset.equals(StandardCharsets.US_ASCII)) {
-            return Utf8Reader.readUtf8(buf, byteLen);
-        } else if (charset.equals(StandardCharsets.UTF_8)) {
-            try {
-                return Utf8Reader.readUtf8(buf.duplicate(), (int) (byteLen * 1.4));
-            } catch (IndexOutOfBoundsException e) {
-                // try again with 3 bytes per char
-                return Utf8Reader.readUtf8(buf, byteLen * 3);
-            }
-        } else {
-            return byteBuffersToString(buf.nioBuffers(), charset);
-        }
-    }
-
-    private static String byteBuffersToString(ByteBuffer[] bufs, Charset cs) throws CharacterCodingException {
-
-        CharsetDecoder cd = cs.newDecoder();
-        int len = 0;
-        for (ByteBuffer buf : bufs) {
-            len += buf.remaining();
-        }
-        int en = (int) (len * (double) cd.maxCharsPerByte());
-        char[] ca = new char[en];
-        cd.reset();
-        CharBuffer cb = CharBuffer.wrap(ca);
-
-        CoderResult cr = null;
-
-        for (int i = 0; i < bufs.length; i++) {
-
-            ByteBuffer buf = bufs[i];
-            cr = cd.decode(buf, cb, i < bufs.length - 1);
-            if (!cr.isUnderflow())
-                cr.throwException();
-        }
-
-        cr = cd.flush(cb);
-        if (!cr.isUnderflow())
-            cr.throwException();
-
-        return new String(ca, 0, cb.position());
-    }
-
-    public static byte[] byteBuf2Bytes(ByteBuf buf) {
-        int readable = buf.readableBytes();
-        int readerIndex = buf.readerIndex();
-        if (buf.hasArray()) {
-            byte[] array = buf.array();
-            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-                return array;
-            }
-        }
-        byte[] array = new byte[readable];
-        buf.getBytes(readerIndex, array);
-        return array;
-    }
-
-    public static byte[] byteBufs2Bytes(List<ByteBuf> bufs) {
-
-        if (bufs.isEmpty()) {
-            return EMPTY_BYTE_ARRAY;
-
-        } else if (bufs.size() == 1) {
-            return byteBuf2Bytes(bufs.get(0));
-
-        } else {
-            int totalSize = 0;
-            for (ByteBuf buf : bufs) {
-                totalSize += buf.readableBytes();
-            }
-
-            byte[] bytes = new byte[totalSize];
-            int offset = 0;
-            for (ByteBuf buf : bufs) {
-                int readable = buf.readableBytes();
-                buf.getBytes(buf.readerIndex(), bytes, offset, readable);
-                offset += readable;
-            }
-            return bytes;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index 254453b6e..edde95850 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -31,23 +31,23 @@
 
     public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
-    public static final void validateSupportedScheme(Uri uri) {
+    public static void validateSupportedScheme(Uri uri) {
         final String scheme = uri.getScheme();
         if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
             throw new IllegalArgumentException("The URI scheme, of the URI " + uri + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
         }
     }
 
-    public final static String getBaseUrl(Uri uri) {
+    public static String getBaseUrl(Uri uri) {
         // getAuthority duplicate but we don't want to re-concatenate
         return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
     }
 
-    public final static String getAuthority(Uri uri) {
+    public static String getAuthority(Uri uri) {
         return uri.getHost() + ":" + uri.getExplicitPort();
     }
 
-    public final static boolean isSameBase(Uri uri1, Uri uri2) {
+    public static boolean isSameBase(Uri uri1, Uri uri2) {
         return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost()) && uri1.getExplicitPort() == uri2.getExplicitPort();
     }
 
@@ -55,7 +55,7 @@ public final static boolean isSameBase(Uri uri1, Uri uri2) {
      * @param uri the uri
      * @return the raw path or "/" if it's null
      */
-    public final static String getNonEmptyPath(Uri uri) {
+    public static String getNonEmptyPath(Uri uri) {
         return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
     }
 
@@ -79,7 +79,7 @@ public static Charset parseCharset(String contentType) {
     }
 
     public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
-        return request.getFollowRedirect() != null ? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
+        return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
     }
 
     private static StringBuilder urlEncodeFormParams0(List<Param> params) {
diff --git a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 1d61e2815..569c8e649 100644
--- a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -40,7 +40,7 @@
  */
 public final class ProxyUtils {
 
-    private final static Logger log = LoggerFactory.getLogger(ProxyUtils.class);
+    private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
 
     /**
      * The host to use as proxy.
@@ -120,10 +120,11 @@ public static ProxyServerSelector createProxyServerSelector(Properties propertie
 
             String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
             if (nonProxyHosts != null) {
-                proxyServer.setNonProxyHosts(new ArrayList<String>(Arrays.asList(nonProxyHosts.split("\\|"))));
+                proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
             }
 
-            return createProxyServerSelector(proxyServer.build());
+            ProxyServer proxy = proxyServer.build();
+            return uri -> proxy;
         }
 
         return ProxyServerSelector.NO_PROXY_SELECTOR;
@@ -157,7 +158,7 @@ public ProxyServer select(Uri uri) {
                             switch (proxy.type()) {
                             case HTTP:
                                 if (!(proxy.address() instanceof InetSocketAddress)) {
-                                    log.warn("Don't know how to connect to address " + proxy.address());
+                                    logger.warn("Don't know how to connect to address " + proxy.address());
                                     return null;
                                 } else {
                                     InetSocketAddress address = (InetSocketAddress) proxy.address();
@@ -166,31 +167,17 @@ public ProxyServer select(Uri uri) {
                             case DIRECT:
                                 return null;
                             default:
-                                log.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
+                                logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
                                 break;
                             }
                         }
                     }
                     return null;
                 } catch (URISyntaxException e) {
-                    log.warn(uri + " couldn't be turned into a java.net.URI", e);
+                    logger.warn(uri + " couldn't be turned into a java.net.URI", e);
                     return null;
                 }
             }
         };
     }
-
-    /**
-     * Create a proxy server selector that always selects a single proxy server.
-     *
-     * @param proxyServer The proxy server to select.
-     * @return The proxy server selector.
-     */
-    public static ProxyServerSelector createProxyServerSelector(final ProxyServer proxyServer) {
-        return new ProxyServerSelector() {
-            public ProxyServer select(Uri uri) {
-                return proxyServer;
-            }
-        };
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java b/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java
deleted file mode 100644
index a1cf2192f..000000000
--- a/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-/**
- * A CharSequence String wrapper that doesn't copy the char[] (damn new String implementation!!!)
- * 
- * @author slandelle
- */
-public class StringCharSequence implements CharSequence {
-
-    private final String value;
-    private final int offset;
-    public final int length;
-    
-    public StringCharSequence(String value, int offset, int length) {
-        this.value = value;
-        this.offset = offset;
-        this.length = length;
-    }
-    
-    @Override
-    public int length() {
-        return length;
-    }
-
-    @Override
-    public char charAt(int index) {
-        return value.charAt(offset + index);
-    }
-
-    @Override
-    public CharSequence subSequence(int start, int end) {
-        int offsetedEnd = offset + end;
-        if (offsetedEnd < length)
-            throw new ArrayIndexOutOfBoundsException();
-        return new StringCharSequence(value, offset + start, end - start);
-    }
-    
-    @Override
-    public String toString() {
-        return value.substring(offset, length);
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/StringUtils.java b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
index 10234d87a..f125b2906 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
@@ -18,10 +18,10 @@
 
 public final class StringUtils {
 
-    private static final ThreadLocal<StringBuilder> STRING_BUILDERS = new ThreadLocal<StringBuilder>() {
+    private static final ThreadLocal<StringBuilder> STRING_BUILDER_POOL = new ThreadLocal<StringBuilder>() {
         protected StringBuilder initialValue() {
             return new StringBuilder(512);
-        };
+        }
     };
 
     /**
@@ -29,13 +29,12 @@ protected StringBuilder initialValue() {
      * @return a pooled StringBuilder
      */
     public static StringBuilder stringBuilder() {
-        StringBuilder sb = STRING_BUILDERS.get();
+        StringBuilder sb = STRING_BUILDER_POOL.get();
         sb.setLength(0);
         return sb;
     }
     
     private StringUtils() {
-        // unused
     }
 
     public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
diff --git a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
index 42b6a429a..1907cbe0e 100644
--- a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
@@ -119,11 +119,11 @@ public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
 
     protected abstract String withoutQueryWithParams(final List<Param> queryParams);
 
-    private final String withQuery(final String query, final List<Param> queryParams) {
+    private String withQuery(final String query, final List<Param> queryParams) {
         return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
     }
 
-    private final String withoutQuery(final List<Param> queryParams) {
+    private String withoutQuery(final List<Param> queryParams) {
         return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
     }
 
@@ -140,7 +140,7 @@ public Uri encode(Uri uri, List<Param> queryParams) {
 
     protected abstract String encodePath(String path);
 
-    private final String encodeQuery(final String query, final List<Param> queryParams) {
+    private String encodeQuery(final String query, final List<Param> queryParams) {
         return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
deleted file mode 100644
index 34c495adc..000000000
--- a/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import io.netty.buffer.AbstractByteBuf;
-import io.netty.buffer.ByteBuf;
-import io.netty.util.concurrent.FastThreadLocal;
-
-import java.io.UTFDataFormatException;
-
-public class Utf8Reader {
-
-    private static int SMALL_BUFFER_SIZE = 4096;
-    private static final IndexOutOfBoundsException STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION = new IndexOutOfBoundsException("String decoder index out of bounds");
-
-    private static final FastThreadLocal<char[]> CACHED_CHAR_BUFFERS = new FastThreadLocal<char[]>() {
-        @Override
-        protected char[] initialValue() throws Exception {
-            return new char[SMALL_BUFFER_SIZE];
-        }
-    };
-
-    public static String readUtf8(ByteBuf buf, int utflen) throws UTFDataFormatException, IndexOutOfBoundsException {
-
-        boolean small = utflen <= SMALL_BUFFER_SIZE;
-        char[] chararr = small ? CACHED_CHAR_BUFFERS.get() : new char[utflen];
-
-        int char1, char2, char3;
-        int count = 0, chararr_count = 0;
-
-        if (buf.readableBytes() > utflen) {
-            throw STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION;
-        }
-
-        if (buf instanceof AbstractByteBuf) {
-            AbstractByteBuf b = (AbstractByteBuf) buf;
-            int readerIndex = buf.readerIndex();
-
-            // fast-path
-            while (count < utflen) {
-                char1 = b.getByte(readerIndex + count) & 0xff;
-                if (char1 > 127)
-                    break;
-                count++;
-                chararr[chararr_count++] = (char) char1;
-            }
-
-            while (count < utflen) {
-                char1 = b.getByte(readerIndex + count) & 0xff;
-                switch (char1 >> 4) {
-                case 0:
-                case 1:
-                case 2:
-                case 3:
-                case 4:
-                case 5:
-                case 6:
-                case 7:
-                    /* 0xxxxxxx */
-                    count++;
-                    chararr[chararr_count++] = (char) char1;
-                    break;
-                case 12:
-                case 13:
-                    /* 110x xxxx 10xx xxxx */
-                    count += 2;
-                    if (count > utflen)
-                        throw new UTFDataFormatException("malformed input: partial character at end");
-                    char2 = b.getByte(readerIndex + count - 1);
-                    if ((char2 & 0xC0) != 0x80)
-                        throw new UTFDataFormatException("malformed input around byte " + count);
-                    chararr[chararr_count++] = (char) (((char1 & 0x1F) << 6) | (char2 & 0x3F));
-                    break;
-                case 14:
-                    /* 1110 xxxx 10xx xxxx 10xx xxxx */
-                    count += 3;
-                    if (count > utflen)
-                        throw new UTFDataFormatException("malformed input: partial character at end");
-                    char2 = b.getByte(readerIndex + count - 2);
-                    char3 = b.getByte(readerIndex + count - 1);
-                    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
-                        throw new UTFDataFormatException("malformed input around byte " + (count - 1));
-                    chararr[chararr_count++] = (char) (((char1 & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
-                    break;
-                default:
-                    /* 10xx xxxx, 1111 xxxx */
-                    throw new UTFDataFormatException("malformed input around byte " + count);
-                }
-            }
-
-            buf.readerIndex(buf.readerIndex() + count);
-
-            // The number of chars produced may be less than utflen
-            return new String(chararr, 0, chararr_count);
-
-        } else {
-            byte[] b = new byte[utflen];
-            buf.readBytes(b);
-
-            return new String(b);
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
deleted file mode 100644
index 6a4c04cfc..000000000
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-public final class Utf8UrlDecoder {
-
-    private Utf8UrlDecoder() {
-    }
-
-    private static StringBuilder initSb(StringBuilder sb, String s, int i, int offset, int length) {
-        if (sb != null) {
-            return sb;
-        } else {
-            int initialSbLength = length > 500 ? length / 2 : length;
-            return new StringBuilder(initialSbLength).append(s, offset, i);
-        }
-    }
-
-    private static int hexaDigit(char c) {
-        return Character.digit(c, 16);
-    }
-
-    public static CharSequence decode(String s) {
-        return decode(s, 0, s.length());
-    }
-    
-    public static CharSequence decode(final String s, final int offset, final int length) {
-
-        StringBuilder sb = null;
-        int i = offset;
-        int end = length + offset;
-
-        while (i < end) {
-            char c = s.charAt(i);
-            if (c == '+') {
-                sb = initSb(sb, s, i, offset, length);
-                sb.append(' ');
-                i++;
-
-            } else if (c == '%') {
-                if (end - i < 3) // We expect 3 chars. 0 based i vs. 1 based length!
-                    throw new IllegalArgumentException("UTF8UrlDecoder: Incomplete trailing escape (%) pattern");
-
-                int x, y;
-                if ((x = hexaDigit(s.charAt(i + 1))) == -1 || (y = hexaDigit(s.charAt(i + 2))) == -1)
-                    throw new IllegalArgumentException("UTF8UrlDecoder: Malformed");
-
-                sb = initSb(sb, s, i, offset, length);
-                sb.append((char) (x * 16 + y));
-                i += 3;
-            } else {
-                if (sb != null)
-                    sb.append(c);
-                i++;
-            }
-        }
-
-        return sb != null ? sb.toString() : new StringCharSequence(s, offset, length);
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
index a9903a07f..0859b5f24 100644
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -1,17 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
  *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.util;
 
@@ -194,7 +192,7 @@ private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input,
         return sb;
     }
 
-    private final static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
+    private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
 
         if (value == ' ' && encodeSpaceAsPlus) {
             sb.append('+');
@@ -206,7 +204,7 @@ private final static void appendSingleByteEncoded(StringBuilder sb, int value, b
         sb.append(HEX[value & 0xF]);
     }
 
-    private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
+    private static void appendMultiByteEncoded(StringBuilder sb, int value) {
         if (value < 0x800) {
             appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
             appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index ceffb2747..114b20cc7 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -47,7 +47,7 @@
 
     private HttpResponseStatus status;
     private HttpResponseHeaders headers;
-    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
+    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
 
     /**
      * {@inheritDoc}
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
index 24f075430..ec4ceec1a 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
@@ -17,7 +17,11 @@
 
 /**
  * Invoked when WebSocket binary fragments are received.
+ * 
+ * Actually doesn't do anything, as chunks as assembled into full WebSocket frames.
+ * Will be removed in 2.1.
  */
+@Deprecated
 public interface WebSocketByteFragmentListener extends WebSocketListener {
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
index 1aee42cc7..b818381ba 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
@@ -17,7 +17,11 @@
 
 /**
  * Invoked when WebSocket text fragments are received.
+ * 
+ * Actually doesn't do anything, as chunks as assembled into full WebSocket frames.
+ * Will be removed in 2.1.
  */
+@Deprecated
 public interface WebSocketTextFragmentListener extends WebSocketListener {
 
     /**
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/ahc-default.properties
index d5ebbceca..887e0c93a 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/ahc-default.properties
@@ -3,6 +3,7 @@ org.asynchttpclient.maxConnections=-1
 org.asynchttpclient.maxConnectionsPerHost=-1
 org.asynchttpclient.connectTimeout=5000
 org.asynchttpclient.pooledConnectionIdleTimeout=60000
+org.asynchttpclient.connectionPoolCleanerPeriod=1000
 org.asynchttpclient.readTimeout=60000
 org.asynchttpclient.requestTimeout=60000
 org.asynchttpclient.connectionTtl=-1
@@ -11,6 +12,7 @@ org.asynchttpclient.maxRedirects=5
 org.asynchttpclient.compressionEnforced=false
 org.asynchttpclient.userAgent=AHC/2.0
 org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
+org.asynchttpclient.enabledCipherSuites=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA
 org.asynchttpclient.useProxySelector=false
 org.asynchttpclient.useProxyProperties=false
 org.asynchttpclient.validateResponseHeaders=true
@@ -40,4 +42,4 @@ org.asynchttpclient.keepEncodingHeader=false
 org.asynchttpclient.shutdownQuietPeriod=2000
 org.asynchttpclient.shutdownTimeout=15000
 org.asynchttpclient.useNativeTransport=false
-org.asynchttpclient.usePooledMemory=true
+org.asynchttpclient.ioThreadsCount=0
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index 00e4d7c4c..07ae6a574 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient;
 
 import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index c3de6d21c..de255cdc5 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -421,7 +421,7 @@ public void asyncOptionsTest() throws Throwable {
 
                 final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
 
-                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
+                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST" };
                 Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
                     @Override
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index 35749ff63..7d0132b46 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -25,6 +25,8 @@
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.ConnectException;
 import java.net.UnknownHostException;
 import java.nio.charset.StandardCharsets;
@@ -42,14 +44,20 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import javax.net.ssl.SSLException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.handler.MaxRedirectException;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
 import org.asynchttpclient.request.body.multipart.StringPart;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.asynchttpclient.test.TestUtils.AsyncCompletionHandlerAdapter;
 import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpServer.EchoHandler;
 import org.asynchttpclient.testserver.HttpTest;
+import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
@@ -560,7 +568,7 @@ public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
         withClient().run(client -> {
             withServer(server).run(server -> {
                 final CountDownLatch latch = new CountDownLatch(1);
-                final AtomicReference<String> message = new AtomicReference<String>();
+                final AtomicReference<String> message = new AtomicReference<>();
 
                 server.enqueueOk();
                 client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
@@ -911,4 +919,76 @@ public void requestingPlainHttpEndpointOverHttpsThrowsSslException() throws Thro
             });
         });
     }
+
+    @Test
+    public void postUnboundedInputStreamAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_JSON);
+                server.enqueue(new AbstractHandler() {
+                    EchoHandler chain = new EchoHandler();
+                    @Override
+                    public void handle(String target, org.eclipse.jetty.server.Request request,
+                                       HttpServletRequest httpServletRequest,
+                                       HttpServletResponse httpServletResponse) throws IOException, ServletException {
+                        assertEquals(request.getHeader(TRANSFER_ENCODING), CHUNKED);
+                        assertNull(request.getHeader(CONTENT_LENGTH));
+                        chain.handle(target, request, httpServletRequest, httpServletResponse);
+                    }
+                });
+                server.enqueueEcho();
+
+                client.preparePost(getTargetUrl())//
+                      .setHeaders(h)//
+                      .setBody(new ByteArrayInputStream("{}".getBytes(StandardCharsets.ISO_8859_1)))//
+                      .execute(new AsyncCompletionHandlerAdapter() {
+                          @Override
+                          public Response onCompleted(Response response) throws Exception {
+                              assertEquals(response.getStatusCode(), 200);
+                              assertEquals(response.getResponseBody(), "{}");
+                              return response;
+                          }
+                      }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postInputStreamWithContentLengthAsBodyGenerator() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_JSON);
+                server.enqueue(new AbstractHandler() {
+                    EchoHandler chain = new EchoHandler();
+                    @Override
+                    public void handle(String target, org.eclipse.jetty.server.Request request,
+                                       HttpServletRequest httpServletRequest,
+                                       HttpServletResponse httpServletResponse) throws IOException, ServletException {
+                        assertNull(request.getHeader(TRANSFER_ENCODING));
+                        assertEquals(request.getHeader(CONTENT_LENGTH),//
+                                     Integer.toString("{}".getBytes(StandardCharsets.ISO_8859_1).length));
+                        chain.handle(target, request, httpServletRequest, httpServletResponse);
+                    }
+                });
+
+                byte[] bodyBytes = "{}".getBytes(StandardCharsets.ISO_8859_1);
+                InputStream bodyStream = new ByteArrayInputStream(bodyBytes);
+
+                client.preparePost(getTargetUrl())//
+                      .setHeaders(h)//
+                      .setBody(new InputStreamBodyGenerator(bodyStream, bodyBytes.length))//
+                      .execute(new AsyncCompletionHandlerAdapter() {
+
+                          @Override
+                          public Response onCompleted(Response response) throws Exception {
+                              assertEquals(response.getStatusCode(), 200);
+                              assertEquals(response.getResponseBody(), "{}");
+                              return response;
+                          }
+                      }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
new file mode 100644
index 000000000..760ec2423
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpHeaders.Values.*;
+import static org.asynchttpclient.Dsl.*;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.eclipse.jetty.server.handler.gzip.GzipHandler;
+import org.testng.annotations.Test;
+
+public class EofTerminatedTest extends AbstractBasicTest {
+
+    private static class StreamHandler extends AbstractHandler {
+        @Override
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+            request.getResponse().getHttpOutput().sendContent(EofTerminatedTest.class.getClassLoader().getResourceAsStream("SimpleTextFile.txt"));
+        }
+    }
+
+    protected String getTargetUrl() {
+        return String.format("http://localhost:%d/", port1);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        GzipHandler gzipHandler = new GzipHandler();
+        gzipHandler.setHandler(new StreamHandler());
+        return gzipHandler;
+    }
+
+    @Test(enabled = false)
+    public void testEolTerminatedResponse() throws Exception {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).setHeader(ACCEPT_ENCODING, GZIP_DEFLATE).setHeader(CONNECTION, CLOSE).build()).get();
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 9c25275e0..71e612d46 100644
--- a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -35,9 +35,7 @@ public void testListenableFuture() throws Exception {
                 try {
                     statusCode.set(future.get().getStatusCode());
                     latch.countDown();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                } catch (ExecutionException e) {
+                } catch (InterruptedException | ExecutionException e) {
                     e.printStackTrace();
                 }
             }, Executors.newFixedThreadPool(1));
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 0e94693ce..8156aa0e3 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -75,6 +75,7 @@ public void setUpGlobal() throws Exception {
         server.start();
         port1 = connector.getLocalPort();
         logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
     }
 
     @Test(groups = "online")
@@ -90,12 +91,12 @@ public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
     public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
         try (AsyncHttpClient c = asyncHttpClient()) {
-            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "https://www.microsoft.com/").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
 
-            String anyMicrosoftPage = "http://www.microsoft.com[^:]*:80";
+            String anyMicrosoftPage = "https://www.microsoft.com[^:]*:443";
             String baseUrl = getBaseUrl(response.getUri());
 
             assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
@@ -132,15 +133,18 @@ private static int getPort(Uri uri) {
     // @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+        Exception e = null;
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 404);
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
         } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            e = ex;
         }
+
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
     }
 
     // @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
index 2e01e2854..bc414b140 100644
--- a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
@@ -10,7 +10,6 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
 package org.asynchttpclient;
 
 import static org.asynchttpclient.Dsl.*;
diff --git a/client/src/test/java/org/asynchttpclient/RC10KTest.java b/client/src/test/java/org/asynchttpclient/RC1KTest.java
similarity index 94%
rename from client/src/test/java/org/asynchttpclient/RC10KTest.java
rename to client/src/test/java/org/asynchttpclient/RC1KTest.java
index e0d0fe602..848b37e97 100644
--- a/client/src/test/java/org/asynchttpclient/RC10KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC1KTest.java
@@ -40,12 +40,12 @@
 import org.testng.annotations.Test;
 
 /**
- * Reverse C10K Problem test.
+ * Reverse C1K Problem test.
  * 
  * @author Hubert Iwaniuk
  */
-public class RC10KTest extends AbstractBasicTest {
-    private static final int C10K = 1000;
+public class RC1KTest extends AbstractBasicTest {
+    private static final int C1K = 1000;
     private static final String ARG_HEADER = "Arg";
     private static final int SRV_COUNT = 10;
     protected Server[] servers = new Server[SRV_COUNT];
@@ -89,10 +89,10 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C10K).setKeepAlive(true))) {
-            List<Future<Integer>> resps = new ArrayList<>(C10K);
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C1K).setKeepAlive(true))) {
+            List<Future<Integer>> resps = new ArrayList<>(C1K);
             int i = 0;
-            while (i < C10K) {
+            while (i < C1K) {
                 resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
             }
             i = 0;
diff --git a/client/src/test/java/org/asynchttpclient/RealmTest.java b/client/src/test/java/org/asynchttpclient/RealmTest.java
index 168410af1..c72b6615a 100644
--- a/client/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/client/src/test/java/org/asynchttpclient/RealmTest.java
@@ -71,7 +71,7 @@ private void testOldDigest(String qop) {
         String ha2 = getMd5(method + ":" + uri.getPath());
         String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
 
-        assertEquals(expectedResponse, orig.getResponse());
+        assertEquals(orig.getResponse(), expectedResponse);
     }
 
     @Test(groups = "standalone")
@@ -96,7 +96,7 @@ public void testStrongDigest() {
         String ha2 = getMd5(method + ":" + uri.getPath());
         String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
 
-        assertEquals(expectedResponse, orig.getResponse());
+        assertEquals(orig.getResponse(), expectedResponse);
     }
 
     private String getMd5(String what) {
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index d406748bb..8de3d2b98 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient;
 
 import static org.asynchttpclient.Dsl.*;
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index a9ca03ebb..d978be2a5 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -72,6 +72,7 @@ public void setUpGlobal() throws Exception {
         server.start();
         port1 = connector.getLocalPort();
         logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
     }
 
     @Test(groups = "online")
@@ -96,19 +97,22 @@ public void redirected302Test() throws Exception {
         }
     }
 
-    // @Test(groups = "standalone")
+//     @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
+        
+        Exception e = null;
 
-        // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 404);
+            c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
         } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            e = ex;
         }
+        
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
     }
 
     // @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index a72ecef04..34c8b152b 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -63,8 +63,7 @@ public void testMaxConnectionsWithinThreads() throws Exception {
         final AtomicInteger failedCount = new AtomicInteger();
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
-            for (int i = 0; i < urls.length; i++) {
-                final String url = urls[i];
+            for (final String url : urls) {
                 Thread t = new Thread() {
                     public void run() {
                         client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
@@ -93,8 +92,7 @@ public void onThrowable(Throwable t) {
 
             final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
             failedCount.set(0);
-            for (int i = 0; i < urls.length; i++) {
-                final String url = urls[i];
+            for (final String url : urls) {
                 client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
                     @Override
                     public Response onCompleted(Response response) throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 3304081fd..387d9caac 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -49,8 +49,8 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
             List<ListenableFuture<Response>> futures = new ArrayList<>();
-            for (int i = 0; i < urls.length; i++) {
-                futures.add(client.prepareGet(urls[i]).execute());
+            for (String url : urls) {
+                futures.add(client.prepareGet(url).execute());
             }
 
             boolean caughtError = false;
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
index 1f43328b5..fdb120d88 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.handler.resumable;
 
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler.ResumableProcessor;
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index 6f5bbb33d..9935a853e 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -1,5 +1,3 @@
-package org.asynchttpclient.handler.resumable;
-
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
@@ -12,6 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
+package org.asynchttpclient.handler.resumable;
 
 import static org.testng.Assert.assertEquals;
 
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index 9da7024cf..2fa7e402e 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -1,5 +1,3 @@
-package org.asynchttpclient.handler.resumable;
-
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
@@ -12,6 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
+package org.asynchttpclient.handler.resumable;
 
 import static org.asynchttpclient.Dsl.get;
 import static org.mockito.Matchers.anyObject;
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
index f064c63dd..663143371 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.handler.resumable;
 
 import static org.mockito.Mockito.*;
diff --git a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
index 5fb91a02f..ac51e2a23 100644
--- a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
@@ -10,7 +10,6 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
 package org.asynchttpclient.netty;
 
 import static org.asynchttpclient.Dsl.*;
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 646a8326c..9d02fca7a 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -10,7 +10,6 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
 package org.asynchttpclient.netty;
 
 import static org.testng.Assert.*;
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index 263f3b291..b58644a00 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -79,7 +79,7 @@ public void testRequestTimeout() throws IOException {
 
         try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
             final CountDownLatch latch = new CountDownLatch(samples);
-            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
+            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
 
             for (int i = 0; i < samples; i++) {
                 new Thread(new Runnable() {
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
index 748b10458..6ef118c7d 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.netty;
 
 import static org.testng.Assert.*;
diff --git a/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java b/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
deleted file mode 100644
index 02b303382..000000000
--- a/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.asynchttpclient.netty.util;
-
-import static org.testng.Assert.assertEquals;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.asynchttpclient.util.ByteBufUtils;
-import org.testng.annotations.Test;
-
-public class ByteBufUtilsTest {
-
-    @Test
-    public void testByteBuf2BytesHasBackingArray() {
-        byte[] input = "testdata".getBytes();
-        ByteBuf inputBuf = Unpooled.copiedBuffer(input);
-        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
-        assertEquals(output, input, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
-    }
-
-    @Test
-    public void testByteBuf2BytesNoBackingArray() {
-        ByteBuf inputBuf = Unpooled.directBuffer();
-        byte[] inputBytes = "testdata".getBytes();
-        inputBuf.writeBytes(inputBytes);
-        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
-        assertEquals(output, inputBytes, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
-    }
-
-    @Test
-    public void testByteBufs2BytesEmptyList() {
-        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.emptyList());
-        assertEquals(output, ByteBufUtils.EMPTY_BYTE_ARRAY,
-                "When an empty list is passed to byteBufs2Bytes, an empty byte array should be returned");
-    }
-
-    @Test
-    public void testByteBufs2BytesSize1List() {
-        byte[] inputBytes = "testdata".getBytes();
-        ByteBuf inputBuf = Unpooled.copiedBuffer(inputBytes);
-        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.singletonList(inputBuf));
-        assertEquals(output, inputBytes, "When a list of a single ByteBuf element is passed to byteBufs2Bytes,"
-                + " the returned byte array should contain the bytes in that ByteBUf");
-    }
-
-    @Test
-    public void testByteBufs2Bytes() {
-        byte[] input1 = "testdata".getBytes();
-        byte[] input2 = "testdata2".getBytes();
-        byte[] input3 = "testdata3333".getBytes();
-
-        List<ByteBuf> byteBufList = new LinkedList<>();
-        byteBufList.add(Unpooled.copiedBuffer(input1));
-        byteBufList.add(Unpooled.copiedBuffer(input2));
-        byteBufList.add(Unpooled.copiedBuffer(input3));
-
-        byte[] output = ByteBufUtils.byteBufs2Bytes(byteBufList);
-        assertEquals(output.length, input1.length + input2.length + input3.length,
-                "Returned bytes length should equal the sum of the parts");
-    }
-
-}
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 955e94f74..5f922175c 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -15,10 +15,9 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
@@ -27,13 +26,13 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.commons.io.output.ByteArrayOutputStream;
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.ntlm.NtlmEngine.Type2Message;
 import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.ByteBufUtils;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -97,7 +96,7 @@ public void lazyNTLMAuthTest() throws IOException, InterruptedException, Executi
     public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
         ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
     }
-    
+
     @Test
     public void testGenerateType1Msg() {
         NtlmEngine engine = new NtlmEngine();
@@ -119,73 +118,101 @@ public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrect
         fail("An NtlmEngineException must have occurred as challenge format is not correct");
     }
 
+    private static byte[] longToBytes(long x) {
+        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
+        buffer.putLong(x);
+        return buffer.array();
+    }
+
     @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(3).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeBytes("challenge".getBytes());
+        buf.write(3);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+        buf.write("challenge".getBytes());
         NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
         fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
     }
 
     @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L)); // we want to write a Long
+
         // flags
-        buf.writeByte(0);// unicode support indicator
-        buf.writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);// challenge
+        buf.write(0);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
         NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
         fail("An NtlmEngineException must have occurred as unicode support is not indicated");
     }
 
-    @Test(groups="standalone")
-    public void testGenerateType2Msg(){
+    @Test(groups = "standalone")
+    public void testGenerateType2Msg() {
         Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
         Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
     }
 
     @Test
-    public void testGenerateType3Msg() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3Msg() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(0);
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(0L)); // we want to write a Long
+
         // flags
-        buf.writeByte(1);// unicode support indicator
-        buf.writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);// challenge
+        buf.write(1);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
         NtlmEngine engine = new NtlmEngine();
-        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation",
-                Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
-        assertEquals(type3Msg,
+        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
+        assertEquals(
+                type3Msg,
                 "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
                 "Incorrect type3 message generated");
     }
 
     @Test
     public void testWriteULong() {
-        //test different combinations so that different positions in the byte array will be written
+        // test different combinations so that different positions in the byte array will be written
         byte[] buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 1, 0);
         assertEquals(buffer, new byte[] { 1, 0, 0, 0 }, "Unsigned long value 1 was not written correctly to the buffer");
-        
+
         buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 257, 0);
         assertEquals(buffer, new byte[] { 1, 1, 0, 0 }, "Unsigned long value 257 was not written correctly to the buffer");
-        
+
         buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 16777216, 0);
         assertEquals(buffer, new byte[] { 0, 0, 0, 1 }, "Unsigned long value 16777216 was not written correctly to the buffer");
diff --git a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
index 990047605..9df68ea18 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
@@ -1,17 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
  *
- * This program is licensed to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.oauth;
 
@@ -21,14 +19,12 @@
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.uri.Uri;
 import org.testng.annotations.Test;
 
 /**
@@ -79,12 +75,9 @@ private void testSignatureBaseString(Request request) {
         OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
 
         String signatureBaseString = calc.signatureBaseString(//
-                request.getMethod(),//
-                request.getUri(),//
+                request,//
                 137131201,//
-                "7d8f3e4a",//
-                request.getFormParams(),//
-                request.getQueryParams()).toString();
+                "7d8f3e4a").toString();
 
         assertEquals(signatureBaseString, "POST&" //
                 + "http%3A%2F%2Fexample.com%2Frequest" //
@@ -108,12 +101,9 @@ private void testSignatureBaseStringWithEncodableOAuthToken(Request request) {
         OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
 
         String signatureBaseString = calc.signatureBaseString(//
-                request.getMethod(),//
-                request.getUri(),//
+                request,//
                 137131201,//
-                "ZLc92RAkooZcIO/0cctl0Q==",//
-                request.getFormParams(),//
-                request.getQueryParams()).toString();
+                "ZLc92RAkooZcIO/0cctl0Q==").toString();
 
         assertEquals(signatureBaseString, "POST&" //
                 + "http%3A%2F%2Fexample.com%2Frequest" //
@@ -130,7 +120,7 @@ private void testSignatureBaseStringWithEncodableOAuthToken(Request request) {
                 + "oauth_version%3D1.0");
     }
 
-    @Test(groups = "standalone")
+    @Test
     public void testSignatureBaseStringWithProperlyEncodedUri() {
 
         Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
@@ -142,7 +132,7 @@ public void testSignatureBaseStringWithProperlyEncodedUri() {
         testSignatureBaseStringWithEncodableOAuthToken(request);
     }
 
-    @Test(groups = "standalone")
+    @Test
     public void testSignatureBaseStringWithRawUri() {
 
         // note: @ is legal so don't decode it into %40 because it won't be
@@ -160,32 +150,31 @@ public void testSignatureBaseStringWithRawUri() {
 
     // based on the reference test case from
     // http://oauth.pbwiki.com/TestCases
-    @Test(groups = "standalone")
+    @Test
     public void testGetCalculateSignature() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
         OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
-        List<Param> queryParams = new ArrayList<>();
-        queryParams.add(new Param("file", "vacation.jpg"));
-        queryParams.add(new Param("size", "original"));
-        String url = "http://photos.example.net/photos";
-        String sig = calc.calculateSignature("GET", Uri.create(url), TIMESTAMP, NONCE, null, queryParams);
+
+        Request request = get("http://photos.example.net/photos")//
+                .addQueryParam("file", "vacation.jpg")//
+                .addQueryParam("size", "original")//
+                .build();
+
+        String sig = calc.calculateSignature(request, TIMESTAMP, NONCE);
 
         assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
     }
 
-    @Test(groups = "standalone")
-    public void testPostCalculateSignature() {
+    @Test
+    public void testPostCalculateSignature() throws UnsupportedEncodingException {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
         OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
 
-        List<Param> formParams = new ArrayList<Param>();
-        formParams.add(new Param("file", "vacation.jpg"));
-        formParams.add(new Param("size", "original"));
-        String url = "http://photos.example.net/photos";
-        final Request req = post(url)//
-                .setFormParams(formParams)//
+        final Request req = post("http://photos.example.net/photos")//
+                .addFormParam("file", "vacation.jpg")//
+                .addFormParam("size", "original")//
                 .setSignatureCalculator(calc)//
                 .build();
 
@@ -198,33 +187,24 @@ public void testPostCalculateSignature() {
         // header: OAuth
         // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
 
-        String authHeader = req.getHeaders().get("Authorization");
+        String authHeader = req.getHeaders().get(AUTHORIZATION);
         Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
         assertEquals(m.find(), true);
         String encodedSig = m.group(1);
-        String sig = null;
-        try {
-            sig = URLDecoder.decode(encodedSig, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            fail("bad encoding", e);
-        }
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
 
         assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
     }
 
-    @Test(groups = "standalone")
-    public void testGetWithRequestBuilder() {
+    @Test
+    public void testGetWithRequestBuilder() throws UnsupportedEncodingException {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
         OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
 
-        List<Param> queryParams = new ArrayList<Param>();
-        queryParams.add(new Param("file", "vacation.jpg"));
-        queryParams.add(new Param("size", "original"));
-        String url = "http://photos.example.net/photos";
-
-        final Request req = get(url)//
-                .setQueryParams(queryParams)//
+        final Request req = get("http://photos.example.net/photos")//
+                .addQueryParam("file", "vacation.jpg")//
+                .addQueryParam("size", "original")//
                 .setSignatureCalculator(calc)//
                 .build();
 
@@ -240,30 +220,23 @@ public void testGetWithRequestBuilder() {
         // Authorization header: OAuth
         // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
 
-        String authHeader = req.getHeaders().get("Authorization");
+        String authHeader = req.getHeaders().get(AUTHORIZATION);
         Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
         assertEquals(m.find(), true);
         String encodedSig = m.group(1);
-        String sig = null;
-        try {
-            sig = URLDecoder.decode(encodedSig, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            fail("bad encoding", e);
-        }
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
 
         assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
         assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
     }
 
-    @Test(groups = "standalone")
-    public void testGetWithRequestBuilderAndQuery() {
+    @Test
+    public void testGetWithRequestBuilderAndQuery() throws UnsupportedEncodingException {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
         OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
 
-        String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
-
-        final Request req = get(url)//
+        final Request req = get("http://photos.example.net/photos?file=vacation.jpg&size=original")//
                 .setSignatureCalculator(calc)//
                 .build();
 
@@ -281,14 +254,9 @@ public void testGetWithRequestBuilderAndQuery() {
 
         String authHeader = req.getHeaders().get(AUTHORIZATION);
         Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-        assertEquals(m.find(), true);
+        assertTrue(m.find());
         String encodedSig = m.group(1);
-        String sig = null;
-        try {
-            sig = URLDecoder.decode(encodedSig, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            fail("bad encoding", e);
-        }
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
 
         assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
         assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
@@ -297,24 +265,18 @@ public void testGetWithRequestBuilderAndQuery() {
                 "OAuth oauth_consumer_key=\"dpf43f3p2l4k3l03\", oauth_token=\"nnch734d00sl2jdk\", oauth_signature_method=\"HMAC-SHA1\", oauth_signature=\"tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D\", oauth_timestamp=\"1191242096\", oauth_nonce=\"kllo9940pd9333jh\", oauth_version=\"1.0\"");
     }
 
-    @Test(groups = "standalone")
+    @Test
     public void testWithNullRequestToken() {
-        String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
         ConsumerKey consumer = new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET);
         RequestToken user = new RequestToken(null, null);
         OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
 
-        final Request request = get(url)//
-                .setSignatureCalculator(calc)//
-                .build();
+        final Request request = get("http://photos.example.net/photos?file=vacation.jpg&size=original").build();
 
         String signatureBaseString = calc.signatureBaseString(//
-                request.getMethod(),//
-                request.getUri(),//
+                request,//
                 137131201,//
-                "ZLc92RAkooZcIO/0cctl0Q==",//
-                request.getFormParams(),//
-                request.getQueryParams()).toString();
+                "ZLc92RAkooZcIO/0cctl0Q==").toString();
 
         assertEquals(signatureBaseString, "GET&" + //
                 "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" + //
@@ -324,4 +286,27 @@ public void testWithNullRequestToken() {
                 "oauth_timestamp%3D137131201%26" + //
                 "oauth_version%3D1.0%26size%3Doriginal");
     }
+
+    @Test
+    public void testWithStarQueryParameterValue() {
+        ConsumerKey consumer = new ConsumerKey("key", "secret");
+        RequestToken user = new RequestToken(null, null);
+        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
+
+        final Request request = get("http://term.ie/oauth/example/request_token.php?testvalue=*").build();
+
+        String signatureBaseString = calc.signatureBaseString(//
+                request,//
+                1469019732,//
+                "6ad17f97334700f3ec2df0631d5b7511").toString();
+
+        assertEquals(signatureBaseString, "GET&" + //
+                "http%3A%2F%2Fterm.ie%2Foauth%2Fexample%2Frequest_token.php&"//
+                + "oauth_consumer_key%3Dkey%26"//
+                + "oauth_nonce%3D6ad17f97334700f3ec2df0631d5b7511%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D1469019732%26"//
+                + "oauth_version%3D1.0%26"//
+                + "testvalue%3D%252A");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index f36894f61..1d92babfb 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.reactivestreams;
 
 import java.io.ByteArrayOutputStream;
@@ -71,7 +84,7 @@ public void streamedResponseSmallFileTest() throws Throwable {
         private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
         public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<HttpResponseBodyPart>());
+            this(new SimpleSubscriber<>());
         }
 
         public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
@@ -128,7 +141,7 @@ public SimpleStreamedAsyncHandler onCompleted() throws Exception {
     static protected class SimpleSubscriber<T> implements Subscriber<T> {
         private volatile Subscription subscription;
         private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
         private final CountDownLatch latch = new CountDownLatch(1);
 
         @Override
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index 470873848..7b8dae9f0 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -122,7 +122,7 @@ public void cancelStreamedResponseTest() throws Throwable {
         private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
         public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<HttpResponseBodyPart>());
+            this(new SimpleSubscriber<>());
         }
 
         public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
@@ -176,7 +176,7 @@ public SimpleStreamedAsyncHandler onCompleted() throws Exception {
     static protected class SimpleSubscriber<T> implements Subscriber<T> {
         private volatile Subscription subscription;
         private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
         private final CountDownLatch latch = new CountDownLatch(1);
 
         @Override
@@ -221,7 +221,7 @@ public CancellingStreamedAsyncProvider(int cancelAfter) {
 
         @Override
         public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-            publisher.subscribe(new CancellingSubscriber<HttpResponseBodyPart>(cancelAfter));
+            publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
             return State.CONTINUE;
         }
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
index 052c2d847..5826215b6 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
@@ -10,7 +10,6 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
 package org.asynchttpclient.request.body.generators;
 
 import static org.testng.Assert.assertEquals;
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 2c17496bc..f4dfa3f02 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -34,47 +34,77 @@
 
 public class MultipartBodyTest {
 
-    @Test
-    public void transferWithCopy() throws Exception {
-        try (MultipartBody multipartBody = buildMultipart()) {
-            long tranferred = transferWithCopy(multipartBody);
-            assertEquals(tranferred, multipartBody.getContentLength());
-        }
-    }
+    private static final List<Part> PARTS = new ArrayList<>();
 
-    @Test
-    public void transferZeroCopy() throws Exception {
-        try (MultipartBody multipartBody = buildMultipart()) {
-            long tranferred = transferZeroCopy(multipartBody);
-            assertEquals(tranferred, multipartBody.getContentLength());
+    static {
+        try {
+            PARTS.add(new FilePart("filePart", getTestfile()));
+        } catch (URISyntaxException e) {
+            throw new ExceptionInInitializerError(e);
         }
+        PARTS.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
+        PARTS.add(new StringPart("stringPart", "testString"));
     }
 
-    private File getTestfile() throws URISyntaxException {
+    private static File getTestfile() throws URISyntaxException {
         final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
         final URL url = cl.getResource("textfile.txt");
         assertNotNull(url);
         return new File(url.toURI());
     }
 
-    private MultipartBody buildMultipart() throws URISyntaxException {
-        List<Part> parts = new ArrayList<>();
-        parts.add(new FilePart("filePart", getTestfile()));
-        parts.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
-        parts.add(new StringPart("stringPart", "testString"));
-        return MultipartUtils.newMultipartBody(parts, HttpHeaders.EMPTY_HEADERS);
+    private static long MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE;
+
+    static {
+        try (MultipartBody dummyBody = buildMultipart()) {
+            // separator is random
+            MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE = dummyBody.getContentLength() + 100;
+        } catch (IOException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private static MultipartBody buildMultipart() {
+        return MultipartUtils.newMultipartBody(PARTS, HttpHeaders.EMPTY_HEADERS);
     }
 
-    private long transferWithCopy(MultipartBody multipartBody) throws IOException {
-        final ByteBuf buffer = Unpooled.buffer(8192);
-        while (multipartBody.transferTo(buffer) != BodyState.STOP) {
+    @Test
+    public void transferWithCopy() throws Exception {
+        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+            try (MultipartBody multipartBody = buildMultipart()) {
+                long tranferred = transferWithCopy(multipartBody, bufferLength);
+                assertEquals(tranferred, multipartBody.getContentLength());
+            }
+        }
+    }
+
+    @Test
+    public void transferZeroCopy() throws Exception {
+        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+            try (MultipartBody multipartBody = buildMultipart()) {
+                long tranferred = transferZeroCopy(multipartBody, bufferLength);
+                assertEquals(tranferred, multipartBody.getContentLength());
+            }
+        }
+    }
+
+    private static long transferWithCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
+        long transferred = 0;
+        final ByteBuf buffer = Unpooled.buffer(bufferSize);
+        try {
+            while (multipartBody.transferTo(buffer) != BodyState.STOP) {
+                transferred += buffer.readableBytes();
+                buffer.clear();
+            }
+            return transferred;
+        } finally {
+            buffer.release();
         }
-        return buffer.readableBytes();
     }
 
-    private static long transferZeroCopy(MultipartBody multipartBody) throws IOException {
+    private static long transferZeroCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
 
-        final ByteBuffer buffer = ByteBuffer.allocate(8192);
+        final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
         final AtomicLong transferred = new AtomicLong();
 
         WritableByteChannel mockChannel = new WritableByteChannel() {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
index 24411f3c2..b7b9890ce 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.request.body.multipart.part;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
diff --git a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
index dd024ec3a..ec707ad33 100644
--- a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.test;
 
 import org.eclipse.jetty.server.Request;
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index 5d0bff953..9a5fc201b 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
index e30003d44..a78db7559 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
@@ -43,7 +43,7 @@
     @FunctionalInterface
     public interface HttpServletResponseConsumer {
 
-        public void apply(HttpServletResponse response) throws IOException, ServletException;
+        void apply(HttpServletResponse response) throws IOException, ServletException;
     }
 
     public HttpServer() {
@@ -240,7 +240,7 @@ protected void handle0(String target, Request baseRequest, HttpServletRequest re
             Enumeration<String> parameterNames = request.getParameterNames();
             StringBuilder requestBody = new StringBuilder();
             while (parameterNames.hasMoreElements()) {
-                String param = parameterNames.nextElement().toString();
+                String param = parameterNames.nextElement();
                 response.addHeader("X-" + param, request.getParameter(param));
                 requestBody.append(param);
                 requestBody.append("_");
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
index 69ea3d877..2f3399626 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.uri;
 
 import static org.testng.Assert.*;
diff --git a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
index d5afd7937..cf88947da 100644
--- a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
+++ b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.util;
 
 import static org.testng.Assert.*;
diff --git a/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java b/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
index dcb7d75ea..e239e2a64 100644
--- a/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
+++ b/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
@@ -1,3 +1,16 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
 package org.asynchttpclient.ws;
 
 import org.eclipse.jetty.websocket.api.Session;
diff --git a/client/src/test/resources/logback-test.xml b/client/src/test/resources/logback-test.xml
index 4acf27871..3ddbad848 100644
--- a/client/src/test/resources/logback-test.xml
+++ b/client/src/test/resources/logback-test.xml
@@ -7,7 +7,7 @@
 
     <logger name="org.eclipse" level="INFO"/>
 
-    <root level="debug">
+    <root level="DEBUG">
         <appender-ref ref="CONSOLE"/>
     </root>
-</configuration>
\ No newline at end of file
+</configuration>
diff --git a/example/pom.xml b/example/pom.xml
new file mode 100644
index 000000000..e4a5306d5
--- /dev/null
+++ b/example/pom.xml
@@ -0,0 +1,21 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-project</artifactId>
+        <version>2.0.24-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-example</artifactId>
+    <name>Asynchronous Http Client Example</name>
+    <packaging>jar</packaging>
+    <description>
+        The Async Http Client example.
+    </description>
+    <dependencies>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
new file mode 100644
index 000000000..172876113
--- /dev/null
+++ b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient.example.completable;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+
+public class CompletableFutures {
+    public static void main(String[] args) throws IOException {
+        try(AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
+            asyncHttpClient
+                    .prepareGet("http://www.example.com/")
+                    .execute()
+                    .toCompletableFuture()
+                    .thenApply(Response::getResponseBody)
+                    .thenAccept(System.out::println)
+                    .join();
+        }
+    }
+}
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index e4c4f6704..302b26ee5 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.11-SNAPSHOT</version>
+        <version>2.0.24-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
index 0a7cf3ddd..030936437 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -56,7 +56,7 @@ public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerS
             throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
         }
 
-        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<>(ctx.getAsyncHandler(), available))
                 .build();
     }
 
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index f71e505f6..321b25ad4 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.0.11-SNAPSHOT</version>
+    <version>2.0.24-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index 9c7a744a5..441e0dcd3 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.0.11-SNAPSHOT</version>
+        <version>2.0.24-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 0160f6333..c1e2e9e4d 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.0.11-SNAPSHOT</version>
+		<version>2.0.24-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 2f701f2f7..b0d5a061a 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -49,7 +49,7 @@ public static AsyncHttpClient getAsyncHttpClient() {
 
         try {
             if (attemptInstantiation())
-                return (AsyncHttpClient) asyncHttpClientImplClass.newInstance();
+                return asyncHttpClientImplClass.newInstance();
         } catch (InstantiationException e) {
             throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
                     + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 218cb9808..f252a8e8d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -42,9 +42,7 @@ public static AsyncHttpClientRegistry getInstance() {
                     else
                         _instance = new AsyncHttpClientRegistryImpl();
                 }
-            } catch (InstantiationException e) {
-                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
-            } catch (IllegalAccessException e) {
+            } catch (InstantiationException | IllegalAccessException e) {
                 throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
             } finally {
                 lock.unlock();
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 6261a7acd..de60bd597 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.11-SNAPSHOT</version>
+        <version>2.0.24-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
@@ -12,7 +12,7 @@
         <dependency>
             <groupId>io.reactivex</groupId>
             <artifactId>rxjava</artifactId>
-            <version>1.0.14</version>
+            <version>1.2.1</version>
         </dependency>
     </dependencies>
 </project>
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
index f954f7236..c1a7099db 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
@@ -12,16 +12,18 @@
  */
 package org.asynchttpclient.extras.rxjava;
 
+import java.util.concurrent.CancellationException;
+
 /**
  * Indicates that an {@code Observer} unsubscribed during the processing of a HTTP request.
  */
 @SuppressWarnings("serial")
-public class UnsubscribedException extends RuntimeException {
+public class UnsubscribedException extends CancellationException {
 
     public UnsubscribedException() {
     }
 
     public UnsubscribedException(final Throwable cause) {
-        super(cause);
+        initCause(cause);
     }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
index d244fbba8..4e95aab84 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
@@ -20,10 +20,13 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
+import java.util.concurrent.Future;
+
 import rx.Single;
 import rx.SingleSubscriber;
-import rx.functions.Action1;
 import rx.functions.Func0;
+import rx.functions.Func1;
+import rx.subscriptions.Subscriptions;
 
 /**
  * Wraps HTTP requests into RxJava {@code Single} instances.
@@ -54,14 +57,17 @@
      *
      * @param requestTemplate called to start the HTTP request with an
      *            {@code AysncHandler} that builds the HTTP response and
-     *            propagates results to the returned {@code Single}
+     *            propagates results to the returned {@code Single}. The
+     *            {@code Future} that is returned by {@code requestTemplate}
+     *            will be used to cancel the request when the {@code Single} is
+     *            unsubscribed.
      *
      * @return a {@code Single} that executes new requests on subscription by
      *         calling {@code requestTemplate} and that emits the response
      *
      * @throws NullPointerException if {@code requestTemplate} is {@code null}
      */
-    public static Single<Response> create(Action1<? super AsyncHandler<?>> requestTemplate) {
+    public static Single<Response> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate) {
         return create(requestTemplate, AsyncCompletionHandlerBase::new);
     }
 
@@ -92,7 +98,10 @@
      *
      * @param requestTemplate called to start the HTTP request with an
      *            {@code AysncHandler} that builds the HTTP response and
-     *            propagates results to the returned {@code Single}
+     *            propagates results to the returned {@code Single}.  The
+     *            {@code Future} that is returned by {@code requestTemplate}
+     *            will be used to cancel the request when the {@code Single} is
+     *            unsubscribed.
      * @param handlerSupplier supplies the desired {@code AsyncHandler}
      *            instances that are used to produce results
      *
@@ -104,13 +113,17 @@
      * @throws NullPointerException if at least one of the parameters is
      *             {@code null}
      */
-    public static <T> Single<T> create(Action1<? super AsyncHandler<?>> requestTemplate,
+    public static <T> Single<T> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate,
             Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
 
         requireNonNull(requestTemplate);
         requireNonNull(handlerSupplier);
 
-        return Single.create(subscriber -> requestTemplate.call(createBridge(subscriber, handlerSupplier.call())));
+        return Single.create(subscriber -> {
+            final AsyncHandler<?> bridge = createBridge(subscriber, handlerSupplier.call());
+            final Future<?> responseFuture = requestTemplate.call(bridge);
+            subscriber.add(Subscriptions.from(responseFuture));
+        });
     }
 
     static <T> AsyncHandler<?> createBridge(SingleSubscriber<? super T> subscriber, AsyncHandler<? extends T> handler) {
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
index d0039bc73..55ae64c15 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
@@ -18,6 +18,7 @@
 import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
@@ -25,6 +26,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 import static org.testng.Assert.assertEquals;
 
@@ -34,13 +36,16 @@
 import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.extras.rxjava.UnsubscribedException;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.mockito.InOrder;
 import org.testng.annotations.Test;
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import rx.Single;
 import rx.exceptions.CompositeException;
@@ -61,6 +66,7 @@ public void testFailsOnNullHandlerSupplier() {
     @Test(groups = "standalone")
     public void testSuccessfulCompletion() throws Exception {
 
+        @SuppressWarnings("unchecked")
         final AsyncHandler<Object> handler = mock(AsyncHandler.class);
         when(handler.onCompleted()).thenReturn(handler);
 
@@ -82,6 +88,8 @@ public void testSuccessfulCompletion() throws Exception {
             } catch (final Throwable t) {
                 bridge.onThrowable(t);
             }
+
+            return mock(Future.class);
         } , () -> handler);
 
         final TestSubscriber<Object> subscriber = new TestSubscriber<>();
@@ -99,6 +107,7 @@ public void testSuccessfulCompletion() throws Exception {
     @Test(groups = "standalone")
     public void testSuccessfulCompletionWithProgress() throws Exception {
 
+        @SuppressWarnings("unchecked")
         final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
         when(handler.onCompleted()).thenReturn(handler);
         final InOrder inOrder = inOrder(handler);
@@ -132,6 +141,8 @@ public void testSuccessfulCompletionWithProgress() throws Exception {
             } catch (final Throwable t) {
                 bridge.onThrowable(t);
             }
+
+            return mock(Future.class);
         } , () -> handler);
 
         final TestSubscriber<Object> subscriber = new TestSubscriber<>();
@@ -162,6 +173,7 @@ public void testNewRequestForEachSubscription() throws Exception {
     public void testErrorPropagation() throws Exception {
 
         final RuntimeException expectedException = new RuntimeException("expected");
+        @SuppressWarnings("unchecked")
         final AsyncHandler<Object> handler = mock(AsyncHandler.class);
         when(handler.onCompleted()).thenReturn(handler);
         final InOrder inOrder = inOrder(handler);
@@ -186,6 +198,8 @@ public void testErrorPropagation() throws Exception {
             } catch (final Throwable t) {
                 bridge.onThrowable(t);
             }
+
+            return mock(Future.class);
         } , () -> handler);
 
         final TestSubscriber<Object> subscriber = new TestSubscriber<>();
@@ -203,12 +217,14 @@ public void testErrorPropagation() throws Exception {
     public void testErrorInOnCompletedPropagation() throws Exception {
 
         final RuntimeException expectedException = new RuntimeException("expected");
+        @SuppressWarnings("unchecked")
         final AsyncHandler<Object> handler = mock(AsyncHandler.class);
         when(handler.onCompleted()).thenThrow(expectedException);
 
         final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
             try {
                 bridge.onCompleted();
+                return mock(Future.class);
             } catch (final Throwable t) {
                 throw new AssertionError(t);
             }
@@ -231,12 +247,14 @@ public void testErrorInOnThrowablePropagation() throws Exception {
 
         final RuntimeException processingException = new RuntimeException("processing");
         final RuntimeException thrownException = new RuntimeException("thrown");
+        @SuppressWarnings("unchecked")
         final AsyncHandler<Object> handler = mock(AsyncHandler.class);
         doThrow(thrownException).when(handler).onThrowable(processingException);
 
         final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
             try {
                 bridge.onThrowable(processingException);
+                return mock(Future.class);
             } catch (final Throwable t) {
                 throw new AssertionError(t);
             }
@@ -281,4 +299,24 @@ public State onStatusReceived(HttpResponseStatus status) {
         subscriber.assertValue(null);
     }
 
+    @Test(groups = "standalone")
+    public void testUnsubscribe() throws Exception {
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        final Future<?> future = mock(Future.class);
+        final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
+
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            bridgeRef.set(bridge);
+            return future;
+        } , () -> handler);
+
+        underTest.subscribe().unsubscribe();
+        verify(future).cancel(true);
+        verifyZeroInteractions(handler);
+
+        assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
+        verify(handler).onThrowable(isA(UnsubscribedException.class));
+        verifyNoMoreInteractions(handler);
+    }
 }
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 4485c9475..14b14bc29 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.11-SNAPSHOT</version>
+        <version>2.0.24-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index fee51be4f..2f6e79f33 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -366,7 +366,7 @@ public DerivedBuilder derive() {
          * Omit error documents. An error document will neither be available in
          * the response nor written via a {@link BodyConsumer}.
          */
-        OMIT;
+        OMIT
     }
 
     /**
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
index 75bf8e517..b02b8c2f1 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
@@ -157,7 +157,7 @@ public void testDeriveOverrideURL() throws Exception {
     @Test(groups = "standalone")
     public void testSimpleTransferListener() throws Exception {
 
-        final List<Error> errors = Collections.synchronizedList(new ArrayList<Error>());
+        final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
 
         SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
 
diff --git a/netty-bp/codec-dns/pom.xml b/netty-bp/codec-dns/pom.xml
index 8d8c09bea..d57b1ca86 100644
--- a/netty-bp/codec-dns/pom.xml
+++ b/netty-bp/codec-dns/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.11-SNAPSHOT</version>
+    <version>2.0.24-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-codec-dns</artifactId>
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
index efa291406..1a733f437 100644
--- a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
@@ -88,9 +88,14 @@ protected DnsRecord decodeRecord(
             String name, DnsRecordType type, int dnsClass, long timeToLive,
             ByteBuf in, int offset, int length) throws Exception {
 
+        // DNS message compression means that domain names may contain "pointers" to other positions in the packet
+        // to build a full message. This means the indexes are meaningful and we need the ability to reference the
+        // indexes un-obstructed, and thus we cannot use a slice here.
+        // See https://www.ietf.org/rfc/rfc1035 [4.1.4. Message compression]
         if (type == DnsRecordType.PTR) {
             in.setIndex(offset, offset + length);
-            return new DefaultDnsPtrRecord(name, dnsClass, timeToLive, decodeName0(in));
+            return new DefaultDnsPtrRecord(
+                    name, dnsClass, timeToLive, decodeName0(in.duplicate().setIndex(offset, offset + length)));
         }
         return new DefaultDnsRawRecord(
                 name, type, dnsClass, timeToLive, in.duplicate().setIndex(offset, offset + length).retain());
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
index 3222566e0..2eb61a444 100644
--- a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
@@ -85,7 +85,7 @@ protected void encodeName(String name, ByteBuf buf) throws Exception {
             return;
         }
 
-        final String[] labels = StringUtil.split(name, '.');
+        final String[] labels = name.split("\\.");
         for (String label : labels) {
             final int labelLen = label.length();
             if (labelLen == 0) {
diff --git a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java
index 6004d713a..244422fcd 100644
--- a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java
+++ b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java
@@ -17,10 +17,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.util.internal.StringUtil;
-import org.junit.Assert;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
+
 public class DefaultDnsRecordDecoderTest {
 
     @Test
@@ -63,7 +63,27 @@ public void testDecodeEmptyNameFromExtraZeroes() {
     private static void testDecodeName(String expected, ByteBuf buffer) {
         try {
             DefaultDnsRecordDecoder decoder = new DefaultDnsRecordDecoder();
-            Assert.assertEquals(expected, decoder.decodeName(buffer));
+            assertEquals(expected, decoder.decodeName0(buffer));
+        } finally {
+            buffer.release();
+        }
+    }
+
+    @Test
+    public void testDecodePtrRecord() throws Exception {
+        DefaultDnsRecordDecoder decoder = new DefaultDnsRecordDecoder();
+        ByteBuf buffer = Unpooled.buffer().writeByte(0);
+        int readerIndex = buffer.readerIndex();
+        int writerIndex = buffer.writerIndex();
+        try {
+            DnsPtrRecord record = (DnsPtrRecord) decoder.decodeRecord(
+                    "netty.io", DnsRecordType.PTR, DnsRecord.CLASS_IN, 60, buffer, 0, 1);
+            assertEquals("netty.io.", record.name());
+            assertEquals(DnsRecord.CLASS_IN, record.dnsClass());
+            assertEquals(60, record.timeToLive());
+            assertEquals(DnsRecordType.PTR, record.type());
+            assertEquals(readerIndex, buffer.readerIndex());
+            assertEquals(writerIndex, buffer.writerIndex());
         } finally {
             buffer.release();
         }
diff --git a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java
index 08c0896d5..ac8b5b65e 100644
--- a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java
+++ b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.util.internal.StringUtil;
 import org.junit.Test;
@@ -63,4 +62,72 @@ private static void testEncodeName(byte[] expected, String name) throws Exceptio
             expectedBuf.release();
         }
     }
+    
+    @Test
+    public void testDecodeMessageCompression() throws Exception {
+        // See https://www.ietf.org/rfc/rfc1035 [4.1.4. Message compression]
+        DefaultDnsRecordDecoder decoder = new DefaultDnsRecordDecoder();
+        byte[] rfcExample = new byte[] { 1, 'F', 3, 'I', 'S', 'I', 4, 'A', 'R', 'P', 'A',
+                0, 3, 'F', 'O', 'O',
+                (byte) 0xC0, 0, // this is 20 in the example
+                (byte) 0xC0, 6, // this is 26 in the example
+        };
+        DefaultDnsRawRecord rawPlainRecord = null;
+        DefaultDnsRawRecord rawUncompressedRecord = null;
+        DefaultDnsRawRecord rawUncompressedIndexedRecord = null;
+        ByteBuf buffer = Unpooled.wrappedBuffer(rfcExample);
+        try {
+            // First lets test that our utility funciton can correctly handle index references and decompression.
+            String plainName = DefaultDnsRecordDecoder.decodeName(buffer.duplicate());
+            assertEquals("F.ISI.ARPA.", plainName);
+            String uncompressedPlainName = DefaultDnsRecordDecoder.decodeName(buffer.duplicate().setIndex(16, 20));
+            assertEquals(plainName, uncompressedPlainName);
+            String uncompressedIndexedName = DefaultDnsRecordDecoder.decodeName(buffer.duplicate().setIndex(12, 20));
+            assertEquals("FOO." + plainName, uncompressedIndexedName);
+
+            // Now lets make sure out object parsing produces the same results for non PTR type (just use CNAME).
+            rawPlainRecord = (DefaultDnsRawRecord) decoder.decodeRecord(
+                    plainName, DnsRecordType.CNAME, DnsRecord.CLASS_IN, 60, buffer, 0, 11);
+            assertEquals(plainName, rawPlainRecord.name());
+            assertEquals(plainName, DefaultDnsRecordDecoder.decodeName(rawPlainRecord.content()));
+
+            rawUncompressedRecord = (DefaultDnsRawRecord) decoder.decodeRecord(
+                    uncompressedPlainName, DnsRecordType.CNAME, DnsRecord.CLASS_IN, 60, buffer, 16, 4);
+            assertEquals(uncompressedPlainName, rawUncompressedRecord.name());
+            assertEquals(uncompressedPlainName, DefaultDnsRecordDecoder.decodeName(rawUncompressedRecord.content()));
+
+            rawUncompressedIndexedRecord = (DefaultDnsRawRecord) decoder.decodeRecord(
+                    uncompressedIndexedName, DnsRecordType.CNAME, DnsRecord.CLASS_IN, 60, buffer, 12, 8);
+            assertEquals(uncompressedIndexedName, rawUncompressedIndexedRecord.name());
+            assertEquals(uncompressedIndexedName,
+                         DefaultDnsRecordDecoder.decodeName(rawUncompressedIndexedRecord.content()));
+
+            // Now lets make sure out object parsing produces the same results for PTR type.
+            DnsPtrRecord ptrRecord = (DnsPtrRecord) decoder.decodeRecord(
+                    plainName, DnsRecordType.PTR, DnsRecord.CLASS_IN, 60, buffer, 0, 11);
+            assertEquals(plainName, ptrRecord.name());
+            assertEquals(plainName, ptrRecord.hostname());
+
+            ptrRecord = (DnsPtrRecord) decoder.decodeRecord(
+                    uncompressedPlainName, DnsRecordType.PTR, DnsRecord.CLASS_IN, 60, buffer, 16, 4);
+            assertEquals(uncompressedPlainName, ptrRecord.name());
+            assertEquals(uncompressedPlainName, ptrRecord.hostname());
+
+            ptrRecord = (DnsPtrRecord) decoder.decodeRecord(
+                    uncompressedIndexedName, DnsRecordType.PTR, DnsRecord.CLASS_IN, 60, buffer, 12, 8);
+            assertEquals(uncompressedIndexedName, ptrRecord.name());
+            assertEquals(uncompressedIndexedName, ptrRecord.hostname());
+        } finally {
+            if (rawPlainRecord != null) {
+                rawPlainRecord.release();
+            }
+            if (rawUncompressedRecord != null) {
+                rawUncompressedRecord.release();
+            }
+            if (rawUncompressedIndexedRecord != null) {
+                rawUncompressedIndexedRecord.release();
+            }
+            buffer.release();
+        }
+    }
 }
diff --git a/netty-bp/pom.xml b/netty-bp/pom.xml
index f5921b03d..4994aeed7 100644
--- a/netty-bp/pom.xml
+++ b/netty-bp/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.11-SNAPSHOT</version>
+		<version>2.0.24-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>netty-bp</artifactId>
diff --git a/netty-bp/resolver-dns/pom.xml b/netty-bp/resolver-dns/pom.xml
index b3e6beebf..a8d09e9d9 100644
--- a/netty-bp/resolver-dns/pom.xml
+++ b/netty-bp/resolver-dns/pom.xml
@@ -9,7 +9,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>netty-bp</artifactId>
-		<version>2.0.11-SNAPSHOT</version>
+		<version>2.0.24-SNAPSHOT</version>
 	</parent>
 
 	<artifactId>netty-resolver-dns</artifactId>
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
index 15e5ce288..27520555a 100644
--- a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
@@ -42,10 +42,13 @@
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.StringUtil2;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.lang.reflect.Method;
 import java.net.IDN;
 import java.net.Inet4Address;
 import java.net.InetAddress;
@@ -67,6 +70,7 @@
     private static final InetAddress LOCALHOST_ADDRESS;
 
     static final InternetProtocolFamily[] DEFAULT_RESOLVE_ADDRESS_TYPES = new InternetProtocolFamily[2];
+    static final String[] DEFAULT_SEACH_DOMAINS;
 
     static {
         // Note that we did not use SystemPropertyUtil.getBoolean() here to emulate the behavior of JDK.
@@ -83,6 +87,24 @@
         }
     }
 
+    static {
+        String[] searchDomains;
+        try {
+            Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");
+            Method open = configClass.getMethod("open");
+            Method nameservers = configClass.getMethod("searchlist");
+            Object instance = open.invoke(null);
+
+            @SuppressWarnings("unchecked")
+            List<String> list = (List<String>) nameservers.invoke(instance);
+            searchDomains = list.toArray(new String[list.size()]);
+        } catch (Exception ignore) {
+            // Failed to get the system name search domain list.
+            searchDomains = EmptyArrays.EMPTY_STRINGS;
+        }
+        DEFAULT_SEACH_DOMAINS = searchDomains;
+    }
+
     private static final DatagramDnsResponseDecoder DECODER = new DatagramDnsResponseDecoder();
     private static final DatagramDnsQueryEncoder ENCODER = new DatagramDnsQueryEncoder();
 
@@ -116,6 +138,8 @@ protected DnsServerAddressStream initialValue() throws Exception {
     private final int maxPayloadSize;
     private final boolean optResourceEnabled;
     private final HostsFileEntriesResolver hostsFileEntriesResolver;
+    private final String[] searchDomains;
+    private final int ndots;
 
     /**
      * Creates a new DNS-based name resolver that communicates with the specified list of DNS servers.
@@ -134,6 +158,8 @@ protected DnsServerAddressStream initialValue() throws Exception {
      * @param maxPayloadSize the capacity of the datagram packet buffer
      * @param optResourceEnabled if automatic inclusion of a optional records is enabled
      * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to check for local aliases
+     * @param searchDomains the list of search domain
+     * @param ndots the ndots value
      */
     public DnsNameResolver(
             EventLoop eventLoop,
@@ -147,7 +173,9 @@ public DnsNameResolver(
             boolean traceEnabled,
             int maxPayloadSize,
             boolean optResourceEnabled,
-            HostsFileEntriesResolver hostsFileEntriesResolver) {
+            HostsFileEntriesResolver hostsFileEntriesResolver,
+            String[] searchDomains,
+            int ndots) {
 
         super(eventLoop);
         checkNotNull(channelFactory, "channelFactory");
@@ -161,6 +189,8 @@ public DnsNameResolver(
         this.optResourceEnabled = optResourceEnabled;
         this.hostsFileEntriesResolver = checkNotNull(hostsFileEntriesResolver, "hostsFileEntriesResolver");
         this.resolveCache = resolveCache;
+        this.searchDomains = checkNotNull(searchDomains, "searchDomains").clone();
+        this.ndots = checkPositiveOrZero(ndots, "ndots");
 
         Bootstrap b = new Bootstrap();
         b.group(executor());
@@ -214,6 +244,14 @@ public long queryTimeoutMillis() {
         return resolvedAddressTypes;
     }
 
+    final String[] searchDomains() {
+        return searchDomains;
+    }
+
+    final int ndots() {
+        return ndots;
+    }
+
     /**
      * Returns {@code true} if and only if this resolver sends a DNS query with the RD (recursion desired) flag set.
      * The default value is {@code true}.
@@ -375,25 +413,37 @@ private static void setSuccess(Promise<InetAddress> promise, InetAddress result)
     private void doResolveUncached(String hostname,
                                    Promise<InetAddress> promise,
                                    DnsCache resolveCache) {
-        final DnsNameResolverContext<InetAddress> ctx =
-                new DnsNameResolverContext<InetAddress>(this, hostname, promise, resolveCache) {
-                    @Override
-                    protected boolean finishResolve(
-                            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries) {
-
-                        final int numEntries = resolvedEntries.size();
-                        for (int i = 0; i < numEntries; i++) {
-                            final InetAddress a = resolvedEntries.get(i).address();
-                            if (addressMatchFamily(a, f)) {
-                                setSuccess(promise(), a);
-                                return true;
-                            }
-                        }
-                        return false;
-                    }
-                };
+        SingleResolverContext ctx = new SingleResolverContext(this, hostname, resolveCache);
+        ctx.resolve(promise);
+    }
+
+    final class SingleResolverContext extends DnsNameResolverContext<InetAddress> {
+
+        SingleResolverContext(DnsNameResolver parent, String hostname, DnsCache resolveCache) {
+            super(parent, hostname, resolveCache);
+        }
 
-        ctx.resolve();
+        @Override
+        DnsNameResolverContext<InetAddress> newResolverContext(DnsNameResolver parent,
+                                                                         String hostname, DnsCache resolveCache) {
+            return new SingleResolverContext(parent, hostname, resolveCache);
+        }
+
+        @Override
+        boolean finishResolve(
+                InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries,
+            Promise<InetAddress> promise) {
+
+            final int numEntries = resolvedEntries.size();
+            for (int i = 0; i < numEntries; i++) {
+                final InetAddress a = resolvedEntries.get(i).address();
+                if (addressMatchFamily(a, f)) {
+                    setSuccess(promise, a);
+                    return true;
+                }
+            }
+            return false;
+        }
     }
 
     @Override
@@ -471,40 +521,56 @@ private boolean doResolveAllCached(String hostname,
         return true;
     }
 
-    private void doResolveAllUncached(final String hostname,
-                                      final Promise<List<InetAddress>> promise,
-                                      DnsCache resolveCache) {
-        final DnsNameResolverContext<List<InetAddress>> ctx =
-                new DnsNameResolverContext<List<InetAddress>>(this, hostname, promise, resolveCache) {
-                    @Override
-                    protected boolean finishResolve(
-                            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries) {
-
-                        List<InetAddress> result = null;
-                        final int numEntries = resolvedEntries.size();
-                        for (int i = 0; i < numEntries; i++) {
-                            final InetAddress a = resolvedEntries.get(i).address();
-                            if (addressMatchFamily(a, f)) {
-                                if (result == null) {
-                                    result = new ArrayList<InetAddress>(numEntries);
-                                }
-                                result.add(a);
-                            }
-                        }
+    final class ListResolverContext extends DnsNameResolverContext<List<InetAddress>> {
+        ListResolverContext(DnsNameResolver parent, String hostname, DnsCache resolveCache) {
+            super(parent, hostname, resolveCache);
+        }
 
-                        if (result != null) {
-                            promise().trySuccess(result);
-                            return true;
-                        }
-                        return false;
+        @Override
+        DnsNameResolverContext<List<InetAddress>> newResolverContext(DnsNameResolver parent, String hostname,
+                                                                               DnsCache resolveCache) {
+            return new ListResolverContext(parent, hostname, resolveCache);
+        }
+
+        @Override
+        boolean finishResolve(
+            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries,
+            Promise<List<InetAddress>> promise) {
+
+            List<InetAddress> result = null;
+            final int numEntries = resolvedEntries.size();
+            for (int i = 0; i < numEntries; i++) {
+                final InetAddress a = resolvedEntries.get(i).address();
+                if (addressMatchFamily(a, f)) {
+                    if (result == null) {
+                        result = new ArrayList<InetAddress>(numEntries);
                     }
-                };
+                    result.add(a);
+                }
+            }
+
+            if (result != null) {
+                promise.trySuccess(result);
+                return true;
+            }
+            return false;
+        }
+    }
 
-        ctx.resolve();
+    private void doResolveAllUncached(String hostname,
+                                      Promise<List<InetAddress>> promise,
+                                      DnsCache resolveCache) {
+        DnsNameResolverContext<List<InetAddress>> ctx = new ListResolverContext(this, hostname, resolveCache);
+        ctx.resolve(promise);
     }
 
     private static String hostname(String inetHost) {
-        return IDN.toASCII(inetHost);
+        String hostname = IDN.toASCII(inetHost);
+        // Check for http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6894622
+        if (StringUtil2.endsWith(inetHost, '.') && !StringUtil2.endsWith(hostname, '.')) {
+            hostname += ".";
+        }
+        return hostname;
     }
 
     /**
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
index 3b7e2238d..338662480 100644
--- a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
@@ -49,6 +49,8 @@
     private int maxPayloadSize = 4096;
     private boolean optResourceEnabled = true;
     private HostsFileEntriesResolver hostsFileEntriesResolver = HostsFileEntriesResolver.DEFAULT;
+    private String[] searchDomains = DnsNameResolver.DEFAULT_SEACH_DOMAINS;
+    private int ndots = 1;
 
     /**
      * Creates a new builder.
@@ -286,6 +288,47 @@ public DnsNameResolverBuilder hostsFileEntriesResolver(HostsFileEntriesResolver
         return this;
     }
 
+    /**
+     * Set the list of search domains of the resolver.
+     *
+     * @param searchDomains the search domains
+     * @return {@code this}
+     */
+    public DnsNameResolverBuilder searchDomains(Iterable<String> searchDomains) {
+        checkNotNull(searchDomains, "searchDomains");
+
+        final List<String> list =
+            InternalThreadLocalMap.get().arrayList(4);
+
+        for (String f : searchDomains) {
+            if (f == null) {
+                break;
+            }
+
+            // Avoid duplicate entries.
+            if (list.contains(f)) {
+                continue;
+            }
+
+            list.add(f);
+        }
+
+        this.searchDomains = list.toArray(new String[list.size()]);
+        return this;
+    }
+
+  /**
+   * Set the number of dots which must appear in a name before an initial absolute query is made.
+   * The default value is {@code 1}.
+   *
+   * @param ndots the ndots value
+   * @return {@code this}
+   */
+    public DnsNameResolverBuilder ndots(int ndots) {
+        this.ndots = ndots;
+        return this;
+    }
+
     /**
      * Returns a new {@link DnsNameResolver} instance.
      *
@@ -312,6 +355,8 @@ public DnsNameResolver build() {
                 traceEnabled,
                 maxPayloadSize,
                 optResourceEnabled,
-                hostsFileEntriesResolver);
+                hostsFileEntriesResolver,
+                searchDomains,
+                ndots);
     }
 }
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
index a91f8e217..7c663f7ae 100644
--- a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
@@ -35,6 +35,7 @@
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.Promise;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.StringUtil2;
 
 import java.net.Inet4Address;
 import java.net.Inet6Address;
@@ -68,8 +69,8 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
 
     private final DnsNameResolver parent;
     private final DnsServerAddressStream nameServerAddrs;
-    private final Promise<T> promise;
     private final String hostname;
+    protected String pristineHostname;
     private final DnsCache resolveCache;
     private final boolean traceEnabled;
     private final int maxAllowedQueries;
@@ -86,10 +87,8 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
 
     protected DnsNameResolverContext(DnsNameResolver parent,
                                      String hostname,
-                                     Promise<T> promise,
                                      DnsCache resolveCache) {
         this.parent = parent;
-        this.promise = promise;
         this.hostname = hostname;
         this.resolveCache = resolveCache;
 
@@ -100,11 +99,49 @@ protected DnsNameResolverContext(DnsNameResolver parent,
         allowedQueries = maxAllowedQueries;
     }
 
-    protected Promise<T> promise() {
-        return promise;
+    void resolve(Promise<T> promise) {
+        boolean directSearch = parent.searchDomains().length == 0 || StringUtil2.endsWith(hostname, '.');
+        if (directSearch) {
+            internalResolve(promise);
+        } else {
+            final Promise<T> original = promise;
+            promise = parent.executor().newPromise();
+            promise.addListener(new FutureListener<T>() {
+                int count;
+                @Override
+                public void operationComplete(Future<T> future) throws Exception {
+                    if (future.isSuccess()) {
+                        original.trySuccess(future.getNow());
+                    } else if (count < parent.searchDomains().length) {
+                        String searchDomain = parent.searchDomains()[count++];
+                        Promise<T> nextPromise = parent.executor().newPromise();
+                        String nextHostname = DnsNameResolverContext.this.hostname + "." + searchDomain;
+                        DnsNameResolverContext<T> nextContext = newResolverContext(parent,
+                            nextHostname, resolveCache);
+                        nextContext.pristineHostname = hostname;
+                        nextContext.internalResolve(nextPromise);
+                        nextPromise.addListener(this);
+                    } else {
+                        original.tryFailure(future.cause());
+                    }
+                }
+            });
+            if (parent.ndots() == 0) {
+                internalResolve(promise);
+            } else {
+                int dots = 0;
+                for (int idx = hostname.length() - 1; idx >= 0; idx--) {
+                    if (hostname.charAt(idx) == '.' && ++dots >= parent.ndots()) {
+                        internalResolve(promise);
+                        return;
+                    }
+                 }
+                 promise.tryFailure(new UnknownHostException(hostname));
+             }
+        }
     }
 
-    void resolve() {
+    private void internalResolve(Promise<T> promise) {
         InetSocketAddress nameServerAddrToTry = nameServerAddrs.next();
         for (InternetProtocolFamily f: resolveAddressTypes) {
             final DnsRecordType type;
@@ -119,13 +156,13 @@ void resolve() {
                 throw new Error();
             }
 
-            query(nameServerAddrToTry, new DefaultDnsQuestion(hostname, type));
+            query(nameServerAddrToTry, new DefaultDnsQuestion(hostname, type), promise);
         }
     }
 
-    private void query(InetSocketAddress nameServerAddr, final DnsQuestion question) {
+    private void query(InetSocketAddress nameServerAddr, final DnsQuestion question, final Promise<T> promise) {
         if (allowedQueries == 0 || promise.isCancelled()) {
-            tryToFinishResolve();
+            tryToFinishResolve(promise);
             return;
         }
 
@@ -145,31 +182,32 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
 
                 try {
                     if (future.isSuccess()) {
-                        onResponse(question, future.getNow());
+                        onResponse(question, future.getNow(), promise);
                     } else {
                         // Server did not respond or I/O error occurred; try again.
                         if (traceEnabled) {
                             addTrace(future.cause());
                         }
-                        query(nameServerAddrs.next(), question);
+                        query(nameServerAddrs.next(), question, promise);
                     }
                 } finally {
-                    tryToFinishResolve();
+                    tryToFinishResolve(promise);
                 }
             }
         });
     }
 
-    void onResponse(final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
+    void onResponse(final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,
+                    Promise<T> promise) {
         try {
             final DnsResponse res = envelope.content();
             final DnsResponseCode code = res.code();
             if (code == DnsResponseCode.NOERROR) {
                 final DnsRecordType type = question.type();
                 if (type == DnsRecordType.A || type == DnsRecordType.AAAA) {
-                    onResponseAorAAAA(type, question, envelope);
+                    onResponseAorAAAA(type, question, envelope, promise);
                 } else if (type == DnsRecordType.CNAME) {
-                    onResponseCNAME(question, envelope);
+                    onResponseCNAME(question, envelope, promise);
                 }
                 return;
             }
@@ -182,7 +220,7 @@ void onResponse(final DnsQuestion question, AddressedEnvelope<DnsResponse, InetS
 
             // Retry with the next server if the server did not tell us that the domain does not exist.
             if (code != DnsResponseCode.NXDOMAIN) {
-                query(nameServerAddrs.next(), question);
+                query(nameServerAddrs.next(), question, promise);
             }
         } finally {
             ReferenceCountUtil.safeRelease(envelope);
@@ -190,7 +228,8 @@ void onResponse(final DnsQuestion question, AddressedEnvelope<DnsResponse, InetS
     }
 
     private void onResponseAorAAAA(
-            DnsRecordType qType, DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
+            DnsRecordType qType, DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,
+            Promise<T> promise) {
 
         // We often get a bunch of CNAMES as well when we asked for A/AAAA.
         final DnsResponse response = envelope.content();
@@ -267,17 +306,18 @@ private void onResponseAorAAAA(
 
         // We aked for A/AAAA but we got only CNAME.
         if (!cnames.isEmpty()) {
-            onResponseCNAME(question, envelope, cnames, false);
+            onResponseCNAME(question, envelope, cnames, false, promise);
         }
     }
 
-    private void onResponseCNAME(DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
-        onResponseCNAME(question, envelope, buildAliasMap(envelope.content()), true);
+    private void onResponseCNAME(DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,
+                                 Promise<T> promise) {
+        onResponseCNAME(question, envelope, buildAliasMap(envelope.content()), true, promise);
     }
 
     private void onResponseCNAME(
             DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> response,
-            Map<String, String> cnames, boolean trace) {
+            Map<String, String> cnames, boolean trace, Promise<T> promise) {
 
         // Resolve the host name in the question into the real host name.
         final String name = question.name().toLowerCase(Locale.US);
@@ -296,7 +336,7 @@ private void onResponseCNAME(
         }
 
         if (found) {
-            followCname(response.sender(), name, resolved);
+            followCname(response.sender(), name, resolved, promise);
         } else if (trace && traceEnabled) {
             addTrace(response.sender(), "no matching CNAME record found");
         }
@@ -332,12 +372,12 @@ private void onResponseCNAME(
         return cnames != null? cnames : Collections.<String, String>emptyMap();
     }
 
-    void tryToFinishResolve() {
+    void tryToFinishResolve(Promise<T> promise) {
         if (!queriesInProgress.isEmpty()) {
             // There are still some queries we did not receive responses for.
             if (gotPreferredAddress()) {
                 // But it's OK to finish the resolution process if we got a resolved address of the preferred type.
-                finishResolve();
+                finishResolve(promise);
             }
 
             // We did not get any resolved address of the preferred type, so we can't finish the resolution process.
@@ -350,13 +390,13 @@ void tryToFinishResolve() {
             if (!triedCNAME) {
                 // As the last resort, try to query CNAME, just in case the name server has it.
                 triedCNAME = true;
-                query(nameServerAddrs.next(), new DefaultDnsQuestion(hostname, DnsRecordType.CNAME));
+                query(nameServerAddrs.next(), new DefaultDnsQuestion(hostname, DnsRecordType.CNAME), promise);
                 return;
             }
         }
 
         // We have at least one resolved address or tried CNAME as the last resort..
-        finishResolve();
+        finishResolve(promise);
     }
 
     private boolean gotPreferredAddress() {
@@ -385,7 +425,7 @@ private boolean gotPreferredAddress() {
         return false;
     }
 
-    private void finishResolve() {
+    private void finishResolve(Promise<T> promise) {
         if (!queriesInProgress.isEmpty()) {
             // If there are queries in progress, we should cancel it because we already finished the resolution.
             for (Iterator<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> i = queriesInProgress.iterator();
@@ -402,7 +442,7 @@ private void finishResolve() {
         if (resolvedEntries != null) {
             // Found at least one resolved address.
             for (InternetProtocolFamily f: resolveAddressTypes) {
-                if (finishResolve(f, resolvedEntries)) {
+                if (finishResolve(f, resolvedEntries, promise)) {
                     return;
                 }
             }
@@ -412,8 +452,13 @@ private void finishResolve() {
         final int tries = maxAllowedQueries - allowedQueries;
         final StringBuilder buf = new StringBuilder(64);
 
-        buf.append("failed to resolve '")
-           .append(hostname).append('\'');
+        buf.append("failed to resolve '");
+        if (pristineHostname != null) {
+          buf.append(pristineHostname);
+        } else {
+          buf.append(hostname);
+        }
+        buf.append('\'');
         if (tries > 1) {
             if (tries < maxAllowedQueries) {
                 buf.append(" after ")
@@ -435,8 +480,11 @@ private void finishResolve() {
         promise.tryFailure(cause);
     }
 
-    protected abstract boolean finishResolve(
-            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries);
+    abstract boolean finishResolve(InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries,
+                                   Promise<T> promise);
+
+    abstract DnsNameResolverContext<T> newResolverContext(DnsNameResolver parent, String hostname,
+                                                          DnsCache resolveCache);
 
     static String decodeDomainName(ByteBuf in) {
         in.markReaderIndex();
@@ -450,7 +498,7 @@ static String decodeDomainName(ByteBuf in) {
         }
     }
 
-    private void followCname(InetSocketAddress nameServerAddr, String name, String cname) {
+    private void followCname(InetSocketAddress nameServerAddr, String name, String cname, Promise<T> promise) {
 
         if (traceEnabled) {
             if (trace == null) {
@@ -467,8 +515,8 @@ private void followCname(InetSocketAddress nameServerAddr, String name, String c
         }
 
         final InetSocketAddress nextAddr = nameServerAddrs.next();
-        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.A));
-        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.AAAA));
+        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.A), promise);
+        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.AAAA), promise);
     }
 
     private void addTrace(InetSocketAddress nameServerAddr, String msg) {
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/StringUtil2.java b/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/StringUtil2.java
new file mode 100644
index 000000000..3197de71e
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/StringUtil2.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+/**
+ * String utility class.
+ */
+public final class StringUtil2 {
+
+    /**
+     * Determine if the string {@code s} ends with the char {@code c}.
+     *
+     * @param s the string to test
+     * @param c the tested char
+     * @return true if {@code s} ends with the char {@code c}
+     */
+    public static boolean endsWith(CharSequence s, char c) {
+        int len = s.length();
+        return len > 0 && s.charAt(len - 1) == c;
+    }
+
+    private StringUtil2() {
+        // Unused.
+    }
+}
\ No newline at end of file
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
index 64b2d2213..0f4f28ed6 100644
--- a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
@@ -28,41 +28,14 @@
 import io.netty.handler.codec.dns.DnsResponse;
 import io.netty.handler.codec.dns.DnsResponseCode;
 import io.netty.handler.codec.dns.DnsSection;
-import io.netty.util.NetUtil;
 import io.netty.util.concurrent.Future;
 import io.netty.util.internal.StringUtil;
-import io.netty.util.internal.ThreadLocalRandom;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import org.apache.directory.server.dns.DnsServer;
-import org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;
-import org.apache.directory.server.dns.io.encoder.ResourceRecordEncoder;
-import org.apache.directory.server.dns.messages.DnsMessage;
-import org.apache.directory.server.dns.messages.QuestionRecord;
-import org.apache.directory.server.dns.messages.RecordClass;
-import org.apache.directory.server.dns.messages.RecordType;
-import org.apache.directory.server.dns.messages.ResourceRecord;
-import org.apache.directory.server.dns.messages.ResourceRecordModifier;
-import org.apache.directory.server.dns.protocol.DnsProtocolHandler;
-import org.apache.directory.server.dns.protocol.DnsUdpDecoder;
-import org.apache.directory.server.dns.protocol.DnsUdpEncoder;
-import org.apache.directory.server.dns.store.DnsAttribute;
-import org.apache.directory.server.dns.store.RecordStore;
-import org.apache.directory.server.protocol.shared.transport.UdpTransport;
-import org.apache.mina.core.buffer.IoBuffer;
-import org.apache.mina.core.session.IoSession;
-import org.apache.mina.filter.codec.ProtocolCodecFactory;
-import org.apache.mina.filter.codec.ProtocolCodecFilter;
-import org.apache.mina.filter.codec.ProtocolDecoder;
-import org.apache.mina.filter.codec.ProtocolEncoder;
-import org.apache.mina.filter.codec.ProtocolEncoderOutput;
-import org.apache.mina.transport.socket.DatagramAcceptor;
-import org.apache.mina.transport.socket.DatagramSessionConfig;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
-import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
@@ -262,7 +235,7 @@
                 StringUtil.EMPTY_STRING);
     }
 
-    private static final TestDnsServer dnsServer = new TestDnsServer();
+    private static final TestDnsServer dnsServer = new TestDnsServer(DOMAINS);
     private static final EventLoopGroup group = new NioEventLoopGroup(1);
 
     private static DnsNameResolverBuilder newResolver() {
@@ -278,6 +251,12 @@ private static DnsNameResolverBuilder newResolver(InternetProtocolFamily... reso
                 .resolvedAddressTypes(resolvedAddressTypes);
     }
 
+    private static DnsNameResolverBuilder newNonCachedResolver(InternetProtocolFamily... resolvedAddressTypes) {
+        return newResolver()
+                .resolveCache(NoopDnsCache.INSTANCE)
+                .resolvedAddressTypes(resolvedAddressTypes);
+    }
+
     @BeforeClass
     public static void init() throws Exception {
         dnsServer.start();
@@ -349,6 +328,16 @@ public void testResolveAAAA() throws Exception {
         }
     }
 
+    @Test
+    public void testNonCachedResolve() throws Exception {
+        DnsNameResolver resolver = newNonCachedResolver(InternetProtocolFamily.IPv4).build();
+        try {
+            testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
+        } finally {
+            resolver.close();
+        }
+    }
+
     private static Map<String, InetAddress> testResolve0(DnsNameResolver resolver, Set<String> excludedDomains)
             throws InterruptedException {
 
@@ -515,174 +504,4 @@ private static void queryMx(
         futures.put(hostname, resolver.query(new DefaultDnsQuestion(hostname, DnsRecordType.MX)));
     }
 
-    private static final class TestDnsServer extends DnsServer {
-        private static final Map<String, byte[]> BYTES = new HashMap<String, byte[]>();
-        private static final String[] IPV6_ADDRESSES;
-        static {
-            BYTES.put("::1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
-            BYTES.put("0:0:0:0:0:0:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1});
-            BYTES.put("0:0:0:0:0:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1});
-            BYTES.put("0:0:0:0:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1});
-            BYTES.put("0:0:0:1:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
-            BYTES.put("0:0:1:1:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
-            BYTES.put("0:1:1:1:1:1:1:1", new byte[] {0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
-            BYTES.put("1:1:1:1:1:1:1:1", new byte[] {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
-
-            IPV6_ADDRESSES = BYTES.keySet().toArray(new String[BYTES.size()]);
-        }
-
-        @Override
-        public void start() throws IOException {
-            InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST4, 0);
-            UdpTransport transport = new UdpTransport(address.getHostName(), address.getPort());
-            setTransports(transport);
-
-            DatagramAcceptor acceptor = transport.getAcceptor();
-
-            acceptor.setHandler(new DnsProtocolHandler(this, new TestRecordStore()) {
-                @Override
-                public void sessionCreated(IoSession session) throws Exception {
-                    // USe our own codec to support AAAA testing
-                    session.getFilterChain()
-                           .addFirst("codec", new ProtocolCodecFilter(new TestDnsProtocolUdpCodecFactory()));
-                }
-            });
-
-            ((DatagramSessionConfig) acceptor.getSessionConfig()).setReuseAddress(true);
-
-            // Start the listener
-            acceptor.bind();
-        }
-
-        public InetSocketAddress localAddress() {
-            return (InetSocketAddress) getTransports()[0].getAcceptor().getLocalAddress();
-        }
-
-        /**
-         * {@link ProtocolCodecFactory} which allows to test AAAA resolution.
-         */
-        private static final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory {
-            private final DnsMessageEncoder encoder = new DnsMessageEncoder();
-            private final TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder();
-
-            @Override
-            public ProtocolEncoder getEncoder(IoSession session) throws Exception {
-                return new DnsUdpEncoder() {
-
-                    @Override
-                    public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {
-                        IoBuffer buf = IoBuffer.allocate(1024);
-                        DnsMessage dnsMessage = (DnsMessage) message;
-                        encoder.encode(buf, dnsMessage);
-                        for (ResourceRecord record: dnsMessage.getAnswerRecords()) {
-                            // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder
-                            // does not support it and it is hard to extend, because the interesting methods
-                            // are private...
-                            // In case of RecordType.AAAA we need to encode the RecordType by ourselves.
-                            if (record.getRecordType() == RecordType.AAAA) {
-                                try {
-                                    recordEncoder.put(buf, record);
-                                } catch (IOException e) {
-                                    // Should never happen
-                                    throw new IllegalStateException(e);
-                                }
-                            }
-                        }
-                        buf.flip();
-
-                        out.write(buf);
-                    }
-                };
-            }
-
-            @Override
-            public ProtocolDecoder getDecoder(IoSession session) throws Exception {
-                return new DnsUdpDecoder();
-            }
-
-            private static final class TestAAAARecordEncoder extends ResourceRecordEncoder {
-
-                @Override
-                protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {
-                    byte[] bytes = BYTES.get(resourceRecord.get(DnsAttribute.IP_ADDRESS));
-                    if (bytes == null) {
-                        throw new IllegalStateException();
-                    }
-                    // encode the ::1
-                    ioBuffer.put(bytes);
-                }
-            }
-        }
-
-        private static final class TestRecordStore implements RecordStore {
-            private static final int[] NUMBERS = new int[254];
-            private static final char[] CHARS = new char[26];
-
-            static {
-                for (int i = 0; i < NUMBERS.length; i++) {
-                    NUMBERS[i] = i + 1;
-                }
-
-                for (int i = 0; i < CHARS.length; i++) {
-                    CHARS[i] =  (char) ('a' + i);
-                }
-            }
-
-            private static int index(int arrayLength) {
-                return Math.abs(ThreadLocalRandom.current().nextInt()) % arrayLength;
-            }
-
-            private static String nextDomain() {
-               return CHARS[index(CHARS.length)] + ".netty.io";
-            }
-
-            private static String nextIp() {
-                return ipPart() + "." + ipPart() + '.' + ipPart() + '.' + ipPart();
-            }
-
-            private static int ipPart() {
-                return NUMBERS[index(NUMBERS.length)];
-            }
-
-            private static String nextIp6() {
-                return IPV6_ADDRESSES[index(IPV6_ADDRESSES.length)];
-            }
-
-            @Override
-            public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {
-                String name = questionRecord.getDomainName();
-                if (DOMAINS.contains(name)) {
-                    ResourceRecordModifier rm = new ResourceRecordModifier();
-                    rm.setDnsClass(RecordClass.IN);
-                    rm.setDnsName(name);
-                    rm.setDnsTtl(100);
-                    rm.setDnsType(questionRecord.getRecordType());
-
-                    switch (questionRecord.getRecordType()) {
-                    case A:
-                        do {
-                            rm.put(DnsAttribute.IP_ADDRESS, nextIp());
-                        } while (ThreadLocalRandom.current().nextBoolean());
-                        break;
-                    case AAAA:
-                        do {
-                            rm.put(DnsAttribute.IP_ADDRESS, nextIp6());
-                        } while (ThreadLocalRandom.current().nextBoolean());
-                        break;
-                    case MX:
-                        int priority = 0;
-                        do {
-                            rm.put(DnsAttribute.DOMAIN_NAME, nextDomain());
-                            rm.put(DnsAttribute.MX_PREFERENCE, String.valueOf(++priority));
-                        } while (ThreadLocalRandom.current().nextBoolean());
-                        break;
-                    default:
-                        return null;
-                    }
-                    return Collections.singleton(rm.getEntry());
-                }
-                return null;
-            }
-        }
-    }
 }
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
new file mode 100644
index 000000000..77c652ff7
--- /dev/null
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioDatagramChannel;
+import io.netty.util.concurrent.Future;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.hamcrest.Matchers.not;
+import static org.hamcrest.core.StringContains.containsString;
+
+public class SearchDomainTest {
+
+    private DnsNameResolverBuilder newResolver() {
+        return new DnsNameResolverBuilder(group.next())
+            .channelType(NioDatagramChannel.class)
+            .nameServerAddresses(DnsServerAddresses.singleton(dnsServer.localAddress()))
+            .maxQueriesPerResolve(1)
+            .optResourceEnabled(false);
+    }
+
+    private TestDnsServer dnsServer;
+    private EventLoopGroup group;
+    private DnsNameResolver resolver;
+
+    @Before
+    public void before() {
+        group = new NioEventLoopGroup(1);
+    }
+
+    @After
+    public void destroy() {
+        if (dnsServer != null) {
+            dnsServer.stop();
+            dnsServer = null;
+        }
+        if (resolver != null) {
+            resolver.close();
+        }
+        group.shutdownGracefully();
+    }
+
+    @Test
+    public void testResolve() throws Exception {
+        Set<String> domains = new HashSet<String>();
+        domains.add("host1.foo.com");
+        domains.add("host1");
+        domains.add("host3");
+        domains.add("host4.sub.foo.com");
+        domains.add("host5.sub.foo.com");
+        domains.add("host5.sub");
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singletonList("foo.com")).build();
+
+        String a = "host1.foo.com";
+        String resolved = assertResolve(resolver, a);
+        assertEquals(store.getAddress("host1.foo.com"), resolved);
+
+        // host1 resolves host1.foo.com with foo.com search domain
+        resolved = assertResolve(resolver, "host1");
+        assertEquals(store.getAddress("host1.foo.com"), resolved);
+
+        // "host1." absolute query
+        resolved = assertResolve(resolver, "host1.");
+        assertEquals(store.getAddress("host1"), resolved);
+
+        // "host2" not resolved
+        assertNotResolve(resolver, "host2");
+
+        // "host3" does not contain a dot or is not absolute
+        assertNotResolve(resolver, "host3");
+
+        // "host3." does not contain a dot but is absolute
+        resolved = assertResolve(resolver, "host3.");
+        assertEquals(store.getAddress("host3"), resolved);
+
+        // "host4.sub" contains a dot but not resolved then resolved to "host4.sub.foo.com" with "foo.com" search domain
+        resolved = assertResolve(resolver, "host4.sub");
+        assertEquals(store.getAddress("host4.sub.foo.com"), resolved);
+
+        // "host5.sub" contains a dot and is resolved
+        resolved = assertResolve(resolver, "host5.sub");
+        assertEquals(store.getAddress("host5.sub"), resolved);
+    }
+
+    @Test
+    public void testResolveAll() throws Exception {
+        Set<String> domains = new HashSet<String>();
+        domains.add("host1.foo.com");
+        domains.add("host1");
+        domains.add("host3");
+        domains.add("host4.sub.foo.com");
+        domains.add("host5.sub.foo.com");
+        domains.add("host5.sub");
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains, 2);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singletonList("foo.com")).build();
+
+        String a = "host1.foo.com";
+        List<String> resolved = assertResolveAll(resolver, a);
+        assertEquals(store.getAddresses("host1.foo.com"), resolved);
+
+        // host1 resolves host1.foo.com with foo.com search domain
+        resolved = assertResolveAll(resolver, "host1");
+        assertEquals(store.getAddresses("host1.foo.com"), resolved);
+
+        // "host1." absolute query
+        resolved = assertResolveAll(resolver, "host1.");
+        assertEquals(store.getAddresses("host1"), resolved);
+
+        // "host2" not resolved
+        assertNotResolveAll(resolver, "host2");
+
+        // "host3" does not contain a dot or is not absolute
+        assertNotResolveAll(resolver, "host3");
+
+        // "host3." does not contain a dot but is absolute
+        resolved = assertResolveAll(resolver, "host3.");
+        assertEquals(store.getAddresses("host3"), resolved);
+
+        // "host4.sub" contains a dot but not resolved then resolved to "host4.sub.foo.com" with "foo.com" search domain
+        resolved = assertResolveAll(resolver, "host4.sub");
+        assertEquals(store.getAddresses("host4.sub.foo.com"), resolved);
+
+        // "host5.sub" contains a dot and is resolved
+        resolved = assertResolveAll(resolver, "host5.sub");
+        assertEquals(store.getAddresses("host5.sub"), resolved);
+    }
+
+    @Test
+    public void testMultipleSearchDomain() throws Exception {
+        Set<String> domains = new HashSet<String>();
+        domains.add("host1.foo.com");
+        domains.add("host2.bar.com");
+        domains.add("host3.bar.com");
+        domains.add("host3.foo.com");
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Arrays.asList("foo.com", "bar.com")).build();
+
+        // "host1" resolves via the "foo.com" search path
+        String resolved = assertResolve(resolver, "host1");
+        assertEquals(store.getAddress("host1.foo.com"), resolved);
+
+        // "host2" resolves via the "bar.com" search path
+        resolved = assertResolve(resolver, "host2");
+        assertEquals(store.getAddress("host2.bar.com"), resolved);
+
+        // "host3" resolves via the the "foo.com" search path as it is the first one
+        resolved = assertResolve(resolver, "host3");
+        assertEquals(store.getAddress("host3.foo.com"), resolved);
+
+        // "host4" does not resolve
+        assertNotResolve(resolver, "host4");
+    }
+
+    @Test
+    public void testSearchDomainWithNdots2() throws Exception {
+        Set<String> domains = new HashSet<String>();
+        domains.add("host1.sub.foo.com");
+        domains.add("host2.sub.foo.com");
+        domains.add("host2.sub");
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singleton("foo.com")).ndots(2).build();
+
+        String resolved = assertResolve(resolver, "host1.sub");
+        assertEquals(store.getAddress("host1.sub.foo.com"), resolved);
+
+        // "host2.sub" is resolved with the foo.com search domain as ndots = 2
+        resolved = assertResolve(resolver, "host2.sub");
+        assertEquals(store.getAddress("host2.sub.foo.com"), resolved);
+    }
+
+    @Test
+    public void testSearchDomainWithNdots0() throws Exception {
+        Set<String> domains = new HashSet<String>();
+        domains.add("host1");
+        domains.add("host1.foo.com");
+        domains.add("host2.foo.com");
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singleton("foo.com")).ndots(0).build();
+
+        // "host1" resolves directly as ndots = 0
+        String resolved = assertResolve(resolver, "host1");
+        assertEquals(store.getAddress("host1"), resolved);
+
+        // "host1.foo.com" resolves to host1.foo
+        resolved = assertResolve(resolver, "host1.foo.com");
+        assertEquals(store.getAddress("host1.foo.com"), resolved);
+
+        // "host2" resolves to host2.foo.com with the foo.com search domain
+        resolved = assertResolve(resolver, "host2");
+        assertEquals(store.getAddress("host2.foo.com"), resolved);
+    }
+
+    private void assertNotResolve(DnsNameResolver resolver, String inetHost) throws InterruptedException {
+        Future<InetAddress> fut = resolver.resolve(inetHost);
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        assertFalse(fut.isSuccess());
+    }
+
+    private void assertNotResolveAll(DnsNameResolver resolver, String inetHost) throws InterruptedException {
+        Future<List<InetAddress>> fut = resolver.resolveAll(inetHost);
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        assertFalse(fut.isSuccess());
+    }
+
+    private String assertResolve(DnsNameResolver resolver, String inetHost) throws InterruptedException {
+        Future<InetAddress> fut = resolver.resolve(inetHost);
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        return fut.getNow().getHostAddress();
+    }
+
+    private List<String> assertResolveAll(DnsNameResolver resolver, String inetHost) throws InterruptedException {
+        Future<List<InetAddress>> fut = resolver.resolveAll(inetHost);
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        List<String> list = new ArrayList<String>();
+        for (InetAddress addr : fut.getNow()) {
+            list.add(addr.getHostAddress());
+        }
+        return list;
+    }
+
+    @Test
+    public void testExceptionMsgNoSearchDomain() throws Exception {
+        Set<String> domains = new HashSet<String>();
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singletonList("foo.com")).build();
+
+        Future<InetAddress> fut = resolver.resolve("unknown.hostname");
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        assertFalse(fut.isSuccess());
+        final Throwable cause = fut.cause();
+        assertEquals(UnknownHostException.class, cause.getClass());
+        assertThat("search domain is included in UnknownHostException", cause.getMessage(),
+            not(containsString("foo.com")));
+    }
+}
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java
new file mode 100644
index 000000000..ade7b729e
--- /dev/null
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.util.NetUtil;
+import io.netty.util.internal.ThreadLocalRandom;
+import org.apache.directory.server.dns.DnsException;
+import org.apache.directory.server.dns.DnsServer;
+import org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;
+import org.apache.directory.server.dns.io.encoder.ResourceRecordEncoder;
+import org.apache.directory.server.dns.messages.DnsMessage;
+import org.apache.directory.server.dns.messages.QuestionRecord;
+import org.apache.directory.server.dns.messages.RecordClass;
+import org.apache.directory.server.dns.messages.RecordType;
+import org.apache.directory.server.dns.messages.ResourceRecord;
+import org.apache.directory.server.dns.messages.ResourceRecordImpl;
+import org.apache.directory.server.dns.messages.ResourceRecordModifier;
+import org.apache.directory.server.dns.protocol.DnsProtocolHandler;
+import org.apache.directory.server.dns.protocol.DnsUdpDecoder;
+import org.apache.directory.server.dns.protocol.DnsUdpEncoder;
+import org.apache.directory.server.dns.store.DnsAttribute;
+import org.apache.directory.server.dns.store.RecordStore;
+import org.apache.directory.server.protocol.shared.transport.UdpTransport;
+import org.apache.mina.core.buffer.IoBuffer;
+import org.apache.mina.core.session.IoSession;
+import org.apache.mina.filter.codec.ProtocolCodecFactory;
+import org.apache.mina.filter.codec.ProtocolCodecFilter;
+import org.apache.mina.filter.codec.ProtocolDecoder;
+import org.apache.mina.filter.codec.ProtocolEncoder;
+import org.apache.mina.filter.codec.ProtocolEncoderOutput;
+import org.apache.mina.transport.socket.DatagramAcceptor;
+import org.apache.mina.transport.socket.DatagramSessionConfig;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+final class TestDnsServer extends DnsServer {
+    private static final Map<String, byte[]> BYTES = new HashMap<String, byte[]>();
+    private static final String[] IPV6_ADDRESSES;
+
+    static {
+        BYTES.put("::1", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
+        BYTES.put("0:0:0:0:0:0:1:1", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1});
+        BYTES.put("0:0:0:0:0:1:1:1", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1});
+        BYTES.put("0:0:0:0:1:1:1:1", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1});
+        BYTES.put("0:0:0:1:1:1:1:1", new byte[]{0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+        BYTES.put("0:0:1:1:1:1:1:1", new byte[]{0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+        BYTES.put("0:1:1:1:1:1:1:1", new byte[]{0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+        BYTES.put("1:1:1:1:1:1:1:1", new byte[]{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+
+        IPV6_ADDRESSES = BYTES.keySet().toArray(new String[BYTES.size()]);
+    }
+
+    private final RecordStore store;
+
+    TestDnsServer(Set<String> domains) {
+        this.store = new TestRecordStore(domains);
+    }
+
+    TestDnsServer(RecordStore store) {
+        this.store = store;
+    }
+
+    @Override
+    public void start() throws IOException {
+        InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST4, 50000);
+        UdpTransport transport = new UdpTransport(address.getHostName(), address.getPort());
+        setTransports(transport);
+
+        DatagramAcceptor acceptor = transport.getAcceptor();
+
+        acceptor.setHandler(new DnsProtocolHandler(this, store) {
+            @Override
+            public void sessionCreated(IoSession session) throws Exception {
+                // USe our own codec to support AAAA testing
+                session.getFilterChain()
+                    .addFirst("codec", new ProtocolCodecFilter(new TestDnsProtocolUdpCodecFactory()));
+            }
+        });
+
+        ((DatagramSessionConfig) acceptor.getSessionConfig()).setReuseAddress(true);
+
+        // Start the listener
+        acceptor.bind();
+    }
+
+    public InetSocketAddress localAddress() {
+        return (InetSocketAddress) getTransports()[0].getAcceptor().getLocalAddress();
+    }
+
+    /**
+     * {@link ProtocolCodecFactory} which allows to test AAAA resolution.
+     */
+    private static final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory {
+        private final DnsMessageEncoder encoder = new DnsMessageEncoder();
+        private final TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder();
+
+        @Override
+        public ProtocolEncoder getEncoder(IoSession session) throws Exception {
+            return new DnsUdpEncoder() {
+
+                @Override
+                public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {
+                    IoBuffer buf = IoBuffer.allocate(1024);
+                    DnsMessage dnsMessage = (DnsMessage) message;
+                    encoder.encode(buf, dnsMessage);
+                    for (ResourceRecord record : dnsMessage.getAnswerRecords()) {
+                        // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder
+                        // does not support it and it is hard to extend, because the interesting methods
+                        // are private...
+                        // In case of RecordType.AAAA we need to encode the RecordType by ourselves.
+                        if (record.getRecordType() == RecordType.AAAA) {
+                            try {
+                                recordEncoder.put(buf, record);
+                            } catch (IOException e) {
+                                // Should never happen
+                                throw new IllegalStateException(e);
+                            }
+                        }
+                    }
+                    buf.flip();
+
+                    out.write(buf);
+                }
+            };
+        }
+
+        @Override
+        public ProtocolDecoder getDecoder(IoSession session) throws Exception {
+            return new DnsUdpDecoder();
+        }
+
+        private static final class TestAAAARecordEncoder extends ResourceRecordEncoder {
+
+            @Override
+            protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {
+                byte[] bytes = BYTES.get(resourceRecord.get(DnsAttribute.IP_ADDRESS));
+                if (bytes == null) {
+                    throw new IllegalStateException();
+                }
+                // encode the ::1
+                ioBuffer.put(bytes);
+            }
+        }
+    }
+
+    public static final class MapRecordStoreA implements RecordStore {
+
+        private final Map<String, List<String>> domainMap;
+
+        public MapRecordStoreA(Set<String> domains, int length) {
+            domainMap = new HashMap<String, List<String>>(domains.size());
+            for (String domain : domains) {
+                List<String> addresses = new ArrayList<String>(length);
+                for (int i = 0; i < length; i++) {
+                    addresses.add(TestRecordStore.nextIp());
+                }
+                domainMap.put(domain, addresses);
+            }
+        }
+
+        public MapRecordStoreA(Set<String> domains) {
+            this(domains, 1);
+        }
+
+        public String getAddress(String domain) {
+            return domainMap.get(domain).get(0);
+        }
+
+        public List<String> getAddresses(String domain) {
+            return domainMap.get(domain);
+        }
+
+        @Override
+        public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) throws DnsException {
+            String name = questionRecord.getDomainName();
+            List<String> addresses = domainMap.get(name);
+            if (addresses != null && questionRecord.getRecordType() == RecordType.A) {
+                Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>();
+                for (String address : addresses) {
+                    HashMap<String, Object> attributes = new HashMap<String, Object>();
+                    attributes.put(DnsAttribute.IP_ADDRESS.toLowerCase(), address);
+                    records.add(new ResourceRecordImpl(name, questionRecord.getRecordType(),
+                        RecordClass.IN, 100, attributes) {
+                        @Override
+                        public int hashCode() {
+                            return System.identityHashCode(this);
+                        }
+                        @Override
+                        public boolean equals(Object o) {
+                            return false;
+                        }
+                    });
+                }
+                return records;
+            }
+            return null;
+        }
+    }
+
+    private static final class TestRecordStore implements RecordStore {
+        private static final int[] NUMBERS = new int[254];
+        private static final char[] CHARS = new char[26];
+
+        static {
+            for (int i = 0; i < NUMBERS.length; i++) {
+                NUMBERS[i] = i + 1;
+            }
+
+            for (int i = 0; i < CHARS.length; i++) {
+                CHARS[i] = (char) ('a' + i);
+            }
+        }
+
+        private static int index(int arrayLength) {
+            return Math.abs(ThreadLocalRandom.current().nextInt()) % arrayLength;
+        }
+
+        private static String nextDomain() {
+            return CHARS[index(CHARS.length)] + ".netty.io";
+        }
+
+        private static String nextIp() {
+            return ipPart() + "." + ipPart() + '.' + ipPart() + '.' + ipPart();
+        }
+
+        private static int ipPart() {
+            return NUMBERS[index(NUMBERS.length)];
+        }
+
+        private static String nextIp6() {
+            return IPV6_ADDRESSES[index(IPV6_ADDRESSES.length)];
+        }
+
+        private final Set<String> domains;
+
+        public TestRecordStore(Set<String> domains) {
+            this.domains = domains;
+        }
+
+        @Override
+        public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {
+            String name = questionRecord.getDomainName();
+            if (domains.contains(name)) {
+                ResourceRecordModifier rm = new ResourceRecordModifier();
+                rm.setDnsClass(RecordClass.IN);
+                rm.setDnsName(name);
+                rm.setDnsTtl(100);
+                rm.setDnsType(questionRecord.getRecordType());
+
+                switch (questionRecord.getRecordType()) {
+                    case A:
+                        do {
+                            rm.put(DnsAttribute.IP_ADDRESS, nextIp());
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    case AAAA:
+                        do {
+                            rm.put(DnsAttribute.IP_ADDRESS, nextIp6());
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    case MX:
+                        int priority = 0;
+                        do {
+                            rm.put(DnsAttribute.DOMAIN_NAME, nextDomain());
+                            rm.put(DnsAttribute.MX_PREFERENCE, String.valueOf(++priority));
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    default:
+                        return null;
+                }
+                return Collections.singleton(rm.getEntry());
+            }
+            return null;
+        }
+    }
+}
diff --git a/netty-bp/resolver/pom.xml b/netty-bp/resolver/pom.xml
index f50de093b..48c1335b2 100644
--- a/netty-bp/resolver/pom.xml
+++ b/netty-bp/resolver/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.11-SNAPSHOT</version>
+    <version>2.0.24-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-resolver</artifactId>
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
new file mode 100644
index 000000000..9cbfc310a
--- /dev/null
+++ b/netty-utils/pom.xml
@@ -0,0 +1,17 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.0.24-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-netty-utils</artifactId>
+	<name>Asynchronous Http Client Netty Utils</name>
+
+	<dependencies>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-buffer</artifactId>
+		</dependency>
+	</dependencies>
+</project>
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
new file mode 100755
index 000000000..237ea001f
--- /dev/null
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.*;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+
+public final class ByteBufUtils {
+
+    private ByteBufUtils() {
+    }
+
+    public static String byteBuf2String(Charset charset, ByteBuf buf) throws CharacterCodingException {
+        if (charset.equals(UTF_8) || charset.equals(US_ASCII)) {
+            return Utf8ByteBufCharsetDecoder.decodeUtf8(buf);
+        } else {
+            return buf.toString(charset);
+        }
+    }
+
+    public static String decodeNonOptimized(Charset charset, ByteBuf... bufs) {
+        
+        CompositeByteBuf composite = Unpooled.compositeBuffer(bufs.length);
+
+        try {
+            for (ByteBuf buf : bufs) {
+                buf.retain();
+                composite.addComponent(buf);
+            }
+
+            return composite.toString(charset);
+
+        } finally {
+            composite.release();
+        }
+    }
+    
+    public static String byteBuf2String(Charset charset, ByteBuf... bufs) throws CharacterCodingException {
+        if (charset.equals(UTF_8) || charset.equals(US_ASCII)) {
+            return Utf8ByteBufCharsetDecoder.decodeUtf8(bufs);
+        } else {
+            return decodeNonOptimized(charset, bufs);
+        }
+    }
+
+    public static byte[] byteBuf2Bytes(ByteBuf buf) {
+        int readable = buf.readableBytes();
+        int readerIndex = buf.readerIndex();
+        if (buf.hasArray()) {
+            byte[] array = buf.array();
+            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        buf.getBytes(readerIndex, array);
+        return array;
+    }
+}
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
new file mode 100644
index 000000000..09061db23
--- /dev/null
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import io.netty.buffer.ByteBuf;
+
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CoderResult;
+
+public class Utf8ByteBufCharsetDecoder {
+
+    private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = new ThreadLocal<Utf8ByteBufCharsetDecoder>() {
+        protected Utf8ByteBufCharsetDecoder initialValue() {
+            return new Utf8ByteBufCharsetDecoder();
+        }
+    };
+
+    private static Utf8ByteBufCharsetDecoder pooledDecoder() {
+        Utf8ByteBufCharsetDecoder decoder = POOL.get();
+        decoder.reset();
+        return decoder;
+    }
+
+    public static String decodeUtf8(ByteBuf buf) throws CharacterCodingException {
+        return pooledDecoder().decode(buf);
+    }
+
+    public static String decodeUtf8(ByteBuf... bufs) throws CharacterCodingException {
+        return pooledDecoder().decode(bufs);
+    }
+
+    private final CharsetDecoder decoder = UTF_8.newDecoder();
+    protected CharBuffer charBuffer = allocateCharBuffer(1024);
+    private ByteBuffer splitCharBuffer;
+
+    protected void initSplitCharBuffer() {
+        if (splitCharBuffer == null) {
+            // UTF-8 chars are 4 bytes max
+            splitCharBuffer = ByteBuffer.allocate(4);
+        }
+    }
+
+    protected CharBuffer allocateCharBuffer(int l) {
+        return CharBuffer.allocate(l);
+    }
+
+    private void ensureCapacity(int l) {
+        if (charBuffer.position() == 0) {
+            if (charBuffer.capacity() < l) {
+                charBuffer = allocateCharBuffer(l);
+            }
+        } else if (charBuffer.remaining() < l) {
+            CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
+            charBuffer.flip();
+            newCharBuffer.put(charBuffer);
+            charBuffer = newCharBuffer;
+        }
+    }
+
+    public void reset() {
+        decoder.reset();
+        charBuffer.clear();
+    }
+
+    private static int charSize(byte firstByte) throws CharacterCodingException {
+        if ((firstByte >> 5) == -2 && (firstByte & 0x1e) != 0) {
+            // 2 bytes, 11 bits: 110xxxxx 10xxxxxx
+            return 2;
+
+        } else if ((firstByte >> 4) == -2) {
+            // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
+            return 3;
+
+        } else if ((firstByte >> 3) == -2) {
+            // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+            return 4;
+
+        } else {
+            // charSize isn't supposed to be called for regular bytes
+            throw new CharacterCodingException();
+        }
+    }
+
+    private void handleSplitCharBuffer(ByteBuffer nioBuffer, boolean endOfInput) throws CharacterCodingException {
+        // TODO we could save charSize
+        int missingBytes = charSize(splitCharBuffer.get(0)) - splitCharBuffer.position();
+
+        if (nioBuffer.remaining() < missingBytes) {
+            if (endOfInput) {
+                throw new CharacterCodingException();
+            }
+
+            // still not enough bytes
+            splitCharBuffer.put(nioBuffer);
+
+        } else {
+            // FIXME better way?
+            for (int i = 0; i < missingBytes; i++) {
+                splitCharBuffer.put(nioBuffer.get());
+            }
+
+            splitCharBuffer.flip();
+            CoderResult res = decoder.decode(splitCharBuffer, charBuffer, endOfInput && !nioBuffer.hasRemaining());
+            if (res.isError()) {
+                res.throwException();
+            }
+
+            splitCharBuffer.position(0);
+        }
+    }
+
+    protected void decodePartial(ByteBuffer nioBuffer, boolean endOfInput) throws CharacterCodingException {
+        // deal with pending splitCharBuffer
+        if (splitCharBuffer != null && splitCharBuffer.position() > 0 && nioBuffer.hasRemaining()) {
+            handleSplitCharBuffer(nioBuffer, endOfInput);
+        }
+
+        // decode remaining buffer
+        if (nioBuffer.hasRemaining()) {
+            CoderResult res = decoder.decode(nioBuffer, charBuffer, endOfInput);
+            if (res.isUnderflow()) {
+                if (nioBuffer.remaining() > 0) {
+                    initSplitCharBuffer();
+                    splitCharBuffer.put(nioBuffer);
+                }
+            } else if (res.isError()) {
+                res.throwException();
+            }
+        }
+    }
+
+    private void decode(ByteBuffer[] nioBuffers, int length) throws CharacterCodingException {
+        int count = nioBuffers.length;
+        for (int i = 0; i < count; i++) {
+            decodePartial(nioBuffers[i].duplicate(), i == count - 1);
+        }
+    }
+
+    private void decodeSingleNioBuffer(ByteBuffer nioBuffer, int length) throws CharacterCodingException {
+        CoderResult res = decoder.decode(nioBuffer, charBuffer, true);
+        if (res.isError()) {
+            res.throwException();
+        }
+    }
+
+    public String decode(ByteBuf buf) throws CharacterCodingException {
+        if (buf.isDirect()) {
+            return buf.toString(UTF_8);
+        }
+
+        int length = buf.readableBytes();
+        ensureCapacity(length);
+
+        if (buf.nioBufferCount() == 1) {
+            decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate(), length);
+        } else {
+            decode(buf.nioBuffers(), buf.readableBytes());
+        }
+
+        return charBuffer.flip().toString();
+    }
+
+    public String decode(ByteBuf... bufs) throws CharacterCodingException {
+        if (bufs.length == 1) {
+            return decode(bufs[0]);
+        }
+
+        int totalSize = 0;
+        int totalNioBuffers = 0;
+        boolean withoutArray = false;
+        for (ByteBuf buf : bufs) {
+            if (!buf.hasArray()) {
+                withoutArray = true;
+                break;
+            }
+            totalSize += buf.readableBytes();
+            totalNioBuffers += buf.nioBufferCount();
+        }
+
+        if (withoutArray) {
+            return ByteBufUtils.decodeNonOptimized(UTF_8, bufs);
+
+        } else {
+            ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
+            int i = 0;
+            for (ByteBuf buf : bufs) {
+                for (ByteBuffer nioBuffer : buf.nioBuffers()) {
+                    nioBuffers[i++] = nioBuffer;
+                }
+            }
+
+            ensureCapacity(totalSize);
+            decode(nioBuffers, totalSize);
+
+            return charBuffer.flip().toString();
+        }
+    }
+}
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
new file mode 100644
index 000000000..a7da5290f
--- /dev/null
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.testng.Assert.assertEquals;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import org.testng.annotations.Test;
+
+public class ByteBufUtilsTest {
+
+    @Test
+    public void testByteBuf2BytesHasBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf inputBuf = Unpooled.wrappedBuffer(inputBytes);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, inputBytes);
+    }
+
+    @Test
+    public void testByteBuf2BytesNoBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf inputBuf = Unpooled.directBuffer();
+        inputBuf.writeBytes(inputBytes);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, inputBytes);
+    }
+}
diff --git a/pom.xml b/pom.xml
index 2ac0e062b..412e9bdd3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.0.11-SNAPSHOT</version>
+	<version>2.0.24-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -205,19 +205,20 @@
 			<url>${distMgmtSnapshotsUrl}</url>
 		</snapshotRepository>
 	</distributionManagement>
-	<repositories>
-		<repository>
-			<id>maven.java.net</id>
-			<url>https://maven.java.net/content/repositories/releases</url>
-		</repository>
-	</repositories>
 	<modules>
 		<module>netty-bp</module>
+		<module>netty-utils</module>
 		<module>client</module>
 		<module>extras</module>
+		<module>example</module>
 	</modules>
 	<dependencyManagement>
 		<dependencies>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-buffer</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>io.netty</groupId>
 				<artifactId>netty-codec-http</artifactId>
@@ -373,16 +374,16 @@
 		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
-		<netty.version>4.0.39.Final</netty.version>
+		<netty.version>4.0.42.Final</netty.version>
 		<slf4j.version>1.7.21</slf4j.version>
 		<logback.version>1.1.7</logback.version>
 		<testng.version>6.9.10</testng.version>
-		<jetty.version>9.3.10.v20160621</jetty.version>
+		<jetty.version>9.3.12.v20160915</jetty.version>
 		<tomcat.version>6.0.45</tomcat.version>
 		<commons-io.version>2.4</commons-io.version>
 		<commons-fileupload.version>1.3</commons-fileupload.version>
 		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-		<rxjava-reactive-streams.version>1.0.1</rxjava-reactive-streams.version>
+		<rxjava-reactive-streams.version>1.1.1</rxjava-reactive-streams.version>
 		<powermock.version>1.6.4</powermock.version>
 	</properties>
 </project>
