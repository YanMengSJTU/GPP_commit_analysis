diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
index 9002e600e..de9010409 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -18,10 +18,16 @@
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
 
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES_MD5;
+
 import java.io.IOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.NoSuchElementException;
 
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.util.ByteBufUtils;
+import org.asynchttpclient.util.Base64;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -32,96 +38,120 @@
 
 public class NettyReactiveStreamsBody implements NettyBody {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
-    private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
-
-    private final Publisher<ByteBuf> publisher;
-
-    private final long contentLength;
-
-    public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
-        this.publisher = publisher;
-        this.contentLength = contentLength;
-    }
-
-    @Override
-    public long getContentLength() {
-        return contentLength;
-    }
-
-    @Override
-    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        if (future.isStreamConsumed()) {
-            LOGGER.warn("Stream has already been consumed and cannot be reset");
-        } else {
-            future.setStreamConsumed(true);
-            NettySubscriber subscriber = new NettySubscriber(channel, future);
-            channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
-            publisher.subscribe(new SubscriberAdapter(subscriber));
-        }
-    }
-
-    private static class SubscriberAdapter implements Subscriber<ByteBuf> {
-        private final Subscriber<HttpContent> subscriber;
-
-        public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
-            this.subscriber = subscriber;
-        }
-
-        @Override
-        public void onSubscribe(Subscription s) {
-            subscriber.onSubscribe(s);
-        }
-
-        @Override
-        public void onNext(ByteBuf buffer) {
-            HttpContent content = new DefaultHttpContent(buffer);
-            subscriber.onNext(content);
-        }
-
-        @Override
-        public void onError(Throwable t) {
-            subscriber.onError(t);
-        }
-
-        @Override
-        public void onComplete() {
-            subscriber.onComplete();
-        }
-    }
-
-    private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
-        private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
-
-        private final Channel channel;
-        private final NettyResponseFuture<?> future;
-
-        public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
-            super(channel.eventLoop());
-            this.channel = channel;
-            this.future = future;
-        }
-
-        @Override
-        protected void complete() {
-            channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(future -> removeFromPipeline()));
-        }
-
-        @Override
-        protected void error(Throwable error) {
-            if (error == null)
-                throw null;
-            removeFromPipeline();
-            future.abort(error);
-        }
-
-        private void removeFromPipeline() {
-            try {
-                channel.pipeline().remove(this);
-                LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
-            } catch (NoSuchElementException e) {
-                LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
-            }
-        }
-    }
+	private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
+	private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
+
+	private final Publisher<ByteBuf> publisher;
+
+	private final long contentLength;
+
+	public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
+		this.publisher = publisher;
+		this.contentLength = contentLength;
+	}
+
+	@Override
+	public long getContentLength() {
+		return contentLength;
+	}
+
+	@Override
+	public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+		if (future.isStreamConsumed()) {
+			LOGGER.warn("Stream has already been consumed and cannot be reset");
+		} else {
+			future.setStreamConsumed(true);
+			NettySubscriber subscriber = new NettySubscriber(channel, future);
+			channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
+			publisher.subscribe(new SubscriberAdapter(subscriber));
+		}
+	}
+
+	private static class SubscriberAdapter implements Subscriber<ByteBuf> {
+		private final Subscriber<HttpContent> subscriber;
+
+		public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
+			this.subscriber = subscriber;
+		}
+
+		@Override
+		public void onSubscribe(Subscription s) {
+			subscriber.onSubscribe(s);
+		}
+
+		@Override
+		public void onNext(ByteBuf buffer) {
+			HttpContent content = new DefaultHttpContent(buffer);
+			subscriber.onNext(content);
+		}
+
+		@Override
+		public void onError(Throwable t) {
+			subscriber.onError(t);
+		}
+
+		@Override
+		public void onComplete() {
+			subscriber.onComplete();
+		}
+	}
+
+	private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
+		private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
+
+		private final Channel channel;
+		private final NettyResponseFuture<?> future;
+
+		public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
+			super(channel.eventLoop());
+			this.channel = channel;
+			this.future = future;
+		}
+
+		private static MessageDigest newMd5() {
+			try {
+				return MessageDigest.getInstance("MD5");
+			} catch (NoSuchAlgorithmException e) {
+				throw new InternalError(e);
+			}
+		}
+		private final MessageDigest md = newMd5();
+		
+		@Override
+		public void onNext(HttpContent t) {
+			LOGGER.debug(">>>>>>>>>>>>onNext with {} bytes", t.content().readableBytes());
+			if (t.content().isReadable()) {
+				byte[] bytes = ByteBufUtils.byteBuf2Bytes(t.content().duplicate());
+				md.update(bytes, 0, bytes.length);
+			}
+			
+			// TODO Auto-generated method stub
+			super.onNext(t);
+		}
+
+		@Override
+		protected void complete() {
+			LOGGER.debug(">>>>>>>>>>>>complete with {} md5", Base64.encode(md.digest()));
+			md.reset();
+			channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
+					.addListener(future -> removeFromPipeline())); // FIXME why not remove immediately?
+		}
+
+		@Override
+		protected void error(Throwable error) {
+			if (error == null)
+				throw null;
+			removeFromPipeline();
+			future.abort(error);
+		}
+
+		private void removeFromPipeline() {
+			try {
+				channel.pipeline().remove(this);
+				LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
+			} catch (NoSuchElementException e) {
+				LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
+			}
+		}
+	}
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index 400bd2594..2170263c9 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -248,11 +248,14 @@ public void testConnectionDoesNotGetClosed() throws Exception {
 			byte[] responseBody = response.getResponseBodyAsBytes();
 			responseBody = response.getResponseBodyAsBytes();
 			assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-					LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-			assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-			assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
-			assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
+					LARGE_IMAGE_BYTES.length, "Length of request payload received by the server invalid");
+			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length,
+					"Length of response payload received from the server invalid");
+			assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5,
+					"MD5 of request payload received by the server invalid");
+			assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5,
+					"MD5 of response payload received from the server invalid");
+			assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on first attempt");
 
 			response = requestBuilder.execute().get();
 			assertEquals(response.getStatusCode(), 200);
@@ -544,17 +547,18 @@ public ByteBuf next() {
 					int thisCurrentIndex = currentIndex;
 					int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
 					currentIndex += length;
-					
+
 					md.update(payload, thisCurrentIndex, length);
-					
+
 					if (!hasNext()) {
 						String md5 = Base64.encode(md.digest());
 						if (!md5.equals(LARGE_IMAGE_BYTES_MD5)) {
-							new Exception("ByteBufIterable generated a request payload with invalid MD5 of " + md5).printStackTrace();
+							new Exception("ByteBufIterable generated a request payload with invalid MD5 of " + md5)
+									.printStackTrace();
 						}
 						md.reset();
 					}
-					
+
 					return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
 				}
 
@@ -565,7 +569,7 @@ public void remove() {
 			};
 		}
 	}
-	
+
 	private static MessageDigest newMd5() {
 		try {
 			return MessageDigest.getInstance("MD5");
