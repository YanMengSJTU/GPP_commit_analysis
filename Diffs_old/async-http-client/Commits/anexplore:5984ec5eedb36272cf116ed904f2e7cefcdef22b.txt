diff --git a/.travis.yml b/.travis.yml
index 82e19aef9..2760c26e6 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,6 +1,6 @@
 language: java
 jdk:
-  - oraclejdk8
+  - openjdk8
 
 before_script:
   - travis/before_script.sh
@@ -16,12 +16,6 @@ after_success:
 
 sudo: false
 
-# https://github.com/travis-ci/travis-ci/issues/3259
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer
-
 # Cache settings
 cache:
   directories:
diff --git a/README.md b/README.md
index ddf73fc99..cfdc3789a 100644
--- a/README.md
+++ b/README.md
@@ -89,7 +89,7 @@ AsyncHttpClient c = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0
 ### Basics
 
 AHC provides 2 APIs for defining requests: bound and unbound.
-`AsyncHttpClient` and Dls` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
+`AsyncHttpClient` and Dsl` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
 
 ```java
 import org.asynchttpclient.*;
diff --git a/client/pom.xml b/client/pom.xml
index 75f8e3973..6967b74e8 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client</artifactId>
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index aca4acb06..ef8ece087 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -124,6 +124,9 @@ else if (request.getByteBufferData() != null)
             requestBuilder.setBody(request.getByteBufferData());
           else if (request.getBodyGenerator() != null)
             requestBuilder.setBody(request.getBodyGenerator());
+          else if (isNonEmpty(request.getBodyParts())) {
+            requestBuilder.setBodyParts(request.getBodyParts());
+          }
         }
 
         requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
index ab38a66f9..0a51e63e9 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
@@ -16,11 +16,13 @@
 import io.netty.channel.Channel;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.net.ssl.SSLException;
 import java.nio.channels.ClosedChannelException;
 
 public abstract class WriteListener {
@@ -36,27 +38,27 @@
     this.notifyHeaders = notifyHeaders;
   }
 
-  private boolean abortOnThrowable(Channel channel, Throwable cause) {
-    if (cause != null) {
-      if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-        LOGGER.debug(cause.getMessage(), cause);
-        Channels.silentlyCloseChannel(channel);
+  private void abortOnThrowable(Channel channel, Throwable cause) {
+    if (future.getChannelState() == ChannelState.POOLED
+      && (cause instanceof IllegalStateException
+      || cause instanceof ClosedChannelException
+      || cause instanceof SSLException
+      || StackTraceInspector.recoverOnReadOrWriteException(cause))) {
+      LOGGER.debug("Write exception on pooled channel, letting retry trigger", cause);
 
-      } else {
-        future.abort(cause);
-      }
-      return true;
+    } else {
+      future.abort(cause);
     }
-
-    return false;
+    Channels.silentlyCloseChannel(channel);
   }
 
   void operationComplete(Channel channel, Throwable cause) {
     future.touch();
 
-    // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+    // The write operation failed. If the channel was pooled, it means it got asynchronously closed.
     // Let's retry a second time.
-    if (abortOnThrowable(channel, cause)) {
+    if (cause != null) {
+      abortOnThrowable(channel, cause);
       return;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index 531eaadd8..f6ab4ae2f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -155,7 +155,7 @@ public SocketAddress getLocalAddress() {
   @Override
   public Future<Void> sendCloseFrame(int statusCode, String reasonText) {
     if (channel.isOpen()) {
-      return channel.writeAndFlush(new CloseWebSocketFrame(1000, "normal closure"));
+      return channel.writeAndFlush(new CloseWebSocketFrame(statusCode, reasonText));
     }
     return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);
   }
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 5992bf3ed..fcf34896f 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -33,7 +33,7 @@
 
   @Test(groups = "online")
   public void testMaxTotalConnectionsExceedingException() throws IOException {
-    String[] urls = new String[]{"http://google.com", "http://github.com/"};
+    String[] urls = new String[]{"https://google.com", "https://github.com"};
 
     AsyncHttpClientConfig config = config()
             .setConnectTimeout(1000)
@@ -69,7 +69,7 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
 
   @Test(groups = "online")
   public void testMaxTotalConnections() throws Exception {
-    String[] urls = new String[]{"http://google.com", "http://gatling.io"};
+    String[] urls = new String[]{"https://google.com", "https://github.com"};
 
     final CountDownLatch latch = new CountDownLatch(2);
     final AtomicReference<Throwable> ex = new AtomicReference<>();
diff --git a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 52aaefc3a..ebbfb511f 100644
--- a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -51,7 +51,8 @@ public void onCloseWithCodeServerClose() throws Exception {
       c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
       latch.await();
-      assertEquals(text.get(), "1001-Idle Timeout");
+      // used to be correct 001-Idle Timeout prior to Jetty 9.4.15...
+      assertEquals(text.get(), "1000-");
     }
   }
 
diff --git a/example/pom.xml b/example/pom.xml
index 42ebc8d19..82ee427e1 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-example</artifactId>
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index cd5c8051c..0c6d1c18b 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 77c7f55b4..040a5912c 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index d2a1ed3aa..42545c867 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 894e05e5b..b14c8636a 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index b305ff249..32cb4ae49 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
 
   <artifactId>async-http-client-extras-retrofit2</artifactId>
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
index bbd760187..d5534a9ce 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
@@ -39,7 +39,7 @@
 @Value
 @Builder(toBuilder = true)
 @Slf4j
-class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
+public class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
   private static final ResponseBody EMPTY_BODY = ResponseBody.create(null, "");
 
   /**
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index ba4594d92..301fe6ca7 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <artifactId>async-http-client-extras-rxjava</artifactId>
   <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 840dcb432..c1389cf5b 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <artifactId>async-http-client-extras-rxjava2</artifactId>
   <name>Asynchronous Http Client RxJava2 Extras</name>
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
index bf366f820..6a5f8dca7 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
@@ -21,10 +22,14 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
+import org.asynchttpclient.netty.request.NettyRequest;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.net.ssl.SSLSession;
+import java.net.InetSocketAddress;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import static java.util.Objects.requireNonNull;
@@ -144,6 +149,76 @@ public final void onThrowable(Throwable t) {
     emitOnError(error);
   }
 
+  @Override
+  public void onHostnameResolutionAttempt(String name) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionAttempt(name));
+  }
+
+  @Override
+  public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionSuccess(name, addresses));
+  }
+
+  @Override
+  public void onHostnameResolutionFailure(String name, Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionFailure(name, cause));
+  }
+
+  @Override
+  public void onTcpConnectAttempt(InetSocketAddress remoteAddress) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectAttempt(remoteAddress));
+  }
+
+  @Override
+  public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectSuccess(remoteAddress, connection));
+  }
+
+  @Override
+  public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectFailure(remoteAddress, cause));
+  }
+
+  @Override
+  public void onTlsHandshakeAttempt() {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeAttempt());
+  }
+
+  @Override
+  public void onTlsHandshakeSuccess(SSLSession sslSession) {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeSuccess(sslSession));
+  }
+
+  @Override
+  public void onTlsHandshakeFailure(Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeFailure(cause));
+  }
+
+  @Override
+  public void onConnectionPoolAttempt() {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionPoolAttempt());
+  }
+
+  @Override
+  public void onConnectionPooled(Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionPooled(connection));
+  }
+
+  @Override
+  public void onConnectionOffer(Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionOffer(connection));
+  }
+
+  @Override
+  public void onRequestSend(NettyRequest request) {
+    executeUnlessEmitterDisposed(() -> delegate().onRequestSend(request));
+  }
+
+  @Override
+  public void onRetry() {
+    executeUnlessEmitterDisposed(() -> delegate().onRetry());
+  }
+
   /**
    * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
    * the {@link #delegate() delegate} didn't already receive a terminal event,
@@ -184,4 +259,12 @@ private void emitOnError(Throwable error) {
       LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
     }
   }
+
+  private void executeUnlessEmitterDisposed(Runnable runnable) {
+    if (emitter.isDisposed()) {
+      disposed();
+    } else {
+      runnable.run();
+    }
+  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
index b8a9b3b4e..5c14778e1 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
@@ -26,7 +27,10 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import javax.net.ssl.SSLSession;
+import java.net.InetSocketAddress;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Callable;
 
@@ -35,10 +39,6 @@
 import static org.mockito.BDDMockito.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
 
 public class AbstractMaybeAsyncHandlerBridgeTest {
 
@@ -57,6 +57,20 @@
   @Mock
   private HttpResponseBodyPart bodyPart;
 
+  private final String hostname = "service:8080";
+
+  @Mock
+  private InetSocketAddress remoteAddress;
+
+  @Mock
+  private Channel channel;
+
+  @Mock
+  private SSLSession sslSession;
+
+  @Mock
+  private Throwable error;
+
   @Captor
   private ArgumentCaptor<Throwable> throwable;
 
@@ -76,6 +90,20 @@ public T call() throws Exception {
     };
   }
 
+  private static Runnable named(String name, Runnable runnable) {
+    return new Runnable() {
+      @Override
+      public String toString() {
+        return name;
+      }
+
+      @Override
+      public void run() {
+        runnable.run();
+      }
+    };
+  }
+
   @BeforeMethod
   public void initializeTest() {
     MockitoAnnotations.initMocks(this);
@@ -104,10 +132,68 @@ public void forwardsEvents() throws Exception {
     underTest.onTrailingHeadersReceived(headers);
     then(delegate).should().onTrailingHeadersReceived(headers);
 
+    /* when */
+    underTest.onHostnameResolutionAttempt(hostname);
+    then(delegate).should().onHostnameResolutionAttempt(hostname);
+
+    /* when */
+    List<InetSocketAddress> remoteAddresses = Collections.singletonList(remoteAddress);
+    underTest.onHostnameResolutionSuccess(hostname, remoteAddresses);
+    then(delegate).should().onHostnameResolutionSuccess(hostname, remoteAddresses);
+
+    /* when */
+    underTest.onHostnameResolutionFailure(hostname, error);
+    then(delegate).should().onHostnameResolutionFailure(hostname, error);
+
+    /* when */
+    underTest.onTcpConnectAttempt(remoteAddress);
+    then(delegate).should().onTcpConnectAttempt(remoteAddress);
+
+    /* when */
+    underTest.onTcpConnectSuccess(remoteAddress, channel);
+    then(delegate).should().onTcpConnectSuccess(remoteAddress, channel);
+
+    /* when */
+    underTest.onTcpConnectFailure(remoteAddress, error);
+    then(delegate).should().onTcpConnectFailure(remoteAddress, error);
+
+    /* when */
+    underTest.onTlsHandshakeAttempt();
+    then(delegate).should().onTlsHandshakeAttempt();
+
+    /* when */
+    underTest.onTlsHandshakeSuccess(sslSession);
+    then(delegate).should().onTlsHandshakeSuccess(sslSession);
+
+    /* when */
+    underTest.onTlsHandshakeFailure(error);
+    then(delegate).should().onTlsHandshakeFailure(error);
+
+    /* when */
+    underTest.onConnectionPoolAttempt();
+    then(delegate).should().onConnectionPoolAttempt();
+
+    /* when */
+    underTest.onConnectionPooled(channel);
+    then(delegate).should().onConnectionPooled(channel);
+
+    /* when */
+    underTest.onConnectionOffer(channel);
+    then(delegate).should().onConnectionOffer(channel);
+
+    /* when */
+    underTest.onRequestSend(null);
+    then(delegate).should().onRequestSend(null);
+
+    /* when */
+    underTest.onRetry();
+    then(delegate).should().onRetry();
+
     /* when */
     underTest.onCompleted();
     then(delegate).should().onCompleted();
     then(emitter).should().onSuccess(this);
+
     /* then */
     verifyNoMoreInteractions(delegate);
   }
@@ -254,6 +340,42 @@ public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEve
     verifyNoMoreInteractions(delegate);
   }
 
+  @DataProvider
+  public Object[][] variousEvents() {
+    return new Object[][]{
+            {named("onHostnameResolutionAttempt", () -> underTest.onHostnameResolutionAttempt("service:8080"))},
+            {named("onHostnameResolutionSuccess", () -> underTest.onHostnameResolutionSuccess("service:8080",
+                    Collections.singletonList(remoteAddress)))},
+            {named("onHostnameResolutionFailure", () -> underTest.onHostnameResolutionFailure("service:8080", error))},
+            {named("onTcpConnectAttempt", () -> underTest.onTcpConnectAttempt(remoteAddress))},
+            {named("onTcpConnectSuccess", () -> underTest.onTcpConnectSuccess(remoteAddress, channel))},
+            {named("onTcpConnectFailure", () -> underTest.onTcpConnectFailure(remoteAddress, error))},
+            {named("onTlsHandshakeAttempt", () -> underTest.onTlsHandshakeAttempt())},
+            {named("onTlsHandshakeSuccess", () -> underTest.onTlsHandshakeSuccess(sslSession))},
+            {named("onTlsHandshakeFailure", () -> underTest.onTlsHandshakeFailure(error))},
+            {named("onConnectionPoolAttempt", () -> underTest.onConnectionPoolAttempt())},
+            {named("onConnectionPooled", () -> underTest.onConnectionPooled(channel))},
+            {named("onConnectionOffer", () -> underTest.onConnectionOffer(channel))},
+            {named("onRequestSend", () -> underTest.onRequestSend(null))},
+            {named("onRetry", () -> underTest.onRetry())},
+    };
+  }
+
+  @Test(dataProvider = "variousEvents")
+  public void variousEventCallbacksCheckDisposal(Runnable event) {
+    given(emitter.isDisposed()).willReturn(true);
+
+    /* when */
+    event.run();
+    /* then */
+    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+    /* when */
+    event.run();
+    /* then */
+    verifyNoMoreInteractions(delegate);
+  }
+
   private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
     UnderTest() {
       super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 01957d5eb..4fcd42837 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <artifactId>async-http-client-extras-simple</artifactId>
   <name>Asynchronous Http Simple Client</name>
diff --git a/extras/typesafeconfig/pom.xml b/extras/typesafeconfig/pom.xml
index 1d1601613..d444456eb 100644
--- a/extras/typesafeconfig/pom.xml
+++ b/extras/typesafeconfig/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
 
   <artifactId>async-http-client-extras-typesafe-config</artifactId>
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
index 041508adb..d7caf9377 100644
--- a/netty-utils/pom.xml
+++ b/netty-utils/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.9.1-SNAPSHOT</version>
+    <version>2.10.2</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-netty-utils</artifactId>
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java
new file mode 100644
index 000000000..4aaa61c8a
--- /dev/null
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2019 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.nio.charset.Charset;
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import org.testng.internal.junit.ArrayAsserts;
+
+public class ByteBufUtilsTests {
+
+    @Test
+    public void testByteBuf2BytesEmptyByteBuf() {
+        ByteBuf buf = Unpooled.buffer();
+
+        try {
+            ArrayAsserts.assertArrayEquals(new byte[]{},
+                    ByteBufUtils.byteBuf2Bytes(buf));
+        } finally {
+            buf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2BytesNotEmptyByteBuf() {
+        ByteBuf byteBuf = Unpooled.wrappedBuffer(new byte[]{'f', 'o', 'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new byte[]{'f', 'o', 'o'},
+                    ByteBufUtils.byteBuf2Bytes(byteBuf));
+        } finally {
+            byteBuf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2String() {
+        ByteBuf byteBuf = Unpooled.wrappedBuffer(new byte[]{'f', 'o', 'o'});
+        Charset charset = Charset.forName("US-ASCII");
+
+        try {
+            Assert.assertEquals(
+                    ByteBufUtils.byteBuf2String(charset, byteBuf), "foo");
+        } finally {
+            byteBuf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2StringWithByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{'f'});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o', 'o'});
+
+        try {
+            Assert.assertEquals(ByteBufUtils.byteBuf2String(
+                    Charset.forName("ISO-8859-1"), byteBuf1, byteBuf2), "foo");
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2Chars() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("US-ASCII"), byteBuf1));
+            ArrayAsserts.assertArrayEquals(new char[]{}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"), byteBuf1));
+            ArrayAsserts.assertArrayEquals(new char[]{'o'}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"), byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2CharsWithByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{'f', 'o'});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'%', '*'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{'f', 'o', '%', '*'},
+                    ByteBufUtils.byteBuf2Chars(Charset.forName("US-ASCII"),
+                            byteBuf1, byteBuf2));
+            ArrayAsserts.assertArrayEquals(new char[]{'f', 'o', '%', '*'},
+                    ByteBufUtils.byteBuf2Chars(Charset.forName("ISO-8859-1"),
+                            byteBuf1, byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2CharsWithEmptyByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{'o'}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"),
+                            byteBuf1, byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+}
diff --git a/pom.xml b/pom.xml
index fb88c8228..d8849684e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
   <groupId>org.asynchttpclient</groupId>
   <artifactId>async-http-client-project</artifactId>
   <name>Asynchronous Http Client Project</name>
-  <version>2.9.1-SNAPSHOT</version>
+  <version>2.10.2</version>
   <packaging>pom</packaging>
   <description>
     The Async Http Client (AHC) library's purpose is to allow Java
@@ -427,21 +427,21 @@
     <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
     <source.property>1.8</source.property>
     <target.property>1.8</target.property>
-    <netty.version>4.1.33.Final</netty.version>
-    <slf4j.version>1.7.25</slf4j.version>
+    <netty.version>4.1.39.Final</netty.version>
+    <slf4j.version>1.7.26</slf4j.version>
     <reactive-streams.version>1.0.2</reactive-streams.version>
     <activation.version>1.2.0</activation.version>
-    <netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
+    <netty-reactive-streams.version>2.0.3</netty-reactive-streams.version>
     <rxjava.version>1.3.8</rxjava.version>
-    <rxjava2.version>2.2.5</rxjava2.version>
+    <rxjava2.version>2.2.10</rxjava2.version>
     <logback.version>1.2.3</logback.version>
     <testng.version>6.13.1</testng.version>
-    <jetty.version>9.4.14.v20181114</jetty.version>
-    <tomcat.version>9.0.14</tomcat.version>
+    <jetty.version>9.4.18.v20190429</jetty.version>
+    <tomcat.version>9.0.20</tomcat.version>
     <commons-io.version>2.6</commons-io.version>
     <commons-fileupload.version>1.3.3</commons-fileupload.version>
     <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-    <mockito.version>2.23.4</mockito.version>
+    <mockito.version>2.28.2</mockito.version>
     <hamcrest.version>2.1</hamcrest.version>
     <kerby.version>1.1.1</kerby.version>
   </properties>
