diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 22156626c..0f47bc44b 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -105,6 +105,9 @@
    */
   boolean isFollowRedirect();
 
+  /**
+   * 最大的http重定向次数
+   */
   /**
    * Get the maximum number of HTTP redirect
    *
@@ -330,8 +333,11 @@
 
   int getIoThreadsCount();
 
+  /**
+   * 为何这样写代码,第一次见
+   */
   enum ResponseBodyPartFactory {
-
+    /** 枚举类型还可以这样写,长见识了 */
     EAGER {
       @Override
       public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index a1603ded5..7cf63c392 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -46,6 +46,7 @@
 
   /** 同道中人真多 */
   private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
+  /** http client的一些配置属性 */
   private final AsyncHttpClientConfig config;
   private final boolean noRequestFilters;
   /** 线程安全的布尔类 */
@@ -53,12 +54,14 @@
   private final ChannelManager channelManager;
   private final NettyRequestSender requestSender;
   private final boolean allowStopNettyTimer;
+  /** 暂时不知道干啥的 */
   private final Timer nettyTimer;
 
   /**
    * Default signature calculator to use for all requests constructed by this
    * client instance.
    */
+  /** 签名计算 */
   private SignatureCalculator signatureCalculator;
 
   /**
@@ -94,6 +97,10 @@ public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
     channelManager.configureBootstraps(requestSender);
   }
 
+  /**
+   * 构造Netty 时间轮,利用线程轮来进行批量调度,将大量任务绑定到一个调度器上
+   * 时间轮中默认每100纳秒调度一次任务
+   */
   private Timer newNettyTimer(AsyncHttpClientConfig config) {
     ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName() + "-timer");
 
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 914b734b7..11ca2418b 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -18,6 +18,9 @@
 
 import static org.asynchttpclient.util.HttpConstants.Methods.*;
 
+/**
+ * Dsl全称是啥？抱歉,第一次见
+ */
 public final class Dsl {
 
   private Dsl() {
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 053aa28ff..b92c18e91 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -17,6 +17,7 @@
 
 import java.nio.ByteBuffer;
 
+/** 接受http response的回调函数 */
 /**
  * A callback class used when an HTTP response body is received.
  */
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilder.java b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
index ad0a14149..0c5480be9 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -17,6 +17,10 @@
 
 import static org.asynchttpclient.util.HttpConstants.Methods.GET;
 
+/**
+ * 构建一个 {@link org.asynchttpclient.Request}
+ * 不是线程安全的,小心它持有一个Request的应用
+ */
 /**
  * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds, so modifying the builder will modify the
  * request even after it has been built.
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
index 97331fbdf..34ea2bb0c 100755
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
@@ -18,6 +18,9 @@
 import java.util.Map;
 import java.util.function.Predicate;
 
+/**
+ * ARH 自定义的channel pool接口
+ */
 public interface ChannelPool {
 
   /**
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
index fb00ba480..47902bf5b 100644
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
@@ -28,6 +28,7 @@ public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServ
       String targetHostBaseUrl = uri.getBaseUrl();
       if (proxyServer == null) {
         if (virtualHost == null) {
+          /** 对于没用代理的类,直接返回url */
           return targetHostBaseUrl;
         } else {
           return new CompositePartitionKey(
@@ -80,6 +81,7 @@ public boolean equals(Object o) {
       return proxyType == that.proxyType;
     }
 
+    /** hashCode都是这样写吗!*/
     @Override
     public int hashCode() {
       int result = targetHostBaseUrl != null ? targetHostBaseUrl.hashCode() : 0;
diff --git a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
index b9fb306cf..1bd5995c4 100644
--- a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
@@ -7,6 +7,9 @@
 
 import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
 
+/**
+ * 实现标准的Http 1.0/1.1连接策略
+ */
 /**
  * Connection strategy implementing standard HTTP 1.0/1.1 behavior.
  */
diff --git a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
index eb6a6abf2..f02f904a6 100644
--- a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
@@ -19,6 +19,9 @@
 import java.util.Map;
 import java.util.function.Predicate;
 
+/**
+ * 不禁质疑自己,是不是我太菜了(不用质疑,确实是菜)！这种写法确实是奇葩
+ */
 public enum NoopChannelPool implements ChannelPool {
 
   INSTANCE;
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index ea55e6cc3..dbbc3d494 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -16,7 +16,10 @@
 import java.io.InputStream;
 import java.util.Properties;
 
-/** AsyncHttpClient客户端的默认配置 */
+/** AsyncHttpClient客户端的默认配置名称
+ * 只是定义了个属性名,并没有为每个属性名设置属性值
+ * 静态配置类都会加个final
+ * */
 public final class AsyncHttpClientConfigDefaults {
 
   public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index 140119326..f10cd5dc4 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -5,6 +5,11 @@
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
+/**
+ * 加载AHC的配置
+ * 1.默认配置文件的配置(ahc-default.propertieds)
+ * 2.自定义配置文件(ahc.properties)
+ */
 public class AsyncHttpClientConfigHelper {
 
   private static volatile Config config;
@@ -31,6 +36,7 @@ public static void reloadProperties() {
     public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
     public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
 
+    /** 使用了一个线程安全的map来缓存被访问过的value值 */
     private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
     private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES, true);
     private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
@@ -57,7 +63,11 @@ private Properties parsePropertiesFile(String file, boolean required) {
       return props;
     }
 
+    /**
+     * 缓存的思想无处不在
+     */
     public String getString(String key) {
+      /** computeIfAbsent设置本地缓存,将访问过的key的value都缓存起来 */
       return propsCache.computeIfAbsent(key, k -> {
         String value = System.getProperty(k);
         if (value == null)
diff --git a/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java b/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
index 277db387c..00fe0ef37 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
@@ -24,6 +24,9 @@
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
+/**
+ * 线程安全的cook store
+ */
 public final class ThreadSafeCookieStore implements CookieStore {
 
   private Map<CookieKey, StoredCookie> cookieJar = new ConcurrentHashMap<>();
diff --git a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
index d56cac876..09d45b03d 100644
--- a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
@@ -19,6 +19,7 @@
 @SuppressWarnings("serial")
 public final class ChannelClosedException extends IOException {
 
+  /** 这是什么骚操作,我乡里人,没见过 */
   public static final ChannelClosedException INSTANCE = unknownStackTrace(new ChannelClosedException(), ChannelClosedException.class, "INSTANCE");
 
   private ChannelClosedException() {
diff --git a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
index b3d3f4761..a1c577498 100644
--- a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
+++ b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -88,6 +88,9 @@ public IOException getIOException() {
     return b.ioException;
   }
 
+  /**
+   * 我看作者总喜欢在Object中加个静态对象,是有什么花招吗
+   */
   public static class FilterContextBuilder<T> {
     private AsyncHandler<T> asyncHandler = null;
     private Request request = null;
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index 8f2b18961..98119c338 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -25,6 +25,7 @@
  */
 public class EagerResponseBodyPart extends HttpResponseBodyPart {
 
+  /** 直接使用的是字节数组 */
   private final byte[] bytes;
 
   public EagerResponseBodyPart(ByteBuf buf, boolean last) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index 1abe8ce11..fa8f94dbb 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -20,9 +20,11 @@
 
 /**
  * A callback class used when an HTTP response body is received.
+ *
  */
 public class LazyResponseBodyPart extends HttpResponseBodyPart {
 
+  /** 与{@link EagerResponseBodyPart} 的字节数组不一样了*/
   private final ByteBuf buf;
 
   public LazyResponseBodyPart(ByteBuf buf, boolean last) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 8deb22e53..466b1a7f0 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -70,6 +70,7 @@
   public static final String SOCKS_HANDLER = "socks";
   public static final String INFLATER_HANDLER = "inflater";
   public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
+  /** WebSocket好像没有像decoder,compressor,encoder这类的 */
   public static final String WS_DECODER_HANDLER = "ws-decoder";
   public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
   public static final String WS_COMPRESSOR_HANDLER = "ws-compressor";
@@ -79,14 +80,19 @@
   public static final String LOGGING_HANDLER = "logging";
   private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
   private final AsyncHttpClientConfig config;
+  /** 暂时放你一马 */
   private final SslEngineFactory sslEngineFactory;
+  /** evenLoopGroup主要负责将Channel注册到Selector上和执行一些Runnable任务  */
   private final EventLoopGroup eventLoopGroup;
   private final boolean allowReleaseEventLoopGroup;
+  /** netty的启动类,主要作用时配置相关端口,ip并启动整个netty服务 */
   private final Bootstrap httpBootstrap;
   private final Bootstrap wsBootstrap;
-  private final long handshakeTimeout;
 
+  private final long handshakeTimeout;
+  /** netty的连接池 */
   private final ChannelPool channelPool;
+  /** 这个暂时不知道是干嘛的 */
   private final ChannelGroup openChannels;
 
   private AsyncHttpClientHandler wsHandler;
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 998842159..17ac7cc7f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -36,7 +36,9 @@
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-
+/**
+ * 一个简单的channelPool实现
+ */
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index de78537ac..91f8d70ff 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -45,6 +45,7 @@
   protected final Logger logger = LoggerFactory.getLogger(getClass());
 
   protected final AsyncHttpClientConfig config;
+
   protected final ChannelManager channelManager;
   protected final NettyRequestSender requestSender;
   final Interceptors interceptors;
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index a0235bb5a..fcc646b0d 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -25,7 +25,7 @@
  * OAuth {@link SignatureCalculator} that delegates to {@link OAuthSignatureCalculatorInstance}s.
  */
 public class OAuthSignatureCalculator implements SignatureCalculator {
-
+  /** ThreadLocal 并不是一个Thread 而是一个 Thread的局部变量,在下面代码中ThreadLocal只保存了OAuthSignatureCalculatorInstance这一个对象 */
   private static final ThreadLocal<OAuthSignatureCalculatorInstance> INSTANCES = ThreadLocal.withInitial(() -> {
     try {
       return new OAuthSignatureCalculatorInstance();
@@ -34,6 +34,7 @@
     }
   });
 
+  /** 在进行https是需要 */
   private final ConsumerKey consumerAuth;
 
   private final RequestToken userAuth;
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
index acb9fce5b..80f8410d5 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
@@ -38,6 +38,9 @@
  * Supports most common signature inclusion and calculation methods: HMAC-SHA1 for calculation, and Header inclusion as inclusion method. Nonce generation uses simple random
  * numbers with base64 encoding.
  */
+/**
+ * 对于{@link SignatureCalculator} 来说不是线程安全的(所以在它使用的时候用了ThreadLocal)
+ */
 public class OAuthSignatureCalculatorInstance {
 
   private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
index e17681e6d..8fe7c6b52 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -16,6 +16,9 @@
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponseStatus;
 
+/**
+ * 关于http的一些常量
+ */
 public final class HttpConstants {
 
   private HttpConstants() {
