diff --git a/.travis.yml b/.travis.yml
index bb8adf60b..74c0c662a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,28 +1,26 @@
-language: java
-jdk:
-  - oraclejdk8
-
-before_script:
-  - travis/before_script.sh
-
-script: 
-  - mvn test -Ptest-output
-  - find $HOME/.m2 -name "_remote.repositories" | xargs rm
-  - find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
-  
-# If building master, Publish to Sonatype
-after_success: 
-  - travis/after_success.sh
-
-sudo: false
-
-# https://github.com/travis-ci/travis-ci/issues/3259
 addons:
   apt:
     packages:
-      - oracle-java8-installer
-
-# Cache settings
+    - oracle-java8-installer
+after_success:
+- travis/after_success.sh
+before_script:
+- travis/before_script.sh
 cache:
   directories:
-    - $HOME/.m2/repository
+  - $HOME/.m2/repository
+jdk:
+- oraclejdk8
+language: java
+script:
+- touch NOW
+- echo GIBSTUDYSTART $(date)
+- mvn test -Ptest-output
+- find $HOME/.m2 -name "_remote.repositories" | xargs rm
+- find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
+- echo GIBSTUDYEND $(date)
+- cd $TRAVIS_BUILD_DIR
+- if [ "$TRAVIS_OS_NAME" == "osx" ];        then echo TESTNUM $(find . -name TEST-*.xml
+  -newer NOW | wc -l);        else echo TESTNUM $(find -name TEST-*.xml -newer NOW
+  | wc -l);        fi
+sudo: false
diff --git a/CHANGES.md b/CHANGES.md
deleted file mode 100644
index 24cc27fdc..000000000
--- a/CHANGES.md
+++ /dev/null
@@ -1,22 +0,0 @@
-## From 2.1 to 2.2
-
-* New [Typesafe config](https://github.com/lightbend/config) extra module
-* new `enableWebSocketCompression` config to enable per-message and per-frame WebSocket compression extension
-
-## From 2.0 to 2.1
-
-* AHC 2.1 targets Netty 4.1.
-* `org.asynchttpclient.HttpResponseHeaders` was dropped in favor of `io.netty.handler.codec.http.HttpHeaders`.
-* `org.asynchttpclient.cookie.Cookie` was dropped in favor of `io.netty.handler.codec.http.cookie.Cookie` as AHC's cookie parsers were contributed to Netty.
-* AHC now has a RFC6265 `CookieStore` that is enabled by default. Implementation can be changed in `AsyncHttpClientConfig`.
-* `AsyncHttpClient` now exposes stats with `getClientStats`.
-* `AsyncHandlerExtensions` was dropped in favor of default methods in `AsyncHandler`.
-* `WebSocket` and `WebSocketListener` methods were renamed to mention frames
-* `AsyncHttpClientConfig` various changes:
-  * new `getCookieStore` now lets you configure a CookieStore (enabled by default)
-  * new `isAggregateWebSocketFrameFragments` now lets you disable WebSocket fragmented frames aggregation
-  * new `isUseLaxCookieEncoder` lets you loosen cookie chars validation
-  * `isAcceptAnyCertificate` was dropped, as it didn't do what its name stated
-  * new `isUseInsecureTrustManager` lets you use a permissive TrustManager, that would typically let you accept self-signed certificates
-  * new `isDisableHttpsEndpointIdentificationAlgorithm` disables setting `HTTPS` algorithm on the SSLEngines, typically disables SNI and HTTPS hostname verification
-  * new `isAggregateWebSocketFrameFragments` lets you disable fragmented WebSocket frames aggregation
diff --git a/MIGRATION.md b/MIGRATION.md
new file mode 100644
index 000000000..05c976a07
--- /dev/null
+++ b/MIGRATION.md
@@ -0,0 +1,51 @@
+Migration Guide
+---------------
+
+## From 1.8 to 1.9
+
+AsyncHttpClient v1.9 is a preview of v2, so it comes with some breaking changes.
+
+* Target JDK7, drop support for JDK5 and JDK6
+* Rename many AsyncHttpClientConfig parameters:
+  * `maxTotalConnections` becomes `maxConnections`
+  * `maxConnectionPerHost` becomes `maxConnectionsPerHost`
+  * `connectionTimeOutInMs` becomes `connectTimeout`
+  * `webSocketIdleTimeoutInMs` becomes `webSocketTimeout`
+  * `idleConnectionInPoolTimeoutInMs` becomes `pooledConnectionIdleTimeout`
+  * `idleConnectionTimeoutInMs` becomes `readTimeout`
+  * `requestTimeoutInMs` becomes `requestTimeout`
+  * `maxConnectionLifeTimeInMs` becomes `connectionTTL`
+  * `redirectEnabled` becomes `followRedirect`
+  * `allowPoolingConnection` becomes `allowPoolingConnections`
+  * `allowSslConnectionPool` becomes `allowPoolingSslConnections`
+  * `connectionTimeout` becomes `connectTimeout`
+  * `compressionEnabled` becomes `compressionEnforced`. Default false, so AHC only honors user defined Accept-Encoding.
+  * `requestCompressionLevel` was dropped, as it wasn't working
+  * `SSLEngineFactory` was moved to Netty config as only Netty honors it
+  * `useRawUrl` becomes `disableUrlEncodingForBoundedRequests`, as it's only honored by bound requests
+  * `getAllowPoolingConnection` becomes `isAllowPoolingConnection`
+* Drop `PerRequestConfig`. `requestTimeOut` and `proxy` can now be directly set on the request.
+* Drop `java.net.URI` in favor of own `com.ning.http.client.uri.Uri`. You can use `toJavaNetURI` to convert.
+* Drop `Proxy.getURI` in favor of `getUrl`
+* Drop deprecated methods: `Request` and `RequestBuilderBase`'s `getReqType` in favor of `getMethod`, `Request.getLength` in favor of `getContentLength`
+* Drop deprecated `RealmBuilder.getDomain` in favor of `getNtlmDomain`
+* Rename `xxxParameter` (add, set, get...) into `xxxFormParam`
+* Rename `xxxQueryParameter` (add, set, get...) into `xxxQueryParam`
+* Merge `boolean Request.isRedirectEnabled` and `boolean isRedirectOverrideSet` are merged into `Boolean isRedirectEnabled`
+* Remove url parameter from `SignatureCalculator.calculateAndAddSignature`, as it can be fetched on the request parameter
+* Rename `com.ning.http.client.websocket` package into `com.ning.http.client.ws`
+* WebSocket Listeners now have to implement proper interfaces to be notified or fragment events: `WebSocketByteFragmentListener` and `WebSocketTextFragmentListener`
+* Rename WebSocket's `sendTextMessage` into `sendMessage` and `streamText` into `stream`
+* Rename NettyAsyncHttpProviderConfig's `handshakeTimeoutInMillis` into `handshakeTimeout`
+* Netty provider now creates SslEngines instances with proper hoststring and port.
+* Parts, Realm and ProxyServer now take a java.nio.Charset instead of a String charset name
+* New AsyncHandlerExtensions methods:
+  * `onOpenConnection`,
+  * `onConnectionOpen`,
+  * `onPoolConnection`,
+  * `onConnectionPooled`,
+  * `onSendRequest`,
+  * `onDnsResolved`,
+  * `onSslHandshakeCompleted`
+* Rename FluentCaseInsensitiveStringsMap and FluentStringsMap `replace` into `replaceWith` to not conflict with new JDK8 Map methods
+* execute no longer throws Exceptions, all of them are notified to the handler/future
diff --git a/README.md b/README.md
index 15f053b0b..a8919ee79 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,20 @@
-# Async Http Client [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/)
+Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter) [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client)
+---------------------------------------------------
 
-Follow [@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on Twitter.
+[Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/)
 
-The AsyncHttpClient (AHC) library allows Java applications to easily execute HTTP requests and asynchronously process HTTP responses.
-The library also supports the WebSocket Protocol.
+[Getting](https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/) [started](https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/), and use [WebSockets](http://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/)
 
-It's built on top of [Netty](https://github.com/netty/netty). I's currently compiled on Java 8 but runs on Java 9 too.
+The Async Http Client library's purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
+The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
+
+It's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
+
+Latest `version`: [![Maven](https://img.shields.io/maven-central/v/org.asynchttpclient/async-http-client.svg)](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.asynchttpclient%22%20AND%20a%3A%22async-http-client%22)
 
 ## Installation
 
-Binaries are deployed on Maven central:
+First, in order to add it to your Maven project, simply download from Maven central or add this dependency:
 
 ```xml
 <dependency>
@@ -19,220 +24,177 @@ Binaries are deployed on Maven central:
 </dependency>
 ```
 
-## Version
-
-AHC doesn't use SEMVER, and won't.
-
-* MAJOR = huge refactoring
-* MINOR = new features and minor API changes, upgrading should require 1 hour of work to adapt sources
-* FIX = no API change, just bug fixes, only those are source and binary compatible with same minor version
-
-Check CHANGES.md for migration path between versions.
-
-## Basics
+## Usage
 
-Feel free to check the [Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/) or the code for more information.
-
-### Dsl
-
-Import the Dsl helpers to use convenient methods to bootstrap components:
+Then in your code you can simply do
 
 ```java
-import static org.asynchttpclient.Dsl.*;
-```
-
-### Client
-
-```java
-import static org.asynchttpclient.Dsl.*;
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
 
-AsyncHttpClient asyncHttpClient = asyncHttpClient();
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+Future<Response> f = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+Response r = f.get();
 ```
 
-AsyncHttpClient instances must be closed (call the `close` method) once you're done with them, typically when shutting down your application.
-If you don't, you'll experience threads hanging and resource leaks.
+Note that in this case all the content must be read fully in memory, even if you used `getResponseBodyAsStream()` method on returned `Response` object.
 
-AsyncHttpClient instances are intended to be global resources that share the same lifecycle as the application.
-Typically, AHC will usually underperform if you create a new client for each request, as it will create new threads and connection pools for each.
-It's possible to create shared resources (EventLoop and Timer) beforehand and pass them to multiple client instances in the config. You'll then be responsible for closing those shared resources.
-
-## Configuration
-
-Finally, you can also configure the AsyncHttpClient instance via its AsyncHttpClientConfig object:
+You can also accomplish asynchronous (non-blocking) operation without using a Future if you want to receive and process the response in your handler:
 
 ```java
-import static org.asynchttpclient.Dsl.*;
-
-AsyncHttpClient c = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", 38080)));
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
+
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+asyncHttpClient.prepareGet("http://www.example.com/").execute(new AsyncCompletionHandler<Response>(){
+    
+    @Override
+    public Response onCompleted(Response response) throws Exception{
+        // Do something with the Response
+        // ...
+        return response;
+    }
+    
+    @Override
+    public void onThrowable(Throwable t){
+        // Something wrong happened.
+    }
+});
 ```
 
-## HTTP
-
-### Sending Requests
+(this will also fully read `Response` in memory before calling `onCompleted`)
 
-### Basics
-
-AHC provides 2 APIs for defining requests: bound and unbound.
-`AsyncHttpClient` and Dls` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
+Alternatively you may use continuations (through Java 8 class `CompletableFuture<T>`) to accomplish asynchronous (non-blocking) solution. The equivalent continuation approach to the previous example is:
 
 ```java
-import org.asynchttpclient.*;
+import static org.asynchttpclient.Dsl.*;
 
-// bound
-Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+import org.asynchttpclient.*;
+import java.util.concurrent.CompletableFuture;
 
-// unbound
-Request request = get("http://www.example.com/").build();
-Future<Response> whenResponse = asyncHttpClient.execute(request);
+AsyncHttpClient asyncHttpClient = asyncHttpClient();
+CompletableFuture<Response> promise = asyncHttpClient
+            .prepareGet("http://www.example.com/")
+            .execute()
+            .toCompletableFuture()
+            .exceptionally(t -> { /* Something wrong happened... */  } )
+            .thenApply(resp -> { /*  Do something with the Response */ return resp; });
+promise.join(); // wait for completion
 ```
 
-#### Setting Request Body
-
-Use the `setBody` method to add a body to the request.
-
-This body can be of type:
-* `java.io.File`
-* `byte[]`
-* `List<byte[]>`
-* `String`
-* `java.nio.ByteBuffer`
-* `java.io.InputStream`
-* `Publisher<io.netty.bufferByteBuf>`
-* `org.asynchttpclient.request.body.generator.BodyGenerator`
-
-`BodyGenerator` is a generic abstraction that let you create request bodies on the fly.
-Have a look at `FeedableBodyGenerator` if you're looking for a way to pass requests chunks on the fly. 
-
-#### Multipart
-
-Use the `addBodyPart` method to add a multipart part to the request.
-
-This part can be of type:
-* `ByteArrayPart`
-* `FilePart`
-* `StringPart`
-
-### Dealing with Responses
-
-#### Blocking on the Future
+You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
 
-`execute` methods return a `java.util.concurrent.Future`. You can simply both the calling thread to get the response.
+You can also mix Future with AsyncHandler to only retrieve part of the asynchronous response
 
 ```java
-Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
-Response response = whenResponse.get();
-```
-
-This is useful for debugging but you'll most likely hurt performance or create bugs when running such code on production.
-The point of using a non blocking client is to *NOT BLOCK* the calling thread!
-
-### Setting callbacks on the ListenableFuture
-
-`execute` methods actually return a `org.asynchttpclient.ListenableFuture` similar to Guava's.
-You can configure listeners to be notified of the Future's completion. 
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
+
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+Future<Integer> f = asyncHttpClient.prepareGet("http://www.example.com/").execute(
+   new AsyncCompletionHandler<Integer>(){
+    
+    @Override
+    public Integer onCompleted(Response response) throws Exception{
+        // Do something with the Response
+        return response.getStatusCode();
+    }
+    
+    @Override
+    public void onThrowable(Throwable t){
+        // Something wrong happened.
+    }
+});
 
-```java
-ListenableFuture<Response> whenResponse = ???;
-Runnable callback = () -> {
-	try  {
-		Response response = whenResponse.get();
-		System.out.println(response);
-	} catch (InterruptedException | ExecutionException e) {
-		e.printStackTrace();
-	}
-};
-java.util.concurrent.Executor executor = ???;
-whenResponse.addListener(() -> ???, executor);
+int statusCode = f.get();
 ```
 
-If the `executor` parameter is null, callback will be executed in the IO thread.
-You *MUST NEVER PERFORM BLOCKING* operations in there, typically sending another request and block on a future.
-
-#### Using custom AsyncHandlers
-
-`execute` methods can take an `org.asynchttpclient.AsyncHandler` to be notified on the different events, such as receiving the status, the headers and body chunks.
-When you don't specify one, AHC will use a `org.asynchttpclient.AsyncCompletionHandler`;
-
-`AsyncHandler` methods can let you abort processing early (return `AsyncHandler.State.ABORT`) and can let you return a computation result from `onCompleted` that will be used as the Future's result.
-See `AsyncCompletionHandler` implementation as an example.
+which is something you want to do for large responses: this way you can process content as soon as it becomes available, piece by piece, without having to buffer it all in memory.
 
-The below sample just capture the response status and skips processing the response body chunks.
-
-Note that returning `ABORT` closed the underlying connection.
+ You have full control on the Response life cycle, so you can decide at any moment to stop processing what the server is sending back:
 
 ```java
 import static org.asynchttpclient.Dsl.*;
+
 import org.asynchttpclient.*;
-import io.netty.handler.codec.http.HttpHeaders;
-
-Future<Integer> whenStatusCode = asyncHttpClient.prepareGet("http://www.example.com/")
-.execute(new AsyncHandler<Integer>() {
-	private Integer status;
-	@Override
-	public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-		status = responseStatus.getStatusCode();
-		return State.ABORT;
-	}
-	@Override
-	public State onHeadersReceived(HttpHeaders headers) throws Exception {
-		return State.ABORT;
-	}
-	@Override
-	public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-		return State.ABORT;
-	}
-	@Override
-	public Integer onCompleted() throws Exception {
-		return status;
-	}
-	@Override
-	public void onThrowable(Throwable t) {
-	}
+import java.util.concurrent.Future;
+
+AsyncHttpClient c = asyncHttpClient();
+Future<String> f = c.prepareGet("http://www.example.com/").execute(new AsyncHandler<String>() {
+    private ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+
+    @Override
+    public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
+        int statusCode = status.getStatusCode();
+        // The Status have been read
+        // If you don't want to read the headers,body or stop processing the response
+        if (statusCode >= 500) {
+            return STATE.ABORT;
+        }
+    }
+
+    @Override
+    public STATE onHeadersReceived(HttpResponseHeaders h) throws Exception {
+        Headers headers = h.getHeaders();
+         // The headers have been read
+         // If you don't want to read the body, or stop processing the response
+         return STATE.ABORT;
+    }
+
+    @Override
+    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+         bytes.write(bodyPart.getBodyPartBytes());
+         return STATE.CONTINUE;
+    }
+
+    @Override
+    public String onCompleted() throws Exception {
+         // Will be invoked once the response has been fully read or a ResponseComplete exception
+         // has been thrown.
+         // NOTE: should probably use Content-Encoding from headers
+         return bytes.toString("UTF-8");
+    }
+
+    @Override
+    public void onThrowable(Throwable t) {
+    }
 });
 
-Integer statusCode = whenStatusCode.get();
+String bodyResponse = f.get();
 ```
 
-#### Using Continuations
+## Configuration
 
-`ListenableFuture` has a `toCompletableFuture` that returns a `CompletableFuture`.
-Beware that canceling this `CompletableFuture` won't properly cancel the ongoing request.
-There's a very good chance we'll return a `CompletionStage` instead in the next release.
+Finally, you can also configure the AsyncHttpClient via its AsyncHttpClientConfig object:
 
 ```java
-CompletableFuture<Response> whenResponse = asyncHttpClient
-            .prepareGet("http://www.example.com/")
-            .execute()
-            .toCompletableFuture()
-            .exceptionally(t -> { /* Something wrong happened... */  } )
-            .thenApply(response -> { /*  Do something with the Response */ return resp; });
-whenResponse.join(); // wait for completion
-```
+AsyncHttpClientConfig cf = new DefaultAsyncHttpClientConfig.Builder()
+    .setProxyServer(new ProxyServer.Builder("127.0.0.1", 38080)).build();
 
-You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
+AsyncHttpClient c = new DefaultAsyncHttpClient(cf);
+```
 
 ## WebSocket
 
-Async Http Client also supports WebSocket.
-You need to pass a `WebSocketUpgradeHandler` where you would register a `WebSocketListener`.
+Async Http Client also support WebSocket by simply doing:
 
 ```java
-WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
+WebSocket websocket = c.prepareGet(getTargetUrl())
       .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(
-          new WebSocketListener() {
+          new WebSocketTextListener() {
+
+          @Override
+          public void onMessage(String message) {
+          }
 
           @Override
           public void onOpen(WebSocket websocket) {
-              websocket.sendTextFrame("...").sendTextFrame("...");
+              websocket.sendTextMessage("...").sendMessage("...");
           }
 
           @Override
           public void onClose(WebSocket websocket) {
-          }
-          
-    		  @Override
-          public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          	System.out.println(payload);
+              latch.countDown();
           }
 
           @Override
@@ -241,41 +203,6 @@ WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
       }).build()).get();
 ```
 
-## Reactive Streams
-
-AsyncHttpClient has build in support for reactive streams.
-
-You can pass a request body as a `Publisher<ByteBuf>` or a `ReactiveStreamsBodyGenerator`.
-
-You can also pass a `StreamedAsyncHandler<T>` whose `onStream` method will be notified with a `Publisher<HttpResponseBodyPart>`.
-
-See tests in package `org.asynchttpclient.reactivestreams` for examples.
-
-## WebDAV
-
-AsyncHttpClient has build in support for the WebDAV protocol.
-The API can be used the same way normal HTTP request are made:
-
-```java
-Request mkcolRequest = new RequestBuilder("MKCOL").setUrl("http://host:port/folder1").build();
-Response response = c.executeRequest(mkcolRequest).get();
-```
-or
-
-```java
-Request propFindRequest = new RequestBuilder("PROPFIND").setUrl("http://host:port).build();
-Response response = c.executeRequest(propFindRequest, new AsyncHandler(){...}).get();
-```
-
-## More
-
-You can find more information on Jean-François Arcand's blog.  Jean-François is the original author of this library.
-Code is sometimes not up-to-date but gives a pretty good idea of advanced features.
-
-* https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/
-* https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/
-* https://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/
-
 ## User Group
 
 Keep up to date on the library development by joining the Asynchronous HTTP Client discussion group
@@ -289,7 +216,9 @@ Of course, Pull Requests are welcome.
 Here a the few rules we'd like you to respect if you do so:
 
 * Only edit the code related to the suggested change, so DON'T automatically format the classes you've edited.
-* Use IntelliJ default formatting rules.
+* Respect the formatting rules:
+  * Indent with 4 spaces
+* Your PR can contain multiple commits when submitting, but once it's been reviewed, we'll ask you to squash them into a single one
 * Regarding licensing:
   * You must be the original author of the code you suggest.
   * You must give the copyright to "the AsyncHttpClient Project"
diff --git a/client/pom.xml b/client/pom.xml
index eacd9053b..ee1eb829f 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -1,72 +1,64 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-project</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client</artifactId>
-  <name>Asynchronous Http Client</name>
-  <description>The Async Http Client (AHC) classes.</description>
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.1.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client</artifactId>
+	<name>Asynchronous Http Client</name>
+	<description>The Async Http Client (AHC) classes.</description>
 
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-jar-plugin</artifactId>
-        <executions>
-          <execution>
-            <goals>
-              <goal>test-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
+	<build>
+		<plugins>
+			<plugin>
+				<artifactId>maven-jar-plugin</artifactId>
+				<executions>
+					<execution>
+						<goals>
+							<goal>test-jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+	</build>
 
-  <dependencies>
-    <dependency>
-      <groupId>org.asynchttpclient</groupId>
-      <artifactId>async-http-client-netty-utils</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-codec-http</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-handler</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-codec-socks</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-handler-proxy</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-transport-native-epoll</artifactId>
-      <classifier>linux-x86_64</classifier>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-resolver-dns</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.reactivestreams</groupId>
-      <artifactId>reactive-streams</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.typesafe.netty</groupId>
-      <artifactId>netty-reactive-streams</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex.rxjava2</groupId>
-      <artifactId>rxjava</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+	<dependencies>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>async-http-client-netty-utils</artifactId>
+			<version>${project.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-codec-http</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-handler</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-transport-native-epoll</artifactId>
+			<classifier>linux-x86_64</classifier>
+		</dependency>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-resolver-dns</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.reactivestreams</groupId>
+			<artifactId>reactive-streams</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>com.typesafe.netty</groupId>
+			<artifactId>netty-reactive-streams</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>io.reactivex.rxjava2</groupId>
+			<artifactId>rxjava</artifactId>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
 </project>
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index c7b60e0b4..5cb8530f8 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -17,105 +17,96 @@
 package org.asynchttpclient;
 
 import io.netty.handler.codec.http.HttpHeaders;
+
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)}
- * convenience method which gets called when the {@link Response} processing is
- * finished. This class also implement the {@link ProgressAsyncHandler}
- * callback, all doing nothing except returning
- * {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
+ * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)} convenience method which gets called when the {@link Response} processing is finished. This class also
+ * implement the {@link ProgressAsyncHandler} callback, all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
  *
- * @param <T> Type of the value that will be returned by the associated
- *            {@link java.util.concurrent.Future}
+ * @param <T> Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
  */
-public abstract class AsyncCompletionHandler<T> implements ProgressAsyncHandler<T> {
+public abstract class AsyncCompletionHandler<T> implements AsyncHandler<T>, ProgressAsyncHandler<T> {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
-  private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
+    private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-  @Override
-  public State onStatusReceived(HttpResponseStatus status) throws Exception {
-    builder.reset();
-    builder.accumulate(status);
-    return State.CONTINUE;
-  }
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+        builder.accumulate(content);
+        return State.CONTINUE;
+    }
 
-  @Override
-  public State onHeadersReceived(HttpHeaders headers) throws Exception {
-    builder.accumulate(headers);
-    return State.CONTINUE;
-  }
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+        builder.reset();
+        builder.accumulate(status);
+        return State.CONTINUE;
+    }
 
-  @Override
-  public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-    builder.accumulate(content);
-    return State.CONTINUE;
-  }
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        builder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-    builder.accumulate(headers);
-    return State.CONTINUE;
-  }
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        builder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
-  @Override
-  public final T onCompleted() throws Exception {
-    return onCompleted(builder.build());
-  }
+    @Override
+    public final T onCompleted() throws Exception {
+        return onCompleted(builder.build());
+    }
 
-  @Override
-  public void onThrowable(Throwable t) {
-    LOGGER.debug(t.getMessage(), t);
-  }
+    @Override
+    public void onThrowable(Throwable t) {
+        LOGGER.debug(t.getMessage(), t);
+    }
 
-  /**
-   * Invoked once the HTTP response processing is finished.
-   *
-   * @param response The {@link Response}
-   * @return T Value that will be returned by the associated
-   * {@link java.util.concurrent.Future}
-   * @throws Exception if something wrong happens
-   */
-  abstract public T onCompleted(Response response) throws Exception;
+    /**
+     * Invoked once the HTTP response processing is finished.
+     *
+     * @param response The {@link Response}
+     * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @throws Exception if something wrong happens
+     */
+    abstract public T onCompleted(Response response) throws Exception;
 
-  /**
-   * Invoked when the HTTP headers have been fully written on the I/O socket.
-   *
-   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-   * or ABORT the current processing.
-   */
-  @Override
-  public State onHeadersWritten() {
-    return State.CONTINUE;
-  }
+    /**
+     * Invoked when the HTTP headers have been fully written on the I/O socket.
+     *
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onHeadersWritten() {
+        return State.CONTINUE;
+    }
 
-  /**
-   * Invoked when the content (a {@link java.io.File}, {@link String} or
-   * {@link java.io.InputStream} has been fully written on the I/O socket.
-   *
-   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-   * or ABORT the current processing.
-   */
-  @Override
-  public State onContentWritten() {
-    return State.CONTINUE;
-  }
+    /**
+     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.InputStream} has been fully written on the I/O socket.
+     *
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onContentWritten() {
+        return State.CONTINUE;
+    }
 
-  /**
-   * Invoked when the I/O operation associated with the {@link Request} body as
-   * been progressed.
-   *
-   * @param amount  The amount of bytes to transfer
-   * @param current The amount of bytes transferred
-   * @param total   The total number of bytes transferred
-   * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-   * or ABORT the current processing.
-   */
-  @Override
-  public State onContentWriteProgress(long amount, long current, long total) {
-    return State.CONTINUE;
-  }
+    /**
+     * Invoked when the I/O operation associated with the {@link Request} body as been progressed.
+     *
+     * @param amount The amount of bytes to transfer
+     * @param current The amount of bytes transferred
+     * @param total The total number of bytes transferred
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onContentWriteProgress(long amount, long current, long total) {
+        return State.CONTINUE;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index c631e412e..15301c2bb 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -21,11 +21,11 @@
  * Simple {@link AsyncHandler} of type {@link Response}
  */
 public class AsyncCompletionHandlerBase extends AsyncCompletionHandler<Response> {
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public Response onCompleted(Response response) throws Exception {
-    return response;
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+        return response;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHandler.java b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
index 090503cf1..0bade6f47 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -15,12 +15,7 @@
  */
 package org.asynchttpclient;
 
-import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.netty.request.NettyRequest;
-
-import java.net.InetSocketAddress;
-import java.util.List;
 
 
 /**
@@ -29,11 +24,11 @@
  * <br>
  * Callback methods get invoked in the following order:
  * <ol>
- * <li>{@link #onStatusReceived(HttpResponseStatus)},</li>
- * <li>{@link #onHeadersReceived(HttpHeaders)},</li>
- * <li>{@link #onBodyPartReceived(HttpResponseBodyPart)}, which could be invoked multiple times,</li>
- * <li>{@link #onTrailingHeadersReceived(HttpHeaders)}, which is only invoked if trailing HTTP headers are received</li>
- * <li>{@link #onCompleted()}, once the response has been fully read.</li>
+ *  <li>{@link #onStatusReceived(HttpResponseStatus)},</li>
+ *  <li>{@link #onHeadersReceived(HttpHeaders)},</li>
+ *  <li>{@link #onBodyPartReceived(HttpResponseBodyPart)}, which could be invoked multiple times,</li>
+ *  <li>{@link #onTrailingHeadersReceived(HttpHeaders)}, which is only invoked if trailing HTTP headers are received</li>
+ *  <li>{@link #onCompleted()}, once the response has been fully read.</li>
  * </ol>
  * <br>
  * Returning a {@link AsyncHandler.State#ABORT} from any of those callback methods will interrupt asynchronous response
@@ -48,7 +43,7 @@
  *   client.prepareGet("http://...").execute(ah);
  * </pre></blockquote>
  * It is recommended to create a new instance instead.
- * <p>
+ * 
  * Do NOT perform any blocking operation in there, typically trying to send another request and call get() on its future.
  * There's a chance you might end up in a dead lock.
  * If you really to perform blocking operation, executed it in a different dedicated thread pool.
@@ -57,195 +52,71 @@
  */
 public interface AsyncHandler<T> {
 
-  /**
-   * Invoked as soon as the HTTP status line has been received
-   *
-   * @param responseStatus the status code and test of the response
-   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-   * @throws Exception if something wrong happens
-   */
-  State onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
-
-  /**
-   * Invoked as soon as the HTTP headers have been received.
-   *
-   * @param headers the HTTP headers.
-   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-   * @throws Exception if something wrong happens
-   */
-  State onHeadersReceived(HttpHeaders headers) throws Exception;
-
-  /**
-   * Invoked as soon as some response body part are received. Could be invoked many times.
-   * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
-   *
-   * @param bodyPart response's body part.
-   * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
-   * @throws Exception if something wrong happens
-   */
-  State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
-
-  /**
-   * Invoked when trailing headers have been received.
-   *
-   * @param headers the trailing HTTP headers.
-   * @return a {@link State} telling to CONTINUE or ABORT the current processing.
-   * @throws Exception if something wrong happens
-   */
-  default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-    return State.CONTINUE;
-  }
-
-  /**
-   * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
-   * produced by implementation of onXXXReceived method invocation.
-   *
-   * @param t a {@link Throwable}
-   */
-  void onThrowable(Throwable t);
-
-  /**
-   * Invoked once the HTTP response processing is finished.
-   * <br>
-   * Gets always invoked as last callback method.
-   *
-   * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
-   * @throws Exception if something wrong happens
-   */
-  T onCompleted() throws Exception;
-
-  /**
-   * Notify the callback before hostname resolution
-   *
-   * @param name the name to be resolved
-   */
-  default void onHostnameResolutionAttempt(String name) {
-  }
-
-  // ////////// DNS /////////////////
-
-  /**
-   * Notify the callback after hostname resolution was successful.
-   *
-   * @param name      the name to be resolved
-   * @param addresses the resolved addresses
-   */
-  default void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-  }
-
-  /**
-   * Notify the callback after hostname resolution failed.
-   *
-   * @param name  the name to be resolved
-   * @param cause the failure cause
-   */
-  default void onHostnameResolutionFailure(String name, Throwable cause) {
-  }
-
-  /**
-   * Notify the callback when trying to open a new connection.
-   * <p>
-   * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
-   *
-   * @param remoteAddress the address we try to connect to
-   */
-  default void onTcpConnectAttempt(InetSocketAddress remoteAddress) {
-  }
-
-  // ////////////// TCP CONNECT ////////
-
-  /**
-   * Notify the callback after a successful connect
-   *
-   * @param remoteAddress the address we try to connect to
-   * @param connection    the connection
-   */
-  default void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
-  }
-
-  /**
-   * Notify the callback after a failed connect.
-   * <p>
-   * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
-   *
-   * @param remoteAddress the address we try to connect to
-   * @param cause         the cause of the failure
-   */
-  default void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
-  }
-
-  /**
-   * Notify the callback before TLS handshake
-   */
-  default void onTlsHandshakeAttempt() {
-  }
-
-  // ////////////// TLS ///////////////
+    enum State {
 
-  /**
-   * Notify the callback after the TLS was successful
-   */
-  default void onTlsHandshakeSuccess() {
-  }
+        /**
+         * Stop the processing.
+         */
+        ABORT,
+        /**
+         * Continue the processing
+         */
+        CONTINUE
+    }
 
-  /**
-   * Notify the callback after the TLS failed
-   *
-   * @param cause the cause of the failure
-   */
-  default void onTlsHandshakeFailure(Throwable cause) {
-  }
-
-  /**
-   * Notify the callback when trying to fetch a connection from the pool.
-   */
-  default void onConnectionPoolAttempt() {
-  }
-
-  // /////////// POOLING /////////////
-
-  /**
-   * Notify the callback when a new connection was successfully fetched from the pool.
-   *
-   * @param connection the connection
-   */
-  default void onConnectionPooled(Channel connection) {
-  }
-
-  /**
-   * Notify the callback when trying to offer a connection to the pool.
-   *
-   * @param connection the connection
-   */
-  default void onConnectionOffer(Channel connection) {
-  }
-
-  /**
-   * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
-   * retry, it will be notified multiple times.
-   *
-   * @param request the real request object as passed to the provider
-   */
-  default void onRequestSend(NettyRequest request) {
-  }
-
-  // //////////// SENDING //////////////
+    /**
+     * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
+     * produced by implementation of onXXXReceived method invocation.
+     *
+     * @param t a {@link Throwable}
+     */
+    void onThrowable(Throwable t);
 
-  /**
-   * Notify the callback every time a request is being retried.
-   */
-  default void onRetry() {
-  }
+    /**
+     * Invoked as soon as some response body part are received. Could be invoked many times.
+     * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
+     *
+     * @param bodyPart response's body part.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
+     * @throws Exception if something wrong happens
+     */
+    State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
 
-  enum State {
+    /**
+     * Invoked as soon as the HTTP status line has been received
+     *
+     * @param responseStatus the status code and test of the response
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+     * @throws Exception if something wrong happens
+     */
+    State onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
 
     /**
-     * Stop the processing.
+     * Invoked as soon as the HTTP headers have been received.
+     *
+     * @param headers the HTTP headers.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+     * @throws Exception if something wrong happens
      */
-    ABORT,
+    State onHeadersReceived(HttpHeaders headers) throws Exception;
+    
+    /**
+     * Invoked when trailing headers have been received. 
+     * @param headers the trailing HTTP headers.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+     * @throws Exception if something wrong happens
+     */
+    default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        return State.CONTINUE;
+    }
+
     /**
-     * Continue the processing
+     * Invoked once the HTTP response processing is finished.
+     * <br>
+     * Gets always invoked as last callback method.
+     *
+     * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @throws Exception if something wrong happens
      */
-    CONTINUE
-  }
+    T onCompleted() throws Exception;
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index 6e126bf96..7d1c0c650 100755
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -35,28 +35,28 @@
  * <blockquote><pre>
  *       AsyncHttpClient c = new AsyncHttpClient();
  *       Future&lt;Response&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncCompletionHandler&lt;Response&gt;() &#123;
- *
+ * 
  *          &#64;Override
  *          public Response onCompleted(Response response) throws IOException &#123;
  *               // Do something
  *              return response;
  *          &#125;
- *
+ * 
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
  *      &#125;);
  *      Response response = f.get();
- *
+ * 
  *      // We are just interested to retrieve the status code.
  *     Future&lt;Integer&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncCompletionHandler&lt;Integer&gt;() &#123;
- *
+ * 
  *          &#64;Override
  *          public Integer onCompleted(Response response) throws IOException &#123;
  *               // Do something
  *              return response.getStatusCode();
  *          &#125;
- *
+ * 
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
@@ -71,44 +71,44 @@
  *      AsyncHttpClient c = new AsyncHttpClient();
  *      Future&lt;String&gt; f = c.prepareGet(TARGET_URL).execute(new AsyncHandler&lt;String&gt;() &#123;
  *          private StringBuilder builder = new StringBuilder();
- *
+ * 
  *          &#64;Override
  *          public STATE onStatusReceived(HttpResponseStatus s) throws Exception &#123;
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
  *          }
- *
+ * 
  *          &#64;Override
  *          public STATE onHeadersReceived(HttpResponseHeaders bodyPart) throws Exception &#123;
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
- *
+ * 
  *          }
  *          &#64;Override
- *
+ * 
  *          public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception &#123;
  *               builder.append(new String(bodyPart));
  *               // return STATE.CONTINUE or STATE.ABORT
  *               return STATE.CONTINUE
  *          &#125;
- *
+ * 
  *          &#64;Override
  *          public String onCompleted() throws Exception &#123;
  *               // Will be invoked once the response has been fully read or a ResponseComplete exception
  *               // has been thrown.
  *               return builder.toString();
  *          &#125;
- *
+ * 
  *          &#64;Override
  *          public void onThrowable(Throwable t) &#123;
  *          &#125;
  *      &#125;);
- *
+ * 
  *      String bodyResponse = f.get();
  * </pre></blockquote>
  * You can asynchronously process the response status,headers and body and decide when to
  * stop the processing the response by returning a new {@link AsyncHandler.State#ABORT} at any moment.
- *
+ * 
  * This class can also be used without the need of {@link AsyncHandler}.
  * <br>
  * <blockquote><pre>
@@ -116,7 +116,7 @@
  *      Future&lt;Response&gt; f = c.prepareGet(TARGET_URL).execute();
  *      Response r = f.get();
  * </pre></blockquote>
- *
+ * 
  * Finally, you can configure the AsyncHttpClient using an {@link DefaultAsyncHttpClientConfig} instance.
  * <br>
  * <blockquote><pre>
@@ -130,163 +130,161 @@
  */
 public interface AsyncHttpClient extends Closeable {
 
-  /**
-   * Return true if closed
-   *
-   * @return true if closed
-   */
-  boolean isClosed();
-
-  /**
-   * Set default signature calculator to use for requests build by this client instance
-   *
-   * @param signatureCalculator a signature calculator
-   * @return {@link RequestBuilder}
-   */
-  AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator);
-
-  /**
-   * Prepare an HTTP client GET request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareGet(String url);
-
-  /**
-   * Prepare an HTTP client CONNECT request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareConnect(String url);
+    /**
+     * Return true if closed
+     *
+     * @return true if closed
+     */
+    boolean isClosed();
 
-  /**
-   * Prepare an HTTP client OPTIONS request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareOptions(String url);
+    /**
+     * Set default signature calculator to use for requests build by this client instance
+     * @param signatureCalculator a signature calculator
+     * @return {@link RequestBuilder}
+     */
+    AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator);
 
-  /**
-   * Prepare an HTTP client HEAD request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareHead(String url);
+    /**
+     * Prepare an HTTP client GET request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareGet(String url);
 
-  /**
-   * Prepare an HTTP client POST request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder preparePost(String url);
+    /**
+     * Prepare an HTTP client CONNECT request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareConnect(String url);
 
-  /**
-   * Prepare an HTTP client PUT request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder preparePut(String url);
+    /**
+     * Prepare an HTTP client OPTIONS request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareOptions(String url);
 
-  /**
-   * Prepare an HTTP client DELETE request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareDelete(String url);
+    /**
+     * Prepare an HTTP client HEAD request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareHead(String url);
 
-  /**
-   * Prepare an HTTP client PATCH request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder preparePatch(String url);
+    /**
+     * Prepare an HTTP client POST request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder preparePost(String url);
 
-  /**
-   * Prepare an HTTP client TRACE request.
-   *
-   * @param url A well formed URL.
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareTrace(String url);
+    /**
+     * Prepare an HTTP client PUT request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder preparePut(String url);
 
-  /**
-   * Construct a {@link RequestBuilder} using a {@link Request}
-   *
-   * @param request a {@link Request}
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareRequest(Request request);
+    /**
+     * Prepare an HTTP client DELETE request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareDelete(String url);
 
-  /**
-   * Construct a {@link RequestBuilder} using a {@link RequestBuilder}
-   *
-   * @param requestBuilder a {@link RequestBuilder}
-   * @return {@link RequestBuilder}
-   */
-  BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder);
+    /**
+     * Prepare an HTTP client PATCH request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder preparePatch(String url);
 
-  /**
-   * Execute an HTTP request.
-   *
-   * @param request {@link Request}
-   * @param handler an instance of {@link AsyncHandler}
-   * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-   * @return a {@link Future} of type T
-   */
-  <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
+    /**
+     * Prepare an HTTP client TRACE request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareTrace(String url);
 
-  /**
-   * Execute an HTTP request.
-   *
-   * @param requestBuilder {@link RequestBuilder}
-   * @param handler        an instance of {@link AsyncHandler}
-   * @param <T>            Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-   * @return a {@link Future} of type T
-   */
-  <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler);
+    /**
+     * Construct a {@link RequestBuilder} using a {@link Request}
+     *
+     * @param request a {@link Request}
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareRequest(Request request);
+    
+    /**
+     * Construct a {@link RequestBuilder} using a {@link RequestBuilder}
+     *
+     * @param requestBuilder a {@link RequestBuilder}
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder);
 
-  /**
-   * Execute an HTTP request.
-   *
-   * @param request {@link Request}
-   * @return a {@link Future} of type Response
-   */
-  ListenableFuture<Response> executeRequest(Request request);
+    /**
+     * Execute an HTTP request.
+     *
+     * @param request {@link Request}
+     * @param handler an instance of {@link AsyncHandler}
+     * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @return a {@link Future} of type T
+     */
+    <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
+    
+    /**
+     * Execute an HTTP request.
+     *
+     * @param requestBuilder {@link RequestBuilder}
+     * @param handler an instance of {@link AsyncHandler}
+     * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @return a {@link Future} of type T
+     */
+    <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler);
 
-  /**
-   * Execute an HTTP request.
-   *
-   * @param requestBuilder {@link RequestBuilder}
-   * @return a {@link Future} of type Response
-   */
-  ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder);
+    /**
+     * Execute an HTTP request.
+     *
+     * @param request {@link Request}
+     * @return a {@link Future} of type Response
+     */
+    ListenableFuture<Response> executeRequest(Request request);
+    
+    /**
+     * Execute an HTTP request.
+     *
+     * @param requestBuilder {@link RequestBuilder}
+     * @return a {@link Future} of type Response
+     */
+    ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder);
 
-  /***
-   * Return details about pooled connections.
-   *
-   * @return a {@link ClientStats}
-   */
-  ClientStats getClientStats();
+    /***
+     * Return details about pooled connections.
+     *
+     * @return a {@link ClientStats}
+     */
+    ClientStats getClientStats();
 
-  /**
-   * Flush ChannelPool partitions based on a predicate
-   *
-   * @param predicate the predicate
-   */
-  void flushChannelPoolPartitions(Predicate<Object> predicate);
+    /**
+     * Flush ChannelPool partitions based on a predicate
+     * 
+     * @param predicate the predicate
+     */
+    void flushChannelPoolPartitions(Predicate<Object> predicate);
 
-  /**
-   * Return the config associated to this client.
-   *
-   * @return the config associated to this client.
-   */
-  AsyncHttpClientConfig getConfig();
+    /**
+     * Return the config associated to this client.
+     * @return the config associated to this client.
+     */
+    AsyncHttpClientConfig getConfig();
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 5fb937eb7..d1395bc00 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -20,9 +20,13 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.Timer;
+
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ThreadFactory;
+
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.KeepAliveStrategy;
-import org.asynchttpclient.cookie.CookieStore;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
@@ -31,303 +35,295 @@
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ThreadFactory;
-import java.util.function.Consumer;
-
 public interface AsyncHttpClientConfig {
 
-  /**
-   * @return the version of AHC
-   */
-  String getAhcVersion();
-
-  /**
-   * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
-   *
-   * @return the name.
-   */
-  String getThreadPoolName();
-
-  /**
-   * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
-   *
-   * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
-   */
-  int getMaxConnections();
-
-  /**
-   * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
-   *
-   * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
-   */
-  int getMaxConnectionsPerHost();
-
-  /**
-   * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
-   *
-   * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
-   */
-  int getConnectTimeout();
-
-  /**
-   * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
-   *
-   * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
-   */
-  int getReadTimeout();
-
-  /**
-   * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
-   *
-   * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
-   */
-  int getPooledConnectionIdleTimeout();
-
-  /**
-   * @return the period in millis to clean the pool of dead and idle connections.
-   */
-  int getConnectionPoolCleanerPeriod();
-
-  /**
-   * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
-   *
-   * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
-   */
-  int getRequestTimeout();
-
-  /**
-   * Is HTTP redirect enabled
-   *
-   * @return true if enabled.
-   */
-  boolean isFollowRedirect();
-
-  /**
-   * Get the maximum number of HTTP redirect
-   *
-   * @return the maximum number of HTTP redirect
-   */
-  int getMaxRedirects();
-
-  /**
-   * Is the {@link ChannelPool} support enabled.
-   *
-   * @return true if keep-alive is enabled
-   */
-  boolean isKeepAlive();
-
-  /**
-   * Return the USER_AGENT header value
-   *
-   * @return the USER_AGENT header value
-   */
-  String getUserAgent();
-
-  /**
-   * Is HTTP compression enforced.
-   *
-   * @return true if compression is enforced
-   */
-  boolean isCompressionEnforced();
-
-  /**
-   * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
-   *
-   * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
-   * provided, this method will return <code>null</code>
-   */
-  ThreadFactory getThreadFactory();
-
-  /**
-   * An instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
-   *
-   * @return instance of {@link ProxyServer}
-   */
-  ProxyServerSelector getProxyServerSelector();
-
-  /**
-   * Return an instance of {@link SslContext} used for SSL connection.
-   *
-   * @return an instance of {@link SslContext} used for SSL connection.
-   */
-  SslContext getSslContext();
-
-  /**
-   * Return the current {@link Realm}
-   *
-   * @return the current {@link Realm}
-   */
-  Realm getRealm();
-
-  /**
-   * Return the list of {@link RequestFilter}
-   *
-   * @return Unmodifiable list of {@link ResponseFilter}
-   */
-  List<RequestFilter> getRequestFilters();
-
-  /**
-   * Return the list of {@link ResponseFilter}
-   *
-   * @return Unmodifiable list of {@link ResponseFilter}
-   */
-  List<ResponseFilter> getResponseFilters();
-
-  /**
-   * Return the list of {@link java.io.IOException}
-   *
-   * @return Unmodifiable list of {@link java.io.IOException}
-   */
-  List<IOExceptionFilter> getIoExceptionFilters();
-
-  /**
-   * Return cookie store that is used to store and retrieve cookies
-   *
-   * @return {@link CookieStore} object
-   */
-  CookieStore getCookieStore();
-
-  /**
-   * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
-   *
-   * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
-   */
-  int getMaxRequestRetry();
+    /**
+     * @return the version of AHC
+     */
+    String getAhcVersion();
+
+    /**
+     * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
+     *
+     * @return the name.
+     */
+    String getThreadPoolName();
+
+    /**
+     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
+     *
+     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
+     */
+    int getMaxConnections();
+
+    /**
+     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
+     *
+     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
+     */
+    int getMaxConnectionsPerHost();
+
+    /**
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+     *
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+     */
+    int getConnectTimeout();
+
+    /**
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+     *
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+     */
+    int getReadTimeout();
+
+    /**
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
+     *
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
+     */
+    int getPooledConnectionIdleTimeout();
+
+    /**
+     * @return the period in millis to clean the pool of dead and idle connections.
+     */
+    int getConnectionPoolCleanerPeriod();
+
+    /**
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
+     *
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
+     */
+    int getRequestTimeout();
+
+    /**
+     * Is HTTP redirect enabled
+     *
+     * @return true if enabled.
+     */
+    boolean isFollowRedirect();
+
+    /**
+     * Get the maximum number of HTTP redirect
+     *
+     * @return the maximum number of HTTP redirect
+     */
+    int getMaxRedirects();
+
+    /**
+     * Is the {@link ChannelPool} support enabled.
+     *
+     * @return true if keep-alive is enabled
+     */
+    boolean isKeepAlive();
+
+    /**
+     * Return the USER_AGENT header value
+     *
+     * @return the USER_AGENT header value
+     */
+    String getUserAgent();
+
+    /**
+     * Is HTTP compression enforced.
+     *
+     * @return true if compression is enforced
+     */
+    boolean isCompressionEnforced();
+
+    /**
+     * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
+     *
+     * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
+     *         provided, this method will return <code>null</code>
+     */
+    ThreadFactory getThreadFactory();
+
+    /**
+     * An instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
+     *
+     * @return instance of {@link ProxyServer}
+     */
+    ProxyServerSelector getProxyServerSelector();
+
+    /**
+     * Return an instance of {@link SslContext} used for SSL connection.
+     *
+     * @return an instance of {@link SslContext} used for SSL connection.
+     */
+    SslContext getSslContext();
+
+    /**
+     * Return the current {@link Realm}
+     *
+     * @return the current {@link Realm}
+     */
+    Realm getRealm();
+
+    /**
+     * Return the list of {@link RequestFilter}
+     *
+     * @return Unmodifiable list of {@link ResponseFilter}
+     */
+    List<RequestFilter> getRequestFilters();
+
+    /**
+     * Return the list of {@link ResponseFilter}
+     *
+     * @return Unmodifiable list of {@link ResponseFilter}
+     */
+    List<ResponseFilter> getResponseFilters();
+
+    /**
+     * Return the list of {@link java.io.IOException}
+     *
+     * @return Unmodifiable list of {@link java.io.IOException}
+     */
+    List<IOExceptionFilter> getIoExceptionFilters();
+
+    /**
+     * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+     *
+     * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+     */
+    int getMaxRequestRetry();
+
+    /**
+     * @return the disableUrlEncodingForBoundRequests
+     */
+    boolean isDisableUrlEncodingForBoundRequests();
+
+    /**
+     * @return true if AHC is to use a LAX cookie encoder, eg accept illegal chars in cookie value
+     */
+    boolean isUseLaxCookieEncoder();
 
-  /**
-   * @return the disableUrlEncodingForBoundRequests
-   */
-  boolean isDisableUrlEncodingForBoundRequests();
+    /**
+     * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
+     * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
+     *
+     * @return <code>true</code> if strict 302 handling is to be used, otherwise <code>false</code>.
+     */
+    boolean isStrict302Handling();
 
-  /**
-   * @return true if AHC is to use a LAX cookie encoder, eg accept illegal chars in cookie value
-   */
-  boolean isUseLaxCookieEncoder();
+    /**
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     */
+    int getConnectionTtl();
 
-  /**
-   * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
-   * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
-   *
-   * @return <code>true</code> if strict 302 handling is to be used, otherwise <code>false</code>.
-   */
-  boolean isStrict302Handling();
+    boolean isUseOpenSsl();
 
-  /**
-   * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
-   */
-  int getConnectionTtl();
+    boolean isUseInsecureTrustManager();
 
-  boolean isUseOpenSsl();
+    /**
+     * @return true to disable all HTTPS behaviors AT ONCE, such as hostname verification and SNI
+     */
+    boolean isDisableHttpsEndpointIdentificationAlgorithm();
 
-  boolean isUseInsecureTrustManager();
+    /**
+     * @return the array of enabled protocols
+     */
+    String[] getEnabledProtocols();
 
-  /**
-   * @return true to disable all HTTPS behaviors AT ONCE, such as hostname verification and SNI
-   */
-  boolean isDisableHttpsEndpointIdentificationAlgorithm();
+    /**
+     * @return the array of enabled cipher suites
+     */
+    String[] getEnabledCipherSuites();
 
-  /**
-   * @return the array of enabled protocols
-   */
-  String[] getEnabledProtocols();
+    /**
+     * @return the size of the SSL session cache, 0 means using the default value
+     */
+    int getSslSessionCacheSize();
 
-  /**
-   * @return the array of enabled cipher suites
-   */
-  String[] getEnabledCipherSuites();
+    /**
+     * @return the SSL session timeout in seconds, 0 means using the default value
+     */
+    int getSslSessionTimeout();
 
-  /**
-   * @return the size of the SSL session cache, 0 means using the default value
-   */
-  int getSslSessionCacheSize();
+    int getHttpClientCodecMaxInitialLineLength();
 
-  /**
-   * @return the SSL session timeout in seconds, 0 means using the default value
-   */
-  int getSslSessionTimeout();
+    int getHttpClientCodecMaxHeaderSize();
 
-  int getHttpClientCodecMaxInitialLineLength();
+    int getHttpClientCodecMaxChunkSize();
 
-  int getHttpClientCodecMaxHeaderSize();
+    int getHttpClientCodecInitialBufferSize();
 
-  int getHttpClientCodecMaxChunkSize();
+    boolean isDisableZeroCopy();
 
-  int getHttpClientCodecInitialBufferSize();
+    int getHandshakeTimeout();
 
-  boolean isDisableZeroCopy();
+    SslEngineFactory getSslEngineFactory();
 
-  int getHandshakeTimeout();
+    int getChunkedFileChunkSize();
 
-  SslEngineFactory getSslEngineFactory();
+    int getWebSocketMaxBufferSize();
 
-  int getChunkedFileChunkSize();
+    int getWebSocketMaxFrameSize();
 
-  int getWebSocketMaxBufferSize();
+    boolean isKeepEncodingHeader();
 
-  int getWebSocketMaxFrameSize();
+    int getShutdownQuietPeriod();
 
-  boolean isKeepEncodingHeader();
+    int getShutdownTimeout();
 
-  int getShutdownQuietPeriod();
+    Map<ChannelOption<Object>, Object> getChannelOptions();
 
-  int getShutdownTimeout();
+    EventLoopGroup getEventLoopGroup();
 
-  Map<ChannelOption<Object>, Object> getChannelOptions();
+    boolean isUseNativeTransport();
 
-  EventLoopGroup getEventLoopGroup();
+    AdditionalChannelInitializer getHttpAdditionalChannelInitializer();
 
-  boolean isUseNativeTransport();
+    AdditionalChannelInitializer getWsAdditionalChannelInitializer();
 
-  Consumer<Channel> getHttpAdditionalChannelInitializer();
+    ResponseBodyPartFactory getResponseBodyPartFactory();
 
-  Consumer<Channel> getWsAdditionalChannelInitializer();
+    ChannelPool getChannelPool();
 
-  ResponseBodyPartFactory getResponseBodyPartFactory();
+    Timer getNettyTimer();
 
-  ChannelPool getChannelPool();
+    KeepAliveStrategy getKeepAliveStrategy();
 
-  Timer getNettyTimer();
+    boolean isValidateResponseHeaders();
 
-  KeepAliveStrategy getKeepAliveStrategy();
+    boolean isAggregateWebSocketFrameFragments();
 
-  boolean isValidateResponseHeaders();
+    boolean isTcpNoDelay();
 
-  boolean isAggregateWebSocketFrameFragments();
+    boolean isSoReuseAddress();
 
-  boolean isEnableWebSocketCompression();
+    int getSoLinger();
 
-  boolean isTcpNoDelay();
+    int getSoSndBuf();
 
-  boolean isSoReuseAddress();
+    int getSoRcvBuf();
 
-  int getSoLinger();
+    ByteBufAllocator getAllocator();
 
-  int getSoSndBuf();
+    int getIoThreadsCount();
 
-  int getSoRcvBuf();
+    interface AdditionalChannelInitializer {
 
-  ByteBufAllocator getAllocator();
+        void initChannel(Channel channel) throws Exception;
+    }
 
-  int getIoThreadsCount();
+    enum ResponseBodyPartFactory {
 
-  enum ResponseBodyPartFactory {
+        EAGER {
+            @Override
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new EagerResponseBodyPart(buf, last);
+            }
+        },
 
-    EAGER {
-      @Override
-      public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-        return new EagerResponseBodyPart(buf, last);
-      }
-    },
+        LAZY {
 
-    LAZY {
-      @Override
-      public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-        return new LazyResponseBodyPart(buf, last);
-      }
-    };
+            @Override
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new LazyResponseBodyPart(buf, last);
+            }
+        };
 
-    public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
-  }
+        public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
index 1fcc3ed8b..b2570056f 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientState.java
@@ -17,13 +17,13 @@
 
 public class AsyncHttpClientState {
 
-  private final AtomicBoolean closed;
-
-  AsyncHttpClientState(AtomicBoolean closed) {
-    this.closed = closed;
-  }
-
-  public boolean isClosed() {
-    return closed.get();
-  }
+    private final AtomicBoolean closed;
+    
+    public AsyncHttpClientState(AtomicBoolean closed) {
+        this.closed = closed;
+    }
+    
+    public boolean isClosed() {
+        return closed.get();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
index d82d9b02a..e4ad98879 100644
--- a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -14,28 +14,28 @@
 
 public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
 
-  private final AsyncHttpClient client;
+    private final AsyncHttpClient client;
 
-  public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
-    super(method, isDisableUrlEncoding, validateHeaders);
-    this.client = client;
-  }
+    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
+        super(method, isDisableUrlEncoding, validateHeaders);
+        this.client = client;
+    }
 
-  public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
-    super(method, isDisableUrlEncoding);
-    this.client = client;
-  }
+    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
+        super(method, isDisableUrlEncoding);
+        this.client = client;
+    }
 
-  public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
-    super(prototype);
-    this.client = client;
-  }
+    public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
+        super(prototype);
+        this.client = client;
+    }
 
-  public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) {
-    return client.executeRequest(build(), handler);
-  }
+    public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) {
+        return client.executeRequest(build(), handler);
+    }
 
-  public ListenableFuture<Response> execute() {
-    return client.executeRequest(build(), new AsyncCompletionHandlerBase());
-  }
+    public ListenableFuture<Response> execute() {
+        return client.executeRequest(build(), new AsyncCompletionHandlerBase());
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ClientStats.java b/client/src/main/java/org/asynchttpclient/ClientStats.java
index 9f44604c2..d6e4efa4a 100644
--- a/client/src/main/java/org/asynchttpclient/ClientStats.java
+++ b/client/src/main/java/org/asynchttpclient/ClientStats.java
@@ -22,71 +22,71 @@
  */
 public class ClientStats {
 
-  private final Map<String, HostStats> statsPerHost;
+    private final Map<String, HostStats> statsPerHost;
 
-  public ClientStats(Map<String, HostStats> statsPerHost) {
-    this.statsPerHost = Collections.unmodifiableMap(statsPerHost);
-  }
+    public ClientStats(Map<String, HostStats> statsPerHost) {
+        this.statsPerHost = Collections.unmodifiableMap(statsPerHost);
+    }
 
-  /**
-   * @return A map from hostname to statistics on that host's connections.
-   * The returned map is unmodifiable.
-   */
-  public Map<String, HostStats> getStatsPerHost() {
-    return statsPerHost;
-  }
+    /**
+     * @return A map from hostname to statistics on that host's connections.
+     * The returned map is unmodifiable.
+     */
+    public Map<String, HostStats> getStatsPerHost() {
+        return statsPerHost;
+    }
 
-  /**
-   * @return The sum of {@link #getTotalActiveConnectionCount()} and {@link #getTotalIdleConnectionCount()},
-   * a long representing the total number of connections in the connection pool.
-   */
-  public long getTotalConnectionCount() {
-    return statsPerHost
-            .values()
-            .stream()
-            .mapToLong(HostStats::getHostConnectionCount)
-            .sum();
-  }
+    /**
+     * @return The sum of {@link #getTotalActiveConnectionCount()} and {@link #getTotalIdleConnectionCount()},
+     * a long representing the total number of connections in the connection pool.
+     */
+    public long getTotalConnectionCount() {
+        return statsPerHost
+                .values()
+                .stream()
+                .mapToLong(HostStats::getHostConnectionCount)
+                .sum();
+    }
 
-  /**
-   * @return A long representing the number of active connections in the connection pool.
-   */
-  public long getTotalActiveConnectionCount() {
-    return statsPerHost
-            .values()
-            .stream()
-            .mapToLong(HostStats::getHostActiveConnectionCount)
-            .sum();
-  }
+    /**
+     * @return A long representing the number of active connections in the connection pool.
+     */
+    public long getTotalActiveConnectionCount() {
+        return statsPerHost
+                .values()
+                .stream()
+                .mapToLong(HostStats::getHostActiveConnectionCount)
+                .sum();
+    }
 
-  /**
-   * @return A long representing the number of idle connections in the connection pool.
-   */
-  public long getTotalIdleConnectionCount() {
-    return statsPerHost
-            .values()
-            .stream()
-            .mapToLong(HostStats::getHostIdleConnectionCount)
-            .sum();
-  }
+    /**
+     * @return A long representing the number of idle connections in the connection pool.
+     */
+    public long getTotalIdleConnectionCount() {
+        return statsPerHost
+                .values()
+                .stream()
+                .mapToLong(HostStats::getHostIdleConnectionCount)
+                .sum();
+    }
 
-  @Override
-  public String toString() {
-    return "There are " + getTotalConnectionCount() +
-            " total connections, " + getTotalActiveConnectionCount() +
-            " are active and " + getTotalIdleConnectionCount() + " are idle.";
-  }
+    @Override
+    public String toString() {
+        return "There are " + getTotalConnectionCount() +
+                " total connections, " + getTotalActiveConnectionCount() +
+                " are active and " + getTotalIdleConnectionCount() + " are idle.";
+    }
 
-  @Override
-  public boolean equals(final Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-    final ClientStats that = (ClientStats) o;
-    return Objects.equals(statsPerHost, that.statsPerHost);
-  }
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        final ClientStats that = (ClientStats) o;
+        return Objects.equals(statsPerHost, that.statsPerHost);
+    }
 
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(statsPerHost);
-  }
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(statsPerHost);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 833804db6..bded469db 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -16,284 +16,269 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.channel.EventLoopGroup;
-import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
-import io.netty.util.concurrent.DefaultThreadFactory;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Predicate;
+
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ConnectionSemaphore;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.List;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Predicate;
-
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 /**
  * Default and threadsafe implementation of {@link AsyncHttpClient}.
  */
 public class DefaultAsyncHttpClient implements AsyncHttpClient {
 
-  private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
-  private final AsyncHttpClientConfig config;
-  private final boolean noRequestFilters;
-  private final AtomicBoolean closed = new AtomicBoolean(false);
-  private final ChannelManager channelManager;
-  private final NettyRequestSender requestSender;
-  private final boolean allowStopNettyTimer;
-  private final Timer nettyTimer;
-
-  /**
-   * Default signature calculator to use for all requests constructed by this
-   * client instance.
-   */
-  private SignatureCalculator signatureCalculator;
-
-  /**
-   * Create a new HTTP Asynchronous Client using the default
-   * {@link DefaultAsyncHttpClientConfig} configuration. The default
-   * {@link AsyncHttpClient} that will be used will be based on the classpath
-   * configuration.
-   * <p>
-   * If none of those providers are found, then the engine will throw an
-   * IllegalStateException.
-   */
-  public DefaultAsyncHttpClient() {
-    this(new DefaultAsyncHttpClientConfig.Builder().build());
-  }
-
-  /**
-   * Create a new HTTP Asynchronous Client using the specified
-   * {@link DefaultAsyncHttpClientConfig} configuration. This configuration
-   * will be passed to the default {@link AsyncHttpClient} that will be
-   * selected based on the classpath configuration.
-   *
-   * @param config a {@link DefaultAsyncHttpClientConfig}
-   */
-  public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
-
-    this.config = config;
-    this.noRequestFilters = config.getRequestFilters().isEmpty();
-    allowStopNettyTimer = config.getNettyTimer() == null;
-    nettyTimer = allowStopNettyTimer ? newNettyTimer(config) : config.getNettyTimer();
-
-    channelManager = new ChannelManager(config, nettyTimer);
-    requestSender = new NettyRequestSender(config, channelManager, nettyTimer, new AsyncHttpClientState(closed));
-    channelManager.configureBootstraps(requestSender);
-  }
-
-  private Timer newNettyTimer(AsyncHttpClientConfig config) {
-    ThreadFactory threadFactory = new DefaultThreadFactory(config.getThreadPoolName() + "-timer");
-    HashedWheelTimer timer = new HashedWheelTimer(threadFactory);
-    timer.start();
-    return timer;
-  }
-
-  @Override
-  public void close() {
-    if (closed.compareAndSet(false, true)) {
-      try {
-        channelManager.close();
-      } catch (Throwable t) {
-        LOGGER.warn("Unexpected error on ChannelManager close", t);
-      }
-      if (allowStopNettyTimer) {
+    private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
+    private final AsyncHttpClientConfig config;
+    private final AtomicBoolean closed = new AtomicBoolean(false);
+    private final ChannelManager channelManager;
+    private final ConnectionSemaphore connectionSemaphore;
+    private final NettyRequestSender requestSender;
+    private final boolean allowStopNettyTimer;
+    private final Timer nettyTimer;
+
+    /**
+     * Default signature calculator to use for all requests constructed by this
+     * client instance.
+     *
+     * @since 1.1
+     */
+    protected SignatureCalculator signatureCalculator;
+
+    /**
+     * Create a new HTTP Asynchronous Client using the default
+     * {@link DefaultAsyncHttpClientConfig} configuration. The default
+     * {@link AsyncHttpClient} that will be used will be based on the classpath
+     * configuration.
+     *
+     * If none of those providers are found, then the engine will throw an
+     * IllegalStateException.
+     */
+    public DefaultAsyncHttpClient() {
+        this(new DefaultAsyncHttpClientConfig.Builder().build());
+    }
+
+    /**
+     * Create a new HTTP Asynchronous Client using the specified
+     * {@link DefaultAsyncHttpClientConfig} configuration. This configuration
+     * will be passed to the default {@link AsyncHttpClient} that will be
+     * selected based on the classpath configuration.
+     *
+     * @param config a {@link DefaultAsyncHttpClientConfig}
+     */
+    public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
+
+        this.config = config;
+
+        allowStopNettyTimer = config.getNettyTimer() == null;
+        nettyTimer = allowStopNettyTimer ? newNettyTimer() : config.getNettyTimer();
+
+        channelManager = new ChannelManager(config, nettyTimer);
+        connectionSemaphore = new ConnectionSemaphore(config);
+        requestSender = new NettyRequestSender(config, channelManager, connectionSemaphore, nettyTimer, new AsyncHttpClientState(closed));
+        channelManager.configureBootstraps(requestSender);
+    }
+
+    private Timer newNettyTimer() {
+        HashedWheelTimer timer = new HashedWheelTimer();
+        timer.start();
+        return timer;
+    }
+
+    @Override
+    public void close() {
+        if (closed.compareAndSet(false, true)) {
+            try {
+                channelManager.close();
+            } catch (Throwable t) {
+                LOGGER.warn("Unexpected error on ChannelManager close", t);
+            }
+            if (allowStopNettyTimer) {
+                try {
+                    nettyTimer.stop();
+                } catch (Throwable t) {
+                    LOGGER.warn("Unexpected error on HashedWheelTimer close", t);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean isClosed() {
+        return closed.get();
+    }
+
+    @Override
+    public DefaultAsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        this.signatureCalculator = signatureCalculator;
+        return this;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return requestBuilder("GET", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return requestBuilder("CONNECT", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return requestBuilder("OPTIONS", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return requestBuilder("HEAD", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return requestBuilder("POST", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return requestBuilder("PUT", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return requestBuilder("DELETE", url);
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return requestBuilder("PATCH", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return requestBuilder("TRACE", url);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return requestBuilder(request);
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return prepareRequest(requestBuilder.build());
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+
+        if (config.getRequestFilters().isEmpty()) {
+            return execute(request, handler);
+
+        } else {
+            FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
+            try {
+                fc = preProcessRequest(fc);
+            } catch (Exception e) {
+                handler.onThrowable(e);
+                return new ListenableFuture.CompletedFailure<>("preProcessRequest failed", e);
+            }
+
+            return execute(fc.getRequest(), fc.getAsyncHandler());
+        }
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return executeRequest(requestBuilder.build(), handler);
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) {
+        return executeRequest(request, new AsyncCompletionHandlerBase());
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return executeRequest(requestBuilder.build());
+    }
+
+    private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
         try {
-          nettyTimer.stop();
-        } catch (Throwable t) {
-          LOGGER.warn("Unexpected error on HashedWheelTimer close", t);
+            return requestSender.sendRequest(request, asyncHandler, null, false);
+        } catch (Exception e) {
+            asyncHandler.onThrowable(e);
+            return new ListenableFuture.CompletedFailure<>(e);
         }
-      }
     }
-  }
-
-  @Override
-  public boolean isClosed() {
-    return closed.get();
-  }
-
-  @Override
-  public DefaultAsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-    this.signatureCalculator = signatureCalculator;
-    return this;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareGet(String url) {
-    return requestBuilder("GET", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareConnect(String url) {
-    return requestBuilder("CONNECT", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareOptions(String url) {
-    return requestBuilder("OPTIONS", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareHead(String url) {
-    return requestBuilder("HEAD", url);
-  }
-
-  @Override
-  public BoundRequestBuilder preparePost(String url) {
-    return requestBuilder("POST", url);
-  }
-
-  @Override
-  public BoundRequestBuilder preparePut(String url) {
-    return requestBuilder("PUT", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareDelete(String url) {
-    return requestBuilder("DELETE", url);
-  }
-
-  @Override
-  public BoundRequestBuilder preparePatch(String url) {
-    return requestBuilder("PATCH", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareTrace(String url) {
-    return requestBuilder("TRACE", url);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(Request request) {
-    return requestBuilder(request);
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-    return prepareRequest(requestBuilder.build());
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-    if (config.getCookieStore() != null) {
-      try {
-        List<Cookie> cookies = config.getCookieStore().get(request.getUri());
-        if (!cookies.isEmpty()) {
-          RequestBuilder requestBuilder = new RequestBuilder(request);
-          for (Cookie cookie : cookies) {
-            requestBuilder.addOrReplaceCookie(cookie);
-          }
-          request = requestBuilder.build();
+
+    /**
+     * Configure and execute the associated {@link RequestFilter}. This class
+     * may decorate the {@link Request} and {@link AsyncHandler}
+     *
+     * @param fc {@link FilterContext}
+     * @return {@link FilterContext}
+     */
+    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
+        for (RequestFilter asyncFilter : config.getRequestFilters()) {
+            fc = asyncFilter.filter(fc);
+            assertNotNull(fc, "filterContext");
+        }
+
+        Request request = fc.getRequest();
+        if (fc.getAsyncHandler() instanceof ResumableAsyncHandler) {
+            request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
+        }
+
+        if (request.getRangeOffset() != 0) {
+            RequestBuilder builder = new RequestBuilder(request);
+            builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
+            request = builder.build();
         }
-      } catch (Exception e) {
-        handler.onThrowable(e);
-        return new ListenableFuture.CompletedFailure<>("Failed to set cookies of request", e);
-      }
+        fc = new FilterContext.FilterContextBuilder<>(fc).request(request).build();
+        return fc;
+    }
+
+    public ChannelPool getChannelPool() {
+        return channelManager.getChannelPool();
+    }
+
+    public EventLoopGroup getEventLoopGroup() {
+        return channelManager.getEventLoopGroup();
     }
 
-    if (noRequestFilters) {
-      return execute(request, handler);
-    } else {
-      FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
-      try {
-        fc = preProcessRequest(fc);
-      } catch (Exception e) {
-        handler.onThrowable(e);
-        return new ListenableFuture.CompletedFailure<>("preProcessRequest failed", e);
-      }
-
-      return execute(fc.getRequest(), fc.getAsyncHandler());
+    @Override
+    public ClientStats getClientStats() {
+        return channelManager.getClientStats();
     }
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-    return executeRequest(requestBuilder.build(), handler);
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(Request request) {
-    return executeRequest(request, new AsyncCompletionHandlerBase());
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-    return executeRequest(requestBuilder.build());
-  }
-
-  private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
-    try {
-      return requestSender.sendRequest(request, asyncHandler, null);
-    } catch (Exception e) {
-      asyncHandler.onThrowable(e);
-      return new ListenableFuture.CompletedFailure<>(e);
+    
+    @Override
+    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+        getChannelPool().flushPartitions(predicate);
     }
-  }
-
-  /**
-   * Configure and execute the associated {@link RequestFilter}. This class
-   * may decorate the {@link Request} and {@link AsyncHandler}
-   *
-   * @param fc {@link FilterContext}
-   * @return {@link FilterContext}
-   */
-  private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
-    for (RequestFilter asyncFilter : config.getRequestFilters()) {
-      fc = asyncFilter.filter(fc);
-      assertNotNull(fc, "filterContext");
+
+    protected BoundRequestBuilder requestBuilder(String method, String url) {
+        return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
     }
 
-    Request request = fc.getRequest();
-    if (fc.getAsyncHandler() instanceof ResumableAsyncHandler) {
-      request = ResumableAsyncHandler.class.cast(fc.getAsyncHandler()).adjustRequestRange(request);
+    protected BoundRequestBuilder requestBuilder(Request prototype) {
+        return new BoundRequestBuilder(this, prototype).setSignatureCalculator(signatureCalculator);
     }
 
-    if (request.getRangeOffset() != 0) {
-      RequestBuilder builder = new RequestBuilder(request);
-      builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
-      request = builder.build();
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return this.config;
     }
-    fc = new FilterContext.FilterContextBuilder<>(fc).request(request).build();
-    return fc;
-  }
-
-  public ChannelPool getChannelPool() {
-    return channelManager.getChannelPool();
-  }
-
-  public EventLoopGroup getEventLoopGroup() {
-    return channelManager.getEventLoopGroup();
-  }
-
-  @Override
-  public ClientStats getClientStats() {
-    return channelManager.getClientStats();
-  }
-
-  @Override
-  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-    getChannelPool().flushPartitions(predicate);
-  }
-
-  protected BoundRequestBuilder requestBuilder(String method, String url) {
-    return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
-  }
-
-  protected BoundRequestBuilder requestBuilder(Request prototype) {
-    return new BoundRequestBuilder(this, prototype).setSignatureCalculator(signatureCalculator);
-  }
-
-  @Override
-  public AsyncHttpClientConfig getConfig() {
-    return this.config;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 322bea196..2010c4594 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -15,18 +15,26 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.handler.ssl.SslContext;
 import io.netty.util.Timer;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.ThreadFactory;
+
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
 import org.asynchttpclient.channel.KeepAliveStrategy;
-import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
-import org.asynchttpclient.cookie.CookieStore;
-import org.asynchttpclient.cookie.ThreadSafeCookieStore;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
@@ -34,1228 +42,1180 @@
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
-import java.util.*;
-import java.util.concurrent.ThreadFactory;
-import java.util.function.Consumer;
-
-import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
-
 /**
  * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this object default behavior by doing: <br>
  * -Dorg.asynchttpclient.nameOfTheProperty
- *
+ * 
  * @see AsyncHttpClientConfig for documentation
  */
 public class DefaultAsyncHttpClientConfig implements AsyncHttpClientConfig {
 
-  // http
-  private final boolean followRedirect;
-  private final int maxRedirects;
-  private final boolean strict302Handling;
-  private final boolean compressionEnforced;
-  private final String userAgent;
-  private final Realm realm;
-  private final int maxRequestRetry;
-  private final boolean disableUrlEncodingForBoundRequests;
-  private final boolean useLaxCookieEncoder;
-  private final boolean disableZeroCopy;
-  private final boolean keepEncodingHeader;
-  private final ProxyServerSelector proxyServerSelector;
-  private final boolean validateResponseHeaders;
-
-  // websockets
-  private final boolean aggregateWebSocketFrameFragments;
-  private final boolean enablewebSocketCompression;
-  private final int webSocketMaxBufferSize;
-  private final int webSocketMaxFrameSize;
-
-  // timeouts
-  private final int connectTimeout;
-  private final int requestTimeout;
-  private final int readTimeout;
-  private final int shutdownQuietPeriod;
-  private final int shutdownTimeout;
-
-  // keep-alive
-  private final boolean keepAlive;
-  private final int pooledConnectionIdleTimeout;
-  private final int connectionPoolCleanerPeriod;
-  private final int connectionTtl;
-  private final int maxConnections;
-  private final int maxConnectionsPerHost;
-  private final ChannelPool channelPool;
-  private final KeepAliveStrategy keepAliveStrategy;
-
-  // ssl
-  private final boolean useOpenSsl;
-  private final boolean useInsecureTrustManager;
-  private final boolean disableHttpsEndpointIdentificationAlgorithm;
-  private final int handshakeTimeout;
-  private final String[] enabledProtocols;
-  private final String[] enabledCipherSuites;
-  private final int sslSessionCacheSize;
-  private final int sslSessionTimeout;
-  private final SslContext sslContext;
-  private final SslEngineFactory sslEngineFactory;
-
-  // filters
-  private final List<RequestFilter> requestFilters;
-  private final List<ResponseFilter> responseFilters;
-  private final List<IOExceptionFilter> ioExceptionFilters;
-
-  // cookie store
-  private final CookieStore cookieStore;
-
-  // internals
-  private final String threadPoolName;
-  private final int httpClientCodecMaxInitialLineLength;
-  private final int httpClientCodecMaxHeaderSize;
-  private final int httpClientCodecMaxChunkSize;
-  private final int httpClientCodecInitialBufferSize;
-  private final int chunkedFileChunkSize;
-  private final Map<ChannelOption<Object>, Object> channelOptions;
-  private final EventLoopGroup eventLoopGroup;
-  private final boolean useNativeTransport;
-  private final ByteBufAllocator allocator;
-  private final boolean tcpNoDelay;
-  private final boolean soReuseAddress;
-  private final int soLinger;
-  private final int soSndBuf;
-  private final int soRcvBuf;
-  private final Timer nettyTimer;
-  private final ThreadFactory threadFactory;
-  private final Consumer<Channel> httpAdditionalChannelInitializer;
-  private final Consumer<Channel> wsAdditionalChannelInitializer;
-  private final ResponseBodyPartFactory responseBodyPartFactory;
-  private final int ioThreadsCount;
-
-  private DefaultAsyncHttpClientConfig(// http
-                                       boolean followRedirect,
-                                       int maxRedirects,
-                                       boolean strict302Handling,
-                                       boolean compressionEnforced,
-                                       String userAgent,
-                                       Realm realm,
-                                       int maxRequestRetry,
-                                       boolean disableUrlEncodingForBoundRequests,
-                                       boolean useLaxCookieEncoder,
-                                       boolean disableZeroCopy,
-                                       boolean keepEncodingHeader,
-                                       ProxyServerSelector proxyServerSelector,
-                                       boolean validateResponseHeaders,
-                                       boolean aggregateWebSocketFrameFragments,
-                                       boolean enablewebSocketCompression,
-
-                                       // timeouts
-                                       int connectTimeout,
-                                       int requestTimeout,
-                                       int readTimeout,
-                                       int shutdownQuietPeriod,
-                                       int shutdownTimeout,
-
-                                       // keep-alive
-                                       boolean keepAlive,
-                                       int pooledConnectionIdleTimeout,
-                                       int connectionPoolCleanerPeriod,
-                                       int connectionTtl,
-                                       int maxConnections,
-                                       int maxConnectionsPerHost,
-                                       ChannelPool channelPool,
-                                       KeepAliveStrategy keepAliveStrategy,
-
-                                       // ssl
-                                       boolean useOpenSsl,
-                                       boolean useInsecureTrustManager,
-                                       boolean disableHttpsEndpointIdentificationAlgorithm,
-                                       int handshakeTimeout,
-                                       String[] enabledProtocols,
-                                       String[] enabledCipherSuites,
-                                       int sslSessionCacheSize,
-                                       int sslSessionTimeout,
-                                       SslContext sslContext,
-                                       SslEngineFactory sslEngineFactory,
-
-                                       // filters
-                                       List<RequestFilter> requestFilters,
-                                       List<ResponseFilter> responseFilters,
-                                       List<IOExceptionFilter> ioExceptionFilters,
-
-                                       // cookie store
-                                       CookieStore cookieStore,
-
-                                       // tuning
-                                       boolean tcpNoDelay,
-                                       boolean soReuseAddress,
-                                       int soLinger,
-                                       int soSndBuf,
-                                       int soRcvBuf,
-
-                                       // internals
-                                       String threadPoolName,
-                                       int httpClientCodecMaxInitialLineLength,
-                                       int httpClientCodecMaxHeaderSize,
-                                       int httpClientCodecMaxChunkSize,
-                                       int httpClientCodecInitialBufferSize,
-                                       int chunkedFileChunkSize,
-                                       int webSocketMaxBufferSize,
-                                       int webSocketMaxFrameSize,
-                                       Map<ChannelOption<Object>, Object> channelOptions,
-                                       EventLoopGroup eventLoopGroup,
-                                       boolean useNativeTransport,
-                                       ByteBufAllocator allocator,
-                                       Timer nettyTimer,
-                                       ThreadFactory threadFactory,
-                                       Consumer<Channel> httpAdditionalChannelInitializer,
-                                       Consumer<Channel> wsAdditionalChannelInitializer,
-                                       ResponseBodyPartFactory responseBodyPartFactory,
-                                       int ioThreadsCount) {
-
-    // http
-    this.followRedirect = followRedirect;
-    this.maxRedirects = maxRedirects;
-    this.strict302Handling = strict302Handling;
-    this.compressionEnforced = compressionEnforced;
-    this.userAgent = userAgent;
-    this.realm = realm;
-    this.maxRequestRetry = maxRequestRetry;
-    this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
-    this.useLaxCookieEncoder = useLaxCookieEncoder;
-    this.disableZeroCopy = disableZeroCopy;
-    this.keepEncodingHeader = keepEncodingHeader;
-    this.proxyServerSelector = proxyServerSelector;
-    this.validateResponseHeaders = validateResponseHeaders;
-
-    // websocket
-    this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
-    this.enablewebSocketCompression = enablewebSocketCompression;
-    this.webSocketMaxBufferSize = webSocketMaxBufferSize;
-    this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-
-    // timeouts
-    this.connectTimeout = connectTimeout;
-    this.requestTimeout = requestTimeout;
-    this.readTimeout = readTimeout;
-    this.shutdownQuietPeriod = shutdownQuietPeriod;
-    this.shutdownTimeout = shutdownTimeout;
-
-    // keep-alive
-    this.keepAlive = keepAlive;
-    this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
-    this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
-    this.connectionTtl = connectionTtl;
-    this.maxConnections = maxConnections;
-    this.maxConnectionsPerHost = maxConnectionsPerHost;
-    this.channelPool = channelPool;
-    this.keepAliveStrategy = keepAliveStrategy;
+    private static final String AHC_VERSION;
 
-    // ssl
-    this.useOpenSsl = useOpenSsl;
-    this.useInsecureTrustManager = useInsecureTrustManager;
-    this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
-    this.handshakeTimeout = handshakeTimeout;
-    this.enabledProtocols = enabledProtocols;
-    this.enabledCipherSuites = enabledCipherSuites;
-    this.sslSessionCacheSize = sslSessionCacheSize;
-    this.sslSessionTimeout = sslSessionTimeout;
-    this.sslContext = sslContext;
-    this.sslEngineFactory = sslEngineFactory;
-
-    // filters
-    this.requestFilters = requestFilters;
-    this.responseFilters = responseFilters;
-    this.ioExceptionFilters = ioExceptionFilters;
-
-    // cookie store
-    this.cookieStore = cookieStore;
-
-    // tuning
-    this.tcpNoDelay = tcpNoDelay;
-    this.soReuseAddress = soReuseAddress;
-    this.soLinger = soLinger;
-    this.soSndBuf = soSndBuf;
-    this.soRcvBuf = soRcvBuf;
-
-    // internals
-    this.threadPoolName = threadPoolName;
-    this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
-    this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
-    this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-    this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
-    this.chunkedFileChunkSize = chunkedFileChunkSize;
-    this.channelOptions = channelOptions;
-    this.eventLoopGroup = eventLoopGroup;
-    this.useNativeTransport = useNativeTransport;
-    this.allocator = allocator;
-    this.nettyTimer = nettyTimer;
-    this.threadFactory = threadFactory;
-    this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
-    this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
-    this.responseBodyPartFactory = responseBodyPartFactory;
-    this.ioThreadsCount = ioThreadsCount;
-  }
-
-  @Override
-  public String getAhcVersion() {
-    return AsyncHttpClientConfigDefaults.AHC_VERSION;
-  }
-
-  // http
-  @Override
-  public boolean isFollowRedirect() {
-    return followRedirect;
-  }
-
-  @Override
-  public int getMaxRedirects() {
-    return maxRedirects;
-  }
-
-  @Override
-  public boolean isStrict302Handling() {
-    return strict302Handling;
-  }
-
-  @Override
-  public boolean isCompressionEnforced() {
-    return compressionEnforced;
-  }
-
-  @Override
-  public String getUserAgent() {
-    return userAgent;
-  }
-
-  @Override
-  public Realm getRealm() {
-    return realm;
-  }
-
-  @Override
-  public int getMaxRequestRetry() {
-    return maxRequestRetry;
-  }
-
-  @Override
-  public boolean isDisableUrlEncodingForBoundRequests() {
-    return disableUrlEncodingForBoundRequests;
-  }
-
-  @Override
-  public boolean isUseLaxCookieEncoder() {
-    return useLaxCookieEncoder;
-  }
-
-  @Override
-  public boolean isDisableZeroCopy() {
-    return disableZeroCopy;
-  }
-
-  @Override
-  public boolean isKeepEncodingHeader() {
-    return keepEncodingHeader;
-  }
-
-  @Override
-  public ProxyServerSelector getProxyServerSelector() {
-    return proxyServerSelector;
-  }
-
-  // websocket
-  @Override
-  public boolean isAggregateWebSocketFrameFragments() {
-    return aggregateWebSocketFrameFragments;
-  }
-
-  @Override
-  public boolean isEnableWebSocketCompression() {
-    return enablewebSocketCompression;
-  }
-
-  @Override
-  public int getWebSocketMaxBufferSize() {
-    return webSocketMaxBufferSize;
-  }
-
-  @Override
-  public int getWebSocketMaxFrameSize() {
-    return webSocketMaxFrameSize;
-  }
-
-  // timeouts
-  @Override
-  public int getConnectTimeout() {
-    return connectTimeout;
-  }
-
-  @Override
-  public int getRequestTimeout() {
-    return requestTimeout;
-  }
-
-  @Override
-  public int getReadTimeout() {
-    return readTimeout;
-  }
-
-  @Override
-  public int getShutdownQuietPeriod() {
-    return shutdownQuietPeriod;
-  }
-
-  @Override
-  public int getShutdownTimeout() {
-    return shutdownTimeout;
-  }
-
-  // keep-alive
-  @Override
-  public boolean isKeepAlive() {
-    return keepAlive;
-  }
-
-  @Override
-  public int getPooledConnectionIdleTimeout() {
-    return pooledConnectionIdleTimeout;
-  }
-
-  @Override
-  public int getConnectionPoolCleanerPeriod() {
-    return connectionPoolCleanerPeriod;
-  }
-
-  @Override
-  public int getConnectionTtl() {
-    return connectionTtl;
-  }
-
-  @Override
-  public int getMaxConnections() {
-    return maxConnections;
-  }
-
-  @Override
-  public int getMaxConnectionsPerHost() {
-    return maxConnectionsPerHost;
-  }
-
-  @Override
-  public ChannelPool getChannelPool() {
-    return channelPool;
-  }
-
-  @Override
-  public KeepAliveStrategy getKeepAliveStrategy() {
-    return keepAliveStrategy;
-  }
-
-  @Override
-  public boolean isValidateResponseHeaders() {
-    return validateResponseHeaders;
-  }
-
-  // ssl
-  @Override
-  public boolean isUseOpenSsl() {
-    return useOpenSsl;
-  }
-
-  @Override
-  public boolean isUseInsecureTrustManager() {
-    return useInsecureTrustManager;
-  }
-
-  @Override
-  public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
-    return disableHttpsEndpointIdentificationAlgorithm;
-  }
-
-  @Override
-  public int getHandshakeTimeout() {
-    return handshakeTimeout;
-  }
-
-  @Override
-  public String[] getEnabledProtocols() {
-    return enabledProtocols;
-  }
-
-  @Override
-  public String[] getEnabledCipherSuites() {
-    return enabledCipherSuites;
-  }
-
-  @Override
-  public int getSslSessionCacheSize() {
-    return sslSessionCacheSize;
-  }
-
-  @Override
-  public int getSslSessionTimeout() {
-    return sslSessionTimeout;
-  }
-
-  @Override
-  public SslContext getSslContext() {
-    return sslContext;
-  }
-
-  @Override
-  public SslEngineFactory getSslEngineFactory() {
-    return sslEngineFactory;
-  }
-
-  // filters
-  @Override
-  public List<RequestFilter> getRequestFilters() {
-    return requestFilters;
-  }
-
-  @Override
-  public List<ResponseFilter> getResponseFilters() {
-    return responseFilters;
-  }
-
-  @Override
-  public List<IOExceptionFilter> getIoExceptionFilters() {
-    return ioExceptionFilters;
-  }
-
-  // cookie store
-  @Override
-  public CookieStore getCookieStore() {
-    return cookieStore;
-  }
-
-  // tuning
-  @Override
-  public boolean isTcpNoDelay() {
-    return tcpNoDelay;
-  }
-
-  @Override
-  public boolean isSoReuseAddress() {
-    return soReuseAddress;
-  }
-
-  @Override
-  public int getSoLinger() {
-    return soLinger;
-  }
-
-  @Override
-  public int getSoSndBuf() {
-    return soSndBuf;
-  }
-
-  @Override
-  public int getSoRcvBuf() {
-    return soRcvBuf;
-  }
-
-  // internals
-  @Override
-  public String getThreadPoolName() {
-    return threadPoolName;
-  }
-
-  @Override
-  public int getHttpClientCodecMaxInitialLineLength() {
-    return httpClientCodecMaxInitialLineLength;
-  }
-
-  @Override
-  public int getHttpClientCodecMaxHeaderSize() {
-    return httpClientCodecMaxHeaderSize;
-  }
-
-  @Override
-  public int getHttpClientCodecMaxChunkSize() {
-    return httpClientCodecMaxChunkSize;
-  }
-
-  @Override
-  public int getHttpClientCodecInitialBufferSize() {
-    return httpClientCodecInitialBufferSize;
-  }
-
-  @Override
-  public int getChunkedFileChunkSize() {
-    return chunkedFileChunkSize;
-  }
-
-  @Override
-  public Map<ChannelOption<Object>, Object> getChannelOptions() {
-    return channelOptions;
-  }
-
-  @Override
-  public EventLoopGroup getEventLoopGroup() {
-    return eventLoopGroup;
-  }
-
-  @Override
-  public boolean isUseNativeTransport() {
-    return useNativeTransport;
-  }
-
-  @Override
-  public ByteBufAllocator getAllocator() {
-    return allocator;
-  }
-
-  @Override
-  public Timer getNettyTimer() {
-    return nettyTimer;
-  }
-
-  @Override
-  public ThreadFactory getThreadFactory() {
-    return threadFactory;
-  }
-
-  @Override
-  public Consumer<Channel> getHttpAdditionalChannelInitializer() {
-    return httpAdditionalChannelInitializer;
-  }
-
-  @Override
-  public Consumer<Channel> getWsAdditionalChannelInitializer() {
-    return wsAdditionalChannelInitializer;
-  }
-
-  @Override
-  public ResponseBodyPartFactory getResponseBodyPartFactory() {
-    return responseBodyPartFactory;
-  }
-
-  @Override
-  public int getIoThreadsCount() {
-    return ioThreadsCount;
-  }
-
-  /**
-   * Builder for an {@link AsyncHttpClient}
-   */
-  public static class Builder {
+    static {
+        try (InputStream is = DefaultAsyncHttpClientConfig.class.getResourceAsStream("/ahc-version.properties")) {
+            Properties prop = new Properties();
+            prop.load(is);
+            AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
+        } catch (IOException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
 
-    // filters
-    private final List<RequestFilter> requestFilters = new LinkedList<>();
-    private final List<ResponseFilter> responseFilters = new LinkedList<>();
-    private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
     // http
-    private boolean followRedirect = defaultFollowRedirect();
-    private int maxRedirects = defaultMaxRedirects();
-    private boolean strict302Handling = defaultStrict302Handling();
-    private boolean compressionEnforced = defaultCompressionEnforced();
-    private String userAgent = defaultUserAgent();
-    private Realm realm;
-    private int maxRequestRetry = defaultMaxRequestRetry();
-    private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
-    private boolean useLaxCookieEncoder = defaultUseLaxCookieEncoder();
-    private boolean disableZeroCopy = defaultDisableZeroCopy();
-    private boolean keepEncodingHeader = defaultKeepEncodingHeader();
-    private ProxyServerSelector proxyServerSelector;
-    private boolean useProxySelector = defaultUseProxySelector();
-    private boolean useProxyProperties = defaultUseProxyProperties();
-    private boolean validateResponseHeaders = defaultValidateResponseHeaders();
-
-    // websocket
-    private boolean aggregateWebSocketFrameFragments = defaultAggregateWebSocketFrameFragments();
-    private boolean enablewebSocketCompression = defaultEnableWebSocketCompression();
-    private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
-    private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
+    private final boolean followRedirect;
+    private final int maxRedirects;
+    private final boolean strict302Handling;
+    private final boolean compressionEnforced;
+    private final String userAgent;
+    private final Realm realm;
+    private final int maxRequestRetry;
+    private final boolean disableUrlEncodingForBoundRequests;
+    private final boolean useLaxCookieEncoder;
+    private final boolean disableZeroCopy;
+    private final boolean keepEncodingHeader;
+    private final ProxyServerSelector proxyServerSelector;
+    private final boolean validateResponseHeaders;
+    private final boolean aggregateWebSocketFrameFragments;
 
     // timeouts
-    private int connectTimeout = defaultConnectTimeout();
-    private int requestTimeout = defaultRequestTimeout();
-    private int readTimeout = defaultReadTimeout();
-    private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
-    private int shutdownTimeout = defaultShutdownTimeout();
+    private final int connectTimeout;
+    private final int requestTimeout;
+    private final int readTimeout;
+    private final int shutdownQuietPeriod;
+    private final int shutdownTimeout;
 
     // keep-alive
-    private boolean keepAlive = defaultKeepAlive();
-    private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
-    private int connectionPoolCleanerPeriod = defaultConnectionPoolCleanerPeriod();
-    private int connectionTtl = defaultConnectionTtl();
-    private int maxConnections = defaultMaxConnections();
-    private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
-    private ChannelPool channelPool;
-    private KeepAliveStrategy keepAliveStrategy = new DefaultKeepAliveStrategy();
+    private final boolean keepAlive;
+    private final int pooledConnectionIdleTimeout;
+    private final int connectionPoolCleanerPeriod;
+    private final int connectionTtl;
+    private final int maxConnections;
+    private final int maxConnectionsPerHost;
+    private final ChannelPool channelPool;
+    private final KeepAliveStrategy keepAliveStrategy;
 
     // ssl
-    private boolean useOpenSsl = defaultUseOpenSsl();
-    private boolean useInsecureTrustManager = defaultUseInsecureTrustManager();
-    private boolean disableHttpsEndpointIdentificationAlgorithm = defaultDisableHttpsEndpointIdentificationAlgorithm();
-    private int handshakeTimeout = defaultHandshakeTimeout();
-    private String[] enabledProtocols = defaultEnabledProtocols();
-    private String[] enabledCipherSuites = defaultEnabledCipherSuites();
-    private int sslSessionCacheSize = defaultSslSessionCacheSize();
-    private int sslSessionTimeout = defaultSslSessionTimeout();
-    private SslContext sslContext;
-    private SslEngineFactory sslEngineFactory;
-
-    // cookie store
-    private CookieStore cookieStore = new ThreadSafeCookieStore();
+    private final boolean useOpenSsl;
+    private final boolean useInsecureTrustManager;
+    private final boolean disableHttpsEndpointIdentificationAlgorithm;
+    private final int handshakeTimeout;
+    private final String[] enabledProtocols;
+    private final String[] enabledCipherSuites;
+    private final int sslSessionCacheSize;
+    private final int sslSessionTimeout;
+    private final SslContext sslContext;
+    private final SslEngineFactory sslEngineFactory;
 
-    // tuning
-    private boolean tcpNoDelay = defaultTcpNoDelay();
-    private boolean soReuseAddress = defaultSoReuseAddress();
-    private int soLinger = defaultSoLinger();
-    private int soSndBuf = defaultSoSndBuf();
-    private int soRcvBuf = defaultSoRcvBuf();
+    // filters
+    private final List<RequestFilter> requestFilters;
+    private final List<ResponseFilter> responseFilters;
+    private final List<IOExceptionFilter> ioExceptionFilters;
 
     // internals
-    private String threadPoolName = defaultThreadPoolName();
-    private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
-    private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
-    private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
-    private int httpClientCodecInitialBufferSize = defaultHttpClientCodecInitialBufferSize();
-    private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
-    private boolean useNativeTransport = defaultUseNativeTransport();
-    private ByteBufAllocator allocator;
-    private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
-    private EventLoopGroup eventLoopGroup;
-    private Timer nettyTimer;
-    private ThreadFactory threadFactory;
-    private Consumer<Channel> httpAdditionalChannelInitializer;
-    private Consumer<Channel> wsAdditionalChannelInitializer;
-    private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
-    private int ioThreadsCount = defaultIoThreadsCount();
-
-    public Builder() {
-    }
-
-    public Builder(AsyncHttpClientConfig config) {
-      // http
-      followRedirect = config.isFollowRedirect();
-      maxRedirects = config.getMaxRedirects();
-      strict302Handling = config.isStrict302Handling();
-      compressionEnforced = config.isCompressionEnforced();
-      userAgent = config.getUserAgent();
-      realm = config.getRealm();
-      maxRequestRetry = config.getMaxRequestRetry();
-      disableUrlEncodingForBoundRequests = config.isDisableUrlEncodingForBoundRequests();
-      disableZeroCopy = config.isDisableZeroCopy();
-      keepEncodingHeader = config.isKeepEncodingHeader();
-      proxyServerSelector = config.getProxyServerSelector();
-
-      // websocket
-      aggregateWebSocketFrameFragments = config.isAggregateWebSocketFrameFragments();
-      enablewebSocketCompression = config.isEnableWebSocketCompression();
-      webSocketMaxBufferSize = config.getWebSocketMaxBufferSize();
-      webSocketMaxFrameSize = config.getWebSocketMaxFrameSize();
-
-      // timeouts
-      connectTimeout = config.getConnectTimeout();
-      requestTimeout = config.getRequestTimeout();
-      readTimeout = config.getReadTimeout();
-      shutdownQuietPeriod = config.getShutdownQuietPeriod();
-      shutdownTimeout = config.getShutdownTimeout();
-
-      // keep-alive
-      keepAlive = config.isKeepAlive();
-      pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
-      connectionTtl = config.getConnectionTtl();
-      maxConnections = config.getMaxConnections();
-      maxConnectionsPerHost = config.getMaxConnectionsPerHost();
-      channelPool = config.getChannelPool();
-      keepAliveStrategy = config.getKeepAliveStrategy();
-
-      // ssl
-      useInsecureTrustManager = config.isUseInsecureTrustManager();
-      handshakeTimeout = config.getHandshakeTimeout();
-      enabledProtocols = config.getEnabledProtocols();
-      enabledCipherSuites = config.getEnabledCipherSuites();
-      sslSessionCacheSize = config.getSslSessionCacheSize();
-      sslSessionTimeout = config.getSslSessionTimeout();
-      sslContext = config.getSslContext();
-      sslEngineFactory = config.getSslEngineFactory();
-
-      // filters
-      requestFilters.addAll(config.getRequestFilters());
-      responseFilters.addAll(config.getResponseFilters());
-      ioExceptionFilters.addAll(config.getIoExceptionFilters());
-
-      // tuning
-      tcpNoDelay = config.isTcpNoDelay();
-      soReuseAddress = config.isSoReuseAddress();
-      soLinger = config.getSoLinger();
-      soSndBuf = config.getSoSndBuf();
-      soRcvBuf = config.getSoRcvBuf();
-
-      // internals
-      threadPoolName = config.getThreadPoolName();
-      httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
-      httpClientCodecMaxHeaderSize = config.getHttpClientCodecMaxHeaderSize();
-      httpClientCodecMaxChunkSize = config.getHttpClientCodecMaxChunkSize();
-      chunkedFileChunkSize = config.getChunkedFileChunkSize();
-      channelOptions.putAll(config.getChannelOptions());
-      eventLoopGroup = config.getEventLoopGroup();
-      useNativeTransport = config.isUseNativeTransport();
-      allocator = config.getAllocator();
-      nettyTimer = config.getNettyTimer();
-      threadFactory = config.getThreadFactory();
-      httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
-      wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
-      responseBodyPartFactory = config.getResponseBodyPartFactory();
-      ioThreadsCount = config.getIoThreadsCount();
+    private final String threadPoolName;
+    private final int httpClientCodecMaxInitialLineLength;
+    private final int httpClientCodecMaxHeaderSize;
+    private final int httpClientCodecMaxChunkSize;
+    private final int httpClientCodecInitialBufferSize;
+    private final int chunkedFileChunkSize;
+    private final int webSocketMaxBufferSize;
+    private final int webSocketMaxFrameSize;
+    private final Map<ChannelOption<Object>, Object> channelOptions;
+    private final EventLoopGroup eventLoopGroup;
+    private final boolean useNativeTransport;
+    private final ByteBufAllocator allocator;
+    private final boolean tcpNoDelay;
+    private final boolean soReuseAddress;
+    private final int soLinger;
+    private final int soSndBuf;
+    private final int soRcvBuf;
+    private final Timer nettyTimer;
+    private final ThreadFactory threadFactory;
+    private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
+    private final AdditionalChannelInitializer wsAdditionalChannelInitializer;
+    private final ResponseBodyPartFactory responseBodyPartFactory;
+    private final int ioThreadsCount;
+
+    private DefaultAsyncHttpClientConfig(//
+            // http
+            boolean followRedirect,//
+            int maxRedirects,//
+            boolean strict302Handling,//
+            boolean compressionEnforced,//
+            String userAgent,//
+            Realm realm,//
+            int maxRequestRetry,//
+            boolean disableUrlEncodingForBoundRequests,//
+            boolean useLaxCookieEncoder,//
+            boolean disableZeroCopy,//
+            boolean keepEncodingHeader,//
+            ProxyServerSelector proxyServerSelector,//
+            boolean validateResponseHeaders,//
+            boolean aggregateWebSocketFrameFragments,
+
+            // timeouts
+            int connectTimeout,//
+            int requestTimeout,//
+            int readTimeout,//
+            int shutdownQuietPeriod,//
+            int shutdownTimeout,//
+
+            // keep-alive
+            boolean keepAlive,//
+            int pooledConnectionIdleTimeout,//
+            int connectionPoolCleanerPeriod,//
+            int connectionTtl,//
+            int maxConnections,//
+            int maxConnectionsPerHost,//
+            ChannelPool channelPool,//
+            KeepAliveStrategy keepAliveStrategy,//
+
+            // ssl
+            boolean useOpenSsl,//
+            boolean useInsecureTrustManager,//
+            boolean disableHttpsEndpointIdentificationAlgorithm,//
+            int handshakeTimeout,//
+            String[] enabledProtocols,//
+            String[] enabledCipherSuites,//
+            int sslSessionCacheSize,//
+            int sslSessionTimeout,//
+            SslContext sslContext,//
+            SslEngineFactory sslEngineFactory,//
+
+            // filters
+            List<RequestFilter> requestFilters,//
+            List<ResponseFilter> responseFilters,//
+            List<IOExceptionFilter> ioExceptionFilters,//
+
+            // tuning
+            boolean tcpNoDelay,//
+            boolean soReuseAddress,//
+            int soLinger, //
+            int soSndBuf, //
+            int soRcvBuf, //
+
+            // internals
+            String threadPoolName,//
+            int httpClientCodecMaxInitialLineLength,//
+            int httpClientCodecMaxHeaderSize,//
+            int httpClientCodecMaxChunkSize,//
+            int httpClientCodecInitialBufferSize,//
+            int chunkedFileChunkSize,//
+            int webSocketMaxBufferSize,//
+            int webSocketMaxFrameSize,//
+            Map<ChannelOption<Object>, Object> channelOptions,//
+            EventLoopGroup eventLoopGroup,//
+            boolean useNativeTransport,//
+            ByteBufAllocator allocator,//
+            Timer nettyTimer,//
+            ThreadFactory threadFactory,//
+            AdditionalChannelInitializer httpAdditionalChannelInitializer,//
+            AdditionalChannelInitializer wsAdditionalChannelInitializer,//
+            ResponseBodyPartFactory responseBodyPartFactory,//
+            int ioThreadsCount) {
+
+        // http
+        this.followRedirect = followRedirect;
+        this.maxRedirects = maxRedirects;
+        this.strict302Handling = strict302Handling;
+        this.compressionEnforced = compressionEnforced;
+        this.userAgent = userAgent;
+        this.realm = realm;
+        this.maxRequestRetry = maxRequestRetry;
+        this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+        this.useLaxCookieEncoder = useLaxCookieEncoder;
+        this.disableZeroCopy = disableZeroCopy;
+        this.keepEncodingHeader = keepEncodingHeader;
+        this.proxyServerSelector = proxyServerSelector;
+        this.validateResponseHeaders = validateResponseHeaders;
+        this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
+
+        // timeouts
+        this.connectTimeout = connectTimeout;
+        this.requestTimeout = requestTimeout;
+        this.readTimeout = readTimeout;
+        this.shutdownQuietPeriod = shutdownQuietPeriod;
+        this.shutdownTimeout = shutdownTimeout;
+
+        // keep-alive
+        this.keepAlive = keepAlive;
+        this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+        this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
+        this.connectionTtl = connectionTtl;
+        this.maxConnections = maxConnections;
+        this.maxConnectionsPerHost = maxConnectionsPerHost;
+        this.channelPool = channelPool;
+        this.keepAliveStrategy = keepAliveStrategy;
+
+        // ssl
+        this.useOpenSsl = useOpenSsl;
+        this.useInsecureTrustManager = useInsecureTrustManager;
+        this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
+        this.handshakeTimeout = handshakeTimeout;
+        this.enabledProtocols = enabledProtocols;
+        this.enabledCipherSuites = enabledCipherSuites;
+        this.sslSessionCacheSize = sslSessionCacheSize;
+        this.sslSessionTimeout = sslSessionTimeout;
+        this.sslContext = sslContext;
+        this.sslEngineFactory = sslEngineFactory;
+
+        // filters
+        this.requestFilters = requestFilters;
+        this.responseFilters = responseFilters;
+        this.ioExceptionFilters = ioExceptionFilters;
+
+        // tuning
+        this.tcpNoDelay = tcpNoDelay;
+        this.soReuseAddress = soReuseAddress;
+        this.soLinger = soLinger;
+        this.soSndBuf = soSndBuf;
+        this.soRcvBuf = soRcvBuf;
+
+        // internals
+        this.threadPoolName = threadPoolName;
+        this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+        this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+        this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+        this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
+        this.chunkedFileChunkSize = chunkedFileChunkSize;
+        this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+        this.webSocketMaxFrameSize = webSocketMaxFrameSize;
+        this.channelOptions = channelOptions;
+        this.eventLoopGroup = eventLoopGroup;
+        this.useNativeTransport = useNativeTransport;
+        this.allocator = allocator;
+        this.nettyTimer = nettyTimer;
+        this.threadFactory = threadFactory;
+        this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+        this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+        this.responseBodyPartFactory = responseBodyPartFactory;
+        this.ioThreadsCount = ioThreadsCount;
+    }
+
+    @Override
+    public String getAhcVersion() {
+        return AHC_VERSION;
     }
 
     // http
-    public Builder setFollowRedirect(boolean followRedirect) {
-      this.followRedirect = followRedirect;
-      return this;
-    }
-
-    public Builder setMaxRedirects(int maxRedirects) {
-      this.maxRedirects = maxRedirects;
-      return this;
+    @Override
+    public boolean isFollowRedirect() {
+        return followRedirect;
     }
 
-    public Builder setStrict302Handling(final boolean strict302Handling) {
-      this.strict302Handling = strict302Handling;
-      return this;
+    @Override
+    public int getMaxRedirects() {
+        return maxRedirects;
     }
 
-    public Builder setCompressionEnforced(boolean compressionEnforced) {
-      this.compressionEnforced = compressionEnforced;
-      return this;
+    @Override
+    public boolean isStrict302Handling() {
+        return strict302Handling;
     }
 
-    public Builder setUserAgent(String userAgent) {
-      this.userAgent = userAgent;
-      return this;
+    @Override
+    public boolean isCompressionEnforced() {
+        return compressionEnforced;
     }
 
-    public Builder setRealm(Realm realm) {
-      this.realm = realm;
-      return this;
+    @Override
+    public String getUserAgent() {
+        return userAgent;
     }
 
-    public Builder setRealm(Realm.Builder realmBuilder) {
-      this.realm = realmBuilder.build();
-      return this;
+    @Override
+    public Realm getRealm() {
+        return realm;
     }
 
-    public Builder setMaxRequestRetry(int maxRequestRetry) {
-      this.maxRequestRetry = maxRequestRetry;
-      return this;
+    @Override
+    public int getMaxRequestRetry() {
+        return maxRequestRetry;
     }
 
-    public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
-      this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
-      return this;
+    @Override
+    public boolean isDisableUrlEncodingForBoundRequests() {
+        return disableUrlEncodingForBoundRequests;
     }
 
-    public Builder setUseLaxCookieEncoder(boolean useLaxCookieEncoder) {
-      this.useLaxCookieEncoder = useLaxCookieEncoder;
-      return this;
+    @Override
+    public boolean isUseLaxCookieEncoder() {
+        return useLaxCookieEncoder;
     }
 
-    public Builder setDisableZeroCopy(boolean disableZeroCopy) {
-      this.disableZeroCopy = disableZeroCopy;
-      return this;
+    @Override
+    public boolean isDisableZeroCopy() {
+        return disableZeroCopy;
     }
 
-    public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
-      this.keepEncodingHeader = keepEncodingHeader;
-      return this;
+    @Override
+    public boolean isKeepEncodingHeader() {
+        return keepEncodingHeader;
     }
 
-    public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
-      this.proxyServerSelector = proxyServerSelector;
-      return this;
-    }
-
-    public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
-      this.validateResponseHeaders = validateResponseHeaders;
-      return this;
-    }
-
-    public Builder setProxyServer(ProxyServer proxyServer) {
-      this.proxyServerSelector = uri -> proxyServer;
-      return this;
-    }
-
-    public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-      return setProxyServer(proxyServerBuilder.build());
-    }
-
-    public Builder setUseProxySelector(boolean useProxySelector) {
-      this.useProxySelector = useProxySelector;
-      return this;
-    }
-
-    public Builder setUseProxyProperties(boolean useProxyProperties) {
-      this.useProxyProperties = useProxyProperties;
-      return this;
+    @Override
+    public ProxyServerSelector getProxyServerSelector() {
+        return proxyServerSelector;
     }
 
-    // websocket
-    public Builder setAggregateWebSocketFrameFragments(boolean aggregateWebSocketFrameFragments) {
-      this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
-      return this;
-    }
+    // timeouts
 
-    public Builder setEnablewebSocketCompression(boolean enablewebSocketCompression) {
-      this.enablewebSocketCompression = enablewebSocketCompression;
-      return this;
+    @Override
+    public int getConnectTimeout() {
+        return connectTimeout;
     }
 
-    public Builder setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
-      this.webSocketMaxBufferSize = webSocketMaxBufferSize;
-      return this;
+    @Override
+    public int getRequestTimeout() {
+        return requestTimeout;
     }
 
-    public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
-      this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-      return this;
+    @Override
+    public int getReadTimeout() {
+        return readTimeout;
     }
 
-    // timeouts
-    public Builder setConnectTimeout(int connectTimeout) {
-      this.connectTimeout = connectTimeout;
-      return this;
+    @Override
+    public int getShutdownQuietPeriod() {
+        return shutdownQuietPeriod;
     }
 
-    public Builder setRequestTimeout(int requestTimeout) {
-      this.requestTimeout = requestTimeout;
-      return this;
+    @Override
+    public int getShutdownTimeout() {
+        return shutdownTimeout;
     }
 
-    public Builder setReadTimeout(int readTimeout) {
-      this.readTimeout = readTimeout;
-      return this;
-    }
-
-    public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
-      this.shutdownQuietPeriod = shutdownQuietPeriod;
-      return this;
+    // keep-alive
+    @Override
+    public boolean isKeepAlive() {
+        return keepAlive;
     }
 
-    public Builder setShutdownTimeout(int shutdownTimeout) {
-      this.shutdownTimeout = shutdownTimeout;
-      return this;
+    @Override
+    public int getPooledConnectionIdleTimeout() {
+        return pooledConnectionIdleTimeout;
     }
 
-    // keep-alive
-    public Builder setKeepAlive(boolean keepAlive) {
-      this.keepAlive = keepAlive;
-      return this;
+    @Override
+    public int getConnectionPoolCleanerPeriod() {
+        return connectionPoolCleanerPeriod;
     }
 
-    public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
-      this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
-      return this;
+    @Override
+    public int getConnectionTtl() {
+        return connectionTtl;
     }
 
-    public Builder setConnectionPoolCleanerPeriod(int connectionPoolCleanerPeriod) {
-      this.connectionPoolCleanerPeriod = connectionPoolCleanerPeriod;
-      return this;
+    @Override
+    public int getMaxConnections() {
+        return maxConnections;
     }
 
-    public Builder setConnectionTtl(int connectionTtl) {
-      this.connectionTtl = connectionTtl;
-      return this;
+    @Override
+    public int getMaxConnectionsPerHost() {
+        return maxConnectionsPerHost;
     }
 
-    public Builder setMaxConnections(int maxConnections) {
-      this.maxConnections = maxConnections;
-      return this;
+    @Override
+    public ChannelPool getChannelPool() {
+        return channelPool;
     }
 
-    public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
-      this.maxConnectionsPerHost = maxConnectionsPerHost;
-      return this;
+    @Override
+    public KeepAliveStrategy getKeepAliveStrategy() {
+        return keepAliveStrategy;
     }
 
-    public Builder setChannelPool(ChannelPool channelPool) {
-      this.channelPool = channelPool;
-      return this;
+    @Override
+    public boolean isValidateResponseHeaders() {
+        return validateResponseHeaders;
     }
 
-    public Builder setKeepAliveStrategy(KeepAliveStrategy keepAliveStrategy) {
-      this.keepAliveStrategy = keepAliveStrategy;
-      return this;
+    @Override
+    public boolean isAggregateWebSocketFrameFragments() {
+        return aggregateWebSocketFrameFragments;
     }
 
     // ssl
-    public Builder setUseOpenSsl(boolean useOpenSsl) {
-      this.useOpenSsl = useOpenSsl;
-      return this;
+    @Override
+    public boolean isUseOpenSsl() {
+        return useOpenSsl;
     }
 
-    public Builder setUseInsecureTrustManager(boolean useInsecureTrustManager) {
-      this.useInsecureTrustManager = useInsecureTrustManager;
-      return this;
+    @Override
+    public boolean isUseInsecureTrustManager() {
+        return useInsecureTrustManager;
     }
 
-    public Builder setDisableHttpsEndpointIdentificationAlgorithm(boolean disableHttpsEndpointIdentificationAlgorithm) {
-      this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
-      return this;
+    @Override
+    public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
+        return disableHttpsEndpointIdentificationAlgorithm;
     }
 
-    public Builder setHandshakeTimeout(int handshakeTimeout) {
-      this.handshakeTimeout = handshakeTimeout;
-      return this;
+    @Override
+    public int getHandshakeTimeout() {
+        return handshakeTimeout;
     }
 
-    public Builder setEnabledProtocols(String[] enabledProtocols) {
-      this.enabledProtocols = enabledProtocols;
-      return this;
+    @Override
+    public String[] getEnabledProtocols() {
+        return enabledProtocols;
     }
 
-    public Builder setEnabledCipherSuites(String[] enabledCipherSuites) {
-      this.enabledCipherSuites = enabledCipherSuites;
-      return this;
+    @Override
+    public String[] getEnabledCipherSuites() {
+        return enabledCipherSuites;
     }
 
-    public Builder setSslSessionCacheSize(Integer sslSessionCacheSize) {
-      this.sslSessionCacheSize = sslSessionCacheSize;
-      return this;
+    @Override
+    public int getSslSessionCacheSize() {
+        return sslSessionCacheSize;
     }
 
-    public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
-      this.sslSessionTimeout = sslSessionTimeout;
-      return this;
+    @Override
+    public int getSslSessionTimeout() {
+        return sslSessionTimeout;
     }
 
-    public Builder setSslContext(final SslContext sslContext) {
-      this.sslContext = sslContext;
-      return this;
+    @Override
+    public SslContext getSslContext() {
+        return sslContext;
     }
 
-    public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
-      this.sslEngineFactory = sslEngineFactory;
-      return this;
+    @Override
+    public SslEngineFactory getSslEngineFactory() {
+        return sslEngineFactory;
     }
 
     // filters
-    public Builder addRequestFilter(RequestFilter requestFilter) {
-      requestFilters.add(requestFilter);
-      return this;
-    }
-
-    public Builder removeRequestFilter(RequestFilter requestFilter) {
-      requestFilters.remove(requestFilter);
-      return this;
-    }
-
-    public Builder addResponseFilter(ResponseFilter responseFilter) {
-      responseFilters.add(responseFilter);
-      return this;
+    @Override
+    public List<RequestFilter> getRequestFilters() {
+        return requestFilters;
     }
 
-    public Builder removeResponseFilter(ResponseFilter responseFilter) {
-      responseFilters.remove(responseFilter);
-      return this;
+    @Override
+    public List<ResponseFilter> getResponseFilters() {
+        return responseFilters;
     }
 
-    public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-      ioExceptionFilters.add(ioExceptionFilter);
-      return this;
-    }
-
-    public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-      ioExceptionFilters.remove(ioExceptionFilter);
-      return this;
-    }
-
-    // cookie store
-    public Builder setCookieStore(CookieStore cookieStore) {
-      this.cookieStore = cookieStore;
-      return this;
+    @Override
+    public List<IOExceptionFilter> getIoExceptionFilters() {
+        return ioExceptionFilters;
     }
 
     // tuning
-    public Builder setTcpNoDelay(boolean tcpNoDelay) {
-      this.tcpNoDelay = tcpNoDelay;
-      return this;
+    @Override
+    public boolean isTcpNoDelay() {
+        return tcpNoDelay;
     }
 
-    public Builder setSoReuseAddress(boolean soReuseAddress) {
-      this.soReuseAddress = soReuseAddress;
-      return this;
+    @Override
+    public boolean isSoReuseAddress() {
+        return soReuseAddress;
     }
 
-    public Builder setSoLinger(int soLinger) {
-      this.soLinger = soLinger;
-      return this;
+    @Override
+    public int getSoLinger() {
+        return soLinger;
     }
 
-    public Builder setSoSndBuf(int soSndBuf) {
-      this.soSndBuf = soSndBuf;
-      return this;
+    @Override
+    public int getSoSndBuf() {
+        return soSndBuf;
     }
 
-    public Builder setSoRcvBuf(int soRcvBuf) {
-      this.soRcvBuf = soRcvBuf;
-      return this;
+    @Override
+    public int getSoRcvBuf() {
+        return soRcvBuf;
     }
 
     // internals
-    public Builder setThreadPoolName(String threadPoolName) {
-      this.threadPoolName = threadPoolName;
-      return this;
+    @Override
+    public String getThreadPoolName() {
+        return threadPoolName;
     }
 
-    public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
-      this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
-      return this;
+    @Override
+    public int getHttpClientCodecMaxInitialLineLength() {
+        return httpClientCodecMaxInitialLineLength;
     }
 
-    public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
-      this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
-      return this;
+    @Override
+    public int getHttpClientCodecMaxHeaderSize() {
+        return httpClientCodecMaxHeaderSize;
     }
 
-    public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
-      this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-      return this;
+    @Override
+    public int getHttpClientCodecMaxChunkSize() {
+        return httpClientCodecMaxChunkSize;
     }
 
-    public Builder setHttpClientCodecInitialBufferSize(int httpClientCodecInitialBufferSize) {
-      this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
-      return this;
+    @Override
+    public int getHttpClientCodecInitialBufferSize() {
+        return httpClientCodecInitialBufferSize;
     }
 
-    public Builder setChunkedFileChunkSize(int chunkedFileChunkSize) {
-      this.chunkedFileChunkSize = chunkedFileChunkSize;
-      return this;
+    @Override
+    public int getChunkedFileChunkSize() {
+        return chunkedFileChunkSize;
     }
 
-    @SuppressWarnings("unchecked")
-    public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
-      channelOptions.put((ChannelOption<Object>) name, value);
-      return this;
+    @Override
+    public int getWebSocketMaxBufferSize() {
+        return webSocketMaxBufferSize;
     }
 
-    public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
-      this.eventLoopGroup = eventLoopGroup;
-      return this;
+    @Override
+    public int getWebSocketMaxFrameSize() {
+        return webSocketMaxFrameSize;
     }
 
-    public Builder setUseNativeTransport(boolean useNativeTransport) {
-      this.useNativeTransport = useNativeTransport;
-      return this;
+    @Override
+    public Map<ChannelOption<Object>, Object> getChannelOptions() {
+        return channelOptions;
     }
 
-    public Builder setAllocator(ByteBufAllocator allocator) {
-      this.allocator = allocator;
-      return this;
+    @Override
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
     }
 
-    public Builder setNettyTimer(Timer nettyTimer) {
-      this.nettyTimer = nettyTimer;
-      return this;
+    @Override
+    public boolean isUseNativeTransport() {
+        return useNativeTransport;
     }
 
-    public Builder setThreadFactory(ThreadFactory threadFactory) {
-      this.threadFactory = threadFactory;
-      return this;
+    @Override
+    public ByteBufAllocator getAllocator() {
+        return allocator;
     }
 
-    public Builder setHttpAdditionalChannelInitializer(Consumer<Channel> httpAdditionalChannelInitializer) {
-      this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
-      return this;
+    @Override
+    public Timer getNettyTimer() {
+        return nettyTimer;
     }
 
-    public Builder setWsAdditionalChannelInitializer(Consumer<Channel> wsAdditionalChannelInitializer) {
-      this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
-      return this;
+    @Override
+    public ThreadFactory getThreadFactory() {
+        return threadFactory;
     }
 
-    public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
-      this.responseBodyPartFactory = responseBodyPartFactory;
-      return this;
+    @Override
+    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
+        return httpAdditionalChannelInitializer;
     }
 
-    public Builder setIoThreadsCount(int ioThreadsCount) {
-      this.ioThreadsCount = ioThreadsCount;
-      return this;
+    @Override
+    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
+        return wsAdditionalChannelInitializer;
     }
 
-    private ProxyServerSelector resolveProxyServerSelector() {
-      if (proxyServerSelector != null)
-        return proxyServerSelector;
-
-      if (useProxySelector)
-        return ProxyUtils.getJdkDefaultProxyServerSelector();
-
-      if (useProxyProperties)
-        return ProxyUtils.createProxyServerSelector(System.getProperties());
-
-      return ProxyServerSelector.NO_PROXY_SELECTOR;
-    }
-
-    public DefaultAsyncHttpClientConfig build() {
-
-      return new DefaultAsyncHttpClientConfig(
-              followRedirect,
-              maxRedirects,
-              strict302Handling,
-              compressionEnforced,
-              userAgent,
-              realm,
-              maxRequestRetry,
-              disableUrlEncodingForBoundRequests,
-              useLaxCookieEncoder,
-              disableZeroCopy,
-              keepEncodingHeader,
-              resolveProxyServerSelector(),
-              validateResponseHeaders,
-              aggregateWebSocketFrameFragments,
-              enablewebSocketCompression,
-              connectTimeout,
-              requestTimeout,
-              readTimeout,
-              shutdownQuietPeriod,
-              shutdownTimeout,
-              keepAlive,
-              pooledConnectionIdleTimeout,
-              connectionPoolCleanerPeriod,
-              connectionTtl,
-              maxConnections,
-              maxConnectionsPerHost,
-              channelPool,
-              keepAliveStrategy,
-              useOpenSsl,
-              useInsecureTrustManager,
-              disableHttpsEndpointIdentificationAlgorithm,
-              handshakeTimeout,
-              enabledProtocols,
-              enabledCipherSuites,
-              sslSessionCacheSize,
-              sslSessionTimeout,
-              sslContext,
-              sslEngineFactory,
-              requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters),
-              responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),
-              ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),
-              cookieStore,
-              tcpNoDelay,
-              soReuseAddress,
-              soLinger,
-              soSndBuf,
-              soRcvBuf,
-              threadPoolName,
-              httpClientCodecMaxInitialLineLength,
-              httpClientCodecMaxHeaderSize,
-              httpClientCodecMaxChunkSize,
-              httpClientCodecInitialBufferSize,
-              chunkedFileChunkSize,
-              webSocketMaxBufferSize,
-              webSocketMaxFrameSize,
-              channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),
-              eventLoopGroup,
-              useNativeTransport,
-              allocator,
-              nettyTimer,
-              threadFactory,
-              httpAdditionalChannelInitializer,
-              wsAdditionalChannelInitializer,
-              responseBodyPartFactory,
-              ioThreadsCount);
-    }
-  }
+    @Override
+    public ResponseBodyPartFactory getResponseBodyPartFactory() {
+        return responseBodyPartFactory;
+    }
+
+    @Override
+    public int getIoThreadsCount() {
+        return ioThreadsCount;
+    }
+
+    /**
+     * Builder for an {@link AsyncHttpClient}
+     */
+    public static class Builder {
+
+        // http
+        private boolean followRedirect = defaultFollowRedirect();
+        private int maxRedirects = defaultMaxRedirects();
+        private boolean strict302Handling = defaultStrict302Handling();
+        private boolean compressionEnforced = defaultCompressionEnforced();
+        private String userAgent = defaultUserAgent();
+        private Realm realm;
+        private int maxRequestRetry = defaultMaxRequestRetry();
+        private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
+        private boolean useLaxCookieEncoder = defaultUseLaxCookieEncoder();
+        private boolean disableZeroCopy = defaultDisableZeroCopy();
+        private boolean keepEncodingHeader = defaultKeepEncodingHeader();
+        private ProxyServerSelector proxyServerSelector;
+        private boolean useProxySelector = defaultUseProxySelector();
+        private boolean useProxyProperties = defaultUseProxyProperties();
+        private boolean validateResponseHeaders = defaultValidateResponseHeaders();
+        private boolean aggregateWebSocketFrameFragments = defaultAggregateWebSocketFrameFragments();
+
+        // timeouts
+        private int connectTimeout = defaultConnectTimeout();
+        private int requestTimeout = defaultRequestTimeout();
+        private int readTimeout = defaultReadTimeout();
+        private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
+        private int shutdownTimeout = defaultShutdownTimeout();
+
+        // keep-alive
+        private boolean keepAlive = defaultKeepAlive();
+        private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+        private int connectionPoolCleanerPeriod = defaultConnectionPoolCleanerPeriod();
+        private int connectionTtl = defaultConnectionTtl();
+        private int maxConnections = defaultMaxConnections();
+        private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
+        private ChannelPool channelPool;
+        private KeepAliveStrategy keepAliveStrategy = new DefaultKeepAliveStrategy();
+
+        // ssl
+        private boolean useOpenSsl = defaultUseOpenSsl();
+        private boolean useInsecureTrustManager = defaultUseInsecureTrustManager();
+        private boolean disableHttpsEndpointIdentificationAlgorithm = defaultDisableHttpsEndpointIdentificationAlgorithm();
+        private int handshakeTimeout = defaultHandshakeTimeout();
+        private String[] enabledProtocols = defaultEnabledProtocols();
+        private String[] enabledCipherSuites = defaultEnabledCipherSuites();
+        private int sslSessionCacheSize = defaultSslSessionCacheSize();
+        private int sslSessionTimeout = defaultSslSessionTimeout();
+        private SslContext sslContext;
+        private SslEngineFactory sslEngineFactory;
+
+        // filters
+        private final List<RequestFilter> requestFilters = new LinkedList<>();
+        private final List<ResponseFilter> responseFilters = new LinkedList<>();
+        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
+
+        // tuning
+        private boolean tcpNoDelay = defaultTcpNoDelay();
+        private boolean soReuseAddress = defaultSoReuseAddress();
+        private int soLinger = defaultSoLinger();
+        private int soSndBuf = defaultSoSndBuf();
+        private int soRcvBuf = defaultSoRcvBuf();
+
+        // internals
+        private String threadPoolName = defaultThreadPoolName();
+        private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
+        private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
+        private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
+        private int httpClientCodecInitialBufferSize = defaultHttpClientCodecInitialBufferSize();
+        private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
+        private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
+        private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
+        private boolean useNativeTransport = defaultUseNativeTransport();
+        private ByteBufAllocator allocator;
+        private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
+        private EventLoopGroup eventLoopGroup;
+        private Timer nettyTimer;
+        private ThreadFactory threadFactory;
+        private AdditionalChannelInitializer httpAdditionalChannelInitializer;
+        private AdditionalChannelInitializer wsAdditionalChannelInitializer;
+        private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
+        private int ioThreadsCount = defaultIoThreadsCount();
+
+        public Builder() {
+        }
+
+        public Builder(AsyncHttpClientConfig config) {
+            // http
+            followRedirect = config.isFollowRedirect();
+            maxRedirects = config.getMaxRedirects();
+            strict302Handling = config.isStrict302Handling();
+            compressionEnforced = config.isCompressionEnforced();
+            userAgent = config.getUserAgent();
+            realm = config.getRealm();
+            maxRequestRetry = config.getMaxRequestRetry();
+            disableUrlEncodingForBoundRequests = config.isDisableUrlEncodingForBoundRequests();
+            disableZeroCopy = config.isDisableZeroCopy();
+            keepEncodingHeader = config.isKeepEncodingHeader();
+            proxyServerSelector = config.getProxyServerSelector();
+
+            // timeouts
+            connectTimeout = config.getConnectTimeout();
+            requestTimeout = config.getRequestTimeout();
+            readTimeout = config.getReadTimeout();
+            shutdownQuietPeriod = config.getShutdownQuietPeriod();
+            shutdownTimeout = config.getShutdownTimeout();
+
+            // keep-alive
+            keepAlive = config.isKeepAlive();
+            pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
+            connectionTtl = config.getConnectionTtl();
+            maxConnections = config.getMaxConnections();
+            maxConnectionsPerHost = config.getMaxConnectionsPerHost();
+            channelPool = config.getChannelPool();
+            keepAliveStrategy = config.getKeepAliveStrategy();
+
+            // ssl
+            useInsecureTrustManager = config.isUseInsecureTrustManager();
+            handshakeTimeout = config.getHandshakeTimeout();
+            enabledProtocols = config.getEnabledProtocols();
+            enabledCipherSuites = config.getEnabledCipherSuites();
+            sslSessionCacheSize = config.getSslSessionCacheSize();
+            sslSessionTimeout = config.getSslSessionTimeout();
+            sslContext = config.getSslContext();
+            sslEngineFactory = config.getSslEngineFactory();
+
+            // filters
+            requestFilters.addAll(config.getRequestFilters());
+            responseFilters.addAll(config.getResponseFilters());
+            ioExceptionFilters.addAll(config.getIoExceptionFilters());
+
+            // tuning
+            tcpNoDelay = config.isTcpNoDelay();
+            soReuseAddress = config.isSoReuseAddress();
+            soLinger = config.getSoLinger();
+            soSndBuf = config.getSoSndBuf();
+            soRcvBuf = config.getSoRcvBuf();
+
+            // internals
+            threadPoolName = config.getThreadPoolName();
+            httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
+            httpClientCodecMaxHeaderSize = config.getHttpClientCodecMaxHeaderSize();
+            httpClientCodecMaxChunkSize = config.getHttpClientCodecMaxChunkSize();
+            chunkedFileChunkSize = config.getChunkedFileChunkSize();
+            webSocketMaxBufferSize = config.getWebSocketMaxBufferSize();
+            webSocketMaxFrameSize = config.getWebSocketMaxFrameSize();
+            channelOptions.putAll(config.getChannelOptions());
+            eventLoopGroup = config.getEventLoopGroup();
+            useNativeTransport = config.isUseNativeTransport();
+            allocator = config.getAllocator();
+            nettyTimer = config.getNettyTimer();
+            threadFactory = config.getThreadFactory();
+            httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
+            wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
+            responseBodyPartFactory = config.getResponseBodyPartFactory();
+            ioThreadsCount = config.getIoThreadsCount();
+        }
+
+        // http
+        public Builder setFollowRedirect(boolean followRedirect) {
+            this.followRedirect = followRedirect;
+            return this;
+        }
+
+        public Builder setMaxRedirects(int maxRedirects) {
+            this.maxRedirects = maxRedirects;
+            return this;
+        }
+
+        public Builder setStrict302Handling(final boolean strict302Handling) {
+            this.strict302Handling = strict302Handling;
+            return this;
+        }
+
+        public Builder setCompressionEnforced(boolean compressionEnforced) {
+            this.compressionEnforced = compressionEnforced;
+            return this;
+        }
+
+        public Builder setUserAgent(String userAgent) {
+            this.userAgent = userAgent;
+            return this;
+        }
+
+        public Builder setRealm(Realm realm) {
+            this.realm = realm;
+            return this;
+        }
+
+        public Builder setRealm(Realm.Builder realmBuilder) {
+            this.realm = realmBuilder.build();
+            return this;
+        }
+
+        public Builder setMaxRequestRetry(int maxRequestRetry) {
+            this.maxRequestRetry = maxRequestRetry;
+            return this;
+        }
+
+        public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
+            this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+            return this;
+        }
+
+        public Builder setUseLaxCookieEncoder(boolean useLaxCookieEncoder) {
+            this.useLaxCookieEncoder = useLaxCookieEncoder;
+            return this;
+        }
+
+        public Builder setDisableZeroCopy(boolean disableZeroCopy) {
+            this.disableZeroCopy = disableZeroCopy;
+            return this;
+        }
+
+        public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
+            this.keepEncodingHeader = keepEncodingHeader;
+            return this;
+        }
+
+        public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
+            this.proxyServerSelector = proxyServerSelector;
+            return this;
+        }
+
+        public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
+            this.validateResponseHeaders = validateResponseHeaders;
+            return this;
+        }
+
+        public Builder setAggregateWebSocketFrameFragments(boolean aggregateWebSocketFrameFragments) {
+            this.aggregateWebSocketFrameFragments = aggregateWebSocketFrameFragments;
+            return this;
+        }
+
+        public Builder setProxyServer(ProxyServer proxyServer) {
+            this.proxyServerSelector = uri -> proxyServer;
+            return this;
+        }
+
+        public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+            return setProxyServer(proxyServerBuilder.build());
+        }
+
+        public Builder setUseProxySelector(boolean useProxySelector) {
+            this.useProxySelector = useProxySelector;
+            return this;
+        }
+
+        public Builder setUseProxyProperties(boolean useProxyProperties) {
+            this.useProxyProperties = useProxyProperties;
+            return this;
+        }
+
+        // timeouts
+        public Builder setConnectTimeout(int connectTimeout) {
+            this.connectTimeout = connectTimeout;
+            return this;
+        }
+
+        public Builder setRequestTimeout(int requestTimeout) {
+            this.requestTimeout = requestTimeout;
+            return this;
+        }
+
+        public Builder setReadTimeout(int readTimeout) {
+            this.readTimeout = readTimeout;
+            return this;
+        }
+
+        public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
+            this.shutdownQuietPeriod = shutdownQuietPeriod;
+            return this;
+        }
+
+        public Builder setShutdownTimeout(int shutdownTimeout) {
+            this.shutdownTimeout = shutdownTimeout;
+            return this;
+        }
+
+        // keep-alive
+        public Builder setKeepAlive(boolean keepAlive) {
+            this.keepAlive = keepAlive;
+            return this;
+        }
+
+        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+            this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+            return this;
+        }
+
+        public Builder setConnectionTtl(int connectionTtl) {
+            this.connectionTtl = connectionTtl;
+            return this;
+        }
+
+        public Builder setMaxConnections(int maxConnections) {
+            this.maxConnections = maxConnections;
+            return this;
+        }
+
+        public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
+            this.maxConnectionsPerHost = maxConnectionsPerHost;
+            return this;
+        }
+
+        public Builder setChannelPool(ChannelPool channelPool) {
+            this.channelPool = channelPool;
+            return this;
+        }
+
+        public Builder setKeepAliveStrategy(KeepAliveStrategy keepAliveStrategy) {
+            this.keepAliveStrategy = keepAliveStrategy;
+            return this;
+        }
+
+        // ssl
+        public Builder setUseOpenSsl(boolean useOpenSsl) {
+            this.useOpenSsl = useOpenSsl;
+            return this;
+        }
+
+        public Builder setUseInsecureTrustManager(boolean useInsecureTrustManager) {
+            this.useInsecureTrustManager = useInsecureTrustManager;
+            return this;
+        }
+
+        public Builder setDisableHttpsEndpointIdentificationAlgorithm(boolean disableHttpsEndpointIdentificationAlgorithm) {
+            this.disableHttpsEndpointIdentificationAlgorithm = disableHttpsEndpointIdentificationAlgorithm;
+            return this;
+        }
+
+        public Builder setHandshakeTimeout(int handshakeTimeout) {
+            this.handshakeTimeout = handshakeTimeout;
+            return this;
+        }
+
+        public Builder setEnabledProtocols(String[] enabledProtocols) {
+            this.enabledProtocols = enabledProtocols;
+            return this;
+        }
+
+        public Builder setEnabledCipherSuites(String[] enabledCipherSuites) {
+            this.enabledCipherSuites = enabledCipherSuites;
+            return this;
+        }
+
+        public Builder setSslSessionCacheSize(Integer sslSessionCacheSize) {
+            this.sslSessionCacheSize = sslSessionCacheSize;
+            return this;
+        }
+
+        public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
+            this.sslSessionTimeout = sslSessionTimeout;
+            return this;
+        }
+
+        public Builder setSslContext(final SslContext sslContext) {
+            this.sslContext = sslContext;
+            return this;
+        }
+
+        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+            this.sslEngineFactory = sslEngineFactory;
+            return this;
+        }
+
+        // filters
+        public Builder addRequestFilter(RequestFilter requestFilter) {
+            requestFilters.add(requestFilter);
+            return this;
+        }
+
+        public Builder removeRequestFilter(RequestFilter requestFilter) {
+            requestFilters.remove(requestFilter);
+            return this;
+        }
+
+        public Builder addResponseFilter(ResponseFilter responseFilter) {
+            responseFilters.add(responseFilter);
+            return this;
+        }
+
+        public Builder removeResponseFilter(ResponseFilter responseFilter) {
+            responseFilters.remove(responseFilter);
+            return this;
+        }
+
+        public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+            ioExceptionFilters.add(ioExceptionFilter);
+            return this;
+        }
+
+        public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+            ioExceptionFilters.remove(ioExceptionFilter);
+            return this;
+        }
+
+        // tuning
+        public Builder setTcpNoDelay(boolean tcpNoDelay) {
+            this.tcpNoDelay = tcpNoDelay;
+            return this;
+        }
+
+        public Builder setSoReuseAddress(boolean soReuseAddress) {
+            this.soReuseAddress = soReuseAddress;
+            return this;
+        }
+
+        public Builder setSoLinger(int soLinger) {
+            this.soLinger = soLinger;
+            return this;
+        }
+
+        public Builder setSoSndBuf(int soSndBuf) {
+            this.soSndBuf = soSndBuf;
+            return this;
+        }
+
+        public Builder setSoRcvBuf(int soRcvBuf) {
+            this.soRcvBuf = soRcvBuf;
+            return this;
+        }
+
+        // internals
+        public Builder setThreadPoolName(String threadPoolName) {
+            this.threadPoolName = threadPoolName;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
+            this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
+            this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
+            this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+            return this;
+        }
+
+        public Builder setHttpClientCodecInitialBufferSize(int httpClientCodecInitialBufferSize) {
+            this.httpClientCodecInitialBufferSize = httpClientCodecInitialBufferSize;
+            return this;
+        }
+
+        public Builder setChunkedFileChunkSize(int chunkedFileChunkSize) {
+            this.chunkedFileChunkSize = chunkedFileChunkSize;
+            return this;
+        }
+
+        public Builder setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
+            this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+            return this;
+        }
+
+        public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
+            this.webSocketMaxFrameSize = webSocketMaxFrameSize;
+            return this;
+        }
+
+        @SuppressWarnings("unchecked")
+        public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
+            channelOptions.put((ChannelOption<Object>) name, value);
+            return this;
+        }
+
+        public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+            this.eventLoopGroup = eventLoopGroup;
+            return this;
+        }
+
+        public Builder setUseNativeTransport(boolean useNativeTransport) {
+            this.useNativeTransport = useNativeTransport;
+            return this;
+        }
+
+        public Builder setAllocator(ByteBufAllocator allocator) {
+            this.allocator = allocator;
+            return this;
+        }
+
+        public Builder setNettyTimer(Timer nettyTimer) {
+            this.nettyTimer = nettyTimer;
+            return this;
+        }
+
+        public Builder setThreadFactory(ThreadFactory threadFactory) {
+            this.threadFactory = threadFactory;
+            return this;
+        }
+
+        public Builder setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
+            this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+            return this;
+        }
+
+        public Builder setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
+            this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+            return this;
+        }
+
+        public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
+            this.responseBodyPartFactory = responseBodyPartFactory;
+            return this;
+        }
+
+        public Builder setIoThreadsCount(int ioThreadsCount) {
+            this.ioThreadsCount = ioThreadsCount;
+            return this;
+        }
+
+        private ProxyServerSelector resolveProxyServerSelector() {
+            if (proxyServerSelector != null)
+                return proxyServerSelector;
+
+            if (useProxySelector)
+                return ProxyUtils.getJdkDefaultProxyServerSelector();
+
+            if (useProxyProperties)
+                return ProxyUtils.createProxyServerSelector(System.getProperties());
+
+            return ProxyServerSelector.NO_PROXY_SELECTOR;
+        }
+
+        public DefaultAsyncHttpClientConfig build() {
+
+            return new DefaultAsyncHttpClientConfig(//
+                    followRedirect, //
+                    maxRedirects, //
+                    strict302Handling, //
+                    compressionEnforced, //
+                    userAgent, //
+                    realm, //
+                    maxRequestRetry, //
+                    disableUrlEncodingForBoundRequests, //
+                    useLaxCookieEncoder, //
+                    disableZeroCopy, //
+                    keepEncodingHeader, //
+                    resolveProxyServerSelector(), //
+                    validateResponseHeaders, //
+                    aggregateWebSocketFrameFragments, //
+                    connectTimeout, //
+                    requestTimeout, //
+                    readTimeout, //
+                    shutdownQuietPeriod, //
+                    shutdownTimeout, //
+                    keepAlive, //
+                    pooledConnectionIdleTimeout, //
+                    connectionPoolCleanerPeriod, //
+                    connectionTtl, //
+                    maxConnections, //
+                    maxConnectionsPerHost, //
+                    channelPool, //
+                    keepAliveStrategy, //
+                    useOpenSsl, //
+                    useInsecureTrustManager, //
+                    disableHttpsEndpointIdentificationAlgorithm, //
+                    handshakeTimeout, //
+                    enabledProtocols, //
+                    enabledCipherSuites, //
+                    sslSessionCacheSize, //
+                    sslSessionTimeout, //
+                    sslContext, //
+                    sslEngineFactory, //
+                    requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters), //
+                    responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),//
+                    ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),//
+                    tcpNoDelay, //
+                    soReuseAddress, //
+                    soLinger, //
+                    soSndBuf, //
+                    soRcvBuf, //
+                    threadPoolName, //
+                    httpClientCodecMaxInitialLineLength, //
+                    httpClientCodecMaxHeaderSize, //
+                    httpClientCodecMaxChunkSize, //
+                    httpClientCodecInitialBufferSize, //
+                    chunkedFileChunkSize, //
+                    webSocketMaxBufferSize, //
+                    webSocketMaxFrameSize, //
+                    channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
+                    eventLoopGroup, //
+                    useNativeTransport, //
+                    allocator, //
+                    nettyTimer, //
+                    threadFactory, //
+                    httpAdditionalChannelInitializer, //
+                    wsAdditionalChannelInitializer, //
+                    responseBodyPartFactory, //
+                    ioThreadsCount);
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultRequest.java b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
index 4cabb4179..bbc854090 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultRequest.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
@@ -13,14 +13,10 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.resolver.NameResolver;
-import org.asynchttpclient.channel.ChannelPoolPartitioning;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
 
 import java.io.File;
 import java.io.InputStream;
@@ -32,263 +28,267 @@
 import java.util.List;
 import java.util.Map;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 
 public class DefaultRequest implements Request {
 
-  public final ProxyServer proxyServer;
-  private final String method;
-  private final Uri uri;
-  private final InetAddress address;
-  private final InetAddress localAddress;
-  private final HttpHeaders headers;
-  private final List<Cookie> cookies;
-  private final byte[] byteData;
-  private final List<byte[]> compositeByteData;
-  private final String stringData;
-  private final ByteBuffer byteBufferData;
-  private final InputStream streamData;
-  private final BodyGenerator bodyGenerator;
-  private final List<Param> formParams;
-  private final List<Part> bodyParts;
-  private final String virtualHost;
-  private final Realm realm;
-  private final File file;
-  private final Boolean followRedirect;
-  private final int requestTimeout;
-  private final int readTimeout;
-  private final long rangeOffset;
-  private final Charset charset;
-  private final ChannelPoolPartitioning channelPoolPartitioning;
-  private final NameResolver<InetAddress> nameResolver;
-  // lazily loaded
-  private List<Param> queryParams;
-
-  public DefaultRequest(String method,
-                        Uri uri,
-                        InetAddress address,
-                        InetAddress localAddress,
-                        HttpHeaders headers,
-                        List<Cookie> cookies,
-                        byte[] byteData,
-                        List<byte[]> compositeByteData,
-                        String stringData,
-                        ByteBuffer byteBufferData,
-                        InputStream streamData,
-                        BodyGenerator bodyGenerator,
-                        List<Param> formParams,
-                        List<Part> bodyParts,
-                        String virtualHost,
-                        ProxyServer proxyServer,
-                        Realm realm,
-                        File file,
-                        Boolean followRedirect,
-                        int requestTimeout,
-                        int readTimeout,
-                        long rangeOffset,
-                        Charset charset,
-                        ChannelPoolPartitioning channelPoolPartitioning,
-                        NameResolver<InetAddress> nameResolver) {
-    this.method = method;
-    this.uri = uri;
-    this.address = address;
-    this.localAddress = localAddress;
-    this.headers = headers;
-    this.cookies = cookies;
-    this.byteData = byteData;
-    this.compositeByteData = compositeByteData;
-    this.stringData = stringData;
-    this.byteBufferData = byteBufferData;
-    this.streamData = streamData;
-    this.bodyGenerator = bodyGenerator;
-    this.formParams = formParams;
-    this.bodyParts = bodyParts;
-    this.virtualHost = virtualHost;
-    this.proxyServer = proxyServer;
-    this.realm = realm;
-    this.file = file;
-    this.followRedirect = followRedirect;
-    this.requestTimeout = requestTimeout;
-    this.readTimeout = readTimeout;
-    this.rangeOffset = rangeOffset;
-    this.charset = charset;
-    this.channelPoolPartitioning = channelPoolPartitioning;
-    this.nameResolver = nameResolver;
-  }
-
-  @Override
-  public String getUrl() {
-    return uri.toUrl();
-  }
-
-  @Override
-  public String getMethod() {
-    return method;
-  }
-
-  @Override
-  public Uri getUri() {
-    return uri;
-  }
-
-  @Override
-  public InetAddress getAddress() {
-    return address;
-  }
-
-  @Override
-  public InetAddress getLocalAddress() {
-    return localAddress;
-  }
-
-  @Override
-  public HttpHeaders getHeaders() {
-    return headers;
-  }
-
-  @Override
-  public List<Cookie> getCookies() {
-    return cookies;
-  }
-
-  @Override
-  public byte[] getByteData() {
-    return byteData;
-  }
-
-  @Override
-  public List<byte[]> getCompositeByteData() {
-    return compositeByteData;
-  }
-
-  @Override
-  public String getStringData() {
-    return stringData;
-  }
-
-  @Override
-  public ByteBuffer getByteBufferData() {
-    return byteBufferData;
-  }
-
-  @Override
-  public InputStream getStreamData() {
-    return streamData;
-  }
-
-  @Override
-  public BodyGenerator getBodyGenerator() {
-    return bodyGenerator;
-  }
-
-  @Override
-  public List<Param> getFormParams() {
-    return formParams;
-  }
-
-  @Override
-  public List<Part> getBodyParts() {
-    return bodyParts;
-  }
-
-  @Override
-  public String getVirtualHost() {
-    return virtualHost;
-  }
-
-  @Override
-  public ProxyServer getProxyServer() {
-    return proxyServer;
-  }
-
-  @Override
-  public Realm getRealm() {
-    return realm;
-  }
-
-  @Override
-  public File getFile() {
-    return file;
-  }
-
-  @Override
-  public Boolean getFollowRedirect() {
-    return followRedirect;
-  }
-
-  @Override
-  public int getRequestTimeout() {
-    return requestTimeout;
-  }
-
-  @Override
-  public int getReadTimeout() {
-    return readTimeout;
-  }
-
-  @Override
-  public long getRangeOffset() {
-    return rangeOffset;
-  }
-
-  @Override
-  public Charset getCharset() {
-    return charset;
-  }
-
-  @Override
-  public ChannelPoolPartitioning getChannelPoolPartitioning() {
-    return channelPoolPartitioning;
-  }
-
-  @Override
-  public NameResolver<InetAddress> getNameResolver() {
-    return nameResolver;
-  }
-
-  @Override
-  public List<Param> getQueryParams() {
-    if (queryParams == null)
-      // lazy load
-      if (isNonEmpty(uri.getQuery())) {
-        queryParams = new ArrayList<>(1);
-        for (String queryStringParam : uri.getQuery().split("&")) {
-          int pos = queryStringParam.indexOf('=');
-          if (pos <= 0)
-            queryParams.add(new Param(queryStringParam, null));
-          else
-            queryParams.add(new Param(queryStringParam.substring(0, pos), queryStringParam.substring(pos + 1)));
-        }
-      } else
-        queryParams = Collections.emptyList();
-    return queryParams;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder(getUrl());
-
-    sb.append("\t");
-    sb.append(method);
-    sb.append("\theaders:");
-    if (!headers.isEmpty()) {
-      for (Map.Entry<String, String> header : headers) {
-        sb.append("\t");
-        sb.append(header.getKey());
-        sb.append(":");
-        sb.append(header.getValue());
-      }
+    private final String method;
+    private final Uri uri;
+    private final InetAddress address;
+    private final InetAddress localAddress;
+    private final HttpHeaders headers;
+    private final List<Cookie> cookies;
+    private final byte[] byteData;
+    private final List<byte[]> compositeByteData;
+    private final String stringData;
+    private final ByteBuffer byteBufferData;
+    private final InputStream streamData;
+    private final BodyGenerator bodyGenerator;
+    private final List<Param> formParams;
+    private final List<Part> bodyParts;
+    private final String virtualHost;
+    public final ProxyServer proxyServer;
+    private final Realm realm;
+    private final File file;
+    private final Boolean followRedirect;
+    private final int requestTimeout;
+    private final int readTimeout;
+    private final long rangeOffset;
+    private final Charset charset;
+    private final ChannelPoolPartitioning channelPoolPartitioning;
+    private final NameResolver<InetAddress> nameResolver;
+    // lazily loaded
+    private List<Param> queryParams;
+
+    public DefaultRequest(String method,//
+            Uri uri,//
+            InetAddress address,//
+            InetAddress localAddress,//
+            HttpHeaders headers,//
+            List<Cookie> cookies,//
+            byte[] byteData,//
+            List<byte[]> compositeByteData,//
+            String stringData,//
+            ByteBuffer byteBufferData,//
+            InputStream streamData,//
+            BodyGenerator bodyGenerator,//
+            List<Param> formParams,//
+            List<Part> bodyParts,//
+            String virtualHost,//
+            ProxyServer proxyServer,//
+            Realm realm,//
+            File file,//
+            Boolean followRedirect,//
+            int requestTimeout,//
+            int readTimeout,//
+            long rangeOffset,//
+            Charset charset,//
+            ChannelPoolPartitioning channelPoolPartitioning,//
+            NameResolver<InetAddress> nameResolver) {
+        this.method = method;
+        this.uri = uri;
+        this.address = address;
+        this.localAddress = localAddress;
+        this.headers = headers;
+        this.cookies = cookies;
+        this.byteData = byteData;
+        this.compositeByteData = compositeByteData;
+        this.stringData = stringData;
+        this.byteBufferData = byteBufferData;
+        this.streamData = streamData;
+        this.bodyGenerator = bodyGenerator;
+        this.formParams = formParams;
+        this.bodyParts = bodyParts;
+        this.virtualHost = virtualHost;
+        this.proxyServer = proxyServer;
+        this.realm = realm;
+        this.file = file;
+        this.followRedirect = followRedirect;
+        this.requestTimeout = requestTimeout;
+        this.readTimeout = readTimeout;
+        this.rangeOffset = rangeOffset;
+        this.charset = charset;
+        this.channelPoolPartitioning = channelPoolPartitioning;
+        this.nameResolver = nameResolver;
     }
-    if (isNonEmpty(formParams)) {
-      sb.append("\tformParams:");
-      for (Param param : formParams) {
-        sb.append("\t");
-        sb.append(param.getName());
-        sb.append(":");
-        sb.append(param.getValue());
-      }
+
+    @Override
+    public String getUrl() {
+        return uri.toUrl();
+    }
+    
+    @Override
+    public String getMethod() {
+        return method;
+    }
+
+    @Override
+    public Uri getUri() {
+        return uri;
+    }
+
+    @Override
+    public InetAddress getAddress() {
+        return address;
+    }
+
+    @Override
+    public InetAddress getLocalAddress() {
+        return localAddress;
+    }
+
+    @Override
+    public HttpHeaders getHeaders() {
+        return headers;
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+        return cookies;
+    }
+
+    @Override
+    public byte[] getByteData() {
+        return byteData;
+    }
+
+    @Override
+    public List<byte[]> getCompositeByteData() {
+        return compositeByteData;
+    }
+
+    @Override
+    public String getStringData() {
+        return stringData;
+    }
+
+    @Override
+    public ByteBuffer getByteBufferData() {
+        return byteBufferData;
+    }
+
+    @Override
+    public InputStream getStreamData() {
+        return streamData;
     }
 
-    return sb.toString();
-  }
+    @Override
+    public BodyGenerator getBodyGenerator() {
+        return bodyGenerator;
+    }
+
+    @Override
+    public List<Param> getFormParams() {
+        return formParams;
+    }
+
+    @Override
+    public List<Part> getBodyParts() {
+        return bodyParts;
+    }
+
+    @Override
+    public String getVirtualHost() {
+        return virtualHost;
+    }
+
+    @Override
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
+    @Override
+    public Realm getRealm() {
+        return realm;
+    }
+
+    @Override
+    public File getFile() {
+        return file;
+    }
+
+    @Override
+    public Boolean getFollowRedirect() {
+        return followRedirect;
+    }
+
+    @Override
+    public int getRequestTimeout() {
+        return requestTimeout;
+    }
+
+    @Override
+    public int getReadTimeout() {
+        return readTimeout;
+    }
+
+    @Override
+    public long getRangeOffset() {
+        return rangeOffset;
+    }
+
+    @Override
+    public Charset getCharset() {
+        return charset;
+    }
+
+    @Override
+    public ChannelPoolPartitioning getChannelPoolPartitioning() {
+        return channelPoolPartitioning;
+    }
+
+    @Override
+    public NameResolver<InetAddress> getNameResolver() {
+        return nameResolver;
+    }
+
+    @Override
+    public List<Param> getQueryParams() {
+        if (queryParams == null)
+            // lazy load
+            if (isNonEmpty(uri.getQuery())) {
+                queryParams = new ArrayList<>(1);
+                for (String queryStringParam : uri.getQuery().split("&")) {
+                    int pos = queryStringParam.indexOf('=');
+                    if (pos <= 0)
+                        queryParams.add(new Param(queryStringParam, null));
+                    else
+                        queryParams.add(new Param(queryStringParam.substring(0, pos), queryStringParam.substring(pos + 1)));
+                }
+            } else
+                queryParams = Collections.emptyList();
+        return queryParams;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder(getUrl());
+
+        sb.append("\t");
+        sb.append(method);
+        sb.append("\theaders:");
+        if (!headers.isEmpty()) {
+            for (Map.Entry<String, String> header : headers) {
+                sb.append("\t");
+                sb.append(header.getKey());
+                sb.append(":");
+                sb.append(header.getValue());
+            }
+        }
+        if (isNonEmpty(formParams)) {
+            sb.append("\tformParams:");
+            for (Param param : formParams) {
+                sb.append("\t");
+                sb.append(param.getName());
+                sb.append(":");
+                sb.append(param.getValue());
+            }
+        }
+
+        return sb.toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 914b734b7..4d3d9b4b1 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -13,109 +13,109 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.proxy.ProxyServer;
 
-import static org.asynchttpclient.util.HttpConstants.Methods.*;
-
 public final class Dsl {
 
-  private Dsl() {
-  }
-
-  // /////////// Client ////////////////
-  public static AsyncHttpClient asyncHttpClient() {
-    return new DefaultAsyncHttpClient();
-  }
-
-  public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {
-    return new DefaultAsyncHttpClient(configBuilder.build());
-  }
-
-  public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
-    return new DefaultAsyncHttpClient(config);
-  }
-
-  // /////////// Request ////////////////
-  public static RequestBuilder get(String url) {
-    return request(GET, url);
-  }
-
-  public static RequestBuilder put(String url) {
-    return request(PUT, url);
-  }
-
-  public static RequestBuilder post(String url) {
-    return request(POST, url);
-  }
-
-  public static RequestBuilder delete(String url) {
-    return request(DELETE, url);
-  }
-
-  public static RequestBuilder head(String url) {
-    return request(HEAD, url);
-  }
-
-  public static RequestBuilder options(String url) {
-    return request(OPTIONS, url);
-  }
-
-  public static RequestBuilder patch(String url) {
-    return request(PATCH, url);
-  }
-
-  public static RequestBuilder trace(String url) {
-    return request(TRACE, url);
-  }
-
-  public static RequestBuilder request(String method, String url) {
-    return new RequestBuilder(method).setUrl(url);
-  }
-
-  // /////////// ProxyServer ////////////////
-  public static ProxyServer.Builder proxyServer(String host, int port) {
-    return new ProxyServer.Builder(host, port);
-  }
-
-  // /////////// Config ////////////////
-  public static DefaultAsyncHttpClientConfig.Builder config() {
-    return new DefaultAsyncHttpClientConfig.Builder();
-  }
-
-  // /////////// Realm ////////////////
-  public static Realm.Builder realm(Realm prototype) {
-    return new Realm.Builder(prototype.getPrincipal(), prototype.getPassword())
-            .setRealmName(prototype.getRealmName())
-            .setAlgorithm(prototype.getAlgorithm())
-            .setNc(prototype.getNc())
-            .setNonce(prototype.getNonce())
-            .setCharset(prototype.getCharset())
-            .setOpaque(prototype.getOpaque())
-            .setQop(prototype.getQop())
-            .setScheme(prototype.getScheme())
-            .setUri(prototype.getUri())
-            .setUsePreemptiveAuth(prototype.isUsePreemptiveAuth())
-            .setNtlmDomain(prototype.getNtlmDomain())
-            .setNtlmHost(prototype.getNtlmHost())
-            .setUseAbsoluteURI(prototype.isUseAbsoluteURI())
-            .setOmitQuery(prototype.isOmitQuery());
-  }
-
-  public static Realm.Builder realm(AuthScheme scheme, String principal, String password) {
-    return new Realm.Builder(principal, password)
-            .setScheme(scheme);
-  }
-
-  public static Realm.Builder basicAuthRealm(String principal, String password) {
-    return realm(AuthScheme.BASIC, principal, password);
-  }
-
-  public static Realm.Builder digestAuthRealm(String principal, String password) {
-    return realm(AuthScheme.DIGEST, principal, password);
-  }
-
-  public static Realm.Builder ntlmAuthRealm(String principal, String password) {
-    return realm(AuthScheme.NTLM, principal, password);
-  }
+    // /////////// Client ////////////////
+    public static AsyncHttpClient asyncHttpClient() {
+        return new DefaultAsyncHttpClient();
+    }
+
+    public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {
+        return new DefaultAsyncHttpClient(configBuilder.build());
+    }
+
+    public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
+        return new DefaultAsyncHttpClient(config);
+    }
+
+    // /////////// Request ////////////////
+    public static RequestBuilder get(String url) {
+        return request(GET, url);
+    }
+
+    public static RequestBuilder put(String url) {
+        return request(PUT, url);
+    }
+
+    public static RequestBuilder post(String url) {
+        return request(POST, url);
+    }
+
+    public static RequestBuilder delete(String url) {
+        return request(DELETE, url);
+    }
+
+    public static RequestBuilder head(String url) {
+        return request(HEAD, url);
+    }
+
+    public static RequestBuilder options(String url) {
+        return request(OPTIONS, url);
+    }
+
+    public static RequestBuilder patch(String url) {
+        return request(PATCH, url);
+    }
+
+    public static RequestBuilder trace(String url) {
+        return request(TRACE, url);
+    }
+
+    public static RequestBuilder request(String method, String url) {
+        return new RequestBuilder(method).setUrl(url);
+    }
+
+    // /////////// ProxyServer ////////////////
+    public static ProxyServer.Builder proxyServer(String host, int port) {
+        return new ProxyServer.Builder(host, port);
+    }
+
+    // /////////// Config ////////////////
+    public static DefaultAsyncHttpClientConfig.Builder config() {
+        return new DefaultAsyncHttpClientConfig.Builder();
+    }
+
+    // /////////// Realm ////////////////
+    public static Realm.Builder realm(Realm prototype) {
+        return new Realm.Builder(prototype.getPrincipal(), prototype.getPassword())//
+                .setRealmName(prototype.getRealmName())//
+                .setAlgorithm(prototype.getAlgorithm())//
+                .setNc(prototype.getNc())//
+                .setNonce(prototype.getNonce())//
+                .setCharset(prototype.getCharset())//
+                .setOpaque(prototype.getOpaque())//
+                .setQop(prototype.getQop())//
+                .setScheme(prototype.getScheme())//
+                .setUri(prototype.getUri())//
+                .setUsePreemptiveAuth(prototype.isUsePreemptiveAuth())//
+                .setNtlmDomain(prototype.getNtlmDomain())//
+                .setNtlmHost(prototype.getNtlmHost())//
+                .setUseAbsoluteURI(prototype.isUseAbsoluteURI())//
+                .setOmitQuery(prototype.isOmitQuery());
+    }
+
+    public static Realm.Builder realm(AuthScheme scheme, String principal, String password) {
+        return new Realm.Builder(principal, password)//
+                .setScheme(scheme);
+    }
+
+    public static Realm.Builder basicAuthRealm(String principal, String password) {
+        return realm(AuthScheme.BASIC, principal, password);
+    }
+
+    public static Realm.Builder digestAuthRealm(String principal, String password) {
+        return realm(AuthScheme.DIGEST, principal, password);
+    }
+
+    public static Realm.Builder ntlmAuthRealm(String principal, String password) {
+        return realm(AuthScheme.NTLM, principal, password);
+    }
+
+    private Dsl() {
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HostStats.java b/client/src/main/java/org/asynchttpclient/HostStats.java
index b5fea52f6..87d927882 100644
--- a/client/src/main/java/org/asynchttpclient/HostStats.java
+++ b/client/src/main/java/org/asynchttpclient/HostStats.java
@@ -20,55 +20,55 @@
  */
 public class HostStats {
 
-  private final long activeConnectionCount;
-  private final long idleConnectionCount;
+    private final long activeConnectionCount;
+    private final long idleConnectionCount;
 
-  public HostStats(long activeConnectionCount,
-                   long idleConnectionCount) {
-    this.activeConnectionCount = activeConnectionCount;
-    this.idleConnectionCount = idleConnectionCount;
-  }
+    public HostStats(long activeConnectionCount,
+                     long idleConnectionCount) {
+        this.activeConnectionCount = activeConnectionCount;
+        this.idleConnectionCount = idleConnectionCount;
+    }
 
-  /**
-   * @return The sum of {@link #getHostActiveConnectionCount()} and {@link #getHostIdleConnectionCount()},
-   * a long representing the total number of connections to this host.
-   */
-  public long getHostConnectionCount() {
-    return activeConnectionCount + idleConnectionCount;
-  }
+    /**
+     * @return The sum of {@link #getHostActiveConnectionCount()} and {@link #getHostIdleConnectionCount()},
+     * a long representing the total number of connections to this host.
+     */
+    public long getHostConnectionCount() {
+        return activeConnectionCount + idleConnectionCount;
+    }
 
-  /**
-   * @return A long representing the number of active connections to the host.
-   */
-  public long getHostActiveConnectionCount() {
-    return activeConnectionCount;
-  }
+    /**
+     * @return A long representing the number of active connections to the host.
+     */
+    public long getHostActiveConnectionCount() {
+        return activeConnectionCount;
+    }
 
-  /**
-   * @return A long representing the number of idle connections in the connection pool.
-   */
-  public long getHostIdleConnectionCount() {
-    return idleConnectionCount;
-  }
+    /**
+     * @return A long representing the number of idle connections in the connection pool.
+     */
+    public long getHostIdleConnectionCount() {
+        return idleConnectionCount;
+    }
 
-  @Override
-  public String toString() {
-    return "There are " + getHostConnectionCount() +
-            " total connections, " + getHostActiveConnectionCount() +
-            " are active and " + getHostIdleConnectionCount() + " are idle.";
-  }
+    @Override
+    public String toString() {
+        return "There are " + getHostConnectionCount() +
+                " total connections, " + getHostActiveConnectionCount() +
+                " are active and " + getHostIdleConnectionCount() + " are idle.";
+    }
 
-  @Override
-  public boolean equals(final Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-    final HostStats hostStats = (HostStats) o;
-    return activeConnectionCount == hostStats.activeConnectionCount &&
-            idleConnectionCount == hostStats.idleConnectionCount;
-  }
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        final HostStats hostStats = (HostStats) o;
+        return activeConnectionCount == hostStats.activeConnectionCount &&
+                idleConnectionCount == hostStats.idleConnectionCount;
+    }
 
-  @Override
-  public int hashCode() {
-    return Objects.hash(activeConnectionCount, idleConnectionCount);
-  }
+    @Override
+    public int hashCode() {
+        return Objects.hash(activeConnectionCount, idleConnectionCount);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 053aa28ff..38da320f6 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -22,32 +22,32 @@
  */
 public abstract class HttpResponseBodyPart {
 
-  private final boolean last;
-
-  public HttpResponseBodyPart(boolean last) {
-    this.last = last;
-  }
-
-  /**
-   * @return length of this part in bytes
-   */
-  public abstract int length();
-
-  /**
-   * @return the response body's part bytes received.
-   */
-  public abstract byte[] getBodyPartBytes();
-
-  /**
-   * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
-   * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
-   */
-  public abstract ByteBuffer getBodyByteBuffer();
-
-  /**
-   * @return true if this is the last part.
-   */
-  public boolean isLast() {
-    return last;
-  }
+    private final boolean last;
+
+    public HttpResponseBodyPart(boolean last) {
+        this.last = last;
+    }
+
+    /**
+     * @return length of this part in bytes
+     */
+    public abstract int length();
+
+    /**
+     * @return  the response body's part bytes received.
+     */
+    public abstract byte[] getBodyPartBytes();
+
+    /**
+     * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
+     * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
+     */
+    public abstract ByteBuffer getBodyByteBuffer();
+
+    /**
+     * @return true if this is the last part.
+     */
+    public boolean isLast() {
+        return last;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index 75c94b855..d0ef51439 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -16,93 +16,93 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.uri.Uri;
-
 import java.net.SocketAddress;
 
+import org.asynchttpclient.uri.Uri;
+
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
 public abstract class HttpResponseStatus {
 
-  private final Uri uri;
+    private final Uri uri;
 
-  public HttpResponseStatus(Uri uri) {
-    this.uri = uri;
-  }
+    public HttpResponseStatus(Uri uri) {
+        this.uri = uri;
+    }
 
-  /**
-   * Return the request {@link Uri}
-   *
-   * @return the request {@link Uri}
-   */
-  public final Uri getUri() {
-    return uri;
-  }
+    /**
+     * Return the request {@link Uri}
+     * 
+     * @return the request {@link Uri}
+     */
+    public final Uri getUri() {
+        return uri;
+    }
 
-  /**
-   * Return the response status code
-   *
-   * @return the response status code
-   */
-  public abstract int getStatusCode();
+    /**
+     * Return the response status code
+     * 
+     * @return the response status code
+     */
+    public abstract int getStatusCode();
 
-  /**
-   * Return the response status text
-   *
-   * @return the response status text
-   */
-  public abstract String getStatusText();
+    /**
+     * Return the response status text
+     * 
+     * @return the response status text
+     */
+    public abstract String getStatusText();
 
-  /**
-   * Protocol name from status line.
-   *
-   * @return Protocol name.
-   */
-  public abstract String getProtocolName();
+    /**
+     * Protocol name from status line.
+     * 
+     * @return Protocol name.
+     */
+    public abstract String getProtocolName();
 
-  /**
-   * Protocol major version.
-   *
-   * @return Major version.
-   */
-  public abstract int getProtocolMajorVersion();
+    /**
+     * Protocol major version.
+     * 
+     * @return Major version.
+     */
+    public abstract int getProtocolMajorVersion();
 
-  /**
-   * Protocol minor version.
-   *
-   * @return Minor version.
-   */
-  public abstract int getProtocolMinorVersion();
+    /**
+     * Protocol minor version.
+     * 
+     * @return Minor version.
+     */
+    public abstract int getProtocolMinorVersion();
 
-  /**
-   * Full protocol name + version
-   *
-   * @return protocol name + version
-   */
-  public abstract String getProtocolText();
+    /**
+     * Full protocol name + version
+     * 
+     * @return protocol name + version
+     */
+    public abstract String getProtocolText();
 
-  /**
-   * Get remote address client initiated request to.
-   *
-   * @return remote address client initiated request to, may be {@code null}
-   * if asynchronous provider is unable to provide the remote address
-   */
-  public abstract SocketAddress getRemoteAddress();
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null}
+     *         if asynchronous provider is unable to provide the remote address
+     */
+    public abstract SocketAddress getRemoteAddress();
 
-  /**
-   * Get local address client initiated request from.
-   *
-   * @return local address client initiated request from, may be {@code null}
-   * if asynchronous provider is unable to provide the local address
-   */
-  public abstract SocketAddress getLocalAddress();
+    /**
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null}
+     *         if asynchronous provider is unable to provide the local address
+     */
+    public abstract SocketAddress getLocalAddress();
 
-  /**
-   * Code followed by text.
-   */
-  @Override
-  public String toString() {
-    return getStatusCode() + " " + getStatusText();
-  }
+    /**
+     * Code followed by text.
+     */
+    @Override
+    public String toString() {
+        return getStatusCode() + " " + getStatusText();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ListenableFuture.java b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
index d63ebc52c..46a0a261e 100755
--- a/client/src/main/java/org/asynchttpclient/ListenableFuture.java
+++ b/client/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -30,7 +30,12 @@
  */
 package org.asynchttpclient;
 
-import java.util.concurrent.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 /**
  * Extended {@link Future}
@@ -39,109 +44,109 @@
  */
 public interface ListenableFuture<V> extends Future<V> {
 
-  /**
-   * Terminate and if there is no exception, mark this Future as done and release the internal lock.
-   */
-  void done();
-
-  /**
-   * Abort the current processing, and propagate the {@link Throwable} to the {@link AsyncHandler} or {@link Future}
-   *
-   * @param t the exception
-   */
-  void abort(Throwable t);
-
-  /**
-   * Touch the current instance to prevent external service to times out.
-   */
-  void touch();
-
-  /**
-   * Adds a listener and executor to the ListenableFuture.
-   * The listener will be {@linkplain java.util.concurrent.Executor#execute(Runnable) passed
-   * to the executor} for execution when the {@code Future}'s computation is
-   * {@linkplain Future#isDone() complete}.
-   * <br>
-   * Executor can be <code>null</code>, in that case executor will be executed
-   * in the thread where completion happens.
-   * <br>
-   * There is no guaranteed ordering of execution of listeners, they may get
-   * called in the order they were added and they may get called out of order,
-   * but any listener added through this method is guaranteed to be called once
-   * the computation is complete.
-   *
-   * @param listener the listener to run when the computation is complete.
-   * @param exec     the executor to run the listener in.
-   * @return this Future
-   */
-  ListenableFuture<V> addListener(Runnable listener, Executor exec);
-
-  CompletableFuture<V> toCompletableFuture();
-
-  class CompletedFailure<T> implements ListenableFuture<T> {
-
-    private final ExecutionException e;
-
-    public CompletedFailure(Throwable t) {
-      e = new ExecutionException(t);
+    /**
+     * Terminate and if there is no exception, mark this Future as done and release the internal lock.
+     */
+    void done();
+
+    /**
+     * Abort the current processing, and propagate the {@link Throwable} to the {@link AsyncHandler} or {@link Future}
+     *
+     * @param t the exception
+     */
+    void abort(Throwable t);
+
+    /**
+     * Touch the current instance to prevent external service to times out.
+     */
+    void touch();
+
+    /**
+     * Adds a listener and executor to the ListenableFuture.
+     * The listener will be {@linkplain java.util.concurrent.Executor#execute(Runnable) passed
+     * to the executor} for execution when the {@code Future}'s computation is
+     * {@linkplain Future#isDone() complete}.
+     * <br>
+     * Executor can be <code>null</code>, in that case executor will be executed
+     * in the thread where completion happens.
+     * <br>
+     * There is no guaranteed ordering of execution of listeners, they may get
+     * called in the order they were added and they may get called out of order,
+     * but any listener added through this method is guaranteed to be called once
+     * the computation is complete.
+     *
+     * @param listener the listener to run when the computation is complete.
+     * @param exec     the executor to run the listener in.
+     * @return this Future
+     */
+    ListenableFuture<V> addListener(Runnable listener, Executor exec);
+
+    CompletableFuture<V> toCompletableFuture();
+    
+    class CompletedFailure<T> implements ListenableFuture<T>{
+
+        private final ExecutionException e;
+
+        public CompletedFailure(Throwable t) {
+            e = new ExecutionException(t);
+        }
+
+        public CompletedFailure(String message, Throwable t) {
+            e = new ExecutionException(message, t);
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return true;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+
+        @Override
+        public T get() throws InterruptedException, ExecutionException {
+            throw e;
+        }
+
+        @Override
+        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            throw e;
+        }
+
+        @Override
+        public void done() {
+        }
+
+        @Override
+        public void abort(Throwable t) {
+        }
+
+        @Override
+        public void touch() {
+        }
+
+        @Override
+        public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
+            if (exec != null) {
+                exec.execute(listener);
+            } else {
+                listener.run();
+            }
+            return this;
+        }
+        
+        @Override
+        public CompletableFuture<T> toCompletableFuture() {
+            CompletableFuture<T> future = new CompletableFuture<>();
+            future.completeExceptionally(e);
+            return future;
+        }
     }
-
-    public CompletedFailure(String message, Throwable t) {
-      e = new ExecutionException(message, t);
-    }
-
-    @Override
-    public boolean cancel(boolean mayInterruptIfRunning) {
-      return true;
-    }
-
-    @Override
-    public boolean isCancelled() {
-      return false;
-    }
-
-    @Override
-    public boolean isDone() {
-      return true;
-    }
-
-    @Override
-    public T get() throws ExecutionException {
-      throw e;
-    }
-
-    @Override
-    public T get(long timeout, TimeUnit unit) throws ExecutionException {
-      throw e;
-    }
-
-    @Override
-    public void done() {
-    }
-
-    @Override
-    public void abort(Throwable t) {
-    }
-
-    @Override
-    public void touch() {
-    }
-
-    @Override
-    public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
-      if (exec != null) {
-        exec.execute(listener);
-      } else {
-        listener.run();
-      }
-      return this;
-    }
-
-    @Override
-    public CompletableFuture<T> toCompletableFuture() {
-      CompletableFuture<T> future = new CompletableFuture<>();
-      future.completeExceptionally(e);
-      return future;
-    }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Param.java b/client/src/main/java/org/asynchttpclient/Param.java
index 858c1158e..e3ee12ce6 100644
--- a/client/src/main/java/org/asynchttpclient/Param.java
+++ b/client/src/main/java/org/asynchttpclient/Param.java
@@ -18,66 +18,62 @@
 
 /**
  * A pair of (name, value) String
- *
  * @author slandelle
  */
 public class Param {
+    
+    public static List<Param> map2ParamList(Map<String, List<String>> map) {
+        if (map == null)
+            return null;
 
-  private final String name;
-  private final String value;
-
-  public Param(String name, String value) {
-    this.name = name;
-    this.value = value;
-  }
-
-  public static List<Param> map2ParamList(Map<String, List<String>> map) {
-    if (map == null)
-      return null;
-
-    List<Param> params = new ArrayList<>(map.size());
-    for (Map.Entry<String, List<String>> entries : map.entrySet()) {
-      String name = entries.getKey();
-      for (String value : entries.getValue())
-        params.add(new Param(name, value));
+        List<Param> params = new ArrayList<>(map.size());
+        for (Map.Entry<String, List<String>> entries : map.entrySet()) {
+            String name = entries.getKey();
+            for (String value : entries.getValue())
+                params.add(new Param(name, value));
+        }
+        return params;
     }
-    return params;
-  }
-
-  public String getName() {
-    return name;
-  }
 
-  public String getValue() {
-    return value;
-  }
+    private final String name;
+    private final String value;
+    public Param(String name, String value) {
+        this.name = name;
+        this.value = value;
+    }
+    public String getName() {
+        return name;
+    }
+    public String getValue() {
+        return value;
+    }
 
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((name == null) ? 0 : name.hashCode());
-    result = prime * result + ((value == null) ? 0 : value.hashCode());
-    return result;
-  }
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((name == null) ? 0 : name.hashCode());
+        result = prime * result + ((value == null) ? 0 : value.hashCode());
+        return result;
+    }
 
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (!(obj instanceof Param))
-      return false;
-    Param other = (Param) obj;
-    if (name == null) {
-      if (other.name != null)
-        return false;
-    } else if (!name.equals(other.name))
-      return false;
-    if (value == null) {
-      if (other.value != null)
-        return false;
-    } else if (!value.equals(other.value))
-      return false;
-    return true;
-  }
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (!(obj instanceof Param))
+            return false;
+        Param other = (Param) obj;
+        if (name == null) {
+            if (other.name != null)
+                return false;
+        } else if (!name.equals(other.name))
+            return false;
+        if (value == null) {
+            if (other.value != null)
+                return false;
+        } else if (!value.equals(other.value))
+            return false;
+        return true;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 9b9bdf798..a80da0ed6 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -16,492 +16,502 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.util.StringBuilderPool;
-import org.asynchttpclient.util.StringUtils;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.StringUtils.*;
 
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.ThreadLocalRandom;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledMd5MessageDigest;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.StringUtils.appendBase16;
-import static org.asynchttpclient.util.StringUtils.toHexString;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.StringBuilderPool;
+import org.asynchttpclient.util.StringUtils;
 
 /**
- * This class is required when authentication is needed. The class support
- * BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
+ * This class is required when authentication is needed. The class support BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
  */
 public class Realm {
 
-  private static final String DEFAULT_NC = "00000001";
-  // MD5("")
-  private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
-
-  private final String principal;
-  private final String password;
-  private final AuthScheme scheme;
-  private final String realmName;
-  private final String nonce;
-  private final String algorithm;
-  private final String response;
-  private final String opaque;
-  private final String qop;
-  private final String nc;
-  private final String cnonce;
-  private final Uri uri;
-  private final boolean usePreemptiveAuth;
-  private final Charset charset;
-  private final String ntlmHost;
-  private final String ntlmDomain;
-  private final boolean useAbsoluteURI;
-  private final boolean omitQuery;
-
-  private Realm(AuthScheme scheme,
-                String principal,
-                String password,
-                String realmName,
-                String nonce,
-                String algorithm,
-                String response,
-                String opaque,
-                String qop,
-                String nc,
-                String cnonce,
-                Uri uri,
-                boolean usePreemptiveAuth,
-                Charset charset,
-                String ntlmDomain,
-                String ntlmHost,
-                boolean useAbsoluteURI,
-                boolean omitQuery) {
-
-    this.scheme = assertNotNull(scheme, "scheme");
-    this.principal = assertNotNull(principal, "principal");
-    this.password = assertNotNull(password, "password");
-    this.realmName = realmName;
-    this.nonce = nonce;
-    this.algorithm = algorithm;
-    this.response = response;
-    this.opaque = opaque;
-    this.qop = qop;
-    this.nc = nc;
-    this.cnonce = cnonce;
-    this.uri = uri;
-    this.usePreemptiveAuth = usePreemptiveAuth;
-    this.charset = charset;
-    this.ntlmDomain = ntlmDomain;
-    this.ntlmHost = ntlmHost;
-    this.useAbsoluteURI = useAbsoluteURI;
-    this.omitQuery = omitQuery;
-  }
-
-  public String getPrincipal() {
-    return principal;
-  }
-
-  public String getPassword() {
-    return password;
-  }
-
-  public AuthScheme getScheme() {
-    return scheme;
-  }
-
-  public String getRealmName() {
-    return realmName;
-  }
-
-  public String getNonce() {
-    return nonce;
-  }
-
-  public String getAlgorithm() {
-    return algorithm;
-  }
-
-  public String getResponse() {
-    return response;
-  }
-
-  public String getOpaque() {
-    return opaque;
-  }
-
-  public String getQop() {
-    return qop;
-  }
-
-  public String getNc() {
-    return nc;
-  }
-
-  public String getCnonce() {
-    return cnonce;
-  }
-
-  public Uri getUri() {
-    return uri;
-  }
-
-  public Charset getCharset() {
-    return charset;
-  }
-
-  /**
-   * Return true is preemptive authentication is enabled
-   *
-   * @return true is preemptive authentication is enabled
-   */
-  public boolean isUsePreemptiveAuth() {
-    return usePreemptiveAuth;
-  }
-
-  /**
-   * Return the NTLM domain to use. This value should map the JDK
-   *
-   * @return the NTLM domain
-   */
-  public String getNtlmDomain() {
-    return ntlmDomain;
-  }
-
-  /**
-   * Return the NTLM host.
-   *
-   * @return the NTLM host
-   */
-  public String getNtlmHost() {
-    return ntlmHost;
-  }
-
-  public boolean isUseAbsoluteURI() {
-    return useAbsoluteURI;
-  }
-
-  public boolean isOmitQuery() {
-    return omitQuery;
-  }
-
-  @Override
-  public String toString() {
-    return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\''
-            + ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm + '\'' + ", response='" + response + '\''
-            + ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
-            + ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
-  }
-
-  public enum AuthScheme {
-    BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
-  }
-
-  /**
-   * A builder for {@link Realm}
-   */
-  public static class Builder {
+    private static final String DEFAULT_NC = "00000001";
+    // MD5("")
+    private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
 
     private final String principal;
     private final String password;
-    private AuthScheme scheme;
-    private String realmName;
-    private String nonce;
-    private String algorithm;
-    private String response;
-    private String opaque;
-    private String qop;
-    private String nc = DEFAULT_NC;
-    private String cnonce;
-    private Uri uri;
-    private String methodName = "GET";
-    private boolean usePreemptive;
-    private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
-    private Charset charset = UTF_8;
-    private String ntlmHost = "localhost";
-    private boolean useAbsoluteURI = false;
-    private boolean omitQuery;
-
-    public Builder(String principal, String password) {
-      this.principal = principal;
-      this.password = password;
-    }
-
-    public Builder setNtlmDomain(String ntlmDomain) {
-      this.ntlmDomain = ntlmDomain;
-      return this;
-    }
-
-    public Builder setNtlmHost(String host) {
-      this.ntlmHost = host;
-      return this;
-    }
-
-    public Builder setScheme(AuthScheme scheme) {
-      this.scheme = scheme;
-      return this;
+    private final AuthScheme scheme;
+    private final String realmName;
+    private final String nonce;
+    private final String algorithm;
+    private final String response;
+    private final String opaque;
+    private final String qop;
+    private final String nc;
+    private final String cnonce;
+    private final Uri uri;
+    private final boolean usePreemptiveAuth;
+    private final Charset charset;
+    private final String ntlmHost;
+    private final String ntlmDomain;
+    private final boolean useAbsoluteURI;
+    private final boolean omitQuery;
+
+    public enum AuthScheme {
+        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
     }
 
-    public Builder setRealmName(String realmName) {
-      this.realmName = realmName;
-      return this;
-    }
-
-    public Builder setNonce(String nonce) {
-      this.nonce = nonce;
-      return this;
-    }
-
-    public Builder setAlgorithm(String algorithm) {
-      this.algorithm = algorithm;
-      return this;
-    }
-
-    public Builder setResponse(String response) {
-      this.response = response;
-      return this;
+    private Realm(AuthScheme scheme,//
+            String principal,//
+            String password,//
+            String realmName,//
+            String nonce,//
+            String algorithm,//
+            String response,//
+            String opaque,//
+            String qop,//
+            String nc,//
+            String cnonce,//
+            Uri uri,//
+            boolean usePreemptiveAuth,//
+            Charset charset,//
+            String ntlmDomain,//
+            String ntlmHost,//
+            boolean useAbsoluteURI,//
+            boolean omitQuery) {
+
+        this.scheme = assertNotNull(scheme, "scheme");
+        this.principal = assertNotNull(principal, "principal");
+        this.password = assertNotNull(password, "password");
+        this.realmName = realmName;
+        this.nonce = nonce;
+        this.algorithm = algorithm;
+        this.response = response;
+        this.opaque = opaque;
+        this.qop = qop;
+        this.nc = nc;
+        this.cnonce = cnonce;
+        this.uri = uri;
+        this.usePreemptiveAuth = usePreemptiveAuth;
+        this.charset = charset;
+        this.ntlmDomain = ntlmDomain;
+        this.ntlmHost = ntlmHost;
+        this.useAbsoluteURI = useAbsoluteURI;
+        this.omitQuery = omitQuery;
     }
 
-    public Builder setOpaque(String opaque) {
-      this.opaque = opaque;
-      return this;
+    public String getPrincipal() {
+        return principal;
     }
 
-    public Builder setQop(String qop) {
-      if (isNonEmpty(qop)) {
-        this.qop = qop;
-      }
-      return this;
+    public String getPassword() {
+        return password;
     }
 
-    public Builder setNc(String nc) {
-      this.nc = nc;
-      return this;
+    public AuthScheme getScheme() {
+        return scheme;
     }
 
-    public Builder setUri(Uri uri) {
-      this.uri = uri;
-      return this;
+    public String getRealmName() {
+        return realmName;
     }
 
-    public Builder setMethodName(String methodName) {
-      this.methodName = methodName;
-      return this;
+    public String getNonce() {
+        return nonce;
     }
 
-    public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
-      this.usePreemptive = usePreemptiveAuth;
-      return this;
+    public String getAlgorithm() {
+        return algorithm;
     }
 
-    public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
-      this.useAbsoluteURI = useAbsoluteURI;
-      return this;
+    public String getResponse() {
+        return response;
     }
 
-    public Builder setOmitQuery(boolean omitQuery) {
-      this.omitQuery = omitQuery;
-      return this;
+    public String getOpaque() {
+        return opaque;
     }
 
-    public Builder setCharset(Charset charset) {
-      this.charset = charset;
-      return this;
+    public String getQop() {
+        return qop;
     }
 
-    private String parseRawQop(String rawQop) {
-      String[] rawServerSupportedQops = rawQop.split(",");
-      String[] serverSupportedQops = new String[rawServerSupportedQops.length];
-      for (int i = 0; i < rawServerSupportedQops.length; i++) {
-        serverSupportedQops[i] = rawServerSupportedQops[i].trim();
-      }
-
-      // prefer auth over auth-int
-      for (String rawServerSupportedQop : serverSupportedQops) {
-        if (rawServerSupportedQop.equals("auth"))
-          return rawServerSupportedQop;
-      }
-
-      for (String rawServerSupportedQop : serverSupportedQops) {
-        if (rawServerSupportedQop.equals("auth-int"))
-          return rawServerSupportedQop;
-      }
-
-      return null;
+    public String getNc() {
+        return nc;
     }
 
-    public Builder parseWWWAuthenticateHeader(String headerLine) {
-      setRealmName(match(headerLine, "realm"))
-              .setNonce(match(headerLine, "nonce"))
-              .setOpaque(match(headerLine, "opaque"))
-              .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-      String algorithm = match(headerLine, "algorithm");
-      if (isNonEmpty(algorithm)) {
-        setAlgorithm(algorithm);
-      }
-
-      // FIXME qop is different with proxy?
-      String rawQop = match(headerLine, "qop");
-      if (rawQop != null) {
-        setQop(parseRawQop(rawQop));
-      }
-
-      return this;
+    public String getCnonce() {
+        return cnonce;
     }
 
-    public Builder parseProxyAuthenticateHeader(String headerLine) {
-      setRealmName(match(headerLine, "realm"))
-              .setNonce(match(headerLine, "nonce"))
-              .setOpaque(match(headerLine, "opaque"))
-              .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-      String algorithm = match(headerLine, "algorithm");
-      if (isNonEmpty(algorithm)) {
-        setAlgorithm(algorithm);
-      }
-      // FIXME qop is different with proxy?
-      setQop(match(headerLine, "qop"));
-
-      return this;
+    public Uri getUri() {
+        return uri;
     }
 
-    private void newCnonce(MessageDigest md) {
-      byte[] b = new byte[8];
-      ThreadLocalRandom.current().nextBytes(b);
-      b = md.digest(b);
-      cnonce = toHexString(b);
+    public Charset getCharset() {
+        return charset;
     }
 
     /**
-     * TODO: A Pattern/Matcher may be better.
+     * Return true is preemptive authentication is enabled
+     * 
+     * @return true is preemptive authentication is enabled
      */
-    private String match(String headerLine, String token) {
-      if (headerLine == null) {
-        return null;
-      }
-
-      int match = headerLine.indexOf(token);
-      if (match <= 0)
-        return null;
-
-      // = to skip
-      match += token.length() + 1;
-      int trailingComa = headerLine.indexOf(",", match);
-      String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
-      value = value.length() > 0 && value.charAt(value.length() - 1) == '"'
-              ? value.substring(0, value.length() - 1)
-              : value;
-      return value.charAt(0) == '"' ? value.substring(1) : value;
+    public boolean isUsePreemptiveAuth() {
+        return usePreemptiveAuth;
     }
 
-    private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
-      md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
-      sb.setLength(0);
-      return md.digest();
+    /**
+     * Return the NTLM domain to use. This value should map the JDK
+     * 
+     * @return the NTLM domain
+     */
+    public String getNtlmDomain() {
+        return ntlmDomain;
     }
 
-    private byte[] ha1(StringBuilder sb, MessageDigest md) {
-      // if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":"
-      // passwd
-      // if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":"
-      // passwd ) ":" nonce-value ":" cnonce-value
-
-      sb.append(principal).append(':').append(realmName).append(':').append(password);
-      byte[] core = md5FromRecycledStringBuilder(sb, md);
-
-      if (algorithm == null || algorithm.equals("MD5")) {
-        // A1 = username ":" realm-value ":" passwd
-        return core;
-      } else if ("MD5-sess".equals(algorithm)) {
-        // A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
-        appendBase16(sb, core);
-        sb.append(':').append(nonce).append(':').append(cnonce);
-        return md5FromRecycledStringBuilder(sb, md);
-      }
-
-      throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+    /**
+     * Return the NTLM host.
+     * 
+     * @return the NTLM host
+     */
+    public String getNtlmHost() {
+        return ntlmHost;
     }
 
-    private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
-
-      // if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
-      // if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
-      sb.append(methodName).append(':').append(digestUri);
-      if ("auth-int".equals(qop)) {
-        // when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
-        // but we don't have the request body here
-        // we would need a new API
-        sb.append(':').append(EMPTY_ENTITY_MD5);
-
-      } else if (qop != null && !qop.equals("auth")) {
-        throw new UnsupportedOperationException("Digest qop not supported: " + qop);
-      }
-
-      return md5FromRecycledStringBuilder(sb, md);
+    public boolean isUseAbsoluteURI() {
+        return useAbsoluteURI;
     }
 
-    private void appendMiddlePart(StringBuilder sb) {
-      // request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
-      sb.append(':').append(nonce).append(':');
-      if ("auth".equals(qop) || "auth-int".equals(qop)) {
-        sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
-      }
+    public boolean isOmitQuery() {
+        return omitQuery;
     }
 
-    private void newResponse(MessageDigest md) {
-      // when using preemptive auth, the request uri is missing
-      if (uri != null) {
-        // BEWARE: compute first as it uses the cached StringBuilder
-        String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
-
-        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-
-        // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
-        byte[] ha1 = ha1(sb, md);
-        byte[] ha2 = ha2(sb, digestUri, md);
-
-        appendBase16(sb, ha1);
-        appendMiddlePart(sb);
-        appendBase16(sb, ha2);
-
-        byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
-        response = toHexString(responseDigest);
-      }
+    @Override
+    public String toString() {
+        return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\'' + ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm
+                + '\'' + ", response='" + response + '\'' + ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
+                + ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
     }
 
     /**
-     * Build a {@link Realm}
-     *
-     * @return a {@link Realm}
+     * A builder for {@link Realm}
      */
-    public Realm build() {
-
-      // Avoid generating
-      if (isNonEmpty(nonce)) {
-        MessageDigest md = pooledMd5MessageDigest();
-        newCnonce(md);
-        newResponse(md);
-      }
-
-      return new Realm(scheme,
-              principal,
-              password,
-              realmName,
-              nonce,
-              algorithm,
-              response,
-              opaque,
-              qop,
-              nc,
-              cnonce,
-              uri,
-              usePreemptive,
-              charset,
-              ntlmDomain,
-              ntlmHost,
-              useAbsoluteURI,
-              omitQuery);
+    public static class Builder {
+
+        private static final ThreadLocal<MessageDigest> DIGEST_TL = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("MD5");
+                } catch (NoSuchAlgorithmException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+
+        private static MessageDigest getMessageDigest() {
+            MessageDigest md = DIGEST_TL.get();
+            md.reset();
+            return md;
+        }
+
+        private final String principal;
+        private final String password;
+        private AuthScheme scheme;
+        private String realmName;
+        private String nonce;
+        private String algorithm;
+        private String response;
+        private String opaque;
+        private String qop;
+        private String nc = DEFAULT_NC;
+        private String cnonce;
+        private Uri uri;
+        private String methodName = "GET";
+        private boolean usePreemptive;
+        private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
+        private Charset charset = UTF_8;
+        private String ntlmHost = "localhost";
+        private boolean useAbsoluteURI = false;
+        private boolean omitQuery;
+
+        public Builder(String principal, String password) {
+            this.principal = principal;
+            this.password = password;
+        }
+
+        public Builder setNtlmDomain(String ntlmDomain) {
+            this.ntlmDomain = ntlmDomain;
+            return this;
+        }
+
+        public Builder setNtlmHost(String host) {
+            this.ntlmHost = host;
+            return this;
+        }
+
+        public Builder setScheme(AuthScheme scheme) {
+            this.scheme = scheme;
+            return this;
+        }
+
+        public Builder setRealmName(String realmName) {
+            this.realmName = realmName;
+            return this;
+        }
+
+        public Builder setNonce(String nonce) {
+            this.nonce = nonce;
+            return this;
+        }
+
+        public Builder setAlgorithm(String algorithm) {
+            this.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder setResponse(String response) {
+            this.response = response;
+            return this;
+        }
+
+        public Builder setOpaque(String opaque) {
+            this.opaque = opaque;
+            return this;
+        }
+
+        public Builder setQop(String qop) {
+            if (isNonEmpty(qop)) {
+                this.qop = qop;
+            }
+            return this;
+        }
+
+        public Builder setNc(String nc) {
+            this.nc = nc;
+            return this;
+        }
+
+        public Builder setUri(Uri uri) {
+            this.uri = uri;
+            return this;
+        }
+
+        public Builder setMethodName(String methodName) {
+            this.methodName = methodName;
+            return this;
+        }
+
+        public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
+            this.usePreemptive = usePreemptiveAuth;
+            return this;
+        }
+
+        public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
+            this.useAbsoluteURI = useAbsoluteURI;
+            return this;
+        }
+
+        public Builder setOmitQuery(boolean omitQuery) {
+            this.omitQuery = omitQuery;
+            return this;
+        }
+
+        public Builder setCharset(Charset charset) {
+            this.charset = charset;
+            return this;
+        }
+
+        private String parseRawQop(String rawQop) {
+            String[] rawServerSupportedQops = rawQop.split(",");
+            String[] serverSupportedQops = new String[rawServerSupportedQops.length];
+            for (int i = 0; i < rawServerSupportedQops.length; i++) {
+                serverSupportedQops[i] = rawServerSupportedQops[i].trim();
+            }
+
+            // prefer auth over auth-int
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth"))
+                    return rawServerSupportedQop;
+            }
+
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth-int"))
+                    return rawServerSupportedQop;
+            }
+
+            return null;
+        }
+
+        public Builder parseWWWAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+
+            // FIXME qop is different with proxy?
+            String rawQop = match(headerLine, "qop");
+            if (rawQop != null) {
+                setQop(parseRawQop(rawQop));
+            }
+
+            return this;
+        }
+
+        public Builder parseProxyAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+            // FIXME qop is different with proxy?
+            setQop(match(headerLine, "qop"));
+
+            return this;
+        }
+
+        private void newCnonce(MessageDigest md) {
+            byte[] b = new byte[8];
+            ThreadLocalRandom.current().nextBytes(b);
+            b = md.digest(b);
+            cnonce = toHexString(b);
+        }
+
+        /**
+         * TODO: A Pattern/Matcher may be better.
+         */
+        private String match(String headerLine, String token) {
+            if (headerLine == null) {
+                return null;
+            }
+
+            int match = headerLine.indexOf(token);
+            if (match <= 0)
+                return null;
+
+            // = to skip
+            match += token.length() + 1;
+            int trailingComa = headerLine.indexOf(",", match);
+            String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
+            value = value.length() > 0 && value.charAt(value.length() - 1) == '"' ? value.substring(0, value.length() - 1) : value;
+            return value.charAt(0) == '"' ? value.substring(1) : value;
+        }
+
+        private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
+            md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
+            sb.setLength(0);
+            return md.digest();
+        }
+
+        private byte[] ha1(StringBuilder sb, MessageDigest md) {
+            // if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":" passwd
+            // if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":" passwd ) ":" nonce-value ":" cnonce-value
+
+            sb.append(principal).append(':').append(realmName).append(':').append(password);
+            byte[] core = md5FromRecycledStringBuilder(sb, md);
+
+            if (algorithm == null || algorithm.equals("MD5")) {
+                // A1 = username ":" realm-value ":" passwd
+                return core;
+            } else if ("MD5-sess".equals(algorithm)) {
+                // A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
+                appendBase16(sb, core);
+                sb.append(':').append(nonce).append(':').append(cnonce);
+                return md5FromRecycledStringBuilder(sb, md);
+            }
+
+            throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+        }
+
+        private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
+
+            // if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
+            // if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
+            sb.append(methodName).append(':').append(digestUri);
+            if ("auth-int".equals(qop)) {
+                // when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
+                // but we don't have the request body here
+                // we would need a new API
+                sb.append(':').append(EMPTY_ENTITY_MD5);
+
+            } else if (qop != null && !qop.equals("auth")) {
+                throw new UnsupportedOperationException("Digest qop not supported: " + qop);
+            }
+
+            return md5FromRecycledStringBuilder(sb, md);
+        }
+
+        private void appendMiddlePart(StringBuilder sb) {
+            // request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
+            sb.append(':').append(nonce).append(':');
+            if ("auth".equals(qop) || "auth-int".equals(qop)) {
+                sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
+            }
+        }
+
+        private void newResponse(MessageDigest md) {
+            // when using preemptive auth, the request uri is missing
+            if (uri != null) {
+                // BEWARE: compute first as it uses the cached StringBuilder
+                String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
+
+                StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+
+                // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
+                byte[] ha1 = ha1(sb, md);
+                byte[] ha2 = ha2(sb, digestUri, md);
+
+                appendBase16(sb, ha1);
+                appendMiddlePart(sb);
+                appendBase16(sb, ha2);
+
+                byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
+                response = toHexString(responseDigest);
+            }
+        }
+
+        /**
+         * Build a {@link Realm}
+         * 
+         * @return a {@link Realm}
+         */
+        public Realm build() {
+
+            // Avoid generating
+            if (isNonEmpty(nonce)) {
+                MessageDigest md = getMessageDigest();
+                newCnonce(md);
+                newResponse(md);
+            }
+
+            return new Realm(scheme,//
+                    principal,//
+                    password,//
+                    realmName,//
+                    nonce, //
+                    algorithm, //
+                    response,//
+                    opaque, //
+                    qop, //
+                    nc, //
+                    cnonce, //
+                    uri, //
+                    usePreemptive, //
+                    charset, //
+                    ntlmDomain,//
+                    ntlmHost, //
+                    useAbsoluteURI, //
+                    omitQuery);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Request.java b/client/src/main/java/org/asynchttpclient/Request.java
index 0bcf3ae71..9aab60469 100644
--- a/client/src/main/java/org/asynchttpclient/Request.java
+++ b/client/src/main/java/org/asynchttpclient/Request.java
@@ -19,11 +19,6 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.resolver.NameResolver;
-import org.asynchttpclient.channel.ChannelPoolPartitioning;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
 
 import java.io.File;
 import java.io.InputStream;
@@ -32,6 +27,12 @@
 import java.nio.charset.Charset;
 import java.util.List;
 
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
+
 /**
  * The Request class can be used to construct HTTP request:
  * <blockquote><pre>
@@ -46,138 +47,139 @@
  */
 public interface Request {
 
-  /**
-   * @return the request's HTTP method (GET, POST, etc.)
-   */
-  String getMethod();
-
-  /**
-   * @return the uri
-   */
-  Uri getUri();
-
-  /**
-   * @return the url (the uri's String form)
-   */
-  String getUrl();
-
-  /**
-   * @return the InetAddress to be used to bypass uri's hostname resolution
-   */
-  InetAddress getAddress();
-
-  /**
-   * @return the local address to bind from
-   */
-  InetAddress getLocalAddress();
-
-  /**
-   * @return the HTTP headers
-   */
-  HttpHeaders getHeaders();
-
-  /**
-   * @return the HTTP cookies
-   */
-  List<Cookie> getCookies();
-
-  /**
-   * @return the request's body byte array (only non null if it was set this way)
-   */
-  byte[] getByteData();
-
-  /**
-   * @return the request's body array of byte arrays (only non null if it was set this way)
-   */
-  List<byte[]> getCompositeByteData();
-
-  /**
-   * @return the request's body string (only non null if it was set this way)
-   */
-  String getStringData();
-
-  /**
-   * @return the request's body ByteBuffer (only non null if it was set this way)
-   */
-  ByteBuffer getByteBufferData();
-
-  /**
-   * @return the request's body InputStream (only non null if it was set this way)
-   */
-  InputStream getStreamData();
-
-  /**
-   * @return the request's body BodyGenerator (only non null if it was set this way)
-   */
-  BodyGenerator getBodyGenerator();
-
-  /**
-   * @return the request's form parameters
-   */
-  List<Param> getFormParams();
-
-  /**
-   * @return the multipart parts
-   */
-  List<Part> getBodyParts();
-
-  /**
-   * @return the virtual host to connect to
-   */
-  String getVirtualHost();
-
-  /**
-   * @return the query params resolved from the url/uri
-   */
-  List<Param> getQueryParams();
-
-  /**
-   * @return the proxy server to be used to perform this request (overrides the one defined in config)
-   */
-  ProxyServer getProxyServer();
-
-  /**
-   * @return the realm to be used to perform this request (overrides the one defined in config)
-   */
-  Realm getRealm();
-
-  /**
-   * @return the file to be uploaded
-   */
-  File getFile();
-
-  /**
-   * @return if this request is to follow redirects. Non null values means "override config value".
-   */
-  Boolean getFollowRedirect();
-
-  /**
-   * @return the request timeout. Non zero values means "override config value".
-   */
-  int getRequestTimeout();
-
-  /**
-   * @return the read timeout. Non zero values means "override config value".
-   */
-  int getReadTimeout();
-
-  /**
-   * @return the range header value, or 0 is not set.
-   */
-  long getRangeOffset();
-
-  /**
-   * @return the charset value used when decoding the request's body.
-   */
-  Charset getCharset();
-
-  /**
-   * @return the strategy to compute ChannelPool's keys
-   */
-  ChannelPoolPartitioning getChannelPoolPartitioning();
-
-  /**
-   * @return the NameResolver to be used to resolve hostnams's IP
-   */
-  NameResolver<InetAddress> getNameResolver();
+    /**
+     * @return the request's HTTP method (GET, POST, etc.)
+     */
+    String getMethod();
+
+    /**
+     * 
+     * @return the uri
+     */
+    Uri getUri();
+
+    /**
+     * @return the url (the uri's String form)
+     */
+    String getUrl();
+
+    /**
+     * @return the InetAddress to be used to bypass uri's hostname resolution
+     */
+    InetAddress getAddress();
+
+    /**
+     * @return the local address to bind from
+     */
+    InetAddress getLocalAddress();
+
+    /**
+     * @return the HTTP headers
+     */
+    HttpHeaders getHeaders();
+
+    /**
+     * @return the HTTP cookies
+     */
+    List<Cookie> getCookies();
+
+    /**
+     * @return the request's body byte array (only non null if it was set this way)
+     */
+    byte[] getByteData();
+
+    /**
+     * @return the request's body array of byte arrays (only non null if it was set this way)
+     */
+    List<byte[]> getCompositeByteData();
+    
+    /**
+     * @return the request's body string (only non null if it was set this way)
+     */
+    String getStringData();
+
+    /**
+     * @return the request's body ByteBuffer (only non null if it was set this way)
+     */
+    ByteBuffer getByteBufferData();
+
+    /**
+     * @return the request's body InputStream (only non null if it was set this way)
+     */
+    InputStream getStreamData();
+
+    /**
+     * @return the request's body BodyGenerator (only non null if it was set this way)
+     */
+    BodyGenerator getBodyGenerator();
+
+    /**
+     * @return the request's form parameters
+     */
+    List<Param> getFormParams();
+
+    /**
+     * @return the multipart parts
+     */
+    List<Part> getBodyParts();
+
+    /**
+     * @return the virtual host to connect to
+     */
+    String getVirtualHost();
+
+    /**
+     * @return the query params resolved from the url/uri
+     */
+    List<Param> getQueryParams();
+
+    /**
+     * @return the proxy server to be used to perform this request (overrides the one defined in config)
+     */
+    ProxyServer getProxyServer();
+
+    /**
+     * @return the realm to be used to perform this request (overrides the one defined in config)
+     */
+    Realm getRealm();
+
+    /**
+     * @return the file to be uploaded
+     */
+    File getFile();
+
+    /**
+     * @return if this request is to follow redirects. Non null values means "override config value".
+     */
+    Boolean getFollowRedirect();
+
+    /**
+     * @return the request timeout. Non zero values means "override config value".
+     */
+    int getRequestTimeout();
+
+    /**
+     * @return the read timeout. Non zero values means "override config value".
+     */
+    int getReadTimeout();
+
+    /**
+     * @return the range header value, or 0 is not set.
+     */
+    long getRangeOffset();
+
+    /**
+     * @return the charset value used when decoding the request's body.
+     */
+    Charset getCharset();
+
+    /**
+     * @return the strategy to compute ChannelPool's keys
+     */
+    ChannelPoolPartitioning getChannelPoolPartitioning();
+
+    /**
+     * @return the NameResolver to be used to resolve hostnams's IP
+     */
+    NameResolver<InetAddress> getNameResolver();
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilder.java b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
index ad0a14149..47b7e2da3 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -23,27 +23,27 @@
  */
 public class RequestBuilder extends RequestBuilderBase<RequestBuilder> {
 
-  public RequestBuilder() {
-    this(GET);
-  }
+    public RequestBuilder() {
+        this(GET);
+    }
 
-  public RequestBuilder(String method) {
-    this(method, false);
-  }
+    public RequestBuilder(String method) {
+        this(method, false);
+    }
 
-  public RequestBuilder(String method, boolean disableUrlEncoding) {
-    super(method, disableUrlEncoding);
-  }
+    public RequestBuilder(String method, boolean disableUrlEncoding) {
+        super(method, disableUrlEncoding);
+    }
 
-  public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
-    super(method, disableUrlEncoding, validateHeaders);
-  }
+    public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(method, disableUrlEncoding, validateHeaders);
+    }
 
-  public RequestBuilder(Request prototype) {
-    super(prototype);
-  }
+    public RequestBuilder(Request prototype) {
+        super(prototype);
+    }
 
-  public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
-    super(prototype, disableUrlEncoding, validateHeaders);
-  }
+    public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(prototype, disableUrlEncoding, validateHeaders);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index 0fa5b63a4..b012bc177 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -15,6 +15,9 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -22,6 +25,18 @@
 import io.netty.resolver.DefaultNameResolver;
 import io.netty.resolver.NameResolver;
 import io.netty.util.concurrent.ImmediateEventExecutor;
+
+import java.io.File;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -33,615 +48,610 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.File;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.*;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.util.HttpUtils.extractCharset;
-import static org.asynchttpclient.util.HttpUtils.validateSupportedScheme;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.MiscUtils.withDefault;
-
 /**
  * Builder for {@link Request}
- *
+ * 
  * @param <T> the builder type
  */
 public abstract class RequestBuilderBase<T extends RequestBuilderBase<T>> {
 
-  private final static Logger LOGGER = LoggerFactory.getLogger(RequestBuilderBase.class);
-  private static final Uri DEFAULT_REQUEST_URL = Uri.create("http://localhost");
-  public static NameResolver<InetAddress> DEFAULT_NAME_RESOLVER = new DefaultNameResolver(ImmediateEventExecutor.INSTANCE);
-  // builder only fields
-  protected UriEncoder uriEncoder;
-  protected List<Param> queryParams;
-  protected SignatureCalculator signatureCalculator;
-
-  // request fields
-  protected String method;
-  protected Uri uri;
-  protected InetAddress address;
-  protected InetAddress localAddress;
-  protected HttpHeaders headers;
-  protected ArrayList<Cookie> cookies;
-  protected byte[] byteData;
-  protected List<byte[]> compositeByteData;
-  protected String stringData;
-  protected ByteBuffer byteBufferData;
-  protected InputStream streamData;
-  protected BodyGenerator bodyGenerator;
-  protected List<Param> formParams;
-  protected List<Part> bodyParts;
-  protected String virtualHost;
-  protected ProxyServer proxyServer;
-  protected Realm realm;
-  protected File file;
-  protected Boolean followRedirect;
-  protected int requestTimeout;
-  protected int readTimeout;
-  protected long rangeOffset;
-  protected Charset charset;
-  protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
-  protected NameResolver<InetAddress> nameResolver = DEFAULT_NAME_RESOLVER;
-
-  protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
-    this(method, disableUrlEncoding, true);
-  }
-
-  protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
-    this.method = method;
-    this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
-    this.headers = new DefaultHttpHeaders(validateHeaders);
-  }
-
-  protected RequestBuilderBase(Request prototype) {
-    this(prototype, false, false);
-  }
-
-  protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
-    this.method = prototype.getMethod();
-    this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
-    this.uri = prototype.getUri();
-    this.address = prototype.getAddress();
-    this.localAddress = prototype.getLocalAddress();
-    this.headers = new DefaultHttpHeaders(validateHeaders);
-    this.headers.add(prototype.getHeaders());
-    if (isNonEmpty(prototype.getCookies())) {
-      this.cookies = new ArrayList<>(prototype.getCookies());
-    }
-    this.byteData = prototype.getByteData();
-    this.compositeByteData = prototype.getCompositeByteData();
-    this.stringData = prototype.getStringData();
-    this.byteBufferData = prototype.getByteBufferData();
-    this.streamData = prototype.getStreamData();
-    this.bodyGenerator = prototype.getBodyGenerator();
-    if (isNonEmpty(prototype.getFormParams())) {
-      this.formParams = new ArrayList<>(prototype.getFormParams());
-    }
-    if (isNonEmpty(prototype.getBodyParts())) {
-      this.bodyParts = new ArrayList<>(prototype.getBodyParts());
-    }
-    this.virtualHost = prototype.getVirtualHost();
-    this.proxyServer = prototype.getProxyServer();
-    this.realm = prototype.getRealm();
-    this.file = prototype.getFile();
-    this.followRedirect = prototype.getFollowRedirect();
-    this.requestTimeout = prototype.getRequestTimeout();
-    this.rangeOffset = prototype.getRangeOffset();
-    this.charset = prototype.getCharset();
-    this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
-    this.nameResolver = prototype.getNameResolver();
-  }
-
-  @SuppressWarnings("unchecked")
-  private T asDerivedType() {
-    return (T) this;
-  }
-
-  public T setUrl(String url) {
-    return setUri(Uri.create(url));
-  }
-
-  public T setUri(Uri uri) {
-    this.uri = uri;
-    return asDerivedType();
-  }
-
-  public T setAddress(InetAddress address) {
-    this.address = address;
-    return asDerivedType();
-  }
-
-  public T setLocalAddress(InetAddress address) {
-    this.localAddress = address;
-    return asDerivedType();
-  }
-
-  public T setVirtualHost(String virtualHost) {
-    this.virtualHost = virtualHost;
-    return asDerivedType();
-  }
-
-  /**
-   * Remove all added headers
-   *
-   * @return {@code this}
-   */
-  public T clearHeaders() {
-    this.headers.clear();
-    return asDerivedType();
-  }
-
-  /**
-   * @param name  header name
-   * @param value header value to set
-   * @return {@code this}
-   * @see #setHeader(CharSequence, Object)
-   */
-  public T setHeader(CharSequence name, String value) {
-    return setHeader(name, (Object) value);
-  }
-
-  /**
-   * Set uni-value header for the request
-   *
-   * @param name  header name
-   * @param value header value to set
-   * @return {@code this}
-   */
-  public T setHeader(CharSequence name, Object value) {
-    this.headers.set(name, value);
-    return asDerivedType();
-  }
-
-  /**
-   * Set multi-values header for the request
-   *
-   * @param name   header name
-   * @param values {@code Iterable} with multiple header values to set
-   * @return {@code this}
-   */
-  public T setHeader(CharSequence name, Iterable<?> values) {
-    this.headers.set(name, values);
-    return asDerivedType();
-  }
-
-  /**
-   * @param name  header name
-   * @param value header value to add
-   * @return {@code this}
-   * @see #addHeader(CharSequence, Object)
-   */
-  public T addHeader(CharSequence name, String value) {
-    return addHeader(name, (Object) value);
-  }
-
-  /**
-   * Add a header value for the request. If a header with {@code name} was setup for this request already -
-   * call will add one more header value and convert it to multi-value header
-   *
-   * @param name  header name
-   * @param value header value to add
-   * @return {@code this}
-   */
-  public T addHeader(CharSequence name, Object value) {
-    if (value == null) {
-      LOGGER.warn("Value was null, set to \"\"");
-      value = "";
-    }
-
-    this.headers.add(name, value);
-    return asDerivedType();
-  }
-
-  /**
-   * Add header values for the request. If a header with {@code name} was setup for this request already -
-   * call will add more header values and convert it to multi-value header
-   *
-   * @param name   header name
-   * @param values {@code Iterable} with multiple header values to add
-   * @return {@code}
-   */
-  public T addHeader(CharSequence name, Iterable<?> values) {
-    this.headers.add(name, values);
-    return asDerivedType();
-  }
-
-  public T setHeaders(HttpHeaders headers) {
-    if (headers == null)
-      this.headers.clear();
-    else
-      this.headers = headers;
-    return asDerivedType();
-  }
-
-  /**
-   * Set request headers using a map {@code headers} of pair (Header name, Header values)
-   * This method could be used to setup multi-valued headers
-   *
-   * @param headers map of header names as the map keys and header values {@link Iterable} as the map values
-   * @return {@code this}
-   */
-  public T setHeaders(Map<CharSequence, ? extends Iterable<?>> headers) {
-    clearHeaders();
-    if (headers != null) {
-      headers.forEach((name, values) -> this.headers.add(name, values));
-    }
-    return asDerivedType();
-  }
-
-  /**
-   * Set single-value request headers using a map {@code headers} of pairs (Header name, Header value).
-   * To set headers with multiple values use {@link #setHeaders(Map)}
-   *
-   * @param headers map of header names as the map keys and header values as the map values
-   * @return {@code this}
-   */
-  public T setSingleHeaders(Map<CharSequence, ?> headers) {
-    clearHeaders();
-    if (headers != null) {
-      headers.forEach((name, value) -> this.headers.add(name, value));
-    }
-    return asDerivedType();
-  }
-
-  private void lazyInitCookies() {
-    if (this.cookies == null)
-      this.cookies = new ArrayList<>(3);
-  }
-
-  public T setCookies(Collection<Cookie> cookies) {
-    this.cookies = new ArrayList<>(cookies);
-    return asDerivedType();
-  }
-
-  public T addCookie(Cookie cookie) {
-    lazyInitCookies();
-    this.cookies.add(cookie);
-    return asDerivedType();
-  }
-
-  /**
-   * Add/replace a cookie based on its name
-   * @param cookie the new cookie
-   * @return this
-   */
-  public T addOrReplaceCookie(Cookie cookie) {
-    String cookieKey = cookie.name();
-    boolean replace = false;
-    int index = 0;
-    lazyInitCookies();
-    for (Cookie c : this.cookies) {
-      if (c.name().equals(cookieKey)) {
-        replace = true;
-        break;
-      }
-
-      index++;
-    }
-    if (replace)
-      this.cookies.set(index, cookie);
-    else
-      this.cookies.add(cookie);
-    return asDerivedType();
-  }
-
-  public void resetCookies() {
-    if (this.cookies != null)
-      this.cookies.clear();
-  }
-
-  public void resetQuery() {
-    queryParams = null;
-    if (this.uri != null)
-      this.uri = this.uri.withNewQuery(null);
-  }
-
-  public void resetFormParams() {
-    this.formParams = null;
-  }
-
-  public void resetNonMultipartData() {
-    this.byteData = null;
-    this.compositeByteData = null;
-    this.byteBufferData = null;
-    this.stringData = null;
-    this.streamData = null;
-    this.bodyGenerator = null;
-  }
-
-  public void resetMultipartData() {
-    this.bodyParts = null;
-  }
-
-  public T setBody(File file) {
-    this.file = file;
-    return asDerivedType();
-  }
-
-  private void resetBody() {
-    resetFormParams();
-    resetNonMultipartData();
-    resetMultipartData();
-  }
-
-  public T setBody(byte[] data) {
-    resetBody();
-    this.byteData = data;
-    return asDerivedType();
-  }
-
-  public T setBody(List<byte[]> data) {
-    resetBody();
-    this.compositeByteData = data;
-    return asDerivedType();
-  }
-
-  public T setBody(String data) {
-    resetBody();
-    this.stringData = data;
-    return asDerivedType();
-  }
-
-  public T setBody(ByteBuffer data) {
-    resetBody();
-    this.byteBufferData = data;
-    return asDerivedType();
-  }
-
-  public T setBody(InputStream stream) {
-    resetBody();
-    this.streamData = stream;
-    return asDerivedType();
-  }
-
-  public T setBody(Publisher<ByteBuf> publisher) {
-    return setBody(publisher, -1L);
-  }
-
-  public T setBody(Publisher<ByteBuf> publisher, long contentLength) {
-    return setBody(new ReactiveStreamsBodyGenerator(publisher, contentLength));
-  }
-
-  public T setBody(BodyGenerator bodyGenerator) {
-    this.bodyGenerator = bodyGenerator;
-    return asDerivedType();
-  }
-
-  public T addQueryParam(String name, String value) {
-    if (queryParams == null)
-      queryParams = new ArrayList<>(1);
-    queryParams.add(new Param(name, value));
-    return asDerivedType();
-  }
-
-  public T addQueryParams(List<Param> params) {
-    if (queryParams == null)
-      queryParams = params;
-    else
-      queryParams.addAll(params);
-    return asDerivedType();
-  }
-
-  public T setQueryParams(Map<String, List<String>> map) {
-    return setQueryParams(Param.map2ParamList(map));
-  }
-
-  public T setQueryParams(List<Param> params) {
-    // reset existing query
-    if (this.uri != null && isNonEmpty(this.uri.getQuery()))
-      this.uri = this.uri.withNewQuery(null);
-    queryParams = params;
-    return asDerivedType();
-  }
-
-  public T addFormParam(String name, String value) {
-    resetNonMultipartData();
-    resetMultipartData();
-    if (this.formParams == null)
-      this.formParams = new ArrayList<>(1);
-    this.formParams.add(new Param(name, value));
-    return asDerivedType();
-  }
-
-  public T setFormParams(Map<String, List<String>> map) {
-    return setFormParams(Param.map2ParamList(map));
-  }
-
-  public T setFormParams(List<Param> params) {
-    resetNonMultipartData();
-    resetMultipartData();
-    this.formParams = params;
-    return asDerivedType();
-  }
-
-  public T addBodyPart(Part bodyPart) {
-    resetFormParams();
-    resetNonMultipartData();
-    if (this.bodyParts == null)
-      this.bodyParts = new ArrayList<>();
-    this.bodyParts.add(bodyPart);
-    return asDerivedType();
-  }
-
-  public T setBodyParts(List<Part> bodyParts) {
-    this.bodyParts = new ArrayList<>(bodyParts);
-    return asDerivedType();
-  }
-
-  public T setProxyServer(ProxyServer proxyServer) {
-    this.proxyServer = proxyServer;
-    return asDerivedType();
-  }
-
-  public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-    this.proxyServer = proxyServerBuilder.build();
-    return asDerivedType();
-  }
-
-  public T setRealm(Realm.Builder realm) {
-    this.realm = realm.build();
-    return asDerivedType();
-  }
-
-  public T setRealm(Realm realm) {
-    this.realm = realm;
-    return asDerivedType();
-  }
-
-  public T setFollowRedirect(boolean followRedirect) {
-    this.followRedirect = followRedirect;
-    return asDerivedType();
-  }
-
-  public T setRequestTimeout(int requestTimeout) {
-    this.requestTimeout = requestTimeout;
-    return asDerivedType();
-  }
-
-  public T setReadTimeout(int readTimeout) {
-    this.readTimeout = readTimeout;
-    return asDerivedType();
-  }
-
-  public T setRangeOffset(long rangeOffset) {
-    this.rangeOffset = rangeOffset;
-    return asDerivedType();
-  }
-
-  public T setMethod(String method) {
-    this.method = method;
-    return asDerivedType();
-  }
-
-  public T setCharset(Charset charset) {
-    this.charset = charset;
-    return asDerivedType();
-  }
-
-  public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
-    this.channelPoolPartitioning = channelPoolPartitioning;
-    return asDerivedType();
-  }
-
-  public T setNameResolver(NameResolver<InetAddress> nameResolver) {
-    this.nameResolver = nameResolver;
-    return asDerivedType();
-  }
-
-  public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
-    this.signatureCalculator = signatureCalculator;
-    return asDerivedType();
-  }
-
-  private RequestBuilderBase<?> executeSignatureCalculator() {
-    if (signatureCalculator == null)
-      return this;
-
-    // build a first version of the request, without signatureCalculator in play
-    RequestBuilder rb = new RequestBuilder(this.method);
-    // make copy of mutable collections so we don't risk affecting
-    // original RequestBuilder
-    // call setFormParams first as it resets other fields
-    if (this.formParams != null)
-      rb.setFormParams(this.formParams);
-    if (this.headers != null)
-      rb.headers.add(this.headers);
-    if (this.cookies != null)
-      rb.setCookies(this.cookies);
-    if (this.bodyParts != null)
-      rb.setBodyParts(this.bodyParts);
-
-    // copy all other fields
-    // but rb.signatureCalculator, that's the whole point here
-    rb.uriEncoder = this.uriEncoder;
-    rb.queryParams = this.queryParams;
-    rb.uri = this.uri;
-    rb.address = this.address;
-    rb.localAddress = this.localAddress;
-    rb.byteData = this.byteData;
-    rb.compositeByteData = this.compositeByteData;
-    rb.stringData = this.stringData;
-    rb.byteBufferData = this.byteBufferData;
-    rb.streamData = this.streamData;
-    rb.bodyGenerator = this.bodyGenerator;
-    rb.virtualHost = this.virtualHost;
-    rb.proxyServer = this.proxyServer;
-    rb.realm = this.realm;
-    rb.file = this.file;
-    rb.followRedirect = this.followRedirect;
-    rb.requestTimeout = this.requestTimeout;
-    rb.rangeOffset = this.rangeOffset;
-    rb.charset = this.charset;
-    rb.channelPoolPartitioning = this.channelPoolPartitioning;
-    rb.nameResolver = this.nameResolver;
-    Request unsignedRequest = rb.build();
-    signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
-    return rb;
-  }
-
-  private void updateCharset() {
-    String contentTypeHeader = headers.get(CONTENT_TYPE);
-    Charset contentTypeCharset = extractCharset(contentTypeHeader);
-    charset = withDefault(contentTypeCharset, withDefault(charset, UTF_8));
-    if (contentTypeHeader != null && contentTypeHeader.regionMatches(true, 0, "text/", 0, 5) && contentTypeCharset == null) {
-      // add explicit charset to content-type header
-      headers.set(CONTENT_TYPE, contentTypeHeader + "; charset=" + charset.name());
-    }
-  }
-
-  private Uri computeUri() {
-
-    Uri tempUri = this.uri;
-    if (tempUri == null) {
-      LOGGER.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
-      tempUri = DEFAULT_REQUEST_URL;
-    } else {
-      validateSupportedScheme(tempUri);
-    }
-
-    return uriEncoder.encode(tempUri, queryParams);
-  }
-
-  public Request build() {
-    updateCharset();
-    RequestBuilderBase<?> rb = executeSignatureCalculator();
-    Uri finalUri = rb.computeUri();
-
-    // make copies of mutable internal collections
-    List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
-    List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
-    List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
-
-    return new DefaultRequest(rb.method,
-            finalUri,
-            rb.address,
-            rb.localAddress,
-            rb.headers,
-            cookiesCopy,
-            rb.byteData,
-            rb.compositeByteData,
-            rb.stringData,
-            rb.byteBufferData,
-            rb.streamData,
-            rb.bodyGenerator,
-            formParamsCopy,
-            bodyPartsCopy,
-            rb.virtualHost,
-            rb.proxyServer,
-            rb.realm,
-            rb.file,
-            rb.followRedirect,
-            rb.requestTimeout,
-            rb.readTimeout,
-            rb.rangeOffset,
-            rb.charset,
-            rb.channelPoolPartitioning,
-            rb.nameResolver);
-  }
+    public static NameResolver<InetAddress> DEFAULT_NAME_RESOLVER = new DefaultNameResolver(ImmediateEventExecutor.INSTANCE);
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(RequestBuilderBase.class);
+
+    private static final Uri DEFAULT_REQUEST_URL = Uri.create("http://localhost");
+
+    // builder only fields
+    protected UriEncoder uriEncoder;
+    protected List<Param> queryParams;
+    protected SignatureCalculator signatureCalculator;
+
+    // request fields
+    protected String method;
+    protected Uri uri;
+    protected InetAddress address;
+    protected InetAddress localAddress;
+    protected HttpHeaders headers;
+    protected ArrayList<Cookie> cookies;
+    protected byte[] byteData;
+    protected List<byte[]> compositeByteData;
+    protected String stringData;
+    protected ByteBuffer byteBufferData;
+    protected InputStream streamData;
+    protected BodyGenerator bodyGenerator;
+    protected List<Param> formParams;
+    protected List<Part> bodyParts;
+    protected String virtualHost;
+    protected ProxyServer proxyServer;
+    protected Realm realm;
+    protected File file;
+    protected Boolean followRedirect;
+    protected int requestTimeout;
+    protected int readTimeout;
+    protected long rangeOffset;
+    protected Charset charset;
+    protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
+    protected NameResolver<InetAddress> nameResolver = DEFAULT_NAME_RESOLVER;
+
+    protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
+        this(method, disableUrlEncoding, true);
+    }
+
+    protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+        this.method = method;
+        this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+        this.headers = new DefaultHttpHeaders(validateHeaders);
+    }
+
+    protected RequestBuilderBase(Request prototype) {
+        this(prototype, false, false);
+    }
+
+    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+        this.method = prototype.getMethod();
+        this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+        this.uri = prototype.getUri();
+        this.address = prototype.getAddress();
+        this.localAddress = prototype.getLocalAddress();
+        this.headers = new DefaultHttpHeaders(validateHeaders);
+        this.headers.add(prototype.getHeaders());
+        if (isNonEmpty(prototype.getCookies())) {
+            this.cookies = new ArrayList<>(prototype.getCookies());
+        }
+        this.byteData = prototype.getByteData();
+        this.compositeByteData = prototype.getCompositeByteData();
+        this.stringData = prototype.getStringData();
+        this.byteBufferData = prototype.getByteBufferData();
+        this.streamData = prototype.getStreamData();
+        this.bodyGenerator = prototype.getBodyGenerator();
+        if (isNonEmpty(prototype.getFormParams())) {
+            this.formParams = new ArrayList<>(prototype.getFormParams());
+        }
+        if (isNonEmpty(prototype.getBodyParts())) {
+            this.bodyParts = new ArrayList<>(prototype.getBodyParts());
+        }
+        this.virtualHost = prototype.getVirtualHost();
+        this.proxyServer = prototype.getProxyServer();
+        this.realm = prototype.getRealm();
+        this.file = prototype.getFile();
+        this.followRedirect = prototype.getFollowRedirect();
+        this.requestTimeout = prototype.getRequestTimeout();
+        this.rangeOffset = prototype.getRangeOffset();
+        this.charset = prototype.getCharset();
+        this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
+        this.nameResolver = prototype.getNameResolver();
+    }
+
+    @SuppressWarnings("unchecked")
+    private T asDerivedType() {
+        return (T) this;
+    }
+
+    public T setUrl(String url) {
+        return setUri(Uri.create(url));
+    }
+
+    public T setUri(Uri uri) {
+        this.uri = uri;
+        return asDerivedType();
+    }
+
+    public T setAddress(InetAddress address) {
+        this.address = address;
+        return asDerivedType();
+    }
+
+    public T setLocalAddress(InetAddress address) {
+        this.localAddress = address;
+        return asDerivedType();
+    }
+
+    public T setVirtualHost(String virtualHost) {
+        this.virtualHost = virtualHost;
+        return asDerivedType();
+    }
+
+    /**
+     * Remove all added headers
+     *
+     * @return {@code this}
+     */
+    public T clearHeaders() {
+        this.headers.clear();
+        return asDerivedType();
+    }
+
+    /**
+     * @param name header name
+     * @param value header value to set
+     * @return {@code this}
+     * @see #setHeader(CharSequence, Object)
+     */
+    public T setHeader(CharSequence name, String value) {
+        return setHeader(name, (Object) value);
+    }
+
+    /**
+     * Set uni-value header for the request
+     *
+     * @param name header name
+     * @param value header value to set
+     * @return {@code this}
+     */
+    public T setHeader(CharSequence name, Object value) {
+        this.headers.set(name, value);
+        return asDerivedType();
+    }
+
+    /**
+     * Set multi-values header for the request
+     *
+     * @param name header name
+     * @param values {@code Iterable} with multiple header values to set
+     * @return {@code this}
+     */
+    public T setHeader(CharSequence name, Iterable<?> values) {
+        this.headers.set(name, values);
+        return asDerivedType();
+    }
+
+    /**
+     * @param name header name
+     * @param value header value to add
+     * @return {@code this}
+     * @see #addHeader(CharSequence, Object)
+     */
+    public T addHeader(CharSequence name, String value) {
+        return addHeader(name, (Object) value);
+    }
+
+    /**
+     * Add a header value for the request. If a header with {@code name} was setup for this request already -
+     * call will add one more header value and convert it to multi-value header
+     *
+     * @param name header name
+     * @param value header value to add
+     * @return {@code this}
+     */
+    public T addHeader(CharSequence name, Object value) {
+        if (value == null) {
+            LOGGER.warn("Value was null, set to \"\"");
+            value = "";
+        }
+
+        this.headers.add(name, value);
+        return asDerivedType();
+    }
+
+    /**
+     * Add header values for the request. If a header with {@code name} was setup for this request already -
+     * call will add more header values and convert it to multi-value header
+     *
+     * @param name header name
+     * @param values {@code Iterable} with multiple header values to add
+     * @return {@code}
+     */
+    public T addHeader(CharSequence name, Iterable<?> values) {
+        this.headers.add(name, values);
+        return asDerivedType();
+    }
+
+    public T setHeaders(HttpHeaders headers) {
+        if (headers == null)
+            this.headers.clear();
+        else
+            this.headers = headers;
+        return asDerivedType();
+    }
+
+    /**
+     * Set request headers using a map {@code headers} of pair (Header name, Header values)
+     * This method could be used to setup multi-valued headers
+     *
+     * @param headers map of header names as the map keys and header values {@link Iterable} as the map values
+     * @return {@code this}
+     */
+    public T setHeaders(Map<CharSequence, ? extends Iterable<?>> headers) {
+        clearHeaders();
+        if (headers != null) {
+            headers.forEach((name, values) -> this.headers.add(name, values));
+        }
+        return asDerivedType();
+    }
+
+    /**
+     * Set single-value request headers using a map {@code headers} of pairs (Header name, Header value).
+     * To set headers with multiple values use {@link #setHeaders(Map)}
+     *
+     * @param headers map of header names as the map keys and header values as the map values
+     * @return {@code this}
+     */
+    public T setSingleHeaders(Map<CharSequence, ?> headers) {
+        clearHeaders();
+        if (headers != null) {
+            headers.forEach((name, value) -> this.headers.add(name, value));
+        }
+        return asDerivedType();
+    }
+
+    private void lazyInitCookies() {
+        if (this.cookies == null)
+            this.cookies = new ArrayList<>(3);
+    }
+
+    public T setCookies(Collection<Cookie> cookies) {
+        this.cookies = new ArrayList<>(cookies);
+        return asDerivedType();
+    }
+
+    public T addCookie(Cookie cookie) {
+        lazyInitCookies();
+        this.cookies.add(cookie);
+        return asDerivedType();
+    }
+
+    public T addOrReplaceCookie(Cookie cookie) {
+        String cookieKey = cookie.name();
+        boolean replace = false;
+        int index = 0;
+        lazyInitCookies();
+        for (Cookie c : this.cookies) {
+            if (c.name().equals(cookieKey)) {
+                replace = true;
+                break;
+            }
+
+            index++;
+        }
+        if (replace)
+            this.cookies.set(index, cookie);
+        else
+            this.cookies.add(cookie);
+        return asDerivedType();
+    }
+
+    public void resetCookies() {
+        if (this.cookies != null)
+            this.cookies.clear();
+    }
+
+    public void resetQuery() {
+        queryParams = null;
+        if (this.uri != null)
+            this.uri = this.uri.withNewQuery(null);
+    }
+
+    public void resetFormParams() {
+        this.formParams = null;
+    }
+
+    public void resetNonMultipartData() {
+        this.byteData = null;
+        this.compositeByteData = null;
+        this.byteBufferData = null;
+        this.stringData = null;
+        this.streamData = null;
+        this.bodyGenerator = null;
+    }
+
+    public void resetMultipartData() {
+        this.bodyParts = null;
+    }
+
+    public T setBody(File file) {
+        this.file = file;
+        return asDerivedType();
+    }
+
+    private void resetBody() {
+        resetFormParams();
+        resetNonMultipartData();
+        resetMultipartData();
+    }
+
+    public T setBody(byte[] data) {
+        resetBody();
+        this.byteData = data;
+        return asDerivedType();
+    }
+
+    public T setBody(List<byte[]> data) {
+        resetBody();
+        this.compositeByteData = data;
+        return asDerivedType();
+    }
+
+    public T setBody(String data) {
+        resetBody();
+        this.stringData = data;
+        return asDerivedType();
+    }
+
+    public T setBody(ByteBuffer data) {
+        resetBody();
+        this.byteBufferData = data;
+        return asDerivedType();
+    }
+
+    public T setBody(InputStream stream) {
+        resetBody();
+        this.streamData = stream;
+        return asDerivedType();
+    }
+
+    public T setBody(Publisher<ByteBuf> publisher) {
+        return setBody(publisher, -1L);
+    }
+
+    public T setBody(Publisher<ByteBuf> publisher, long contentLength) {
+        return setBody(new ReactiveStreamsBodyGenerator(publisher, contentLength));
+    }
+
+    public T setBody(BodyGenerator bodyGenerator) {
+        this.bodyGenerator = bodyGenerator;
+        return asDerivedType();
+    }
+
+    public T addQueryParam(String name, String value) {
+        if (queryParams == null)
+            queryParams = new ArrayList<>(1);
+        queryParams.add(new Param(name, value));
+        return asDerivedType();
+    }
+
+    public T addQueryParams(List<Param> params) {
+        if (queryParams == null)
+            queryParams = params;
+        else
+            queryParams.addAll(params);
+        return asDerivedType();
+    }
+
+    public T setQueryParams(Map<String, List<String>> map) {
+        return setQueryParams(Param.map2ParamList(map));
+    }
+
+    public T setQueryParams(List<Param> params) {
+        // reset existing query
+        if (this.uri != null && isNonEmpty(this.uri.getQuery()))
+            this.uri = this.uri.withNewQuery(null);
+        queryParams = params;
+        return asDerivedType();
+    }
+
+    public T addFormParam(String name, String value) {
+        resetNonMultipartData();
+        resetMultipartData();
+        if (this.formParams == null)
+            this.formParams = new ArrayList<>(1);
+        this.formParams.add(new Param(name, value));
+        return asDerivedType();
+    }
+
+    public T setFormParams(Map<String, List<String>> map) {
+        return setFormParams(Param.map2ParamList(map));
+    }
+
+    public T setFormParams(List<Param> params) {
+        resetNonMultipartData();
+        resetMultipartData();
+        this.formParams = params;
+        return asDerivedType();
+    }
+
+    public T addBodyPart(Part bodyPart) {
+        resetFormParams();
+        resetNonMultipartData();
+        if (this.bodyParts == null)
+            this.bodyParts = new ArrayList<>();
+        this.bodyParts.add(bodyPart);
+        return asDerivedType();
+    }
+
+    public T setBodyParts(List<Part> bodyParts) {
+        this.bodyParts = new ArrayList<>(bodyParts);
+        return asDerivedType();
+    }
+
+    public T setProxyServer(ProxyServer proxyServer) {
+        this.proxyServer = proxyServer;
+        return asDerivedType();
+    }
+
+    public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+        this.proxyServer = proxyServerBuilder.build();
+        return asDerivedType();
+    }
+
+    public T setRealm(Realm.Builder realm) {
+        this.realm = realm.build();
+        return asDerivedType();
+    }
+
+    public T setRealm(Realm realm) {
+        this.realm = realm;
+        return asDerivedType();
+    }
+
+    public T setFollowRedirect(boolean followRedirect) {
+        this.followRedirect = followRedirect;
+        return asDerivedType();
+    }
+
+    public T setRequestTimeout(int requestTimeout) {
+        this.requestTimeout = requestTimeout;
+        return asDerivedType();
+    }
+
+    public T setReadTimeout(int readTimeout) {
+        this.readTimeout = readTimeout;
+        return asDerivedType();
+    }
+
+    public T setRangeOffset(long rangeOffset) {
+        this.rangeOffset = rangeOffset;
+        return asDerivedType();
+    }
+
+    public T setMethod(String method) {
+        this.method = method;
+        return asDerivedType();
+    }
+
+    public T setCharset(Charset charset) {
+        this.charset = charset;
+        return asDerivedType();
+    }
+
+    public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
+        this.channelPoolPartitioning = channelPoolPartitioning;
+        return asDerivedType();
+    }
+
+    public T setNameResolver(NameResolver<InetAddress> nameResolver) {
+        this.nameResolver = nameResolver;
+        return asDerivedType();
+    }
+
+    public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        this.signatureCalculator = signatureCalculator;
+        return asDerivedType();
+    }
+
+    private RequestBuilderBase<?> executeSignatureCalculator() {
+        if (signatureCalculator == null)
+            return this;
+
+        // build a first version of the request, without signatureCalculator in play
+        RequestBuilder rb = new RequestBuilder(this.method);
+        // make copy of mutable collections so we don't risk affecting
+        // original RequestBuilder
+        // call setFormParams first as it resets other fields
+        if (this.formParams != null)
+            rb.setFormParams(this.formParams);
+        if (this.headers != null)
+            rb.headers.add(this.headers);
+        if (this.cookies != null)
+            rb.setCookies(this.cookies);
+        if (this.bodyParts != null)
+            rb.setBodyParts(this.bodyParts);
+
+        // copy all other fields
+        // but rb.signatureCalculator, that's the whole point here
+        rb.uriEncoder = this.uriEncoder;
+        rb.queryParams = this.queryParams;
+        rb.uri = this.uri;
+        rb.address = this.address;
+        rb.localAddress = this.localAddress;
+        rb.byteData = this.byteData;
+        rb.compositeByteData = this.compositeByteData;
+        rb.stringData = this.stringData;
+        rb.byteBufferData = this.byteBufferData;
+        rb.streamData = this.streamData;
+        rb.bodyGenerator = this.bodyGenerator;
+        rb.virtualHost = this.virtualHost;
+        rb.proxyServer = this.proxyServer;
+        rb.realm = this.realm;
+        rb.file = this.file;
+        rb.followRedirect = this.followRedirect;
+        rb.requestTimeout = this.requestTimeout;
+        rb.rangeOffset = this.rangeOffset;
+        rb.charset = this.charset;
+        rb.channelPoolPartitioning = this.channelPoolPartitioning;
+        rb.nameResolver = this.nameResolver;
+        Request unsignedRequest = rb.build();
+        signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
+        return rb;
+    }
+
+    private Charset computeCharset() {
+        if (this.charset == null) {
+            try {
+                final String contentType = this.headers.get(CONTENT_TYPE);
+                if (contentType != null) {
+                    final Charset charset = parseCharset(contentType);
+                    if (charset != null) {
+                        // ensure that if charset is provided with the
+                        // Content-Type header,
+                        // we propagate that down to the charset of the Request
+                        // object
+                        return charset;
+                    }
+                }
+            } catch (Throwable e) {
+                // NoOp -- we can't fix the Content-Type or charset from here
+            }
+        }
+        return this.charset;
+    }
+
+    private Uri computeUri() {
+
+        Uri tempUri = this.uri;
+        if (tempUri == null) {
+            LOGGER.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
+            tempUri = DEFAULT_REQUEST_URL;
+        } else {
+            validateSupportedScheme(tempUri);
+        }
+
+        return uriEncoder.encode(tempUri, queryParams);
+    }
+
+    public Request build() {
+        RequestBuilderBase<?> rb = executeSignatureCalculator();
+        Uri finalUri = rb.computeUri();
+        Charset finalCharset = rb.computeCharset();
+
+        // make copies of mutable internal collections
+        List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
+        List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
+        List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
+
+        return new DefaultRequest(rb.method,//
+                finalUri,//
+                rb.address,//
+                rb.localAddress,//
+                rb.headers,//
+                cookiesCopy,//
+                rb.byteData,//
+                rb.compositeByteData,//
+                rb.stringData,//
+                rb.byteBufferData,//
+                rb.streamData,//
+                rb.bodyGenerator,//
+                formParamsCopy,//
+                bodyPartsCopy,//
+                rb.virtualHost,//
+                rb.proxyServer,//
+                rb.realm,//
+                rb.file,//
+                rb.followRedirect,//
+                rb.requestTimeout,//
+                rb.readTimeout,//
+                rb.rangeOffset,//
+                finalCharset,//
+                rb.channelPoolPartitioning,//
+                rb.nameResolver);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Response.java b/client/src/main/java/org/asynchttpclient/Response.java
index f3bc6e3a9..ba97ae73e 100644
--- a/client/src/main/java/org/asynchttpclient/Response.java
+++ b/client/src/main/java/org/asynchttpclient/Response.java
@@ -18,8 +18,6 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.netty.NettyResponse;
-import org.asynchttpclient.uri.Uri;
 
 import java.io.InputStream;
 import java.net.SocketAddress;
@@ -28,183 +26,190 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.asynchttpclient.netty.NettyResponse;
+import org.asynchttpclient.uri.Uri;
+
 /**
  * Represents the asynchronous HTTP response callback for an {@link AsyncCompletionHandler}
  */
 public interface Response {
-  /**
-   * Returns the status code for the request.
-   *
-   * @return The status code
-   */
-  int getStatusCode();
-
-  /**
-   * Returns the status text for the request.
-   *
-   * @return The status text
-   */
-  String getStatusText();
-
-  /**
-   * Return the entire response body as a byte[].
-   *
-   * @return the entire response body as a byte[].
-   */
-  byte[] getResponseBodyAsBytes();
-
-  /**
-   * Return the entire response body as a ByteBuffer.
-   *
-   * @return the entire response body as a ByteBuffer.
-   */
-  ByteBuffer getResponseBodyAsByteBuffer();
-
-  /**
-   * Returns an input stream for the response body. Note that you should not try to get this more than once, and that you should not close the stream.
-   *
-   * @return The input stream
-   */
-  InputStream getResponseBodyAsStream();
-
-  /**
-   * Return the entire response body as a String.
-   *
-   * @param charset the charset to use when decoding the stream
-   * @return the entire response body as a String.
-   */
-  String getResponseBody(Charset charset);
-
-  /**
-   * Return the entire response body as a String.
-   *
-   * @return the entire response body as a String.
-   */
-  String getResponseBody();
-
-  /**
-   * Return the request {@link Uri}. Note that if the request got redirected, the value of the {@link Uri} will be the last valid redirect url.
-   *
-   * @return the request {@link Uri}.
-   */
-  Uri getUri();
-
-  /**
-   * Return the content-type header value.
-   *
-   * @return the content-type header value.
-   */
-  String getContentType();
-
-  /**
-   * @param name the header name
-   * @return the first response header value
-   */
-  String getHeader(CharSequence name);
-
-  /**
-   * Return a {@link List} of the response header value.
-   *
-   * @param name the header name
-   * @return the response header value
-   */
-  List<String> getHeaders(CharSequence name);
-
-  HttpHeaders getHeaders();
-
-  /**
-   * Return true if the response redirects to another object.
-   *
-   * @return True if the response redirects to another object.
-   */
-  boolean isRedirected();
-
-  /**
-   * Subclasses SHOULD implement toString() in a way that identifies the response for logging.
-   *
-   * @return the textual representation
-   */
-  String toString();
-
-  /**
-   * @return the list of {@link Cookie}.
-   */
-  List<Cookie> getCookies();
-
-  /**
-   * Return true if the response's status has been computed by an {@link AsyncHandler}
-   *
-   * @return true if the response's status has been computed by an {@link AsyncHandler}
-   */
-  boolean hasResponseStatus();
-
-  /**
-   * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
-   * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
-   *
-   * @return true if the response's headers has been computed by an {@link AsyncHandler}
-   */
-  boolean hasResponseHeaders();
-
-  /**
-   * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
-   * or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
-   *
-   * @return true if the response's body has been computed by an {@link AsyncHandler}
-   */
-  boolean hasResponseBody();
-
-  /**
-   * Get remote address client initiated request to.
-   *
-   * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
-   */
-  SocketAddress getRemoteAddress();
-
-  /**
-   * Get local address client initiated request from.
-   *
-   * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
-   */
-  SocketAddress getLocalAddress();
-
-  class ResponseBuilder {
-    private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>(1);
-    private HttpResponseStatus status;
-    private HttpHeaders headers;
-
-    public void accumulate(HttpResponseStatus status) {
-      this.status = status;
-    }
+    /**
+     * Returns the status code for the request.
+     * 
+     * @return The status code
+     */
+    int getStatusCode();
 
-    public void accumulate(HttpHeaders headers) {
-      this.headers = this.headers == null ? headers : this.headers.add(headers);
-    }
+    /**
+     * Returns the status text for the request.
+     * 
+     * @return The status text
+     */
+    String getStatusText();
 
     /**
-     * @param bodyPart a body part (possibly empty, but will be filtered out)
+     * Return the entire response body as a byte[].
+     * 
+     * @return the entire response body as a byte[].
      */
-    public void accumulate(HttpResponseBodyPart bodyPart) {
-      if (bodyPart.length() > 0)
-        bodyParts.add(bodyPart);
-    }
+    byte[] getResponseBodyAsBytes();
 
     /**
-     * Build a {@link Response} instance
-     *
-     * @return a {@link Response} instance
+     * Return the entire response body as a ByteBuffer.
+     * 
+     * @return the entire response body as a ByteBuffer.
      */
-    public Response build() {
-      return status == null ? null : new NettyResponse(status, headers, bodyParts);
-    }
+    ByteBuffer getResponseBodyAsByteBuffer();
+
+    /**
+     * Returns an input stream for the response body. Note that you should not try to get this more than once, and that you should not close the stream.
+     * 
+     * @return The input stream
+     */
+    InputStream getResponseBodyAsStream();
+
+    /**
+     * Return the entire response body as a String.
+     * 
+     * @param charset the charset to use when decoding the stream
+     * @return the entire response body as a String.
+     */
+    String getResponseBody(Charset charset);
+
+    /**
+     * Return the entire response body as a String.
+     * 
+     * @return the entire response body as a String.
+     */
+    String getResponseBody();
+
+    /**
+     * Return the request {@link Uri}. Note that if the request got redirected, the value of the {@link Uri} will be the last valid redirect url.
+     * 
+     * @return the request {@link Uri}.
+     */
+    Uri getUri();
+
+    /**
+     * Return the content-type header value.
+     * 
+     * @return the content-type header value.
+     */
+    String getContentType();
+
+    /**
+     * @param name the header name
+     * @return the first response header value
+     */
+    String getHeader(CharSequence name);
+
+    /**
+     * Return a {@link List} of the response header value.
+     * 
+     * @param name the header name
+     * @return the response header value
+     */
+    List<String> getHeaders(CharSequence name);
+
+    HttpHeaders getHeaders();
+
+    /**
+     * Return true if the response redirects to another object.
+     * 
+     * @return True if the response redirects to another object.
+     */
+    boolean isRedirected();
+
+    /**
+     * Subclasses SHOULD implement toString() in a way that identifies the response for logging.
+     * 
+     * @return the textual representation
+     */
+    String toString();
+
+    /**
+     * @return the list of {@link Cookie}.
+     */
+    List<Cookie> getCookies();
+
+    /**
+     * Return true if the response's status has been computed by an {@link AsyncHandler}
+     * 
+     * @return true if the response's status has been computed by an {@link AsyncHandler}
+     */
+    boolean hasResponseStatus();
+
+    /**
+     * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
+     * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
+     * 
+     * @return true if the response's headers has been computed by an {@link AsyncHandler}
+     */
+    boolean hasResponseHeaders();
+
+    /**
+     * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
+     * or {@link AsyncHandler#onHeadersReceived(HttpHeaders)} returned {@link AsyncHandler.State#ABORT}
+     * 
+     * @return true if the response's body has been computed by an {@link AsyncHandler}
+     */
+    boolean hasResponseBody();
+
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
+     */
+    SocketAddress getRemoteAddress();
 
     /**
-     * Reset the internal state of this builder.
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
      */
-    public void reset() {
-      bodyParts.clear();
-      status = null;
-      headers = null;
+    SocketAddress getLocalAddress();
+
+    class ResponseBuilder {
+        private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>(1);
+        private HttpResponseStatus status;
+        private HttpHeaders headers;
+
+        public ResponseBuilder accumulate(HttpResponseStatus status) {
+            this.status = status;
+            return this;
+        }
+
+        public ResponseBuilder accumulate(HttpHeaders headers) {
+            this.headers = this.headers == null ? headers : this.headers.add(headers);
+            return this;
+        }
+
+        /**
+         * @param bodyPart a body part (possibly empty, but will be filtered out)
+         * @return this
+         */
+        public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
+            if (bodyPart.length() > 0)
+                bodyParts.add(bodyPart);
+            return this;
+        }
+
+        /**
+         * Build a {@link Response} instance
+         * 
+         * @return a {@link Response} instance
+         */
+        public Response build() {
+            return status == null ? null : new NettyResponse(status, headers, bodyParts);
+        }
+
+        /**
+         * Reset the internal state of this builder.
+         */
+        public void reset() {
+            bodyParts.clear();
+            status = null;
+            headers = null;
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/SignatureCalculator.java b/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
index fbec1037e..f406c70de 100644
--- a/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/SignatureCalculator.java
@@ -16,6 +16,7 @@
 package org.asynchttpclient;
 
 
+
 /**
  * Interface that allows injecting signature calculator into
  * {@link RequestBuilder} so that signature calculation and inclusion can
@@ -24,18 +25,18 @@
  * @since 1.1
  */
 public interface SignatureCalculator {
-  /**
-   * Method called when {@link RequestBuilder#build} method is called.
-   * Should first calculate signature information and then modify request
-   * (using passed {@link RequestBuilder}) to add signature (usually as
-   * an HTTP header).
-   *
-   * @param requestBuilder builder that can be used to modify request, usually
-   *                       by adding header that includes calculated signature. Be sure NOT to
-   *                       call {@link RequestBuilder#build} since this will cause infinite recursion
-   * @param request        Request that is being built; needed to access content to
-   *                       be signed
-   */
-  void calculateAndAddSignature(Request request,
-                                RequestBuilderBase<?> requestBuilder);
+    /**
+     * Method called when {@link RequestBuilder#build} method is called.
+     * Should first calculate signature information and then modify request
+     * (using passed {@link RequestBuilder}) to add signature (usually as
+     * an HTTP header).
+     *
+     * @param requestBuilder builder that can be used to modify request, usually
+     *                       by adding header that includes calculated signature. Be sure NOT to
+     *                       call {@link RequestBuilder#build} since this will cause infinite recursion
+     * @param request        Request that is being built; needed to access content to
+     *                       be signed
+     */
+    void calculateAndAddSignature(Request request,
+                                  RequestBuilderBase<?> requestBuilder);
 }
diff --git a/client/src/main/java/org/asynchttpclient/SslEngineFactory.java b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
index 1157e499f..d756aa83d 100644
--- a/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
@@ -18,25 +18,25 @@
 
 public interface SslEngineFactory {
 
-  /**
-   * Creates new {@link SSLEngine}.
-   *
-   * @param config   the client config
-   * @param peerHost the peer hostname
-   * @param peerPort the peer port
-   * @return new engine
-   */
-  SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort);
+    /**
+     * Creates new {@link SSLEngine}.
+     *
+     * @param config the client config
+     * @param peerHost the peer hostname
+     * @param peerPort the peer port
+     * @return new engine
+     */
+    SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort);
 
-  /**
-   * Perform any necessary one-time configuration. This will be called just once before {@code newSslEngine} is called
-   * for the first time.
-   *
-   * @param config the client config
-   * @throws SSLException if initialization fails. If an exception is thrown, the instance will not be used as client
-   *                      creation will fail.
-   */
-  default void init(AsyncHttpClientConfig config) throws SSLException {
-    // no op
-  }
+    /**
+     * Perform any necessary one-time configuration. This will be called just once before {@code newSslEngine} is called
+     * for the first time.
+     *
+     * @param config the client config
+     * @throws SSLException if initialization fails. If an exception is thrown, the instance will not be used as client
+     *                      creation will fail.
+     */
+    default void init(AsyncHttpClientConfig config) throws SSLException {
+        // no op
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
index 97331fbdf..91de4de84 100755
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
@@ -13,62 +13,62 @@
  */
 package org.asynchttpclient.channel;
 
-import io.netty.channel.Channel;
-
 import java.util.Map;
 import java.util.function.Predicate;
 
+import io.netty.channel.Channel;
+
 public interface ChannelPool {
 
-  /**
-   * Add a channel to the pool
-   *
-   * @param channel      an I/O channel
-   * @param partitionKey a key used to retrieve the cached channel
-   * @return true if added.
-   */
-  boolean offer(Channel channel, Object partitionKey);
+    /**
+     * Add a channel to the pool
+     * 
+     * @param channel an I/O channel
+     * @param partitionKey a key used to retrieve the cached channel
+     * @return true if added.
+     */
+    boolean offer(Channel channel, Object partitionKey);
 
-  /**
-   * Remove the channel associated with the uri.
-   *
-   * @param partitionKey the partition used when invoking offer
-   * @return the channel associated with the uri
-   */
-  Channel poll(Object partitionKey);
+    /**
+     * Remove the channel associated with the uri.
+     * 
+     * @param partitionKey the partition used when invoking offer
+     * @return the channel associated with the uri
+     */
+    Channel poll(Object partitionKey);
 
-  /**
-   * Remove all channels from the cache. A channel might have been associated
-   * with several uri.
-   *
-   * @param channel a channel
-   * @return the true if the channel has been removed
-   */
-  boolean removeAll(Channel channel);
+    /**
+     * Remove all channels from the cache. A channel might have been associated
+     * with several uri.
+     * 
+     * @param channel a channel
+     * @return the true if the channel has been removed
+     */
+    boolean removeAll(Channel channel);
 
-  /**
-   * Return true if a channel can be cached. A implementation can decide based
-   * on some rules to allow caching Calling this method is equivalent of
-   * checking the returned value of {@link ChannelPool#offer(Channel, Object)}
-   *
-   * @return true if a channel can be cached.
-   */
-  boolean isOpen();
+    /**
+     * Return true if a channel can be cached. A implementation can decide based
+     * on some rules to allow caching Calling this method is equivalent of
+     * checking the returned value of {@link ChannelPool#offer(Channel, Object)}
+     * 
+     * @return true if a channel can be cached.
+     */
+    boolean isOpen();
 
-  /**
-   * Destroy all channels that has been cached by this instance.
-   */
-  void destroy();
+    /**
+     * Destroy all channels that has been cached by this instance.
+     */
+    void destroy();
 
-  /**
-   * Flush partitions based on a predicate
-   *
-   * @param predicate the predicate
-   */
-  void flushPartitions(Predicate<Object> predicate);
+    /**
+     * Flush partitions based on a predicate
+     * 
+     * @param predicate the predicate
+     */
+    void flushPartitions(Predicate<Object> predicate);
 
-  /**
-   * @return The number of idle channels per host.
-   */
-  Map<String, Long> getIdleChannelCountPerHost();
+    /**
+     * @return The number of idle channels per host.
+     */
+    Map<String, Long> getIdleChannelCountPerHost();
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
index ecdf84d99..4cce3c636 100644
--- a/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
@@ -13,90 +13,87 @@
 package org.asynchttpclient.channel;
 
 import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.proxy.ProxyType;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.HttpUtils;
 
 public interface ChannelPoolPartitioning {
 
-  Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
+    class ProxyPartitionKey {
+        private final String proxyHost;
+        private final int proxyPort;
+        private final boolean secured;
+        private final String targetHostBaseUrl;
 
-  enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
+        public ProxyPartitionKey(String proxyHost, int proxyPort, boolean secured, String targetHostBaseUrl) {
+            this.proxyHost = proxyHost;
+            this.proxyPort = proxyPort;
+            this.secured = secured;
+            this.targetHostBaseUrl = targetHostBaseUrl;
+        }
 
-    INSTANCE;
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((proxyHost == null) ? 0 : proxyHost.hashCode());
+            result = prime * result + proxyPort;
+            result = prime * result + (secured ? 1231 : 1237);
+            result = prime * result + ((targetHostBaseUrl == null) ? 0 : targetHostBaseUrl.hashCode());
+            return result;
+        }
 
-    public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer) {
-      String targetHostBaseUrl = virtualHost != null ? virtualHost : HttpUtils.getBaseUrl(uri);
-      if (proxyServer != null) {
-        return uri.isSecured() ? //
-                new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getSecuredPort(), true, targetHostBaseUrl, proxyServer.getProxyType())
-                : new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getPort(), false, targetHostBaseUrl, proxyServer.getProxyType());
-      } else {
-        return targetHostBaseUrl;
-      }
-    }
-  }
-
-  class ProxyPartitionKey {
-    private final String proxyHost;
-    private final int proxyPort;
-    private final boolean secured;
-    private final String targetHostBaseUrl;
-    private final ProxyType proxyType;
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            ProxyPartitionKey other = (ProxyPartitionKey) obj;
+            if (proxyHost == null) {
+                if (other.proxyHost != null)
+                    return false;
+            } else if (!proxyHost.equals(other.proxyHost))
+                return false;
+            if (proxyPort != other.proxyPort)
+                return false;
+            if (secured != other.secured)
+                return false;
+            if (targetHostBaseUrl == null) {
+                if (other.targetHostBaseUrl != null)
+                    return false;
+            } else if (!targetHostBaseUrl.equals(other.targetHostBaseUrl))
+                return false;
+            return true;
+        }
 
-    public ProxyPartitionKey(String proxyHost, int proxyPort, boolean secured, String targetHostBaseUrl, ProxyType proxyType) {
-      this.proxyHost = proxyHost;
-      this.proxyPort = proxyPort;
-      this.secured = secured;
-      this.targetHostBaseUrl = targetHostBaseUrl;
-      this.proxyType = proxyType;
+        @Override
+        public String toString() {
+            return new StringBuilder()//
+                    .append("ProxyPartitionKey(proxyHost=").append(proxyHost)//
+                    .append(", proxyPort=").append(proxyPort)//
+                    .append(", secured=").append(secured)//
+                    .append(", targetHostBaseUrl=").append(targetHostBaseUrl)//
+                    .toString();
+        }
     }
 
-    @Override
-    public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      result = prime * result + ((proxyHost == null) ? 0 : proxyHost.hashCode());
-      result = prime * result + proxyPort;
-      result = prime * result + (secured ? 1231 : 1237);
-      result = prime * result + ((targetHostBaseUrl == null) ? 0 : targetHostBaseUrl.hashCode());
-      result = prime * result + proxyType.hashCode();
-      return result;
-    }
+    Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
 
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj)
-        return true;
-      if (obj == null)
-        return false;
-      if (getClass() != obj.getClass())
-        return false;
-      ProxyPartitionKey other = (ProxyPartitionKey) obj;
-      if (proxyHost == null) {
-        if (other.proxyHost != null)
-          return false;
-      } else if (!proxyHost.equals(other.proxyHost))
-        return false;
-      if (proxyPort != other.proxyPort)
-        return false;
-      if (secured != other.secured)
-        return false;
-      if (targetHostBaseUrl == null) {
-        if (other.targetHostBaseUrl != null)
-          return false;
-      } else if (!targetHostBaseUrl.equals(other.targetHostBaseUrl))
-        return false;
-      return proxyType == other.proxyType;
-    }
+    enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
+
+        INSTANCE;
 
-    @Override
-    public String toString() {
-      return "ProxyPartitionKey(proxyHost=" + proxyHost +
-              ", proxyPort=" + proxyPort +
-              ", secured=" + secured +
-              ", targetHostBaseUrl=" + targetHostBaseUrl +
-              ", proxyType=" + proxyType;
+        public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer) {
+            String targetHostBaseUrl = virtualHost != null ? virtualHost : HttpUtils.getBaseUrl(uri);
+            if (proxyServer != null) {
+                return uri.isSecured() ? //
+                new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getSecuredPort(), true, targetHostBaseUrl)
+                        : new ProxyPartitionKey(proxyServer.getHost(), proxyServer.getPort(), false, targetHostBaseUrl);
+            } else {
+                return targetHostBaseUrl;
+            }
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
index b9fb306cf..a1fb0fd42 100644
--- a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
@@ -1,25 +1,25 @@
 package org.asynchttpclient.channel;
 
+import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
-import org.asynchttpclient.Request;
 
-import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
+import org.asynchttpclient.Request;
 
 /**
  * Connection strategy implementing standard HTTP 1.0/1.1 behavior.
  */
 public class DefaultKeepAliveStrategy implements KeepAliveStrategy {
 
-  /**
-   * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
-   */
-  @Override
-  public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
-    return HttpUtil.isKeepAlive(response)
-            && HttpUtil.isKeepAlive(request)
-            // support non standard Proxy-Connection
-            && !response.headers().contains("Proxy-Connection", CLOSE, true);
-  }
+    /**
+     * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
+     */
+    @Override
+    public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
+        return HttpUtil.isKeepAlive(response)//
+                && HttpUtil.isKeepAlive(request)
+                // support non standard Proxy-Connection
+                && !response.headers().contains("Proxy-Connection", CLOSE, true);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
index 4d619f222..db24724e4 100644
--- a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
@@ -15,17 +15,18 @@
 
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
+
 import org.asynchttpclient.Request;
 
 public interface KeepAliveStrategy {
 
-  /**
-   * Determines whether the connection should be kept alive after this HTTP message exchange.
-   *
-   * @param ahcRequest    the Request, as built by AHC
-   * @param nettyRequest  the HTTP request sent to Netty
-   * @param nettyResponse the HTTP response received from Netty
-   * @return true if the connection should be kept alive, false if it should be closed.
-   */
-  boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
+    /**
+     * Determines whether the connection should be kept alive after this HTTP message exchange.
+     * 
+     * @param ahcRequest the Request, as built by AHC
+     * @param nettyRequest the HTTP request sent to Netty
+     * @param nettyResponse the HTTP response received from Netty
+     * @return true if the connection should be kept alive, false if it should be closed.
+     */
+    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
index eb6a6abf2..281f3f127 100644
--- a/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
@@ -21,38 +21,38 @@
 
 public enum NoopChannelPool implements ChannelPool {
 
-  INSTANCE;
-
-  @Override
-  public boolean offer(Channel channel, Object partitionKey) {
-    return false;
-  }
-
-  @Override
-  public Channel poll(Object partitionKey) {
-    return null;
-  }
-
-  @Override
-  public boolean removeAll(Channel channel) {
-    return false;
-  }
-
-  @Override
-  public boolean isOpen() {
-    return true;
-  }
-
-  @Override
-  public void destroy() {
-  }
-
-  @Override
-  public void flushPartitions(Predicate<Object> predicate) {
-  }
-
-  @Override
-  public Map<String, Long> getIdleChannelCountPerHost() {
-    return Collections.emptyMap();
-  }
+    INSTANCE;
+
+    @Override
+    public boolean offer(Channel channel, Object partitionKey) {
+        return false;
+    }
+
+    @Override
+    public Channel poll(Object partitionKey) {
+        return null;
+    }
+
+    @Override
+    public boolean removeAll(Channel channel) {
+        return false;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return true;
+    }
+
+    @Override
+    public void destroy() {
+    }
+
+    @Override
+    public void flushPartitions(Predicate<Object> predicate) {
+    }
+
+    @Override
+    public Map<String, Long> getIdleChannelCountPerHost() {
+        return Collections.emptyMap();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index 65d2c9a75..df1c4cfb8 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -12,271 +12,202 @@
  */
 package org.asynchttpclient.config;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Properties;
-
 public final class AsyncHttpClientConfigDefaults {
 
-  public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
-  public static final String THREAD_POOL_NAME_CONFIG = "threadPoolName";
-  public static final String MAX_CONNECTIONS_CONFIG = "maxConnections";
-  public static final String MAX_CONNECTIONS_PER_HOST_CONFIG = "maxConnectionsPerHost";
-  public static final String CONNECTION_TIMEOUT_CONFIG = "connectTimeout";
-  public static final String POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG = "pooledConnectionIdleTimeout";
-  public static final String CONNECTION_POOL_CLEANER_PERIOD_CONFIG = "connectionPoolCleanerPeriod";
-  public static final String READ_TIMEOUT_CONFIG = "readTimeout";
-  public static final String REQUEST_TIMEOUT_CONFIG = "requestTimeout";
-  public static final String CONNECTION_TTL_CONFIG = "connectionTtl";
-  public static final String FOLLOW_REDIRECT_CONFIG = "followRedirect";
-  public static final String MAX_REDIRECTS_CONFIG = "maxRedirects";
-  public static final String COMPRESSION_ENFORCED_CONFIG = "compressionEnforced";
-  public static final String USER_AGENT_CONFIG = "userAgent";
-  public static final String ENABLED_PROTOCOLS_CONFIG = "enabledProtocols";
-  public static final String ENABLED_CIPHER_SUITES_CONFIG = "enabledCipherSuites";
-  public static final String USE_PROXY_SELECTOR_CONFIG = "useProxySelector";
-  public static final String USE_PROXY_PROPERTIES_CONFIG = "useProxyProperties";
-  public static final String VALIDATE_RESPONSE_HEADERS_CONFIG = "validateResponseHeaders";
-  public static final String AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG = "aggregateWebSocketFrameFragments";
-  public static final String ENABLE_WEBSOCKET_COMPRESSION_CONFIG= "enableWebSocketCompression";
-  public static final String STRICT_302_HANDLING_CONFIG = "strict302Handling";
-  public static final String KEEP_ALIVE_CONFIG = "keepAlive";
-  public static final String MAX_REQUEST_RETRY_CONFIG = "maxRequestRetry";
-  public static final String DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG = "disableUrlEncodingForBoundRequests";
-  public static final String USE_LAX_COOKIE_ENCODER_CONFIG = "useLaxCookieEncoder";
-  public static final String USE_OPEN_SSL_CONFIG = "useOpenSsl";
-  public static final String USE_INSECURE_TRUST_MANAGER_CONFIG = "useInsecureTrustManager";
-  public static final String DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG = "disableHttpsEndpointIdentificationAlgorithm";
-  public static final String SSL_SESSION_CACHE_SIZE_CONFIG = "sslSessionCacheSize";
-  public static final String SSL_SESSION_TIMEOUT_CONFIG = "sslSessionTimeout";
-  public static final String TCP_NO_DELAY_CONFIG = "tcpNoDelay";
-  public static final String SO_REUSE_ADDRESS_CONFIG = "soReuseAddress";
-  public static final String SO_LINGER_CONFIG = "soLinger";
-  public static final String SO_SND_BUF_CONFIG = "soSndBuf";
-  public static final String SO_RCV_BUF_CONFIG = "soRcvBuf";
-  public static final String HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG = "httpClientCodecMaxInitialLineLength";
-  public static final String HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG = "httpClientCodecMaxHeaderSize";
-  public static final String HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG = "httpClientCodecMaxChunkSize";
-  public static final String HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG = "httpClientCodecInitialBufferSize";
-  public static final String DISABLE_ZERO_COPY_CONFIG = "disableZeroCopy";
-  public static final String HANDSHAKE_TIMEOUT_CONFIG = "handshakeTimeout";
-  public static final String CHUNKED_FILE_CHUNK_SIZE_CONFIG = "chunkedFileChunkSize";
-  public static final String WEBSOCKET_MAX_BUFFER_SIZE_CONFIG = "webSocketMaxBufferSize";
-  public static final String WEBSOCKET_MAX_FRAME_SIZE_CONFIG = "webSocketMaxFrameSize";
-  public static final String KEEP_ENCODING_HEADER_CONFIG = "keepEncodingHeader";
-  public static final String SHUTDOWN_QUIET_PERIOD_CONFIG = "shutdownQuietPeriod";
-  public static final String SHUTDOWN_TIMEOUT_CONFIG = "shutdownTimeout";
-  public static final String USE_NATIVE_TRANSPORT_CONFIG = "useNativeTransport";
-  public static final String IO_THREADS_COUNT_CONFIG = "ioThreadsCount";
-
-  public static final String AHC_VERSION;
-
-  static {
-    try (InputStream is = AsyncHttpClientConfigDefaults.class.getResourceAsStream("/ahc-version.properties")) {
-      Properties prop = new Properties();
-      prop.load(is);
-      AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
-    } catch (IOException e) {
-      throw new ExceptionInInitializerError(e);
-    }
-  }
-
-  private AsyncHttpClientConfigDefaults() {
-  }
-
-  public static String defaultThreadPoolName() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + THREAD_POOL_NAME_CONFIG);
-  }
-
-  public static int defaultMaxConnections() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_CONNECTIONS_CONFIG);
-  }
-
-  public static int defaultMaxConnectionsPerHost() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_CONNECTIONS_PER_HOST_CONFIG);
-  }
-
-  public static int defaultConnectTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_TIMEOUT_CONFIG);
-  }
-
-  public static int defaultPooledConnectionIdleTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG);
-  }
-
-  public static int defaultConnectionPoolCleanerPeriod() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_POOL_CLEANER_PERIOD_CONFIG);
-  }
-
-  public static int defaultReadTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + READ_TIMEOUT_CONFIG);
-  }
-
-  public static int defaultRequestTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + REQUEST_TIMEOUT_CONFIG);
-  }
-
-  public static int defaultConnectionTtl() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CONNECTION_TTL_CONFIG);
-  }
-
-  public static boolean defaultFollowRedirect() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + FOLLOW_REDIRECT_CONFIG);
-  }
-
-  public static int defaultMaxRedirects() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_REDIRECTS_CONFIG);
-  }
-
-  public static boolean defaultCompressionEnforced() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + COMPRESSION_ENFORCED_CONFIG);
-  }
-
-  public static String defaultUserAgent() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + USER_AGENT_CONFIG);
-  }
-
-  public static String[] defaultEnabledProtocols() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + ENABLED_PROTOCOLS_CONFIG);
-  }
-
-  public static String[] defaultEnabledCipherSuites() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + ENABLED_CIPHER_SUITES_CONFIG);
-  }
-
-  public static boolean defaultUseProxySelector() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_PROXY_SELECTOR_CONFIG);
-  }
-
-  public static boolean defaultUseProxyProperties() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_PROXY_PROPERTIES_CONFIG);
-  }
-
-  public static boolean defaultValidateResponseHeaders() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + VALIDATE_RESPONSE_HEADERS_CONFIG);
-  }
-
-  public static boolean defaultAggregateWebSocketFrameFragments() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG);
-  }
-
-  public static boolean defaultEnableWebSocketCompression() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + ENABLE_WEBSOCKET_COMPRESSION_CONFIG);
-  }
+    private AsyncHttpClientConfigDefaults() {
+    }
+
+    public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
+
+    public static String defaultThreadPoolName() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "threadPoolName");
+    }
+
+    public static int defaultMaxConnections() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnections");
+    }
+
+    public static int defaultMaxConnectionsPerHost() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnectionsPerHost");
+    }
+
+    public static int defaultConnectTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectTimeout");
+    }
+
+    public static int defaultPooledConnectionIdleTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "pooledConnectionIdleTimeout");
+    }
+
+    public static int defaultConnectionPoolCleanerPeriod() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionPoolCleanerPeriod");
+    }
+
+    public static int defaultReadTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "readTimeout");
+    }
+
+    public static int defaultRequestTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "requestTimeout");
+    }
+
+    public static int defaultConnectionTtl() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionTtl");
+    }
+
+    public static boolean defaultFollowRedirect() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "followRedirect");
+    }
+
+    public static int defaultMaxRedirects() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRedirects");
+    }
+
+    public static boolean defaultCompressionEnforced() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "compressionEnforced");
+    }
+
+    public static String defaultUserAgent() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "userAgent");
+    }
+
+    public static String[] defaultEnabledProtocols() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledProtocols");
+    }
+
+    public static String[] defaultEnabledCipherSuites() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledCipherSuites");
+    }
+
+    public static boolean defaultUseProxySelector() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxySelector");
+    }
+
+    public static boolean defaultUseProxyProperties() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties");
+    }
 
-  public static boolean defaultStrict302Handling() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + STRICT_302_HANDLING_CONFIG);
-  }
+    public static boolean defaultValidateResponseHeaders() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "validateResponseHeaders");
+    }
 
-  public static boolean defaultKeepAlive() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + KEEP_ALIVE_CONFIG);
-  }
+    public static boolean defaultAggregateWebSocketFrameFragments() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "aggregateWebSocketFrameFragments");
+    }
 
-  public static int defaultMaxRequestRetry() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + MAX_REQUEST_RETRY_CONFIG);
-  }
+    public static boolean defaultStrict302Handling() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
+    }
 
-  public static boolean defaultDisableUrlEncodingForBoundRequests() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG);
-  }
+    public static boolean defaultKeepAlive() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepAlive");
+    }
 
-  public static boolean defaultUseLaxCookieEncoder() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_LAX_COOKIE_ENCODER_CONFIG);
-  }
+    public static int defaultMaxRequestRetry() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRequestRetry");
+    }
 
-  public static boolean defaultUseOpenSsl() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_OPEN_SSL_CONFIG);
-  }
+    public static boolean defaultDisableUrlEncodingForBoundRequests() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableUrlEncodingForBoundRequests");
+    }
 
-  public static boolean defaultUseInsecureTrustManager() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_INSECURE_TRUST_MANAGER_CONFIG);
-  }
+    public static boolean defaultUseLaxCookieEncoder() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useLaxCookieEncoder");
+    }
 
-  public static boolean defaultDisableHttpsEndpointIdentificationAlgorithm() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG);
-  }
+    public static boolean defaultUseOpenSsl() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useOpenSsl");
+    }
 
-  public static int defaultSslSessionCacheSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SSL_SESSION_CACHE_SIZE_CONFIG);
-  }
+    public static boolean defaultUseInsecureTrustManager() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useInsecureTrustManager");
+    }
 
-  public static int defaultSslSessionTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SSL_SESSION_TIMEOUT_CONFIG);
-  }
+    public static boolean defaultDisableHttpsEndpointIdentificationAlgorithm() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableHttpsEndpointIdentificationAlgorithm");
+    }
 
-  public static boolean defaultTcpNoDelay() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + TCP_NO_DELAY_CONFIG);
-  }
+    public static int defaultSslSessionCacheSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionCacheSize");
+    }
 
-  public static boolean defaultSoReuseAddress() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + SO_REUSE_ADDRESS_CONFIG);
-  }
+    public static int defaultSslSessionTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
+    }
 
-  public static int defaultSoLinger() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_LINGER_CONFIG);
-  }
+    public static boolean defaultTcpNoDelay() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "tcpNoDelay");
+    }
 
-  public static int defaultSoSndBuf() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_SND_BUF_CONFIG);
-  }
+    public static boolean defaultSoReuseAddress() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "soReuseAddress");
+    }
 
-  public static int defaultSoRcvBuf() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SO_RCV_BUF_CONFIG);
-  }
+    public static int defaultSoLinger() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soLinger");
+    }
 
-  public static int defaultHttpClientCodecMaxInitialLineLength() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG);
-  }
+    public static int defaultSoSndBuf() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soSndBuf");
+    }
 
-  public static int defaultHttpClientCodecMaxHeaderSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG);
-  }
+    public static int defaultSoRcvBuf() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soRcvBuf");
+    }
 
-  public static int defaultHttpClientCodecMaxChunkSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG);
-  }
+    public static int defaultHttpClientCodecMaxInitialLineLength() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxInitialLineLength");
+    }
 
-  public static int defaultHttpClientCodecInitialBufferSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG);
-  }
+    public static int defaultHttpClientCodecMaxHeaderSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxHeaderSize");
+    }
 
-  public static boolean defaultDisableZeroCopy() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + DISABLE_ZERO_COPY_CONFIG);
-  }
+    public static int defaultHttpClientCodecMaxChunkSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxChunkSize");
+    }
 
-  public static int defaultHandshakeTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + HANDSHAKE_TIMEOUT_CONFIG);
-  }
+    public static int defaultHttpClientCodecInitialBufferSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecInitialBufferSize");
+    }
 
-  public static int defaultChunkedFileChunkSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + CHUNKED_FILE_CHUNK_SIZE_CONFIG);
-  }
+    public static boolean defaultDisableZeroCopy() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableZeroCopy");
+    }
 
-  public static int defaultWebSocketMaxBufferSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + WEBSOCKET_MAX_BUFFER_SIZE_CONFIG);
-  }
+    public static int defaultHandshakeTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "handshakeTimeout");
+    }
 
-  public static int defaultWebSocketMaxFrameSize() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + WEBSOCKET_MAX_FRAME_SIZE_CONFIG);
-  }
+    public static int defaultChunkedFileChunkSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "chunkedFileChunkSize");
+    }
 
-  public static boolean defaultKeepEncodingHeader() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + KEEP_ENCODING_HEADER_CONFIG);
-  }
+    public static int defaultWebSocketMaxBufferSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxBufferSize");
+    }
 
-  public static int defaultShutdownQuietPeriod() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SHUTDOWN_QUIET_PERIOD_CONFIG);
-  }
+    public static int defaultWebSocketMaxFrameSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxFrameSize");
+    }
+
+    public static boolean defaultKeepEncodingHeader() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepEncodingHeader");
+    }
+
+    public static int defaultShutdownQuietPeriod() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "shutdownQuietPeriod");
+    }
 
-  public static int defaultShutdownTimeout() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + SHUTDOWN_TIMEOUT_CONFIG);
-  }
+    public static int defaultShutdownTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "shutdownTimeout");
+    }
 
-  public static boolean defaultUseNativeTransport() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + USE_NATIVE_TRANSPORT_CONFIG);
-  }
+    public static boolean defaultUseNativeTransport() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
+    }
 
-  public static int defaultIoThreadsCount() {
-    return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + IO_THREADS_COUNT_CONFIG);
-  }
+    public static int defaultIoThreadsCount() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "ioThreadsCount");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index 50aa52e67..80ebd712a 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -9,108 +9,117 @@
 
 public class AsyncHttpClientConfigHelper {
 
-  private static volatile Config config;
+    private static volatile Config config;
 
-  public static Config getAsyncHttpClientConfig() {
-    if (config == null) {
-      config = new Config();
-    }
+    public static Config getAsyncHttpClientConfig() {
+        if (config == null) {
+            config = new Config();
+        }
 
-    return config;
-  }
+        return config;
+    }
 
-  /**
-   * This method invalidates the property caches. So if a system property has been changed and the effect of this change is to be seen then call reloadProperties() and then
-   * getAsyncHttpClientConfig() to get the new property values.
-   */
-  public static void reloadProperties() {
-    if (config != null)
-      config.reload();
-  }
+    /**
+     * This method invalidates the property caches. So if a system property has been changed and the effect of this change is to be seen then call reloadProperties() and then
+     * getAsyncHttpClientConfig() to get the new property values.
+     */
+    public static void reloadProperties() {
+        if (config != null)
+            config.reload();
+    }
 
-  public static class Config {
+    public static class Config {
 
-    public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
-    public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
+        public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
+        public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
 
-    private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
-    private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES, true);
-    private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
+        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
+        private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES, true);
+        private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
 
-    public void reload() {
-      customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
-      propsCache.clear();
-    }
+        public void reload() {
+            customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES, false);
+            propsCache.clear();
+        }
 
-    private Properties parsePropertiesFile(String file, boolean required) {
-      Properties props = new Properties();
-
-      List<ClassLoader> cls = new ArrayList<>();
-
-      ClassLoader cl = Thread.currentThread().getContextClassLoader();
-      if (cl != null) {
-        cls.add(cl);
-      }
-      cl = getClass().getClassLoader();
-      if (cl != null) {
-        cls.add(cl);
-      }
-      cl = ClassLoader.getSystemClassLoader();
-      if (cl != null) {
-        cls.add(cl);
-      }
-
-      InputStream is = null;
-      for (ClassLoader classLoader : cls) {
-        is = classLoader.getResourceAsStream(file);
-        if (is != null) {
-          break;
+        private Properties parsePropertiesFile(String file, boolean required) {
+            Properties props = new Properties();
+
+            List<ClassLoader> cls = new ArrayList<>();
+
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            if (cl != null) {
+                cls.add(cl);
+            }
+            cl = getClass().getClassLoader();
+            if (cl != null) {
+                cls.add(cl);
+            }
+            cl = ClassLoader.getSystemClassLoader();
+            if (cl != null) {
+                cls.add(cl);
+            }
+
+            InputStream is = null;
+            for (ClassLoader classLoader : cls) {
+                is = classLoader.getResourceAsStream(file);
+                if (is != null) {
+                    break;
+                }
+            }
+
+            if (is != null) {
+                try {
+                    props.load(is);
+                } catch (IOException e) {
+                    throw new IllegalArgumentException("Can't parse config file " + file, e);
+                }
+            } else if (required) {
+                throw new IllegalArgumentException("Can't locate config file " + file);
+            }
+
+            return props;
         }
-      }
 
-      if (is != null) {
-        try {
-          props.load(is);
-        } catch (IOException e) {
-          throw new IllegalArgumentException("Can't parse config file " + file, e);
+        public String getString(String key) {
+            return propsCache.computeIfAbsent(key, k -> {
+                String value = System.getProperty(k);
+                if (value == null)
+                    value = customProperties.getProperty(k);
+                if (value == null)
+                    value = defaultProperties.getProperty(k);
+                return value;
+            });
         }
-      } else if (required) {
-        throw new IllegalArgumentException("Can't locate config file " + file);
-      }
 
-      return props;
-    }
+        public String[] getStringArray(String key) {
+            String s = getString(key);
+            s = s.trim();
+            if (s.isEmpty()) {
+                return null;
+            }
+            String[] rawArray = s.split(",");
+            String[] array = new String[rawArray.length];
+            for (int i = 0; i < rawArray.length; i++)
+                array[i] = rawArray[i].trim();
+            return array;
+        }
 
-    public String getString(String key) {
-      return propsCache.computeIfAbsent(key, k -> {
-        String value = System.getProperty(k);
-        if (value == null)
-          value = customProperties.getProperty(k);
-        if (value == null)
-          value = defaultProperties.getProperty(k);
-        return value;
-      });
-    }
+        public int getInt(String key) {
+            return Integer.parseInt(getString(key));
+        }
 
-    public String[] getStringArray(String key) {
-      String s = getString(key);
-      s = s.trim();
-      if (s.isEmpty()) {
-        return null;
-      }
-      String[] rawArray = s.split(",");
-      String[] array = new String[rawArray.length];
-      for (int i = 0; i < rawArray.length; i++)
-        array[i] = rawArray[i].trim();
-      return array;
-    }
+        public long getLong(String key) {
+            return Long.parseLong(getString(key));
+        }
 
-    public int getInt(String key) {
-      return Integer.parseInt(getString(key));
-    }
+        public Integer getInteger(String key) {
+            String s = getString(key);
+            return s != null ? Integer.valueOf(s) : null;
+        }
 
-    public boolean getBoolean(String key) {
-      return Boolean.parseBoolean(getString(key));
+        public boolean getBoolean(String key) {
+            return Boolean.parseBoolean(getString(key));
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java b/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java
deleted file mode 100644
index 0c5ad544e..000000000
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieStore.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.cookie;
-
-import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
-
-import java.net.CookieManager;
-import java.util.List;
-import java.util.function.Predicate;
-
-/**
- * This interface represents an abstract store for {@link Cookie} objects.
- *
- * <p>{@link CookieManager} will call {@code CookieStore.add} to save cookies
- * for every incoming HTTP response, and call {@code CookieStore.get} to
- * retrieve cookie for every outgoing HTTP request. A CookieStore
- * is responsible for removing HttpCookie instances which have expired.
- *
- * @since 2.1
- */
-public interface CookieStore {
-  /**
-   * Adds one {@link Cookie} to the store. This is called for every incoming HTTP response.
-   * If the given cookie has already expired it will not be added, but existing values will still be removed.
-   *
-   * <p>A cookie to store may or may not be associated with an URI. If it
-   * is not associated with an URI, the cookie's domain and path attribute
-   * will indicate where it comes from. If it is associated with an URI and
-   * its domain and path attribute are not specified, given URI will indicate
-   * where this cookie comes from.
-   *
-   * <p>If a cookie corresponding to the given URI already exists,
-   * then it is replaced with the new one.
-   *
-   * @param uri    the {@link Uri uri} this cookie associated with. if {@code null}, this cookie will not be associated with an URI
-   * @param cookie the {@link Cookie cookie} to be added
-   */
-  void add(Uri uri, Cookie cookie);
-
-  /**
-   * Retrieve cookies associated with given URI, or whose domain matches the given URI. Only cookies that
-   * have not expired are returned. This is called for every outgoing HTTP request.
-   *
-   * @param uri the {@link Uri uri} associated with the cookies to be returned
-   * @return an immutable list of Cookie, return empty list if no cookies match the given URI
-   */
-  List<Cookie> get(Uri uri);
-
-  /**
-   * Get all not-expired cookies in cookie store.
-   *
-   * @return an immutable list of http cookies;
-   * return empty list if there's no http cookie in store
-   */
-  List<Cookie> getAll();
-
-  /**
-   * Remove a cookie from store.
-   *
-   * @param predicate that indicates what cookies to remove
-   * @return {@code true} if this store contained the specified cookie
-   * @throws NullPointerException if {@code cookie} is {@code null}
-   */
-  boolean remove(Predicate<Cookie> predicate);
-
-  /**
-   * Remove all cookies in this cookie store.
-   *
-   * @return true if any cookies were purged.
-   */
-  boolean clear();
-}
diff --git a/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java b/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
deleted file mode 100644
index 277db387c..000000000
--- a/client/src/main/java/org/asynchttpclient/cookie/ThreadSafeCookieStore.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.cookie;
-
-import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.Assertions;
-import org.asynchttpclient.util.MiscUtils;
-
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
-
-public final class ThreadSafeCookieStore implements CookieStore {
-
-  private Map<CookieKey, StoredCookie> cookieJar = new ConcurrentHashMap<>();
-
-  @Override
-  public void add(Uri uri, Cookie cookie) {
-    String thisRequestDomain = requestDomain(uri);
-    String thisRequestPath = requestPath(uri);
-
-    add(thisRequestDomain, thisRequestPath, cookie);
-  }
-
-  @Override
-  public List<Cookie> get(Uri uri) {
-    return get(requestDomain(uri), requestPath(uri), uri.isSecured());
-  }
-
-  @Override
-  public List<Cookie> getAll() {
-    final boolean[] removeExpired = {false};
-    List<Cookie> result = cookieJar
-            .entrySet()
-            .stream()
-            .filter(pair -> {
-              boolean hasCookieExpired = hasCookieExpired(pair.getValue().cookie, pair.getValue().createdAt);
-              if (hasCookieExpired && !removeExpired[0])
-                removeExpired[0] = true;
-              return !hasCookieExpired;
-            })
-            .map(pair -> pair.getValue().cookie)
-            .collect(Collectors.toList());
-
-    if (removeExpired[0])
-      removeExpired();
-
-    return result;
-  }
-
-  @Override
-  public boolean remove(Predicate<Cookie> predicate) {
-    return cookieJar.entrySet().removeIf(v -> predicate.test(v.getValue().cookie));
-  }
-
-  @Override
-  public boolean clear() {
-    boolean result = !cookieJar.isEmpty();
-    cookieJar.clear();
-    return result;
-  }
-
-  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-  private String requestDomain(Uri requestUri) {
-    return requestUri.getHost().toLowerCase();
-  }
-
-  private String requestPath(Uri requestUri) {
-    return requestUri.getPath().isEmpty() ? "/" : requestUri.getPath();
-  }
-
-  // rfc6265#section-5.2.3
-  // Let cookie-domain be the attribute-value without the leading %x2E (".") character.
-  private AbstractMap.SimpleEntry<String, Boolean> cookieDomain(String cookieDomain, String requestDomain) {
-    if (cookieDomain != null) {
-      String normalizedCookieDomain = cookieDomain.toLowerCase();
-      return new AbstractMap.SimpleEntry<>(
-              (!cookieDomain.isEmpty() && cookieDomain.charAt(0) == '.') ?
-                      normalizedCookieDomain.substring(1) :
-                      normalizedCookieDomain, false);
-    } else
-      return new AbstractMap.SimpleEntry<>(requestDomain, true);
-  }
-
-  // rfc6265#section-5.2.4
-  private String cookiePath(String rawCookiePath, String requestPath) {
-    if (MiscUtils.isNonEmpty(rawCookiePath) && rawCookiePath.charAt(0) == '/') {
-      return rawCookiePath;
-    } else {
-      // rfc6265#section-5.1.4
-      int indexOfLastSlash = requestPath.lastIndexOf('/');
-      if (!requestPath.isEmpty() && requestPath.charAt(0) == '/' && indexOfLastSlash > 0)
-        return requestPath.substring(0, indexOfLastSlash);
-      else
-        return "/";
-    }
-  }
-
-  private boolean hasCookieExpired(Cookie cookie, long whenCreated) {
-    // if not specify max-age, this cookie should be discarded when user agent is to be closed, but it is not expired.
-    if (cookie.maxAge() == Cookie.UNDEFINED_MAX_AGE)
-      return false;
-
-    if (cookie.maxAge() <= 0)
-      return true;
-
-    if (whenCreated > 0) {
-      long deltaSecond = (System.currentTimeMillis() - whenCreated) / 1000;
-      return deltaSecond > cookie.maxAge();
-    } else
-      return false;
-  }
-
-  // rfc6265#section-5.1.3
-  // check "The string is a host name (i.e., not an IP address)" ignored
-  private boolean domainsMatch(String cookieDomain, String requestDomain, boolean hostOnly) {
-    return (hostOnly && Objects.equals(requestDomain, cookieDomain)) ||
-            (Objects.equals(requestDomain, cookieDomain) || requestDomain.endsWith("." + cookieDomain));
-  }
-
-  // rfc6265#section-5.1.4
-  private boolean pathsMatch(String cookiePath, String requestPath) {
-    return Objects.equals(cookiePath, requestPath) ||
-            (requestPath.startsWith(cookiePath) && (cookiePath.charAt(cookiePath.length() - 1) == '/' || requestPath.charAt(cookiePath.length()) == '/'));
-  }
-
-  private void add(String requestDomain, String requestPath, Cookie cookie) {
-
-    AbstractMap.SimpleEntry<String, Boolean> pair = cookieDomain(cookie.domain(), requestDomain);
-    String keyDomain = pair.getKey();
-    boolean hostOnly = pair.getValue();
-    String keyPath = cookiePath(cookie.path(), requestPath);
-    CookieKey key = new CookieKey(cookie.name().toLowerCase(), keyDomain, keyPath);
-
-    if (hasCookieExpired(cookie, 0))
-      cookieJar.remove(key);
-    else
-      cookieJar.put(key, new StoredCookie(cookie, hostOnly, cookie.maxAge() != Cookie.UNDEFINED_MAX_AGE));
-  }
-
-  private List<Cookie> get(String domain, String path, boolean secure) {
-
-    final boolean[] removeExpired = {false};
-
-    List<Cookie> result = cookieJar.entrySet().stream().filter(pair -> {
-      CookieKey key = pair.getKey();
-      StoredCookie storedCookie = pair.getValue();
-      boolean hasCookieExpired = hasCookieExpired(storedCookie.cookie, storedCookie.createdAt);
-      if (hasCookieExpired && !removeExpired[0])
-        removeExpired[0] = true;
-      return !hasCookieExpired && domainsMatch(key.domain, domain, storedCookie.hostOnly) && pathsMatch(key.path, path) && (secure || !storedCookie.cookie.isSecure());
-    }).map(v -> v.getValue().cookie).collect(Collectors.toList());
-
-    if (removeExpired[0])
-      removeExpired();
-
-    return result;
-  }
-
-  private void removeExpired() {
-    cookieJar.entrySet().removeIf(v -> hasCookieExpired(v.getValue().cookie, v.getValue().createdAt));
-  }
-
-  private static class CookieKey implements Comparable<CookieKey> {
-    final String name;
-    final String domain;
-    final String path;
-
-    CookieKey(String name, String domain, String path) {
-      this.name = name;
-      this.domain = domain;
-      this.path = path;
-    }
-
-    @Override
-    public int compareTo(CookieKey o) {
-      Assertions.assertNotNull(o, "Parameter can't be null");
-      int result;
-      if ((result = this.name.compareTo(o.name)) == 0)
-        if ((result = this.domain.compareTo(o.domain)) == 0)
-          result = this.path.compareTo(o.path);
-
-      return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      return obj instanceof CookieKey && this.compareTo((CookieKey) obj) == 0;
-    }
-
-    @Override
-    public int hashCode() {
-      int result = 17;
-      result = 31 * result + name.hashCode();
-      result = 31 * result + domain.hashCode();
-      result = 31 * result + path.hashCode();
-      return result;
-    }
-
-    @Override
-    public String toString() {
-      return String.format("%s: %s; %s", name, domain, path);
-    }
-  }
-
-  private static class StoredCookie {
-    final Cookie cookie;
-    final boolean hostOnly;
-    final boolean persistent;
-    final long createdAt = System.currentTimeMillis();
-
-    StoredCookie(Cookie cookie, boolean hostOnly, boolean persistent) {
-      this.cookie = cookie;
-      this.hostOnly = hostOnly;
-      this.persistent = persistent;
-    }
-
-    @Override
-    public String toString() {
-      return String.format("%s; hostOnly %s; persistent %s", cookie.toString(), hostOnly, persistent);
-    }
-  }
-}
diff --git a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
index d56cac876..e86dd2fa4 100644
--- a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import java.io.IOException;
-
 import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 
+import java.io.IOException;
+
 @SuppressWarnings("serial")
 public final class ChannelClosedException extends IOException {
 
-  public static final ChannelClosedException INSTANCE = unknownStackTrace(new ChannelClosedException(), ChannelClosedException.class, "INSTANCE");
+    public static final ChannelClosedException INSTANCE = unknownStackTrace(new ChannelClosedException(), ChannelClosedException.class, "INSTANCE");
 
-  private ChannelClosedException() {
-    super("Channel closed");
-  }
+    private ChannelClosedException() {
+        super("Channel closed");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
index 3b8367089..5e1dd2df7 100644
--- a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import java.io.IOException;
-
 import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 
+import java.io.IOException;
+
 @SuppressWarnings("serial")
 public class PoolAlreadyClosedException extends IOException {
 
-  public static final PoolAlreadyClosedException INSTANCE = unknownStackTrace(new PoolAlreadyClosedException(), PoolAlreadyClosedException.class, "INSTANCE");
+    public static final PoolAlreadyClosedException INSTANCE = unknownStackTrace(new PoolAlreadyClosedException(), PoolAlreadyClosedException.class, "INSTANCE");
 
-  private PoolAlreadyClosedException() {
-    super("Pool is already closed");
-  }
+    private PoolAlreadyClosedException() {
+        super("Pool is already closed");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
index 85d9478b3..eeba6ee2d 100644
--- a/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
@@ -12,16 +12,16 @@
  */
 package org.asynchttpclient.exception;
 
-import java.io.IOException;
-
 import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 
+import java.io.IOException;
+
 @SuppressWarnings("serial")
 public final class RemotelyClosedException extends IOException {
 
-  public static final RemotelyClosedException INSTANCE = unknownStackTrace(new RemotelyClosedException(), RemotelyClosedException.class, "INSTANCE");
+    public static final RemotelyClosedException INSTANCE = unknownStackTrace(new RemotelyClosedException(), RemotelyClosedException.class, "INSTANCE");
 
-  RemotelyClosedException() {
-    super("Remotely closed");
-  }
+    public RemotelyClosedException() {
+        super("Remotely closed");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
index 6f3bc43e1..2685e3a95 100644
--- a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
@@ -17,7 +17,7 @@
 @SuppressWarnings("serial")
 public class TooManyConnectionsException extends IOException {
 
-  public TooManyConnectionsException(int max) {
-    super("Too many connections: " + max);
-  }
+    public TooManyConnectionsException(int max) {
+        super("Too many connections: " + max);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
index 2cec931b9..a08a22ee3 100644
--- a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
@@ -17,7 +17,7 @@
 @SuppressWarnings("serial")
 public class TooManyConnectionsPerHostException extends IOException {
 
-  public TooManyConnectionsPerHostException(int max) {
-    super("Too many connections: " + max);
-  }
+    public TooManyConnectionsPerHostException(int max) {
+        super("Too many connections: " + max);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
index b3d3f4761..74d64e297 100644
--- a/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
+++ b/client/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -13,12 +13,13 @@
 package org.asynchttpclient.filter;
 
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.IOException;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Request;
 
-import java.io.IOException;
-
 /**
  * A {@link FilterContext} can be used to decorate {@link Request} and {@link AsyncHandler} from a list of {@link RequestFilter}.
  * {@link RequestFilter} gets executed before the HTTP request is made to the remote server. Once the response bytes are
@@ -30,124 +31,124 @@
  * that can be used to decide if the response processing should continue or not. You can stop the current response processing
  * and replay the request but creating a {@link FilterContext}. The {@link org.asynchttpclient.AsyncHttpClient}
  * will interrupt the processing and "replay" the associated {@link Request} instance.
- *
+ * 
  * @param <T> the handler result type
  */
 public class FilterContext<T> {
 
-  private final FilterContextBuilder<T> b;
-
-  /**
-   * Create a new {@link FilterContext}
-   *
-   * @param b a {@link FilterContextBuilder}
-   */
-  private FilterContext(FilterContextBuilder<T> b) {
-    this.b = b;
-  }
-
-  /**
-   * @return the original or decorated {@link AsyncHandler}
-   */
-  public AsyncHandler<T> getAsyncHandler() {
-    return b.asyncHandler;
-  }
-
-  /**
-   * @return the original or decorated {@link Request}
-   */
-  public Request getRequest() {
-    return b.request;
-  }
-
-  /**
-   * @return the unprocessed response's {@link HttpResponseStatus}
-   */
-  public HttpResponseStatus getResponseStatus() {
-    return b.responseStatus;
-  }
-
-  /**
-   * @return the response {@link HttpHeaders}
-   */
-  public HttpHeaders getResponseHeaders() {
-    return b.headers;
-  }
-
-  /**
-   * @return true if the current response's processing needs to be interrupted and a new {@link Request} be executed.
-   */
-  public boolean replayRequest() {
-    return b.replayRequest;
-  }
-
-  /**
-   * @return the {@link IOException}
-   */
-  public IOException getIOException() {
-    return b.ioException;
-  }
-
-  public static class FilterContextBuilder<T> {
-    private AsyncHandler<T> asyncHandler = null;
-    private Request request = null;
-    private HttpResponseStatus responseStatus = null;
-    private boolean replayRequest = false;
-    private IOException ioException = null;
-    private HttpHeaders headers;
-
-    public FilterContextBuilder() {
-    }
+    private final FilterContextBuilder<T> b;
 
-    public FilterContextBuilder(FilterContext<T> clone) {
-      asyncHandler = clone.getAsyncHandler();
-      request = clone.getRequest();
-      responseStatus = clone.getResponseStatus();
-      replayRequest = clone.replayRequest();
-      ioException = clone.getIOException();
+    /**
+     * Create a new {@link FilterContext}
+     *
+     * @param b a {@link FilterContextBuilder}
+     */
+    private FilterContext(FilterContextBuilder<T> b) {
+        this.b = b;
     }
 
+    /**
+     * @return the original or decorated {@link AsyncHandler}
+     */
     public AsyncHandler<T> getAsyncHandler() {
-      return asyncHandler;
-    }
-
-    public FilterContextBuilder<T> asyncHandler(AsyncHandler<T> asyncHandler) {
-      this.asyncHandler = asyncHandler;
-      return this;
+        return b.asyncHandler;
     }
 
+    /**
+     * @return the original or decorated {@link Request}
+     */
     public Request getRequest() {
-      return request;
-    }
-
-    public FilterContextBuilder<T> request(Request request) {
-      this.request = request;
-      return this;
+        return b.request;
     }
 
-    public FilterContextBuilder<T> responseStatus(HttpResponseStatus responseStatus) {
-      this.responseStatus = responseStatus;
-      return this;
+    /**
+     * @return the unprocessed response's {@link HttpResponseStatus}
+     */
+    public HttpResponseStatus getResponseStatus() {
+        return b.responseStatus;
     }
 
-    public FilterContextBuilder<T> responseHeaders(HttpHeaders headers) {
-      this.headers = headers;
-      return this;
+    /**
+     * @return the response {@link HttpHeaders}
+     */
+    public HttpHeaders getResponseHeaders() {
+        return b.headers;
     }
 
-    public FilterContextBuilder<T> replayRequest(boolean replayRequest) {
-      this.replayRequest = replayRequest;
-      return this;
+    /**
+     * @return true if the current response's processing needs to be interrupted and a new {@link Request} be executed.
+     */
+    public boolean replayRequest() {
+        return b.replayRequest;
     }
 
-    public FilterContextBuilder<T> ioException(IOException ioException) {
-      this.ioException = ioException;
-      return this;
+    /**
+     * @return the {@link IOException}
+     */
+    public IOException getIOException() {
+        return b.ioException;
     }
 
-    public FilterContext<T> build() {
-      return new FilterContext<>(this);
+    public static class FilterContextBuilder<T> {
+        private AsyncHandler<T> asyncHandler = null;
+        private Request request = null;
+        private HttpResponseStatus responseStatus = null;
+        private boolean replayRequest = false;
+        private IOException ioException = null;
+        private HttpHeaders headers;
+
+        public FilterContextBuilder() {
+        }
+
+        public FilterContextBuilder(FilterContext<T> clone) {
+            asyncHandler = clone.getAsyncHandler();
+            request = clone.getRequest();
+            responseStatus = clone.getResponseStatus();
+            replayRequest = clone.replayRequest();
+            ioException = clone.getIOException();
+        }
+
+        public AsyncHandler<T> getAsyncHandler() {
+            return asyncHandler;
+        }
+
+        public FilterContextBuilder<T> asyncHandler(AsyncHandler<T> asyncHandler) {
+            this.asyncHandler = asyncHandler;
+            return this;
+        }
+
+        public Request getRequest() {
+            return request;
+        }
+
+        public FilterContextBuilder<T> request(Request request) {
+            this.request = request;
+            return this;
+        }
+
+        public FilterContextBuilder<T> responseStatus(HttpResponseStatus responseStatus) {
+            this.responseStatus = responseStatus;
+            return this;
+        }
+
+        public FilterContextBuilder<T> responseHeaders(HttpHeaders headers) {
+            this.headers = headers;
+            return this;
+        }
+
+        public FilterContextBuilder<T> replayRequest(boolean replayRequest) {
+            this.replayRequest = replayRequest;
+            return this;
+        }
+
+        public FilterContextBuilder<T> ioException(IOException ioException) {
+            this.ioException = ioException;
+            return this;
+        }
+
+        public FilterContext<T> build() {
+            return new FilterContext<>(this);
+        }
     }
-  }
 
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/FilterException.java b/client/src/main/java/org/asynchttpclient/filter/FilterException.java
index 75d36573f..a90cf8494 100644
--- a/client/src/main/java/org/asynchttpclient/filter/FilterException.java
+++ b/client/src/main/java/org/asynchttpclient/filter/FilterException.java
@@ -19,11 +19,11 @@
 @SuppressWarnings("serial")
 public class FilterException extends Exception {
 
-  public FilterException(final String message) {
-    super(message);
-  }
+    public FilterException(final String message) {
+        super(message);
+    }
 
-  public FilterException(final String message, final Throwable cause) {
-    super(message, cause);
-  }
+    public FilterException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java b/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
index a8ed41dba..71f45b5b4 100644
--- a/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
@@ -17,14 +17,14 @@
  */
 public interface IOExceptionFilter {
 
-  /**
-   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link IOExceptionFilter#filter} and will
-   * use the returned {@link FilterContext} to replay the {@link org.asynchttpclient.Request} or abort the processing.
-   *
-   * @param ctx a {@link FilterContext}
-   * @param <T> the handler result type
-   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-   * @throws FilterException to interrupt the filter processing.
-   */
-  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    /**
+     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link IOExceptionFilter#filter} and will
+     * use the returned {@link FilterContext} to replay the {@link org.asynchttpclient.Request} or abort the processing.
+     *
+     * @param ctx a {@link FilterContext}
+     * @param <T> the handler result type
+     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+     * @throws FilterException to interrupt the filter processing.
+     */
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java b/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
index 60abb266b..2f23cf718 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ReleasePermitOnComplete.java
@@ -1,57 +1,61 @@
 package org.asynchttpclient.filter;
 
-import org.asynchttpclient.AsyncHandler;
-
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.Semaphore;
 
+import org.asynchttpclient.AsyncHandler;
+
 /**
  * Wrapper for {@link AsyncHandler}s to release a permit on {@link AsyncHandler#onCompleted()}. This is done via a dynamic proxy to preserve all interfaces of the wrapped handler.
  */
 public class ReleasePermitOnComplete {
 
-  /**
-   * Wrap handler to release the permit of the semaphore on {@link AsyncHandler#onCompleted()}.
-   *
-   * @param handler   the handler to be wrapped
-   * @param available the Semaphore to be released when the wrapped handler is completed
-   * @param <T>       the handler result type
-   * @return the wrapped handler
-   */
-  @SuppressWarnings("unchecked")
-  public static <T> AsyncHandler<T> wrap(final AsyncHandler<T> handler, final Semaphore available) {
-    Class<?> handlerClass = handler.getClass();
-    ClassLoader classLoader = handlerClass.getClassLoader();
-    Class<?>[] interfaces = allInterfaces(handlerClass);
+    /**
+     * Wrap handler to release the permit of the semaphore on {@link AsyncHandler#onCompleted()}.
+     * 
+     * @param handler the handler to be wrapped
+     * @param available the Semaphore to be released when the wrapped handler is completed
+     * @param <T> the handler result type
+     * @return the wrapped handler
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> AsyncHandler<T> wrap(final AsyncHandler<T> handler, final Semaphore available) {
+        Class<?> handlerClass = handler.getClass();
+        ClassLoader classLoader = handlerClass.getClassLoader();
+        Class<?>[] interfaces = allInterfaces(handlerClass);
 
-    return (AsyncHandler<T>) Proxy.newProxyInstance(classLoader, interfaces, (proxy, method, args) -> {
-        try {
-          return method.invoke(handler, args);
-        } finally {
-          switch (method.getName()) {
-            case "onCompleted":
-            case "onThrowable":
-              available.release();
-            default:
-          }
-        }
-    });
-  }
+        return (AsyncHandler<T>) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() {
+            @Override
+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                try {
+                    return method.invoke(handler, args);
+                } finally {
+                    switch (method.getName()) {
+                    case "onCompleted":
+                    case "onThrowable":
+                        available.release();
+                    default:
+                    }
+                }
+            }
+        });
+    }
 
-  /**
-   * Extract all interfaces of a class.
-   *
-   * @param handlerClass the handler class
-   * @return all interfaces implemented by this class
-   */
-  private static Class<?>[] allInterfaces(Class<?> handlerClass) {
-    Set<Class<?>> allInterfaces = new HashSet<>();
-    for (Class<?> clazz = handlerClass; clazz != null; clazz = clazz.getSuperclass()) {
-      Collections.addAll(allInterfaces, clazz.getInterfaces());
+    /**
+     * Extract all interfaces of a class.
+     * @param handlerClass the handler class
+     * @return all interfaces implemented by this class
+     */
+    static Class<?>[] allInterfaces(Class<?> handlerClass) {
+        Set<Class<?>> allInterfaces = new HashSet<>();
+        for (Class<?> clazz = handlerClass; clazz != null; clazz = clazz.getSuperclass()) {
+            Collections.addAll(allInterfaces, clazz.getInterfaces());
+        }
+        return allInterfaces.toArray(new Class[allInterfaces.size()]);
     }
-    return allInterfaces.toArray(new Class[allInterfaces.size()]);
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java b/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
index ff609c585..823a662b6 100644
--- a/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/RequestFilter.java
@@ -17,15 +17,15 @@
  */
 public interface RequestFilter {
 
-  /**
-   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link RequestFilter#filter} and will use the
-   * returned {@link FilterContext#getRequest()} and {@link FilterContext#getAsyncHandler()} to continue the request
-   * processing.
-   *
-   * @param ctx a {@link FilterContext}
-   * @param <T> the handler result type
-   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-   * @throws FilterException to interrupt the filter processing.
-   */
-  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    /**
+     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link RequestFilter#filter} and will use the
+     * returned {@link FilterContext#getRequest()} and {@link FilterContext#getAsyncHandler()} to continue the request
+     * processing.
+     *
+     * @param ctx a {@link FilterContext}
+     * @param <T>  the handler result type
+     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+     * @throws FilterException to interrupt the filter processing.
+     */
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java b/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
index de508c2ad..404d9ee09 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
@@ -19,16 +19,16 @@
  */
 public interface ResponseFilter {
 
-  /**
-   * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link ResponseFilter#filter} and will use the
-   * returned {@link FilterContext#replayRequest()} and {@link FilterContext#getAsyncHandler()} to decide if the response
-   * processing can continue. If {@link FilterContext#replayRequest()} return true, a new request will be made
-   * using {@link FilterContext#getRequest()} and the current response processing will be ignored.
-   *
-   * @param ctx a {@link FilterContext}
-   * @param <T> the handler result type
-   * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
-   * @throws FilterException to interrupt the filter processing.
-   */
-  <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
+    /**
+     * An {@link org.asynchttpclient.AsyncHttpClient} will invoke {@link ResponseFilter#filter} and will use the
+     * returned {@link FilterContext#replayRequest()} and {@link FilterContext#getAsyncHandler()} to decide if the response
+     * processing can continue. If {@link FilterContext#replayRequest()} return true, a new request will be made
+     * using {@link FilterContext#getRequest()} and the current response processing will be ignored.
+     *
+     * @param ctx a {@link FilterContext}
+     * @param <T> the handler result type
+     * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
+     * @throws FilterException to interrupt the filter processing.
+     */
+    <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java b/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
index a74876971..4eb280050 100644
--- a/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
+++ b/client/src/main/java/org/asynchttpclient/filter/ThrottleRequestFilter.java
@@ -23,43 +23,43 @@
  * waiting for the response to arrives before executing the next request.
  */
 public class ThrottleRequestFilter implements RequestFilter {
-  private static final Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
-  private final Semaphore available;
-  private final int maxWait;
+    private static final Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
+    private final Semaphore available;
+    private final int maxWait;
 
-  public ThrottleRequestFilter(int maxConnections) {
-    this(maxConnections, Integer.MAX_VALUE);
-  }
-
-  public ThrottleRequestFilter(int maxConnections, int maxWait) {
-    this(maxConnections, maxWait, false);
-  }
+    public ThrottleRequestFilter(int maxConnections) {
+        this(maxConnections, Integer.MAX_VALUE);
+    }
 
-  public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
-    this.maxWait = maxWait;
-    available = new Semaphore(maxConnections, fair);
-  }
+    public ThrottleRequestFilter(int maxConnections, int maxWait) {
+        this(maxConnections, maxWait, false);
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-    try {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Current Throttling Status {}", available.availablePermits());
-      }
-      if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
-        throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
-                ctx.getRequest(), ctx.getAsyncHandler()));
-      }
-    } catch (InterruptedException e) {
-      throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s",
-              ctx.getRequest(), ctx.getAsyncHandler()));
+    public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
+        this.maxWait = maxWait;
+        available = new Semaphore(maxConnections, fair);
     }
 
-    return new FilterContext.FilterContextBuilder<>(ctx)
-            .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
-            .build();
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Current Throttling Status {}", available.availablePermits());
+            }
+            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
+                throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
+                      ctx.getRequest(), ctx.getAsyncHandler()));
+            }
+        } catch (InterruptedException e) {
+            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s",
+                  ctx.getRequest(), ctx.getAsyncHandler()));
+        }
+
+        return new FilterContext.FilterContextBuilder<>(ctx)
+              .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
+              .build();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
new file mode 100644
index 000000000..167b4003d
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import io.netty.channel.Channel;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+/**
+ * This interface hosts new low level callback methods on {@link AsyncHandler}.
+ * 
+ */
+public interface AsyncHandlerExtensions {
+
+    // ////////// DNS /////////////////
+
+    /**
+     * Notify the callback before hostname resolution
+     * 
+     * @param name the name to be resolved
+     */
+    void onHostnameResolutionAttempt(String name);
+
+    /**
+     * Notify the callback after hostname resolution was successful.
+     * 
+     * @param name the name to be resolved
+     * @param addresses the resolved addresses
+     */
+    void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses);
+
+    /**
+     * Notify the callback after hostname resolution failed.
+     * 
+     * @param name the name to be resolved
+     * @param cause the failure cause
+     */
+    void onHostnameResolutionFailure(String name, Throwable cause);
+
+    // ////////////// TCP CONNECT ////////
+
+    /**
+     * Notify the callback when trying to open a new connection.
+     * 
+     * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
+     * 
+     * @param remoteAddress the address we try to connect to
+     */
+    void onTcpConnectAttempt(InetSocketAddress remoteAddress);
+
+    /**
+     * Notify the callback after a successful connect
+     * 
+     * @param remoteAddress the address we try to connect to
+     * @param connection the connection
+     */
+    void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection);
+
+    /**
+     * Notify the callback after a failed connect.
+     * 
+     * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
+     * 
+     * @param remoteAddress the address we try to connect to
+     * @param cause the cause of the failure
+     */
+    void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause);
+
+    // ////////////// TLS ///////////////
+
+    /**
+     * Notify the callback before TLS handshake
+     */
+    void onTlsHandshakeAttempt();
+
+    /**
+     * Notify the callback after the TLS was successful
+     */
+    void onTlsHandshakeSuccess();
+
+    /**
+     * Notify the callback after the TLS failed
+     * 
+     * @param cause the cause of the failure
+     */
+    void onTlsHandshakeFailure(Throwable cause);
+
+    // /////////// POOLING /////////////
+
+    /**
+     * Notify the callback when trying to fetch a connection from the pool.
+     */
+    void onConnectionPoolAttempt();
+
+    /**
+     * Notify the callback when a new connection was successfully fetched from the pool.
+     * 
+     * @param connection the connection
+     */
+    void onConnectionPooled(Channel connection);
+
+    /**
+     * Notify the callback when trying to offer a connection to the pool.
+     * 
+     * @param connection the connection
+     */
+    void onConnectionOffer(Channel connection);
+
+    // //////////// SENDING //////////////
+
+    /**
+     * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
+     * retry, it will be notified multiple times.
+     * 
+     * @param request the real request object as passed to the provider
+     */
+    void onRequestSend(NettyRequest request);
+
+    /**
+     * Notify the callback every time a request is being retried.
+     */
+    void onRetry();
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
new file mode 100644
index 000000000..3d6f7d37f
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHandler;
+
+public final class AsyncHandlerExtensionsUtils {
+
+    public static AsyncHandlerExtensions toAsyncHandlerExtensions(AsyncHandler<?> asyncHandler) {
+        return asyncHandler instanceof AsyncHandlerExtensions ? (AsyncHandlerExtensions) asyncHandler : null;
+    }
+
+    private AsyncHandlerExtensionsUtils() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
index a4b08256d..a203ed5f6 100644
--- a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
@@ -13,10 +13,6 @@
 package org.asynchttpclient.handler;
 
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -27,6 +23,11 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+
 /**
  * An AsyncHandler that returns Response (without body, so status code and
  * headers only) as fast as possible for inspection, but leaves you the option
@@ -81,212 +82,222 @@
  */
 public class BodyDeferringAsyncHandler implements AsyncHandler<Response> {
 
-  private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
-
-  private final CountDownLatch headersArrived = new CountDownLatch(1);
-
-  private final OutputStream output;
-  private final Semaphore semaphore = new Semaphore(1);
-  private boolean responseSet;
-  private volatile Response response;
-  private volatile Throwable throwable;
-
-  public BodyDeferringAsyncHandler(final OutputStream os) {
-    this.output = os;
-    this.responseSet = false;
-  }
-
-  @Override
-  public void onThrowable(Throwable t) {
-    this.throwable = t;
-    // Counting down to handle error cases too.
-    // In "premature exceptions" cases, the onBodyPartReceived() and
-    // onCompleted()
-    // methods will never be invoked, leaving caller of getResponse() method
-    // blocked forever.
-    try {
-      semaphore.acquire();
-    } catch (InterruptedException e) {
-      // Ignore
-    } finally {
-      headersArrived.countDown();
-      semaphore.release();
-    }
+    private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
 
-    try {
-      closeOut();
-    } catch (IOException e) {
-      // ignore
-    }
-  }
-
-  @Override
-  public State onStatusReceived(HttpResponseStatus responseStatus) {
-    responseBuilder.reset();
-    responseBuilder.accumulate(responseStatus);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public State onHeadersReceived(HttpHeaders headers) {
-    responseBuilder.accumulate(headers);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) {
-    responseBuilder.accumulate(headers);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-    // body arrived, flush headers
-    if (!responseSet) {
-      response = responseBuilder.build();
-      responseSet = true;
-      headersArrived.countDown();
-    }
+    private final CountDownLatch headersArrived = new CountDownLatch(1);
 
-    output.write(bodyPart.getBodyPartBytes());
-    return State.CONTINUE;
-  }
+    private final OutputStream output;
 
-  protected void closeOut() throws IOException {
-    try {
-      output.flush();
-    } finally {
-      output.close();
-    }
-  }
+    private boolean responseSet;
+
+    private volatile Response response;
+
+    private volatile Throwable throwable;
 
-  @Override
-  public Response onCompleted() throws IOException {
+    private final Semaphore semaphore = new Semaphore(1);
 
-    if (!responseSet) {
-      response = responseBuilder.build();
-      responseSet = true;
+    public BodyDeferringAsyncHandler(final OutputStream os) {
+        this.output = os;
+        this.responseSet = false;
     }
 
-    // Counting down to handle error cases too.
-    // In "normal" cases, latch is already at 0 here
-    // But in other cases, for example when because of some error
-    // onBodyPartReceived() is never called, the caller
-    // of getResponse() would remain blocked infinitely.
-    // By contract, onCompleted() is always invoked, even in case of errors
-    headersArrived.countDown();
-
-    closeOut();
-
-    try {
-      semaphore.acquire();
-      if (throwable != null) {
-        throw new IOException(throwable);
-      } else {
-        // sending out current response
-        return responseBuilder.build();
-      }
-    } catch (InterruptedException e) {
-      return null;
-    } finally {
-      semaphore.release();
+    @Override
+    public void onThrowable(Throwable t) {
+        this.throwable = t;
+        // Counting down to handle error cases too.
+        // In "premature exceptions" cases, the onBodyPartReceived() and
+        // onCompleted()
+        // methods will never be invoked, leaving caller of getResponse() method
+        // blocked forever.
+        try {
+            semaphore.acquire();
+        } catch (InterruptedException e) {
+            // Ignore
+        } finally {
+            headersArrived.countDown();
+            semaphore.release();
+        }
+
+        try {
+            closeOut();
+        } catch (IOException e) {
+            // ignore
+        }
     }
-  }
-
-  /**
-   * This method -- unlike Future&lt;Reponse&gt;.get() -- will block only as long,
-   * as headers arrive. This is useful for large transfers, to examine headers
-   * ASAP, and defer body streaming to it's fine destination and prevent
-   * unneeded bandwidth consumption. The response here will contain the very
-   * 1st response from server, so status code and headers, but it might be
-   * incomplete in case of broken servers sending trailing headers. In that
-   * case, the "usual" Future&lt;Response&gt;.get() method will return complete
-   * headers, but multiple invocations of getResponse() will always return the
-   * 1st cached, probably incomplete one. Note: the response returned by this
-   * method will contain everything <em>except</em> the response body itself,
-   * so invoking any method like Response.getResponseBodyXXX() will result in
-   * error! Also, please not that this method might return <code>null</code>
-   * in case of some errors.
-   *
-   * @return a {@link Response}
-   * @throws InterruptedException if the latch is interrupted
-   * @throws IOException          if the handler completed with an exception
-   */
-  public Response getResponse() throws InterruptedException, IOException {
-    // block here as long as headers arrive
-    headersArrived.await();
-
-    try {
-      semaphore.acquire();
-      if (throwable != null) {
-        throw new IOException(throwable.getMessage(), throwable);
-      } else {
-        return response;
-      }
-    } finally {
-      semaphore.release();
+
+    @Override
+    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+        responseBuilder.reset();
+        responseBuilder.accumulate(responseStatus);
+        return State.CONTINUE;
     }
-  }
 
-  // ==
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        responseBuilder.accumulate(headers);
+        return State.CONTINUE;
+    }
+    
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        responseBuilder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
-  /**
-   * A simple helper class that is used to perform automatic "join" for async
-   * download and the error checking of the Future of the request.
-   */
-  public static class BodyDeferringInputStream extends FilterInputStream {
-    private final Future<Response> future;
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+        // body arrived, flush headers
+        if (!responseSet) {
+            response = responseBuilder.build();
+            responseSet = true;
+            headersArrived.countDown();
+        }
 
-    private final BodyDeferringAsyncHandler bdah;
+        output.write(bodyPart.getBodyPartBytes());
+        return State.CONTINUE;
+    }
 
-    public BodyDeferringInputStream(final Future<Response> future, final BodyDeferringAsyncHandler bdah, final InputStream in) {
-      super(in);
-      this.future = future;
-      this.bdah = bdah;
+    protected void closeOut() throws IOException {
+        try {
+            output.flush();
+        } finally {
+            output.close();
+        }
     }
 
-    /**
-     * Closes the input stream, and "joins" (wait for complete execution
-     * together with potential exception thrown) of the async request.
-     */
     @Override
-    public void close() throws IOException {
-      // close
-      super.close();
-      // "join" async request
-      try {
-        getLastResponse();
-      } catch (ExecutionException e) {
-        throw new IOException(e.getMessage(), e.getCause());
-      } catch (InterruptedException e) {
-        throw new IOException(e.getMessage(), e);
-      }
+    public Response onCompleted() throws IOException {
+
+        if (!responseSet) {
+            response = responseBuilder.build();
+            responseSet = true;
+        }
+
+        // Counting down to handle error cases too.
+        // In "normal" cases, latch is already at 0 here
+        // But in other cases, for example when because of some error
+        // onBodyPartReceived() is never called, the caller
+        // of getResponse() would remain blocked infinitely.
+        // By contract, onCompleted() is always invoked, even in case of errors
+        headersArrived.countDown();
+
+        closeOut();
+
+        try {
+            semaphore.acquire();
+            if (throwable != null) {
+                IOException ioe = new IOException(throwable.getMessage());
+                ioe.initCause(throwable);
+                throw ioe;
+            } else {
+                // sending out current response
+                return responseBuilder.build();
+            }
+        } catch (InterruptedException e) {
+            return null;
+        } finally {
+            semaphore.release();
+        }
     }
 
     /**
-     * Delegates to {@link BodyDeferringAsyncHandler#getResponse()}. Will
-     * blocks as long as headers arrives only. Might return
-     * <code>null</code>. See
-     * {@link BodyDeferringAsyncHandler#getResponse()} method for details.
+     * This method -- unlike Future&lt;Reponse&gt;.get() -- will block only as long,
+     * as headers arrive. This is useful for large transfers, to examine headers
+     * ASAP, and defer body streaming to it's fine destination and prevent
+     * unneeded bandwidth consumption. The response here will contain the very
+     * 1st response from server, so status code and headers, but it might be
+     * incomplete in case of broken servers sending trailing headers. In that
+     * case, the "usual" Future&lt;Response&gt;.get() method will return complete
+     * headers, but multiple invocations of getResponse() will always return the
+     * 1st cached, probably incomplete one. Note: the response returned by this
+     * method will contain everything <em>except</em> the response body itself,
+     * so invoking any method like Response.getResponseBodyXXX() will result in
+     * error! Also, please not that this method might return <code>null</code>
+     * in case of some errors.
      *
      * @return a {@link Response}
      * @throws InterruptedException if the latch is interrupted
-     * @throws IOException          if the handler completed with an exception
+     * @throws IOException if the handler completed with an exception
      */
-    public Response getAsapResponse() throws InterruptedException, IOException {
-      return bdah.getResponse();
+    public Response getResponse() throws InterruptedException, IOException {
+        // block here as long as headers arrive
+        headersArrived.await();
+
+        try {
+            semaphore.acquire();
+            if (throwable != null) {
+                throw new IOException(throwable.getMessage(), throwable);
+            } else {
+                return response;
+            }
+        } finally {
+            semaphore.release();
+        }
     }
 
+    // ==
+
     /**
-     * Delegates to <code>Future$lt;Response&gt;#get()</code> method. Will block
-     * as long as complete response arrives.
-     *
-     * @return a {@link Response}
-     * @throws ExecutionException   if the computation threw an exception
-     * @throws InterruptedException if the current thread was interrupted
+     * A simple helper class that is used to perform automatic "join" for async
+     * download and the error checking of the Future of the request.
      */
-    public Response getLastResponse() throws InterruptedException, ExecutionException {
-      return future.get();
+    public static class BodyDeferringInputStream extends FilterInputStream {
+        private final Future<Response> future;
+
+        private final BodyDeferringAsyncHandler bdah;
+
+        public BodyDeferringInputStream(final Future<Response> future, final BodyDeferringAsyncHandler bdah, final InputStream in) {
+            super(in);
+            this.future = future;
+            this.bdah = bdah;
+        }
+
+        /**
+         * Closes the input stream, and "joins" (wait for complete execution
+         * together with potential exception thrown) of the async request.
+         */
+        @Override
+        public void close() throws IOException {
+            // close
+            super.close();
+            // "join" async request
+            try {
+                getLastResponse();
+            } catch (ExecutionException e) {
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e.getCause());
+                throw ioe;
+            } catch (InterruptedException e) {
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e);
+                throw ioe;
+            }
+        }
+
+        /**
+         * Delegates to {@link BodyDeferringAsyncHandler#getResponse()}. Will
+         * blocks as long as headers arrives only. Might return
+         * <code>null</code>. See
+         * {@link BodyDeferringAsyncHandler#getResponse()} method for details.
+         *
+         * @return a {@link Response}
+         * @throws InterruptedException if the latch is interrupted
+         * @throws IOException if the handler completed with an exception
+         */
+        public Response getAsapResponse() throws InterruptedException, IOException {
+            return bdah.getResponse();
+        }
+
+        /**
+         * Delegates to <code>Future$lt;Response&gt;#get()</code> method. Will block
+         * as long as complete response arrives.
+         *
+         * @return a {@link Response}
+         * @throws ExecutionException if the computation threw an exception
+         * @throws InterruptedException if the current thread was interrupted
+         */
+        public Response getLastResponse() throws InterruptedException, ExecutionException {
+            return future.get();
+        }
     }
-  }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
new file mode 100644
index 000000000..6c173d4a3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import io.netty.channel.Channel;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+public abstract class ExtendedAsyncHandler<T> implements AsyncHandler<T>, AsyncHandlerExtensions {
+
+    @Override
+    public void onHostnameResolutionAttempt(String name) {
+    }
+
+    @Override
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    }
+
+    @Override
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+    }
+
+    @Override
+    public void onTcpConnectAttempt(InetSocketAddress address) {
+    }
+
+    @Override
+    public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+    }
+
+    @Override
+    public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+    }
+
+    @Override
+    public void onTlsHandshakeAttempt() {
+    }
+
+    @Override
+    public void onTlsHandshakeSuccess() {
+    }
+
+    @Override
+    public void onTlsHandshakeFailure(Throwable cause) {
+    }
+
+    @Override
+    public void onConnectionPoolAttempt() {
+    }
+
+    @Override
+    public void onConnectionPooled(Channel connection) {
+    }
+
+    @Override
+    public void onConnectionOffer(Channel connection) {
+    }
+
+    @Override
+    public void onRequestSend(NettyRequest request) {
+    }
+
+    @Override
+    public void onRetry() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
index 9deb452ef..e88882e2b 100644
--- a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
+++ b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
@@ -17,9 +17,9 @@
  * Thrown when the {@link org.asynchttpclient.DefaultAsyncHttpClientConfig#getMaxRedirects()} has been reached.
  */
 public class MaxRedirectException extends Exception {
-  private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 1L;
 
-  public MaxRedirectException(String msg) {
-    super(msg, null, true, false);
-  }
+    public MaxRedirectException(String msg) {
+        super(msg, null, true, false);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
index 556ce3006..e46fcea10 100644
--- a/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
@@ -21,30 +21,30 @@
  */
 public interface ProgressAsyncHandler<T> extends AsyncHandler<T> {
 
-  /**
-   * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
-   * written on the I/O socket.
-   *
-   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-   */
-  State onHeadersWritten();
+    /**
+     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
+     * written on the I/O socket.
+     *
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    State onHeadersWritten();
 
-  /**
-   * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
-   * written on the I/O socket.
-   *
-   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-   */
-  State onContentWritten();
+    /**
+     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
+     * written on the I/O socket.
+     *
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    State onContentWritten();
 
-  /**
-   * Invoked when the I/O operation associated with the {@link Request} body wasn't fully written in a single I/O write
-   * operation. This method is never invoked if the write operation complete in a sinfle I/O write.
-   *
-   * @param amount  The amount of bytes to transfer.
-   * @param current The amount of bytes transferred
-   * @param total   The total number of bytes transferred
-   * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
-   */
-  State onContentWriteProgress(long amount, long current, long total);
+    /**
+     * Invoked when the I/O operation associated with the {@link Request} body wasn't fully written in a single I/O write
+     * operation. This method is never invoked if the write operation complete in a sinfle I/O write.
+     *
+     * @param amount  The amount of bytes to transfer.
+     * @param current The amount of bytes transferred
+     * @param total   The total number of bytes transferred
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    State onContentWriteProgress(long amount, long current, long total);
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
index 2438cd0e7..e05ff2ddf 100644
--- a/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
@@ -21,11 +21,11 @@
  */
 public interface StreamedAsyncHandler<T> extends AsyncHandler<T> {
 
-  /**
-   * Called when the body is received. May not be called if there's no body.
-   *
-   * @param publisher The publisher of response body parts.
-   * @return Whether to continue or abort.
-   */
-  State onStream(Publisher<HttpResponseBodyPart> publisher);
+    /**
+     * Called when the body is received. May not be called if there's no body.
+     *
+     * @param publisher The publisher of response body parts.
+     * @return Whether to continue or abort.
+     */
+    State onStream(Publisher<HttpResponseBodyPart> publisher);
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java b/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
index d3baff0ca..ae0eeb943 100644
--- a/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
@@ -13,188 +13,192 @@
 package org.asynchttpclient.handler;
 
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.concurrent.ConcurrentLinkedQueue;
-
 /**
  * A {@link org.asynchttpclient.AsyncHandler} that can be used to notify a set of {@link TransferListener}
  * <br>
  * <blockquote>
+ * 
  * <pre>
  * AsyncHttpClient client = new AsyncHttpClient();
  * TransferCompletionHandler tl = new TransferCompletionHandler();
  * tl.addTransferListener(new TransferListener() {
- *
+ * 
  * public void onRequestHeadersSent(HttpHeaders headers) {
  * }
- *
+ * 
  * public void onResponseHeadersReceived(HttpHeaders headers) {
  * }
- *
+ * 
  * public void onBytesReceived(ByteBuffer buffer) {
  * }
- *
+ * 
  * public void onBytesSent(long amount, long current, long total) {
  * }
- *
+ * 
  * public void onRequestResponseCompleted() {
  * }
- *
+ * 
  * public void onThrowable(Throwable t) {
  * }
  * });
- *
+ * 
  * Response response = httpClient.prepareGet("http://...").execute(tl).get();
  * </pre>
+ * 
  * </blockquote>
  */
 public class TransferCompletionHandler extends AsyncCompletionHandlerBase {
-  private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
-  private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<>();
-  private final boolean accumulateResponseBytes;
-  private HttpHeaders headers;
-
-  /**
-   * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
-   * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} will throw an IllegalStateException if called.
-   */
-  public TransferCompletionHandler() {
-    this(false);
-  }
-
-  /**
-   * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when {@link org.asynchttpclient.Response#getResponseBody()} get called. The
-   * default is false.
-   *
-   * @param accumulateResponseBytes true to accumulates bytes in memory.
-   */
-  public TransferCompletionHandler(boolean accumulateResponseBytes) {
-    this.accumulateResponseBytes = accumulateResponseBytes;
-  }
-
-  public TransferCompletionHandler addTransferListener(TransferListener t) {
-    listeners.offer(t);
-    return this;
-  }
-
-  public TransferCompletionHandler removeTransferListener(TransferListener t) {
-    listeners.remove(t);
-    return this;
-  }
-
-  public void headers(HttpHeaders headers) {
-    this.headers = headers;
-  }
-
-  @Override
-  public State onHeadersReceived(final HttpHeaders headers) throws Exception {
-    fireOnHeaderReceived(headers);
-    return super.onHeadersReceived(headers);
-  }
-
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-    fireOnHeaderReceived(headers);
-    return super.onHeadersReceived(headers);
-  }
-
-  @Override
-  public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-    State s = State.CONTINUE;
-    if (accumulateResponseBytes) {
-      s = super.onBodyPartReceived(content);
-    }
-    fireOnBytesReceived(content.getBodyPartBytes());
-    return s;
-  }
-
-  @Override
-  public Response onCompleted(Response response) throws Exception {
-    fireOnEnd();
-    return response;
-  }
-
-  @Override
-  public State onHeadersWritten() {
-    if (headers != null) {
-      fireOnHeadersSent(headers);
-    }
-    return State.CONTINUE;
-  }
-
-  @Override
-  public State onContentWriteProgress(long amount, long current, long total) {
-    fireOnBytesSent(amount, current, total);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public void onThrowable(Throwable t) {
-    fireOnThrowable(t);
-  }
-
-  private void fireOnHeadersSent(HttpHeaders headers) {
-    for (TransferListener l : listeners) {
-      try {
-        l.onRequestHeadersSent(headers);
-      } catch (Throwable t) {
-        l.onThrowable(t);
-      }
-    }
-  }
-
-  private void fireOnHeaderReceived(HttpHeaders headers) {
-    for (TransferListener l : listeners) {
-      try {
-        l.onResponseHeadersReceived(headers);
-      } catch (Throwable t) {
-        l.onThrowable(t);
-      }
-    }
-  }
-
-  private void fireOnEnd() {
-    for (TransferListener l : listeners) {
-      try {
-        l.onRequestResponseCompleted();
-      } catch (Throwable t) {
-        l.onThrowable(t);
-      }
-    }
-  }
-
-  private void fireOnBytesReceived(byte[] b) {
-    for (TransferListener l : listeners) {
-      try {
-        l.onBytesReceived(b);
-      } catch (Throwable t) {
-        l.onThrowable(t);
-      }
-    }
-  }
-
-  private void fireOnBytesSent(long amount, long current, long total) {
-    for (TransferListener l : listeners) {
-      try {
-        l.onBytesSent(amount, current, total);
-      } catch (Throwable t) {
-        l.onThrowable(t);
-      }
-    }
-  }
-
-  private void fireOnThrowable(Throwable t) {
-    for (TransferListener l : listeners) {
-      try {
-        l.onThrowable(t);
-      } catch (Throwable t2) {
-        logger.warn("onThrowable", t2);
-      }
-    }
-  }
+    private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
+    private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<>();
+    private final boolean accumulateResponseBytes;
+    private HttpHeaders headers;
+
+    /**
+     * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
+     * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} will throw an IllegalStateException if called.
+     */
+    public TransferCompletionHandler() {
+        this(false);
+    }
+
+    /**
+     * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when {@link org.asynchttpclient.Response#getResponseBody()} get called. The
+     * default is false.
+     * 
+     * @param accumulateResponseBytes
+     *            true to accumulates bytes in memory.
+     */
+    public TransferCompletionHandler(boolean accumulateResponseBytes) {
+        this.accumulateResponseBytes = accumulateResponseBytes;
+    }
+
+    public TransferCompletionHandler addTransferListener(TransferListener t) {
+        listeners.offer(t);
+        return this;
+    }
+
+    public TransferCompletionHandler removeTransferListener(TransferListener t) {
+        listeners.remove(t);
+        return this;
+    }
+
+    public void headers(HttpHeaders headers) {
+        this.headers = headers;
+    }
+
+    @Override
+    public State onHeadersReceived(final HttpHeaders headers) throws Exception {
+        fireOnHeaderReceived(headers);
+        return super.onHeadersReceived(headers);
+    }
+    
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        fireOnHeaderReceived(headers);
+        return super.onHeadersReceived(headers);
+    }
+
+    @Override
+    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+        State s = State.CONTINUE;
+        if (accumulateResponseBytes) {
+            s = super.onBodyPartReceived(content);
+        }
+        fireOnBytesReceived(content.getBodyPartBytes());
+        return s;
+    }
+
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+        fireOnEnd();
+        return response;
+    }
+
+    @Override
+    public State onHeadersWritten() {
+        if (headers != null) {
+            fireOnHeadersSent(headers);
+        }
+        return State.CONTINUE;
+    }
+
+    @Override
+    public State onContentWriteProgress(long amount, long current, long total) {
+        fireOnBytesSent(amount, current, total);
+        return State.CONTINUE;
+    }
+
+    @Override
+    public void onThrowable(Throwable t) {
+        fireOnThrowable(t);
+    }
+
+    private void fireOnHeadersSent(HttpHeaders headers) {
+        for (TransferListener l : listeners) {
+            try {
+                l.onRequestHeadersSent(headers);
+            } catch (Throwable t) {
+                l.onThrowable(t);
+            }
+        }
+    }
+
+    private void fireOnHeaderReceived(HttpHeaders headers) {
+        for (TransferListener l : listeners) {
+            try {
+                l.onResponseHeadersReceived(headers);
+            } catch (Throwable t) {
+                l.onThrowable(t);
+            }
+        }
+    }
+
+    private void fireOnEnd() {
+        for (TransferListener l : listeners) {
+            try {
+                l.onRequestResponseCompleted();
+            } catch (Throwable t) {
+                l.onThrowable(t);
+            }
+        }
+    }
+
+    private void fireOnBytesReceived(byte[] b) {
+        for (TransferListener l : listeners) {
+            try {
+                l.onBytesReceived(b);
+            } catch (Throwable t) {
+                l.onThrowable(t);
+            }
+        }
+    }
+
+    private void fireOnBytesSent(long amount, long current, long total) {
+        for (TransferListener l : listeners) {
+            try {
+                l.onBytesSent(amount, current, total);
+            } catch (Throwable t) {
+                l.onThrowable(t);
+            }
+        }
+    }
+
+    private void fireOnThrowable(Throwable t) {
+        for (TransferListener l : listeners) {
+            try {
+                l.onThrowable(t);
+            } catch (Throwable t2) {
+                logger.warn("onThrowable", t2);
+            }
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/TransferListener.java b/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
index b733d5d40..f9b81fb80 100644
--- a/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/TransferListener.java
@@ -19,46 +19,46 @@
  */
 public interface TransferListener {
 
-  /**
-   * Invoked when the request bytes are starting to get send.
-   *
-   * @param headers the headers
-   */
-  void onRequestHeadersSent(HttpHeaders headers);
+    /**
+     * Invoked when the request bytes are starting to get send.
+     * 
+     * @param headers the headers
+     */
+    void onRequestHeadersSent(HttpHeaders headers);
 
-  /**
-   * Invoked when the response bytes are starting to get received.
-   *
-   * @param headers the headers
-   */
-  void onResponseHeadersReceived(HttpHeaders headers);
+    /**
+     * Invoked when the response bytes are starting to get received.
+     * 
+     * @param headers the headers
+     */
+    void onResponseHeadersReceived(HttpHeaders headers);
 
-  /**
-   * Invoked every time response's chunk are received.
-   *
-   * @param bytes a {@link byte[]}
-   */
-  void onBytesReceived(byte[] bytes);
+    /**
+     * Invoked every time response's chunk are received.
+     *
+     * @param bytes a {@link byte[]}
+     */
+    void onBytesReceived(byte[] bytes);
 
-  /**
-   * Invoked every time request's chunk are sent.
-   *
-   * @param amount  The amount of bytes to transfer
-   * @param current The amount of bytes transferred
-   * @param total   The total number of bytes transferred
-   */
-  void onBytesSent(long amount, long current, long total);
+    /**
+     * Invoked every time request's chunk are sent.
+     *
+     * @param amount  The amount of bytes to transfer
+     * @param current The amount of bytes transferred
+     * @param total   The total number of bytes transferred
+     */
+    void onBytesSent(long amount, long current, long total);
 
-  /**
-   * Invoked when the response bytes are been fully received.
-   */
-  void onRequestResponseCompleted();
+    /**
+     * Invoked when the response bytes are been fully received.
+     */
+    void onRequestResponseCompleted();
 
-  /**
-   * Invoked when there is an unexpected issue.
-   *
-   * @param t a {@link Throwable}
-   */
-  void onThrowable(Throwable t);
+    /**
+     * Invoked when there is an unexpected issue.
+     *
+     * @param t a {@link Throwable}
+     */
+    void onThrowable(Throwable t);
 }
 
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java b/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
index 1eb99f11b..8540fc191 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
@@ -12,8 +12,8 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -23,100 +23,100 @@
 import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A {@link org.asynchttpclient.handler.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
  * to store the download index information.
  */
 public class PropertiesBasedResumableProcessor implements ResumableAsyncHandler.ResumableProcessor {
-  private final static Logger log = LoggerFactory.getLogger(PropertiesBasedResumableProcessor.class);
-  private final static File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc");
-  private final static String storeName = "ResumableAsyncHandler.properties";
-  private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<>();
-
-  private static String append(Map.Entry<String, Long> e) {
-    return e.getKey() + '=' + e.getValue() + '\n';
-  }
+    private final static Logger log = LoggerFactory.getLogger(PropertiesBasedResumableProcessor.class);
+    private final static File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc");
+    private final static String storeName = "ResumableAsyncHandler.properties";
+    private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<>();
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void put(String url, long transferredBytes) {
-    properties.put(url, transferredBytes);
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void put(String url, long transferredBytes) {
+        properties.put(url, transferredBytes);
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void remove(String uri) {
-    if (uri != null) {
-      properties.remove(uri);
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove(String uri) {
+        if (uri != null) {
+            properties.remove(uri);
+        }
     }
-  }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void save(Map<String, Long> map) {
-    log.debug("Saving current download state {}", properties.toString());
-    OutputStream os = null;
-    try {
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void save(Map<String, Long> map) {
+        log.debug("Saving current download state {}", properties.toString());
+        OutputStream os = null;
+        try {
+
+            if (!TMP.exists() && !TMP.mkdirs()) {
+                throw new IllegalStateException("Unable to create directory: " + TMP.getAbsolutePath());
+            }
+            File f = new File(TMP, storeName);
+            if (!f.exists() && !f.createNewFile()) {
+                throw new IllegalStateException("Unable to create temp file: " + f.getAbsolutePath());
+            }
+            if (!f.canWrite()) {
+                throw new IllegalStateException();
+            }
 
-      if (!TMP.exists() && !TMP.mkdirs()) {
-        throw new IllegalStateException("Unable to create directory: " + TMP.getAbsolutePath());
-      }
-      File f = new File(TMP, storeName);
-      if (!f.exists() && !f.createNewFile()) {
-        throw new IllegalStateException("Unable to create temp file: " + f.getAbsolutePath());
-      }
-      if (!f.canWrite()) {
-        throw new IllegalStateException();
-      }
+            os = Files.newOutputStream(f.toPath());
+            for (Map.Entry<String, Long> e : properties.entrySet()) {
+                os.write(append(e).getBytes(UTF_8));
+            }
+            os.flush();
+        } catch (Throwable e) {
+            log.warn(e.getMessage(), e);
+        } finally {
+            closeSilently(os);
+        }
+    }
 
-      os = Files.newOutputStream(f.toPath());
-      for (Map.Entry<String, Long> e : properties.entrySet()) {
-        os.write(append(e).getBytes(UTF_8));
-      }
-      os.flush();
-    } catch (Throwable e) {
-      log.warn(e.getMessage(), e);
-    } finally {
-      closeSilently(os);
+    private static String append(Map.Entry<String, Long> e) {
+        return new StringBuilder(e.getKey()).append('=').append(e.getValue()).append('\n').toString();
     }
-  }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public Map<String, Long> load() {
-    Scanner scan = null;
-    try {
-      scan = new Scanner(new File(TMP, storeName), UTF_8.name());
-      scan.useDelimiter("[=\n]");
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Map<String, Long> load() {
+        Scanner scan = null;
+        try {
+            scan = new Scanner(new File(TMP, storeName), UTF_8.name());
+            scan.useDelimiter("[=\n]");
 
-      String key;
-      String value;
-      while (scan.hasNext()) {
-        key = scan.next().trim();
-        value = scan.next().trim();
-        properties.put(key, Long.valueOf(value));
-      }
-      log.debug("Loading previous download state {}", properties.toString());
-    } catch (FileNotFoundException ex) {
-      log.debug("Missing {}", storeName);
-    } catch (Throwable ex) {
-      // Survive any exceptions
-      log.warn(ex.getMessage(), ex);
-    } finally {
-      if (scan != null)
-        scan.close();
+            String key;
+            String value;
+            while (scan.hasNext()) {
+                key = scan.next().trim();
+                value = scan.next().trim();
+                properties.put(key, Long.valueOf(value));
+            }
+            log.debug("Loading previous download state {}", properties.toString());
+        } catch (FileNotFoundException ex) {
+            log.debug("Missing {}", storeName);
+        } catch (Throwable ex) {
+            // Survive any exceptions
+            log.warn(ex.getMessage(), ex);
+        } finally {
+            if (scan != null)
+                scan.close();
+        }
+        return properties;
     }
-    return properties;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
index 399638fbb..1a5274fab 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
@@ -12,12 +12,8 @@
  */
 package org.asynchttpclient.handler.resumable;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.*;
-import org.asynchttpclient.Response.ResponseBuilder;
-import org.asynchttpclient.handler.TransferCompletionHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -26,8 +22,16 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderNames.RANGE;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.Response.ResponseBuilder;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * An {@link AsyncHandler} which support resumable download, e.g when used with an {@link ResumableIOExceptionFilter},
@@ -36,271 +40,271 @@
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <br>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
- * <p>
+ * 
  * Beware that it registers a shutdown hook, that will cause a ClassLoader leak when used in an appserver and only redeploying the application.
  */
 public class ResumableAsyncHandler implements AsyncHandler<Response> {
-  private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
-  private final static ResumableIndexThread resumeIndexThread = new ResumableIndexThread();
-  private static Map<String, Long> resumableIndex;
-  private final AtomicLong byteTransferred;
-  private final ResumableProcessor resumableProcessor;
-  private final AsyncHandler<Response> decoratedAsyncHandler;
-  private final boolean accumulateBody;
-  private String url;
-  private ResponseBuilder responseBuilder = new ResponseBuilder();
-  private ResumableListener resumableListener = new NULLResumableListener();
-
-  private ResumableAsyncHandler(long byteTransferred, ResumableProcessor resumableProcessor,
-                                AsyncHandler<Response> decoratedAsyncHandler, boolean accumulateBody) {
-
-    this.byteTransferred = new AtomicLong(byteTransferred);
-
-    if (resumableProcessor == null) {
-      resumableProcessor = new NULLResumableHandler();
-    }
-    this.resumableProcessor = resumableProcessor;
-
-    resumableIndex = resumableProcessor.load();
-    resumeIndexThread.addResumableProcessor(resumableProcessor);
-
-    this.decoratedAsyncHandler = decoratedAsyncHandler;
-    this.accumulateBody = accumulateBody;
-  }
-
-  public ResumableAsyncHandler(long byteTransferred) {
-    this(byteTransferred, null, null, false);
-  }
-
-  public ResumableAsyncHandler(boolean accumulateBody) {
-    this(0, null, null, accumulateBody);
-  }
-
-  public ResumableAsyncHandler() {
-    this(0, null, null, false);
-  }
-
-  public ResumableAsyncHandler(AsyncHandler<Response> decoratedAsyncHandler) {
-    this(0, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
-  }
-
-  public ResumableAsyncHandler(long byteTransferred, AsyncHandler<Response> decoratedAsyncHandler) {
-    this(byteTransferred, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
-  }
-
-  public ResumableAsyncHandler(ResumableProcessor resumableProcessor) {
-    this(0, resumableProcessor, null, false);
-  }
-
-  public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accumulateBody) {
-    this(0, resumableProcessor, null, accumulateBody);
-  }
-
-  @Override
-  public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-    responseBuilder.accumulate(status);
-    if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
-      url = status.getUri().toUrl();
-    } else {
-      return AsyncHandler.State.ABORT;
+    private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
+    private final AtomicLong byteTransferred;
+    private String url;
+    private final ResumableProcessor resumableProcessor;
+    private final AsyncHandler<Response> decoratedAsyncHandler;
+    private static Map<String, Long> resumableIndex;
+    private final static ResumableIndexThread resumeIndexThread = new ResumableIndexThread();
+    private ResponseBuilder responseBuilder = new ResponseBuilder();
+    private final boolean accumulateBody;
+    private ResumableListener resumableListener = new NULLResumableListener();
+
+    private ResumableAsyncHandler(long byteTransferred, ResumableProcessor resumableProcessor,
+            AsyncHandler<Response> decoratedAsyncHandler, boolean accumulateBody) {
+
+        this.byteTransferred = new AtomicLong(byteTransferred);
+
+        if (resumableProcessor == null) {
+            resumableProcessor = new NULLResumableHandler();
+        }
+        this.resumableProcessor = resumableProcessor;
+
+        resumableIndex = resumableProcessor.load();
+        resumeIndexThread.addResumableProcessor(resumableProcessor);
+
+        this.decoratedAsyncHandler = decoratedAsyncHandler;
+        this.accumulateBody = accumulateBody;
     }
 
-    if (decoratedAsyncHandler != null) {
-      return decoratedAsyncHandler.onStatusReceived(status);
+    public ResumableAsyncHandler(long byteTransferred) {
+        this(byteTransferred, null, null, false);
     }
 
-    return AsyncHandler.State.CONTINUE;
-  }
-
-  @Override
-  public void onThrowable(Throwable t) {
-    if (decoratedAsyncHandler != null) {
-      decoratedAsyncHandler.onThrowable(t);
-    } else {
-      logger.debug("", t);
+    public ResumableAsyncHandler(boolean accumulateBody) {
+        this(0, null, null, accumulateBody);
     }
-  }
 
-  @Override
-  public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    public ResumableAsyncHandler() {
+        this(0, null, null, false);
+    }
 
-    if (accumulateBody) {
-      responseBuilder.accumulate(bodyPart);
+    public ResumableAsyncHandler(AsyncHandler<Response> decoratedAsyncHandler) {
+        this(0, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
     }
 
-    State state = State.CONTINUE;
-    try {
-      resumableListener.onBytesReceived(bodyPart.getBodyByteBuffer());
-    } catch (IOException ex) {
-      return AsyncHandler.State.ABORT;
+    public ResumableAsyncHandler(long byteTransferred, AsyncHandler<Response> decoratedAsyncHandler) {
+        this(byteTransferred, new PropertiesBasedResumableProcessor(), decoratedAsyncHandler, false);
     }
 
-    if (decoratedAsyncHandler != null) {
-      state = decoratedAsyncHandler.onBodyPartReceived(bodyPart);
+    public ResumableAsyncHandler(ResumableProcessor resumableProcessor) {
+        this(0, resumableProcessor, null, false);
     }
 
-    byteTransferred.addAndGet(bodyPart.getBodyPartBytes().length);
-    resumableProcessor.put(url, byteTransferred.get());
+    public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accumulateBody) {
+        this(0, resumableProcessor, null, accumulateBody);
+    }
 
-    return state;
-  }
+    @Override
+    public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+        responseBuilder.accumulate(status);
+        if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
+            url = status.getUri().toUrl();
+        } else {
+            return AsyncHandler.State.ABORT;
+        }
 
-  @Override
-  public Response onCompleted() throws Exception {
-    resumableProcessor.remove(url);
-    resumableListener.onAllBytesReceived();
+        if (decoratedAsyncHandler != null) {
+            return decoratedAsyncHandler.onStatusReceived(status);
+        }
 
-    if (decoratedAsyncHandler != null) {
-      decoratedAsyncHandler.onCompleted();
-    }
-    // Not sure
-    return responseBuilder.build();
-  }
-
-  @Override
-  public State onHeadersReceived(HttpHeaders headers) throws Exception {
-    responseBuilder.accumulate(headers);
-    String contentLengthHeader = headers.get(CONTENT_LENGTH);
-    if (contentLengthHeader != null) {
-      if (Long.parseLong(contentLengthHeader) == -1L) {
-        return AsyncHandler.State.ABORT;
-      }
+        return AsyncHandler.State.CONTINUE;
     }
 
-    if (decoratedAsyncHandler != null) {
-      return decoratedAsyncHandler.onHeadersReceived(headers);
-    }
-    return State.CONTINUE;
-  }
-
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) {
-    responseBuilder.accumulate(headers);
-    return State.CONTINUE;
-  }
-
-  /**
-   * Invoke this API if you want to set the Range header on your {@link Request} based on the last valid bytes
-   * position.
-   *
-   * @param request {@link Request}
-   * @return a {@link Request} with the Range header properly set.
-   */
-  public Request adjustRequestRange(Request request) {
-
-    Long ri = resumableIndex.get(request.getUrl());
-    if (ri != null) {
-      byteTransferred.set(ri);
+    @Override
+    public void onThrowable(Throwable t) {
+        if (decoratedAsyncHandler != null) {
+            decoratedAsyncHandler.onThrowable(t);
+        } else {
+            logger.debug("", t);
+        }
     }
 
-    // The Resumable
-    if (resumableListener != null && resumableListener.length() > 0 && byteTransferred.get() != resumableListener.length()) {
-      byteTransferred.set(resumableListener.length());
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+
+        if (accumulateBody) {
+            responseBuilder.accumulate(bodyPart);
+        }
+
+        State state = State.CONTINUE;
+        try {
+            resumableListener.onBytesReceived(bodyPart.getBodyByteBuffer());
+        } catch (IOException ex) {
+            return AsyncHandler.State.ABORT;
+        }
+
+        if (decoratedAsyncHandler != null) {
+            state = decoratedAsyncHandler.onBodyPartReceived(bodyPart);
+        }
+
+        byteTransferred.addAndGet(bodyPart.getBodyPartBytes().length);
+        resumableProcessor.put(url, byteTransferred.get());
+
+        return state;
     }
 
-    RequestBuilder builder = new RequestBuilder(request);
-    if (request.getHeaders().get(RANGE) == null && byteTransferred.get() != 0) {
-      builder.setHeader(RANGE, "bytes=" + byteTransferred.get() + "-");
+    @Override
+    public Response onCompleted() throws Exception {
+        resumableProcessor.remove(url);
+        resumableListener.onAllBytesReceived();
+
+        if (decoratedAsyncHandler != null) {
+            decoratedAsyncHandler.onCompleted();
+        }
+        // Not sure
+        return responseBuilder.build();
     }
-    return builder.build();
-  }
-
-  /**
-   * Set a {@link ResumableListener}
-   *
-   * @param resumableListener a {@link ResumableListener}
-   * @return this
-   */
-  public ResumableAsyncHandler setResumableListener(ResumableListener resumableListener) {
-    this.resumableListener = resumableListener;
-    return this;
-  }
-
-  /**
-   * An interface to implement in order to manage the way the incomplete file management are handled.
-   */
-  public interface ResumableProcessor {
 
-    /**
-     * Associate a key with the number of bytes successfully transferred.
-     *
-     * @param key              a key. The recommended way is to use an url.
-     * @param transferredBytes The number of bytes successfully transferred.
-     */
-    void put(String key, long transferredBytes);
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        responseBuilder.accumulate(headers);
+        String contentLengthHeader = headers.get(CONTENT_LENGTH);
+        if (contentLengthHeader != null) {
+            if (Long.parseLong(contentLengthHeader) == -1L) {
+                return AsyncHandler.State.ABORT;
+            }
+        }
+
+        if (decoratedAsyncHandler != null) {
+            return decoratedAsyncHandler.onHeadersReceived(headers);
+        }
+        return State.CONTINUE;
+    }
+    
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        responseBuilder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
     /**
-     * Remove the key associate value.
+     * Invoke this API if you want to set the Range header on your {@link Request} based on the last valid bytes
+     * position.
      *
-     * @param key key from which the value will be discarded
+     * @param request {@link Request}
+     * @return a {@link Request} with the Range header properly set.
      */
-    void remove(String key);
+    public Request adjustRequestRange(Request request) {
+
+        Long ri = resumableIndex.get(request.getUrl());
+        if (ri != null) {
+            byteTransferred.set(ri);
+        }
+
+        // The Resumable
+        if (resumableListener != null && resumableListener.length() > 0 && byteTransferred.get() != resumableListener.length()) {
+            byteTransferred.set(resumableListener.length());
+        }
+
+        RequestBuilder builder = new RequestBuilder(request);
+        if (request.getHeaders().get(RANGE) == null && byteTransferred.get() != 0) {
+            builder.setHeader(RANGE, "bytes=" + byteTransferred.get() + "-");
+        }
+        return builder.build();
+    }
 
     /**
-     * Save the current {@link Map} instance which contains information about the current transfer state.
-     * This method *only* invoked when the JVM is shutting down.
+     * Set a {@link ResumableListener}
      *
-     * @param map the current transfer state
+     * @param resumableListener a {@link ResumableListener}
+     * @return this
      */
-    void save(Map<String, Long> map);
+    public ResumableAsyncHandler setResumableListener(ResumableListener resumableListener) {
+        this.resumableListener = resumableListener;
+        return this;
+    }
 
-    /**
-     * Load the {@link Map} in memory, contains information about the transferred bytes.
-     *
-     * @return {@link Map} current transfer state
-     */
-    Map<String, Long> load();
+    private static class ResumableIndexThread extends Thread {
 
-  }
+        public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<>();
 
-  private static class ResumableIndexThread extends Thread {
+        public ResumableIndexThread() {
+            Runtime.getRuntime().addShutdownHook(this);
+        }
 
-    public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<>();
+        public void addResumableProcessor(ResumableProcessor p) {
+            resumableProcessors.offer(p);
+        }
 
-    public ResumableIndexThread() {
-      Runtime.getRuntime().addShutdownHook(this);
+        public void run() {
+            for (ResumableProcessor p : resumableProcessors) {
+                p.save(resumableIndex);
+            }
+        }
     }
 
-    public void addResumableProcessor(ResumableProcessor p) {
-      resumableProcessors.offer(p);
-    }
+    /**
+     * An interface to implement in order to manage the way the incomplete file management are handled.
+     */
+    public interface ResumableProcessor {
+
+        /**
+         * Associate a key with the number of bytes successfully transferred.
+         *
+         * @param key              a key. The recommended way is to use an url.
+         * @param transferredBytes The number of bytes successfully transferred.
+         */
+        void put(String key, long transferredBytes);
+
+        /**
+         * Remove the key associate value.
+         *
+         * @param key key from which the value will be discarded
+         */
+        void remove(String key);
+
+        /**
+         * Save the current {@link Map} instance which contains information about the current transfer state.
+         * This method *only* invoked when the JVM is shutting down.
+         *
+         * @param map the current transfer state
+         */
+        void save(Map<String, Long> map);
+
+        /**
+         * Load the {@link Map} in memory, contains information about the transferred bytes.
+         *
+         * @return {@link Map} current transfer state
+         */
+        Map<String, Long> load();
 
-    public void run() {
-      for (ResumableProcessor p : resumableProcessors) {
-        p.save(resumableIndex);
-      }
     }
-  }
 
-  private static class NULLResumableHandler implements ResumableProcessor {
+    private static class NULLResumableHandler implements ResumableProcessor {
 
-    public void put(String url, long transferredBytes) {
-    }
+        public void put(String url, long transferredBytes) {
+        }
 
-    public void remove(String uri) {
-    }
+        public void remove(String uri) {
+        }
 
-    public void save(Map<String, Long> map) {
-    }
+        public void save(Map<String, Long> map) {
+        }
 
-    public Map<String, Long> load() {
-      return new HashMap<>();
+        public Map<String, Long> load() {
+            return new HashMap<>();
+        }
     }
-  }
 
-  private static class NULLResumableListener implements ResumableListener {
+    private static class NULLResumableListener implements ResumableListener {
 
-    private long length = 0L;
+        private long length = 0L;
 
-    public void onBytesReceived(ByteBuffer byteBuffer) {
-      length += byteBuffer.remaining();
-    }
+        public void onBytesReceived(ByteBuffer byteBuffer) throws IOException {
+            length += byteBuffer.remaining();
+        }
 
-    public void onAllBytesReceived() {
-    }
+        public void onAllBytesReceived() {
+        }
 
-    public long length() {
-      return length;
+        public long length() {
+            return length;
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
index 948bb6649..c87867499 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
@@ -14,19 +14,20 @@
 
 import org.asynchttpclient.Request;
 import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
 
 /**
  * Simple {@link org.asynchttpclient.filter.IOExceptionFilter} that replay the current {@link org.asynchttpclient.Request} using a {@link ResumableAsyncHandler}
  */
 public class ResumableIOExceptionFilter implements IOExceptionFilter {
-  public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-    if (ctx.getIOException() != null && ctx.getAsyncHandler() instanceof ResumableAsyncHandler) {
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+        if (ctx.getIOException() != null && ctx.getAsyncHandler() instanceof ResumableAsyncHandler) {
 
-      Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
+            Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
 
-      return new FilterContext.FilterContextBuilder<>(ctx).request(request).replayRequest(true).build();
+            return new FilterContext.FilterContextBuilder<>(ctx).request(request).replayRequest(true).build();
+        }
+        return ctx;
     }
-    return ctx;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
index 4e36d7430..68261f6af 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
@@ -20,23 +20,23 @@
  */
 public interface ResumableListener {
 
-  /**
-   * Invoked when some bytes are available to digest.
-   *
-   * @param byteBuffer the current bytes
-   * @throws IOException exception while writing the byteBuffer
-   */
-  void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
+    /**
+     * Invoked when some bytes are available to digest.
+     *
+     * @param byteBuffer the current bytes
+     * @throws IOException exception while writing the byteBuffer
+     */
+    void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
 
-  /**
-   * Invoked when all the bytes has been sucessfully transferred.
-   */
-  void onAllBytesReceived();
+    /**
+     * Invoked when all the bytes has been sucessfully transferred.
+     */
+    void onAllBytesReceived();
 
-  /**
-   * Return the length of previously downloaded bytes.
-   *
-   * @return the length of previously downloaded bytes
-   */
-  long length();
+    /**
+     * Return the length of previously downloaded bytes.
+     *
+     * @return the length of previously downloaded bytes
+     */
+    long length();
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
index 918a2b938..3fc4adecc 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListener.java
@@ -12,57 +12,57 @@
  */
 package org.asynchttpclient.handler.resumable;
 
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
 /**
  * A {@link org.asynchttpclient.handler.resumable.ResumableListener} which use a {@link RandomAccessFile} for storing the received bytes.
  */
 public class ResumableRandomAccessFileListener implements ResumableListener {
-  private final RandomAccessFile file;
+    private final RandomAccessFile file;
 
-  public ResumableRandomAccessFileListener(RandomAccessFile file) {
-    this.file = file;
-  }
+    public ResumableRandomAccessFileListener(RandomAccessFile file) {
+        this.file = file;
+    }
 
-  /**
-   * This method uses the last valid bytes written on disk to position a {@link RandomAccessFile}, allowing
-   * resumable file download.
-   *
-   * @param buffer a {@link ByteBuffer}
-   * @throws IOException exception while writing into the file
-   */
-  public void onBytesReceived(ByteBuffer buffer) throws IOException {
-    file.seek(file.length());
-    if (buffer.hasArray()) {
-      file.write(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
-    } else { // if the buffer is direct or backed by a String...
-      byte[] b = new byte[buffer.remaining()];
-      int pos = buffer.position();
-      buffer.get(b);
-      buffer.position(pos);
-      file.write(b);
+    /**
+     * This method uses the last valid bytes written on disk to position a {@link RandomAccessFile}, allowing
+     * resumable file download.
+     *
+     * @param buffer a {@link ByteBuffer}
+     * @throws IOException exception while writing into the file
+     */
+    public void onBytesReceived(ByteBuffer buffer) throws IOException {
+        file.seek(file.length());
+        if (buffer.hasArray()) {
+            file.write(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
+        } else { // if the buffer is direct or backed by a String...
+            byte[] b = new byte[buffer.remaining()];
+            int pos = buffer.position();
+            buffer.get(b);
+            buffer.position(pos);
+            file.write(b);
+        }
     }
-  }
 
-  /**
-   * {@inheritDoc}
-   */
-  public void onAllBytesReceived() {
-    closeSilently(file);
-  }
+    /**
+     * {@inheritDoc}
+     */
+    public void onAllBytesReceived() {
+        closeSilently(file);
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  public long length() {
-    try {
-      return file.length();
-    } catch (IOException e) {
-      return 0;
+    /**
+     * {@inheritDoc}
+     */
+    public long length() {
+        try {
+            return file.length();
+        } catch (IOException e) {
+            return 0;
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java b/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
index 9c419de65..7aa86b8e2 100644
--- a/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
+++ b/client/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
@@ -17,5 +17,5 @@
  * Simple marker for stopping publishing bytes
  */
 public enum DiscardEvent {
-  DISCARD
+    DISCARD
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index 8f2b18961..49450e12f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,12 +12,12 @@
  */
 package org.asynchttpclient.netty;
 
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.HttpResponseBodyPart;
 
 import java.nio.ByteBuffer;
 
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
+import org.asynchttpclient.HttpResponseBodyPart;
 
 /**
  * A callback class used when an HTTP response body is received.
@@ -25,30 +25,30 @@
  */
 public class EagerResponseBodyPart extends HttpResponseBodyPart {
 
-  private final byte[] bytes;
-
-  public EagerResponseBodyPart(ByteBuf buf, boolean last) {
-    super(last);
-    bytes = byteBuf2Bytes(buf);
-  }
-
-  /**
-   * Return the response body's part bytes received.
-   *
-   * @return the response body's part bytes received.
-   */
-  @Override
-  public byte[] getBodyPartBytes() {
-    return bytes;
-  }
-
-  @Override
-  public int length() {
-    return bytes.length;
-  }
-
-  @Override
-  public ByteBuffer getBodyByteBuffer() {
-    return ByteBuffer.wrap(bytes);
-  }
+    private final byte[] bytes;
+
+    public EagerResponseBodyPart(ByteBuf buf, boolean last) {
+        super(last);
+        bytes = byteBuf2Bytes(buf);
+    }
+
+    /**
+     * Return the response body's part bytes received.
+     * 
+     * @return the response body's part bytes received.
+     */
+    @Override
+    public byte[] getBodyPartBytes() {
+        return bytes;
+    }
+
+    @Override
+    public int length() {
+        return bytes.length;
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        return ByteBuffer.wrap(bytes);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index 1abe8ce11..61a1aea83 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -13,44 +13,45 @@
 package org.asynchttpclient.netty;
 
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.netty.util.ByteBufUtils;
 
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.netty.util.ByteBufUtils;
+
 /**
  * A callback class used when an HTTP response body is received.
  */
 public class LazyResponseBodyPart extends HttpResponseBodyPart {
 
-  private final ByteBuf buf;
-
-  public LazyResponseBodyPart(ByteBuf buf, boolean last) {
-    super(last);
-    this.buf = buf;
-  }
-
-  public ByteBuf getBuf() {
-    return buf;
-  }
-
-  @Override
-  public int length() {
-    return buf.readableBytes();
-  }
-
-  /**
-   * Return the response body's part bytes received.
-   *
-   * @return the response body's part bytes received.
-   */
-  @Override
-  public byte[] getBodyPartBytes() {
-    return ByteBufUtils.byteBuf2Bytes(buf.duplicate());
-  }
-
-  @Override
-  public ByteBuffer getBodyByteBuffer() {
-    return buf.nioBuffer();
-  }
+    private final ByteBuf buf;
+
+    public LazyResponseBodyPart(ByteBuf buf, boolean last) {
+        super(last);
+        this.buf = buf;
+    }
+
+    public ByteBuf getBuf() {
+        return buf;
+    }
+
+    @Override
+    public int length() {
+        return buf.readableBytes();
+    }
+    
+    /**
+     * Return the response body's part bytes received.
+     * 
+     * @return the response body's part bytes received.
+     */
+    @Override
+    public byte[] getBodyPartBytes() {
+        return ByteBufUtils.byteBuf2Bytes(buf.duplicate());
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        return buf.nioBuffer();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
index d4697df5e..ff45fb681 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -13,14 +13,13 @@
  */
 package org.asynchttpclient.netty;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
 import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
@@ -32,185 +31,196 @@
 import java.util.List;
 import java.util.Map;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.util.HttpUtils.extractCharset;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.MiscUtils.withDefault;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
 public class NettyResponse implements Response {
 
-  private final List<HttpResponseBodyPart> bodyParts;
-  private final HttpHeaders headers;
-  private final HttpResponseStatus status;
-  private List<Cookie> cookies;
+    private final List<HttpResponseBodyPart> bodyParts;
+    private final HttpHeaders headers;
+    private final HttpResponseStatus status;
+    private List<Cookie> cookies;
+
+    public NettyResponse(HttpResponseStatus status,//
+            HttpHeaders headers,//
+            List<HttpResponseBodyPart> bodyParts) {
+        this.bodyParts = bodyParts;
+        this.headers = headers;
+        this.status = status;
+    }
+
+    private List<Cookie> buildCookies() {
+
+        List<String> setCookieHeaders = headers.getAll(SET_COOKIE2);
+
+        if (!isNonEmpty(setCookieHeaders)) {
+            setCookieHeaders = headers.getAll(SET_COOKIE);
+        }
 
-  public NettyResponse(HttpResponseStatus status,
-                       HttpHeaders headers,
-                       List<HttpResponseBodyPart> bodyParts) {
-    this.bodyParts = bodyParts;
-    this.headers = headers;
-    this.status = status;
-  }
+        if (isNonEmpty(setCookieHeaders)) {
+            List<Cookie> cookies = new ArrayList<>(1);
+            for (String value : setCookieHeaders) {
+                Cookie c = ClientCookieDecoder.STRICT.decode(value);
+                if (c != null)
+                    cookies.add(c);
+            }
+            return Collections.unmodifiableList(cookies);
+        }
 
-  private List<Cookie> buildCookies() {
-
-    List<String> setCookieHeaders = headers.getAll(SET_COOKIE2);
+        return Collections.emptyList();
+    }
+
+    @Override
+    public final int getStatusCode() {
+        return status.getStatusCode();
+    }
+
+    @Override
+    public final String getStatusText() {
+        return status.getStatusText();
+    }
+
+    @Override
+    public final Uri getUri() {
+        return status.getUri();
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return status.getRemoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return status.getLocalAddress();
+    }
+
+    @Override
+    public final String getContentType() {
+        return headers != null ? getHeader(CONTENT_TYPE) : null;
+    }
+
+    @Override
+    public final String getHeader(CharSequence name) {
+        return headers != null ? getHeaders().get(name) : null;
+    }
 
-    if (!isNonEmpty(setCookieHeaders)) {
-      setCookieHeaders = headers.getAll(SET_COOKIE);
-    }
-
-    if (isNonEmpty(setCookieHeaders)) {
-      List<Cookie> cookies = new ArrayList<>(1);
-      for (String value : setCookieHeaders) {
-        Cookie c = ClientCookieDecoder.STRICT.decode(value);
-        if (c != null)
-          cookies.add(c);
-      }
-      return Collections.unmodifiableList(cookies);
+    @Override
+    public final List<String> getHeaders(CharSequence name) {
+        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
     }
 
-    return Collections.emptyList();
-  }
-
-  @Override
-  public final int getStatusCode() {
-    return status.getStatusCode();
-  }
-
-  @Override
-  public final String getStatusText() {
-    return status.getStatusText();
-  }
-
-  @Override
-  public final Uri getUri() {
-    return status.getUri();
-  }
-
-  @Override
-  public SocketAddress getRemoteAddress() {
-    return status.getRemoteAddress();
-  }
-
-  @Override
-  public SocketAddress getLocalAddress() {
-    return status.getLocalAddress();
-  }
-
-  @Override
-  public final String getContentType() {
-    return headers != null ? getHeader(CONTENT_TYPE) : null;
-  }
-
-  @Override
-  public final String getHeader(CharSequence name) {
-    return headers != null ? getHeaders().get(name) : null;
-  }
-
-  @Override
-  public final List<String> getHeaders(CharSequence name) {
-    return headers != null ? getHeaders().getAll(name) : Collections.emptyList();
-  }
-
-  @Override
-  public final HttpHeaders getHeaders() {
-    return headers != null ? headers : EmptyHttpHeaders.INSTANCE;
-  }
-
-  @Override
-  public final boolean isRedirected() {
-    switch (status.getStatusCode()) {
-      case 301:
-      case 302:
-      case 303:
-      case 307:
-      case 308:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  @Override
-  public List<Cookie> getCookies() {
-
-    if (headers == null) {
-      return Collections.emptyList();
-    }
-
-    if (cookies == null) {
-      cookies = buildCookies();
-    }
-    return cookies;
-
-  }
-
-  @Override
-  public boolean hasResponseStatus() {
-    return status != null;
-  }
-
-  @Override
-  public boolean hasResponseHeaders() {
-    return headers != null && !headers.isEmpty();
-  }
-
-  @Override
-  public boolean hasResponseBody() {
-    return isNonEmpty(bodyParts);
-  }
-
-  @Override
-  public byte[] getResponseBodyAsBytes() {
-    return getResponseBodyAsByteBuffer().array();
-  }
-
-  @Override
-  public ByteBuffer getResponseBodyAsByteBuffer() {
-
-    int length = 0;
-    for (HttpResponseBodyPart part : bodyParts)
-      length += part.length();
-
-    ByteBuffer target = ByteBuffer.wrap(new byte[length]);
-    for (HttpResponseBodyPart part : bodyParts)
-      target.put(part.getBodyPartBytes());
-
-    target.flip();
-    return target;
-  }
-
-  @Override
-  public String getResponseBody() {
-    return getResponseBody(withDefault(extractCharset(getContentType()), UTF_8));
-  }
-
-  @Override
-  public String getResponseBody(Charset charset) {
-    return new String(getResponseBodyAsBytes(), charset);
-  }
-
-  @Override
-  public InputStream getResponseBodyAsStream() {
-    return new ByteArrayInputStream(getResponseBodyAsBytes());
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName()).append(" {\n")
-            .append("\tstatusCode=").append(getStatusCode()).append("\n")
-            .append("\theaders=\n");
-
-    for (Map.Entry<String, String> header : getHeaders()) {
-      sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
-    }
-    return sb.append("\tbody=\n").append(getResponseBody()).append("\n")
-            .append("}").toString();
-  }
+    @Override
+    public final HttpHeaders getHeaders() {
+        return headers != null ? headers : EmptyHttpHeaders.INSTANCE;
+    }
+
+    @Override
+    public final boolean isRedirected() {
+        switch (status.getStatusCode()) {
+        case 301:
+        case 302:
+        case 303:
+        case 307:
+        case 308:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+
+        if (headers == null) {
+            return Collections.emptyList();
+        }
+
+        if (cookies == null) {
+            cookies = buildCookies();
+        }
+        return cookies;
+
+    }
+
+    @Override
+    public boolean hasResponseStatus() {
+        return status != null;
+    }
+
+    @Override
+    public boolean hasResponseHeaders() {
+        return headers != null && !headers.isEmpty();
+    }
+
+    @Override
+    public boolean hasResponseBody() {
+        return isNonEmpty(bodyParts);
+    }
+
+    @Override
+    public byte[] getResponseBodyAsBytes() {
+        return getResponseBodyAsByteBuffer().array();
+    }
+
+    @Override
+    public ByteBuffer getResponseBodyAsByteBuffer() {
+
+        int length = 0;
+        for (HttpResponseBodyPart part : bodyParts)
+            length += part.length();
+
+        ByteBuffer target = ByteBuffer.wrap(new byte[length]);
+        for (HttpResponseBodyPart part : bodyParts)
+            target.put(part.getBodyPartBytes());
+
+        target.flip();
+        return target;
+    }
+
+    @Override
+    public String getResponseBody() {
+        return getResponseBody(null);
+    }
+
+    private Charset computeCharset(Charset charset) {
+
+        if (charset == null) {
+            String contentType = getContentType();
+            if (contentType != null)
+                charset = parseCharset(contentType); // parseCharset can return
+                                                     // null
+        }
+        return charset != null ? charset : DEFAULT_CHARSET;
+    }
+
+    @Override
+    public String getResponseBody(Charset charset) {
+        return new String(getResponseBodyAsBytes(), computeCharset(charset));
+    }
+
+    @Override
+    public InputStream getResponseBodyAsStream() {
+        return new ByteArrayInputStream(getResponseBodyAsBytes());
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(getClass().getSimpleName()).append(" {\n")//
+                .append("\tstatusCode=").append(getStatusCode()).append("\n")//
+                .append("\theaders=\n");
+
+        for (Map.Entry<String, String> header : getHeaders()) {
+            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
+        }
+        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
+                .append("}").toString();
+        return sb.toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index cb3b05fbd..9a96ddfd1 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -13,7 +13,20 @@
  */
 package org.asynchttpclient.netty;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.channel.Channel;
+
+import java.io.IOException;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Realm;
@@ -29,518 +42,502 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-
 /**
- * A {@link Future} that can be used to track when an asynchronous HTTP request
- * has been fully processed.
- *
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
+ * 
  * @param <V> the result type
  */
 public final class NettyResponseFuture<V> implements ListenableFuture<V> {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
-
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "redirectCount");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "currentRetry");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_DONE_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "isDone");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_CANCELLED_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "isCancelled");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_AUTH_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "inAuth");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_PROXY_AUTH_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "inProxyAuth");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CONTENT_PROCESSED_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "contentProcessed");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicIntegerFieldUpdater<NettyResponseFuture> ON_THROWABLE_CALLED_FIELD = AtomicIntegerFieldUpdater
-          .newUpdater(NettyResponseFuture.class, "onThrowableCalled");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> TIMEOUTS_HOLDER_FIELD = AtomicReferenceFieldUpdater
-          .newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
-  @SuppressWarnings("rawtypes")
-  private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> PARTITION_KEY_LOCK_FIELD = AtomicReferenceFieldUpdater
-          .newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
-
-  private final long start = unpreciseMillisTime();
-  private final ChannelPoolPartitioning connectionPoolPartitioning;
-  private final ConnectionSemaphore connectionSemaphore;
-  private final ProxyServer proxyServer;
-  private final int maxRetry;
-  private final CompletableFuture<V> future = new CompletableFuture<>();
-  public Throwable pendingException;
-  // state mutated from outside the event loop
-  // TODO check if they are indeed mutated outside the event loop
-  private volatile int isDone = 0;
-  private volatile int isCancelled = 0;
-  private volatile int inAuth = 0;
-  private volatile int inProxyAuth = 0;
-  private volatile int statusReceived = 0;
-  @SuppressWarnings("unused")
-  private volatile int contentProcessed = 0;
-  @SuppressWarnings("unused")
-  private volatile int onThrowableCalled = 0;
-  @SuppressWarnings("unused")
-  private volatile TimeoutsHolder timeoutsHolder;
-  // partition key, when != null used to release lock in ChannelManager
-  private volatile Object partitionKeyLock;
-  // volatile where we need CAS ops
-  private volatile int redirectCount = 0;
-  private volatile int currentRetry = 0;
-  // volatile where we don't need CAS ops
-  private volatile long touch = unpreciseMillisTime();
-  private volatile ChannelState channelState = ChannelState.NEW;
-  // state mutated only inside the event loop
-  private Channel channel;
-  private boolean keepAlive = true;
-  private Request targetRequest;
-  private Request currentRequest;
-  private NettyRequest nettyRequest;
-  private AsyncHandler<V> asyncHandler;
-  private boolean streamAlreadyConsumed;
-  private boolean reuseChannel;
-  private boolean headersAlreadyWrittenOnContinue;
-  private boolean dontWriteBodyBecauseExpectContinue;
-  private boolean allowConnect;
-  private Realm realm;
-  private Realm proxyRealm;
-
-  public NettyResponseFuture(Request originalRequest,
-                             AsyncHandler<V> asyncHandler,
-                             NettyRequest nettyRequest,
-                             int maxRetry,
-                             ChannelPoolPartitioning connectionPoolPartitioning,
-                             ConnectionSemaphore connectionSemaphore,
-                             ProxyServer proxyServer) {
-
-    this.asyncHandler = asyncHandler;
-    this.targetRequest = currentRequest = originalRequest;
-    this.nettyRequest = nettyRequest;
-    this.connectionPoolPartitioning = connectionPoolPartitioning;
-    this.connectionSemaphore = connectionSemaphore;
-    this.proxyServer = proxyServer;
-    this.maxRetry = maxRetry;
-  }
-
-  private void releasePartitionKeyLock() {
-    if (connectionSemaphore == null) {
-      return;
-    }
-
-    Object partitionKey = takePartitionKeyLock();
-    if (partitionKey != null) {
-      connectionSemaphore.releaseChannelLock(partitionKey);
-    }
-  }
-
-  // Take partition key lock object,
-  // but do not release channel lock.
-  public Object takePartitionKeyLock() {
-    // shortcut, much faster than getAndSet
-    if (partitionKeyLock == null) {
-      return null;
-    }
-
-    return PARTITION_KEY_LOCK_FIELD.getAndSet(this, null);
-  }
-
-  // java.util.concurrent.Future
-
-  @Override
-  public boolean isDone() {
-    return isDone != 0 || isCancelled();
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return isCancelled != 0;
-  }
-
-  @Override
-  public boolean cancel(boolean force) {
-    releasePartitionKeyLock();
-    cancelTimeouts();
-
-    if (IS_CANCELLED_FIELD.getAndSet(this, 1) != 0)
-      return false;
-
-    // cancel could happen before channel was attached
-    if (channel != null) {
-      Channels.setDiscard(channel);
-      Channels.silentlyCloseChannel(channel);
-    }
-
-    if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
-      try {
-        asyncHandler.onThrowable(new CancellationException());
-      } catch (Throwable t) {
-        LOGGER.warn("cancel", t);
-      }
-    }
-
-    future.cancel(false);
-    return true;
-  }
-
-  @Override
-  public V get() throws InterruptedException, ExecutionException {
-    return future.get();
-  }
-
-  @Override
-  public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
-    return future.get(l, tu);
-  }
-
-  private void loadContent() throws ExecutionException {
-    if (future.isDone()) {
-      try {
-        future.get();
-      } catch (InterruptedException e) {
-        throw new RuntimeException("unreachable", e);
-      }
-    }
-
-    // No more retry
-    CURRENT_RETRY_UPDATER.set(this, maxRetry);
-    if (CONTENT_PROCESSED_FIELD.getAndSet(this, 1) == 0) {
-      try {
-        future.complete(asyncHandler.onCompleted());
-      } catch (Throwable ex) {
-        if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
-          try {
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
+
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "redirectCount");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "currentRetry");
+
+    private final long start = unpreciseMillisTime();
+    private final ChannelPoolPartitioning connectionPoolPartitioning;
+    private final ConnectionSemaphore connectionSemaphore;
+    private final ProxyServer proxyServer;
+    private final int maxRetry;
+    private final CompletableFuture<V> future = new CompletableFuture<>();
+
+    // state mutated from outside the event loop
+    // TODO check if they are indeed mutated outside the event loop
+    private volatile int isDone = 0;
+    private volatile int isCancelled = 0;
+    private volatile int inAuth = 0;
+    private volatile int inProxyAuth = 0;
+    private volatile int statusReceived = 0;
+    @SuppressWarnings("unused")
+    private volatile int contentProcessed = 0;
+    @SuppressWarnings("unused")
+    private volatile int onThrowableCalled = 0;
+    @SuppressWarnings("unused")
+    private volatile TimeoutsHolder timeoutsHolder;
+    // partition key, when != null used to release lock in ChannelManager
+    private volatile Object partitionKeyLock;
+
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isDoneField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isDone");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isCancelledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isCancelled");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inAuth");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inProxyAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inProxyAuth");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> contentProcessedField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "contentProcessed");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> onThrowableCalledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "onThrowableCalled");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> timeoutsHolderField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> partitionKeyLockField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
+
+    // volatile where we need CAS ops
+    private volatile int redirectCount = 0;
+    private volatile int currentRetry = 0;
+
+    // volatile where we don't need CAS ops
+    private volatile long touch = unpreciseMillisTime();
+    private volatile ChannelState channelState = ChannelState.NEW;
+
+    // state mutated only inside the event loop
+    private Channel channel;
+    private boolean keepAlive = true;
+    private Request targetRequest;
+    private Request currentRequest;
+    private NettyRequest nettyRequest;
+    private AsyncHandler<V> asyncHandler;
+    private boolean streamAlreadyConsumed;
+    private boolean reuseChannel;
+    private boolean headersAlreadyWrittenOnContinue;
+    private boolean dontWriteBodyBecauseExpectContinue;
+    private boolean allowConnect;
+    private Realm realm;
+    private Realm proxyRealm;
+    public Throwable pendingException;
+
+    public NettyResponseFuture(Request originalRequest,//
+            AsyncHandler<V> asyncHandler,//
+            NettyRequest nettyRequest,//
+            int maxRetry,//
+            ChannelPoolPartitioning connectionPoolPartitioning,//
+            ConnectionSemaphore connectionSemaphore,//
+            ProxyServer proxyServer) {
+
+        this.asyncHandler = asyncHandler;
+        this.targetRequest = currentRequest = originalRequest;
+        this.nettyRequest = nettyRequest;
+        this.connectionPoolPartitioning = connectionPoolPartitioning;
+        this.connectionSemaphore = connectionSemaphore;
+        this.proxyServer = proxyServer;
+        this.maxRetry = maxRetry;
+    }
+
+    private void releasePartitionKeyLock() {
+        Object partitionKey = takePartitionKeyLock();
+        if (partitionKey != null) {
+            connectionSemaphore.releaseChannelLock(partitionKey);
+        }
+    }
+
+    // Take partition key lock object,
+    // but do not release channel lock.
+    public Object takePartitionKeyLock() {
+        // shortcut, much faster than getAndSet
+        if (partitionKeyLock == null) {
+            return null;
+        }
+
+        return partitionKeyLockField.getAndSet(this, null);
+    }
+
+    // java.util.concurrent.Future
+
+    @Override
+    public boolean isDone() {
+        return isDone != 0 || isCancelled();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return isCancelled != 0;
+    }
+
+    @Override
+    public boolean cancel(boolean force) {
+        releasePartitionKeyLock();
+        cancelTimeouts();
+
+        if (isCancelledField.getAndSet(this, 1) != 0)
+            return false;
+
+        // cancel could happen before channel was attached
+        if (channel != null) {
+            Channels.setDiscard(channel);
+            Channels.silentlyCloseChannel(channel);
+        }
+
+        if (onThrowableCalledField.getAndSet(this, 1) == 0) {
             try {
-              asyncHandler.onThrowable(ex);
+                asyncHandler.onThrowable(new CancellationException());
             } catch (Throwable t) {
-              LOGGER.debug("asyncHandler.onThrowable", t);
+                LOGGER.warn("cancel", t);
             }
-          } finally {
-            cancelTimeouts();
-          }
         }
-        future.completeExceptionally(ex);
-      }
+
+        future.cancel(false);
+        return true;
     }
-    future.getNow(null);
-  }
 
-  // org.asynchttpclient.ListenableFuture
+    @Override
+    public V get() throws InterruptedException, ExecutionException {
+        return future.get();
+    }
 
-  private boolean terminateAndExit() {
-    releasePartitionKeyLock();
-    cancelTimeouts();
-    this.channel = null;
-    this.reuseChannel = false;
-    return IS_DONE_FIELD.getAndSet(this, 1) != 0 || isCancelled != 0;
-  }
+    @Override
+    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+        return future.get(l, tu);
+    }
 
-  public final void done() {
+    private V getContent() throws ExecutionException {
+        if (future.isDone()) {
+            try {
+                return future.get();
+            } catch (InterruptedException e) {
+                throw new RuntimeException("unreachable", e);
+            }
+        }
 
-    if (terminateAndExit())
-      return;
+        // No more retry
+        CURRENT_RETRY_UPDATER.set(this, maxRetry);
+        if (contentProcessedField.getAndSet(this, 1) == 0) {
+            try {
+                future.complete(asyncHandler.onCompleted());
+            } catch (Throwable ex) {
+                if (onThrowableCalledField.getAndSet(this, 1) == 0) {
+                    try {
+                        try {
+                            asyncHandler.onThrowable(ex);
+                        } catch (Throwable t) {
+                            LOGGER.debug("asyncHandler.onThrowable", t);
+                        }
+                    } finally {
+                        cancelTimeouts();
+                    }
+                }
+                future.completeExceptionally(ex);
+            }
+        }
+        return future.getNow(null);
+    }
 
-    try {
-      loadContent();
-    } catch (ExecutionException ignored) {
+    // org.asynchttpclient.ListenableFuture
 
-    } catch (RuntimeException t) {
-      future.completeExceptionally(t);
-    } catch (Throwable t) {
-      future.completeExceptionally(t);
-      throw t;
+    private boolean terminateAndExit() {
+        releasePartitionKeyLock();
+        cancelTimeouts();
+        this.channel = null;
+        this.reuseChannel = false;
+        return isDoneField.getAndSet(this, 1) != 0 || isCancelled != 0;
     }
-  }
 
-  public final void abort(final Throwable t) {
+    public final void done() {
 
-    if (terminateAndExit())
-      return;
+        if (terminateAndExit())
+            return;
 
-    future.completeExceptionally(t);
+        try {
+            getContent();
+        } catch (ExecutionException ignored) {
 
-    if (ON_THROWABLE_CALLED_FIELD.compareAndSet(this, 0, 1)) {
-      try {
-        asyncHandler.onThrowable(t);
-      } catch (Throwable te) {
-        LOGGER.debug("asyncHandler.onThrowable", te);
-      }
+        } catch (RuntimeException t) {
+            future.completeExceptionally(t);
+        } catch (Throwable t) {
+            future.completeExceptionally(t);
+            throw t;
+        }
     }
-  }
 
-  @Override
-  public void touch() {
-    touch = unpreciseMillisTime();
-  }
+    public final void abort(final Throwable t) {
+
+        if (terminateAndExit())
+            return;
+
+        future.completeExceptionally(t);
 
-  @Override
-  public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
-    if (exec == null) {
-      exec = Runnable::run;
+        if (onThrowableCalledField.compareAndSet(this, 0, 1)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                LOGGER.debug("asyncHandler.onThrowable", te);
+            }
+        }
     }
-    future.whenCompleteAsync((r, v) -> listener.run(), exec);
-    return this;
-  }
 
-  @Override
-  public CompletableFuture<V> toCompletableFuture() {
-    return future;
-  }
+    @Override
+    public void touch() {
+        touch = unpreciseMillisTime();
+    }
 
-  // INTERNAL
+    @Override
+    public ListenableFuture<V> addListener(Runnable listener, Executor exec) {
+        if (exec == null) {
+            exec = Runnable::run;
+        }
+        future.whenCompleteAsync((r, v) -> listener.run(), exec);
+        return this;
+    }
 
-  public Uri getUri() {
-    return targetRequest.getUri();
-  }
+    @Override
+    public CompletableFuture<V> toCompletableFuture() {
+        return future;
+    }
 
-  public ProxyServer getProxyServer() {
-    return proxyServer;
-  }
+    // INTERNAL
 
-  public void cancelTimeouts() {
-    TimeoutsHolder ref = TIMEOUTS_HOLDER_FIELD.getAndSet(this, null);
-    if (ref != null) {
-      ref.cancel();
+    public Uri getUri() {
+        return targetRequest.getUri();
     }
-  }
 
-  public final Request getTargetRequest() {
-    return targetRequest;
-  }
+    public ChannelPoolPartitioning getConnectionPoolPartitioning() {
+        return connectionPoolPartitioning;
+    }
 
-  public void setTargetRequest(Request targetRequest) {
-    this.targetRequest = targetRequest;
-  }
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
 
-  public final Request getCurrentRequest() {
-    return currentRequest;
-  }
+    public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+        this.asyncHandler = asyncHandler;
+    }
 
-  public void setCurrentRequest(Request currentRequest) {
-    this.currentRequest = currentRequest;
-  }
+    public void cancelTimeouts() {
+        TimeoutsHolder ref = timeoutsHolderField.getAndSet(this, null);
+        if (ref != null) {
+            ref.cancel();
+        }
+    }
 
-  public final NettyRequest getNettyRequest() {
-    return nettyRequest;
-  }
+    public final Request getTargetRequest() {
+        return targetRequest;
+    }
 
-  public final void setNettyRequest(NettyRequest nettyRequest) {
-    this.nettyRequest = nettyRequest;
-  }
+    public final Request getCurrentRequest() {
+        return currentRequest;
+    }
 
-  public final AsyncHandler<V> getAsyncHandler() {
-    return asyncHandler;
-  }
+    public final NettyRequest getNettyRequest() {
+        return nettyRequest;
+    }
 
-  public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
-    this.asyncHandler = asyncHandler;
-  }
+    public final void setNettyRequest(NettyRequest nettyRequest) {
+        this.nettyRequest = nettyRequest;
+    }
 
-  public final boolean isKeepAlive() {
-    return keepAlive;
-  }
+    public final AsyncHandler<V> getAsyncHandler() {
+        return asyncHandler;
+    }
 
-  public final void setKeepAlive(final boolean keepAlive) {
-    this.keepAlive = keepAlive;
-  }
+    public final boolean isKeepAlive() {
+        return keepAlive;
+    }
 
-  public int incrementAndGetCurrentRedirectCount() {
-    return REDIRECT_COUNT_UPDATER.incrementAndGet(this);
-  }
+    public final void setKeepAlive(final boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
 
-  public TimeoutsHolder getTimeoutsHolder() {
-    return TIMEOUTS_HOLDER_FIELD.get(this);
-  }
+    public int incrementAndGetCurrentRedirectCount() {
+        return REDIRECT_COUNT_UPDATER.incrementAndGet(this);
+    }
 
-  public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
-    TIMEOUTS_HOLDER_FIELD.set(this, timeoutsHolder);
-  }
+    public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
+        timeoutsHolderField.set(this, timeoutsHolder);
+    }
+
+    public TimeoutsHolder getTimeoutsHolder() {
+        return timeoutsHolderField.get(this);
+    }
+
+    public boolean isInAuth() {
+        return inAuth != 0;
+    }
+
+    public void setInAuth(boolean inAuth) {
+        this.inAuth = inAuth ? 1 : 0;
+    }
+
+    public boolean isAndSetInAuth(boolean set) {
+        return inAuthField.getAndSet(this, set ? 1 : 0) != 0;
+    }
+
+    public boolean isInProxyAuth() {
+        return inProxyAuth != 0;
+    }
+
+    public void setInProxyAuth(boolean inProxyAuth) {
+        this.inProxyAuth = inProxyAuth ? 1 : 0;
+    }
+
+    public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
+        return inProxyAuthField.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
+    }
+
+    public ChannelState getChannelState() {
+        return channelState;
+    }
 
-  public boolean isInAuth() {
-    return inAuth != 0;
-  }
-
-  public void setInAuth(boolean inAuth) {
-    this.inAuth = inAuth ? 1 : 0;
-  }
+    public void setChannelState(ChannelState channelState) {
+        this.channelState = channelState;
+    }
 
-  public boolean isAndSetInAuth(boolean set) {
-    return IN_AUTH_FIELD.getAndSet(this, set ? 1 : 0) != 0;
-  }
+    public boolean isStreamConsumed() {
+        return streamAlreadyConsumed;
+    }
 
-  public boolean isInProxyAuth() {
-    return inProxyAuth != 0;
-  }
+    public void setStreamConsumed(boolean streamConsumed) {
+        this.streamAlreadyConsumed = streamConsumed;
+    }
 
-  public void setInProxyAuth(boolean inProxyAuth) {
-    this.inProxyAuth = inProxyAuth ? 1 : 0;
-  }
+    public long getLastTouch() {
+        return touch;
+    }
 
-  public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
-    return IN_PROXY_AUTH_FIELD.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
-  }
+    public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
+        this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
+    }
 
-  public ChannelState getChannelState() {
-    return channelState;
-  }
+    public boolean isHeadersAlreadyWrittenOnContinue() {
+        return headersAlreadyWrittenOnContinue;
+    }
 
-  public void setChannelState(ChannelState channelState) {
-    this.channelState = channelState;
-  }
+    public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
+        this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
+    }
 
-  public boolean isStreamConsumed() {
-    return streamAlreadyConsumed;
-  }
+    public boolean isDontWriteBodyBecauseExpectContinue() {
+        return dontWriteBodyBecauseExpectContinue;
+    }
 
-  public void setStreamConsumed(boolean streamConsumed) {
-    this.streamAlreadyConsumed = streamConsumed;
-  }
+    public void setReuseChannel(boolean reuseChannel) {
+        this.reuseChannel = reuseChannel;
+    }
 
-  public long getLastTouch() {
-    return touch;
-  }
+    public boolean isConnectAllowed() {
+        return allowConnect;
+    }
 
-  public boolean isHeadersAlreadyWrittenOnContinue() {
-    return headersAlreadyWrittenOnContinue;
-  }
+    public void setConnectAllowed(boolean allowConnect) {
+        this.allowConnect = allowConnect;
+    }
 
-  public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
-    this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
-  }
+    public void attachChannel(Channel channel, boolean reuseChannel) {
 
-  public boolean isDontWriteBodyBecauseExpectContinue() {
-    return dontWriteBodyBecauseExpectContinue;
-  }
+        // future could have been cancelled first
+        if (isDone()) {
+            Channels.silentlyCloseChannel(channel);
+        }
 
-  public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
-    this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
-  }
+        this.channel = channel;
+        this.reuseChannel = reuseChannel;
+    }
 
-  public boolean isConnectAllowed() {
-    return allowConnect;
-  }
+    public Channel channel() {
+        return channel;
+    }
 
-  public void setConnectAllowed(boolean allowConnect) {
-    this.allowConnect = allowConnect;
-  }
-
-  public void attachChannel(Channel channel, boolean reuseChannel) {
-
-    // future could have been cancelled first
-    if (isDone()) {
-      Channels.silentlyCloseChannel(channel);
-    }
-
-    this.channel = channel;
-    this.reuseChannel = reuseChannel;
-  }
-
-  public Channel channel() {
-    return channel;
-  }
-
-  public boolean isReuseChannel() {
-    return reuseChannel;
-  }
-
-  public void setReuseChannel(boolean reuseChannel) {
-    this.reuseChannel = reuseChannel;
-  }
-
-  public boolean incrementRetryAndCheck() {
-    return maxRetry > 0 && CURRENT_RETRY_UPDATER.incrementAndGet(this) <= maxRetry;
-  }
-
-  /**
-   * Return true if the {@link Future} can be recovered. There is some scenario
-   * where a connection can be closed by an unexpected IOException, and in some
-   * situation we can recover from that exception.
-   *
-   * @return true if that {@link Future} cannot be recovered.
-   */
-  public boolean isReplayPossible() {
-    return !isDone() && !(Channels.isChannelActive(channel) && !getUri().getScheme().equalsIgnoreCase("https"))
-            && inAuth == 0 && inProxyAuth == 0;
-  }
-
-  public long getStart() {
-    return start;
-  }
-
-  public Object getPartitionKey() {
-    return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(),
-            proxyServer);
-  }
-
-  public void acquirePartitionLockLazily() throws IOException {
-    if (connectionSemaphore == null || partitionKeyLock != null) {
-      return;
-    }
-
-    Object partitionKey = getPartitionKey();
-    connectionSemaphore.acquireChannelLock(partitionKey);
-    Object prevKey = PARTITION_KEY_LOCK_FIELD.getAndSet(this, partitionKey);
-    if (prevKey != null) {
-      // self-check
-
-      connectionSemaphore.releaseChannelLock(prevKey);
-      releasePartitionKeyLock();
-
-      throw new IllegalStateException("Trying to acquire partition lock concurrently. Please report.");
-    }
-
-    if (isDone()) {
-      // may be cancelled while we acquired a lock
-      releasePartitionKeyLock();
-    }
-  }
-
-  public Realm getRealm() {
-    return realm;
-  }
-
-  public void setRealm(Realm realm) {
-    this.realm = realm;
-  }
-
-  public Realm getProxyRealm() {
-    return proxyRealm;
-  }
-
-  public void setProxyRealm(Realm proxyRealm) {
-    this.proxyRealm = proxyRealm;
-  }
-
-  @Override
-  public String toString() {
-    return "NettyResponseFuture{" + //
-            "currentRetry=" + currentRetry + //
-            ",\n\tisDone=" + isDone + //
-            ",\n\tisCancelled=" + isCancelled + //
-            ",\n\tasyncHandler=" + asyncHandler + //
-            ",\n\tnettyRequest=" + nettyRequest + //
-            ",\n\tfuture=" + future + //
-            ",\n\turi=" + getUri() + //
-            ",\n\tkeepAlive=" + keepAlive + //
-            ",\n\tredirectCount=" + redirectCount + //
-            ",\n\ttimeoutsHolder=" + TIMEOUTS_HOLDER_FIELD.get(this) + //
-            ",\n\tinAuth=" + inAuth + //
-            ",\n\tstatusReceived=" + statusReceived + //
-            ",\n\ttouch=" + touch + //
-            '}';
-  }
+    public boolean isReuseChannel() {
+        return reuseChannel;
+    }
+
+    public boolean incrementRetryAndCheck() {
+        return maxRetry > 0 && CURRENT_RETRY_UPDATER.incrementAndGet(this) <= maxRetry;
+    }
+
+    public void setTargetRequest(Request targetRequest) {
+        this.targetRequest = targetRequest;
+    }
+
+    public void setCurrentRequest(Request currentRequest) {
+        this.currentRequest = currentRequest;
+    }
+
+    /**
+     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can
+     * recover from that exception.
+     * 
+     * @return true if that {@link Future} cannot be recovered.
+     */
+    public boolean isReplayPossible() {
+        return !isDone() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && inAuth == 0 && inProxyAuth == 0;
+    }
+
+    public long getStart() {
+        return start;
+    }
+
+    public Object getPartitionKey() {
+        return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(), proxyServer);
+    }
+
+    public void acquirePartitionLockLazily() throws IOException {
+        if (partitionKeyLock != null) {
+            return;
+        }
+
+        Object partitionKey = getPartitionKey();
+        connectionSemaphore.acquireChannelLock(partitionKey);
+        Object prevKey = partitionKeyLockField.getAndSet(this, partitionKey);
+        if (prevKey != null) {
+            // self-check
+
+            connectionSemaphore.releaseChannelLock(prevKey);
+            releasePartitionKeyLock();
+
+            throw new IllegalStateException("Trying to acquire partition lock concurrently. Please report.");
+        }
+
+        if (isDone()) {
+            // may be cancelled while we acquired a lock
+            releasePartitionKeyLock();
+        }
+    }
+
+    public Realm getRealm() {
+        return realm;
+    }
+
+    public void setRealm(Realm realm) {
+        this.realm = realm;
+    }
+
+    public Realm getProxyRealm() {
+        return proxyRealm;
+    }
+
+    public void setProxyRealm(Realm proxyRealm) {
+        this.proxyRealm = proxyRealm;
+    }
+
+    @Override
+    public String toString() {
+        return "NettyResponseFuture{" + //
+                "currentRetry=" + currentRetry + //
+                ",\n\tisDone=" + isDone + //
+                ",\n\tisCancelled=" + isCancelled + //
+                ",\n\tasyncHandler=" + asyncHandler + //
+                ",\n\tnettyRequest=" + nettyRequest + //
+                ",\n\tfuture=" + future + //
+                ",\n\turi=" + getUri() + //
+                ",\n\tkeepAlive=" + keepAlive + //
+                ",\n\tredirectCount=" + redirectCount + //
+                ",\n\ttimeoutsHolder=" + timeoutsHolderField.get(this) + //
+                ",\n\tinAuth=" + inAuth + //
+                ",\n\tstatusReceived=" + statusReceived + //
+                ",\n\ttouch=" + touch + //
+                '}';
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
index bd5bce1f6..79fa97dae 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -15,77 +15,78 @@
 
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpResponse;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.uri.Uri;
 
 import java.net.SocketAddress;
 
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.uri.Uri;
+
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
 public class NettyResponseStatus extends HttpResponseStatus {
 
-  private final HttpResponse response;
-  private final SocketAddress remoteAddress;
-  private final SocketAddress localAddress;
+    private final HttpResponse response;
+    private final SocketAddress remoteAddress;
+    private final SocketAddress localAddress;
 
-  public NettyResponseStatus(Uri uri, HttpResponse response, Channel channel) {
-    super(uri);
-    this.response = response;
-    if (channel != null) {
-      remoteAddress = channel.remoteAddress();
-      localAddress = channel.localAddress();
-    } else {
-      remoteAddress = null;
-      localAddress = null;
+    public NettyResponseStatus(Uri uri, HttpResponse response, Channel channel) {
+        super(uri);
+        this.response = response;
+        if (channel != null) {
+            remoteAddress = channel.remoteAddress();
+            localAddress = channel.localAddress();
+        } else {
+            remoteAddress = null;
+            localAddress = null;
+        }
     }
-  }
 
-  /**
-   * Return the response status code
-   *
-   * @return the response status code
-   */
-  public int getStatusCode() {
-    return response.status().code();
-  }
+    /**
+     * Return the response status code
+     * 
+     * @return the response status code
+     */
+    public int getStatusCode() {
+        return response.status().code();
+    }
 
-  /**
-   * Return the response status text
-   *
-   * @return the response status text
-   */
-  public String getStatusText() {
-    return response.status().reasonPhrase();
-  }
+    /**
+     * Return the response status text
+     * 
+     * @return the response status text
+     */
+    public String getStatusText() {
+        return response.status().reasonPhrase();
+    }
 
-  @Override
-  public String getProtocolName() {
-    return response.protocolVersion().protocolName();
-  }
+    @Override
+    public String getProtocolName() {
+        return response.protocolVersion().protocolName();
+    }
 
-  @Override
-  public int getProtocolMajorVersion() {
-    return response.protocolVersion().majorVersion();
-  }
+    @Override
+    public int getProtocolMajorVersion() {
+        return response.protocolVersion().majorVersion();
+    }
 
-  @Override
-  public int getProtocolMinorVersion() {
-    return response.protocolVersion().minorVersion();
-  }
+    @Override
+    public int getProtocolMinorVersion() {
+        return response.protocolVersion().minorVersion();
+    }
 
-  @Override
-  public String getProtocolText() {
-    return response.protocolVersion().text();
-  }
+    @Override
+    public String getProtocolText() {
+        return response.protocolVersion().text();
+    }
 
-  @Override
-  public SocketAddress getRemoteAddress() {
-    return remoteAddress;
-  }
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return remoteAddress;
+    }
 
-  @Override
-  public SocketAddress getLocalAddress() {
-    return localAddress;
-  }
+    @Override
+    public SocketAddress getLocalAddress() {
+        return localAddress;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
index 87913e3cf..0f1df7e51 100644
--- a/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
+++ b/client/src/main/java/org/asynchttpclient/netty/OnLastHttpContentCallback.java
@@ -14,15 +14,15 @@
 
 public abstract class OnLastHttpContentCallback {
 
-  protected final NettyResponseFuture<?> future;
+    protected final NettyResponseFuture<?> future;
 
-  protected OnLastHttpContentCallback(NettyResponseFuture<?> future) {
-    this.future = future;
-  }
+    public OnLastHttpContentCallback(NettyResponseFuture<?> future) {
+        this.future = future;
+    }
 
-  abstract public void call() throws Exception;
+    abstract public void call() throws Exception;
 
-  public NettyResponseFuture<?> future() {
-    return future;
-  }
+    public NettyResponseFuture<?> future() {
+        return future;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
index 3d8afa96f..f2c8c2c91 100644
--- a/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
@@ -19,17 +19,17 @@
 
 public abstract class SimpleChannelFutureListener implements ChannelFutureListener {
 
-  @Override
-  public final void operationComplete(ChannelFuture future) {
-    Channel channel = future.channel();
-    if (future.isSuccess()) {
-      onSuccess(channel);
-    } else {
-      onFailure(channel, future.cause());
+    @Override
+    public final void operationComplete(ChannelFuture future) throws Exception {
+        Channel channel = future.channel();
+        if (future.isSuccess()) {
+            onSuccess(channel);
+        } else {
+            onFailure(channel, future.cause());
+        }
     }
-  }
 
-  public abstract void onSuccess(Channel channel);
+    public abstract void onSuccess(Channel channel);
 
-  public abstract void onFailure(Channel channel, Throwable cause);
+    public abstract void onFailure(Channel channel, Throwable cause);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
index a0f35fce8..f10f9ff4c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
@@ -18,16 +18,16 @@
 
 public abstract class SimpleFutureListener<V> implements FutureListener<V> {
 
-  @Override
-  public final void operationComplete(Future<V> future) throws Exception {
-    if (future.isSuccess()) {
-      onSuccess(future.getNow());
-    } else {
-      onFailure(future.cause());
+    @Override
+    public final void operationComplete(Future<V> future) throws Exception {
+        if (future.isSuccess()) {
+            onSuccess(future.getNow());
+        } else {
+            onFailure(future.cause());
+        }
     }
-  }
 
-  protected abstract void onSuccess(V value) throws Exception;
+    protected abstract void onSuccess(V value) throws Exception;
 
-  protected abstract void onFailure(Throwable t) throws Exception;
+    protected abstract void onFailure(Throwable t) throws Exception;
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 991dbd5a2..0a6b0caad 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -13,9 +13,16 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.*;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFactory;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -25,20 +32,34 @@
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
 import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
-import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
-import io.netty.handler.proxy.Socks4ProxyHandler;
-import io.netty.handler.proxy.Socks5ProxyHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
-import io.netty.resolver.NameResolver;
 import io.netty.util.Timer;
-import io.netty.util.concurrent.*;
-import org.asynchttpclient.*;
+import io.netty.util.concurrent.DefaultThreadFactory;
+import io.netty.util.concurrent.GlobalEventExecutor;
+
+import java.net.InetSocketAddress;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ClientStats;
+import org.asynchttpclient.HostStats;
+import org.asynchttpclient.SslEngineFactory;
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.channel.NoopChannelPool;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
@@ -51,438 +72,377 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-
 public class ChannelManager {
 
-  public static final String PINNED_ENTRY = "entry";
-  public static final String HTTP_CLIENT_CODEC = "http";
-  public static final String SSL_HANDLER = "ssl";
-  public static final String SOCKS_HANDLER = "socks";
-  public static final String INFLATER_HANDLER = "inflater";
-  public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
-  public static final String WS_DECODER_HANDLER = "ws-decoder";
-  public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
-  public static final String WS_COMPRESSOR_HANDLER = "ws-compressor";
-  public static final String WS_ENCODER_HANDLER = "ws-encoder";
-  public static final String AHC_HTTP_HANDLER = "ahc-http";
-  public static final String AHC_WS_HANDLER = "ahc-ws";
-  public static final String LOGGING_HANDLER = "logging";
-  private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
-  private final AsyncHttpClientConfig config;
-  private final SslEngineFactory sslEngineFactory;
-  private final EventLoopGroup eventLoopGroup;
-  private final boolean allowReleaseEventLoopGroup;
-  private final Bootstrap httpBootstrap;
-  private final Bootstrap wsBootstrap;
-  private final long handshakeTimeout;
-
-  private final ChannelPool channelPool;
-  private final ChannelGroup openChannels;
-
-  private AsyncHttpClientHandler wsHandler;
-
-  public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
-
-    this.config = config;
-
-    this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new DefaultSslEngineFactory();
-    try {
-      this.sslEngineFactory.init(config);
-    } catch (SSLException e) {
-      throw new RuntimeException("Could not initialize sslEngineFactory", e);
-    }
+    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
+    public static final String PINNED_ENTRY = "entry";
+    public static final String HTTP_CLIENT_CODEC = "http";
+    public static final String SSL_HANDLER = "ssl";
+    public static final String DEFLATER_HANDLER = "deflater";
+    public static final String INFLATER_HANDLER = "inflater";
+    public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
+    public static final String WS_DECODER_HANDLER = "ws-decoder";
+    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
+    public static final String WS_ENCODER_HANDLER = "ws-encoder";
+    public static final String AHC_HTTP_HANDLER = "ahc-http";
+    public static final String AHC_WS_HANDLER = "ahc-ws";
+    public static final String LOGGING_HANDLER = "logging";
+
+    private final AsyncHttpClientConfig config;
+    private final SslEngineFactory sslEngineFactory;
+    private final EventLoopGroup eventLoopGroup;
+    private final boolean allowReleaseEventLoopGroup;
+    private final Bootstrap httpBootstrap;
+    private final Bootstrap wsBootstrap;
+    private final long handshakeTimeout;
+
+    private final ChannelPool channelPool;
+    private final ChannelGroup openChannels;
+
+    private AsyncHttpClientHandler wsHandler;
+
+    public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
+
+        this.config = config;
+
+        this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new DefaultSslEngineFactory();
+        try {
+            this.sslEngineFactory.init(config);
+        } catch (SSLException e) {
+            throw new RuntimeException("Could not initialize sslEngineFactory", e);
+        }
 
-    ChannelPool channelPool = config.getChannelPool();
-    if (channelPool == null) {
-      if (config.isKeepAlive()) {
-        channelPool = new DefaultChannelPool(config, nettyTimer);
-      } else {
-        channelPool = NoopChannelPool.INSTANCE;
-      }
-    }
-    this.channelPool = channelPool;
-
-    openChannels = new DefaultChannelGroup("asyncHttpClient", GlobalEventExecutor.INSTANCE);
-
-    handshakeTimeout = config.getHandshakeTimeout();
-
-    // check if external EventLoopGroup is defined
-    ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
-    allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
-    ChannelFactory<? extends Channel> channelFactory;
-    if (allowReleaseEventLoopGroup) {
-      if (config.isUseNativeTransport()) {
-        eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);
-        channelFactory = getEpollSocketChannelFactory();
-
-      } else {
-        eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), threadFactory);
-        channelFactory = NioSocketChannelFactory.INSTANCE;
-      }
-
-    } else {
-      eventLoopGroup = config.getEventLoopGroup();
-      if (eventLoopGroup instanceof OioEventLoopGroup)
-        throw new IllegalArgumentException("Oio is not supported");
-
-      if (eventLoopGroup instanceof NioEventLoopGroup) {
-        channelFactory = NioSocketChannelFactory.INSTANCE;
-      } else {
-        channelFactory = getEpollSocketChannelFactory();
-      }
-    }
+        ChannelPool channelPool = config.getChannelPool();
+        if (channelPool == null) {
+            if (config.isKeepAlive()) {
+                channelPool = new DefaultChannelPool(config, nettyTimer);
+            } else {
+                channelPool = NoopChannelPool.INSTANCE;
+            }
+        }
+        this.channelPool = channelPool;
+
+        openChannels = new DefaultChannelGroup("asyncHttpClient", GlobalEventExecutor.INSTANCE);
 
-    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
-    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
+        handshakeTimeout = config.getHandshakeTimeout();
 
-    // for reactive streams
-    httpBootstrap.option(ChannelOption.AUTO_READ, false);
-  }
+        // check if external EventLoopGroup is defined
+        ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
+        allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
+        ChannelFactory<? extends Channel> channelFactory;
+        if (allowReleaseEventLoopGroup) {
+            if (config.isUseNativeTransport()) {
+                eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);
+                channelFactory = getEpollSocketChannelFactory();
 
-  public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
-    return pipeline.get(SSL_HANDLER) != null;
-  }
+            } else {
+                eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), threadFactory);
+                channelFactory = NioSocketChannelFactory.INSTANCE;
+            }
+
+        } else {
+            eventLoopGroup = config.getEventLoopGroup();
+            if (eventLoopGroup instanceof OioEventLoopGroup)
+                throw new IllegalArgumentException("Oio is not supported");
+
+            if (eventLoopGroup instanceof NioEventLoopGroup) {
+                channelFactory = NioSocketChannelFactory.INSTANCE;
+            } else {
+                channelFactory = getEpollSocketChannelFactory();
+            }
+        }
 
-  private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
-    @SuppressWarnings("deprecation")
-    Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory).group(eventLoopGroup)
-            .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)
-            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())
-            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())
-            .option(ChannelOption.AUTO_CLOSE, false);
+        httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
+        wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);
 
-    if (config.getConnectTimeout() > 0) {
-      bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+        // for reactive streams
+        httpBootstrap.option(ChannelOption.AUTO_READ, false);
     }
 
-    if (config.getSoLinger() >= 0) {
-      bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
-    }
+    private Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
+        @SuppressWarnings("deprecation")
+        Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory).group(eventLoopGroup)//
+                .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)//
+                .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())//
+                .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//
+                .option(ChannelOption.AUTO_CLOSE, false);
 
-    if (config.getSoSndBuf() >= 0) {
-      bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());
+        if (config.getConnectTimeout() > 0) {
+            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+        }
+
+        if (config.getSoLinger() >= 0) {
+            bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
+        }
+
+        if (config.getSoSndBuf() >= 0) {
+            bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());
+        }
+
+        if (config.getSoRcvBuf() >= 0) {
+            bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());
+        }
+
+        for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
+            bootstrap.option(entry.getKey(), entry.getValue());
+        }
+
+        return bootstrap;
     }
 
-    if (config.getSoRcvBuf() >= 0) {
-      bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());
+    private EventLoopGroup newEpollEventLoopGroup(int ioThreadsCount, ThreadFactory threadFactory) {
+        try {
+            Class<?> epollEventLoopGroupClass = Class.forName("io.netty.channel.epoll.EpollEventLoopGroup");
+            return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(ioThreadsCount, threadFactory);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(e);
+        }
     }
 
-    for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
-      bootstrap.option(entry.getKey(), entry.getValue());
+    @SuppressWarnings("unchecked")
+    private ChannelFactory<? extends Channel> getEpollSocketChannelFactory() {
+        try {
+            return (ChannelFactory<? extends Channel>) Class.forName("org.asynchttpclient.netty.channel.EpollSocketChannelFactory").newInstance();
+        } catch (Exception e) {
+            throw new IllegalArgumentException(e);
+        }
     }
 
-    return bootstrap;
-  }
+    public void configureBootstraps(NettyRequestSender requestSender) {
 
-  private EventLoopGroup newEpollEventLoopGroup(int ioThreadsCount, ThreadFactory threadFactory) {
-    try {
-      Class<?> epollEventLoopGroupClass = Class.forName("io.netty.channel.epoll.EpollEventLoopGroup");
-      return (EventLoopGroup) epollEventLoopGroupClass.getConstructor(int.class, ThreadFactory.class).newInstance(ioThreadsCount, threadFactory);
-    } catch (Exception e) {
-      throw new IllegalArgumentException(e);
-    }
-  }
-
-  @SuppressWarnings("unchecked")
-  private ChannelFactory<? extends Channel> getEpollSocketChannelFactory() {
-    try {
-      return (ChannelFactory<? extends Channel>) Class.forName("org.asynchttpclient.netty.channel.EpollSocketChannelFactory").newInstance();
-    } catch (Exception e) {
-      throw new IllegalArgumentException(e);
-    }
-  }
+        final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);
+        wsHandler = new WebSocketHandler(config, this, requestSender);
 
-  public void configureBootstraps(NettyRequestSender requestSender) {
+        final NoopHandler pinnedEntry = new NoopHandler();
 
-    final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);
-    wsHandler = new WebSocketHandler(config, this, requestSender);
+        final LoggingHandler loggingHandler = new LoggingHandler(LogLevel.TRACE);
 
-    final NoopHandler pinnedEntry = new NoopHandler();
+        httpBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline()//
+                        .addLast(PINNED_ENTRY, pinnedEntry)//
+                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
+                        .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//
+                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
+                        .addLast(AHC_HTTP_HANDLER, httpHandler);
+
+                if (LOGGER.isTraceEnabled()) {
+                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
+                }
+
+                if (config.getHttpAdditionalChannelInitializer() != null)
+                    config.getHttpAdditionalChannelInitializer().initChannel(ch);
+            }
+        });
 
-    final LoggingHandler loggingHandler = new LoggingHandler(LogLevel.TRACE);
+        wsBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline()//
+                        .addLast(PINNED_ENTRY, pinnedEntry)//
+                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
+                        .addLast(AHC_WS_HANDLER, wsHandler);
+
+                if (LOGGER.isDebugEnabled()) {
+                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
+                }
+
+                if (config.getWsAdditionalChannelInitializer() != null)
+                    config.getWsAdditionalChannelInitializer().initChannel(ch);
+            }
+        });
+    }
 
-    httpBootstrap.handler(new ChannelInitializer<Channel>() {
-      @Override
-      protected void initChannel(Channel ch) {
-        ChannelPipeline pipeline = ch.pipeline()
-                .addLast(PINNED_ENTRY, pinnedEntry)
-                .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())
-                .addLast(INFLATER_HANDLER, newHttpContentDecompressor())
-                .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())
-                .addLast(AHC_HTTP_HANDLER, httpHandler);
+    private HttpContentDecompressor newHttpContentDecompressor() {
+        if (config.isKeepEncodingHeader())
+            return new HttpContentDecompressor() {
+                @Override
+                protected String getTargetContentEncoding(String contentEncoding) throws Exception {
+                    return contentEncoding;
+                }
+            };
+        else
+            return new HttpContentDecompressor();
+    }
 
-        if (LOGGER.isTraceEnabled()) {
-          pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
-        }
+    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {
+        if (channel.isActive() && keepAlive) {
+            LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
+            Channels.setDiscard(channel);
+
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onConnectionOffer(channel);
+                } catch (Exception e) {
+                    LOGGER.error("onConnectionOffer crashed", e);
+                }
+            }
 
-        if (config.getHttpAdditionalChannelInitializer() != null)
-          config.getHttpAdditionalChannelInitializer().accept(ch);
-      }
-    });
-
-    wsBootstrap.handler(new ChannelInitializer<Channel>() {
-      @Override
-      protected void initChannel(Channel ch) {
-        ChannelPipeline pipeline = ch.pipeline()
-                .addLast(PINNED_ENTRY, pinnedEntry)
-                .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())
-                .addLast(AHC_WS_HANDLER, wsHandler);
-
-        if (config.isEnableWebSocketCompression()) {
-          pipeline.addBefore(AHC_WS_HANDLER, WS_COMPRESSOR_HANDLER, WebSocketClientCompressionHandler.INSTANCE);
+            if (!channelPool.offer(channel, partitionKey)) {
+                // rejected by pool
+                closeChannel(channel);
+            }
+        } else {
+            // not offered
+            closeChannel(channel);
         }
+    }
 
-        if (LOGGER.isDebugEnabled()) {
-          pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
-        }
+    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
+        Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
+        return channelPool.poll(partitionKey);
+    }
 
-        if (config.getWsAdditionalChannelInitializer() != null)
-          config.getWsAdditionalChannelInitializer().accept(ch);
-      }
-    });
-  }
-
-  private HttpContentDecompressor newHttpContentDecompressor() {
-    if (config.isKeepEncodingHeader())
-      return new HttpContentDecompressor() {
-        @Override
-        protected String getTargetContentEncoding(String contentEncoding) {
-          return contentEncoding;
-        }
-      };
-    else
-      return new HttpContentDecompressor();
-  }
-
-  public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {
-    if (channel.isActive() && keepAlive) {
-      LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
-      Channels.setDiscard(channel);
-
-      try {
-        asyncHandler.onConnectionOffer(channel);
-      } catch (Exception e) {
-        LOGGER.error("onConnectionOffer crashed", e);
-      }
-
-      if (!channelPool.offer(channel, partitionKey)) {
-        // rejected by pool
-        closeChannel(channel);
-      }
-    } else {
-      // not offered
-      closeChannel(channel);
+    public boolean removeAll(Channel connection) {
+        return channelPool.removeAll(connection);
     }
-  }
-
-  public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
-    Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
-    return channelPool.poll(partitionKey);
-  }
-
-  public void removeAll(Channel connection) {
-    channelPool.removeAll(connection);
-  }
-
-  private void doClose() {
-    openChannels.close();
-    channelPool.destroy();
-  }
-
-  public void close() {
-    if (allowReleaseEventLoopGroup) {
-      eventLoopGroup
-              .shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)
-              .addListener(future -> doClose());
-    } else {
-      doClose();
+
+    private void doClose() {
+        openChannels.close();
+        channelPool.destroy();
     }
-  }
-
-  public void closeChannel(Channel channel) {
-    LOGGER.debug("Closing Channel {} ", channel);
-    Channels.setDiscard(channel);
-    removeAll(channel);
-    Channels.silentlyCloseChannel(channel);
-  }
-
-  public void registerOpenChannel(Channel channel) {
-    openChannels.add(channel);
-  }
-
-  private HttpClientCodec newHttpClientCodec() {
-    return new HttpClientCodec(//
-            config.getHttpClientCodecMaxInitialLineLength(),
-            config.getHttpClientCodecMaxHeaderSize(),
-            config.getHttpClientCodecMaxChunkSize(),
-            false,
-            config.isValidateResponseHeaders(),
-            config.getHttpClientCodecInitialBufferSize());
-  }
-
-  private SslHandler createSslHandler(String peerHost, int peerPort) {
-    SSLEngine sslEngine = sslEngineFactory.newSslEngine(config, peerHost, peerPort);
-    SslHandler sslHandler = new SslHandler(sslEngine);
-    if (handshakeTimeout > 0)
-      sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
-    return sslHandler;
-  }
-
-  public void updatePipelineForHttpTunneling(ChannelPipeline pipeline, Uri requestUri) {
-    if (pipeline.get(HTTP_CLIENT_CODEC) != null)
-      pipeline.remove(HTTP_CLIENT_CODEC);
-
-    if (requestUri.isSecured())
-      if (isSslHandlerConfigured(pipeline)) {
-        pipeline.addAfter(SSL_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
-      } else {
-        pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
-        pipeline.addAfter(PINNED_ENTRY, SSL_HANDLER, createSslHandler(requestUri.getHost(), requestUri.getExplicitPort()));
-      }
-
-    else
-      pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
-
-    if (requestUri.isWebSocket()) {
-      pipeline.addAfter(AHC_HTTP_HANDLER, AHC_WS_HANDLER, wsHandler);
-      pipeline.remove(AHC_HTTP_HANDLER);
+
+    public void close() {
+        if (allowReleaseEventLoopGroup) {
+            eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)//
+                    .addListener(future -> doClose());
+        } else {
+            doClose();
+        }
     }
-  }
-
-  public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) {
-    String peerHost;
-    int peerPort;
-
-    if (virtualHost != null) {
-      int i = virtualHost.indexOf(':');
-      if (i == -1) {
-        peerHost = virtualHost;
-        peerPort = uri.getSchemeDefaultPort();
-      } else {
-        peerHost = virtualHost.substring(0, i);
-        peerPort = Integer.valueOf(virtualHost.substring(i + 1));
-      }
-
-    } else {
-      peerHost = uri.getHost();
-      peerPort = uri.getExplicitPort();
+
+    public void closeChannel(Channel channel) {
+        LOGGER.debug("Closing Channel {} ", channel);
+        Channels.setDiscard(channel);
+        removeAll(channel);
+        Channels.silentlyCloseChannel(channel);
     }
 
-    SslHandler sslHandler = createSslHandler(peerHost, peerPort);
-    pipeline.addFirst(ChannelManager.SSL_HANDLER, sslHandler);
-    return sslHandler;
-  }
+    public void registerOpenChannel(Channel channel, Object partitionKey) {
+        openChannels.add(channel);
+    }
 
-  public Future<Bootstrap> getBootstrap(Uri uri, NameResolver<InetAddress> nameResolver, ProxyServer proxy) {
+    private HttpClientCodec newHttpClientCodec() {
+        return new HttpClientCodec(//
+                config.getHttpClientCodecMaxInitialLineLength(),//
+                config.getHttpClientCodecMaxHeaderSize(),//
+                config.getHttpClientCodecMaxChunkSize(),//
+                false,//
+                config.isValidateResponseHeaders(),//
+                config.getHttpClientCodecInitialBufferSize());
+    }
 
-    final Promise<Bootstrap> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+    private SslHandler createSslHandler(String peerHost, int peerPort) {
+        SSLEngine sslEngine = sslEngineFactory.newSslEngine(config, peerHost, peerPort);
+        SslHandler sslHandler = new SslHandler(sslEngine);
+        if (handshakeTimeout > 0)
+            sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
+        return sslHandler;
+    }
 
-    if (uri.isWebSocket() && proxy == null) {
-      return promise.setSuccess(wsBootstrap);
+    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
+        return pipeline.get(SSL_HANDLER) != null;
+    }
 
-    } else if (proxy != null && proxy.getProxyType().isSocks()) {
-      Bootstrap socksBootstrap = httpBootstrap.clone();
-      ChannelHandler httpBootstrapHandler = socksBootstrap.config().handler();
+    public void upgradeProtocol(ChannelPipeline pipeline, Uri requestUri) throws SSLException {
+        if (pipeline.get(HTTP_CLIENT_CODEC) != null)
+            pipeline.remove(HTTP_CLIENT_CODEC);
 
-      nameResolver.resolve(proxy.getHost()).addListener((Future<InetAddress> whenProxyAddress) -> {
-        if (whenProxyAddress.isSuccess()) {
-          socksBootstrap.handler(new ChannelInitializer<Channel>() {
-            @Override
-            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-              httpBootstrapHandler.handlerAdded(ctx);
-              super.handlerAdded(ctx);
+        if (requestUri.isSecured())
+            if (isSslHandlerConfigured(pipeline)) {
+                pipeline.addAfter(SSL_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
+            } else {
+                pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
+                pipeline.addAfter(PINNED_ENTRY, SSL_HANDLER, createSslHandler(requestUri.getHost(), requestUri.getExplicitPort()));
             }
 
-            @Override
-            protected void initChannel(Channel channel) throws Exception {
-              InetSocketAddress proxyAddress = new InetSocketAddress(whenProxyAddress.get(), proxy.getPort());
-              switch (proxy.getProxyType()) {
-                case SOCKS_V4:
-                  channel.pipeline().addFirst(SOCKS_HANDLER, new Socks4ProxyHandler(proxyAddress));
-                  break;
-
-                case SOCKS_V5:
-                  channel.pipeline().addFirst(SOCKS_HANDLER, new Socks5ProxyHandler(proxyAddress));
-                  break;
-
-                default:
-                  throw new IllegalArgumentException("Only SOCKS4 and SOCKS5 supported at the moment.");
-              }
+        else
+            pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
+
+        if (requestUri.isWebSocket()) {
+            pipeline.addAfter(AHC_HTTP_HANDLER, AHC_WS_HANDLER, wsHandler);
+            pipeline.remove(AHC_HTTP_HANDLER);
+        }
+    }
+
+    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) {
+        String peerHost;
+        int peerPort;
+
+        if (virtualHost != null) {
+            int i = virtualHost.indexOf(':');
+            if (i == -1) {
+                peerHost = virtualHost;
+                peerPort = uri.getSchemeDefaultPort();
+            } else {
+                peerHost = virtualHost.substring(0, i);
+                peerPort = Integer.valueOf(virtualHost.substring(i + 1));
             }
-          });
-          promise.setSuccess(socksBootstrap);
 
         } else {
-          promise.setFailure(whenProxyAddress.cause());
+            peerHost = uri.getHost();
+            peerPort = uri.getExplicitPort();
+        }
+
+        SslHandler sslHandler = createSslHandler(peerHost, peerPort);
+        pipeline.addFirst(ChannelManager.SSL_HANDLER, sslHandler);
+        return sslHandler;
+    }
+
+    public Bootstrap getBootstrap(Uri uri, ProxyServer proxy) {
+        return uri.isWebSocket() && proxy == null ? wsBootstrap : httpBootstrap;
+    }
+
+    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
+        pipeline.addAfter(HTTP_CLIENT_CODEC, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+        pipeline.addBefore(AHC_WS_HANDLER, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
+        if (config.isAggregateWebSocketFrameFragments()) {
+            pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
         }
-      });
+        pipeline.remove(HTTP_CLIENT_CODEC);
+    }
+
+    public final OnLastHttpContentCallback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+
+        return new OnLastHttpContentCallback(future) {
+            public void call() {
+                tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
+            }
+        };
+    }
 
-    } else {
-      promise.setSuccess(httpBootstrap);
+    public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future) {
+        drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
     }
 
-    return promise;
-  }
+    public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
+        Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
+    }
+
+    public ChannelPool getChannelPool() {
+        return channelPool;
+    }
 
-  public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
-    pipeline.addAfter(HTTP_CLIENT_CODEC, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
-    pipeline.addAfter(WS_ENCODER_HANDLER, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, config.isEnableWebSocketCompression(), config.getWebSocketMaxFrameSize()));
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
+
+    public ClientStats getClientStats() {
+        Map<String, Long> totalConnectionsPerHost = openChannels.stream().map(Channel::remoteAddress).filter(a -> a.getClass() == InetSocketAddress.class)
+                .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostName).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+        Map<String, Long> idleConnectionsPerHost = channelPool.getIdleChannelCountPerHost();
+        Map<String, HostStats> statsPerHost = totalConnectionsPerHost.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> {
+            final long totalConnectionCount = entry.getValue();
+            final long idleConnectionCount = idleConnectionsPerHost.getOrDefault(entry.getKey(), 0L);
+            final long activeConnectionCount = totalConnectionCount - idleConnectionCount;
+            return new HostStats(activeConnectionCount, idleConnectionCount);
+        }));
+        return new ClientStats(statsPerHost);
+    }
 
-    if (config.isAggregateWebSocketFrameFragments()) {
-      pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
+    public boolean isOpen() {
+        return channelPool.isOpen();
     }
-    pipeline.remove(HTTP_CLIENT_CODEC);
-  }
-
-  private OnLastHttpContentCallback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
-
-    return new OnLastHttpContentCallback(future) {
-      public void call() {
-        tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
-      }
-    };
-  }
-
-  public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future) {
-    drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
-  }
-
-  public void drainChannelAndOffer(Channel channel, NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
-    Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
-  }
-
-  public ChannelPool getChannelPool() {
-    return channelPool;
-  }
-
-  public EventLoopGroup getEventLoopGroup() {
-    return eventLoopGroup;
-  }
-
-  public ClientStats getClientStats() {
-    Map<String, Long> totalConnectionsPerHost = openChannels.stream().map(Channel::remoteAddress).filter(a -> a.getClass() == InetSocketAddress.class)
-            .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostName).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
-    Map<String, Long> idleConnectionsPerHost = channelPool.getIdleChannelCountPerHost();
-    Map<String, HostStats> statsPerHost = totalConnectionsPerHost.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> {
-      final long totalConnectionCount = entry.getValue();
-      final long idleConnectionCount = idleConnectionsPerHost.getOrDefault(entry.getKey(), 0L);
-      final long activeConnectionCount = totalConnectionCount - idleConnectionCount;
-      return new HostStats(activeConnectionCount, idleConnectionCount);
-    }));
-    return new ClientStats(statsPerHost);
-  }
-
-  public boolean isOpen() {
-    return channelPool.isOpen();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
index d4439f682..a76df2b90 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
@@ -14,5 +14,5 @@
 package org.asynchttpclient.netty.channel;
 
 public enum ChannelState {
-  NEW, POOLED, RECONNECTED, CLOSED,
+    NEW, POOLED, RECONNECTED, CLOSED,
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 1ddfda1e5..3bd1b82c2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -16,50 +16,51 @@
 import io.netty.channel.Channel;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
+
 import org.asynchttpclient.netty.DiscardEvent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class Channels {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
-
-  private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
-  private static final AttributeKey<Active> ACTIVE_TOKEN_ATTRIBUTE = AttributeKey.valueOf("activeToken");
-
-  public static Object getAttribute(Channel channel) {
-    Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
-    return attr != null ? attr.get() : null;
-  }
+    private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
 
-  public static void setAttribute(Channel channel, Object o) {
-    channel.attr(DEFAULT_ATTRIBUTE).set(o);
-  }
+    private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
+    private static final AttributeKey<Active> ACTIVE_TOKEN_ATTRIBUTE = AttributeKey.valueOf("activeToken");
 
-  public static void setDiscard(Channel channel) {
-    setAttribute(channel, DiscardEvent.DISCARD);
-  }
+    private enum Active { INSTANCE }
 
-  public static boolean isChannelActive(Channel channel) {
-    return channel != null && channel.isActive();
-  }
+    public static Object getAttribute(Channel channel) {
+        Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
+        return attr != null ? attr.get() : null;
+    }
 
-  public static void setActiveToken(Channel channel) {
-    channel.attr(ACTIVE_TOKEN_ATTRIBUTE).set(Active.INSTANCE);
-  }
+    public static void setAttribute(Channel channel, Object o) {
+        channel.attr(DEFAULT_ATTRIBUTE).set(o);
+    }
 
-  public static boolean isActiveTokenSet(Channel channel) {
-    return channel != null && channel.attr(ACTIVE_TOKEN_ATTRIBUTE).getAndSet(null) != null;
-  }
+    public static void setDiscard(Channel channel) {
+        setAttribute(channel, DiscardEvent.DISCARD);
+    }
 
-  public static void silentlyCloseChannel(Channel channel) {
-    try {
-      if (channel != null && channel.isActive())
-        channel.close();
-    } catch (Throwable t) {
-      LOGGER.debug("Failed to close channel", t);
+    public static boolean isChannelValid(Channel channel) {
+        return channel != null && channel.isActive();
+    }
+    
+    public static void setActiveToken(Channel channel) {
+        channel.attr(ACTIVE_TOKEN_ATTRIBUTE).set(Active.INSTANCE);
+    }
+    
+    public static boolean isActiveTokenSet(Channel channel) {
+        return channel != null && channel.attr(ACTIVE_TOKEN_ATTRIBUTE).getAndSet(null) != null;
     }
-  }
 
-  private enum Active {INSTANCE}
+    public static void silentlyCloseChannel(Channel channel) {
+        try {
+            if (channel != null && channel.isActive())
+                channel.close();
+        } catch (Throwable t) {
+            LOGGER.debug("Failed to close channel", t);
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
index 5350888f9..cde61c57c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
@@ -13,14 +13,14 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.exception.TooManyConnectionsException;
-import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 
 import java.io.IOException;
 import java.util.concurrent.ConcurrentHashMap;
 
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
 
 /**
  * Max connections and max-per-host connections limiter.
@@ -29,53 +29,51 @@
  */
 public class ConnectionSemaphore {
 
-  private final NonBlockingSemaphoreLike freeChannels;
-  private final int maxConnectionsPerHost;
-  private final ConcurrentHashMap<Object, NonBlockingSemaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
-  private final IOException tooManyConnections;
-  private final IOException tooManyConnectionsPerHost;
+    private final int maxTotalConnections;
+    private final NonBlockingSemaphoreLike freeChannels;
+    private final int maxConnectionsPerHost;
+    private final ConcurrentHashMap<Object, NonBlockingSemaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
 
-  private ConnectionSemaphore(AsyncHttpClientConfig config) {
-    tooManyConnections = unknownStackTrace(new TooManyConnectionsException(config.getMaxConnections()), ConnectionSemaphore.class, "acquireChannelLock");
-    tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()), ConnectionSemaphore.class, "acquireChannelLock");
-    int maxTotalConnections = config.getMaxConnections();
-    maxConnectionsPerHost = config.getMaxConnectionsPerHost();
+    private final IOException tooManyConnections;
+    private final IOException tooManyConnectionsPerHost;
 
-    freeChannels = maxTotalConnections > 0 ?
-            new NonBlockingSemaphore(config.getMaxConnections()) :
-            NonBlockingSemaphoreInfinite.INSTANCE;
-  }
+    public ConnectionSemaphore(AsyncHttpClientConfig config) {
+        tooManyConnections = unknownStackTrace(new TooManyConnectionsException(config.getMaxConnections()), ConnectionSemaphore.class, "acquireChannelLock");
+        tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()), ConnectionSemaphore.class, "acquireChannelLock");
+        maxTotalConnections = config.getMaxConnections();
+        maxConnectionsPerHost = config.getMaxConnectionsPerHost();
 
-  public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
-    return config.getMaxConnections() > 0 || config.getMaxConnectionsPerHost() > 0 ? new ConnectionSemaphore(config) : null;
-  }
+        freeChannels = maxTotalConnections > 0 ?
+                new NonBlockingSemaphore(config.getMaxConnections()) :
+                NonBlockingSemaphoreInfinite.INSTANCE;
+    }
 
-  private boolean tryAcquireGlobal() {
-    return freeChannels.tryAcquire();
-  }
+    private boolean tryAcquireGlobal() {
+        return freeChannels.tryAcquire();
+    }
 
-  private NonBlockingSemaphoreLike getFreeConnectionsForHost(Object partitionKey) {
-    return maxConnectionsPerHost > 0 ?
-            freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new NonBlockingSemaphore(maxConnectionsPerHost)) :
-            NonBlockingSemaphoreInfinite.INSTANCE;
-  }
+    private NonBlockingSemaphoreLike getFreeConnectionsForHost(Object partitionKey) {
+        return maxConnectionsPerHost > 0 ?
+                freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new NonBlockingSemaphore(maxConnectionsPerHost)) :
+                NonBlockingSemaphoreInfinite.INSTANCE;
+    }
 
-  private boolean tryAcquirePerHost(Object partitionKey) {
-    return getFreeConnectionsForHost(partitionKey).tryAcquire();
-  }
+    private boolean tryAcquirePerHost(Object partitionKey) {
+        return getFreeConnectionsForHost(partitionKey).tryAcquire();
+    }
 
-  public void acquireChannelLock(Object partitionKey) throws IOException {
-    if (!tryAcquireGlobal())
-      throw tooManyConnections;
-    if (!tryAcquirePerHost(partitionKey)) {
-      freeChannels.release();
+    public void acquireChannelLock(Object partitionKey) throws IOException {
+        if (!tryAcquireGlobal())
+            throw tooManyConnections;
+        if (!tryAcquirePerHost(partitionKey)) {
+            freeChannels.release();
 
-      throw tooManyConnectionsPerHost;
+            throw tooManyConnectionsPerHost;
+        }
     }
-  }
 
-  public void releaseChannelLock(Object partitionKey) {
-    freeChannels.release();
-    getFreeConnectionsForHost(partitionKey).release();
-  }
+    public void releaseChannelLock(Object partitionKey) {
+        freeChannels.release();
+        getFreeConnectionsForHost(partitionKey).release();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 76e79e8c2..96075ec7b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -13,15 +13,13 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelId;
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
 import io.netty.util.TimerTask;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.channel.ChannelPool;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -29,364 +27,365 @@
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.ChannelPool;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
 public final class DefaultChannelPool implements ChannelPool {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
-
-  private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();
-  private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;
-  private final AtomicBoolean isClosed = new AtomicBoolean(false);
-  private final Timer nettyTimer;
-  private final int connectionTtl;
-  private final boolean connectionTtlEnabled;
-  private final int maxIdleTime;
-  private final boolean maxIdleTimeEnabled;
-  private final long cleanerPeriod;
-  private final PoolLeaseStrategy poolLeaseStrategy;
-
-  public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
-    this(config.getPooledConnectionIdleTimeout(),
-            config.getConnectionTtl(),
-            hashedWheelTimer,
-            config.getConnectionPoolCleanerPeriod());
-  }
-
-  public DefaultChannelPool(int maxIdleTime,
-                            int connectionTtl,
-                            Timer nettyTimer,
-                            int cleanerPeriod) {
-    this(maxIdleTime,
-            connectionTtl,
-            PoolLeaseStrategy.LIFO,
-            nettyTimer,
-            cleanerPeriod);
-  }
-
-  public DefaultChannelPool(int maxIdleTime,
-                            int connectionTtl,
-                            PoolLeaseStrategy poolLeaseStrategy,
-                            Timer nettyTimer,
-                            int cleanerPeriod) {
-    this.maxIdleTime = maxIdleTime;
-    this.connectionTtl = connectionTtl;
-    connectionTtlEnabled = connectionTtl > 0;
-    channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
-    this.nettyTimer = nettyTimer;
-    maxIdleTimeEnabled = maxIdleTime > 0;
-    this.poolLeaseStrategy = poolLeaseStrategy;
-
-    this.cleanerPeriod = Math.min(cleanerPeriod, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));
-
-    if (connectionTtlEnabled || maxIdleTimeEnabled)
-      scheduleNewIdleChannelDetector(new IdleChannelDetector());
-  }
-
-  private void scheduleNewIdleChannelDetector(TimerTask task) {
-    nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
-  }
-
-  private boolean isTtlExpired(Channel channel, long now) {
-    if (!connectionTtlEnabled)
-      return false;
-
-    ChannelCreation creation = channelId2Creation.get(channel.id());
-    return creation != null && now - creation.creationTime >= connectionTtl;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  public boolean offer(Channel channel, Object partitionKey) {
-    if (isClosed.get())
-      return false;
-
-    long now = unpreciseMillisTime();
-
-    if (isTtlExpired(channel, now))
-      return false;
-
-    boolean offered = offer0(channel, partitionKey, now);
-    if (connectionTtlEnabled && offered) {
-      registerChannelCreation(channel, partitionKey, now);
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
+
+    private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final Timer nettyTimer;
+    private final int connectionTtl;
+    private final boolean connectionTtlEnabled;
+    private final int maxIdleTime;
+    private final boolean maxIdleTimeEnabled;
+    private final long cleanerPeriod;
+    private final PoolLeaseStrategy poolLeaseStrategy;
+
+    public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
+        this(config.getPooledConnectionIdleTimeout(),//
+                config.getConnectionTtl(),//
+                hashedWheelTimer,//
+                config.getConnectionPoolCleanerPeriod());
     }
 
-    return offered;
-  }
+    public DefaultChannelPool(int maxIdleTime,//
+            int connectionTtl,//
+            Timer nettyTimer,//
+            int cleanerPeriod) {
+        this(maxIdleTime,//
+                connectionTtl,//
+                PoolLeaseStrategy.LIFO,//
+                nettyTimer,//
+                cleanerPeriod);
+    }
 
-  private boolean offer0(Channel channel, Object partitionKey, long now) {
-    ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
-    if (partition == null) {
-      partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedDeque<>());
+    public DefaultChannelPool(int maxIdleTime,//
+            int connectionTtl,//
+            PoolLeaseStrategy poolLeaseStrategy,//
+            Timer nettyTimer,//
+            int cleanerPeriod) {
+        this.maxIdleTime = maxIdleTime;
+        this.connectionTtl = connectionTtl;
+        connectionTtlEnabled = connectionTtl > 0;
+        channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
+        this.nettyTimer = nettyTimer;
+        maxIdleTimeEnabled = maxIdleTime > 0;
+        this.poolLeaseStrategy = poolLeaseStrategy;
+
+        this.cleanerPeriod = Math.min(cleanerPeriod, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));
+
+        if (connectionTtlEnabled || maxIdleTimeEnabled)
+            scheduleNewIdleChannelDetector(new IdleChannelDetector());
     }
-    return partition.offerFirst(new IdleChannel(channel, now));
-  }
 
-  private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
-    ChannelId id = channel.id();
-    if (!channelId2Creation.containsKey(id)) {
-      channelId2Creation.putIfAbsent(id, new ChannelCreation(now, partitionKey));
+    private void scheduleNewIdleChannelDetector(TimerTask task) {
+        nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
     }
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  public Channel poll(Object partitionKey) {
-
-    IdleChannel idleChannel = null;
-    ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
-    if (partition != null) {
-      while (idleChannel == null) {
-        idleChannel = poolLeaseStrategy.lease(partition);
-
-        if (idleChannel == null)
-          // pool is empty
-          break;
-        else if (!Channels.isChannelActive(idleChannel.channel)) {
-          idleChannel = null;
-          LOGGER.trace("Channel is inactive, probably remotely closed!");
-        } else if (!idleChannel.takeOwnership()) {
-          idleChannel = null;
-          LOGGER.trace("Couldn't take ownership of channel, probably in the process of being expired!");
+
+    private static final class ChannelCreation {
+        final long creationTime;
+        final Object partitionKey;
+
+        ChannelCreation(long creationTime, Object partitionKey) {
+            this.creationTime = creationTime;
+            this.partitionKey = partitionKey;
         }
-      }
-    }
-    return idleChannel != null ? idleChannel.channel : null;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  public boolean removeAll(Channel channel) {
-    ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channel.id()) : null;
-    return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(new IdleChannel(channel, Long.MIN_VALUE));
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  public boolean isOpen() {
-    return !isClosed.get();
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  public void destroy() {
-    if (isClosed.getAndSet(true))
-      return;
-
-    partitions.clear();
-    if (connectionTtlEnabled) {
-      channelId2Creation.clear();
     }
-  }
 
-  private void close(Channel channel) {
-    // FIXME pity to have to do this here
-    Channels.setDiscard(channel);
-    if (connectionTtlEnabled) {
-      channelId2Creation.remove(channel.id());
-    }
-    Channels.silentlyCloseChannel(channel);
-  }
-
-  private void flushPartition(Object partitionKey, ConcurrentLinkedDeque<IdleChannel> partition) {
-    if (partition != null) {
-      partitions.remove(partitionKey);
-      for (IdleChannel idleChannel : partition)
-        close(idleChannel.channel);
-    }
-  }
-
-  @Override
-  public void flushPartitions(Predicate<Object> predicate) {
-    for (Map.Entry<Object, ConcurrentLinkedDeque<IdleChannel>> partitionsEntry : partitions.entrySet()) {
-      Object partitionKey = partitionsEntry.getKey();
-      if (predicate.test(partitionKey))
-        flushPartition(partitionKey, partitionsEntry.getValue());
-    }
-  }
-
-  @Override
-  public Map<String, Long> getIdleChannelCountPerHost() {
-    return partitions
-            .values()
-            .stream()
-            .flatMap(ConcurrentLinkedDeque::stream)
-            .map(idle -> idle.getChannel().remoteAddress())
-            .filter(a -> a.getClass() == InetSocketAddress.class)
-            .map(a -> (InetSocketAddress) a)
-            .map(InetSocketAddress::getHostName)
-            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
-  }
-
-  public enum PoolLeaseStrategy {
-    LIFO {
-      public <E> E lease(Deque<E> d) {
-        return d.pollFirst();
-      }
-    },
-    FIFO {
-      public <E> E lease(Deque<E> d) {
-        return d.pollLast();
-      }
-    };
-
-    abstract <E> E lease(Deque<E> d);
-  }
-
-  private static final class ChannelCreation {
-    final long creationTime;
-    final Object partitionKey;
-
-    ChannelCreation(long creationTime, Object partitionKey) {
-      this.creationTime = creationTime;
-      this.partitionKey = partitionKey;
-    }
-  }
+    private static final class IdleChannel {
+        final Channel channel;
+        final long start;
+        final AtomicBoolean owned = new AtomicBoolean(false);
 
-  private static final class IdleChannel {
+        IdleChannel(Channel channel, long start) {
+            this.channel = assertNotNull(channel, "channel");
+            this.start = start;
+        }
 
-    private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
+        public boolean takeOwnership() {
+            return owned.compareAndSet(false, true);
+        }
 
-    final Channel channel;
-    final long start;
-    @SuppressWarnings("unused")
-    private volatile int owned = 0;
+        public Channel getChannel() {
+            return channel;
+        }
 
-    IdleChannel(Channel channel, long start) {
-      this.channel = assertNotNull(channel, "channel");
-      this.start = start;
-    }
+        @Override
+        // only depends on channel
+        public boolean equals(Object o) {
+            return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
+        }
 
-    public boolean takeOwnership() {
-      return ownedField.getAndSet(this, 1) == 0;
+        @Override
+        public int hashCode() {
+            return channel.hashCode();
+        }
     }
 
-    public Channel getChannel() {
-      return channel;
-    }
+    private boolean isTtlExpired(Channel channel, long now) {
+        if (!connectionTtlEnabled)
+            return false;
 
-    @Override
-    // only depends on channel
-    public boolean equals(Object o) {
-      return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
+        ChannelCreation creation = channelId2Creation.get(channel.id());
+        return creation != null && now - creation.creationTime >= connectionTtl;
     }
 
-    @Override
-    public int hashCode() {
-      return channel.hashCode();
+    private boolean isRemotelyClosed(Channel channel) {
+        return !channel.isActive();
     }
-  }
 
-  private final class IdleChannelDetector implements TimerTask {
+    private final class IdleChannelDetector implements TimerTask {
 
-    private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
-      return maxIdleTimeEnabled && now - idleChannel.start >= maxIdleTime;
-    }
+        private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
+            return maxIdleTimeEnabled && now - idleChannel.start >= maxIdleTime;
+        }
+
+        private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {
+            // lazy create
+            List<IdleChannel> idleTimeoutChannels = null;
+            for (IdleChannel idleChannel : partition) {
+                boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);
+                boolean isRemotelyClosed = isRemotelyClosed(idleChannel.channel);
+                boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);
+                if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {
+                    LOGGER.debug("Adding Candidate expired Channel {} isIdleTimeoutExpired={} isRemotelyClosed={} isTtlExpired={}", idleChannel.channel, isIdleTimeoutExpired, isRemotelyClosed, isTtlExpired);
+                    if (idleTimeoutChannels == null)
+                        idleTimeoutChannels = new ArrayList<>(1);
+                    idleTimeoutChannels.add(idleChannel);
+                }
+            }
+
+            return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
+        }
 
-    private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {
-      // lazy create
-      List<IdleChannel> idleTimeoutChannels = null;
-      for (IdleChannel idleChannel : partition) {
-        boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);
-        boolean isRemotelyClosed = !Channels.isChannelActive(idleChannel.channel);
-        boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);
-        if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {
-          LOGGER.debug("Adding Candidate expired Channel {} isIdleTimeoutExpired={} isRemotelyClosed={} isTtlExpired={}", idleChannel.channel, isIdleTimeoutExpired, isRemotelyClosed, isTtlExpired);
-          if (idleTimeoutChannels == null)
-            idleTimeoutChannels = new ArrayList<>(1);
-          idleTimeoutChannels.add(idleChannel);
+        private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+
+            // lazy create, only if we hit a non-closeable channel
+            List<IdleChannel> closedChannels = null;
+            for (int i = 0; i < candidates.size(); i++) {
+                // We call takeOwnership here to avoid closing a channel that has just been taken out
+                // of the pool, otherwise we risk closing an active connection.
+                IdleChannel idleChannel = candidates.get(i);
+                if (idleChannel.takeOwnership()) {
+                    LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
+                    close(idleChannel.channel);
+                    if (closedChannels != null) {
+                        closedChannels.add(idleChannel);
+                    }
+
+                } else if (closedChannels == null) {
+                    // first non closeable to be skipped, copy all
+                    // previously skipped closeable channels
+                    closedChannels = new ArrayList<>(candidates.size());
+                    for (int j = 0; j < i; j++)
+                        closedChannels.add(candidates.get(j));
+                }
+            }
+
+            return closedChannels != null ? closedChannels : candidates;
         }
-      }
 
-      return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.emptyList();
+        public void run(Timeout timeout) throws Exception {
+
+            if (isClosed.get())
+                return;
+
+            if (LOGGER.isDebugEnabled())
+                for (Object key : partitions.keySet()) {
+                    int size = partitions.get(key).size();
+                    if (size > 0) {
+                        LOGGER.debug("Entry count for : {} : {}", key, size);
+                    }
+                }
+
+            long start = unpreciseMillisTime();
+            int closedCount = 0;
+            int totalCount = 0;
+
+            for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
+
+                // store in intermediate unsynchronized lists to minimize
+                // the impact on the ConcurrentLinkedDeque
+                if (LOGGER.isDebugEnabled())
+                    totalCount += partition.size();
+
+                List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
+
+                if (!closedChannels.isEmpty()) {
+                    if (connectionTtlEnabled) {
+                        for (IdleChannel closedChannel : closedChannels)
+                            channelId2Creation.remove(closedChannel.channel.id());
+                    }
+
+                    partition.removeAll(closedChannels);
+                    closedCount += closedChannels.size();
+                }
+            }
+
+            if (LOGGER.isDebugEnabled()) {
+                long duration = unpreciseMillisTime() - start;
+                if (closedCount > 0) {
+                    LOGGER.debug("Closed {} connections out of {} in {} ms", closedCount, totalCount, duration);
+                }
+            }
+
+            scheduleNewIdleChannelDetector(timeout.task());
+        }
     }
 
-    private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
-
-      // lazy create, only if we hit a non-closeable channel
-      List<IdleChannel> closedChannels = null;
-      for (int i = 0; i < candidates.size(); i++) {
-        // We call takeOwnership here to avoid closing a channel that has just been taken out
-        // of the pool, otherwise we risk closing an active connection.
-        IdleChannel idleChannel = candidates.get(i);
-        if (idleChannel.takeOwnership()) {
-          LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
-          close(idleChannel.channel);
-          if (closedChannels != null) {
-            closedChannels.add(idleChannel);
-          }
-
-        } else if (closedChannels == null) {
-          // first non closeable to be skipped, copy all
-          // previously skipped closeable channels
-          closedChannels = new ArrayList<>(candidates.size());
-          for (int j = 0; j < i; j++)
-            closedChannels.add(candidates.get(j));
+    /**
+     * {@inheritDoc}
+     */
+    public boolean offer(Channel channel, Object partitionKey) {
+        if (isClosed.get())
+            return false;
+
+        long now = unpreciseMillisTime();
+
+        if (isTtlExpired(channel, now))
+            return false;
+
+        boolean offered = offer0(channel, partitionKey, now);
+        if (connectionTtlEnabled && offered) {
+            registerChannelCreation(channel, partitionKey, now);
         }
-      }
 
-      return closedChannels != null ? closedChannels : candidates;
+        return offered;
     }
 
-    public void run(Timeout timeout) {
+    private boolean offer0(Channel channel, Object partitionKey, long now) {
+        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
+        if (partition == null) {
+            partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedDeque<>());
+        }
+        return partition.offerFirst(new IdleChannel(channel, now));
+    }
 
-      if (isClosed.get())
-        return;
+    private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
+        ChannelId id = channel.id();
+        if (!channelId2Creation.containsKey(id)) {
+            channelId2Creation.putIfAbsent(id, new ChannelCreation(now, partitionKey));
+        }
+    }
 
-      if (LOGGER.isDebugEnabled())
-        for (Object key : partitions.keySet()) {
-          int size = partitions.get(key).size();
-          if (size > 0) {
-            LOGGER.debug("Entry count for : {} : {}", key, size);
-          }
+    /**
+     * {@inheritDoc}
+     */
+    public Channel poll(Object partitionKey) {
+
+        IdleChannel idleChannel = null;
+        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
+        if (partition != null) {
+            while (idleChannel == null) {
+                idleChannel = poolLeaseStrategy.lease(partition);
+
+                if (idleChannel == null)
+                    // pool is empty
+                    break;
+                else if (isRemotelyClosed(idleChannel.channel)) {
+                    idleChannel = null;
+                    LOGGER.trace("Channel not connected or not opened, probably remotely closed!");
+                } else if (!idleChannel.takeOwnership()) {
+                    idleChannel = null;
+                    LOGGER.trace("Couldn't take ownership of channel, probably in the process of being expired!");
+                }
+            }
         }
+        return idleChannel != null ? idleChannel.channel : null;
+    }
 
-      long start = unpreciseMillisTime();
-      int closedCount = 0;
-      int totalCount = 0;
+    /**
+     * {@inheritDoc}
+     */
+    public boolean removeAll(Channel channel) {
+        ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channel.id()) : null;
+        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
+    }
 
-      for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isOpen() {
+        return !isClosed.get();
+    }
 
-        // store in intermediate unsynchronized lists to minimize
-        // the impact on the ConcurrentLinkedDeque
-        if (LOGGER.isDebugEnabled())
-          totalCount += partition.size();
+    /**
+     * {@inheritDoc}
+     */
+    public void destroy() {
+        if (isClosed.getAndSet(true))
+            return;
 
-        List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
+        partitions.clear();
+        if (connectionTtlEnabled) {
+            channelId2Creation.clear();
+        }
+    }
 
-        if (!closedChannels.isEmpty()) {
-          if (connectionTtlEnabled) {
-            for (IdleChannel closedChannel : closedChannels)
-              channelId2Creation.remove(closedChannel.channel.id());
-          }
+    private void close(Channel channel) {
+        // FIXME pity to have to do this here
+        Channels.setDiscard(channel);
+        if (connectionTtlEnabled) {
+            channelId2Creation.remove(channel.id());
+        }
+        Channels.silentlyCloseChannel(channel);
+    }
 
-          partition.removeAll(closedChannels);
-          closedCount += closedChannels.size();
+    private void flushPartition(Object partitionKey, ConcurrentLinkedDeque<IdleChannel> partition) {
+        if (partition != null) {
+            partitions.remove(partitionKey);
+            for (IdleChannel idleChannel : partition)
+                close(idleChannel.channel);
         }
-      }
+    }
 
-      if (LOGGER.isDebugEnabled()) {
-        long duration = unpreciseMillisTime() - start;
-        if (closedCount > 0) {
-          LOGGER.debug("Closed {} connections out of {} in {} ms", closedCount, totalCount, duration);
+    @Override
+    public void flushPartitions(Predicate<Object> predicate) {
+        for (Map.Entry<Object, ConcurrentLinkedDeque<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+            Object partitionKey = partitionsEntry.getKey();
+            if (predicate.test(partitionKey))
+                flushPartition(partitionKey, partitionsEntry.getValue());
         }
-      }
+    }
+
+    @Override
+    public Map<String, Long> getIdleChannelCountPerHost() {
+        return partitions
+                .values()
+                .stream()
+                .flatMap(ConcurrentLinkedDeque::stream)
+                .map(idle -> idle.getChannel().remoteAddress())
+                .filter(a -> a.getClass() == InetSocketAddress.class)
+                .map(a -> (InetSocketAddress) a)
+                .map(InetSocketAddress::getHostName)
+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+    }
 
-      scheduleNewIdleChannelDetector(timeout.task());
+    public enum PoolLeaseStrategy {
+        LIFO {
+            public <E> E lease(Deque<E> d) {
+                return d.pollFirst();
+            }
+        },
+        FIFO {
+            public <E> E lease(Deque<E> d) {
+                return d.pollLast();
+            }
+        };
+
+        abstract <E> E lease(Deque<E> d);
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
index c6970b6d6..18880cbdc 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/EpollSocketChannelFactory.java
@@ -18,8 +18,8 @@
 
 class EpollSocketChannelFactory implements ChannelFactory<EpollSocketChannel> {
 
-  @Override
-  public EpollSocketChannel newChannel() {
-    return new EpollSocketChannel();
-  }
+    @Override
+    public EpollSocketChannel newChannel() {
+        return new EpollSocketChannel();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index e8f995b7d..86bcc043f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -13,174 +13,188 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+import static org.asynchttpclient.util.HttpUtils.getBaseUrl;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.ssl.SslHandler;
-import org.asynchttpclient.AsyncHandler;
+
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
-import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-
-import static org.asynchttpclient.util.HttpUtils.getBaseUrl;
-
 /**
  * Non Blocking connect.
  */
 public final class NettyConnectListener<T> {
 
-  private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
-
-  private final NettyRequestSender requestSender;
-  private final NettyResponseFuture<T> future;
-  private final ChannelManager channelManager;
-  private final ConnectionSemaphore connectionSemaphore;
-
-  public NettyConnectListener(NettyResponseFuture<T> future,
-                              NettyRequestSender requestSender,
-                              ChannelManager channelManager,
-                              ConnectionSemaphore connectionSemaphore) {
-    this.future = future;
-    this.requestSender = requestSender;
-    this.channelManager = channelManager;
-    this.connectionSemaphore = connectionSemaphore;
-  }
-
-  private boolean futureIsAlreadyCancelled(Channel channel) {
-    // FIXME should we only check isCancelled?
-    if (future.isDone()) {
-      Channels.silentlyCloseChannel(channel);
-      return true;
-    }
-    return false;
-  }
-
-  private void writeRequest(Channel channel) {
-
-    if (futureIsAlreadyCancelled(channel)) {
-      return;
+    private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
+
+    private final NettyRequestSender requestSender;
+    private final NettyResponseFuture<T> future;
+    private final ChannelManager channelManager;
+    private final ConnectionSemaphore connectionSemaphore;
+    private final Object partitionKey;
+
+    public NettyConnectListener(NettyResponseFuture<T> future,//
+            NettyRequestSender requestSender,//
+            ChannelManager channelManager,//
+            ConnectionSemaphore connectionSemaphore,//
+            Object partitionKey) {
+        this.future = future;
+        this.requestSender = requestSender;
+        this.channelManager = channelManager;
+        this.connectionSemaphore = connectionSemaphore;
+        this.partitionKey = partitionKey;
     }
 
-    if (LOGGER.isDebugEnabled()) {
-      HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-      LOGGER.debug("Using new Channel '{}' for '{}' to '{}'", channel, httpRequest.method(), httpRequest.uri());
+    private boolean futureIsAlreadyCancelled(Channel channel) {
+        // FIXME should we only check isCancelled?
+        if (future.isDone()) {
+            Channels.silentlyCloseChannel(channel);
+            return true;
+        }
+        return false;
     }
 
-    Channels.setAttribute(channel, future);
+    private void writeRequest(Channel channel) {
 
-    channelManager.registerOpenChannel(channel);
-    future.attachChannel(channel, false);
-    requestSender.writeRequest(future, channel);
-  }
+        if (futureIsAlreadyCancelled(channel)) {
+            return;
+        }
 
-  public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
+        if (LOGGER.isDebugEnabled()) {
+            HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+            LOGGER.debug("Using new Channel '{}' for '{}' to '{}'", channel, httpRequest.method(), httpRequest.uri());
+        }
 
-    if (connectionSemaphore != null) {
-      // transfer lock from future to channel
-      Object partitionKeyLock = future.takePartitionKeyLock();
+        Channels.setAttribute(channel, future);
 
-      if (partitionKeyLock != null) {
-        channel.closeFuture().addListener(future -> connectionSemaphore.releaseChannelLock(partitionKeyLock));
-      }
+        channelManager.registerOpenChannel(channel, partitionKey);
+        future.attachChannel(channel, false);
+        requestSender.writeRequest(future, channel);
     }
 
-    Channels.setActiveToken(channel);
+    public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
 
-    TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();
+        {
+            // transfer lock from future to channel
+            Object partitionKeyLock = future.takePartitionKeyLock();
 
-    if (futureIsAlreadyCancelled(channel)) {
-      return;
-    }
-
-    Request request = future.getTargetRequest();
-    Uri uri = request.getUri();
-
-    timeoutsHolder.setResolvedRemoteAddress(remoteAddress);
-
-    ProxyServer proxyServer = future.getProxyServer();
-
-    // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
-    if ((proxyServer == null || proxyServer.getProxyType().isSocks()) && uri.isSecured()) {
-      SslHandler sslHandler;
-      try {
-        sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost());
-      } catch (Exception sslError) {
-        onFailure(channel, sslError);
-        return;
-      }
-
-      final AsyncHandler<?> asyncHandler = future.getAsyncHandler();
-
-      try {
-        asyncHandler.onTlsHandshakeAttempt();
-      } catch (Exception e) {
-        LOGGER.error("onTlsHandshakeAttempt crashed", e);
-        onFailure(channel, e);
-        return;
-      }
-
-      sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
-        @Override
-        protected void onSuccess(Channel value) {
-          try {
-            asyncHandler.onTlsHandshakeSuccess();
-          } catch (Exception e) {
-            LOGGER.error("onTlsHandshakeSuccess crashed", e);
-            NettyConnectListener.this.onFailure(channel, e);
-            return;
-          }
-          writeRequest(channel);
+            if (partitionKeyLock != null) {
+                channel.closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {
+                    @Override
+                    public void operationComplete(Future<? super Void> future) throws Exception {
+                        connectionSemaphore.releaseChannelLock(partitionKeyLock);
+                    }
+                });
+            }
         }
 
-        @Override
-        protected void onFailure(Throwable cause) {
-          try {
-            asyncHandler.onTlsHandshakeFailure(cause);
-          } catch (Exception e) {
-            LOGGER.error("onTlsHandshakeFailure crashed", e);
-            NettyConnectListener.this.onFailure(channel, e);
+        Channels.setActiveToken(channel);
+
+        TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();
+
+        if (futureIsAlreadyCancelled(channel)) {
             return;
-          }
-          NettyConnectListener.this.onFailure(channel, cause);
         }
-      });
 
-    } else {
-      writeRequest(channel);
+        Request request = future.getTargetRequest();
+        Uri uri = request.getUri();
+
+        timeoutsHolder.setResolvedRemoteAddress(remoteAddress);
+
+        // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
+        if (future.getProxyServer() == null && uri.isSecured()) {
+            SslHandler sslHandler = null;
+            try {
+                sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost());
+            } catch (Exception sslError) {
+                onFailure(channel, sslError);
+                return;
+            }
+
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onTlsHandshakeAttempt();
+                } catch (Exception e) {
+                    LOGGER.error("onTlsHandshakeAttempt crashed", e);
+                    onFailure(channel, e);
+                    return;
+                }
+            }
+
+            sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
+                @Override
+                protected void onSuccess(Channel value) throws Exception {
+                    if (asyncHandlerExtensions != null) {
+                        try {
+                            asyncHandlerExtensions.onTlsHandshakeSuccess();
+                        } catch (Exception e) {
+                            LOGGER.error("onTlsHandshakeSuccess crashed", e);
+                            NettyConnectListener.this.onFailure(channel, e);
+                            return;
+                        }
+                    }
+                    writeRequest(channel);
+                }
+
+                @Override
+                protected void onFailure(Throwable cause) throws Exception {
+                    if (asyncHandlerExtensions != null) {
+                        try {
+                            asyncHandlerExtensions.onTlsHandshakeFailure(cause);
+                        } catch (Exception e) {
+                            LOGGER.error("onTlsHandshakeFailure crashed", e);
+                            NettyConnectListener.this.onFailure(channel, e);
+                            return;
+                        }
+                    }
+                    NettyConnectListener.this.onFailure(channel, cause);
+                }
+            });
+
+        } else {
+            writeRequest(channel);
+        }
     }
-  }
 
-  public void onFailure(Channel channel, Throwable cause) {
+    public void onFailure(Channel channel, Throwable cause) {
 
-    // beware, channel can be null
-    Channels.silentlyCloseChannel(channel);
+        // beware, channel can be null
+        Channels.silentlyCloseChannel(channel);
 
-    boolean canRetry = future.incrementRetryAndCheck();
-    LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
-    if (canRetry//
-            && cause != null // FIXME when can we have a null cause?
-            && (future.getChannelState() != ChannelState.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
+        boolean canRetry = future.incrementRetryAndCheck();
+        LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
+        if (canRetry//
+                && cause != null // FIXME when can we have a null cause?
+                && (future.getChannelState() != ChannelState.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
 
-      if (requestSender.retry(future)) {
-        return;
-      }
-    }
+            if (requestSender.retry(future)) {
+                return;
+            }
+        }
 
-    LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
+        LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
 
-    boolean printCause = cause.getMessage() != null;
-    String printedCause = printCause ? cause.getMessage() : getBaseUrl(future.getUri());
-    ConnectException e = new ConnectException(printedCause);
-    e.initCause(cause);
-    future.abort(e);
-  }
+        boolean printCause = cause.getMessage() != null;
+        String printedCause = printCause ? cause.getMessage() : getBaseUrl(future.getUri());
+        ConnectException e = new ConnectException(printedCause);
+        e.initCause(cause);
+        future.abort(e);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java b/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
index 907623bba..df021b5b6 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NioSocketChannelFactory.java
@@ -18,10 +18,10 @@
 
 enum NioSocketChannelFactory implements ChannelFactory<NioSocketChannel> {
 
-  INSTANCE;
-
-  @Override
-  public NioSocketChannel newChannel() {
-    return new NioSocketChannel();
-  }
+    INSTANCE;
+    
+    @Override
+    public NioSocketChannel newChannel() {
+        return new NioSocketChannel();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java
index a7bd2eacf..923e77d30 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphore.java
@@ -22,33 +22,33 @@
  */
 class NonBlockingSemaphore implements NonBlockingSemaphoreLike {
 
-  private final AtomicInteger permits;
+    private final AtomicInteger permits;
 
-  NonBlockingSemaphore(int permits) {
-    this.permits = new AtomicInteger(permits);
-  }
+    public NonBlockingSemaphore(int permits) {
+        this.permits = new AtomicInteger(permits);
+    }
 
-  @Override
-  public void release() {
-    permits.incrementAndGet();
-  }
+    @Override
+    public void release() {
+        permits.incrementAndGet();
+    }
 
-  @Override
-  public boolean tryAcquire() {
-    for (; ; ) {
-      int count = permits.get();
-      if (count <= 0) {
-        return false;
-      }
-      if (permits.compareAndSet(count, count - 1)) {
-        return true;
-      }
+    @Override
+    public boolean tryAcquire() {
+        for (;;) {
+            int count = permits.get();
+            if (count <= 0) {
+                return false;
+            }
+            if (permits.compareAndSet(count, count - 1)) {
+                return true;
+            }
+        }
     }
-  }
 
-  @Override
-  public String toString() {
-    // mimic toString of Semaphore class
-    return super.toString() + "[Permits = " + permits + "]";
-  }
+    @Override
+    public String toString() {
+        // mimic toString of Semaphore class
+        return super.toString() + "[Permits = " + permits + "]";
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java
index 3d4fb91db..41a4bcd0b 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreInfinite.java
@@ -15,25 +15,25 @@
 
 /**
  * Non-blocking semaphore-like object with infinite permits.
- * <p>
+ *
  * So try-acquire always succeeds.
  *
  * @author Stepan Koltsov
  */
 enum NonBlockingSemaphoreInfinite implements NonBlockingSemaphoreLike {
-  INSTANCE;
+    INSTANCE;
 
-  @Override
-  public void release() {
-  }
+    @Override
+    public void release() {
+    }
 
-  @Override
-  public boolean tryAcquire() {
-    return true;
-  }
+    @Override
+    public boolean tryAcquire() {
+        return true;
+    }
 
-  @Override
-  public String toString() {
-    return NonBlockingSemaphore.class.getName();
-  }
+    @Override
+    public String toString() {
+        return NonBlockingSemaphore.class.getName();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java
index 44303c9df..5c06dd16b 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreLike.java
@@ -19,7 +19,7 @@
  * @author Stepan Koltsov
  */
 interface NonBlockingSemaphoreLike {
-  void release();
+    void release();
 
-  boolean tryAcquire();
+    boolean tryAcquire();
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java b/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
index 56404ece4..e0363a85d 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
@@ -13,8 +13,8 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelHandler.Sharable;
 
 /**
  * A noop handler that just serves as a pinned reference for adding and removing handlers in the pipeline
diff --git a/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java b/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
index 626754d3c..c02c638ae 100755
--- a/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
@@ -17,43 +17,46 @@
 
 public class StackTraceInspector {
 
-  private static boolean exceptionInMethod(Throwable t, String className, String methodName) {
-    try {
-      for (StackTraceElement element : t.getStackTrace()) {
-        if (element.getClassName().equals(className) && element.getMethodName().equals(methodName))
-          return true;
-      }
-    } catch (Throwable ignore) {
+    private static boolean exceptionInMethod(Throwable t, String className, String methodName) {
+        try {
+            for (StackTraceElement element : t.getStackTrace()) {
+                if (element.getClassName().equals(className) && element.getMethodName().equals(methodName))
+                    return true;
+            }
+        } catch (Throwable ignore) {
+        }
+        return false;
     }
-    return false;
-  }
-
-  private static boolean recoverOnConnectCloseException(Throwable t) {
-    return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
-            || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
-  }
-
-  public static boolean recoverOnNettyDisconnectException(Throwable t) {
-    return t instanceof ClosedChannelException
-            || exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
-            || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
-  }
-
-  public static boolean recoverOnReadOrWriteException(Throwable t) {
-
-    if (t instanceof IOException && "Connection reset by peer".equalsIgnoreCase(t.getMessage()))
-      return true;
-
-    try {
-      for (StackTraceElement element : t.getStackTrace()) {
-        String className = element.getClassName();
-        String methodName = element.getMethodName();
-        if (className.equals("sun.nio.ch.SocketDispatcher") && (methodName.equals("read") || methodName.equals("write")))
-          return true;
-      }
-    } catch (Throwable ignore) {
+
+    private static boolean recoverOnConnectCloseException(Throwable t) {
+        return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
+                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
+    }
+
+    public static boolean recoverOnNettyDisconnectException(Throwable t) {
+        return t instanceof ClosedChannelException
+                || exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
+                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
     }
 
-    return t.getCause() != null && recoverOnReadOrWriteException(t.getCause());
-  }
+    public static boolean recoverOnReadOrWriteException(Throwable t) {
+
+        if (t instanceof IOException && "Connection reset by peer".equalsIgnoreCase(t.getMessage()))
+            return true;
+
+        try {
+            for (StackTraceElement element : t.getStackTrace()) {
+                String className = element.getClassName();
+                String methodName = element.getMethodName();
+                if (className.equals("sun.nio.ch.SocketDispatcher") && (methodName.equals("read") || methodName.equals("write")))
+                    return true;
+            }
+        } catch (Throwable ignore) {
+        }
+
+        if (t.getCause() != null)
+            return recoverOnReadOrWriteException(t.getCause());
+
+        return false;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index de78537ac..0829722a9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.netty.handler;
 
+import static org.asynchttpclient.util.MiscUtils.getCause;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -21,12 +22,16 @@
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.ReferenceCountUtil;
+
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.exception.ChannelClosedException;
+import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.DiscardEvent;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
@@ -35,217 +40,214 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.nio.channels.ClosedChannelException;
-
-import static org.asynchttpclient.util.MiscUtils.getCause;
-
 public abstract class AsyncHttpClientHandler extends ChannelInboundHandlerAdapter {
 
-  protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-  protected final AsyncHttpClientConfig config;
-  protected final ChannelManager channelManager;
-  protected final NettyRequestSender requestSender;
-  final Interceptors interceptors;
-  final boolean hasIOExceptionFilters;
-
-  AsyncHttpClientHandler(AsyncHttpClientConfig config,
-                                ChannelManager channelManager,
-                                NettyRequestSender requestSender) {
-    this.config = config;
-    this.channelManager = channelManager;
-    this.requestSender = requestSender;
-    interceptors = new Interceptors(config, channelManager, requestSender);
-    hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
-  }
-
-  @Override
-  public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
-
-    Channel channel = ctx.channel();
-    Object attribute = Channels.getAttribute(channel);
-
-    try {
-      if (attribute instanceof OnLastHttpContentCallback && msg instanceof LastHttpContent) {
-        ((OnLastHttpContentCallback) attribute).call();
-
-      } else if (attribute instanceof NettyResponseFuture) {
-        NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-        future.touch();
-        handleRead(channel, future, msg);
-
-      } else if (attribute instanceof StreamedResponsePublisher) {
-        StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
-        publisher.future().touch();
-
-        if (msg instanceof HttpContent) {
-          ByteBuf content = ((HttpContent) msg).content();
-          // Republish as a HttpResponseBodyPart
-          if (content.isReadable()) {
-            HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
-            ctx.fireChannelRead(part);
-          }
-          if (msg instanceof LastHttpContent) {
-            // Remove the handler from the pipeline, this will trigger
-            // it to finish
-            ctx.pipeline().remove(publisher);
-            // Trigger a read, just in case the last read complete
-            // triggered no new read
-            ctx.read();
-            // Send the last content on to the protocol, so that it can
-            // conclude the cleanup
-            handleRead(channel, publisher.future(), msg);
-          }
-        } else {
-          logger.info("Received unexpected message while expecting a chunk: " + msg);
-          ctx.pipeline().remove(publisher);
-          Channels.setDiscard(channel);
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected final AsyncHttpClientConfig config;
+    protected final ChannelManager channelManager;
+    protected final NettyRequestSender requestSender;
+    protected final Interceptors interceptors;
+    protected final boolean hasIOExceptionFilters;
+
+    public AsyncHttpClientHandler(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+        interceptors = new Interceptors(config, channelManager, requestSender);
+        hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
+    }
+
+    @Override
+    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+
+        Channel channel = ctx.channel();
+        Object attribute = Channels.getAttribute(channel);
+
+        try {
+            if (attribute instanceof OnLastHttpContentCallback && msg instanceof LastHttpContent) {
+                ((OnLastHttpContentCallback) attribute).call();
+
+            } else if (attribute instanceof NettyResponseFuture) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.touch();
+                handleRead(channel, future, msg);
+
+            } else if (attribute instanceof StreamedResponsePublisher) {
+                StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
+                publisher.future().touch();
+
+                if (msg instanceof HttpContent) {
+                    ByteBuf content = ((HttpContent) msg).content();
+                    // Republish as a HttpResponseBodyPart
+                    if (content.isReadable()) {
+                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
+                        ctx.fireChannelRead(part);
+                    }
+                    if (msg instanceof LastHttpContent) {
+                        // Remove the handler from the pipeline, this will trigger
+                        // it to finish
+                        ctx.pipeline().remove(publisher);
+                        // Trigger a read, just in case the last read complete
+                        // triggered no new read
+                        ctx.read();
+                        // Send the last content on to the protocol, so that it can
+                        // conclude the cleanup
+                        handleRead(channel, publisher.future(), msg);
+                    }
+                } else {
+                    logger.info("Received unexpected message while expecting a chunk: " + msg);
+                    ctx.pipeline().remove(publisher);
+                    Channels.setDiscard(channel);
+                }
+            } else if (attribute != DiscardEvent.DISCARD) {
+                // unhandled message
+                logger.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
+                Channels.silentlyCloseChannel(channel);
+            }
+        } finally {
+            ReferenceCountUtil.release(msg);
         }
-      } else if (attribute != DiscardEvent.DISCARD) {
-        // unhandled message
-        logger.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
-        Channels.silentlyCloseChannel(channel);
-      }
-    } finally {
-      ReferenceCountUtil.release(msg);
     }
-  }
 
-  public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
-    if (requestSender.isClosed())
-      return;
+        if (requestSender.isClosed())
+            return;
 
-    Channel channel = ctx.channel();
-    channelManager.removeAll(channel);
+        Channel channel = ctx.channel();
+        channelManager.removeAll(channel);
 
-    Object attribute = Channels.getAttribute(channel);
-    logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
-    if (attribute instanceof StreamedResponsePublisher) {
-      // setting `attribute` to be the underlying future so that the retry
-      // logic can kick-in
-      attribute = ((StreamedResponsePublisher) attribute).future();
-    }
-    if (attribute instanceof OnLastHttpContentCallback) {
-      OnLastHttpContentCallback callback = (OnLastHttpContentCallback) attribute;
-      Channels.setAttribute(channel, callback.future());
-      callback.call();
+        Object attribute = Channels.getAttribute(channel);
+        logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
+        if (attribute instanceof StreamedResponsePublisher) {
+            // setting `attribute` to be the underlying future so that the retry
+            // logic can kick-in
+            attribute = ((StreamedResponsePublisher) attribute).future();
+        }
+        if (attribute instanceof OnLastHttpContentCallback) {
+            OnLastHttpContentCallback callback = (OnLastHttpContentCallback) attribute;
+            Channels.setAttribute(channel, callback.future());
+            callback.call();
 
-    } else if (attribute instanceof NettyResponseFuture<?>) {
-      NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-      future.touch();
+        } else if (attribute instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+            future.touch();
 
-      if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
-        return;
+            if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
+                return;
 
-      handleChannelInactive(future);
-      requestSender.handleUnexpectedClosedChannel(channel, future);
+            handleChannelInactive(future);
+            requestSender.handleUnexpectedClosedChannel(channel, future);
+        }
     }
-  }
-
-  @Override
-  public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) {
-    Throwable cause = getCause(e);
-
-    if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
-      return;
-
-    Channel channel = ctx.channel();
-    NettyResponseFuture<?> future = null;
-
-    logger.debug("Unexpected I/O exception on channel {}", channel, cause);
-
-    try {
-      Object attribute = Channels.getAttribute(channel);
-      if (attribute instanceof StreamedResponsePublisher) {
-        ctx.fireExceptionCaught(e);
-        // setting `attribute` to be the underlying future so that the
-        // retry logic can kick-in
-        attribute = ((StreamedResponsePublisher) attribute).future();
-      }
-      if (attribute instanceof NettyResponseFuture<?>) {
-        future = (NettyResponseFuture<?>) attribute;
-        future.attachChannel(null, false);
-        future.touch();
-
-        if (cause instanceof IOException) {
-
-          // FIXME why drop the original exception and throw a new one?
-          if (hasIOExceptionFilters) {
-            if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel)) {
-              // Close the channel so the recovering can occurs.
-              Channels.silentlyCloseChannel(channel);
-            }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Exception {
+        Throwable cause = getCause(e);
+
+        if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
             return;
-          }
-        }
 
-        if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-          logger.debug("Trying to recover from dead Channel: {}", channel);
-          future.pendingException = cause;
-          return;
+        Channel channel = ctx.channel();
+        NettyResponseFuture<?> future = null;
+
+        logger.debug("Unexpected I/O exception on channel {}", channel, cause);
+
+        try {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof StreamedResponsePublisher) {
+                ctx.fireExceptionCaught(e);
+                // setting `attribute` to be the underlying future so that the
+                // retry logic can kick-in
+                attribute = ((StreamedResponsePublisher) attribute).future();
+            }
+            if (attribute instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) attribute;
+                future.attachChannel(null, false);
+                future.touch();
+
+                if (cause instanceof IOException) {
+
+                    // FIXME why drop the original exception and throw a new one?
+                    if (hasIOExceptionFilters) {
+                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel)) {
+                            // Close the channel so the recovering can occurs.
+                            Channels.silentlyCloseChannel(channel);
+                        }
+                        return;
+                    }
+                }
+
+                if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+                    logger.debug("Trying to recover from dead Channel: {}", channel);
+                    future.pendingException = cause;
+                    return;
+                }
+            } else if (attribute instanceof OnLastHttpContentCallback) {
+                future = OnLastHttpContentCallback.class.cast(attribute).future();
+            }
+        } catch (Throwable t) {
+            cause = t;
         }
-      } else if (attribute instanceof OnLastHttpContentCallback) {
-        future = OnLastHttpContentCallback.class.cast(attribute).future();
-      }
-    } catch (Throwable t) {
-      cause = t;
-    }
 
-    if (future != null)
-      try {
-        logger.debug("Was unable to recover Future: {}", future);
-        requestSender.abort(channel, future, cause);
-        handleException(future, e);
-      } catch (Throwable t) {
-        logger.error(t.getMessage(), t);
-      }
-
-    channelManager.closeChannel(channel);
-    // FIXME not really sure
-    // ctx.fireChannelRead(e);
-    Channels.silentlyCloseChannel(channel);
-  }
-
-  @Override
-  public void channelActive(ChannelHandlerContext ctx) {
-    ctx.read();
-  }
-
-  @Override
-  public void channelReadComplete(ChannelHandlerContext ctx) {
-    if (!isHandledByReactiveStreams(ctx)) {
-      ctx.read();
-    } else {
-      ctx.fireChannelReadComplete();
+        if (future != null)
+            try {
+                logger.debug("Was unable to recover Future: {}", future);
+                requestSender.abort(channel, future, cause);
+                handleException(future, e);
+            } catch (Throwable t) {
+                logger.error(t.getMessage(), t);
+            }
+
+        channelManager.closeChannel(channel);
+        // FIXME not really sure
+        // ctx.fireChannelRead(e);
+        Channels.silentlyCloseChannel(channel);
     }
-  }
 
-  private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
-    return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
-  }
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        ctx.read();
+    }
 
-  void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean close) {
-    future.cancelTimeouts();
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+        if (!isHandledByReactiveStreams(ctx)) {
+            ctx.read();
+        } else {
+            ctx.fireChannelReadComplete();
+        }
+    }
 
-    if (close) {
-      channelManager.closeChannel(channel);
-    } else {
-      channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), true, future.getPartitionKey());
+    private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
+        return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
     }
+    
+    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean keepAlive, boolean expectOtherChunks) throws IOException {
+        future.cancelTimeouts();
+        
+        if (!keepAlive) {
+            channelManager.closeChannel(channel);
+        } else if (expectOtherChunks) {
+            channelManager.drainChannelAndOffer(channel, future);
+        } else {
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
+        }
 
-    try {
-      future.done();
-    } catch (Exception t) {
-      // Never propagate exception once we know we are done.
-      logger.debug(t.getMessage(), t);
+        try {
+            future.done();
+        } catch (Exception t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
     }
-  }
 
-  public abstract void handleRead(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+    public abstract void handleRead(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
 
-  public abstract void handleException(NettyResponseFuture<?> future, Throwable error);
+    public abstract void handleException(NettyResponseFuture<?> future, Throwable error);
 
-  public abstract void handleChannelInactive(NettyResponseFuture<?> future);
+    public abstract void handleChannelInactive(NettyResponseFuture<?> future);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 508f149f6..906d0a3fd 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -16,7 +16,15 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
+
+import java.io.IOException;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
@@ -28,147 +36,147 @@
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
-import java.io.IOException;
-
 @Sharable
 public final class HttpHandler extends AsyncHttpClientHandler {
 
-  public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager, NettyRequestSender requestSender) {
-    super(config, channelManager, requestSender);
-  }
-
-  private boolean abortAfterHandlingStatus(//
-                                           AsyncHandler<?> handler,
-                                           NettyResponseStatus status) throws Exception {
-    return handler.onStatusReceived(status) == State.ABORT;
-  }
-
-  private boolean abortAfterHandlingHeaders(AsyncHandler<?> handler,
-                                            HttpHeaders responseHeaders) throws Exception {
-    return !responseHeaders.isEmpty() && handler.onHeadersReceived(responseHeaders) == State.ABORT;
-  }
-
-  private boolean abortAfterHandlingReactiveStreams(Channel channel,
-                                                    NettyResponseFuture<?> future,
-                                                    AsyncHandler<?> handler) {
-    if (handler instanceof StreamedAsyncHandler) {
-      StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
-      StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
-      // FIXME do we really need to pass the event loop?
-      // FIXME move this to ChannelManager
-      channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
-      Channels.setAttribute(channel, publisher);
-      return streamedAsyncHandler.onStream(publisher) == State.ABORT;
+    public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager, NettyRequestSender requestSender) {
+        super(config, channelManager, requestSender);
     }
-    return false;
-  }
 
-  private void handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+    private boolean abortAfterHandlingStatus(//
+            AsyncHandler<?> handler,//
+            NettyResponseStatus status) throws IOException, Exception {
+        return handler.onStatusReceived(status) == State.ABORT;
+    }
 
-    HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-    logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+    private boolean abortAfterHandlingHeaders(//
+            AsyncHandler<?> handler,//
+            HttpHeaders responseHeaders) throws Exception {
+        return !responseHeaders.isEmpty() && handler.onHeadersReceived(responseHeaders) == State.ABORT;
+    }
 
-    future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
+    private boolean abortAfterHandlingReactiveStreams(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws IOException {
+        if (handler instanceof StreamedAsyncHandler) {
+            StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
+            StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
+            // FIXME do we really need to pass the event loop?
+            // FIXME move this to ChannelManager
+            channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
+            Channels.setAttribute(channel, publisher);
+            return streamedAsyncHandler.onStream(publisher) == State.ABORT;
+        }
+        return false;
+    }
 
-    NettyResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
-    HttpHeaders responseHeaders = response.headers();
+    private void handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
 
-    if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
-      boolean abort = abortAfterHandlingStatus(handler, status) || //
-              abortAfterHandlingHeaders(handler, responseHeaders) || //
-              abortAfterHandlingReactiveStreams(channel, future, handler);
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
 
-      if (abort) {
-        finishUpdate(future, channel, true);
-      }
-    }
-  }
-
-  private void handleChunk(HttpContent chunk,
-                           final Channel channel,
-                           final NettyResponseFuture<?> future,
-                           AsyncHandler<?> handler) throws Exception {
-
-    boolean abort = false;
-    boolean last = chunk instanceof LastHttpContent;
-
-    // Netty 4: the last chunk is not empty
-    if (last) {
-      LastHttpContent lastChunk = (LastHttpContent) chunk;
-      HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
-      if (!trailingHeaders.isEmpty()) {
-        abort = handler.onTrailingHeadersReceived(trailingHeaders) == State.ABORT;
-      }
-    }
+        future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
 
-    ByteBuf buf = chunk.content();
-    if (!abort && !(handler instanceof StreamedAsyncHandler) && (buf.isReadable() || last)) {
-      HttpResponseBodyPart bodyPart = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
-      abort = handler.onBodyPartReceived(bodyPart) == State.ABORT;
-    }
+        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
+        HttpHeaders responseHeaders = response.headers();
 
-    if (abort || last) {
-      boolean close = abort || !future.isKeepAlive();
-      finishUpdate(future, channel, close);
+        if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+            boolean abort = abortAfterHandlingStatus(handler, status) || //
+                    abortAfterHandlingHeaders(handler, responseHeaders) || //
+                    abortAfterHandlingReactiveStreams(channel, future, handler);
+
+            if (abort) {
+                finishUpdate(future, channel, false, true);
+            }
+        }
     }
-  }
 
-  @Override
-  public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+    private void handleChunk(HttpContent chunk,//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws IOException, Exception {
+
+        boolean abort = false;
+        boolean last = chunk instanceof LastHttpContent;
+
+        // Netty 4: the last chunk is not empty
+        if (last) {
+            LastHttpContent lastChunk = (LastHttpContent) chunk;
+            HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
+            if (!trailingHeaders.isEmpty()) {
+                abort = handler.onTrailingHeadersReceived(trailingHeaders) == State.ABORT;
+            }
+        }
+
+        ByteBuf buf = chunk.content();
+        if (!abort && !(handler instanceof StreamedAsyncHandler) && (buf.isReadable() || last)) {
+            HttpResponseBodyPart bodyPart = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
+            abort = handler.onBodyPartReceived(bodyPart) == State.ABORT;
+        }
 
-    // future is already done because of an exception or a timeout
-    if (future.isDone()) {
-      // FIXME isn't the channel already properly closed?
-      channelManager.closeChannel(channel);
-      return;
+        if (abort || last) {
+            boolean keepAlive = !abort && future.isKeepAlive();
+            finishUpdate(future, channel, keepAlive, !last);
+        }
     }
 
-    AsyncHandler<?> handler = future.getAsyncHandler();
-    try {
-      if (e instanceof HttpObject) {
-        HttpObject object = (HttpObject) e;
-        Throwable t = object.decoderResult().cause();
-        if (t != null) {
-          readFailed(channel, future, t);
-          return;
+    @Override
+    public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+
+        // future is already done because of an exception or a timeout
+        if (future.isDone()) {
+            // FIXME isn't the channel already properly closed?
+            channelManager.closeChannel(channel);
+            return;
+        }
+
+        AsyncHandler<?> handler = future.getAsyncHandler();
+        try {
+            if (e instanceof HttpObject) {
+                HttpObject object = (HttpObject) e;
+                Throwable t = object.decoderResult().cause();
+                if (t != null) {
+                    readFailed(channel, future, t);
+                    return;
+                }
+            }
+            
+            if (e instanceof HttpResponse) {
+                handleHttpResponse((HttpResponse) e, channel, future, handler);
+
+            } else if (e instanceof HttpContent) {
+                handleChunk((HttpContent) e, channel, future, handler);
+            }
+        } catch (Exception t) {
+            // e.g. an IOException when trying to open a connection and send the
+            // next request
+            if (hasIOExceptionFilters//
+                    && t instanceof IOException//
+                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
+                return;
+            }
+
+            readFailed(channel, future, t);
+            throw t;
         }
-      }
-
-      if (e instanceof HttpResponse) {
-        handleHttpResponse((HttpResponse) e, channel, future, handler);
-
-      } else if (e instanceof HttpContent) {
-        handleChunk((HttpContent) e, channel, future, handler);
-      }
-    } catch (Exception t) {
-      // e.g. an IOException when trying to open a connection and send the
-      // next request
-      if (hasIOExceptionFilters//
-              && t instanceof IOException//
-              && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
-        return;
-      }
-
-      readFailed(channel, future, t);
-      throw t;
     }
-  }
-
-  private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwable t) {
-    try {
-      requestSender.abort(channel, future, t);
-    } catch (Exception abortException) {
-      logger.debug("Abort failed", abortException);
-    } finally {
-      finishUpdate(future, channel, true);
+    
+    private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwable t) throws Exception {
+        try {
+            requestSender.abort(channel, future, t);
+        } catch (Exception abortException) {
+            logger.debug("Abort failed", abortException);
+        } finally {
+            finishUpdate(future, channel, false, false);
+        }
     }
-  }
 
-  @Override
-  public void handleException(NettyResponseFuture<?> future, Throwable error) {
-  }
+    @Override
+    public void handleException(NettyResponseFuture<?> future, Throwable error) {
+    }
 
-  @Override
-  public void handleChannelInactive(NettyResponseFuture<?> future) {
-  }
+    @Override
+    public void handleChannelInactive(NettyResponseFuture<?> future) {
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
index f4565f91b..9357ae08f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
@@ -13,8 +13,10 @@
 package org.asynchttpclient.netty.handler;
 
 import com.typesafe.netty.HandlerPublisher;
+
 import io.netty.channel.Channel;
 import io.netty.util.concurrent.EventExecutor;
+
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -23,35 +25,36 @@
 
 public class StreamedResponsePublisher extends HandlerPublisher<HttpResponseBodyPart> {
 
-  protected final Logger logger = LoggerFactory.getLogger(getClass());
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    private final ChannelManager channelManager;
+    private final NettyResponseFuture<?> future;
+    private final Channel channel;
 
-  private final ChannelManager channelManager;
-  private final NettyResponseFuture<?> future;
-  private final Channel channel;
+    public StreamedResponsePublisher(EventExecutor executor, ChannelManager channelManager, NettyResponseFuture<?> future, Channel channel) {
+        super(executor, HttpResponseBodyPart.class);
+        this.channelManager = channelManager;
+        this.future = future;
+        this.channel = channel;
+    }
 
-  StreamedResponsePublisher(EventExecutor executor, ChannelManager channelManager, NettyResponseFuture<?> future, Channel channel) {
-    super(executor, HttpResponseBodyPart.class);
-    this.channelManager = channelManager;
-    this.future = future;
-    this.channel = channel;
-  }
+    @Override
+    protected void cancelled() {
+        logger.debug("Subscriber cancelled, ignoring the rest of the body");
 
-  @Override
-  protected void cancelled() {
-    logger.debug("Subscriber cancelled, ignoring the rest of the body");
+        // The subscriber cancelled early, we need to drain the remaining elements from the stream
+        channelManager.drainChannelAndOffer(channel, future);
+        channel.pipeline().remove(StreamedResponsePublisher.class);
 
-    try {
-      future.done();
-    } catch (Exception t) {
-      // Never propagate exception once we know we are done.
-      logger.debug(t.getMessage(), t);
+        try {
+            future.done();
+        } catch (Exception t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
     }
 
-    // The subscriber cancelled early - this channel is dead and should be closed.
-    channelManager.closeChannel(channel);
-  }
-
-  NettyResponseFuture<?> future() {
-    return future;
-  }
+    NettyResponseFuture<?> future() {
+        return future;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index db1e915e1..42f6d792e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -13,10 +13,20 @@
  */
 package org.asynchttpclient.netty.handler;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
+import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
+
+import java.io.IOException;
+
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseStatus;
@@ -28,141 +38,135 @@
 import org.asynchttpclient.netty.ws.NettyWebSocket;
 import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 
-import java.io.IOException;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
-import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
-
 @Sharable
 public final class WebSocketHandler extends AsyncHttpClientHandler {
 
-  public WebSocketHandler(AsyncHttpClientConfig config,
-                          ChannelManager channelManager,
-                          NettyRequestSender requestSender) {
-    super(config, channelManager, requestSender);
-  }
-
-  private static WebSocketUpgradeHandler getWebSocketUpgradeHandler(NettyResponseFuture<?> future) {
-    return (WebSocketUpgradeHandler) future.getAsyncHandler();
-  }
-
-  private static NettyWebSocket getNettyWebSocket(NettyResponseFuture<?> future) throws Exception {
-    return getWebSocketUpgradeHandler(future).onCompleted();
-  }
-
-  private void upgrade(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponse response, HttpHeaders responseHeaders)
-          throws Exception {
-    boolean validStatus = response.status().equals(SWITCHING_PROTOCOLS);
-    boolean validUpgrade = response.headers().get(UPGRADE) != null;
-    String connection = response.headers().get(CONNECTION);
-    boolean validConnection = HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection);
-    final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
-    if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
-      requestSender.abort(channel, future, new IOException("Invalid handshake response"));
-      return;
+    public WebSocketHandler(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender) {
+        super(config, channelManager, requestSender);
     }
 
-    String accept = response.headers().get(SEC_WEBSOCKET_ACCEPT);
-    String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(SEC_WEBSOCKET_KEY));
-    if (accept == null || !accept.equals(key)) {
-      requestSender.abort(channel, future, new IOException("Invalid challenge. Actual: " + accept + ". Expected: " + key));
-    }
+    private void upgrade(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponse response, HttpHeaders responseHeaders)
+            throws Exception {
+        boolean validStatus = response.status().equals(SWITCHING_PROTOCOLS);
+        boolean validUpgrade = response.headers().get(UPGRADE) != null;
+        String connection = response.headers().get(CONNECTION);
+        boolean validConnection = HttpHeaderValues.UPGRADE.contentEqualsIgnoreCase(connection);
+        final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
+        if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
+            requestSender.abort(channel, future, new IOException("Invalid handshake response"));
+            return;
+        }
+
+        String accept = response.headers().get(SEC_WEBSOCKET_ACCEPT);
+        String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(SEC_WEBSOCKET_KEY));
+        if (accept == null || !accept.equals(key)) {
+            requestSender.abort(channel, future, new IOException("Invalid challenge. Actual: " + accept + ". Expected: " + key));
+        }
 
-    // set back the future so the protocol gets notified of frames
-    // removing the HttpClientCodec from the pipeline might trigger a read with a WebSocket message
-    // if it comes in the same frame as the HTTP Upgrade response
-    Channels.setAttribute(channel, future);
+        // set back the future so the protocol gets notified of frames
+        // removing the HttpClientCodec from the pipeline might trigger a read with a WebSocket message
+        // if it comes in the same frame as the HTTP Upgrade response
+        Channels.setAttribute(channel, future);
 
-    handler.setWebSocket(new NettyWebSocket(channel, responseHeaders));
-    channelManager.upgradePipelineForWebSockets(channel.pipeline());
+        handler.setWebSocket(new NettyWebSocket(channel, responseHeaders));
+        channelManager.upgradePipelineForWebSockets(channel.pipeline());
 
-    // We don't need to synchronize as replacing the "ws-decoder" will
-    // process using the same thread.
-    try {
-      handler.onOpen();
-    } catch (Exception ex) {
-      logger.warn("onSuccess unexpected exception", ex);
+        // We don't need to synchronize as replacing the "ws-decoder" will
+        // process using the same thread.
+        try {
+            handler.onOpen();
+        } catch (Exception ex) {
+            logger.warn("onSuccess unexpected exception", ex);
+        }
+        future.done();
     }
-    future.done();
-  }
-
-  private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponseStatus status) {
-    try {
-      handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
-    } finally {
-      finishUpdate(future, channel, true);
+
+    private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgradeHandler handler, HttpResponseStatus status) throws Exception {
+        try {
+            handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
+        } finally {
+            finishUpdate(future, channel, false, false);
+        }
     }
-  }
-
-  @Override
-  public void handleRead(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
-
-    if (e instanceof HttpResponse) {
-      HttpResponse response = (HttpResponse) e;
-      if (logger.isDebugEnabled()) {
-        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
-      }
-
-      WebSocketUpgradeHandler handler = getWebSocketUpgradeHandler(future);
-      HttpResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
-      HttpHeaders responseHeaders = response.headers();
-
-      if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
-        switch (handler.onStatusReceived(status)) {
-          case CONTINUE:
-            upgrade(channel, future, handler, response, responseHeaders);
-            break;
-          default:
-            abort(channel, future, handler, status);
+
+    private static WebSocketUpgradeHandler getWebSocketUpgradeHandler(NettyResponseFuture<?> future) {
+        return (WebSocketUpgradeHandler) future.getAsyncHandler();
+    }
+    
+    private static NettyWebSocket getNettyWebSocket(NettyResponseFuture<?> future) throws Exception {
+        return getWebSocketUpgradeHandler(future).onCompleted();
+    }
+    
+    @Override
+    public void handleRead(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+
+        if (e instanceof HttpResponse) {
+            HttpResponse response = (HttpResponse) e;
+            if (logger.isDebugEnabled()) {
+                HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+                logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+            }
+
+            WebSocketUpgradeHandler handler = getWebSocketUpgradeHandler(future);
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
+            HttpHeaders responseHeaders = response.headers();
+
+            if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+                switch (handler.onStatusReceived(status)) {
+                case CONTINUE:
+                    upgrade(channel, future, handler, response, responseHeaders);
+                    break;
+                default:
+                    abort(channel, future, handler, status);
+                }
+            }
+
+        } else if (e instanceof WebSocketFrame) {
+            WebSocketFrame frame = (WebSocketFrame) e;
+            NettyWebSocket webSocket = getNettyWebSocket(future);
+            // retain because we might buffer the frame
+            if (webSocket.isReady()) {
+                webSocket.handleFrame(frame);
+            } else {
+                // WebSocket hasn't been open yet, but upgrading the pipeline triggered a read and a frame was sent along the HTTP upgrade response
+                // as we want to keep sequential order (but can't notify user of open before upgrading so he doesn't to try send immediately), we have to buffer
+                webSocket.bufferFrame(frame);
+            }
+
+        } else if (!(e instanceof LastHttpContent)) {
+            // ignore, end of handshake response
+            logger.error("Invalid message {}", e);
         }
-      }
-
-    } else if (e instanceof WebSocketFrame) {
-      WebSocketFrame frame = (WebSocketFrame) e;
-      NettyWebSocket webSocket = getNettyWebSocket(future);
-      // retain because we might buffer the frame
-      if (webSocket.isReady()) {
-        webSocket.handleFrame(frame);
-      } else {
-        // WebSocket hasn't been open yet, but upgrading the pipeline triggered a read and a frame was sent along the HTTP upgrade response
-        // as we want to keep sequential order (but can't notify user of open before upgrading so he doesn't to try send immediately), we have to buffer
-        webSocket.bufferFrame(frame);
-      }
-
-    } else if (!(e instanceof LastHttpContent)) {
-      // ignore, end of handshake response
-      logger.error("Invalid message {}", e);
     }
-  }
-
-  @Override
-  public void handleException(NettyResponseFuture<?> future, Throwable e) {
-    logger.warn("onError", e);
-
-    try {
-      NettyWebSocket webSocket = getNettyWebSocket(future);
-      if (webSocket != null) {
-        webSocket.onError(e);
-        webSocket.sendCloseFrame();
-      }
-    } catch (Throwable t) {
-      logger.error("onError", t);
+
+    @Override
+    public void handleException(NettyResponseFuture<?> future, Throwable e) {
+        logger.warn("onError", e);
+
+        try {
+            NettyWebSocket webSocket = getNettyWebSocket(future);
+            if (webSocket != null) {
+                webSocket.onError(e);
+                webSocket.sendCloseFrame();
+            }
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
     }
-  }
-
-  @Override
-  public void handleChannelInactive(NettyResponseFuture<?> future) {
-    logger.trace("Connection was closed abnormally (that is, with no close frame being received).");
-
-    try {
-      NettyWebSocket webSocket = getNettyWebSocket(future);
-      if (webSocket != null) {
-        webSocket.onClose(1006, "Connection was closed abnormally (that is, with no close frame being received).");
-      }
-    } catch (Throwable t) {
-      logger.error("onError", t);
+
+    @Override
+    public void handleChannelInactive(NettyResponseFuture<?> future) {
+        logger.trace("Connection was closed abnormally (that is, with no close frame being received).");
+
+        try {
+            NettyWebSocket webSocket = getNettyWebSocket(future);
+            if (webSocket != null) {
+                webSocket.onClose(1006, "Connection was closed abnormally (that is, with no close frame being received).");
+            }
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
index a09620dca..8da166e20 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
@@ -14,6 +14,10 @@
 package org.asynchttpclient.netty.handler.intercept;
 
 import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpRequest;
+
+import java.io.IOException;
+
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.netty.NettyResponseFuture;
@@ -26,32 +30,35 @@
 
 public class ConnectSuccessInterceptor {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(ConnectSuccessInterceptor.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectSuccessInterceptor.class);
 
-  private final ChannelManager channelManager;
-  private final NettyRequestSender requestSender;
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
 
-  ConnectSuccessInterceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-    this.channelManager = channelManager;
-    this.requestSender = requestSender;
-  }
+    public ConnectSuccessInterceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+    }
 
-  public boolean exitAfterHandlingConnect(Channel channel,
-                                          NettyResponseFuture<?> future,
-                                          Request request,
-                                          ProxyServer proxyServer) {
+    public boolean exitAfterHandlingConnect(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            final Request request,//
+            ProxyServer proxyServer,//
+            int statusCode,//
+            HttpRequest httpRequest) throws IOException {
 
-    if (future.isKeepAlive())
-      future.attachChannel(channel, true);
+        if (future.isKeepAlive())
+            future.attachChannel(channel, true);
 
-    Uri requestUri = request.getUri();
-    LOGGER.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
+        Uri requestUri = request.getUri();
+        LOGGER.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
 
-    channelManager.updatePipelineForHttpTunneling(channel.pipeline(), requestUri);
-    future.setReuseChannel(true);
-    future.setConnectAllowed(false);
-    requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
+        channelManager.upgradeProtocol(channel.pipeline(), requestUri);
+        future.setReuseChannel(true);
+        future.setConnectAllowed(false);
+        requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
 
-    return true;
-  }
+        return true;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
index 86eb39f7f..189aedf5f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
@@ -14,30 +14,33 @@
 package org.asynchttpclient.netty.handler.intercept;
 
 import io.netty.channel.Channel;
-import org.asynchttpclient.netty.NettyResponseFuture;
+
+import java.io.IOException;
+
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
+import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
-class Continue100Interceptor {
+public class Continue100Interceptor {
 
-  private final NettyRequestSender requestSender;
+    private final NettyRequestSender requestSender;
 
-  Continue100Interceptor(NettyRequestSender requestSender) {
-    this.requestSender = requestSender;
-  }
+    public Continue100Interceptor(NettyRequestSender requestSender) {
+        this.requestSender = requestSender;
+    }
 
-  public boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future) {
-    future.setHeadersAlreadyWrittenOnContinue(true);
-    future.setDontWriteBodyBecauseExpectContinue(false);
-    // directly send the body
-    Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
-      @Override
-      public void call() {
-        Channels.setAttribute(channel, future);
-        requestSender.writeRequest(future, channel);
-      }
-    });
-    return true;
-  }
+    public boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
+        future.setHeadersAlreadyWrittenOnContinue(true);
+        future.setDontWriteBodyBecauseExpectContinue(false);
+        // directly send the body
+        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
+            @Override
+            public void call() throws IOException {
+                Channels.setAttribute(channel, future);
+                requestSender.writeRequest(future, channel);
+            }
+        });
+        return true;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
index 373951362..ce144d38b 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
@@ -13,89 +13,82 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
-import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.*;
-import org.asynchttpclient.cookie.CookieStore;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.proxy.ProxyServer;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
-import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
-
 public class Interceptors {
 
-  private final AsyncHttpClientConfig config;
-  private final Unauthorized401Interceptor unauthorized401Interceptor;
-  private final ProxyUnauthorized407Interceptor proxyUnauthorized407Interceptor;
-  private final Continue100Interceptor continue100Interceptor;
-  private final Redirect30xInterceptor redirect30xInterceptor;
-  private final ConnectSuccessInterceptor connectSuccessInterceptor;
-  private final ResponseFiltersInterceptor responseFiltersInterceptor;
-  private final boolean hasResponseFilters;
+    private final AsyncHttpClientConfig config;
+    private final Unauthorized401Interceptor unauthorized401Interceptor;
+    private final ProxyUnauthorized407Interceptor proxyUnauthorized407Interceptor;
+    private final Continue100Interceptor continue100Interceptor;
+    private final Redirect30xInterceptor redirect30xInterceptor;
+    private final ConnectSuccessInterceptor connectSuccessInterceptor;
+    private final ResponseFiltersInterceptor responseFiltersInterceptor;
+    private final boolean hasResponseFilters;
 
-  public Interceptors(AsyncHttpClientConfig config,
-                      ChannelManager channelManager,
-                      NettyRequestSender requestSender) {
-    this.config = config;
-    unauthorized401Interceptor = new Unauthorized401Interceptor(channelManager, requestSender);
-    proxyUnauthorized407Interceptor = new ProxyUnauthorized407Interceptor(channelManager, requestSender);
-    continue100Interceptor = new Continue100Interceptor(requestSender);
-    redirect30xInterceptor = new Redirect30xInterceptor(channelManager, config, requestSender);
-    connectSuccessInterceptor = new ConnectSuccessInterceptor(channelManager, requestSender);
-    responseFiltersInterceptor = new ResponseFiltersInterceptor(config, requestSender);
-    hasResponseFilters = !config.getResponseFilters().isEmpty();
-  }
-
-  public boolean exitAfterIntercept(Channel channel,
-                                    NettyResponseFuture<?> future,
-                                    AsyncHandler<?> handler,
-                                    HttpResponse response,
-                                    HttpResponseStatus status,
-                                    HttpHeaders responseHeaders) throws Exception {
+    public Interceptors(//
+            AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender) {
+        this.config = config;
+        unauthorized401Interceptor = new Unauthorized401Interceptor(channelManager, requestSender);
+        proxyUnauthorized407Interceptor = new ProxyUnauthorized407Interceptor(channelManager, requestSender);
+        continue100Interceptor = new Continue100Interceptor(requestSender);
+        redirect30xInterceptor = new Redirect30xInterceptor(channelManager, config, requestSender);
+        connectSuccessInterceptor = new ConnectSuccessInterceptor(channelManager, requestSender);
+        responseFiltersInterceptor = new ResponseFiltersInterceptor(config, requestSender);
+        hasResponseFilters = !config.getResponseFilters().isEmpty();
+    }
 
-    HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-    ProxyServer proxyServer = future.getProxyServer();
-    int statusCode = response.status().code();
-    Request request = future.getCurrentRequest();
-    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+    public boolean exitAfterIntercept(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler,//
+            HttpResponse response,//
+            HttpResponseStatus status,//
+            HttpHeaders responseHeaders) throws Exception {
 
-    // This MUST BE called before Redirect30xInterceptor because latter assumes cookie store is already updated
-    CookieStore cookieStore = config.getCookieStore();
-    if (cookieStore != null) {
-      for (String cookieStr : responseHeaders.getAll(SET_COOKIE)) {
-        Cookie c = ClientCookieDecoder.STRICT.decode(cookieStr);
-        cookieStore.add(future.getCurrentRequest().getUri(), c);
-      }
-    }
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        ProxyServer proxyServer = future.getProxyServer();
+        int statusCode = response.status().code();
+        Request request = future.getCurrentRequest();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
 
-    if (hasResponseFilters && responseFiltersInterceptor.exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
-      return true;
-    }
+        if (hasResponseFilters && responseFiltersInterceptor.exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+            return true;
+        }
 
-    if (statusCode == UNAUTHORIZED_401) {
-      return unauthorized401Interceptor.exitAfterHandling401(channel, future, response, request, realm, httpRequest);
+        if (statusCode == UNAUTHORIZED_401) {
+            return unauthorized401Interceptor.exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer, httpRequest);
 
-    } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
-      return proxyUnauthorized407Interceptor.exitAfterHandling407(channel, future, response, request, proxyServer, httpRequest);
+        } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
+            return proxyUnauthorized407Interceptor.exitAfterHandling407(channel, future, response, request, statusCode, proxyServer, httpRequest);
 
-    } else if (statusCode == CONTINUE_100) {
-      return continue100Interceptor.exitAfterHandling100(channel, future);
+        } else if (statusCode == CONTINUE_100) {
+            return continue100Interceptor.exitAfterHandling100(channel, future, statusCode);
 
-    } else if (Redirect30xInterceptor.REDIRECT_STATUSES.contains(statusCode)) {
-      return redirect30xInterceptor.exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
+        } else if (Redirect30xInterceptor.REDIRECT_STATUSES.contains(statusCode)) {
+            return redirect30xInterceptor.exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
 
-    } else if (httpRequest.method() == HttpMethod.CONNECT && statusCode == OK_200) {
-      return connectSuccessInterceptor.exitAfterHandlingConnect(channel, future, request, proxyServer);
+        } else if (httpRequest.method() == HttpMethod.CONNECT && statusCode == OK_200) {
+            return connectSuccessInterceptor.exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest);
 
+        }
+        return false;
     }
-    return false;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
index 0812083ad..89ac2cf62 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
@@ -13,8 +13,19 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpUtil;
+
+import java.util.List;
+
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
@@ -30,187 +41,186 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.List;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.AuthenticatorUtils.NEGOTIATE;
-import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
-import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
-
 public class ProxyUnauthorized407Interceptor {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(ProxyUnauthorized407Interceptor.class);
-
-  private final ChannelManager channelManager;
-  private final NettyRequestSender requestSender;
-
-  ProxyUnauthorized407Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-    this.channelManager = channelManager;
-    this.requestSender = requestSender;
-  }
+    private static final Logger LOGGER = LoggerFactory.getLogger(ProxyUnauthorized407Interceptor.class);
 
-  public boolean exitAfterHandling407(Channel channel,
-                                      NettyResponseFuture<?> future,
-                                      HttpResponse response,
-                                      Request request,
-                                      ProxyServer proxyServer,
-                                      HttpRequest httpRequest) {
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
 
-    if (future.isAndSetInProxyAuth(true)) {
-      LOGGER.info("Can't handle 407 as auth was already performed");
-      return false;
+    public ProxyUnauthorized407Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
     }
 
-    Realm proxyRealm = future.getProxyRealm();
-
-    if (proxyRealm == null) {
-      LOGGER.debug("Can't handle 407 as there's no proxyRealm");
-      return false;
-    }
+    public boolean exitAfterHandling407(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
+
+        if (future.isAndSetInProxyAuth(true)) {
+            LOGGER.info("Can't handle 407 as auth was already performed");
+            return false;
+        }
 
-    List<String> proxyAuthHeaders = response.headers().getAll(PROXY_AUTHENTICATE);
+        Realm proxyRealm = future.getProxyRealm();
 
-    if (proxyAuthHeaders.isEmpty()) {
-      LOGGER.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
-      return false;
-    }
+        if (proxyRealm == null) {
+            LOGGER.debug("Can't handle 407 as there's no proxyRealm");
+            return false;
+        }
 
-    // FIXME what's this???
-    future.setChannelState(ChannelState.NEW);
-    HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+        List<String> proxyAuthHeaders = response.headers().getAll(PROXY_AUTHENTICATE);
 
-    switch (proxyRealm.getScheme()) {
-      case BASIC:
-        if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
-          LOGGER.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
-          return false;
+        if (proxyAuthHeaders.isEmpty()) {
+            LOGGER.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
+            return false;
         }
 
-        if (proxyRealm.isUsePreemptiveAuth()) {
-          // FIXME do we need this, as future.getAndSetAuth
-          // was tested above?
-          // auth was already performed, most likely auth
-          // failed
-          LOGGER.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
-          return false;
+        // FIXME what's this???
+        future.setChannelState(ChannelState.NEW);
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+
+        switch (proxyRealm.getScheme()) {
+        case BASIC:
+            if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
+                LOGGER.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+
+            if (proxyRealm.isUsePreemptiveAuth()) {
+                // FIXME do we need this, as future.getAndSetAuth
+                // was tested above?
+                // auth was already performed, most likely auth
+                // failed
+                LOGGER.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
+                return false;
+            }
+
+            // FIXME do we want to update the realm, or directly
+            // set the header?
+            Realm newBasicRealm = realm(proxyRealm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setProxyRealm(newBasicRealm);
+            break;
+
+        case DIGEST:
+            String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
+            if (digestHeader == null) {
+                LOGGER.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            Realm newDigestRealm = realm(proxyRealm)//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setUsePreemptiveAuth(true)//
+                    .parseProxyAuthenticateHeader(digestHeader)//
+                    .build();
+            future.setProxyRealm(newDigestRealm);
+            break;
+
+        case NTLM:
+            String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+            if (ntlmHeader == null) {
+                LOGGER.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            ntlmProxyChallenge(ntlmHeader, request, requestHeaders, proxyRealm, future);
+            Realm newNtlmRealm = realm(proxyRealm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setProxyRealm(newNtlmRealm);
+            break;
+
+        case KERBEROS:
+        case SPNEGO:
+            if (getHeaderWithPrefix(proxyAuthHeaders, NEGOTIATE) == null) {
+                LOGGER.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            try {
+                kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, proxyRealm, requestHeaders, future);
+
+            } catch (SpnegoEngineException e) {
+                // FIXME
+                String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+                if (ntlmHeader2 != null) {
+                    LOGGER.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
+                    ntlmProxyChallenge(ntlmHeader2, request, requestHeaders, proxyRealm, future);
+                    Realm newNtlmRealm2 = realm(proxyRealm)//
+                            .setScheme(AuthScheme.NTLM)//
+                            .setUsePreemptiveAuth(true)//
+                            .build();
+                    future.setProxyRealm(newNtlmRealm2);
+                } else {
+                    requestSender.abort(channel, future, e);
+                    return false;
+                }
+            }
+            break;
+        default:
+            throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
         }
 
-        // FIXME do we want to update the realm, or directly
-        // set the header?
-        Realm newBasicRealm = realm(proxyRealm)
-                .setUsePreemptiveAuth(true)
-                .build();
-        future.setProxyRealm(newBasicRealm);
-        break;
-
-      case DIGEST:
-        String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
-        if (digestHeader == null) {
-          LOGGER.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
-          return false;
-        }
-        Realm newDigestRealm = realm(proxyRealm)
-                .setUri(request.getUri())
-                .setMethodName(request.getMethod())
-                .setUsePreemptiveAuth(true)
-                .parseProxyAuthenticateHeader(digestHeader)
-                .build();
-        future.setProxyRealm(newDigestRealm);
-        break;
-
-      case NTLM:
-        String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-        if (ntlmHeader == null) {
-          LOGGER.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
-          return false;
+        RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
+        if (future.getCurrentRequest().getUri().isSecured()) {
+            nextRequestBuilder.setMethod(CONNECT);
         }
-        ntlmProxyChallenge(ntlmHeader, requestHeaders, proxyRealm, future);
-        Realm newNtlmRealm = realm(proxyRealm)
-                .setUsePreemptiveAuth(true)
-                .build();
-        future.setProxyRealm(newNtlmRealm);
-        break;
-
-      case KERBEROS:
-      case SPNEGO:
-        if (getHeaderWithPrefix(proxyAuthHeaders, NEGOTIATE) == null) {
-          LOGGER.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
-          return false;
+        final Request nextRequest = nextRequestBuilder.build();
+
+        LOGGER.debug("Sending proxy authentication to {}", request.getUri());
+        if (future.isKeepAlive()//
+                && !HttpUtil.isTransferEncodingChunked(httpRequest)//
+                && !HttpUtil.isTransferEncodingChunked(response)) {
+            future.setConnectAllowed(true);
+            future.setReuseChannel(true);
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+        } else {
+            channelManager.closeChannel(channel);
+            requestSender.sendNextRequest(nextRequest, future);
         }
-        try {
-          kerberosProxyChallenge(proxyServer, requestHeaders);
-
-        } catch (SpnegoEngineException e) {
-          // FIXME
-          String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-          if (ntlmHeader2 != null) {
-            LOGGER.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
-            ntlmProxyChallenge(ntlmHeader2, requestHeaders, proxyRealm, future);
-            Realm newNtlmRealm2 = realm(proxyRealm)
-                    .setScheme(AuthScheme.NTLM)
-                    .setUsePreemptiveAuth(true)
-                    .build();
-            future.setProxyRealm(newNtlmRealm2);
-          } else {
-            requestSender.abort(channel, future, e);
-            return false;
-          }
-        }
-        break;
-      default:
-        throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
-    }
 
-    RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
-    if (future.getCurrentRequest().getUri().isSecured()) {
-      nextRequestBuilder.setMethod(CONNECT);
+        return true;
     }
-    final Request nextRequest = nextRequestBuilder.build();
-
-    LOGGER.debug("Sending proxy authentication to {}", request.getUri());
-    if (future.isKeepAlive()
-            && !HttpUtil.isTransferEncodingChunked(httpRequest)
-            && !HttpUtil.isTransferEncodingChunked(response)) {
-      future.setConnectAllowed(true);
-      future.setReuseChannel(true);
-      requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-    } else {
-      channelManager.closeChannel(channel);
-      requestSender.sendNextRequest(nextRequest, future);
+
+    private void kerberosProxyChallenge(Channel channel,//
+            List<String> proxyAuth,//
+            Request request,//
+            ProxyServer proxyServer,//
+            Realm proxyRealm,//
+            HttpHeaders headers,//
+            NettyResponseFuture<?> future) throws SpnegoEngineException {
+
+        String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
+        headers.set(PROXY_AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
     }
 
-    return true;
-  }
-
-  private void kerberosProxyChallenge(ProxyServer proxyServer,
-                                      HttpHeaders headers) throws SpnegoEngineException {
-
-    String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
-    headers.set(PROXY_AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
-  }
-
-  private void ntlmProxyChallenge(String authenticateHeader,
-                                  HttpHeaders requestHeaders,
-                                  Realm proxyRealm,
-                                  NettyResponseFuture<?> future) {
-
-    if (authenticateHeader.equals("NTLM")) {
-      // server replied bare NTLM => we didn't preemptively sent Type1Msg
-      String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-      // FIXME we might want to filter current NTLM and add (leave other
-      // Authorization headers untouched)
-      requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-      future.setInProxyAuth(false);
-
-    } else {
-      String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-      String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
-              proxyRealm.getNtlmHost(), serverChallenge);
-      // FIXME we might want to filter current NTLM and add (leave other
-      // Authorization headers untouched)
-      requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+    private void ntlmProxyChallenge(String authenticateHeader,//
+            Request request,//
+            HttpHeaders requestHeaders,//
+            Realm proxyRealm,//
+            NettyResponseFuture<?> future) {
+
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+            future.setInProxyAuth(false);
+
+        } else {
+            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
+                    proxyRealm.getNtlmHost(), serverChallenge);
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index f490ce56d..907de704f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -13,17 +13,27 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
+import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
 import io.netty.handler.codec.http.cookie.Cookie;
+
+import java.util.HashSet;
+import java.util.Set;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.cookie.CookieStore;
 import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -32,158 +42,146 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.util.HttpConstants.Methods.GET;
-import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
-import static org.asynchttpclient.util.HttpUtils.followRedirect;
-import static org.asynchttpclient.util.HttpUtils.isSameBase;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-
 public class Redirect30xInterceptor {
 
-  public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
-  private static final Logger LOGGER = LoggerFactory.getLogger(Redirect30xInterceptor.class);
-
-  static {
-    REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
-    REDIRECT_STATUSES.add(FOUND_302);
-    REDIRECT_STATUSES.add(SEE_OTHER_303);
-    REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
-    REDIRECT_STATUSES.add(PERMANENT_REDIRECT_308);
-  }
-
-  private final ChannelManager channelManager;
-  private final AsyncHttpClientConfig config;
-  private final NettyRequestSender requestSender;
-  private final MaxRedirectException maxRedirectException;
-
-  Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
-    this.channelManager = channelManager;
-    this.config = config;
-    this.requestSender = requestSender;
-    maxRedirectException = unknownStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()), Redirect30xInterceptor.class,
-            "exitAfterHandlingRedirect");
-  }
-
-  public boolean exitAfterHandlingRedirect(Channel channel,
-                                           NettyResponseFuture<?> future,
-                                           HttpResponse response,
-                                           Request request,
-                                           int statusCode,
-                                           Realm realm) throws Exception {
-
-    if (followRedirect(config, request)) {
-      if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
-        throw maxRedirectException;
-
-      } else {
-        // We must allow auth handling again.
-        future.setInAuth(false);
-        future.setInProxyAuth(false);
-
-        String originalMethod = request.getMethod();
-        boolean switchToGet = !originalMethod.equals(GET)
-                && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
-        boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || statusCode == PERMANENT_REDIRECT_308 || (statusCode == FOUND_302 && config.isStrict302Handling());
-
-        final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)
-                .setChannelPoolPartitioning(request.getChannelPoolPartitioning())
-                .setFollowRedirect(true)
-                .setLocalAddress(request.getLocalAddress())
-                .setNameResolver(request.getNameResolver())
-                .setProxyServer(request.getProxyServer())
-                .setRealm(request.getRealm())
-                .setRequestTimeout(request.getRequestTimeout());
-
-        if (keepBody) {
-          requestBuilder.setCharset(request.getCharset());
-          if (isNonEmpty(request.getFormParams()))
-            requestBuilder.setFormParams(request.getFormParams());
-          else if (request.getStringData() != null)
-            requestBuilder.setBody(request.getStringData());
-          else if (request.getByteData() != null)
-            requestBuilder.setBody(request.getByteData());
-          else if (request.getByteBufferData() != null)
-            requestBuilder.setBody(request.getByteBufferData());
-          else if (request.getBodyGenerator() != null)
-            requestBuilder.setBody(request.getBodyGenerator());
-        }
-
-        requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
-
-        // in case of a redirect from HTTP to HTTPS, future
-        // attributes might change
-        final boolean initialConnectionKeepAlive = future.isKeepAlive();
-        final Object initialPartitionKey = future.getPartitionKey();
-
-        HttpHeaders responseHeaders = response.headers();
-        String location = responseHeaders.get(LOCATION);
-        Uri newUri = Uri.create(future.getUri(), location);
+    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
+    static {
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
+        REDIRECT_STATUSES.add(FOUND_302);
+        REDIRECT_STATUSES.add(SEE_OTHER_303);
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
+        REDIRECT_STATUSES.add(PERMANENT_REDIRECT_308);
+    }
 
-        LOGGER.debug("Redirecting to {}", newUri);
+    private static final Logger LOGGER = LoggerFactory.getLogger(Redirect30xInterceptor.class);
 
-        CookieStore cookieStore = config.getCookieStore();
-        if (cookieStore != null) {
-          // Update request's cookies assuming that cookie store is already updated by Interceptors
-          List<Cookie> cookies = cookieStore.get(newUri);
-          if (!cookies.isEmpty())
-            for (Cookie cookie : cookies)
-              requestBuilder.addOrReplaceCookie(cookie);
-        }
+    private final ChannelManager channelManager;
+    private final AsyncHttpClientConfig config;
+    private final NettyRequestSender requestSender;
+    private final MaxRedirectException maxRedirectException;
 
-        boolean sameBase = isSameBase(request.getUri(), newUri);
-
-        if (sameBase) {
-          // we can only assume the virtual host is still valid if the baseUrl is the same
-          requestBuilder.setVirtualHost(request.getVirtualHost());
-        }
+    public Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.config = config;
+        this.requestSender = requestSender;
+        maxRedirectException = unknownStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()), Redirect30xInterceptor.class,
+                "exitAfterHandlingRedirect");
+    }
 
-        final Request nextRequest = requestBuilder.setUri(newUri).build();
-        future.setTargetRequest(nextRequest);
-
-        LOGGER.debug("Sending redirect to {}", newUri);
-
-        if (future.isKeepAlive() && !HttpUtil.isTransferEncodingChunked(response)) {
-          if (sameBase) {
-            future.setReuseChannel(true);
-            // we can't directly send the next request because we still have to received LastContent
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-          } else {
-            channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
-            requestSender.sendNextRequest(nextRequest, future);
-          }
-
-        } else {
-          // redirect + chunking = WAT
-          channelManager.closeChannel(channel);
-          requestSender.sendNextRequest(nextRequest, future);
+    public boolean exitAfterHandlingRedirect(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            Realm realm) throws Exception {
+
+        if (followRedirect(config, request)) {
+            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
+                throw maxRedirectException;
+
+            } else {
+                // We must allow auth handling again.
+                future.setInAuth(false);
+                future.setInProxyAuth(false);
+
+                String originalMethod = request.getMethod();
+                boolean switchToGet = !originalMethod.equals(GET)
+                        && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
+                boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || statusCode == PERMANENT_REDIRECT_308 || (statusCode == FOUND_302 && config.isStrict302Handling());
+
+                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)//
+                        .setCookies(request.getCookies())//
+                        .setChannelPoolPartitioning(request.getChannelPoolPartitioning())//
+                        .setFollowRedirect(true)//
+                        .setLocalAddress(request.getLocalAddress())//
+                        .setNameResolver(request.getNameResolver())//
+                        .setProxyServer(request.getProxyServer())//
+                        .setRealm(request.getRealm())//
+                        .setRequestTimeout(request.getRequestTimeout());
+
+                if (keepBody) {
+                    requestBuilder.setCharset(request.getCharset());
+                    if (isNonEmpty(request.getFormParams()))
+                        requestBuilder.setFormParams(request.getFormParams());
+                    else if (request.getStringData() != null)
+                        requestBuilder.setBody(request.getStringData());
+                    else if (request.getByteData() != null)
+                        requestBuilder.setBody(request.getByteData());
+                    else if (request.getByteBufferData() != null)
+                        requestBuilder.setBody(request.getByteBufferData());
+                    else if (request.getBodyGenerator() != null)
+                        requestBuilder.setBody(request.getBodyGenerator());
+                }
+
+                requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
+
+                // in case of a redirect from HTTP to HTTPS, future
+                // attributes might change
+                final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                final Object initialPartitionKey = future.getPartitionKey();
+
+                HttpHeaders responseHeaders = response.headers();
+                String location = responseHeaders.get(LOCATION);
+                Uri newUri = Uri.create(future.getUri(), location);
+
+                LOGGER.debug("Redirecting to {}", newUri);
+
+                for (String cookieStr : responseHeaders.getAll(SET_COOKIE)) {
+                    Cookie c = ClientCookieDecoder.STRICT.decode(cookieStr);
+                    if (c != null)
+                        requestBuilder.addOrReplaceCookie(c);
+                }
+
+                boolean sameBase = isSameBase(request.getUri(), newUri);
+
+                if (sameBase) {
+                    // we can only assume the virtual host is still valid if the baseUrl is the same
+                    requestBuilder.setVirtualHost(request.getVirtualHost());
+                }
+
+                final Request nextRequest = requestBuilder.setUri(newUri).build();
+                future.setTargetRequest(nextRequest);
+
+                LOGGER.debug("Sending redirect to {}", newUri);
+
+                if (future.isKeepAlive() && !HttpUtil.isTransferEncodingChunked(response)) {
+
+                    if (sameBase) {
+                        future.setReuseChannel(true);
+                        // we can't directly send the next request because we still have to received LastContent
+                        requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+                    } else {
+                        channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
+                        requestSender.sendNextRequest(nextRequest, future);
+                    }
+
+                } else {
+                    // redirect + chunking = WAT
+                    channelManager.closeChannel(channel);
+                    requestSender.sendNextRequest(nextRequest, future);
+                }
+
+                return true;
+            }
         }
-
-        return true;
-      }
+        return false;
     }
-    return false;
-  }
 
-  private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
+    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
 
-    HttpHeaders headers = request.getHeaders()
-            .remove(HOST)
-            .remove(CONTENT_LENGTH);
+        HttpHeaders headers = request.getHeaders()//
+                .remove(HOST)//
+                .remove(CONTENT_LENGTH);
 
-    if (!keepBody) {
-      headers.remove(CONTENT_TYPE);
-    }
+        if (!keepBody) {
+            headers.remove(CONTENT_TYPE);
+        }
 
-    if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
-      headers.remove(AUTHORIZATION)
-              .remove(PROXY_AUTHORIZATION);
+        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
+            headers.remove(AUTHORIZATION)//
+                    .remove(PROXY_AUTHORIZATION);
+        }
+        return headers;
     }
-    return headers;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
index e0cd67225..8d449476a 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
@@ -13,8 +13,10 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseStatus;
@@ -24,46 +26,45 @@
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 public class ResponseFiltersInterceptor {
 
-  private final AsyncHttpClientConfig config;
-  private final NettyRequestSender requestSender;
+    private final AsyncHttpClientConfig config;
+    private final NettyRequestSender requestSender;
 
-  ResponseFiltersInterceptor(AsyncHttpClientConfig config, NettyRequestSender requestSender) {
-    this.config = config;
-    this.requestSender = requestSender;
-  }
+    public ResponseFiltersInterceptor(AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+        this.config = config;
+        this.requestSender = requestSender;
+    }
 
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  public boolean exitAfterProcessingFilters(Channel channel,
-                                            NettyResponseFuture<?> future,
-                                            AsyncHandler<?> handler,
-                                            HttpResponseStatus status,
-                                            HttpHeaders responseHeaders) {
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public boolean exitAfterProcessingFilters(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler, //
+            HttpResponseStatus status,//
+            HttpHeaders responseHeaders) {
 
-    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status)
-            .responseHeaders(responseHeaders).build();
+        FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status)
+                .responseHeaders(responseHeaders).build();
 
-    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-      try {
-        fc = asyncFilter.filter(fc);
-        // FIXME Is it worth protecting against this?
-        assertNotNull("fc", "filterContext");
-      } catch (FilterException efe) {
-        requestSender.abort(channel, future, efe);
-      }
-    }
+        for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                // FIXME Is it worth protecting against this?
+                assertNotNull("fc", "filterContext");
+            } catch (FilterException efe) {
+                requestSender.abort(channel, future, efe);
+            }
+        }
 
-    // The handler may have been wrapped.
-    future.setAsyncHandler(fc.getAsyncHandler());
+        // The handler may have been wrapped.
+        future.setAsyncHandler(fc.getAsyncHandler());
 
-    // The request has changed
-    if (fc.replayRequest()) {
-      requestSender.replayRequest(future, fc, channel);
-      return true;
+        // The request has changed
+        if (fc.replayRequest()) {
+            requestSender.replayRequest(future, fc, channel);
+            return true;
+        }
+        return false;
     }
-    return false;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
index e63daece5..6936ad9a6 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
@@ -13,8 +13,19 @@
  */
 package org.asynchttpclient.netty.handler.intercept;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpUtil;
+
+import java.util.List;
+
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
@@ -24,188 +35,188 @@
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.spnego.SpnegoEngine;
 import org.asynchttpclient.spnego.SpnegoEngineException;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.List;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
-import static io.netty.handler.codec.http.HttpHeaderNames.WWW_AUTHENTICATE;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.AuthenticatorUtils.NEGOTIATE;
-import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
-import static org.asynchttpclient.util.MiscUtils.withDefault;
-
 public class Unauthorized401Interceptor {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(Unauthorized401Interceptor.class);
-
-  private final ChannelManager channelManager;
-  private final NettyRequestSender requestSender;
-
-  Unauthorized401Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
-    this.channelManager = channelManager;
-    this.requestSender = requestSender;
-  }
+    private static final Logger LOGGER = LoggerFactory.getLogger(Unauthorized401Interceptor.class);
 
-  public boolean exitAfterHandling401(final Channel channel,
-                                      final NettyResponseFuture<?> future,
-                                      HttpResponse response,
-                                      final Request request,
-                                      Realm realm,
-                                      HttpRequest httpRequest) {
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
 
-    if (realm == null) {
-      LOGGER.debug("Can't handle 401 as there's no realm");
-      return false;
+    public Unauthorized401Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
     }
 
-    if (future.isAndSetInAuth(true)) {
-      LOGGER.info("Can't handle 401 as auth was already performed");
-      return false;
-    }
-
-    List<String> wwwAuthHeaders = response.headers().getAll(WWW_AUTHENTICATE);
+    public boolean exitAfterHandling401(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            final Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
+
+        if (realm == null) {
+            LOGGER.debug("Can't handle 401 as there's no realm");
+            return false;
+        }
 
-    if (wwwAuthHeaders.isEmpty()) {
-      LOGGER.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
-      return false;
-    }
+        if (future.isAndSetInAuth(true)) {
+            LOGGER.info("Can't handle 401 as auth was already performed");
+            return false;
+        }
 
-    // FIXME what's this???
-    future.setChannelState(ChannelState.NEW);
-    HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+        List<String> wwwAuthHeaders = response.headers().getAll(WWW_AUTHENTICATE);
 
-    switch (realm.getScheme()) {
-      case BASIC:
-        if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
-          LOGGER.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
-          return false;
+        if (wwwAuthHeaders.isEmpty()) {
+            LOGGER.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
+            return false;
         }
 
-        if (realm.isUsePreemptiveAuth()) {
-          // FIXME do we need this, as future.getAndSetAuth
-          // was tested above?
-          // auth was already performed, most likely auth
-          // failed
-          LOGGER.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
-          return false;
+        // FIXME what's this???
+        future.setChannelState(ChannelState.NEW);
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+
+        switch (realm.getScheme()) {
+        case BASIC:
+            if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
+                LOGGER.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+
+            if (realm.isUsePreemptiveAuth()) {
+                // FIXME do we need this, as future.getAndSetAuth
+                // was tested above?
+                // auth was already performed, most likely auth
+                // failed
+                LOGGER.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
+                return false;
+            }
+
+            // FIXME do we want to update the realm, or directly
+            // set the header?
+            Realm newBasicRealm = realm(realm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setRealm(newBasicRealm);
+            break;
+
+        case DIGEST:
+            String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
+            if (digestHeader == null) {
+                LOGGER.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+            Realm newDigestRealm = realm(realm)//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setUsePreemptiveAuth(true)//
+                    .parseWWWAuthenticateHeader(digestHeader)//
+                    .build();
+            future.setRealm(newDigestRealm);
+            break;
+
+        case NTLM:
+            String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+            if (ntlmHeader == null) {
+                LOGGER.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+
+            ntlmChallenge(ntlmHeader, request, requestHeaders, realm, future);
+            Realm newNtlmRealm = realm(realm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setRealm(newNtlmRealm);
+            break;
+
+        case KERBEROS:
+        case SPNEGO:
+            if (getHeaderWithPrefix(wwwAuthHeaders, NEGOTIATE) == null) {
+                LOGGER.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+            try {
+                kerberosChallenge(channel, wwwAuthHeaders, request, requestHeaders, realm, future);
+
+            } catch (SpnegoEngineException e) {
+                // FIXME
+                String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+                if (ntlmHeader2 != null) {
+                    LOGGER.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
+                    ntlmChallenge(ntlmHeader2, request, requestHeaders, realm, future);
+                    Realm newNtlmRealm2 = realm(realm)//
+                            .setScheme(AuthScheme.NTLM)//
+                            .setUsePreemptiveAuth(true)//
+                            .build();
+                    future.setRealm(newNtlmRealm2);
+                } else {
+                    requestSender.abort(channel, future, e);
+                    return false;
+                }
+            }
+            break;
+        default:
+            throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
         }
 
-        // FIXME do we want to update the realm, or directly
-        // set the header?
-        Realm newBasicRealm = realm(realm)
-                .setUsePreemptiveAuth(true)
-                .build();
-        future.setRealm(newBasicRealm);
-        break;
-
-      case DIGEST:
-        String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
-        if (digestHeader == null) {
-          LOGGER.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
-          return false;
-        }
-        Realm newDigestRealm = realm(realm)
-                .setUri(request.getUri())
-                .setMethodName(request.getMethod())
-                .setUsePreemptiveAuth(true)
-                .parseWWWAuthenticateHeader(digestHeader)
-                .build();
-        future.setRealm(newDigestRealm);
-        break;
-
-      case NTLM:
-        String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-        if (ntlmHeader == null) {
-          LOGGER.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
-          return false;
+        final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
+
+        LOGGER.debug("Sending authentication to {}", request.getUri());
+        if (future.isKeepAlive()//
+                && !HttpUtil.isTransferEncodingChunked(httpRequest)//
+                && !HttpUtil.isTransferEncodingChunked(response)) {
+            future.setReuseChannel(true);
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+        } else {
+            channelManager.closeChannel(channel);
+            requestSender.sendNextRequest(nextRequest, future);
         }
 
-        ntlmChallenge(ntlmHeader, requestHeaders, realm, future);
-        Realm newNtlmRealm = realm(realm)
-                .setUsePreemptiveAuth(true)
-                .build();
-        future.setRealm(newNtlmRealm);
-        break;
-
-      case KERBEROS:
-      case SPNEGO:
-        if (getHeaderWithPrefix(wwwAuthHeaders, NEGOTIATE) == null) {
-          LOGGER.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
-          return false;
-        }
-        try {
-          kerberosChallenge(request, requestHeaders);
-
-        } catch (SpnegoEngineException e) {
-          // FIXME
-          String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-          if (ntlmHeader2 != null) {
-            LOGGER.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
-            ntlmChallenge(ntlmHeader2, requestHeaders, realm, future);
-            Realm newNtlmRealm2 = realm(realm)
-                    .setScheme(AuthScheme.NTLM)
-                    .setUsePreemptiveAuth(true)
-                    .build();
-            future.setRealm(newNtlmRealm2);
-          } else {
-            requestSender.abort(channel, future, e);
-            return false;
-          }
-        }
-        break;
-      default:
-        throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
+        return true;
     }
 
-    final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
-
-    LOGGER.debug("Sending authentication to {}", request.getUri());
-    if (future.isKeepAlive()
-            && !HttpUtil.isTransferEncodingChunked(httpRequest)
-            && !HttpUtil.isTransferEncodingChunked(response)) {
-      future.setReuseChannel(true);
-      requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-    } else {
-      channelManager.closeChannel(channel);
-      requestSender.sendNextRequest(nextRequest, future);
+    private void ntlmChallenge(String authenticateHeader,//
+            Request request,//
+            HttpHeaders requestHeaders,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
+
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
+            future.setInAuth(false);
+
+        } else {
+            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
+        }
     }
 
-    return true;
-  }
-
-  private void ntlmChallenge(String authenticateHeader,
-                             HttpHeaders requestHeaders,
-                             Realm realm,
-                             NettyResponseFuture<?> future) {
-
-    if (authenticateHeader.equals("NTLM")) {
-      // server replied bare NTLM => we didn't preemptively sent Type1Msg
-      String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-      // FIXME we might want to filter current NTLM and add (leave other
-      // Authorization headers untouched)
-      requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
-      future.setInAuth(false);
-
-    } else {
-      String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-      String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
-      // FIXME we might want to filter current NTLM and add (leave other
-      // Authorization headers untouched)
-      requestHeaders.set(AUTHORIZATION, "NTLM " + challengeHeader);
+    private void kerberosChallenge(Channel channel,//
+            List<String> authHeaders,//
+            Request request,//
+            HttpHeaders headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) throws SpnegoEngineException {
+
+        Uri uri = request.getUri();
+        String host = withDefault(request.getVirtualHost(), uri.getHost());
+        String challengeHeader = SpnegoEngine.instance().generateToken(host);
+        headers.set(AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
     }
-  }
-
-  private void kerberosChallenge(Request request,
-                                 HttpHeaders headers) throws SpnegoEngineException {
-
-    Uri uri = request.getUri();
-    String host = withDefault(request.getVirtualHost(), uri.getHost());
-    String challengeHeader = SpnegoEngine.instance().generateToken(host);
-    headers.set(AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 494f2e90c..1bccecec4 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -12,103 +12,110 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.List;
+import java.util.concurrent.RejectedExecutionException;
+
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpClientState;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.SimpleChannelFutureListener;
 import org.asynchttpclient.netty.channel.NettyConnectListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.util.List;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-
 public class NettyChannelConnector {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyChannelConnector.class);
-
-  private static final AtomicIntegerFieldUpdater<NettyChannelConnector> I_UPDATER = AtomicIntegerFieldUpdater
-          .newUpdater(NettyChannelConnector.class, "i");
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyChannelConnector.class);
 
-  private final AsyncHandler<?> asyncHandler;
-  private final InetSocketAddress localAddress;
-  private final List<InetSocketAddress> remoteAddresses;
-  private final AsyncHttpClientState clientState;
-  private volatile int i = 0;
+    private final AsyncHandlerExtensions asyncHandlerExtensions;
+    private final InetSocketAddress localAddress;
+    private final List<InetSocketAddress> remoteAddresses;
+    private final AsyncHttpClientState clientState;
+    private volatile int i = 0;
 
-  NettyChannelConnector(InetAddress localAddress,
-                               List<InetSocketAddress> remoteAddresses,
-                               AsyncHandler<?> asyncHandler,
-                               AsyncHttpClientState clientState) {
-    this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
-    this.remoteAddresses = remoteAddresses;
-    this.asyncHandler = asyncHandler;
-    this.clientState = clientState;
-  }
+    public NettyChannelConnector(InetAddress localAddress,//
+            List<InetSocketAddress> remoteAddresses,//
+            AsyncHandler<?> asyncHandler,//
+            AsyncHttpClientState clientState,//
+            AsyncHttpClientConfig config) {
+        this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
+        this.remoteAddresses = remoteAddresses;
+        this.asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        this.clientState = clientState;
+    }
 
-  private boolean pickNextRemoteAddress() {
-    I_UPDATER.incrementAndGet(this);
-    return i < remoteAddresses.size();
-  }
+    private boolean pickNextRemoteAddress() {
+        i++;
+        return i < remoteAddresses.size();
+    }
 
-  public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
-    final InetSocketAddress remoteAddress = remoteAddresses.get(i);
+    public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
+        final InetSocketAddress remoteAddress = remoteAddresses.get(i);
 
-    try {
-      asyncHandler.onTcpConnectAttempt(remoteAddress);
-    } catch (Exception e) {
-      LOGGER.error("onTcpConnectAttempt crashed", e);
-      connectListener.onFailure(null, e);
-      return;
-    }
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);
+            } catch (Exception e) {
+                LOGGER.error("onTcpConnectAttempt crashed", e);
+                connectListener.onFailure(null, e);
+                return;
+            }
+        }
 
-    try {
-      connect0(bootstrap, connectListener, remoteAddress);
-    } catch (RejectedExecutionException e) {
-      if (clientState.isClosed()) {
-        LOGGER.info("Connect crash but engine is shutting down");
-      } else {
-        connectListener.onFailure(null, e);
-      }
+        try {
+            connect0(bootstrap, connectListener, remoteAddress);
+        } catch (RejectedExecutionException e) {
+            if (clientState.isClosed()) {
+                LOGGER.info("Connect crash but engine is shutting down");
+            } else {
+                connectListener.onFailure(null, e);
+            }
+        }
     }
-  }
 
-  private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {
+    private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {
 
-    bootstrap.connect(remoteAddress, localAddress)
-            .addListener(new SimpleChannelFutureListener() {
-              @Override
-              public void onSuccess(Channel channel) {
-                try {
-                  asyncHandler.onTcpConnectSuccess(remoteAddress, channel);
-                } catch (Exception e) {
-                  LOGGER.error("onTcpConnectSuccess crashed", e);
-                  connectListener.onFailure(channel, e);
-                  return;
-                }
-                connectListener.onSuccess(channel, remoteAddress);
-              }
+        bootstrap.connect(remoteAddress, localAddress)//
+                .addListener(new SimpleChannelFutureListener() {
+                    @Override
+                    public void onSuccess(Channel channel) {
+                        if (asyncHandlerExtensions != null) {
+                            try {
+                                asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);
+                            } catch (Exception e) {
+                                LOGGER.error("onTcpConnectSuccess crashed", e);
+                                connectListener.onFailure(channel, e);
+                                return;
+                            }
+                        }
+                        connectListener.onSuccess(channel, remoteAddress);
+                    }
 
-              @Override
-              public void onFailure(Channel channel, Throwable t) {
-                try {
-                  asyncHandler.onTcpConnectFailure(remoteAddress, t);
-                } catch (Exception e) {
-                  LOGGER.error("onTcpConnectFailure crashed", e);
-                  connectListener.onFailure(channel, e);
-                  return;
-                }
-                boolean retry = pickNextRemoteAddress();
-                if (retry) {
-                  NettyChannelConnector.this.connect(bootstrap, connectListener);
-                } else {
-                  connectListener.onFailure(channel, t);
-                }
-              }
-            });
-  }
+                    @Override
+                    public void onFailure(Channel channel, Throwable t) {
+                        if (asyncHandlerExtensions != null) {
+                            try {
+                                asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);
+                            } catch (Exception e) {
+                                LOGGER.error("onTcpConnectFailure crashed", e);
+                                connectListener.onFailure(channel, e);
+                                return;
+                            }
+                        }
+                        boolean retry = pickNextRemoteAddress();
+                        if (retry) {
+                            NettyChannelConnector.this.connect(bootstrap, connectListener);
+                        } else {
+                            connectListener.onFailure(channel, t);
+                        }
+                    }
+                });
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
index 186350157..65c067b4c 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
@@ -13,24 +13,25 @@
  */
 package org.asynchttpclient.netty.request;
 
-import io.netty.handler.codec.http.HttpRequest;
 import org.asynchttpclient.netty.request.body.NettyBody;
 
+import io.netty.handler.codec.http.HttpRequest;
+
 public final class NettyRequest {
 
-  private final HttpRequest httpRequest;
-  private final NettyBody body;
+    private final HttpRequest httpRequest;
+    private final NettyBody body;
 
-  NettyRequest(HttpRequest httpRequest, NettyBody body) {
-    this.httpRequest = httpRequest;
-    this.body = body;
-  }
+    public NettyRequest(HttpRequest httpRequest, NettyBody body) {
+        this.httpRequest = httpRequest;
+        this.body = body;
+    }
 
-  public HttpRequest getHttpRequest() {
-    return httpRequest;
-  }
+    public HttpRequest getHttpRequest() {
+        return httpRequest;
+    }
 
-  public NettyBody getBody() {
-    return body;
-  }
+    public NettyBody getBody() {
+        return body;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 6415c6cf9..a26f4fc06 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -13,14 +13,37 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.MiscUtils.*;
+import static org.asynchttpclient.ws.WebSocketUtils.getKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
+
+import java.nio.charset.Charset;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.netty.request.body.*;
+import org.asynchttpclient.netty.request.body.NettyBody;
+import org.asynchttpclient.netty.request.body.NettyBodyBody;
+import org.asynchttpclient.netty.request.body.NettyByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyByteBufferBody;
+import org.asynchttpclient.netty.request.body.NettyCompositeByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyDirectBody;
+import org.asynchttpclient.netty.request.body.NettyFileBody;
+import org.asynchttpclient.netty.request.body.NettyInputStreamBody;
+import org.asynchttpclient.netty.request.body.NettyMultipartBody;
+import org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.FileBodyGenerator;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
@@ -28,217 +51,208 @@
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.StringUtils;
 
-import java.nio.charset.Charset;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static org.asynchttpclient.util.AuthenticatorUtils.perRequestAuthorizationHeader;
-import static org.asynchttpclient.util.AuthenticatorUtils.perRequestProxyAuthorizationHeader;
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.ws.WebSocketUtils.getWebSocketKey;
-
 public final class NettyRequestFactory {
 
-  private static final String BROTLY_ACCEPT_ENCODING_SUFFIX = ", br";
-  private static final String GZIP_DEFLATE = HttpHeaderValues.GZIP + "," + HttpHeaderValues.DEFLATE;
+    public static final String BROTLY_ACCEPT_ENCODING_SUFFIX = ", br";
+    public static final String GZIP_DEFLATE = HttpHeaderValues.GZIP + "," + HttpHeaderValues.DEFLATE;
 
-  private final AsyncHttpClientConfig config;
-  private final ClientCookieEncoder cookieEncoder;
+    private final AsyncHttpClientConfig config;
+    private final ClientCookieEncoder cookieEncoder;
 
-  NettyRequestFactory(AsyncHttpClientConfig config) {
-    this.config = config;
-    cookieEncoder = config.isUseLaxCookieEncoder() ? ClientCookieEncoder.LAX : ClientCookieEncoder.STRICT;
-  }
-
-  private NettyBody body(Request request) {
-    NettyBody nettyBody = null;
-    Charset bodyCharset = request.getCharset();
+    public NettyRequestFactory(AsyncHttpClientConfig config) {
+        this.config = config;
+        cookieEncoder = config.isUseLaxCookieEncoder() ? ClientCookieEncoder.LAX : ClientCookieEncoder.STRICT;
+    }
 
-    if (request.getByteData() != null) {
-      nettyBody = new NettyByteArrayBody(request.getByteData());
+    private NettyBody body(Request request) {
+        NettyBody nettyBody = null;
+        Charset bodyCharset = withDefault(request.getCharset(), DEFAULT_CHARSET);
 
-    } else if (request.getCompositeByteData() != null) {
-      nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
+        if (request.getByteData() != null) {
+            nettyBody = new NettyByteArrayBody(request.getByteData());
 
-    } else if (request.getStringData() != null) {
-      nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
+        } else if (request.getCompositeByteData() != null) {
+            nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
 
-    } else if (request.getByteBufferData() != null) {
-      nettyBody = new NettyByteBufferBody(request.getByteBufferData());
+        } else if (request.getStringData() != null) {
+            nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
 
-    } else if (request.getStreamData() != null) {
-      nettyBody = new NettyInputStreamBody(request.getStreamData());
+        } else if (request.getByteBufferData() != null) {
+            nettyBody = new NettyByteBufferBody(request.getByteBufferData());
 
-    } else if (isNonEmpty(request.getFormParams())) {
-      CharSequence contentTypeOverride = request.getHeaders().contains(CONTENT_TYPE) ? null : HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED;
-      nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentTypeOverride);
+        } else if (request.getStreamData() != null) {
+            nettyBody = new NettyInputStreamBody(request.getStreamData());
 
-    } else if (isNonEmpty(request.getBodyParts())) {
-      nettyBody = new NettyMultipartBody(request.getBodyParts(), request.getHeaders(), config);
+        } else if (isNonEmpty(request.getFormParams())) {
+            CharSequence contentTypeOverride = request.getHeaders().contains(CONTENT_TYPE) ? null : HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED;
+            nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentTypeOverride);
 
-    } else if (request.getFile() != null) {
-      nettyBody = new NettyFileBody(request.getFile(), config);
+        } else if (isNonEmpty(request.getBodyParts())) {
+            nettyBody = new NettyMultipartBody(request.getBodyParts(), request.getHeaders(), config);
 
-    } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
-      FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
-      nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
+        } else if (request.getFile() != null) {
+            nettyBody = new NettyFileBody(request.getFile(), config);
 
-    } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
-      InputStreamBodyGenerator inStreamGenerator = InputStreamBodyGenerator.class.cast(request.getBodyGenerator());
-      nettyBody = new NettyInputStreamBody(inStreamGenerator.getInputStream(), inStreamGenerator.getContentLength());
+        } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
+            FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
+            nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
 
-    } else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator) {
-      ReactiveStreamsBodyGenerator reactiveStreamsBodyGenerator = (ReactiveStreamsBodyGenerator) request.getBodyGenerator();
-      nettyBody = new NettyReactiveStreamsBody(reactiveStreamsBodyGenerator.getPublisher(), reactiveStreamsBodyGenerator.getContentLength());
+        } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
+            InputStreamBodyGenerator inStreamGenerator = InputStreamBodyGenerator.class.cast(request.getBodyGenerator());
+            nettyBody = new NettyInputStreamBody(inStreamGenerator.getInputStream(), inStreamGenerator.getContentLength());
 
-    } else if (request.getBodyGenerator() != null) {
-      nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
-    }
+        } else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator) {
+            ReactiveStreamsBodyGenerator reactiveStreamsBodyGenerator = (ReactiveStreamsBodyGenerator) request.getBodyGenerator();
+            nettyBody = new NettyReactiveStreamsBody(reactiveStreamsBodyGenerator.getPublisher(), reactiveStreamsBodyGenerator.getContentLength());
 
-    return nettyBody;
-  }
-
-  public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
-    if (authorizationHeader != null)
-      // don't override authorization but append
-      headers.add(AUTHORIZATION, authorizationHeader);
-  }
+        } else if (request.getBodyGenerator() != null) {
+            nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
+        }
 
-  public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
-    if (proxyAuthorizationHeader != null)
-      headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
-  }
+        return nettyBody;
+    }
 
-  public NettyRequest newNettyRequest(Request request, boolean performConnectRequest, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
+    public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
+        if (authorizationHeader != null)
+            // don't override authorization but append
+            headers.add(AUTHORIZATION, authorizationHeader);
+    }
 
-    Uri uri = request.getUri();
-    HttpMethod method = performConnectRequest ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
-    boolean connect = method == HttpMethod.CONNECT;
+    public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
+        if (proxyAuthorizationHeader != null)
+            headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
+    }
 
-    HttpVersion httpVersion = HttpVersion.HTTP_1_1;
-    String requestUri = requestUri(uri, proxyServer, connect);
+    public NettyRequest newNettyRequest(Request request, boolean forceConnect, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
 
-    NettyBody body = connect ? null : body(request);
+        Uri uri = request.getUri();
+        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+        boolean connect = method == HttpMethod.CONNECT;
 
-    NettyRequest nettyRequest;
-    if (body == null) {
-      HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.EMPTY_BUFFER);
-      nettyRequest = new NettyRequest(httpRequest, null);
+        HttpVersion httpVersion = HttpVersion.HTTP_1_1;
+        String requestUri = requestUri(uri, proxyServer, connect);
 
-    } else if (body instanceof NettyDirectBody) {
-      ByteBuf buf = NettyDirectBody.class.cast(body).byteBuf();
-      HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, buf);
-      // body is passed as null as it's written directly with the request
-      nettyRequest = new NettyRequest(httpRequest, null);
+        NettyBody body = connect ? null : body(request);
 
-    } else {
-      HttpRequest httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
-      nettyRequest = new NettyRequest(httpRequest, body);
-    }
+        NettyRequest nettyRequest;
+        if (body == null) {
+            HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.EMPTY_BUFFER);
+            nettyRequest = new NettyRequest(httpRequest, null);
 
-    HttpHeaders headers = nettyRequest.getHttpRequest().headers();
+        } else if (body instanceof NettyDirectBody) {
+            ByteBuf buf = NettyDirectBody.class.cast(body).byteBuf();
+            HttpRequest httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, buf);
+            // body is passed as null as it's written directly with the request
+            nettyRequest = new NettyRequest(httpRequest, null);
 
-    if (connect) {
-      // assign proxy-auth as configured on request
-      headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
+        } else {
+            HttpRequest httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, body);
+        }
 
-    } else {
-      // assign headers as configured on request
-      headers.set(request.getHeaders());
+        HttpHeaders headers = nettyRequest.getHttpRequest().headers();
 
-      if (isNonEmpty(request.getCookies())) {
-        headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
-      }
+        if (connect) {
+            // assign proxy-auth as configured on request
+            headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
 
-      String userDefinedAcceptEncoding = headers.get(ACCEPT_ENCODING);
-      if (userDefinedAcceptEncoding != null) {
-        // we don't support Brotly ATM
-        if (userDefinedAcceptEncoding.endsWith(BROTLY_ACCEPT_ENCODING_SUFFIX)) {
-          headers.set(ACCEPT_ENCODING, userDefinedAcceptEncoding.subSequence(0, userDefinedAcceptEncoding.length() - BROTLY_ACCEPT_ENCODING_SUFFIX.length()));
+        } else {
+            // assign headers as configured on request
+            headers.set(request.getHeaders());
+
+            if (isNonEmpty(request.getCookies())) {
+                headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
+            }
+
+            String userDefinedAcceptEncoding = headers.get(ACCEPT_ENCODING);
+            if (userDefinedAcceptEncoding != null) {
+                // we don't support Brotly ATM
+                if (userDefinedAcceptEncoding.endsWith(BROTLY_ACCEPT_ENCODING_SUFFIX)) {
+                    headers.set(ACCEPT_ENCODING, userDefinedAcceptEncoding.subSequence(0, userDefinedAcceptEncoding.length() - BROTLY_ACCEPT_ENCODING_SUFFIX.length()));
+                }
+
+            } else if (config.isCompressionEnforced()) {
+                headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
+            }
         }
 
-      } else if (config.isCompressionEnforced()) {
-        headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
-      }
-    }
-
-    if (body != null) {
-      if (!headers.contains(CONTENT_LENGTH)) {
-        if (body.getContentLength() < 0) {
-          headers.set(TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-        } else {
-          headers.set(CONTENT_LENGTH, body.getContentLength());
+        if (body != null) {
+            if (!headers.contains(CONTENT_LENGTH)) {
+                if (body.getContentLength() < 0) {
+                    headers.set(TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
+                } else {
+                    headers.set(CONTENT_LENGTH, body.getContentLength());
+                }
+            }
+
+            if (body.getContentTypeOverride() != null) {
+                headers.set(CONTENT_TYPE, body.getContentTypeOverride());
+            }
         }
-      }
 
-      if (body.getContentTypeOverride() != null) {
-        headers.set(CONTENT_TYPE, body.getContentTypeOverride());
-      }
-    }
+        // connection header and friends
+        if (!connect && uri.isWebSocket()) {
+            headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)//
+                    .set(CONNECTION, HttpHeaderValues.UPGRADE)//
+                    .set(SEC_WEBSOCKET_KEY, getKey())//
+                    .set(SEC_WEBSOCKET_VERSION, "13");
+
+            if (!headers.contains(ORIGIN)) {
+                headers.set(ORIGIN, computeOriginHeader(uri));
+            }
+
+        } else if (!headers.contains(CONNECTION)) {
+            CharSequence connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
+            if (connectionHeaderValue != null) {
+                headers.set(CONNECTION, connectionHeaderValue);
+            }
+        }
 
-    // connection header and friends
-    if (!connect && uri.isWebSocket()) {
-      headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)
-              .set(CONNECTION, HttpHeaderValues.UPGRADE)
-              .set(SEC_WEBSOCKET_KEY, getWebSocketKey())
-              .set(SEC_WEBSOCKET_VERSION, "13");
-
-      if (!headers.contains(ORIGIN)) {
-        headers.set(ORIGIN, computeOriginHeader(uri));
-      }
-
-    } else if (!headers.contains(CONNECTION)) {
-      CharSequence connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
-      if (connectionHeaderValue != null) {
-        headers.set(CONNECTION, connectionHeaderValue);
-      }
-    }
+        if (!headers.contains(HOST)) {
+            headers.set(HOST, hostHeader(request, uri));
+        }
 
-    if (!headers.contains(HOST)) {
-      headers.set(HOST, hostHeader(request, uri));
-    }
+        // don't override authorization but append
+        addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
+        // only set proxy auth on request over plain HTTP, or when performing CONNECT
+        if (!uri.isSecured() || connect) {
+            setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyRealm));
+        }
 
-    // don't override authorization but append
-    addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
-    // only set proxy auth on request over plain HTTP, or when performing CONNECT
-    if (!uri.isSecured() || connect) {
-      setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyRealm));
-    }
+        // Add default accept headers
+        if (!headers.contains(ACCEPT)) {
+            headers.set(ACCEPT, "*/*");
+        }
 
-    // Add default accept headers
-    if (!headers.contains(ACCEPT)) {
-      headers.set(ACCEPT, "*/*");
-    }
+        // Add default user agent
+        if (!headers.contains(USER_AGENT) && config.getUserAgent() != null) {
+            headers.set(USER_AGENT, config.getUserAgent());
+        }
 
-    // Add default user agent
-    if (!headers.contains(USER_AGENT) && config.getUserAgent() != null) {
-      headers.set(USER_AGENT, config.getUserAgent());
+        return nettyRequest;
     }
 
-    return nettyRequest;
-  }
+    private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
+        if (connect) {
+            // proxy tunnelling, connect need host and explicit port
+            return getAuthority(uri);
 
-  private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
-    if (connect) {
-      // proxy tunnelling, connect need host and explicit port
-      return getAuthority(uri);
+        } else if (proxyServer != null && !uri.isSecured()) {
+            // proxy over HTTP, need full url
+            return uri.toUrl();
 
-    } else if (proxyServer != null && !uri.isSecured() && proxyServer.getProxyType().isHttp()) {
-      // proxy over HTTP, need full url
-      return uri.toUrl();
-
-    } else {
-      // direct connection to target host or tunnel already connected: only path and query
-      String path = getNonEmptyPath(uri);
-      return isNonEmpty(uri.getQuery()) ? path + "?" + uri.getQuery() : path;
+        } else {
+            // direct connection to target host or tunnel already connected: only path and query
+            String path = getNonEmptyPath(uri);
+            return isNonEmpty(uri.getQuery()) ? path + "?" + uri.getQuery() : path;
+        }
     }
-  }
 
-  private CharSequence connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
-    if (httpVersion.isKeepAliveDefault()) {
-      return keepAlive ? null : HttpHeaderValues.CLOSE;
-    } else {
-      return keepAlive ? HttpHeaderValues.KEEP_ALIVE : null;
+    private CharSequence connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
+        if (httpVersion.isKeepAliveDefault()) {
+            return keepAlive ? null : HttpHeaderValues.CLOSE;
+        } else {
+            return keepAlive ? HttpHeaderValues.KEEP_ALIVE : null;
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 334388628..6e3e0e0f6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -13,28 +13,56 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
+import static java.util.Collections.singletonList;
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+import static org.asynchttpclient.util.MiscUtils.getCause;
+import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelProgressivePromise;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.*;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.Timer;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
-import org.asynchttpclient.*;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClientState;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
 import org.asynchttpclient.exception.PoolAlreadyClosedException;
 import org.asynchttpclient.exception.RemotelyClosedException;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.SimpleFutureListener;
-import org.asynchttpclient.netty.channel.*;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ChannelState;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.channel.ConnectionSemaphore;
+import org.asynchttpclient.netty.channel.NettyConnectListener;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.resolver.RequestHostnameResolver;
@@ -43,575 +71,541 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.util.List;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
-import static java.util.Collections.singletonList;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionAuthorizationHeader;
-import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionProxyAuthorizationHeader;
-import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
-import static org.asynchttpclient.util.HttpConstants.Methods.GET;
-import static org.asynchttpclient.util.MiscUtils.getCause;
-import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
-
 public final class NettyRequestSender {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
-
-  private final AsyncHttpClientConfig config;
-  private final ChannelManager channelManager;
-  private final ConnectionSemaphore connectionSemaphore;
-  private final Timer nettyTimer;
-  private final AsyncHttpClientState clientState;
-  private final NettyRequestFactory requestFactory;
-
-  public NettyRequestSender(AsyncHttpClientConfig config,
-                            ChannelManager channelManager,
-                            Timer nettyTimer,
-                            AsyncHttpClientState clientState) {
-    this.config = config;
-    this.channelManager = channelManager;
-    this.connectionSemaphore = ConnectionSemaphore.newConnectionSemaphore(config);
-    this.nettyTimer = nettyTimer;
-    this.clientState = clientState;
-    requestFactory = new NettyRequestFactory(config);
-  }
-
-  public <T> ListenableFuture<T> sendRequest(final Request request,
-                                             final AsyncHandler<T> asyncHandler,
-                                             NettyResponseFuture<T> future) {
-
-    if (isClosed()) {
-      throw new IllegalStateException("Closed");
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
+
+    private final AsyncHttpClientConfig config;
+    private final ChannelManager channelManager;
+    private final ConnectionSemaphore connectionSemaphore;
+    private final Timer nettyTimer;
+    private final AsyncHttpClientState clientState;
+    private final NettyRequestFactory requestFactory;
+
+    public NettyRequestSender(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            ConnectionSemaphore connectionSemaphore,//
+            Timer nettyTimer,//
+            AsyncHttpClientState clientState) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.connectionSemaphore = connectionSemaphore;
+        this.nettyTimer = nettyTimer;
+        this.clientState = clientState;
+        requestFactory = new NettyRequestFactory(config);
     }
 
-    validateWebSocketRequest(request, asyncHandler);
-
-    ProxyServer proxyServer = getProxyServer(config, request);
-
-    // WebSockets use connect tunneling to work with proxies
-    if (proxyServer != null //
-            && (request.getUri().isSecured() || request.getUri().isWebSocket()) //
-            && !isConnectDone(request, future) //
-            && proxyServer.getProxyType().isHttp()) {
-      // Proxy with HTTPS or WebSocket: CONNECT for sure
-      if (future != null && future.isConnectAllowed()) {
-        // Perform CONNECT
-        return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, true);
-      } else {
-        // CONNECT will depend if we can pool or connection or if we have to open a new
-        // one
-        return sendRequestThroughSslProxy(request, asyncHandler, future, proxyServer);
-      }
-    } else {
-      // no CONNECT for sure
-      return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, false);
-    }
-  }
-
-  private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
-    return future != null //
-            && future.getNettyRequest() != null //
-            && future.getNettyRequest().getHttpRequest().method() == HttpMethod.CONNECT //
-            && !request.getMethod().equals(CONNECT);
-  }
-
-  /**
-   * We know for sure if we have to force to connect or not, so we can build the
-   * HttpRequest right away This reduces the probability of having a pooled
-   * channel closed by the server by the time we build the request
-   */
-  private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(Request request,
-                                                                     AsyncHandler<T> asyncHandler,
-                                                                     NettyResponseFuture<T> future,
-                                                                     ProxyServer proxyServer,
-                                                                     boolean performConnectRequest) {
-
-    NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer,
-            performConnectRequest);
-
-    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
-
-    return Channels.isChannelActive(channel)
-            ? sendRequestWithOpenChannel(newFuture, asyncHandler, channel)
-            : sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
-  }
-
-  /**
-   * Using CONNECT depends on wither we can fetch a valid channel or not Loop
-   * until we get a valid channel from the pool and it's still valid once the
-   * request is built @
-   */
-  private <T> ListenableFuture<T> sendRequestThroughSslProxy(Request request,
-                                                             AsyncHandler<T> asyncHandler,
-                                                             NettyResponseFuture<T> future,
-                                                             ProxyServer proxyServer) {
-
-    NettyResponseFuture<T> newFuture = null;
-    for (int i = 0; i < 3; i++) {
-      Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
-
-      if (channel == null) {
-        // pool is empty
-        break;
-      }
-
-      if (newFuture == null) {
-        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
-      }
-
-      if (Channels.isChannelActive(channel)) {
-        // if the channel is still active, we can use it,
-        // otherwise, channel was closed by the time we computed the request, try again
-        return sendRequestWithOpenChannel(newFuture, asyncHandler, channel);
-      }
+    public <T> ListenableFuture<T> sendRequest(final Request request,//
+            final AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean performingNextRequest) {
+
+        if (isClosed())
+            throw new IllegalStateException("Closed");
+
+        validateWebSocketRequest(request, asyncHandler);
+
+        ProxyServer proxyServer = getProxyServer(config, request);
+
+        // websockets use connect tunnelling to work with proxies
+        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))
+            if (future != null && future.isConnectAllowed())
+                // SSL proxy or websocket: CONNECT for sure
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, true);
+            else
+                // CONNECT will depend if we can pool or connection or if we have to open a new one
+                return sendRequestThroughSslProxy(request, asyncHandler, future, performingNextRequest, proxyServer);
+        else
+            // no CONNECT for sure
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);
     }
 
-    // couldn't poll an active channel
-    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
-    return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
-  }
-
-  private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request,
-                                                                      final AsyncHandler<T> asyncHandler,
-                                                                      NettyResponseFuture<T> originalFuture,
-                                                                      ProxyServer proxy,
-                                                                      boolean performConnectRequest) {
-
-    Realm realm;
-    if (originalFuture != null) {
-      realm = originalFuture.getRealm();
-    } else {
-      realm = request.getRealm();
-      if (realm == null) {
-        realm = config.getRealm();
-      }
+    private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
+        return future != null //
+                && future.getNettyRequest() != null //
+                && future.getNettyRequest().getHttpRequest().method() == HttpMethod.CONNECT //
+                && !request.getMethod().equals(CONNECT);
     }
 
-    Realm proxyRealm = null;
-    if (originalFuture != null) {
-      proxyRealm = originalFuture.getProxyRealm();
-    } else if (proxy != null) {
-      proxyRealm = proxy.getRealm();
+    /**
+     * We know for sure if we have to force to connect or not, so we can build the HttpRequest right away This reduces the probability of having a pooled channel closed by the
+     * server by the time we build the request
+     */
+    private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean performingNextRequest,//
+            ProxyServer proxyServer,//
+            boolean forceConnect) {
+
+        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
+
+        Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
+
+        if (Channels.isChannelValid(channel))
+            return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
+        else
+            return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
-    NettyRequest nettyRequest = requestFactory.newNettyRequest(request, performConnectRequest, proxy, realm,
-            proxyRealm);
-
-    if (originalFuture == null) {
-      NettyResponseFuture<T> future = newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
-      future.setRealm(realm);
-      future.setProxyRealm(proxyRealm);
-      return future;
-    } else {
-      originalFuture.setNettyRequest(nettyRequest);
-      originalFuture.setCurrentRequest(request);
-      return originalFuture;
-    }
-  }
-
-  private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer,
-                                 AsyncHandler<?> asyncHandler) {
-    if (future != null && future.isReuseChannel() && Channels.isChannelActive(future.channel())) {
-      return future.channel();
-    } else {
-      return pollPooledChannel(request, proxyServer, asyncHandler);
-    }
-  }
-
-  private <T> ListenableFuture<T> sendRequestWithOpenChannel(NettyResponseFuture<T> future,
-                                                             AsyncHandler<T> asyncHandler,
-                                                             Channel channel) {
-
-    try {
-      asyncHandler.onConnectionPooled(channel);
-    } catch (Exception e) {
-      LOGGER.error("onConnectionPooled crashed", e);
-      abort(channel, future, e);
-      return future;
-    }
+    /**
+     * Using CONNECT depends on wither we can fetch a valid channel or not Loop until we get a valid channel from the pool and it's still valid once the request is built @
+     */
+    @SuppressWarnings("unused")
+    private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean performingNextRequest,//
+            ProxyServer proxyServer) {
+
+        NettyResponseFuture<T> newFuture = null;
+        for (int i = 0; i < 3; i++) {
+            Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
+            if (Channels.isChannelValid(channel))
+                if (newFuture == null)
+                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
+
+            if (Channels.isChannelValid(channel))
+                // if the channel is still active, we can use it, otherwise try
+                // gain
+                return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
+            else
+                // pool is empty
+                break;
+        }
 
-    SocketAddress channelRemoteAddress = channel.remoteAddress();
-    if (channelRemoteAddress != null) {
-      // otherwise, bad luck, the channel was closed, see bellow
-      scheduleRequestTimeout(future, (InetSocketAddress) channelRemoteAddress);
+        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
+        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
-    future.setChannelState(ChannelState.POOLED);
-    future.attachChannel(channel, false);
+    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
+            ProxyServer proxy, boolean forceConnect) {
 
-    if (LOGGER.isDebugEnabled()) {
-      HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-      LOGGER.debug("Using open Channel {} for {} '{}'", channel, httpRequest.method(), httpRequest.uri());
-    }
+        Realm realm = null;
+        if (originalFuture != null) {
+            realm = originalFuture.getRealm();
+        } else {
+            realm = request.getRealm();
+            if (realm == null) {
+                realm = config.getRealm();
+            }
+        }
+
+        Realm proxyRealm = null;
+        if (originalFuture != null) {
+            proxyRealm = originalFuture.getProxyRealm();
+        } else if (proxy != null) {
+            proxyRealm = proxy.getRealm();
+        }
+
+        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, forceConnect, proxy, realm, proxyRealm);
 
-    // channelInactive might be called between isChannelValid and writeRequest
-    // so if we don't store the Future now, channelInactive won't perform
-    // handleUnexpectedClosedChannel
-    Channels.setAttribute(channel, future);
-
-    if (Channels.isChannelActive(channel)) {
-      writeRequest(future, channel);
-    } else {
-      // bad luck, the channel was closed in-between
-      // there's a very good chance onClose was already notified but the
-      // future wasn't already registered
-      handleUnexpectedClosedChannel(channel, future);
+        if (originalFuture == null) {
+            NettyResponseFuture<T> future = newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
+            future.setRealm(realm);
+            future.setProxyRealm(proxyRealm);
+            return future;
+        } else {
+            originalFuture.setNettyRequest(nettyRequest);
+            originalFuture.setCurrentRequest(request);
+            return originalFuture;
+        }
     }
 
-    return future;
-  }
-
-  private <T> ListenableFuture<T> sendRequestWithNewChannel(Request request,
-                                                            ProxyServer proxy,
-                                                            NettyResponseFuture<T> future,
-                                                            AsyncHandler<T> asyncHandler) {
-
-    // some headers are only set when performing the first request
-    HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
-    Realm realm = future.getRealm();
-    Realm proxyRealm = future.getProxyRealm();
-    requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
-    requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
-
-    future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
-    future.setInProxyAuth(
-            proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
-
-    try {
-      if (!channelManager.isOpen()) {
-        throw PoolAlreadyClosedException.INSTANCE;
-      }
-
-      // Do not throw an exception when we need an extra connection for a
-      // redirect.
-      future.acquirePartitionLockLazily();
-    } catch (Throwable t) {
-      abort(null, future, getCause(t));
-      // exit and don't try to resolve address
-      return future;
+    private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+        if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel())) {
+            return future.channel();
+        } else {
+            return pollPooledChannel(request, proxyServer, asyncHandler);
+        }
     }
 
-    resolveAddresses(request, proxy, future, asyncHandler)
-            .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
-
-              @Override
-              protected void onSuccess(List<InetSocketAddress> addresses) {
-                NettyConnectListener<T> connectListener = new NettyConnectListener<>(future,
-                        NettyRequestSender.this, channelManager, connectionSemaphore);
-                NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(),
-                        addresses, asyncHandler, clientState);
-                if (!future.isDone()) {
-                  // Do not throw an exception when we need an extra connection for a redirect
-                  // FIXME why? This violate the max connection per host handling, right?
-                  channelManager.getBootstrap(request.getUri(), request.getNameResolver(), proxy)
-                          .addListener((Future<Bootstrap> whenBootstrap) -> {
-                            if (whenBootstrap.isSuccess()) {
-                              connector.connect(whenBootstrap.get(), connectListener);
-                            } else {
-                              abort(null, future, whenBootstrap.cause());
-                            }
-                          });
-                }
-              }
-
-              @Override
-              protected void onFailure(Throwable cause) {
-                abort(null, future, getCause(cause));
-              }
-            });
-
-    return future;
-  }
-
-  private <T> Future<List<InetSocketAddress>> resolveAddresses(Request request,
-                                                               ProxyServer proxy,
-                                                               NettyResponseFuture<T> future,
-                                                               AsyncHandler<T> asyncHandler) {
-
-    Uri uri = request.getUri();
-    final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
-
-    if (proxy != null && !proxy.isIgnoredForHost(uri.getHost()) && proxy.getProxyType().isHttp()) {
-      int port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
-      InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(proxy.getHost(), port);
-      scheduleRequestTimeout(future, unresolvedRemoteAddress);
-      return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
-
-    } else {
-      int port = uri.getExplicitPort();
-
-      if (request.getAddress() != null) {
-        // bypass resolution
-        InetSocketAddress inetSocketAddress = new InetSocketAddress(request.getAddress(), port);
-        return promise.setSuccess(singletonList(inetSocketAddress));
-
-      } else {
-        InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(uri.getHost(), port);
-        scheduleRequestTimeout(future, unresolvedRemoteAddress);
-        return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
-      }
+    private <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
+
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onConnectionPooled(channel);
+            } catch (Exception e) {
+                LOGGER.error("onConnectionPooled crashed", e);
+                abort(channel, future, e);
+                return future;
+            }
+        }
+
+        SocketAddress channelRemoteAddress = channel.remoteAddress();
+        if (channelRemoteAddress != null) {
+            // otherwise, bad luck, the channel was closed, see bellow
+            scheduleRequestTimeout(future, (InetSocketAddress) channelRemoteAddress);
+        }
+
+        future.setChannelState(ChannelState.POOLED);
+        future.attachChannel(channel, false);
+
+        if (LOGGER.isDebugEnabled()) {
+            HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+            LOGGER.debug("Using open Channel {} for {} '{}'", channel, httpRequest.method(), httpRequest.uri());
+        }
+
+        // channelInactive might be called between isChannelValid and writeRequest
+        // so if we don't store the Future now, channelInactive won't perform handleUnexpectedClosedChannel
+        Channels.setAttribute(channel, future);
+
+        if (Channels.isChannelValid(channel)) {
+            writeRequest(future, channel);
+        } else {
+            // bad luck, the channel was closed in-between
+            // there's a very good chance onClose was already notified but the
+            // future wasn't already registered
+            handleUnexpectedClosedChannel(channel, future);
+        }
+
+        return future;
     }
-  }
-
-  private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request,
-                                                            AsyncHandler<T> asyncHandler,
-                                                            NettyRequest nettyRequest,
-                                                            ProxyServer proxyServer) {
-
-    NettyResponseFuture<T> future = new NettyResponseFuture<>(
-            request,
-            asyncHandler,
-            nettyRequest,
-            config.getMaxRequestRetry(),
-            request.getChannelPoolPartitioning(),
-            connectionSemaphore,
-            proxyServer);
-
-    String expectHeader = request.getHeaders().get(EXPECT);
-    if (HttpHeaderValues.CONTINUE.contentEqualsIgnoreCase(expectHeader))
-      future.setDontWriteBodyBecauseExpectContinue(true);
-    return future;
-  }
-
-  public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
-
-    NettyRequest nettyRequest = future.getNettyRequest();
-    HttpRequest httpRequest = nettyRequest.getHttpRequest();
-    AsyncHandler<T> asyncHandler = future.getAsyncHandler();
-
-    // if the channel is dead because it was pooled and the remote server decided to
-    // close it,
-    // we just let it go and the channelInactive do its work
-    if (!Channels.isChannelActive(channel))
-      return;
-
-    try {
-      if (asyncHandler instanceof TransferCompletionHandler) {
-        configureTransferAdapter(asyncHandler, httpRequest);
-      }
-
-      boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue()
-              && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
-
-      if (!future.isHeadersAlreadyWrittenOnContinue()) {
+
+    private <T> ListenableFuture<T> sendRequestWithNewChannel(//
+            Request request,//
+            ProxyServer proxy,//
+            NettyResponseFuture<T> future,//
+            AsyncHandler<T> asyncHandler,//
+            boolean performingNextRequest) {
+
+        // some headers are only set when performing the first request
+        HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
+        Realm realm = future.getRealm();
+        Realm proxyRealm = future.getProxyRealm();
+        requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
+        requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
+
+        future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
+        future.setInProxyAuth(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
+
+        // Do not throw an exception when we need an extra connection for a redirect
+        // FIXME why? This violate the max connection per host handling, right?
+        Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);
+
+        Object partitionKey = future.getPartitionKey();
+
         try {
-          asyncHandler.onRequestSend(nettyRequest);
-        } catch (Exception e) {
-          LOGGER.error("onRequestSend crashed", e);
-          abort(channel, future, e);
-          return;
+            if (!channelManager.isOpen()) {
+                throw PoolAlreadyClosedException.INSTANCE;
+            }
+
+            // Do not throw an exception when we need an extra connection for a
+            // redirect.
+            future.acquirePartitionLockLazily();
+        } catch (Throwable t) {
+            abort(null, future, getCause(t));
+            // exit and don't try to resolve address
+            return future;
         }
 
-        // if the request has a body, we want to track progress
-        if (writeBody) {
-          // FIXME does this really work??? the promise is for the request without body!!!
-          ChannelProgressivePromise promise = channel.newProgressivePromise();
-          ChannelFuture f = channel.write(httpRequest, promise);
-          f.addListener(new WriteProgressListener(future, true, 0L));
+        resolveAddresses(request, proxy, future, asyncHandler)//
+                .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
+
+                    @Override
+                    protected void onSuccess(List<InetSocketAddress> addresses) {
+                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, connectionSemaphore, partitionKey);
+                        NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);
+                        if (!future.isDone()) {
+                            connector.connect(bootstrap, connectListener);
+                        }
+                    }
+
+                    @Override
+                    protected void onFailure(Throwable cause) {
+                        abort(null, future, getCause(cause));
+                    }
+                });
+
+        return future;
+    }
+    
+    private <T> Future<List<InetSocketAddress>> resolveAddresses(
+            Request request,//
+            ProxyServer proxy,//
+            NettyResponseFuture<T> future,//
+            AsyncHandler<T> asyncHandler) {
+        
+        Uri uri = request.getUri();
+        final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+
+        if (proxy != null && !proxy.isIgnoredForHost(uri.getHost())) {
+            int port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
+            InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(proxy.getHost(), port);
+            scheduleRequestTimeout(future, unresolvedRemoteAddress);
+            return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
+            
         } else {
-          // we can just track write completion
-          ChannelPromise promise = channel.newPromise();
-          ChannelFuture f = channel.writeAndFlush(httpRequest, promise);
-          f.addListener(new WriteCompleteListener(future));
+            int port = uri.getExplicitPort();
+            
+            if (request.getAddress() != null) {
+                // bypass resolution
+                InetSocketAddress inetSocketAddress = new InetSocketAddress(request.getAddress(), port);
+                return promise.setSuccess(singletonList(inetSocketAddress));
+                
+            } else {
+                InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(uri.getHost(), port);
+                scheduleRequestTimeout(future, unresolvedRemoteAddress);
+                return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
+            }
         }
-      }
+    }
+
+    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
+
+        NettyResponseFuture<T> future = new NettyResponseFuture<>(//
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                config.getMaxRequestRetry(),//
+                request.getChannelPoolPartitioning(),//
+                connectionSemaphore,//
+                proxyServer);
+
+        String expectHeader = request.getHeaders().get(EXPECT);
+        if (HttpHeaderValues.CONTINUE.contentEqualsIgnoreCase(expectHeader))
+            future.setDontWriteBodyBecauseExpectContinue(true);
+        return future;
+    }
+
+    public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
+
+        NettyRequest nettyRequest = future.getNettyRequest();
+        HttpRequest httpRequest = nettyRequest.getHttpRequest();
+        AsyncHandler<T> handler = future.getAsyncHandler();
+
+        // if the channel is dead because it was pooled and the remote server decided to close it,
+        // we just let it go and the channelInactive do its work
+        if (!Channels.isChannelValid(channel))
+            return;
+
+        try {
+            if (handler instanceof TransferCompletionHandler) {
+                configureTransferAdapter(handler, httpRequest);
+            }
+
+            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue() && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
+
+            if (!future.isHeadersAlreadyWrittenOnContinue()) {
+                final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(handler);
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onRequestSend(nettyRequest);
+                    } catch (Exception e) {
+                        LOGGER.error("onRequestSend crashed", e);
+                        abort(channel, future, e);
+                        return;
+                    }
+                }
+
+                // if the request has a body, we want to track progress
+                if (writeBody) {
+                    // FIXME does this really work??? the promise is for the request without body!!!
+                    ChannelProgressivePromise promise = channel.newProgressivePromise();
+                    ChannelFuture f = channel.write(httpRequest, promise);
+                    f.addListener(new WriteProgressListener(future, true, 0L));
+                } else {
+                    // we can just track write completion
+                    ChannelPromise promise = channel.newPromise();
+                    ChannelFuture f = channel.writeAndFlush(httpRequest, promise);
+                    f.addListener(new WriteCompleteListener(future));
+                }
+            }
 
-      if (writeBody)
-        nettyRequest.getBody().write(channel, future);
+            if (writeBody)
+                nettyRequest.getBody().write(channel, future);
 
-      // don't bother scheduling read timeout if channel became invalid
-      if (Channels.isChannelActive(channel)) {
-        scheduleReadTimeout(future);
-      }
+            // don't bother scheduling read timeout if channel became invalid
+            if (Channels.isChannelValid(channel)) {
+                scheduleReadTimeout(future);
+            }
 
-    } catch (Exception e) {
-      LOGGER.error("Can't write request", e);
-      abort(channel, future, e);
+        } catch (Exception e) {
+            LOGGER.error("Can't write request", e);
+            abort(channel, future, e);
+        }
     }
-  }
-
-  private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
-    HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
-    TransferCompletionHandler.class.cast(handler).headers(h);
-  }
-
-  private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture,
-                                      InetSocketAddress originalRemoteAddress) {
-    nettyResponseFuture.touch();
-    TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config,
-            originalRemoteAddress);
-    nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
-  }
-
-  private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
-    TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
-    if (timeoutsHolder != null) {
-      // on very fast requests, it's entirely possible that the response has already
-      // been completed
-      // by the time we try to schedule the read timeout
-      nettyResponseFuture.touch();
-      timeoutsHolder.startReadTimeout();
+
+    private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
+        HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
+        TransferCompletionHandler.class.cast(handler).headers(h);
     }
-  }
 
-  public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
+    private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture, InetSocketAddress originalRemoteAddress) {
+        nettyResponseFuture.touch();
+        TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config, originalRemoteAddress);
+        nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
+    }
 
-    if (channel != null) {
-      channelManager.closeChannel(channel);
+    private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
+        TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
+        if (timeoutsHolder != null) {
+            // on very fast requests, it's entirely possible that the response has already been completed
+            // by the time we try to schedule the read timeout
+            nettyResponseFuture.touch();
+            timeoutsHolder.startReadTimeout();
+        }
     }
 
-    if (!future.isDone()) {
-      future.setChannelState(ChannelState.CLOSED);
-      LOGGER.debug("Aborting Future {}\n", future);
-      LOGGER.debug(t.getMessage(), t);
-      future.abort(t);
+    public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
+
+        if (channel != null) {
+            channelManager.closeChannel(channel);
+        }
+
+        if (!future.isDone()) {
+            future.setChannelState(ChannelState.CLOSED);
+            LOGGER.debug("Aborting Future {}\n", future);
+            LOGGER.debug(t.getMessage(), t);
+            future.abort(t);
+        }
     }
-  }
-
-  public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
-    if (Channels.isActiveTokenSet(channel)) {
-      if (future.isDone()) {
-        channelManager.closeChannel(channel);
-      } else if (future.incrementRetryAndCheck() && retry(future)) {
-        future.pendingException = null;
-      } else {
-        abort(channel, future,
-                future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
-      }
+
+    public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
+        if (Channels.isActiveTokenSet(channel)) {
+            if (future.isDone()) {
+                channelManager.closeChannel(channel);
+            } else if (future.incrementRetryAndCheck() && retry(future)) {
+                future.pendingException = null;
+            } else {
+                abort(channel, future, future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
+            }
+        }
     }
-  }
 
-  public boolean retry(NettyResponseFuture<?> future) {
+    public boolean retry(NettyResponseFuture<?> future) {
 
-    if (isClosed()) {
-      return false;
-    }
+        if (isClosed()) {
+            return false;
+        }
+
+        if (future.isReplayPossible()) {
+            future.setChannelState(ChannelState.RECONNECTED);
+
+            LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onRetry();
+                } catch (Exception e) {
+                    LOGGER.error("onRetry crashed", e);
+                    abort(future.channel(), future, e);
+                    return false;
+                }
+            }
+
+            try {
+                sendNextRequest(future.getCurrentRequest(), future);
+                return true;
 
-    if (future.isReplayPossible()) {
-      future.setChannelState(ChannelState.RECONNECTED);
-
-      LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
-      try {
-        future.getAsyncHandler().onRetry();
-      } catch (Exception e) {
-        LOGGER.error("onRetry crashed", e);
-        abort(future.channel(), future, e);
-        return false;
-      }
-
-      try {
-        sendNextRequest(future.getCurrentRequest(), future);
-        return true;
-
-      } catch (Exception e) {
-        abort(future.channel(), future, e);
-        return false;
-      }
-    } else {
-      LOGGER.debug("Unable to recover future {}\n", future);
-      return false;
+            } catch (Exception e) {
+                abort(future.channel(), future, e);
+                return false;
+            }
+        } else {
+            LOGGER.debug("Unable to recover future {}\n", future);
+            return false;
+        }
     }
-  }
-
-  public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e,
-                                                         Channel channel) {
-
-    boolean replayed = false;
-
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-            .request(future.getCurrentRequest()).ioException(e).build();
-    for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
-      try {
-        fc = asyncFilter.filter(fc);
-        assertNotNull(fc, "filterContext");
-      } catch (FilterException efe) {
-        abort(channel, future, efe);
-      }
+
+    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) {
+
+        boolean replayed = false;
+
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getCurrentRequest()).ioException(e).build();
+        for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                assertNotNull(fc, "filterContext");
+            } catch (FilterException efe) {
+                abort(channel, future, efe);
+            }
+        }
+
+        if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
+            replayRequest(future, fc, channel);
+            replayed = true;
+        }
+        return replayed;
     }
 
-    if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
-      future.setKeepAlive(false);
-      replayRequest(future, fc, channel);
-      replayed = true;
+    public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
+        sendRequest(request, future.getAsyncHandler(), future, true);
     }
-    return replayed;
-  }
-
-  public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
-    sendRequest(request, future.getAsyncHandler(), future);
-  }
-
-  private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-    Uri uri = request.getUri();
-    boolean isWs = uri.isWebSocket();
-    if (asyncHandler instanceof WebSocketUpgradeHandler) {
-      if (!isWs) {
-        throw new IllegalArgumentException(
-                "WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
-      } else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT)) {
-        throw new IllegalArgumentException(
-                "WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
-      }
-    } else if (isWs) {
-      throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
+
+    private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        Uri uri = request.getUri();
+        boolean isWs = uri.isWebSocket();
+        if (asyncHandler instanceof WebSocketUpgradeHandler) {
+            if (!isWs) {
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
+            } else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT)) {
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
+            }
+        } else if (isWs) {
+            throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
+        }
     }
-  }
 
-  private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
-    try {
-      asyncHandler.onConnectionPoolAttempt();
-    } catch (Exception e) {
-      LOGGER.error("onConnectionPoolAttempt crashed", e);
+    private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
+
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onConnectionPoolAttempt();
+            } catch (Exception e) {
+                LOGGER.error("onConnectionPoolAttempt crashed", e);
+            }
+        }
+
+        Uri uri = request.getUri();
+        String virtualHost = request.getVirtualHost();
+        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
+
+        if (channel != null) {
+            LOGGER.debug("Using pooled Channel '{}' for '{}' to '{}'", channel, request.getMethod(), uri);
+        }
+        return channel;
     }
 
-    Uri uri = request.getUri();
-    String virtualHost = request.getVirtualHost();
-    final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
+
+        Request newRequest = fc.getRequest();
+        future.setAsyncHandler(fc.getAsyncHandler());
+        future.setChannelState(ChannelState.NEW);
+        future.touch();
+
+        LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onRetry();
+            } catch (Exception e) {
+                LOGGER.error("onRetry crashed", e);
+                abort(channel, future, e);
+                return;
+            }
+        }
 
-    if (channel != null) {
-      LOGGER.debug("Using pooled Channel '{}' for '{}' to '{}'", channel, request.getMethod(), uri);
+        channelManager.drainChannelAndOffer(channel, future);
+        sendNextRequest(newRequest, future);
     }
-    return channel;
-  }
-
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
-
-    Request newRequest = fc.getRequest();
-    future.setAsyncHandler(fc.getAsyncHandler());
-    future.setChannelState(ChannelState.NEW);
-    future.touch();
-
-    LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-    try {
-      future.getAsyncHandler().onRetry();
-    } catch (Exception e) {
-      LOGGER.error("onRetry crashed", e);
-      abort(channel, future, e);
-      return;
+
+    public boolean isClosed() {
+        return clientState.isClosed();
     }
 
-    channelManager.drainChannelAndOffer(channel, future);
-    sendNextRequest(newRequest, future);
-  }
-
-  public boolean isClosed() {
-    return clientState.isClosed();
-  }
-
-  public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future,
-                                                Request nextRequest) {
-    Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
-      @Override
-      public void call() {
-        sendNextRequest(nextRequest, future);
-      }
-    });
-  }
+    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
+        Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
+            @Override
+            public void call() {
+                sendNextRequest(nextRequest, future);
+            }
+        });
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
index 0d3560fb7..d82f540d0 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteCompleteListener.java
@@ -13,18 +13,19 @@
  */
 package org.asynchttpclient.netty.request;
 
+import org.asynchttpclient.netty.NettyResponseFuture;
+
 import io.netty.channel.ChannelFuture;
 import io.netty.util.concurrent.GenericFutureListener;
-import org.asynchttpclient.netty.NettyResponseFuture;
 
 public class WriteCompleteListener extends WriteListener implements GenericFutureListener<ChannelFuture> {
 
-  WriteCompleteListener(NettyResponseFuture<?> future) {
-    super(future, true);
-  }
+    public WriteCompleteListener(NettyResponseFuture<?> future) {
+        super(future, true);
+    }
 
-  @Override
-  public void operationComplete(ChannelFuture future) {
-    operationComplete(future.channel(), future.cause());
-  }
+    @Override
+    public void operationComplete(ChannelFuture future) throws Exception {
+        operationComplete(future.channel(), future.cause());
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
index ab38a66f9..74c748f6e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
@@ -14,64 +14,68 @@
 package org.asynchttpclient.netty.request;
 
 import io.netty.channel.Channel;
+
+import java.nio.channels.ClosedChannelException;
+
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.nio.channels.ClosedChannelException;
-
 public abstract class WriteListener {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(WriteListener.class);
-  protected final NettyResponseFuture<?> future;
-  final ProgressAsyncHandler<?> progressAsyncHandler;
-  final boolean notifyHeaders;
+    private static final Logger LOGGER = LoggerFactory.getLogger(WriteListener.class);
+    protected final NettyResponseFuture<?> future;
+    protected final ProgressAsyncHandler<?> progressAsyncHandler;
+    protected final boolean notifyHeaders;
 
-  WriteListener(NettyResponseFuture<?> future, boolean notifyHeaders) {
-    this.future = future;
-    this.progressAsyncHandler = future.getAsyncHandler() instanceof ProgressAsyncHandler ? (ProgressAsyncHandler<?>) future.getAsyncHandler() : null;
-    this.notifyHeaders = notifyHeaders;
-  }
-
-  private boolean abortOnThrowable(Channel channel, Throwable cause) {
-    if (cause != null) {
-      if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-        LOGGER.debug(cause.getMessage(), cause);
-        Channels.silentlyCloseChannel(channel);
-
-      } else {
-        future.abort(cause);
-      }
-      return true;
+    public WriteListener(NettyResponseFuture<?> future, boolean notifyHeaders) {
+        this.future = future;
+        this.progressAsyncHandler = future.getAsyncHandler() instanceof ProgressAsyncHandler ? (ProgressAsyncHandler<?>) future.getAsyncHandler() : null;
+        this.notifyHeaders = notifyHeaders;
     }
 
-    return false;
-  }
+    private boolean abortOnThrowable(Channel channel, Throwable cause) {
+        if (cause != null && future.getChannelState() != ChannelState.NEW) {
+            if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+                LOGGER.debug(cause.getMessage(), cause);
+                Channels.silentlyCloseChannel(channel);
 
-  void operationComplete(Channel channel, Throwable cause) {
-    future.touch();
+            } else {
+                future.abort(cause);
+            }
+            return true;
+        }
 
-    // The write operation failed. If the channel was cached, it means it got asynchronously closed.
-    // Let's retry a second time.
-    if (abortOnThrowable(channel, cause)) {
-      return;
+        return false;
     }
 
-    if (progressAsyncHandler != null) {
-       // We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
-       // causing unpredictable behavior.
-      boolean startPublishing = !future.isInAuth() && !future.isInProxyAuth();
-      if (startPublishing) {
+    protected void operationComplete(Channel channel, Throwable cause) {
+        future.touch();
+
+        // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+        // Let's retry a second time.
+        if (abortOnThrowable(channel, cause)) {
+            return;
+        }
 
-        if (notifyHeaders) {
-          progressAsyncHandler.onHeadersWritten();
-        } else {
-          progressAsyncHandler.onContentWritten();
+        if (progressAsyncHandler != null) {
+            /**
+             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
+             * causing unpredictable behavior.
+             */
+            boolean startPublishing = !future.isInAuth() && !future.isInProxyAuth();
+            if (startPublishing) {
+                
+                if (notifyHeaders) {
+                    progressAsyncHandler.onHeadersWritten();
+                } else {
+                    progressAsyncHandler.onContentWritten();
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
index c7d0ef20c..7fc3ec4a6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteProgressListener.java
@@ -15,38 +15,39 @@
 
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.channel.ChannelProgressiveFutureListener;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 
 public class WriteProgressListener extends WriteListener implements ChannelProgressiveFutureListener {
 
-  private final long expectedTotal;
-  private long lastProgress = 0L;
-
-  public WriteProgressListener(NettyResponseFuture<?> future,
-                               boolean notifyHeaders,
-                               long expectedTotal) {
-    super(future, notifyHeaders);
-    this.expectedTotal = expectedTotal;
-  }
-
-  @Override
-  public void operationComplete(ChannelProgressiveFuture cf) {
-    operationComplete(cf.channel(), cf.cause());
-  }
-
-  @Override
-  public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
-    future.touch();
-
-    if (progressAsyncHandler != null && !notifyHeaders) {
-      long lastLastProgress = lastProgress;
-      lastProgress = progress;
-      if (total < 0) {
-        total = expectedTotal;
-      }
-      if (progress != lastLastProgress) {
-        progressAsyncHandler.onContentWriteProgress(progress - lastLastProgress, progress, total);
-      }
+    private final long expectedTotal;
+    private long lastProgress = 0L;
+
+    public WriteProgressListener(NettyResponseFuture<?> future,//
+            boolean notifyHeaders,//
+            long expectedTotal) {
+        super(future, notifyHeaders);
+        this.expectedTotal = expectedTotal;
+    }
+
+    @Override
+    public void operationComplete(ChannelProgressiveFuture cf) {
+        operationComplete(cf.channel(), cf.cause());
+    }
+
+    @Override
+    public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
+        future.touch();
+
+        if (progressAsyncHandler != null && !notifyHeaders) {
+            long lastLastProgress = lastProgress;
+            lastProgress = progress;
+            if (total < 0) {
+                total = expectedTotal;
+            }
+            if (progress != lastLastProgress) {
+                progressAsyncHandler.onContentWriteProgress(progress - lastLastProgress, progress, total);
+            }
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index d5f1852e2..b1f246244 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -13,83 +13,83 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.stream.ChunkedInput;
-import org.asynchttpclient.request.body.Body;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
+import org.asynchttpclient.request.body.Body;
 
 /**
  * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
  */
 public class BodyChunkedInput implements ChunkedInput<ByteBuf> {
 
-  public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
+    public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
 
-  private final Body body;
-  private final int chunkSize;
-  private final long contentLength;
-  private boolean endOfInput;
-  private long progress = 0L;
+    private final Body body;
+    private final int chunkSize;
+    private boolean endOfInput;
+    private final long contentLength;
+    private long progress = 0L;
 
-  BodyChunkedInput(Body body) {
-    this.body = assertNotNull(body, "body");
-    this.contentLength = body.getContentLength();
-    if (contentLength <= 0)
-      chunkSize = DEFAULT_CHUNK_SIZE;
-    else
-      chunkSize = (int) Math.min(contentLength, (long) DEFAULT_CHUNK_SIZE);
-  }
+    public BodyChunkedInput(Body body) {
+        this.body = assertNotNull(body, "body");
+        this.contentLength = body.getContentLength();
+        if (contentLength <= 0)
+            chunkSize = DEFAULT_CHUNK_SIZE;
+        else
+            chunkSize = (int) Math.min(contentLength, (long) DEFAULT_CHUNK_SIZE);
+    }
 
-  @Override
-  @Deprecated
-  public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
-    return readChunk(ctx.alloc());
-  }
+    @Override
+    @Deprecated
+         public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
+        return readChunk(ctx.alloc());
+    }
 
-  @Override
-  public ByteBuf readChunk(ByteBufAllocator alloc) throws Exception {
+    @Override
+    public ByteBuf readChunk(ByteBufAllocator alloc) throws Exception {
 
-    if (endOfInput)
-      return null;
+        if (endOfInput)
+            return null;
 
-    ByteBuf buffer = alloc.buffer(chunkSize);
-    Body.BodyState state = body.transferTo(buffer);
-    progress += buffer.writerIndex();
-    switch (state) {
-      case STOP:
-        endOfInput = true;
-        return buffer;
-      case SUSPEND:
-        // this will suspend the stream in ChunkedWriteHandler
-        buffer.release();
-        return null;
-      case CONTINUE:
-        return buffer;
-      default:
-        throw new IllegalStateException("Unknown state: " + state);
+        ByteBuf buffer = alloc.buffer(chunkSize);
+        Body.BodyState state = body.transferTo(buffer);
+        progress += buffer.writerIndex();
+        switch (state) {
+        case STOP:
+            endOfInput = true;
+            return buffer;
+        case SUSPEND:
+            // this will suspend the stream in ChunkedWriteHandler
+            buffer.release();
+            return null;
+        case CONTINUE:
+            return buffer;
+        default:
+            throw new IllegalStateException("Unknown state: " + state);
+        }
     }
-  }
 
-  @Override
-  public boolean isEndOfInput() {
-    return endOfInput;
-  }
-
-  @Override
-  public void close() throws Exception {
-    body.close();
-  }
+    @Override
+    public boolean isEndOfInput() throws Exception {
+        return endOfInput;
+    }
 
-  @Override
-  public long length() {
-    return contentLength;
-  }
+    @Override
+    public void close() throws Exception {
+        body.close();
+    }
 
-  @Override
-  public long progress() {
-    return progress;
-  }
+    @Override
+    public long length() {
+        return contentLength;
+    }
+     
+    @Override
+    public long progress() {
+        return progress;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
index bc2ac041f..59ef476d0 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -13,81 +13,83 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import static org.asynchttpclient.util.Assertions.*;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import org.asynchttpclient.request.body.RandomAccessBody;
+
 import io.netty.channel.FileRegion;
 import io.netty.util.AbstractReferenceCounted;
-import org.asynchttpclient.request.body.RandomAccessBody;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
 /**
  * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
  */
-class BodyFileRegion extends AbstractReferenceCounted implements FileRegion {
-
-  private final RandomAccessBody body;
-  private long transferred;
-
-  BodyFileRegion(RandomAccessBody body) {
-    this.body = assertNotNull(body, "body");
-  }
-
-  @Override
-  public long position() {
-    return 0;
-  }
-
-  @Override
-  public long count() {
-    return body.getContentLength();
-  }
-
-  @Override
-  public long transfered() {
-    return transferred();
-  }
-
-  @Override
-  public long transferred() {
-    return transferred;
-  }
-
-  @Override
-  public FileRegion retain() {
-    super.retain();
-    return this;
-  }
-
-  @Override
-  public FileRegion retain(int arg0) {
-    super.retain(arg0);
-    return this;
-  }
-
-  @Override
-  public FileRegion touch() {
-    return this;
-  }
-
-  @Override
-  public FileRegion touch(Object arg0) {
-    return this;
-  }
-
-  @Override
-  public long transferTo(WritableByteChannel target, long position) throws IOException {
-    long written = body.transferTo(target);
-    if (written > 0) {
-      transferred += written;
+public class BodyFileRegion extends AbstractReferenceCounted implements FileRegion {
+
+    private final RandomAccessBody body;
+    private long transferred;
+
+    public BodyFileRegion(RandomAccessBody body) {
+        this.body = assertNotNull(body, "body");
+    }
+
+    @Override
+    public long position() {
+        return 0;
     }
-    return written;
-  }
 
-  @Override
-  protected void deallocate() {
-    closeSilently(body);
-  }
+    @Override
+    public long count() {
+        return body.getContentLength();
+    }
+
+    @Override
+    public long transfered() {
+        return transferred();
+    }
+
+    @Override
+    public long transferred() {
+        return transferred;
+    }
+
+    @Override
+    public FileRegion retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public FileRegion retain(int arg0) {
+        super.retain(arg0);
+        return this;
+    }
+
+    @Override
+    public FileRegion touch() {
+        return this;
+    }
+
+    @Override
+    public FileRegion touch(Object arg0) {
+        return this;
+    }
+
+    @Override
+    public long transferTo(WritableByteChannel target, long position) throws IOException {
+        long written = body.transferTo(target);
+        if (written > 0) {
+            transferred += written;
+        }
+        return written;
+    }
+
+    @Override
+    protected void deallocate() {
+        closeSilently(body);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
index fc8258304..41e2ade2f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
@@ -14,17 +14,18 @@
 package org.asynchttpclient.netty.request.body;
 
 import io.netty.channel.Channel;
-import org.asynchttpclient.netty.NettyResponseFuture;
 
 import java.io.IOException;
 
+import org.asynchttpclient.netty.NettyResponseFuture;
+
 public interface NettyBody {
 
-  long getContentLength();
+    long getContentLength();
 
-  default CharSequence getContentTypeOverride() {
-    return null;
-  }
+    default CharSequence getContentTypeOverride() {
+        return null;
+    }
 
-  void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
+    void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 728e2ec89..76f5c2c28 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -13,10 +13,14 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedWriteHandler;
+
+import java.io.IOException;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
@@ -28,60 +32,58 @@
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
 import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
 public class NettyBodyBody implements NettyBody {
 
-  private final Body body;
-  private final AsyncHttpClientConfig config;
+    private final Body body;
+    private final AsyncHttpClientConfig config;
 
-  public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
-    this.body = body;
-    this.config = config;
-  }
+    public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
+        this.body = body;
+        this.config = config;
+    }
 
-  public Body getBody() {
-    return body;
-  }
+    public Body getBody() {
+        return body;
+    }
 
-  @Override
-  public long getContentLength() {
-    return body.getContentLength();
-  }
+    @Override
+    public long getContentLength() {
+        return body.getContentLength();
+    }
 
-  @Override
-  public void write(final Channel channel, NettyResponseFuture<?> future) {
+    @Override
+    public void write(final Channel channel, NettyResponseFuture<?> future) throws IOException {
 
-    Object msg;
-    if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !config.isDisableZeroCopy()) {
-      msg = new BodyFileRegion((RandomAccessBody) body);
+        Object msg;
+        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !config.isDisableZeroCopy()) {
+            msg = new BodyFileRegion((RandomAccessBody) body);
 
-    } else {
-      msg = new BodyChunkedInput(body);
+        } else {
+            msg = new BodyChunkedInput(body);
 
-      BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
-      if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
-        final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
-        FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
-          @Override
-          public void onContentAdded() {
-            chunkedWriteHandler.resumeTransfer();
-          }
+            BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
+            if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
+                final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
+                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+                    @Override
+                    public void onContentAdded() {
+                        chunkedWriteHandler.resumeTransfer();
+                    }
 
-          @Override
-          public void onError(Throwable t) {
-          }
-        });
-      }
-    }
+                    @Override
+                    public void onError(Throwable t) {
+                    }
+                });
+            }
+        }
 
-    channel.write(msg, channel.newProgressivePromise())
-            .addListener(new WriteProgressListener(future, false, getContentLength()) {
-              public void operationComplete(ChannelProgressiveFuture cf) {
-                closeSilently(body);
-                super.operationComplete(cf);
-              }
-            });
-    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
-  }
+        channel.write(msg, channel.newProgressivePromise())//
+                .addListener(new WriteProgressListener(future, false, getContentLength()) {
+                    public void operationComplete(ChannelProgressiveFuture cf) {
+                        closeSilently(body);
+                        super.operationComplete(cf);
+                    }
+                });
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
index 981aea522..2b54340a4 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
@@ -16,21 +16,22 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 
+
 public class NettyByteArrayBody extends NettyDirectBody {
 
-  private final byte[] bytes;
+    private final byte[] bytes;
 
-  public NettyByteArrayBody(byte[] bytes) {
-    this.bytes = bytes;
-  }
+    public NettyByteArrayBody(byte[] bytes) {
+        this.bytes = bytes;
+    }
 
-  @Override
-  public long getContentLength() {
-    return bytes.length;
-  }
+    @Override
+    public long getContentLength() {
+        return bytes.length;
+    }
 
-  @Override
-  public ByteBuf byteBuf() {
-    return Unpooled.wrappedBuffer(bytes);
-  }
+    @Override
+    public ByteBuf byteBuf() {
+        return Unpooled.wrappedBuffer(bytes);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
index b957dfb4c..9d320aa17 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
@@ -20,35 +20,35 @@
 
 public class NettyByteBufferBody extends NettyDirectBody {
 
-  private final ByteBuffer bb;
-  private final CharSequence contentTypeOverride;
-  private final long length;
-
-  public NettyByteBufferBody(ByteBuffer bb) {
-    this(bb, null);
-  }
-
-  public NettyByteBufferBody(ByteBuffer bb, CharSequence contentTypeOverride) {
-    this.bb = bb;
-    length = bb.remaining();
-    bb.mark();
-    this.contentTypeOverride = contentTypeOverride;
-  }
-
-  @Override
-  public long getContentLength() {
-    return length;
-  }
-
-  @Override
-  public CharSequence getContentTypeOverride() {
-    return contentTypeOverride;
-  }
-
-  @Override
-  public ByteBuf byteBuf() {
-    // for retry
-    bb.reset();
-    return Unpooled.wrappedBuffer(bb);
-  }
+    private final ByteBuffer bb;
+    private final CharSequence contentTypeOverride;
+    private final long length;
+
+    public NettyByteBufferBody(ByteBuffer bb) {
+        this(bb, null);
+    }
+
+    public NettyByteBufferBody(ByteBuffer bb, CharSequence contentTypeOverride) {
+        this.bb = bb;
+        length = bb.remaining();
+        bb.mark();
+        this.contentTypeOverride = contentTypeOverride;
+    }
+
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public CharSequence getContentTypeOverride() {
+        return contentTypeOverride;
+    }
+
+    @Override
+    public ByteBuf byteBuf() {
+        // for retry
+        bb.reset();
+        return Unpooled.wrappedBuffer(bb);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
index bf7085c6a..3ec8ab3dd 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
@@ -20,25 +20,25 @@
 
 public class NettyCompositeByteArrayBody extends NettyDirectBody {
 
-  private final byte[][] bytes;
-  private final long contentLength;
+    private final byte[][] bytes;
+    private final long contentLength;
 
-  public NettyCompositeByteArrayBody(List<byte[]> bytes) {
-    this.bytes = new byte[bytes.size()][];
-    bytes.toArray(this.bytes);
-    long l = 0;
-    for (byte[] b : bytes)
-      l += b.length;
-    contentLength = l;
-  }
+    public NettyCompositeByteArrayBody(List<byte[]> bytes) {
+        this.bytes = new byte[bytes.size()][];
+        bytes.toArray(this.bytes);
+        long l = 0;
+        for (byte[] b : bytes)
+            l += b.length;
+        contentLength = l;
+    }
 
-  @Override
-  public long getContentLength() {
-    return contentLength;
-  }
+    @Override
+    public long getContentLength() {
+        return contentLength;
+    }
 
-  @Override
-  public ByteBuf byteBuf() {
-    return Unpooled.wrappedBuffer(bytes);
-  }
+    @Override
+    public ByteBuf byteBuf() {
+        return Unpooled.wrappedBuffer(bytes);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
index 0d2535871..caa8fbefb 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
@@ -15,14 +15,17 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+
+import java.io.IOException;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 
 public abstract class NettyDirectBody implements NettyBody {
 
-  public abstract ByteBuf byteBuf();
+    public abstract ByteBuf byteBuf();
 
-  @Override
-  public void write(Channel channel, NettyResponseFuture<?> future) {
-    throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
-  }
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
index db6591fb6..4710166d6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
@@ -17,56 +17,61 @@
 import io.netty.channel.DefaultFileRegion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedNioFile;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.request.WriteProgressListener;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.WriteProgressListener;
+
 public class NettyFileBody implements NettyBody {
 
-  private final File file;
-  private final long offset;
-  private final long length;
-  private final AsyncHttpClientConfig config;
+    private final File file;
+    private final long offset;
+    private final long length;
+    private final AsyncHttpClientConfig config;
 
-  public NettyFileBody(File file, AsyncHttpClientConfig config) {
-    this(file, 0, file.length(), config);
-  }
+    public NettyFileBody(File file, AsyncHttpClientConfig config) {
+        this(file, 0, file.length(), config);
+    }
 
-  public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
-    if (!file.isFile()) {
-      throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+    public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
+        if (!file.isFile()) {
+            throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+        }
+        this.file = file;
+        this.offset = offset;
+        this.length = length;
+        this.config = config;
     }
-    this.file = file;
-    this.offset = offset;
-    this.length = length;
-    this.config = config;
-  }
 
-  public File getFile() {
-    return file;
-  }
+    public File getFile() {
+        return file;
+    }
 
-  @Override
-  public long getContentLength() {
-    return length;
-  }
+    public long getOffset() {
+        return offset;
+    }
 
-  @Override
-  public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-    @SuppressWarnings("resource")
-    // netty will close the FileChannel
-            FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
-    boolean noZeroCopy = ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy();
-    Object body = noZeroCopy ? new ChunkedNioFile(fileChannel, offset, length, config.getChunkedFileChunkSize()) : new DefaultFileRegion(fileChannel, offset, length);
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        @SuppressWarnings("resource")
+        // netty will close the FileChannel
+        FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
+        boolean noZeroCopy = ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy();
+        Object body = noZeroCopy ? new ChunkedNioFile(fileChannel, offset, length, config.getChunkedFileChunkSize()) : new DefaultFileRegion(fileChannel, offset, length);
 
-    channel.write(body, channel.newProgressivePromise())
-            .addListener(new WriteProgressListener(future, false, length));
-    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
-  }
+        channel.write(body, channel.newProgressivePromise())//
+                .addListener(new WriteProgressListener(future, false, length));
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
index 8afc38703..b267a7a82 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
@@ -13,67 +13,68 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelProgressiveFuture;
-import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.stream.ChunkedStream;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.WriteProgressListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.stream.ChunkedStream;
+
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-
 public class NettyInputStreamBody implements NettyBody {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
 
-  private final InputStream inputStream;
-  private final long contentLength;
+    private final InputStream inputStream;
+    private final long contentLength;
 
-  public NettyInputStreamBody(InputStream inputStream) {
-    this(inputStream, -1L);
-  }
+    public NettyInputStreamBody(InputStream inputStream) {
+        this(inputStream, -1L);
+    }
 
-  public NettyInputStreamBody(InputStream inputStream, long contentLength) {
-    this.inputStream = inputStream;
-    this.contentLength = contentLength;
-  }
+    public NettyInputStreamBody(InputStream inputStream, long contentLength) {
+        this.inputStream = inputStream;
+        this.contentLength = contentLength;
+    }
 
-  public InputStream getInputStream() {
-    return inputStream;
-  }
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    @Override
+    public long getContentLength() {
+        return contentLength;
+    }
 
-  @Override
-  public long getContentLength() {
-    return contentLength;
-  }
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        final InputStream is = inputStream;
 
-  @Override
-  public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-    final InputStream is = inputStream;
+        if (future.isStreamConsumed()) {
+            if (is.markSupported())
+                is.reset();
+            else {
+                LOGGER.warn("Stream has already been consumed and cannot be reset");
+                return;
+            }
+        } else {
+            future.setStreamConsumed(true);
+        }
 
-    if (future.isStreamConsumed()) {
-      if (is.markSupported())
-        is.reset();
-      else {
-        LOGGER.warn("Stream has already been consumed and cannot be reset");
-        return;
-      }
-    } else {
-      future.setStreamConsumed(true);
+        channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
+                new WriteProgressListener(future, false, getContentLength()) {
+                    public void operationComplete(ChannelProgressiveFuture cf) {
+                        closeSilently(is);
+                        super.operationComplete(cf);
+                    }
+                });
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
     }
-
-    channel.write(new ChunkedStream(is), channel.newProgressivePromise()).addListener(
-            new WriteProgressListener(future, false, getContentLength()) {
-              public void operationComplete(ChannelProgressiveFuture cf) {
-                closeSilently(is);
-                super.operationComplete(cf);
-              }
-            });
-    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
index 142e10d6d..00c461263 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
@@ -13,30 +13,30 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import static org.asynchttpclient.request.body.multipart.MultipartUtils.newMultipartBody;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.request.body.multipart.MultipartBody;
-import org.asynchttpclient.request.body.multipart.Part;
 
 import java.util.List;
 
-import static org.asynchttpclient.request.body.multipart.MultipartUtils.newMultipartBody;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.request.body.multipart.MultipartBody;
+import org.asynchttpclient.request.body.multipart.Part;
 
 public class NettyMultipartBody extends NettyBodyBody {
 
-  private final String contentTypeOverride;
+    private final String contentTypeOverride;
 
-  public NettyMultipartBody(List<Part> parts, HttpHeaders headers, AsyncHttpClientConfig config) {
-    this(newMultipartBody(parts, headers), config);
-  }
+    public NettyMultipartBody(List<Part> parts, HttpHeaders headers, AsyncHttpClientConfig config) {
+        this(newMultipartBody(parts, headers), config);
+    }
 
-  private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
-    super(body, config);
-    contentTypeOverride = body.getContentType();
-  }
+    private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
+        super(body, config);
+        contentTypeOverride = body.getContentType();
+    }
 
-  @Override
-  public String getContentTypeOverride() {
-    return contentTypeOverride;
-  }
+    @Override
+    public String getContentTypeOverride() {
+        return contentTypeOverride;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
index a8f2b72ef..9002e600e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -12,12 +12,15 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import com.typesafe.netty.HandlerSubscriber;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
+
+import java.io.IOException;
+import java.util.NoSuchElementException;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -25,113 +28,100 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.NoSuchElementException;
-
-import static org.asynchttpclient.util.Assertions.assertNotNull;
+import com.typesafe.netty.HandlerSubscriber;
 
 public class NettyReactiveStreamsBody implements NettyBody {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
-  private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
-
-  private final Publisher<ByteBuf> publisher;
-
-  private final long contentLength;
-
-  public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
-    this.publisher = publisher;
-    this.contentLength = contentLength;
-  }
-
-  @Override
-  public long getContentLength() {
-    return contentLength;
-  }
-
-  @Override
-  public void write(Channel channel, NettyResponseFuture<?> future) {
-    if (future.isStreamConsumed()) {
-      LOGGER.warn("Stream has already been consumed and cannot be reset");
-    } else {
-      future.setStreamConsumed(true);
-      NettySubscriber subscriber = new NettySubscriber(channel, future);
-      channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
-      publisher.subscribe(new SubscriberAdapter(subscriber));
-      subscriber.delayedStart();
-    }
-  }
-
-  private static class SubscriberAdapter implements Subscriber<ByteBuf> {
-    private final Subscriber<HttpContent> subscriber;
-
-    SubscriberAdapter(Subscriber<HttpContent> subscriber) {
-      this.subscriber = subscriber;
-    }
-
-    @Override
-    public void onSubscribe(Subscription s) {
-      subscriber.onSubscribe(s);
-    }
-
-    @Override
-    public void onNext(ByteBuf buffer) {
-      HttpContent content = new DefaultHttpContent(buffer);
-      subscriber.onNext(content);
-    }
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
+    private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
 
-    @Override
-    public void onError(Throwable t) {
-      subscriber.onError(t);
-    }
+    private final Publisher<ByteBuf> publisher;
 
-    @Override
-    public void onComplete() {
-      subscriber.onComplete();
-    }
-  }
-
-  private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
-    private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
-
-    private final Channel channel;
-    private final NettyResponseFuture<?> future;
-    private volatile Subscription deferredSubscription;
+    private final long contentLength;
 
-    NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
-      super(channel.eventLoop());
-      this.channel = channel;
-      this.future = future;
+    public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
+        this.publisher = publisher;
+        this.contentLength = contentLength;
     }
 
     @Override
-    protected void complete() {
-      channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
-              .addListener(future -> removeFromPipeline()));
+    public long getContentLength() {
+        return contentLength;
     }
 
     @Override
-    public void onSubscribe(Subscription subscription) {
-      deferredSubscription = subscription;
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        if (future.isStreamConsumed()) {
+            LOGGER.warn("Stream has already been consumed and cannot be reset");
+        } else {
+            future.setStreamConsumed(true);
+            NettySubscriber subscriber = new NettySubscriber(channel, future);
+            channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
+            publisher.subscribe(new SubscriberAdapter(subscriber));
+        }
     }
 
-    void delayedStart() {
-      super.onSubscribe(deferredSubscription);
-    }
-
-    @Override
-    protected void error(Throwable error) {
-      assertNotNull(error, "error");
-      removeFromPipeline();
-      future.abort(error);
+    private static class SubscriberAdapter implements Subscriber<ByteBuf> {
+        private final Subscriber<HttpContent> subscriber;
+
+        public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
+            this.subscriber = subscriber;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            subscriber.onSubscribe(s);
+        }
+
+        @Override
+        public void onNext(ByteBuf buffer) {
+            HttpContent content = new DefaultHttpContent(buffer);
+            subscriber.onNext(content);
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            subscriber.onError(t);
+        }
+
+        @Override
+        public void onComplete() {
+            subscriber.onComplete();
+        }
     }
 
-    private void removeFromPipeline() {
-      try {
-        channel.pipeline().remove(this);
-        LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
-      } catch (NoSuchElementException e) {
-        LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
-      }
+    private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
+        private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
+
+        private final Channel channel;
+        private final NettyResponseFuture<?> future;
+
+        public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
+            super(channel.eventLoop());
+            this.channel = channel;
+            this.future = future;
+        }
+
+        @Override
+        protected void complete() {
+            channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(future -> removeFromPipeline()));
+        }
+
+        @Override
+        protected void error(Throwable error) {
+            if (error == null)
+                throw null;
+            removeFromPipeline();
+            future.abort(error);
+        }
+
+        private void removeFromPipeline() {
+            try {
+                channel.pipeline().remove(this);
+                LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
+            } catch (NoSuchElementException e) {
+                LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
+            }
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
index 74500e403..5a35ac334 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
@@ -13,70 +13,72 @@
  */
 package org.asynchttpclient.netty.ssl;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
 import io.netty.handler.ssl.SslProvider;
 import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
-import org.asynchttpclient.AsyncHttpClientConfig;
+
+import java.util.Arrays;
 
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLException;
-import java.util.Arrays;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.AsyncHttpClientConfig;
 
 public class DefaultSslEngineFactory extends SslEngineFactoryBase {
 
-  private volatile SslContext sslContext;
+    private volatile SslContext sslContext;
 
-  private SslContext buildSslContext(AsyncHttpClientConfig config) throws SSLException {
-    if (config.getSslContext() != null) {
-      return config.getSslContext();
-    }
+    private SslContext buildSslContext(AsyncHttpClientConfig config) throws SSLException {
+        if (config.getSslContext() != null) {
+            return config.getSslContext();
+        }
+
+        SslContextBuilder sslContextBuilder = SslContextBuilder.forClient()//
+                .sslProvider(config.isUseOpenSsl() ? SslProvider.OPENSSL : SslProvider.JDK)//
+                .sessionCacheSize(config.getSslSessionCacheSize())//
+                .sessionTimeout(config.getSslSessionTimeout());
+
+        if (isNonEmpty(config.getEnabledProtocols())) {
+            sslContextBuilder.protocols(config.getEnabledProtocols());
+        }
 
-    SslContextBuilder sslContextBuilder = SslContextBuilder.forClient()
-            .sslProvider(config.isUseOpenSsl() ? SslProvider.OPENSSL : SslProvider.JDK)
-            .sessionCacheSize(config.getSslSessionCacheSize())
-            .sessionTimeout(config.getSslSessionTimeout());
+        if (isNonEmpty(config.getEnabledCipherSuites())) {
+            sslContextBuilder.ciphers(Arrays.asList(config.getEnabledCipherSuites()));
+        }
+
+        if (config.isUseInsecureTrustManager()) {
+            sslContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);
+        }
+
+        return configureSslContextBuilder(sslContextBuilder).build();
+    }
 
-    if (isNonEmpty(config.getEnabledProtocols())) {
-      sslContextBuilder.protocols(config.getEnabledProtocols());
+    @Override
+    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+        // FIXME should be using ctx allocator
+        SSLEngine sslEngine = sslContext.newEngine(ByteBufAllocator.DEFAULT, peerHost, peerPort);
+        configureSslEngine(sslEngine, config);
+        return sslEngine;
     }
 
-    if (isNonEmpty(config.getEnabledCipherSuites())) {
-      sslContextBuilder.ciphers(Arrays.asList(config.getEnabledCipherSuites()));
+    @Override
+    public void init(AsyncHttpClientConfig config) throws SSLException {
+        sslContext = buildSslContext(config);
     }
 
-    if (config.isUseInsecureTrustManager()) {
-      sslContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);
+    /**
+     * The last step of configuring the SslContextBuilder used to create an SslContext when no context is provided in the {@link AsyncHttpClientConfig}. This defaults to no-op and
+     * is intended to be overridden as needed.
+     *
+     * @param builder builder with normal configuration applied
+     * @return builder to be used to build context (can be the same object as the input)
+     */
+    protected SslContextBuilder configureSslContextBuilder(SslContextBuilder builder) {
+        // default to no op
+        return builder;
     }
 
-    return configureSslContextBuilder(sslContextBuilder).build();
-  }
-
-  @Override
-  public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
-    // FIXME should be using ctx allocator
-    SSLEngine sslEngine = sslContext.newEngine(ByteBufAllocator.DEFAULT, domain(peerHost), peerPort);
-    configureSslEngine(sslEngine, config);
-    return sslEngine;
-  }
-
-  @Override
-  public void init(AsyncHttpClientConfig config) throws SSLException {
-    sslContext = buildSslContext(config);
-  }
-
-  /**
-   * The last step of configuring the SslContextBuilder used to create an SslContext when no context is provided in the {@link AsyncHttpClientConfig}. This defaults to no-op and
-   * is intended to be overridden as needed.
-   *
-   * @param builder builder with normal configuration applied
-   * @return builder to be used to build context (can be the same object as the input)
-   */
-  protected SslContextBuilder configureSslContextBuilder(SslContextBuilder builder) {
-    // default to no op
-    return builder;
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
index 1725d3565..aa05d0262 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
@@ -13,23 +13,23 @@
  */
 package org.asynchttpclient.netty.ssl;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+
 public class JsseSslEngineFactory extends SslEngineFactoryBase {
 
-  private final SSLContext sslContext;
+    private final SSLContext sslContext;
 
-  public JsseSslEngineFactory(SSLContext sslContext) {
-    this.sslContext = sslContext;
-  }
+    public JsseSslEngineFactory(SSLContext sslContext) {
+        this.sslContext = sslContext;
+    }
 
-  @Override
-  public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
-    SSLEngine sslEngine = sslContext.createSSLEngine(domain(peerHost), peerPort);
-    configureSslEngine(sslEngine, config);
-    return sslEngine;
-  }
+    @Override
+    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+        SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
+        configureSslEngine(sslEngine, config);
+        return sslEngine;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
index d95237ac9..c4722b127 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
@@ -13,27 +13,20 @@
  */
 package org.asynchttpclient.netty.ssl;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.SslEngineFactory;
-
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLParameters;
 
-public abstract class SslEngineFactoryBase implements SslEngineFactory {
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.SslEngineFactory;
 
-  protected String domain(String hostname) {
-    int fqdnLength = hostname.length() - 1;
-    return hostname.charAt(fqdnLength) == '.' ?
-            hostname.substring(0, fqdnLength) :
-            hostname;
-  }
+public abstract class SslEngineFactoryBase implements SslEngineFactory {
 
-  protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
-    sslEngine.setUseClientMode(true);
-    if (!config.isDisableHttpsEndpointIdentificationAlgorithm()) {
-      SSLParameters params = sslEngine.getSSLParameters();
-      params.setEndpointIdentificationAlgorithm("HTTPS");
-      sslEngine.setSSLParameters(params);
+    protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
+        sslEngine.setUseClientMode(true);
+        if (!config.isDisableHttpsEndpointIdentificationAlgorithm()) {
+            SSLParameters params = sslEngine.getSSLParameters();
+            params.setEndpointIdentificationAlgorithm("HTTPS");
+            sslEngine.setSSLParameters(params);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 5aebed9f8..a91a8ea1b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -13,53 +13,54 @@
  */
 package org.asynchttpclient.netty.timeout;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.util.StringBuilderPool;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-
 public class ReadTimeoutTimerTask extends TimeoutTimerTask {
 
-  private final long readTimeout;
+    private final long readTimeout;
 
-  ReadTimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture,
-                       NettyRequestSender requestSender,
-                       TimeoutsHolder timeoutsHolder,
-                       int readTimeout) {
-    super(nettyResponseFuture, requestSender, timeoutsHolder);
-    this.readTimeout = readTimeout;
-  }
-
-  public void run(Timeout timeout) {
+    public ReadTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            int readTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.readTimeout = readTimeout;
+    }
 
-    if (done.getAndSet(true) || requestSender.isClosed())
-      return;
+    public void run(Timeout timeout) throws Exception {
 
-    if (nettyResponseFuture.isDone()) {
-      timeoutsHolder.cancel();
-      return;
-    }
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
+        
+        if (nettyResponseFuture.isDone()) {
+            timeoutsHolder.cancel();
+            return;
+        }
 
-    long now = unpreciseMillisTime();
+        long now = unpreciseMillisTime();
 
-    long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
-    long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
+        long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
+        long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
 
-    if (durationBeforeCurrentReadTimeout <= 0L) {
-      // idleConnectTimeout reached
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Read timeout to ");
-      appendRemoteAddress(sb);
-      String message = sb.append(" after ").append(readTimeout).append(" ms").toString();
-      long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
-      expire(message, durationSinceLastTouch);
-      // cancel request timeout sibling
-      timeoutsHolder.cancel();
+        if (durationBeforeCurrentReadTimeout <= 0L) {
+            // idleConnectTimeout reached
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Read timeout to ");
+            appendRemoteAddress(sb);
+            String message = sb.append(" after ").append(readTimeout).append(" ms").toString();
+            long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
+            expire(message, durationSinceLastTouch);
+            // cancel request timeout sibling
+            timeoutsHolder.cancel();
 
-    } else {
-      done.set(false);
-      timeoutsHolder.startReadTimeout(this);
+        } else {
+            done.set(false);
+            timeoutsHolder.startReadTimeout(this);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index ea8cef4f1..b8b67be3d 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -13,40 +13,41 @@
  */
 package org.asynchttpclient.netty.timeout;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
+
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.util.StringBuilderPool;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-
 public class RequestTimeoutTimerTask extends TimeoutTimerTask {
 
-  private final long requestTimeout;
+    private final long requestTimeout;
 
-  RequestTimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture,
-                                 NettyRequestSender requestSender,
-                                 TimeoutsHolder timeoutsHolder,
-                                 int requestTimeout) {
-    super(nettyResponseFuture, requestSender, timeoutsHolder);
-    this.requestTimeout = requestTimeout;
-  }
+    public RequestTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            int requestTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.requestTimeout = requestTimeout;
+    }
 
-  public void run(Timeout timeout) {
+    public void run(Timeout timeout) throws Exception {
 
-    if (done.getAndSet(true) || requestSender.isClosed())
-      return;
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
 
-    // in any case, cancel possible readTimeout sibling
-    timeoutsHolder.cancel();
+        // in any case, cancel possible readTimeout sibling
+        timeoutsHolder.cancel();
 
-    if (nettyResponseFuture.isDone())
-      return;
+        if (nettyResponseFuture.isDone())
+            return;
 
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Request timeout to ");
-    appendRemoteAddress(sb);
-    String message = sb.append(" after ").append(requestTimeout).append(" ms").toString();
-    long age = unpreciseMillisTime() - nettyResponseFuture.getStart();
-    expire(message, age);
-  }
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder().append("Request timeout to ");
+        appendRemoteAddress(sb);
+        String message =  sb.append(" after ").append(requestTimeout).append(" ms").toString();
+        long age = unpreciseMillisTime() - nettyResponseFuture.getStart();
+        expire(message, age);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index e746adfdb..a0f468852 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -14,51 +14,52 @@
 package org.asynchttpclient.netty.timeout;
 
 import io.netty.util.TimerTask;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.request.NettyRequestSender;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public abstract class TimeoutTimerTask implements TimerTask {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
 
-  protected final AtomicBoolean done = new AtomicBoolean();
-  protected final NettyRequestSender requestSender;
-  final TimeoutsHolder timeoutsHolder;
-  volatile NettyResponseFuture<?> nettyResponseFuture;
+    protected final AtomicBoolean done = new AtomicBoolean();
+    protected volatile NettyResponseFuture<?> nettyResponseFuture;
+    protected final NettyRequestSender requestSender;
+    protected final TimeoutsHolder timeoutsHolder;
 
-  TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
-    this.nettyResponseFuture = nettyResponseFuture;
-    this.requestSender = requestSender;
-    this.timeoutsHolder = timeoutsHolder;
-  }
+    public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
+        this.nettyResponseFuture = nettyResponseFuture;
+        this.requestSender = requestSender;
+        this.timeoutsHolder = timeoutsHolder;
+    }
 
-  void expire(String message, long time) {
-    LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
-    requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
-  }
+    protected void expire(String message, long time) {
+        LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
+        requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
+    }
 
-  /**
-   * When the timeout is cancelled, it could still be referenced for quite some time in the Timer. Holding a reference to the future might mean holding a reference to the
-   * channel, and heavy objects such as SslEngines
-   */
-  public void clean() {
-    if (done.compareAndSet(false, true)) {
-      nettyResponseFuture = null;
+    /**
+     * When the timeout is cancelled, it could still be referenced for quite some time in the Timer. Holding a reference to the future might mean holding a reference to the
+     * channel, and heavy objects such as SslEngines
+     */
+    public void clean() {
+        if (done.compareAndSet(false, true)) {
+            nettyResponseFuture = null;
+        }
     }
-  }
 
-  void appendRemoteAddress(StringBuilder sb) {
-    InetSocketAddress remoteAddress = timeoutsHolder.remoteAddress();
-    sb.append(remoteAddress.getHostName());
-    if (!remoteAddress.isUnresolved()) {
-      sb.append('/').append(remoteAddress.getAddress().getHostAddress());
+    protected void appendRemoteAddress(StringBuilder sb) {
+        InetSocketAddress remoteAddress = timeoutsHolder.remoteAddress();
+        sb.append(remoteAddress.getHostName());
+        if (!remoteAddress.isUnresolved()) {
+            sb.append('/').append(remoteAddress.getAddress().getHostAddress());
+        }
+        sb.append(':').append(remoteAddress.getPort());
     }
-    sb.append(':').append(remoteAddress.getPort());
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
index 89d3faf58..57e01c372 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
@@ -13,100 +13,102 @@
  */
 package org.asynchttpclient.netty.timeout;
 
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
 import io.netty.util.TimerTask;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.request.NettyRequestSender;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 
 public class TimeoutsHolder {
 
-  private final Timeout requestTimeout;
-  private final AtomicBoolean cancelled = new AtomicBoolean();
-  private final Timer nettyTimer;
-  private final NettyRequestSender requestSender;
-  private final long requestTimeoutMillisTime;
-  private final int readTimeoutValue;
-  private volatile Timeout readTimeout;
-  private volatile NettyResponseFuture<?> nettyResponseFuture;
-  private volatile InetSocketAddress remoteAddress;
-
-  public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config, InetSocketAddress originalRemoteAddress) {
-    this.nettyTimer = nettyTimer;
-    this.nettyResponseFuture = nettyResponseFuture;
-    this.requestSender = requestSender;
-    this.remoteAddress = originalRemoteAddress;
-
-    final Request targetRequest = nettyResponseFuture.getTargetRequest();
-
-    final int readTimeoutInMs = targetRequest.getReadTimeout();
-    this.readTimeoutValue = readTimeoutInMs == 0 ? config.getReadTimeout() : readTimeoutInMs;
-
-    int requestTimeoutInMs = targetRequest.getRequestTimeout();
-    if (requestTimeoutInMs == 0) {
-      requestTimeoutInMs = config.getRequestTimeout();
+    private final AtomicBoolean cancelled = new AtomicBoolean();
+
+    private final Timer nettyTimer;
+    private final NettyRequestSender requestSender;
+    private final long requestTimeoutMillisTime;
+    private final int readTimeoutValue;
+
+    private volatile NettyResponseFuture<?> nettyResponseFuture;
+    public final Timeout requestTimeout;
+    public volatile Timeout readTimeout;
+    private volatile InetSocketAddress remoteAddress;
+
+    public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config, InetSocketAddress originalRemoteAddress) {
+        this.nettyTimer = nettyTimer;
+        this.nettyResponseFuture = nettyResponseFuture;
+        this.requestSender = requestSender;
+        this.remoteAddress = originalRemoteAddress;
+
+        final Request targetRequest = nettyResponseFuture.getTargetRequest();
+
+        final int readTimeoutInMs = targetRequest.getReadTimeout();
+        this.readTimeoutValue = readTimeoutInMs == 0 ? config.getReadTimeout() : readTimeoutInMs;
+
+        int requestTimeoutInMs = targetRequest.getRequestTimeout();
+        if (requestTimeoutInMs == 0) {
+            requestTimeoutInMs = config.getRequestTimeout();
+        }
+
+        if (requestTimeoutInMs != -1) {
+            requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;
+            requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);
+        } else {
+            requestTimeoutMillisTime = -1L;
+            requestTimeout = null;
+        }
     }
 
-    if (requestTimeoutInMs != -1) {
-      requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;
-      requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);
-    } else {
-      requestTimeoutMillisTime = -1L;
-      requestTimeout = null;
+    public void setResolvedRemoteAddress(InetSocketAddress address) {
+        remoteAddress = address;
     }
-  }
 
-  public void setResolvedRemoteAddress(InetSocketAddress address) {
-    remoteAddress = address;
-  }
-
-  InetSocketAddress remoteAddress() {
-    return remoteAddress;
-  }
+    InetSocketAddress remoteAddress() {
+        return remoteAddress;
+    }
 
-  public void startReadTimeout() {
-    if (readTimeoutValue != -1) {
-      startReadTimeout(null);
+    public void startReadTimeout() {
+        if (readTimeoutValue != -1) {
+            startReadTimeout(null);
+        }
     }
-  }
-
-  void startReadTimeout(ReadTimeoutTimerTask task) {
-    if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {
-      // only schedule a new readTimeout if the requestTimeout doesn't happen first
-      if (task == null) {
-        // first call triggered from outside (else is read timeout is re-scheduling itself)
-        task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);
-      }
-      this.readTimeout = newTimeout(task, readTimeoutValue);
-
-    } else if (task != null) {
-      // read timeout couldn't re-scheduling itself, clean up
-      task.clean();
+
+    void startReadTimeout(ReadTimeoutTimerTask task) {
+        if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {
+            // only schedule a new readTimeout if the requestTimeout doesn't happen first
+            if (task == null) {
+                // first call triggered from outside (else is read timeout is re-scheduling itself)
+                task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);
+            }
+            this.readTimeout = newTimeout(task, readTimeoutValue);
+
+        } else if (task != null) {
+            // read timeout couldn't re-scheduling itself, clean up
+            task.clean();
+        }
     }
-  }
-
-  public void cancel() {
-    if (cancelled.compareAndSet(false, true)) {
-      if (requestTimeout != null) {
-        requestTimeout.cancel();
-        RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
-      }
-      if (readTimeout != null) {
-        readTimeout.cancel();
-        ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
-      }
+
+    public void cancel() {
+        if (cancelled.compareAndSet(false, true)) {
+            if (requestTimeout != null) {
+                requestTimeout.cancel();
+                RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
+            }
+            if (readTimeout != null) {
+                readTimeout.cancel();
+                ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
+            }
+        }
     }
-  }
 
-  private Timeout newTimeout(TimerTask task, long delay) {
-    return requestSender.isClosed() ? null : nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
-  }
+    private Timeout newTimeout(TimerTask task, long delay) {
+        return requestSender.isClosed() ? null : nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index 531eaadd8..c4f053e05 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -13,12 +13,27 @@
  */
 package org.asynchttpclient.netty.ws;
 
+import static io.netty.buffer.Unpooled.wrappedBuffer;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.websocketx.*;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
+
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.util.Utf8ByteBufCharsetDecoder;
 import org.asynchttpclient.ws.WebSocket;
@@ -26,321 +41,312 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.ConcurrentLinkedQueue;
+public class NettyWebSocket implements WebSocket {
 
-import static io.netty.buffer.Unpooled.wrappedBuffer;
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
+
+    protected final Channel channel;
+    protected final HttpHeaders upgradeHeaders;
+    protected final Collection<WebSocketListener> listeners;
+    // no need for volatile because only mutated in IO thread
+    private boolean ready;
+    private List<WebSocketFrame> bufferedFrames;
+    protected FragmentedFrameType expectedFragmentedFrameType;
+
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
+        this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
+    }
+
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
+        this.channel = channel;
+        this.upgradeHeaders = upgradeHeaders;
+        this.listeners = listeners;
+    }
+
+    @Override
+    public HttpHeaders getUpgradeHeaders() {
+        return upgradeHeaders;
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return channel.remoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return channel.localAddress();
+    }
+
+    @Override
+    public Future<Void> sendTextFrame(String message) {
+        return sendTextFrame(message, true, 0);
+    }
+
+    @Override
+    public Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv) {
+        return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
+    }
+
+    @Override
+    public Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+        return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
+    }
+
+    @Override
+    public Future<Void> sendBinaryFrame(byte[] payload) {
+        return sendBinaryFrame(payload, true, 0);
+    }
+
+    @Override
+    public Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
+        return sendBinaryFrame(wrappedBuffer(payload), finalFragment, rsv);
+    }
+
+    @Override
+    public Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+        return channel.writeAndFlush(new BinaryWebSocketFrame(payload));
+    }
+
+    @Override
+    public Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv) {
+        return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
+    }
+
+    @Override
+    public Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv) {
+        return sendContinuationFrame(wrappedBuffer(payload), finalFragment, rsv);
+    }
+
+    @Override
+    public Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv) {
+        return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
+    }
+
+    @Override
+    public Future<Void> sendPingFrame() {
+        return channel.writeAndFlush(new PingWebSocketFrame());
+    }
+
+    @Override
+    public Future<Void> sendPingFrame(byte[] payload) {
+        return sendPingFrame(wrappedBuffer(payload));
+    }
+
+    @Override
+    public Future<Void> sendPingFrame(ByteBuf payload) {
+        return channel.writeAndFlush(new PingWebSocketFrame(payload));
+    }
+
+    @Override
+    public Future<Void> sendPongFrame() {
+        return channel.writeAndFlush(new PongWebSocketFrame());
+    }
 
-public final class NettyWebSocket implements WebSocket {
-
-  private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
-
-  protected final Channel channel;
-  private final HttpHeaders upgradeHeaders;
-  private final Collection<WebSocketListener> listeners;
-  private FragmentedFrameType expectedFragmentedFrameType;
-  // no need for volatile because only mutated in IO thread
-  private boolean ready;
-  private List<WebSocketFrame> bufferedFrames;
-
-  public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
-    this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
-  }
-
-  private NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
-    this.channel = channel;
-    this.upgradeHeaders = upgradeHeaders;
-    this.listeners = listeners;
-  }
-
-  @Override
-  public HttpHeaders getUpgradeHeaders() {
-    return upgradeHeaders;
-  }
-
-  @Override
-  public SocketAddress getRemoteAddress() {
-    return channel.remoteAddress();
-  }
-
-  @Override
-  public SocketAddress getLocalAddress() {
-    return channel.localAddress();
-  }
-
-  @Override
-  public Future<Void> sendTextFrame(String message) {
-    return sendTextFrame(message, true, 0);
-  }
-
-  @Override
-  public Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv) {
-    return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
-  }
-
-  @Override
-  public Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-    return channel.writeAndFlush(new TextWebSocketFrame(finalFragment, rsv, payload));
-  }
-
-  @Override
-  public Future<Void> sendBinaryFrame(byte[] payload) {
-    return sendBinaryFrame(payload, true, 0);
-  }
-
-  @Override
-  public Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
-    return sendBinaryFrame(wrappedBuffer(payload), finalFragment, rsv);
-  }
-
-  @Override
-  public Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-    return channel.writeAndFlush(new BinaryWebSocketFrame(finalFragment, rsv, payload));
-  }
-
-  @Override
-  public Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv) {
-    return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
-  }
-
-  @Override
-  public Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv) {
-    return sendContinuationFrame(wrappedBuffer(payload), finalFragment, rsv);
-  }
-
-  @Override
-  public Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv) {
-    return channel.writeAndFlush(new ContinuationWebSocketFrame(finalFragment, rsv, payload));
-  }
-
-  @Override
-  public Future<Void> sendPingFrame() {
-    return channel.writeAndFlush(new PingWebSocketFrame());
-  }
-
-  @Override
-  public Future<Void> sendPingFrame(byte[] payload) {
-    return sendPingFrame(wrappedBuffer(payload));
-  }
-
-  @Override
-  public Future<Void> sendPingFrame(ByteBuf payload) {
-    return channel.writeAndFlush(new PingWebSocketFrame(payload));
-  }
-
-  @Override
-  public Future<Void> sendPongFrame() {
-    return channel.writeAndFlush(new PongWebSocketFrame());
-  }
-
-  @Override
-  public Future<Void> sendPongFrame(byte[] payload) {
-    return sendPongFrame(wrappedBuffer(payload));
-  }
-
-  @Override
-  public Future<Void> sendPongFrame(ByteBuf payload) {
-    return channel.writeAndFlush(new PongWebSocketFrame(wrappedBuffer(payload)));
-  }
-
-  @Override
-  public Future<Void> sendCloseFrame() {
-    return sendCloseFrame(1000, "normal closure");
-  }
-
-  @Override
-  public Future<Void> sendCloseFrame(int statusCode, String reasonText) {
-    if (channel.isOpen()) {
-      return channel.writeAndFlush(new CloseWebSocketFrame(1000, "normal closure"));
-    }
-    return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);
-  }
-
-  @Override
-  public boolean isOpen() {
-    return channel.isOpen();
-  }
-
-  @Override
-  public WebSocket addWebSocketListener(WebSocketListener l) {
-    listeners.add(l);
-    return this;
-  }
-
-  @Override
-  public WebSocket removeWebSocketListener(WebSocketListener l) {
-    listeners.remove(l);
-    return this;
-  }
-
-  // INTERNAL, NOT FOR PUBLIC USAGE!!!
-
-  public boolean isReady() {
-    return ready;
-  }
-
-  public void bufferFrame(WebSocketFrame frame) {
-    if (bufferedFrames == null) {
-      bufferedFrames = new ArrayList<>(1);
-    }
-    frame.retain();
-    bufferedFrames.add(frame);
-  }
-
-  private void releaseBufferedFrames() {
-    if (bufferedFrames != null) {
-      for (WebSocketFrame frame : bufferedFrames) {
-        frame.release();
-      }
-      bufferedFrames = null;
-    }
-  }
-
-  public void processBufferedFrames() {
-    ready = true;
-    if (bufferedFrames != null) {
-      try {
-        for (WebSocketFrame frame : bufferedFrames) {
-          handleFrame(frame);
+    @Override
+    public Future<Void> sendPongFrame(byte[] payload) {
+        return sendPongFrame(wrappedBuffer(payload));
+    }
+
+    @Override
+    public Future<Void> sendPongFrame(ByteBuf payload) {
+        return channel.writeAndFlush(new PongWebSocketFrame(wrappedBuffer(payload)));
+    }
+
+    @Override
+    public Future<Void> sendCloseFrame() {
+        return sendCloseFrame(1000, "normal closure");
+    }
+
+    @Override
+    public Future<Void> sendCloseFrame(int statusCode, String reasonText) {
+        if (channel.isOpen()) {
+            return channel.writeAndFlush(new CloseWebSocketFrame(1000, "normal closure"));
         }
-      } finally {
-        releaseBufferedFrames();
-      }
-      bufferedFrames = null;
+        return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);
+    }
+
+    @Override
+    public boolean isOpen() {
+        return channel.isOpen();
     }
-  }
 
-  public void handleFrame(WebSocketFrame frame) {
-    if (frame instanceof TextWebSocketFrame) {
-      onTextFrame((TextWebSocketFrame) frame);
+    @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        listeners.add(l);
+        return this;
+    }
 
-    } else if (frame instanceof BinaryWebSocketFrame) {
-      onBinaryFrame((BinaryWebSocketFrame) frame);
+    @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        listeners.remove(l);
+        return this;
+    }
 
-    } else if (frame instanceof CloseWebSocketFrame) {
-      Channels.setDiscard(channel);
-      CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
-      onClose(closeFrame.statusCode(), closeFrame.reasonText());
-      Channels.silentlyCloseChannel(channel);
+    // INTERNAL, NOT FOR PUBLIC USAGE!!!
 
-    } else if (frame instanceof PingWebSocketFrame) {
-      onPingFrame((PingWebSocketFrame) frame);
+    public boolean isReady() {
+        return ready;
+    }
 
-    } else if (frame instanceof PongWebSocketFrame) {
-      onPongFrame((PongWebSocketFrame) frame);
+    public void bufferFrame(WebSocketFrame frame) {
+        if (bufferedFrames == null) {
+            bufferedFrames = new ArrayList<>(1);
+        }
+        frame.retain();
+        bufferedFrames.add(frame);
+    }
 
-    } else if (frame instanceof ContinuationWebSocketFrame) {
-      onContinuationFrame((ContinuationWebSocketFrame) frame);
+    private void releaseBufferedFrames() {
+        if (bufferedFrames != null) {
+            for (WebSocketFrame frame : bufferedFrames) {
+                frame.release();
+            }
+            bufferedFrames = null;
+        }
     }
-  }
 
-  public void onError(Throwable t) {
-    try {
-      for (WebSocketListener listener : listeners) {
+    public void processBufferedFrames() {
+        ready = true;
+        if (bufferedFrames != null) {
+            try {
+                for (WebSocketFrame frame : bufferedFrames) {
+                    handleFrame(frame);
+                }
+            } finally {
+                releaseBufferedFrames();
+            }
+            bufferedFrames = null;
+        }
+    }
+
+    public void handleFrame(WebSocketFrame frame) {
+        if (frame instanceof TextWebSocketFrame) {
+            onTextFrame((TextWebSocketFrame) frame);
+
+        } else if (frame instanceof BinaryWebSocketFrame) {
+            onBinaryFrame((BinaryWebSocketFrame) frame);
+
+        } else if (frame instanceof CloseWebSocketFrame) {
+            Channels.setDiscard(channel);
+            CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
+            onClose(closeFrame.statusCode(), closeFrame.reasonText());
+            Channels.silentlyCloseChannel(channel);
+
+        } else if (frame instanceof PingWebSocketFrame) {
+            onPingFrame((PingWebSocketFrame) frame);
+
+        } else if (frame instanceof PongWebSocketFrame) {
+            onPongFrame((PongWebSocketFrame) frame);
+
+        } else if (frame instanceof ContinuationWebSocketFrame) {
+            onContinuationFrame((ContinuationWebSocketFrame) frame);
+        }
+    }
+
+    public void onError(Throwable t) {
         try {
-          listener.onError(t);
-        } catch (Throwable t2) {
-          LOGGER.error("WebSocketListener.onError crash", t2);
+            for (WebSocketListener listener : listeners) {
+                try {
+                    listener.onError(t);
+                } catch (Throwable t2) {
+                    LOGGER.error("WebSocketListener.onError crash", t2);
+                }
+            }
+        } finally {
+            releaseBufferedFrames();
         }
-      }
-    } finally {
-      releaseBufferedFrames();
     }
-  }
 
-  public void onClose(int code, String reason) {
-    try {
-      for (WebSocketListener l : listeners) {
+    public void onClose(int code, String reason) {
         try {
-          l.onClose(this, code, reason);
-        } catch (Throwable t) {
-          l.onError(t);
+            for (WebSocketListener l : listeners) {
+                try {
+                    l.onClose(this, code, reason);
+                } catch (Throwable t) {
+                    l.onError(t);
+                }
+            }
+            listeners.clear();
+        } finally {
+            releaseBufferedFrames();
         }
-      }
-      listeners.clear();
-    } finally {
-      releaseBufferedFrames();
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "NettyWebSocket{channel=" + channel + '}';
-  }
-
-  private void onBinaryFrame(BinaryWebSocketFrame frame) {
-    if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
-      expectedFragmentedFrameType = FragmentedFrameType.BINARY;
-    }
-    onBinaryFrame0(frame);
-  }
-
-  private void onBinaryFrame0(WebSocketFrame frame) {
-    byte[] bytes = byteBuf2Bytes(frame.content());
-    for (WebSocketListener listener : listeners) {
-      listener.onBinaryFrame(bytes, frame.isFinalFragment(), frame.rsv());
-    }
-  }
-
-  private void onTextFrame(TextWebSocketFrame frame) {
-    if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
-      expectedFragmentedFrameType = FragmentedFrameType.TEXT;
-    }
-    onTextFrame0(frame);
-  }
-
-  private void onTextFrame0(WebSocketFrame frame) {
-    // faster than frame.text();
-    String text = Utf8ByteBufCharsetDecoder.decodeUtf8(frame.content());
-    frame.isFinalFragment();
-    frame.rsv();
-    for (WebSocketListener listener : listeners) {
-      listener.onTextFrame(text, frame.isFinalFragment(), frame.rsv());
-    }
-  }
-
-  private void onContinuationFrame(ContinuationWebSocketFrame frame) {
-    if (expectedFragmentedFrameType == null) {
-      LOGGER.warn("Received continuation frame without an original text or binary frame, ignoring");
-      return;
-    }
-    try {
-      switch (expectedFragmentedFrameType) {
-        case BINARY:
-          onBinaryFrame0(frame);
-          break;
-        case TEXT:
-          onTextFrame0(frame);
-          break;
-        default:
-          throw new IllegalArgumentException("Unknown FragmentedFrameType " + expectedFragmentedFrameType);
-      }
-    } finally {
-      if (frame.isFinalFragment()) {
-        expectedFragmentedFrameType = null;
-      }
-    }
-  }
-
-  private void onPingFrame(PingWebSocketFrame frame) {
-    byte[] bytes = byteBuf2Bytes(frame.content());
-    for (WebSocketListener listener : listeners) {
-      listener.onPingFrame(bytes);
-    }
-  }
-
-  private void onPongFrame(PongWebSocketFrame frame) {
-    byte[] bytes = byteBuf2Bytes(frame.content());
-    for (WebSocketListener listener : listeners) {
-      listener.onPongFrame(bytes);
-    }
-  }
-
-  private enum FragmentedFrameType {
-    TEXT, BINARY
-  }
+    }
+
+    @Override
+    public String toString() {
+        return "NettyWebSocket{channel=" + channel + '}';
+    }
+
+    public void onBinaryFrame(BinaryWebSocketFrame frame) {
+        if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
+            expectedFragmentedFrameType = FragmentedFrameType.BINARY;
+        }
+        onBinaryFrame0(frame);
+    }
+
+    private void onBinaryFrame0(WebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
+        for (WebSocketListener listener : listeners) {
+            listener.onBinaryFrame(bytes, frame.isFinalFragment(), frame.rsv());
+        }
+    }
+
+    public void onTextFrame(TextWebSocketFrame frame) {
+        if (expectedFragmentedFrameType == null && !frame.isFinalFragment()) {
+            expectedFragmentedFrameType = FragmentedFrameType.TEXT;
+        }
+        onTextFrame0(frame);
+    }
+
+    private void onTextFrame0(WebSocketFrame frame) {
+        // faster than frame.text();
+        String text = Utf8ByteBufCharsetDecoder.decodeUtf8(frame.content());
+        frame.isFinalFragment();
+        frame.rsv();
+        for (WebSocketListener listener : listeners) {
+            listener.onTextFrame(text, frame.isFinalFragment(), frame.rsv());
+        }
+    }
+
+    public void onContinuationFrame(ContinuationWebSocketFrame frame) {
+        if (expectedFragmentedFrameType == null) {
+            LOGGER.warn("Received continuation frame without an original text or binary frame, ignoring");
+            return;
+        }
+        try {
+            switch (expectedFragmentedFrameType) {
+            case BINARY:
+                onBinaryFrame0(frame);
+                break;
+            case TEXT:
+                onTextFrame0(frame);
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown FragmentedFrameType " + expectedFragmentedFrameType);
+            }
+        } finally {
+            if (frame.isFinalFragment()) {
+                expectedFragmentedFrameType = null;
+            }
+        }
+    }
+
+    public void onPingFrame(PingWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
+        for (WebSocketListener listener : listeners) {
+            listener.onPingFrame(bytes);
+        }
+    }
+
+    public void onPongFrame(PongWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
+        for (WebSocketListener listener : listeners) {
+            listener.onPongFrame(bytes);
+        }
+    }
+
+    private enum FragmentedFrameType {
+        TEXT, BINARY;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
index 9b42a11da..3874723bf 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
@@ -27,10 +27,8 @@
 // fork from Apache HttpComponents
 package org.asynchttpclient.ntlm;
 
-import org.asynchttpclient.util.Base64;
+import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import javax.crypto.Cipher;
-import javax.crypto.spec.SecretKeySpec;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.UnsupportedCharsetException;
@@ -39,7 +37,10 @@
 import java.util.Arrays;
 import java.util.Locale;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.asynchttpclient.util.Base64;
 
 /**
  * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
index fe15cffd3..23f005ebf 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
@@ -30,27 +30,28 @@
 /**
  * Signals NTLM protocol failure.
  */
-class NtlmEngineException extends RuntimeException {
+public class NtlmEngineException extends RuntimeException {
 
-  private static final long serialVersionUID = 6027981323731768824L;
+    private static final long serialVersionUID = 6027981323731768824L;
 
-  /**
-   * Creates a new NTLMEngineException with the specified message.
-   *
-   * @param message the exception detail message
-   */
-  NtlmEngineException(String message) {
-    super(message);
-  }
+    /**
+     * Creates a new NTLMEngineException with the specified message.
+     *
+     * @param message the exception detail message
+     */
+    public NtlmEngineException(String message) {
+        super(message);
+    }
+
+    /**
+     * Creates a new NTLMEngineException with the specified detail message and cause.
+     *
+     * @param message the exception detail message
+     * @param cause   the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
+     *                if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
+     */
+    public NtlmEngineException(String message, Throwable cause) {
+        super(message, cause);
+    }
 
-  /**
-   * Creates a new NTLMEngineException with the specified detail message and cause.
-   *
-   * @param message the exception detail message
-   * @param cause   the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
-   *                if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
-   */
-  NtlmEngineException(String message, Throwable cause) {
-    super(message, cause);
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java b/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
index 552a132db..5e4aab488 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
@@ -22,60 +22,60 @@
  * Value class for OAuth consumer keys.
  */
 public class ConsumerKey {
-  private final String key;
-  private final String secret;
-  private final String percentEncodedKey;
+    private final String key;
+    private final String secret;
+    private final String percentEncodedKey;
 
-  public ConsumerKey(String key, String secret) {
-    this.key = key;
-    this.secret = secret;
-    this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
-  }
+    public ConsumerKey(String key, String secret) {
+        this.key = key;
+        this.secret = secret;
+        this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
+    }
 
-  public String getKey() {
-    return key;
-  }
+    public String getKey() {
+        return key;
+    }
 
-  public String getSecret() {
-    return secret;
-  }
+    public String getSecret() {
+        return secret;
+    }
 
-  public String getPercentEncodedKey() {
-    return percentEncodedKey;
-  }
+    String getPercentEncodedKey() {
+        return percentEncodedKey;
+    }
 
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder("{Consumer key, key=");
-    appendValue(sb, key);
-    sb.append(", secret=");
-    appendValue(sb, secret);
-    sb.append("}");
-    return sb.toString();
-  }
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder("{Consumer key, key=");
+        appendValue(sb, key);
+        sb.append(", secret=");
+        appendValue(sb, secret);
+        sb.append("}");
+        return sb.toString();
+    }
 
-  private void appendValue(StringBuilder sb, String value) {
-    if (value == null) {
-      sb.append("null");
-    } else {
-      sb.append('"');
-      sb.append(value);
-      sb.append('"');
+    private void appendValue(StringBuilder sb, String value) {
+        if (value == null) {
+            sb.append("null");
+        } else {
+            sb.append('"');
+            sb.append(value);
+            sb.append('"');
+        }
     }
-  }
 
-  @Override
-  public int hashCode() {
-    return key.hashCode() + secret.hashCode();
-  }
+    @Override
+    public int hashCode() {
+        return key.hashCode() + secret.hashCode();
+    }
 
-  @Override
-  public boolean equals(Object o) {
-    if (o == this)
-      return true;
-    if (o == null || o.getClass() != getClass())
-      return false;
-    ConsumerKey other = (ConsumerKey) o;
-    return key.equals(other.key) && secret.equals(other.secret);
-  }
+    @Override
+    public boolean equals(Object o) {
+        if (o == this)
+            return true;
+        if (o == null || o.getClass() != getClass())
+            return false;
+        ConsumerKey other = (ConsumerKey) o;
+        return key.equals(other.key) && secret.equals(other.secret);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index bc659196d..2527d7d51 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -13,45 +13,47 @@
  */
 package org.asynchttpclient.oauth;
 
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
 
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-
 /**
  * OAuth {@link SignatureCalculator} that delegates to {@link OAuthSignatureCalculatorInstance}s.
  */
 public class OAuthSignatureCalculator implements SignatureCalculator {
 
-  private static final ThreadLocal<OAuthSignatureCalculatorInstance> INSTANCES = ThreadLocal.withInitial(() -> {
-    try {
-      return new OAuthSignatureCalculatorInstance();
-    } catch (NoSuchAlgorithmException e) {
-      throw new ExceptionInInitializerError(e);
+    private static final ThreadLocal<OAuthSignatureCalculatorInstance> INSTANCES = new ThreadLocal<OAuthSignatureCalculatorInstance>() {
+        protected OAuthSignatureCalculatorInstance initialValue() {
+            try {
+                return new OAuthSignatureCalculatorInstance();
+            } catch (NoSuchAlgorithmException e) {
+                throw new ExceptionInInitializerError(e);
+            }
+        };
+    };
+
+    private final ConsumerKey consumerAuth;
+
+    private final RequestToken userAuth;
+
+    /**
+     * @param consumerAuth Consumer key to use for signature calculation
+     * @param userAuth Request/access token to use for signature calculation
+     */
+    public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth) {
+        this.consumerAuth = consumerAuth;
+        this.userAuth = userAuth;
     }
-  });
-
-  private final ConsumerKey consumerAuth;
-
-  private final RequestToken userAuth;
-
-  /**
-   * @param consumerAuth Consumer key to use for signature calculation
-   * @param userAuth     Request/access token to use for signature calculation
-   */
-  public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth) {
-    this.consumerAuth = consumerAuth;
-    this.userAuth = userAuth;
-  }
-
-  @Override
-  public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
-    try {
-      INSTANCES.get().sign(consumerAuth, userAuth, request, requestBuilder);
-    } catch (InvalidKeyException e) {
-      throw new IllegalArgumentException("Failed to compute a valid key from consumer and user secrets", e);
+
+    @Override
+    public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
+        try {
+            INSTANCES.get().sign(consumerAuth, userAuth, request, requestBuilder);
+        } catch (InvalidKeyException e) {
+            throw new IllegalArgumentException("Failed to compute a valid key from consumer and user secrets", e);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
index 67be29642..4d171694a 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorInstance.java
@@ -13,18 +13,9 @@
  */
 package org.asynchttpclient.oauth;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilderBase;
-import org.asynchttpclient.SignatureCalculator;
-import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.StringBuilderPool;
-import org.asynchttpclient.util.StringUtils;
-import org.asynchttpclient.util.Utf8UrlEncoder;
 
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
 import java.nio.ByteBuffer;
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
@@ -32,159 +23,171 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.regex.Pattern;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilderBase;
+import org.asynchttpclient.SignatureCalculator;
+import org.asynchttpclient.util.Base64;
+import org.asynchttpclient.util.StringBuilderPool;
+import org.asynchttpclient.util.StringUtils;
+import org.asynchttpclient.util.Utf8UrlEncoder;
 
 /**
  * Non thread-safe {@link SignatureCalculator} for OAuth1.
- * <p>
+ * 
  * Supports most common signature inclusion and calculation methods: HMAC-SHA1 for calculation, and Header inclusion as inclusion method. Nonce generation uses simple random
  * numbers with base64 encoding.
  */
 class OAuthSignatureCalculatorInstance {
 
-  private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
-  private static final Pattern PLUS_CHAR_PATTERN = Pattern.compile("+", Pattern.LITERAL);
-  private static final Pattern ENCODED_TILDE_PATTERN = Pattern.compile("%7E", Pattern.LITERAL);
-  private static final String KEY_OAUTH_CONSUMER_KEY = "oauth_consumer_key";
-  private static final String KEY_OAUTH_NONCE = "oauth_nonce";
-  private static final String KEY_OAUTH_SIGNATURE = "oauth_signature";
-  private static final String KEY_OAUTH_SIGNATURE_METHOD = "oauth_signature_method";
-  private static final String KEY_OAUTH_TIMESTAMP = "oauth_timestamp";
-  private static final String KEY_OAUTH_TOKEN = "oauth_token";
-  private static final String KEY_OAUTH_VERSION = "oauth_version";
-  private static final String OAUTH_VERSION_1_0 = "1.0";
-  private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
-  private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
-
-  private final Mac mac;
-  private final byte[] nonceBuffer = new byte[16];
-  private final Parameters parameters = new Parameters();
-
-  OAuthSignatureCalculatorInstance() throws NoSuchAlgorithmException {
-    mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
-  }
-
-  private static long generateTimestamp() {
-    return System.currentTimeMillis() / 1000L;
-  }
-
-  public void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder) throws InvalidKeyException {
-    String nonce = generateNonce();
-    long timestamp = generateTimestamp();
-    sign(consumerAuth, userAuth, request, requestBuilder, timestamp, nonce);
-  }
-
-  private String generateNonce() {
-    ThreadLocalRandom.current().nextBytes(nonceBuffer);
-    // let's use base64 encoding over hex, slightly more compact than hex or decimals
-    return Base64.encode(nonceBuffer);
-  }
-
-  void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder, long timestamp, String nonce) throws InvalidKeyException {
-    String percentEncodedNonce = Utf8UrlEncoder.percentEncodeQueryElement(nonce);
-    String signature = calculateSignature(consumerAuth, userAuth, request, timestamp, percentEncodedNonce);
-    String headerValue = constructAuthHeader(consumerAuth, userAuth, signature, timestamp, percentEncodedNonce);
-    requestBuilder.setHeader(HttpHeaderNames.AUTHORIZATION, headerValue);
-  }
-
-  String calculateSignature(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) throws InvalidKeyException {
-
-    StringBuilder sb = signatureBaseString(consumerAuth, userAuth, request, oauthTimestamp, percentEncodedNonce);
-
-    ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
-    byte[] rawSignature = digest(consumerAuth, userAuth, rawBase);
-    // and finally, base64 encoded... phew!
-    return Base64.encode(rawSignature);
-  }
-
-  StringBuilder signatureBaseString(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) {
-
-    // beware: must generate first as we're using pooled StringBuilder
-    String baseUrl = request.getUri().toBaseUrl();
-    String encodedParams = encodedParams(consumerAuth, userAuth, oauthTimestamp, percentEncodedNonce, request.getFormParams(), request.getQueryParams());
-
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    sb.append(request.getMethod()); // POST / GET etc (nothing to URL encode)
-    sb.append('&');
-    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, baseUrl);
-
-    // and all that needs to be URL encoded (... again!)
-    sb.append('&');
-    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, encodedParams);
-    return sb;
-  }
-
-  private String encodedParams(ConsumerKey consumerAuth, RequestToken userAuth, long oauthTimestamp, String percentEncodedNonce, List<Param> formParams, List<Param> queryParams) {
-
-    parameters.reset();
-
-    // List of all query and form parameters added to this request; needed for calculating request signature
-    // Start with standard OAuth parameters we need
-    parameters.add(KEY_OAUTH_CONSUMER_KEY, consumerAuth.getPercentEncodedKey())
-            .add(KEY_OAUTH_NONCE, percentEncodedNonce)
-            .add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD)
-            .add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
-    if (userAuth.getKey() != null) {
-      parameters.add(KEY_OAUTH_TOKEN, userAuth.getPercentEncodedKey());
+    private static final Pattern STAR_CHAR_PATTERN = Pattern.compile("*", Pattern.LITERAL);
+    private static final Pattern PLUS_CHAR_PATTERN = Pattern.compile("+", Pattern.LITERAL);
+    private static final Pattern ENCODED_TILDE_PATTERN = Pattern.compile("%7E", Pattern.LITERAL);
+    private static final String KEY_OAUTH_CONSUMER_KEY = "oauth_consumer_key";
+    private static final String KEY_OAUTH_NONCE = "oauth_nonce";
+    private static final String KEY_OAUTH_SIGNATURE = "oauth_signature";
+    private static final String KEY_OAUTH_SIGNATURE_METHOD = "oauth_signature_method";
+    private static final String KEY_OAUTH_TIMESTAMP = "oauth_timestamp";
+    private static final String KEY_OAUTH_TOKEN = "oauth_token";
+    private static final String KEY_OAUTH_VERSION = "oauth_version";
+    private static final String OAUTH_VERSION_1_0 = "1.0";
+    private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
+    private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
+
+    private final Mac mac;
+    private final byte[] nonceBuffer = new byte[16];
+    private final Parameters parameters = new Parameters();
+
+    public OAuthSignatureCalculatorInstance() throws NoSuchAlgorithmException {
+        mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
     }
-    parameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
 
-    if (formParams != null) {
-      for (Param param : formParams) {
-        // formParams are not already encoded
-        parameters.add(Utf8UrlEncoder.percentEncodeQueryElement(param.getName()), Utf8UrlEncoder.percentEncodeQueryElement(param.getValue()));
-      }
+    public void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder) throws InvalidKeyException {
+        String nonce = generateNonce();
+        long timestamp = generateTimestamp();
+        sign(consumerAuth, userAuth, request, requestBuilder, timestamp, nonce);
     }
-    if (queryParams != null) {
-      for (Param param : queryParams) {
-        // queryParams are already form-url-encoded
-        // but OAuth1 uses RFC3986_UNRESERVED_CHARS so * and + have to be encoded
-        parameters.add(percentEncodeAlreadyFormUrlEncoded(param.getName()), percentEncodeAlreadyFormUrlEncoded(param.getValue()));
-      }
+
+    private String generateNonce() {
+        ThreadLocalRandom.current().nextBytes(nonceBuffer);
+        // let's use base64 encoding over hex, slightly more compact than hex or decimals
+        return Base64.encode(nonceBuffer);
     }
-    return parameters.sortAndConcat();
-  }
-
-  private String percentEncodeAlreadyFormUrlEncoded(String s) {
-    s = STAR_CHAR_PATTERN.matcher(s).replaceAll("%2A");
-    s = PLUS_CHAR_PATTERN.matcher(s).replaceAll("%20");
-    s = ENCODED_TILDE_PATTERN.matcher(s).replaceAll("~");
-    return s;
-  }
-
-  private byte[] digest(ConsumerKey consumerAuth, RequestToken userAuth, ByteBuffer message) throws InvalidKeyException {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    Utf8UrlEncoder.encodeAndAppendQueryElement(sb, consumerAuth.getSecret());
-    sb.append('&');
-    if (userAuth != null && userAuth.getSecret() != null) {
-      Utf8UrlEncoder.encodeAndAppendQueryElement(sb, userAuth.getSecret());
+
+    private static long generateTimestamp() {
+        return System.currentTimeMillis() / 1000L;
     }
-    byte[] keyBytes = StringUtils.charSequence2Bytes(sb, UTF_8);
-    SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
-
-    mac.init(signingKey);
-    mac.reset();
-    mac.update(message);
-    return mac.doFinal();
-  }
-
-  String constructAuthHeader(ConsumerKey consumerAuth, RequestToken userAuth, String signature, long oauthTimestamp, String percentEncodedNonce) {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    sb.append("OAuth ");
-    sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getPercentEncodedKey()).append("\", ");
-    if (userAuth.getKey() != null) {
-      sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getPercentEncodedKey()).append("\", ");
+
+    void sign(ConsumerKey consumerAuth, RequestToken userAuth, Request request, RequestBuilderBase<?> requestBuilder, long timestamp, String nonce) throws InvalidKeyException {
+        String percentEncodedNonce = Utf8UrlEncoder.percentEncodeQueryElement(nonce);
+        String signature = calculateSignature(consumerAuth, userAuth, request, timestamp, percentEncodedNonce);
+        String headerValue = constructAuthHeader(consumerAuth, userAuth, signature, timestamp, percentEncodedNonce);
+        requestBuilder.setHeader(HttpHeaderNames.AUTHORIZATION, headerValue);
     }
-    sb.append(KEY_OAUTH_SIGNATURE_METHOD).append("=\"").append(OAUTH_SIGNATURE_METHOD).append("\", ");
 
-    // careful: base64 has chars that need URL encoding:
-    sb.append(KEY_OAUTH_SIGNATURE).append("=\"");
-    Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, signature).append("\", ");
-    sb.append(KEY_OAUTH_TIMESTAMP).append("=\"").append(oauthTimestamp).append("\", ");
+    String calculateSignature(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) throws InvalidKeyException {
+
+        StringBuilder sb = signatureBaseString(consumerAuth, userAuth, request, oauthTimestamp, percentEncodedNonce);
 
-    sb.append(KEY_OAUTH_NONCE).append("=\"").append(percentEncodedNonce).append("\", ");
+        ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
+        byte[] rawSignature = digest(consumerAuth, userAuth, rawBase);
+        // and finally, base64 encoded... phew!
+        return Base64.encode(rawSignature);
+    }
+
+    StringBuilder signatureBaseString(ConsumerKey consumerAuth, RequestToken userAuth, Request request, long oauthTimestamp, String percentEncodedNonce) {
+
+        // beware: must generate first as we're using pooled StringBuilder
+        String baseUrl = request.getUri().toBaseUrl();
+        String encodedParams = encodedParams(consumerAuth, userAuth, oauthTimestamp, percentEncodedNonce, request.getFormParams(), request.getQueryParams());
+
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        sb.append(request.getMethod()); // POST / GET etc (nothing to URL encode)
+        sb.append('&');
+        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, baseUrl);
+
+        // and all that needs to be URL encoded (... again!)
+        sb.append('&');
+        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, encodedParams);
+        return sb;
+    }
 
-    sb.append(KEY_OAUTH_VERSION).append("=\"").append(OAUTH_VERSION_1_0).append("\"");
-    return sb.toString();
-  }
+    private String encodedParams(ConsumerKey consumerAuth, RequestToken userAuth, long oauthTimestamp, String percentEncodedNonce, List<Param> formParams, List<Param> queryParams) {
+
+        parameters.reset();
+
+        /**
+         * List of all query and form parameters added to this request; needed for calculating request signature
+         */
+        // start with standard OAuth parameters we need
+        parameters.add(KEY_OAUTH_CONSUMER_KEY, consumerAuth.getPercentEncodedKey())//
+                .add(KEY_OAUTH_NONCE, percentEncodedNonce)
+                .add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD)//
+                .add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
+        if (userAuth.getKey() != null) {
+            parameters.add(KEY_OAUTH_TOKEN, userAuth.getPercentEncodedKey());
+        }
+        parameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
+
+        if (formParams != null) {
+            for (Param param : formParams) {
+                // formParams are not already encoded
+                parameters.add(Utf8UrlEncoder.percentEncodeQueryElement(param.getName()), Utf8UrlEncoder.percentEncodeQueryElement(param.getValue()));
+            }
+        }
+        if (queryParams != null) {
+            for (Param param : queryParams) {
+                // queryParams are already form-url-encoded
+                // but OAuth1 uses RFC3986_UNRESERVED_CHARS so * and + have to be encoded
+                parameters.add(percentEncodeAlreadyFormUrlEncoded(param.getName()), percentEncodeAlreadyFormUrlEncoded(param.getValue()));
+            }
+        }
+        return parameters.sortAndConcat();
+    }
+
+    private String percentEncodeAlreadyFormUrlEncoded(String s) {
+        s = STAR_CHAR_PATTERN.matcher(s).replaceAll("%2A");
+        s = PLUS_CHAR_PATTERN.matcher(s).replaceAll("%20");
+        s = ENCODED_TILDE_PATTERN.matcher(s).replaceAll("~");
+        return s;
+    }
+
+    private byte[] digest(ConsumerKey consumerAuth, RequestToken userAuth, ByteBuffer message) throws InvalidKeyException {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, consumerAuth.getSecret());
+        sb.append('&');
+        if (userAuth != null && userAuth.getSecret() != null) {
+            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, userAuth.getSecret());
+        }
+        byte[] keyBytes = StringUtils.charSequence2Bytes(sb, UTF_8);
+        SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
+
+        mac.init(signingKey);
+        mac.reset();
+        mac.update(message);
+        return mac.doFinal();
+    }
+
+    String constructAuthHeader(ConsumerKey consumerAuth, RequestToken userAuth, String signature, long oauthTimestamp, String percentEncodedNonce) {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        sb.append("OAuth ");
+        sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getPercentEncodedKey()).append("\", ");
+        if (userAuth.getKey() != null) {
+            sb.append(KEY_OAUTH_TOKEN).append("=\"").append(userAuth.getPercentEncodedKey()).append("\", ");
+        }
+        sb.append(KEY_OAUTH_SIGNATURE_METHOD).append("=\"").append(OAUTH_SIGNATURE_METHOD).append("\", ");
+
+        // careful: base64 has chars that need URL encoding:
+        sb.append(KEY_OAUTH_SIGNATURE).append("=\"");
+        Utf8UrlEncoder.encodeAndAppendPercentEncoded(sb, signature).append("\", ");
+        sb.append(KEY_OAUTH_TIMESTAMP).append("=\"").append(oauthTimestamp).append("\", ");
+
+        sb.append(KEY_OAUTH_NONCE).append("=\"").append(percentEncodedNonce).append("\", ");
+
+        sb.append(KEY_OAUTH_VERSION).append("=\"").append(OAUTH_VERSION_1_0).append("\"");
+        return sb.toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/Parameter.java b/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
index bc4734ea2..8da44279d 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/Parameter.java
@@ -18,39 +18,39 @@
  */
 final class Parameter implements Comparable<Parameter> {
 
-  final String key, value;
-
-  public Parameter(String key, String value) {
-    this.key = key;
-    this.value = value;
-  }
-
-  @Override
-  public int compareTo(Parameter other) {
-    int keyDiff = key.compareTo(other.key);
-    return keyDiff == 0 ? value.compareTo(other.value) : keyDiff;
-  }
-
-  @Override
-  public String toString() {
-    return key + "=" + value;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o)
-      return true;
-    if (o == null || getClass() != o.getClass())
-      return false;
-
-    Parameter parameter = (Parameter) o;
-    return key.equals(parameter.key) && value.equals(parameter.value);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = key.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
+    final String key, value;
+
+    public Parameter(String key, String value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    @Override
+    public int compareTo(Parameter other) {
+        int keyDiff = key.compareTo(other.key);
+        return keyDiff == 0 ? value.compareTo(other.value) : keyDiff;
+    }
+
+    @Override
+    public String toString() {
+        return key + "=" + value;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o)
+            return true;
+        if (o == null || getClass() != o.getClass())
+            return false;
+
+        Parameter parameter = (Parameter) o;
+        return key.equals(parameter.key) && value.equals(parameter.value);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = key.hashCode();
+        result = 31 * result + value.hashCode();
+        return result;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/Parameters.java b/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
index b0c533ac2..17f4af9f6 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/Parameters.java
@@ -13,38 +13,39 @@
  */
 package org.asynchttpclient.oauth;
 
-import org.asynchttpclient.util.StringBuilderPool;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-final class Parameters {
-
-  private List<Parameter> parameters = new ArrayList<>();
+import org.asynchttpclient.util.StringBuilderPool;
 
-  public Parameters add(String key, String value) {
-    parameters.add(new Parameter(key, value));
-    return this;
-  }
+class Parameters {
 
-  public void reset() {
-    parameters.clear();
-  }
+    private List<Parameter> parameters = new ArrayList<>();
 
-  String sortAndConcat() {
-    // then sort them (AFTER encoding, important)
-    Collections.sort(parameters);
+    Parameters add(String key, String value) {
+        parameters.add(new Parameter(key, value));
+        return this;
+    }
 
-    // and build parameter section using pre-encoded pieces:
-    StringBuilder encodedParams = StringBuilderPool.DEFAULT.stringBuilder();
-    for (Parameter param : parameters) {
-      encodedParams.append(param.key).append('=').append(param.value).append('&');
+    void reset() {
+        parameters.clear();
     }
-    int length = encodedParams.length();
-    if (length > 0) {
-      encodedParams.setLength(length - 1);
+
+    String sortAndConcat() {
+        // then sort them (AFTER encoding, important)
+        Collections.sort(parameters);
+
+        // and build parameter section using pre-encoded pieces:
+        StringBuilder encodedParams = StringBuilderPool.DEFAULT.stringBuilder();
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter param = parameters.get(i);
+            encodedParams.append(param.key).append('=').append(param.value).append('&');
+        }
+        int length = encodedParams.length();
+        if (length > 0) {
+            encodedParams.setLength(length - 1);
+        }
+        return encodedParams.toString();
     }
-    return encodedParams.toString();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java b/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
index 3dc53642b..0cad6a71d 100644
--- a/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
+++ b/client/src/main/java/org/asynchttpclient/oauth/RequestToken.java
@@ -24,60 +24,60 @@
  * confidential ("secret") part.
  */
 public class RequestToken {
-  private final String key;
-  private final String secret;
-  private final String percentEncodedKey;
+    private final String key;
+    private final String secret;
+    private final String percentEncodedKey;
 
-  public RequestToken(String key, String token) {
-    this.key = key;
-    this.secret = token;
-    this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
-  }
+    public RequestToken(String key, String token) {
+        this.key = key;
+        this.secret = token;
+        this.percentEncodedKey = Utf8UrlEncoder.percentEncodeQueryElement(key);
+    }
 
-  public String getKey() {
-    return key;
-  }
+    public String getKey() {
+        return key;
+    }
 
-  public String getSecret() {
-    return secret;
-  }
+    public String getSecret() {
+        return secret;
+    }
 
-  public String getPercentEncodedKey() {
-    return percentEncodedKey;
-  }
+    String getPercentEncodedKey() {
+        return percentEncodedKey;
+    }
 
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder("{ key=");
-    appendValue(sb, key);
-    sb.append(", secret=");
-    appendValue(sb, secret);
-    sb.append("}");
-    return sb.toString();
-  }
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder("{ key=");
+        appendValue(sb, key);
+        sb.append(", secret=");
+        appendValue(sb, secret);
+        sb.append("}");
+        return sb.toString();
+    }
 
-  private void appendValue(StringBuilder sb, String value) {
-    if (value == null) {
-      sb.append("null");
-    } else {
-      sb.append('"');
-      sb.append(value);
-      sb.append('"');
+    private void appendValue(StringBuilder sb, String value) {
+        if (value == null) {
+            sb.append("null");
+        } else {
+            sb.append('"');
+            sb.append(value);
+            sb.append('"');
+        }
     }
-  }
 
-  @Override
-  public int hashCode() {
-    return key.hashCode() + secret.hashCode();
-  }
+    @Override
+    public int hashCode() {
+        return key.hashCode() + secret.hashCode();
+    }
 
-  @Override
-  public boolean equals(Object o) {
-    if (o == this)
-      return true;
-    if (o == null || o.getClass() != getClass())
-      return false;
-    RequestToken other = (RequestToken) o;
-    return key.equals(other.key) && secret.equals(other.secret);
-  }
+    @Override
+    public boolean equals(Object o) {
+        if (o == this)
+            return true;
+        if (o == null || o.getClass() != getClass())
+            return false;
+        RequestToken other = (RequestToken) o;
+        return key.equals(other.key) && secret.equals(other.secret);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index 13c33590b..62e5a5393 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -16,152 +16,130 @@
  */
 package org.asynchttpclient.proxy;
 
-import org.asynchttpclient.Realm;
+import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.Realm;
 
 /**
  * Represents a proxy server.
  */
 public class ProxyServer {
 
-  private final String host;
-  private final int port;
-  private final int securedPort;
-  private final Realm realm;
-  private final List<String> nonProxyHosts;
-  private final ProxyType proxyType;
-
-  public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts,
-                     ProxyType proxyType) {
-    this.host = host;
-    this.port = port;
-    this.securedPort = securedPort;
-    this.realm = realm;
-    this.nonProxyHosts = nonProxyHosts;
-    this.proxyType = proxyType;
-  }
-
-  public String getHost() {
-    return host;
-  }
-
-  public int getPort() {
-    return port;
-  }
-
-  public int getSecuredPort() {
-    return securedPort;
-  }
-
-  public List<String> getNonProxyHosts() {
-    return nonProxyHosts;
-  }
-
-  public Realm getRealm() {
-    return realm;
-  }
-
-  public ProxyType getProxyType() {
-    return proxyType;
-  }
-
-  /**
-   * Checks whether proxy should be used according to nonProxyHosts settings of
-   * it, or we want to go directly to target host. If <code>null</code> proxy is
-   * passed in, this method returns true -- since there is NO proxy, we should
-   * avoid to use it. Simple hostname pattern matching using "*" are supported,
-   * but only as prefixes.
-   *
-   * @param hostname the hostname
-   * @return true if we have to ignore proxy use (obeying non-proxy hosts
-   * settings), false otherwise.
-   * @see <a href=
-   * "https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking
-   * Properties</a>
-   */
-  public boolean isIgnoredForHost(String hostname) {
-    assertNotNull(hostname, "hostname");
-    if (isNonEmpty(nonProxyHosts)) {
-      for (String nonProxyHost : nonProxyHosts) {
-        if (matchNonProxyHost(hostname, nonProxyHost))
-          return true;
-      }
+    private final String host;
+    private final int port;
+    private final int securedPort;
+    private final Realm realm;
+    private final List<String> nonProxyHosts;
+
+    public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts) {
+        this.host = host;
+        this.port = port;
+        this.securedPort = securedPort;
+        this.realm = realm;
+        this.nonProxyHosts = nonProxyHosts;
     }
 
-    return false;
-  }
-
-  private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
-
-    if (nonProxyHost.length() > 1) {
-      if (nonProxyHost.charAt(0) == '*') {
-        return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1,
-                nonProxyHost.length() - 1);
-      } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
-        return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
+    public String getHost() {
+        return host;
     }
 
-    return nonProxyHost.equalsIgnoreCase(targetHost);
-  }
-
-  public static class Builder {
-
-    private String host;
-    private int port;
-    private int securedPort;
-    private Realm realm;
-    private List<String> nonProxyHosts;
-    private ProxyType proxyType;
-
-    public Builder(String host, int port) {
-      this.host = host;
-      this.port = port;
-      this.securedPort = port;
+    public int getPort() {
+        return port;
     }
 
-    public Builder setSecuredPort(int securedPort) {
-      this.securedPort = securedPort;
-      return this;
+    public int getSecuredPort() {
+        return securedPort;
     }
 
-    public Builder setRealm(Realm realm) {
-      this.realm = realm;
-      return this;
+    public List<String> getNonProxyHosts() {
+        return nonProxyHosts;
     }
 
-    public Builder setRealm(Realm.Builder realm) {
-      this.realm = realm.build();
-      return this;
+    public Realm getRealm() {
+        return realm;
     }
 
-    public Builder setNonProxyHost(String nonProxyHost) {
-      if (nonProxyHosts == null)
-        nonProxyHosts = new ArrayList<>(1);
-      nonProxyHosts.add(nonProxyHost);
-      return this;
+    /**
+     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to target host. If <code>null</code> proxy is passed in, this method
+     * returns true -- since there is NO proxy, we should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
+     * 
+     * @param hostname the hostname
+     * @return true if we have to ignore proxy use (obeying non-proxy hosts settings), false otherwise.
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+     */
+    public boolean isIgnoredForHost(String hostname) {
+        assertNotNull(hostname, "hostname");
+        if (isNonEmpty(nonProxyHosts)) {
+            for (String nonProxyHost : nonProxyHosts) {
+                if (matchNonProxyHost(hostname, nonProxyHost))
+                    return true;
+            }
+        }
+
+        return false;
     }
 
-    public Builder setNonProxyHosts(List<String> nonProxyHosts) {
-      this.nonProxyHosts = nonProxyHosts;
-      return this;
-    }
+    private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
+
+        if (nonProxyHost.length() > 1) {
+            if (nonProxyHost.charAt(0) == '*') {
+                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1, nonProxyHost.length() - 1);
+            } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
+                return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
+        }
 
-    public Builder setProxyType(ProxyType proxyType) {
-      this.proxyType = proxyType;
-      return this;
+        return nonProxyHost.equalsIgnoreCase(targetHost);
     }
 
-    public ProxyServer build() {
-      List<String> nonProxyHosts = this.nonProxyHosts != null ? Collections.unmodifiableList(this.nonProxyHosts)
-              : Collections.emptyList();
-      ProxyType proxyType = this.proxyType != null ? this.proxyType : ProxyType.HTTP;
-      return new ProxyServer(host, port, securedPort, realm, nonProxyHosts, proxyType);
+    public static class Builder {
+
+        private String host;
+        private int port;
+        private int securedPort;
+        private Realm realm;
+        private List<String> nonProxyHosts;
+
+        public Builder(String host, int port) {
+            this.host = host;
+            this.port = port;
+            this.securedPort = port;
+        }
+
+        public Builder setSecuredPort(int securedPort) {
+            this.securedPort = securedPort;
+            return this;
+        }
+
+        public Builder setRealm(Realm realm) {
+            this.realm = realm;
+            return this;
+        }
+
+        public Builder setRealm(Realm.Builder realm) {
+            this.realm = realm.build();
+            return this;
+        }
+
+        public Builder setNonProxyHost(String nonProxyHost) {
+            if (nonProxyHosts == null)
+                nonProxyHosts = new ArrayList<>(1);
+            nonProxyHosts.add(nonProxyHost);
+            return this;
+        }
+
+        public Builder setNonProxyHosts(List<String> nonProxyHosts) {
+            this.nonProxyHosts = nonProxyHosts;
+            return this;
+        }
+
+        public ProxyServer build() {
+            List<String> nonProxyHosts = this.nonProxyHosts != null ? Collections.unmodifiableList(this.nonProxyHosts) : Collections.emptyList();
+            return new ProxyServer(host, port, securedPort, realm, nonProxyHosts);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
index c3381005a..359878b48 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
@@ -7,16 +7,16 @@
  */
 public interface ProxyServerSelector {
 
-  /**
-   * A selector that always selects no proxy.
-   */
-  ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
+    /**
+     * Select a proxy server to use for the given URI.
+     *
+     * @param uri The URI to select a proxy server for.
+     * @return The proxy server to use, if any.  May return null.
+     */
+    ProxyServer select(Uri uri);
 
-  /**
-   * Select a proxy server to use for the given URI.
-   *
-   * @param uri The URI to select a proxy server for.
-   * @return The proxy server to use, if any.  May return null.
-   */
-  ProxyServer select(Uri uri);
+    /**
+     * A selector that always selects no proxy.
+     */
+    ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyType.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyType.java
deleted file mode 100644
index bf680018a..000000000
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyType.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.proxy;
-
-public enum ProxyType {
-  HTTP(true), SOCKS_V4(false), SOCKS_V5(false);
-
-  private final boolean http;
-
-  ProxyType(boolean http) {
-    this.http = http;
-  }
-
-  public boolean isHttp() {
-    return http;
-  }
-
-  public boolean isSocks() {
-    return !isHttp();
-  }
-}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/Body.java b/client/src/main/java/org/asynchttpclient/request/body/Body.java
index 80e7e1c6b..66a588739 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/Body.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -1,15 +1,15 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
+* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+*
+* This program is licensed to you under the Apache License Version 2.0,
+* and you may not use this file except in compliance with the Apache License Version 2.0.
+* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the Apache License Version 2.0 is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+*/
 
 package org.asynchttpclient.request.body;
 
@@ -23,37 +23,37 @@
  */
 public interface Body extends Closeable {
 
-  /**
-   * Gets the length of the body.
-   *
-   * @return The length of the body in bytes, or negative if unknown.
-   */
-  long getContentLength();
+    enum BodyState {
 
-  /**
-   * Reads the next chunk of bytes from the body.
-   *
-   * @param target The buffer to store the chunk in, must not be {@code null}.
-   * @return The state.
-   * @throws IOException If the chunk could not be read.
-   */
-  BodyState transferTo(ByteBuf target) throws IOException;
+        /**
+         * There's something to read
+         */
+        CONTINUE,
 
-  enum BodyState {
+        /**
+         * There's nothing to read and input has to suspend
+         */
+        SUSPEND,
 
-    /**
-     * There's something to read
-     */
-    CONTINUE,
+        /**
+         * There's nothing to read and input has to stop
+         */
+        STOP
+    }
 
     /**
-     * There's nothing to read and input has to suspend
+     * Gets the length of the body.
+     *
+     * @return The length of the body in bytes, or negative if unknown.
      */
-    SUSPEND,
+    long getContentLength();
 
     /**
-     * There's nothing to read and input has to stop
+     * Reads the next chunk of bytes from the body.
+     *
+     * @param target The buffer to store the chunk in, must not be {@code null}.
+     * @return The non-negative number of bytes actually read or {@code -1} if the body has been read completely.
+     * @throws IOException If the chunk could not be read.
      */
-    STOP
-  }
+    BodyState transferTo(ByteBuf target) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
index 2d706fa63..e5bea4bf8 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
@@ -21,12 +21,14 @@
  */
 public interface RandomAccessBody extends Body {
 
-  /**
-   * Transfers the specified chunk of bytes from this body to the specified channel.
-   *
-   * @param target The destination channel to transfer the body chunk to, must not be {@code null}.
-   * @return The non-negative number of bytes actually transferred.
-   * @throws IOException If the body chunk could not be transferred.
-   */
-  long transferTo(WritableByteChannel target) throws IOException;
+    /**
+     * Transfers the specified chunk of bytes from this body to the specified channel.
+     * 
+     * @param target
+     *            The destination channel to transfer the body chunk to, must not be {@code null}.
+     * @return The non-negative number of bytes actually transferred.
+     * @throws IOException
+     *             If the body chunk could not be transferred.
+     */
+    long transferTo(WritableByteChannel target) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
index c4e01fbff..d754a9d65 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
@@ -16,11 +16,11 @@
 import io.netty.buffer.ByteBuf;
 
 public final class BodyChunk {
-  public final boolean last;
-  public final ByteBuf buffer;
+    public final boolean last;
+    public final ByteBuf buffer;
 
-  BodyChunk(ByteBuf buffer, boolean last) {
-    this.buffer = buffer;
-    this.last = last;
-  }
+    public BodyChunk(ByteBuf buffer, boolean last) {
+        this.buffer = buffer;
+        this.last = last;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
index be44180f0..4b20ee978 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
@@ -20,12 +20,12 @@
  */
 public interface BodyGenerator {
 
-  /**
-   * Creates a new instance of the request body to be read. While each invocation of this method is supposed to create
-   * a fresh instance of the body, the actual contents of all these body instances is the same. For example, the body
-   * needs to be resend after an authentication challenge of a redirect.
-   *
-   * @return The request body, never {@code null}.
-   */
-  Body createBody();
+    /**
+     * Creates a new instance of the request body to be read. While each invocation of this method is supposed to create
+     * a fresh instance of the body, the actual contents of all these body instances is the same. For example, the body
+     * needs to be resend after an authentication challenge of a redirect.
+     *
+     * @return The request body, never {@code null}.
+     */
+    Body createBody();
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
index b19590c54..ff6ca2627 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
@@ -18,12 +18,12 @@
 
 public final class BoundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<BlockingQueue<BodyChunk>> {
 
-  public BoundedQueueFeedableBodyGenerator(int capacity) {
-    super(new ArrayBlockingQueue<>(capacity, true));
-  }
+    public BoundedQueueFeedableBodyGenerator(int capacity) {
+        super(new ArrayBlockingQueue<>(capacity, true));
+    }
 
-  @Override
-  protected boolean offer(BodyChunk chunk) throws InterruptedException {
-    return queue.offer(chunk);
-  }
+    @Override
+    protected boolean offer(BodyChunk chunk) throws InterruptedException {
+        return queue.offer(chunk);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
index 3d0496fca..9790b0fee 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
@@ -13,6 +13,9 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
+
+import java.io.IOException;
+
 import org.asynchttpclient.request.body.Body;
 
 /**
@@ -20,49 +23,49 @@
  */
 public final class ByteArrayBodyGenerator implements BodyGenerator {
 
-  private final byte[] bytes;
+    private final byte[] bytes;
 
-  ByteArrayBodyGenerator(byte[] bytes) {
-    this.bytes = bytes;
-  }
+    public ByteArrayBodyGenerator(byte[] bytes) {
+        this.bytes = bytes;
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public Body createBody() {
-    return new ByteBody();
-  }
+    protected final class ByteBody implements Body {
+        private boolean eof = false;
+        private int lastPosition = 0;
 
-  protected final class ByteBody implements Body {
-    private boolean eof = false;
-    private int lastPosition = 0;
+        public long getContentLength() {
+            return bytes.length;
+        }
 
-    public long getContentLength() {
-      return bytes.length;
-    }
+        public BodyState transferTo(ByteBuf target) throws IOException {
 
-    public BodyState transferTo(ByteBuf target) {
+            if (eof) {
+                return BodyState.STOP;
+            }
 
-      if (eof) {
-        return BodyState.STOP;
-      }
+            final int remaining = bytes.length - lastPosition;
+            final int initialTargetWritableBytes = target.writableBytes();
+            if (remaining <= initialTargetWritableBytes) {
+                target.writeBytes(bytes, lastPosition, remaining);
+                eof = true;
+            } else {
+                target.writeBytes(bytes, lastPosition, initialTargetWritableBytes);
+                lastPosition += initialTargetWritableBytes;
+            }
+            return BodyState.CONTINUE;
+        }
 
-      final int remaining = bytes.length - lastPosition;
-      final int initialTargetWritableBytes = target.writableBytes();
-      if (remaining <= initialTargetWritableBytes) {
-        target.writeBytes(bytes, lastPosition, remaining);
-        eof = true;
-      } else {
-        target.writeBytes(bytes, lastPosition, initialTargetWritableBytes);
-        lastPosition += initialTargetWritableBytes;
-      }
-      return BodyState.CONTINUE;
+        public void close() throws IOException {
+            lastPosition = 0;
+            eof = false;
+        }
     }
 
-    public void close() {
-      lastPosition = 0;
-      eof = false;
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Body createBody() {
+        return new ByteBody();
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
index 3ca74f562..63c0c0262 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
@@ -14,7 +14,7 @@
 package org.asynchttpclient.request.body.generator;
 
 public interface FeedListener {
-  void onContentAdded();
+    void onContentAdded();
 
-  void onError(Throwable t);
+    void onError(Throwable t);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
index 9016cdcd3..dc259c7b7 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -21,7 +21,7 @@
  */
 public interface FeedableBodyGenerator extends BodyGenerator {
 
-  boolean feed(ByteBuf buffer, boolean isLast) throws Exception;
+    boolean feed(ByteBuf buffer, boolean isLast) throws Exception;
 
-  void setListener(FeedListener listener);
+    void setListener(FeedListener listener);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
index 1b260ee51..55db64295 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
@@ -12,48 +12,48 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import org.asynchttpclient.request.body.RandomAccessBody;
+import static org.asynchttpclient.util.Assertions.*;
 
 import java.io.File;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
+import org.asynchttpclient.request.body.RandomAccessBody;
 
 /**
  * Creates a request body from the contents of a file.
  */
 public final class FileBodyGenerator implements BodyGenerator {
 
-  private final File file;
-  private final long regionSeek;
-  private final long regionLength;
-
-  public FileBodyGenerator(File file) {
-    this(file, 0L, file.length());
-  }
-
-  public FileBodyGenerator(File file, long regionSeek, long regionLength) {
-    this.file = assertNotNull(file, "file");
-    this.regionLength = regionLength;
-    this.regionSeek = regionSeek;
-  }
-
-  public File getFile() {
-    return file;
-  }
-
-  public long getRegionLength() {
-    return regionLength;
-  }
-
-  public long getRegionSeek() {
-    return regionSeek;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public RandomAccessBody createBody() {
-    throw new UnsupportedOperationException("FileBodyGenerator.createBody isn't used, Netty direclt sends the file");
-  }
+    private final File file;
+    private final long regionSeek;
+    private final long regionLength;
+
+    public FileBodyGenerator(File file) {
+        this(file, 0L, file.length());
+    }
+
+    public FileBodyGenerator(File file, long regionSeek, long regionLength) {
+        this.file = assertNotNull(file, "file");
+        this.regionLength = regionLength;
+        this.regionSeek = regionSeek;
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public long getRegionLength() {
+        return regionLength;
+    }
+
+    public long getRegionSeek() {
+        return regionSeek;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RandomAccessBody createBody() {
+        throw new UnsupportedOperationException("FileBodyGenerator.createBody isn't used, Netty direclt sends the file");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
index b69e6b1eb..155bd0764 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
@@ -14,13 +14,14 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.request.body.Body;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.asynchttpclient.request.body.Body;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
  * <br>
@@ -29,73 +30,73 @@
  */
 public final class InputStreamBodyGenerator implements BodyGenerator {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
-  private final InputStream inputStream;
-  private final long contentLength;
+    private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
+    private final InputStream inputStream;
+    private final long contentLength;
 
-  public InputStreamBodyGenerator(InputStream inputStream) {
-    this(inputStream, -1L);
-  }
+    public InputStreamBodyGenerator(InputStream inputStream) {
+        this(inputStream, -1L);
+    }
 
-  public InputStreamBodyGenerator(InputStream inputStream, long contentLength) {
-    this.inputStream = inputStream;
-    this.contentLength = contentLength;
-  }
+    public InputStreamBodyGenerator(InputStream inputStream, long contentLength) {
+        this.inputStream = inputStream;
+        this.contentLength = contentLength;
+    }
 
-  public InputStream getInputStream() {
-    return inputStream;
-  }
+    public InputStream getInputStream() {
+        return inputStream;
+    }
 
-  public long getContentLength() {
-    return contentLength;
-  }
+    public long getContentLength() {
+        return contentLength;
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public Body createBody() {
-    return new InputStreamBody(inputStream, contentLength);
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Body createBody() {
+        return new InputStreamBody(inputStream, contentLength);
+    }
 
-  private class InputStreamBody implements Body {
+    private class InputStreamBody implements Body {
 
-    private final InputStream inputStream;
-    private final long contentLength;
-    private byte[] chunk;
+        private final InputStream inputStream;
+        private final long contentLength;
+        private byte[] chunk;
 
-    private InputStreamBody(InputStream inputStream, long contentLength) {
-      this.inputStream = inputStream;
-      this.contentLength = contentLength;
-    }
+        private InputStreamBody(InputStream inputStream, long contentLength) {
+            this.inputStream = inputStream;
+            this.contentLength = contentLength;
+        }
 
-    public long getContentLength() {
-      return contentLength;
-    }
+        public long getContentLength() {
+            return contentLength;
+        }
 
-    public BodyState transferTo(ByteBuf target) {
+        public BodyState transferTo(ByteBuf target) throws IOException {
 
-      // To be safe.
-      chunk = new byte[target.writableBytes() - 10];
+            // To be safe.
+            chunk = new byte[target.writableBytes() - 10];
 
-      int read = -1;
-      boolean write = false;
-      try {
-        read = inputStream.read(chunk);
-      } catch (IOException ex) {
-        LOGGER.warn("Unable to read", ex);
-      }
+            int read = -1;
+            boolean write = false;
+            try {
+                read = inputStream.read(chunk);
+            } catch (IOException ex) {
+                LOGGER.warn("Unable to read", ex);
+            }
 
-      if (read > 0) {
-        target.writeBytes(chunk, 0, read);
-        write = true;
-      }
-      return write ? BodyState.CONTINUE : BodyState.STOP;
-    }
+            if (read > 0) {
+                target.writeBytes(chunk, 0, read);
+                write = true;
+            }
+            return write ? BodyState.CONTINUE : BodyState.STOP;
+        }
 
-    public void close() throws IOException {
-      inputStream.close();
+        public void close() throws IOException {
+            inputStream.close();
+        }
     }
-  }
 }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
index 180108de5..08e2a935e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
@@ -14,65 +14,67 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.request.body.Body;
 
+import java.io.IOException;
 import java.util.Queue;
 
+import org.asynchttpclient.request.body.Body;
+
 public final class PushBody implements Body {
 
-  private final Queue<BodyChunk> queue;
-  private BodyState state = BodyState.CONTINUE;
+    private final Queue<BodyChunk> queue;
+    private BodyState state = BodyState.CONTINUE;
 
-  public PushBody(Queue<BodyChunk> queue) {
-    this.queue = queue;
-  }
+    public PushBody(Queue<BodyChunk> queue) {
+        this.queue = queue;
+    }
 
-  @Override
-  public long getContentLength() {
-    return -1;
-  }
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
 
-  @Override
-  public BodyState transferTo(final ByteBuf target) {
-    switch (state) {
-      case CONTINUE:
-        return readNextChunk(target);
-      case STOP:
-        return BodyState.STOP;
-      default:
-        throw new IllegalStateException("Illegal process state.");
+    @Override
+    public BodyState transferTo(final ByteBuf target) throws IOException {
+        switch (state) {
+        case CONTINUE:
+            return readNextChunk(target);
+        case STOP:
+            return BodyState.STOP;
+        default:
+            throw new IllegalStateException("Illegal process state.");
+        }
     }
-  }
 
-  private BodyState readNextChunk(ByteBuf target) {
-    BodyState res = BodyState.SUSPEND;
-    while (target.isWritable() && state != BodyState.STOP) {
-      BodyChunk nextChunk = queue.peek();
-      if (nextChunk == null) {
-        // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+    private BodyState readNextChunk(ByteBuf target) throws IOException {
+        BodyState res = BodyState.SUSPEND;
+        while (target.isWritable() && state != BodyState.STOP) {
+            BodyChunk nextChunk = queue.peek();
+            if (nextChunk == null) {
+                // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+                return res;
+            } else if (!nextChunk.buffer.isReadable() && !nextChunk.last) {
+                // skip empty buffers
+                queue.remove();
+            } else {
+                res = BodyState.CONTINUE;
+                readChunk(target, nextChunk);
+            }
+        }
         return res;
-      } else if (!nextChunk.buffer.isReadable() && !nextChunk.last) {
-        // skip empty buffers
-        queue.remove();
-      } else {
-        res = BodyState.CONTINUE;
-        readChunk(target, nextChunk);
-      }
     }
-    return res;
-  }
 
-  private void readChunk(ByteBuf target, BodyChunk part) {
-    target.writeBytes(part.buffer);
-    if (!part.buffer.isReadable()) {
-      if (part.last) {
-        state = BodyState.STOP;
-      }
-      queue.remove();
+    private void readChunk(ByteBuf target, BodyChunk part) {
+        target.writeBytes(part.buffer);
+        if (!part.buffer.isReadable()) {
+            if (part.last) {
+                state = BodyState.STOP;
+            }
+            queue.remove();
+        }
     }
-  }
 
-  @Override
-  public void close() {
-  }
+    @Override
+    public void close() {
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
index d0f387821..a945292d8 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
@@ -14,37 +14,38 @@
 package org.asynchttpclient.request.body.generator;
 
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.request.body.Body;
 
 import java.util.Queue;
 
+import org.asynchttpclient.request.body.Body;
+
 public abstract class QueueBasedFeedableBodyGenerator<T extends Queue<BodyChunk>> implements FeedableBodyGenerator {
 
-  protected final T queue;
-  private FeedListener listener;
+    protected final T queue;
+    private FeedListener listener;
 
-  public QueueBasedFeedableBodyGenerator(T queue) {
-    this.queue = queue;
-  }
+    public QueueBasedFeedableBodyGenerator(T queue) {
+        this.queue = queue;
+    }
 
-  @Override
-  public Body createBody() {
-    return new PushBody(queue);
-  }
+    @Override
+    public Body createBody() {
+        return new PushBody(queue);
+    }
 
-  protected abstract boolean offer(BodyChunk chunk) throws Exception;
+    protected abstract boolean offer(BodyChunk chunk) throws Exception;
 
-  @Override
-  public boolean feed(final ByteBuf buffer, final boolean isLast) throws Exception {
-    boolean offered = offer(new BodyChunk(buffer, isLast));
-    if (offered && listener != null) {
-      listener.onContentAdded();
+    @Override
+    public boolean feed(final ByteBuf buffer, final boolean isLast) throws Exception {
+        boolean offered = offer(new BodyChunk(buffer, isLast));
+        if (offered && listener != null) {
+            listener.onContentAdded();
+        }
+        return offered;
     }
-    return offered;
-  }
 
-  @Override
-  public void setListener(FeedListener listener) {
-    this.listener = listener;
-  }
+    @Override
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
index 7cf1c14fd..949a0fa43 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -14,6 +14,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.request.body.Body;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -21,143 +25,141 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 public class ReactiveStreamsBodyGenerator implements FeedableBodyGenerator {
 
-  private final Publisher<ByteBuf> publisher;
-  private final FeedableBodyGenerator feedableBodyGenerator;
-  private final long contentLength;
-  private volatile FeedListener feedListener;
-
-  /**
-   * Creates a Streamable Body which takes a Content-Length.
-   * If the contentLength parameter is -1L a Http Header of Transfer-Encoding: chunked will be set.
-   * Otherwise it will set the Content-Length header to the value provided
-   *
-   * @param publisher     Body as a Publisher
-   * @param contentLength Content-Length of the Body
-   */
-  public ReactiveStreamsBodyGenerator(Publisher<ByteBuf> publisher, long contentLength) {
-    this.publisher = publisher;
-    this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-    this.contentLength = contentLength;
-  }
-
-  public Publisher<ByteBuf> getPublisher() {
-    return this.publisher;
-  }
-
-  @Override
-  public boolean feed(ByteBuf buffer, boolean isLast) throws Exception {
-    return feedableBodyGenerator.feed(buffer, isLast);
-  }
-
-  @Override
-  public void setListener(FeedListener listener) {
-    feedListener = listener;
-    feedableBodyGenerator.setListener(listener);
-  }
-
-  public long getContentLength() {
-    return contentLength;
-  }
-
-  @Override
-  public Body createBody() {
-    return new StreamedBody(feedableBodyGenerator, contentLength);
-  }
-
-  private class StreamedBody implements Body {
-    private final AtomicBoolean initialized = new AtomicBoolean(false);
-
-    private final SimpleSubscriber subscriber;
-    private final Body body;
-
+    private final Publisher<ByteBuf> publisher;
+    private final FeedableBodyGenerator feedableBodyGenerator;
+    private volatile FeedListener feedListener;
     private final long contentLength;
 
-    public StreamedBody(FeedableBodyGenerator bodyGenerator, long contentLength) {
-      this.body = bodyGenerator.createBody();
-      this.subscriber = new SimpleSubscriber(bodyGenerator);
-      this.contentLength = contentLength;
+    /**
+     *  Creates a Streamable Body which takes a Content-Length.
+     *  If the contentLength parameter is -1L a Http Header of Transfer-Encoding: chunked will be set.
+     *  Otherwise it will set the Content-Length header to the value provided
+     *
+     * @param publisher Body as a Publisher
+     * @param contentLength Content-Length of the Body
+     */
+    public ReactiveStreamsBodyGenerator(Publisher<ByteBuf> publisher, long contentLength) {
+        this.publisher = publisher;
+        this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+        this.contentLength = contentLength;
+    }
+
+    public Publisher<ByteBuf> getPublisher() {
+        return this.publisher;
     }
 
     @Override
-    public void close() throws IOException {
-      body.close();
+    public boolean feed(ByteBuf buffer, boolean isLast) throws Exception {
+        return feedableBodyGenerator.feed(buffer, isLast);
     }
 
     @Override
+    public void setListener(FeedListener listener) {
+        feedListener = listener;
+        feedableBodyGenerator.setListener(listener);
+    }
+
     public long getContentLength() {
-      return contentLength;
+        return contentLength;
     }
 
     @Override
-    public BodyState transferTo(ByteBuf target) throws IOException {
-      if (initialized.compareAndSet(false, true)) {
-        publisher.subscribe(subscriber);
-      }
-
-      return body.transferTo(target);
+    public Body createBody() {
+        return new StreamedBody(publisher, feedableBodyGenerator, contentLength);
     }
-  }
 
-  private class SimpleSubscriber implements Subscriber<ByteBuf> {
+    private class StreamedBody implements Body {
+        private final AtomicBoolean initialized = new AtomicBoolean(false);
 
-    private final Logger LOGGER = LoggerFactory.getLogger(SimpleSubscriber.class);
+        private final SimpleSubscriber subscriber;
+        private final Body body;
 
-    private final FeedableBodyGenerator feeder;
-    private volatile Subscription subscription;
+        private final long contentLength;
 
-    public SimpleSubscriber(FeedableBodyGenerator feeder) {
-      this.feeder = feeder;
-    }
+        public StreamedBody(Publisher<ByteBuf> publisher, FeedableBodyGenerator bodyGenerator, long contentLength) {
+            this.body = bodyGenerator.createBody();
+            this.subscriber = new SimpleSubscriber(bodyGenerator);
+            this.contentLength = contentLength;
+        }
 
-    @Override
-    public void onSubscribe(Subscription s) {
-      assertNotNull(s, "subscription");
-
-      // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
-      if (this.subscription != null) {
-        s.cancel(); // Cancel the additional subscription
-      } else {
-        subscription = s;
-        subscription.request(Long.MAX_VALUE);
-      }
-    }
+        @Override
+        public void close() throws IOException {
+            body.close();
+        }
 
-    @Override
-    public void onNext(ByteBuf b) {
-      assertNotNull(b, "bytebuf");
-      try {
-        feeder.feed(b, false);
-      } catch (Exception e) {
-        LOGGER.error("Exception occurred while processing element in stream.", e);
-        subscription.cancel();
-      }
-    }
+        @Override
+        public long getContentLength() {
+            return contentLength;
+        }
 
-    @Override
-    public void onError(Throwable t) {
-      assertNotNull(t, "throwable");
-      LOGGER.debug("Error occurred while consuming body stream.", t);
-      FeedListener listener = feedListener;
-      if (listener != null) {
-        listener.onError(t);
-      }
+        @Override
+        public BodyState transferTo(ByteBuf target) throws IOException {
+            if (initialized.compareAndSet(false, true)) {
+                publisher.subscribe(subscriber);
+            }
+
+            return body.transferTo(target);
+        }
     }
 
-    @Override
-    public void onComplete() {
-      try {
-        feeder.feed(Unpooled.EMPTY_BUFFER, true);
-      } catch (Exception e) {
-        LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
-        this.subscription.cancel();
-      }
+    private class SimpleSubscriber implements Subscriber<ByteBuf> {
+
+        private final Logger LOGGER = LoggerFactory.getLogger(SimpleSubscriber.class);
+
+        private final FeedableBodyGenerator feeder;
+        private volatile Subscription subscription;
+
+        public SimpleSubscriber(FeedableBodyGenerator feeder) {
+            this.feeder = feeder;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (s == null)
+                throw null;
+
+            // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
+            if (this.subscription != null) {
+                s.cancel(); // Cancel the additional subscription
+            } else {
+                subscription = s;
+                subscription.request(Long.MAX_VALUE);
+            }
+        }
+
+        @Override
+        public void onNext(ByteBuf t) {
+            if (t == null)
+                throw null;
+            try {
+                feeder.feed(t, false);
+            } catch (Exception e) {
+                LOGGER.error("Exception occurred while processing element in stream.", e);
+                subscription.cancel();
+            }
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            if (t == null)
+                throw null;
+            LOGGER.debug("Error occurred while consuming body stream.", t);
+            FeedListener listener = feedListener;
+            if (listener != null) {
+                listener.onError(t);
+            }
+        }
+
+        @Override
+        public void onComplete() {
+            try {
+                feeder.feed(Unpooled.EMPTY_BUFFER, true);
+            } catch (Exception e) {
+                LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
+                this.subscription.cancel();
+            }
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
index b74319506..d76ae9d03 100755
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
@@ -17,12 +17,12 @@
 
 public final class UnboundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<ConcurrentLinkedQueue<BodyChunk>> {
 
-  public UnboundedQueueFeedableBodyGenerator() {
-    super(new ConcurrentLinkedQueue<>());
-  }
+    public UnboundedQueueFeedableBodyGenerator() {
+        super(new ConcurrentLinkedQueue<>());
+    }
 
-  @Override
-  protected boolean offer(BodyChunk chunk) {
-    return queue.offer(chunk);
-  }
+    @Override
+    protected boolean offer(BodyChunk chunk) throws Exception {
+        return queue.offer(chunk);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
index 9a2200e42..d2f4df30e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
@@ -12,40 +12,40 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import java.nio.charset.Charset;
-
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 
+import java.nio.charset.Charset;
+
 public class ByteArrayPart extends FileLikePart {
 
-  private final byte[] bytes;
+    private final byte[] bytes;
 
-  public ByteArrayPart(String name, byte[] bytes) {
-    this(name, bytes, null);
-  }
+    public ByteArrayPart(String name, byte[] bytes) {
+        this(name, bytes, null);
+    }
 
-  public ByteArrayPart(String name, byte[] bytes, String contentType) {
-    this(name, bytes, contentType, null);
-  }
+    public ByteArrayPart(String name, byte[] bytes, String contentType) {
+        this(name, bytes, contentType, null);
+    }
 
-  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset) {
-    this(name, bytes, contentType, charset, null);
-  }
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset) {
+        this(name, bytes, contentType, charset, null);
+    }
 
-  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName) {
-    this(name, bytes, contentType, charset, fileName, null);
-  }
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName) {
+        this(name, bytes, contentType, charset, fileName, null);
+    }
 
-  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId) {
-    this(name, bytes, contentType, charset, fileName, contentId, null);
-  }
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId) {
+        this(name, bytes, contentType, charset, fileName, contentId, null);
+    }
 
-  public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
-    super(name, contentType, charset, fileName, contentId, transferEncoding);
-    this.bytes = assertNotNull(bytes, "bytes");
-  }
+    public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+        super(name, contentType, charset, fileName, contentId, transferEncoding);
+        this.bytes = assertNotNull(bytes, "bytes");
+    }
 
-  public byte[] getBytes() {
-    return bytes;
-  }
+    public byte[] getBytes() {
+        return bytes;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
index 04c1f982c..a53277978 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
@@ -12,62 +12,66 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import javax.activation.MimetypesFileTypeMap;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
 
-import static org.asynchttpclient.util.MiscUtils.withDefault;
+import javax.activation.MimetypesFileTypeMap;
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
  */
 public abstract class FileLikePart extends PartBase {
 
-  private static final MimetypesFileTypeMap MIME_TYPES_FILE_TYPE_MAP;
+    private static final MimetypesFileTypeMap MIME_TYPES_FILE_TYPE_MAP;
 
-  static {
-    try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("ahc-mime.types")) {
-      MIME_TYPES_FILE_TYPE_MAP = new MimetypesFileTypeMap(is);
-    } catch (IOException e) {
-      throw new ExceptionInInitializerError(e);
+    static {
+        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("ahc-mime.types")) {
+            MIME_TYPES_FILE_TYPE_MAP = new MimetypesFileTypeMap(is);
+        } catch (IOException e) {
+            throw new ExceptionInInitializerError(e);
+        }
     }
-  }
 
-  /**
-   * Default content encoding of file attachments.
-   */
-  private String fileName;
+    /**
+     * Default content encoding of file attachments.
+     */
+    private String fileName;
 
-  /**
-   * FilePart Constructor.
-   *
-   * @param name              the name for this part
-   * @param contentType       the content type for this part, if <code>null</code> try to figure out from the fileName mime type
-   * @param charset           the charset encoding for this part
-   * @param fileName          the fileName
-   * @param contentId         the content id
-   * @param transfertEncoding the transfer encoding
-   */
-  public FileLikePart(String name, String contentType, Charset charset, String fileName, String contentId, String transfertEncoding) {
-    super(name,
-            computeContentType(contentType, fileName),
-            charset,
-            contentId,
-            transfertEncoding);
-    this.fileName = fileName;
-  }
+    private static String computeContentType(String contentType, String fileName) {
+        return contentType != null ? contentType : MIME_TYPES_FILE_TYPE_MAP.getContentType(withDefault(fileName, ""));
+    }
 
-  private static String computeContentType(String contentType, String fileName) {
-    return contentType != null ? contentType : MIME_TYPES_FILE_TYPE_MAP.getContentType(withDefault(fileName, ""));
-  }
+    /**
+     * FilePart Constructor.
+     * 
+     * @param name the name for this part
+     * @param contentType the content type for this part, if <code>null</code> try to figure out from the fileName mime type
+     * @param charset the charset encoding for this part
+     * @param fileName the fileName
+     * @param contentId the content id
+     * @param transfertEncoding the transfer encoding
+     */
+    public FileLikePart(String name, String contentType, Charset charset, String fileName, String contentId, String transfertEncoding) {
+        super(name,//
+                computeContentType(contentType, fileName),//
+                charset,//
+                contentId,//
+                transfertEncoding);
+        this.fileName = fileName;
+    }
 
-  public String getFileName() {
-    return fileName;
-  }
+    public String getFileName() {
+        return fileName;
+    }
 
-  @Override
-  public String toString() {
-    return super.toString() + " filename=" + fileName;
-  }
+    @Override
+    public String toString() {
+        return new StringBuilder()//
+                .append(super.toString())//
+                .append(" filename=").append(fileName)//
+                .toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
index b164fbc2b..306750057 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
@@ -12,50 +12,50 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 import java.io.File;
 import java.nio.charset.Charset;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-
 public class FilePart extends FileLikePart {
 
-  private final File file;
-
-  public FilePart(String name, File file) {
-    this(name, file, null);
-  }
-
-  public FilePart(String name, File file, String contentType) {
-    this(name, file, contentType, null);
-  }
-
-  public FilePart(String name, File file, String contentType, Charset charset) {
-    this(name, file, contentType, charset, null);
-  }
-
-  public FilePart(String name, File file, String contentType, Charset charset, String fileName) {
-    this(name, file, contentType, charset, fileName, null);
-  }
-
-  public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId) {
-    this(name, file, contentType, charset, fileName, contentId, null);
-  }
-
-  public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
-    super(name,
-            contentType,
-            charset,
-            fileName != null ? fileName : file.getName(),
-            contentId,
-            transferEncoding);
-    if (!assertNotNull(file, "file").isFile())
-      throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
-    if (!file.canRead())
-      throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
-    this.file = file;
-  }
-
-  public File getFile() {
-    return file;
-  }
+    private final File file;
+
+    public FilePart(String name, File file) {
+        this(name, file, null);
+    }
+
+    public FilePart(String name, File file, String contentType) {
+        this(name, file, contentType, null);
+    }
+
+    public FilePart(String name, File file, String contentType, Charset charset) {
+        this(name, file, contentType, charset, null);
+    }
+
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName) {
+        this(name, file, contentType, charset, fileName, null);
+    }
+
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId) {
+        this(name, file, contentType, charset, fileName, contentId, null);
+    }
+
+    public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
+        super(name,//
+                contentType,//
+                charset,//
+                fileName != null ? fileName : file.getName(),//
+                contentId,//
+                transferEncoding);
+        if (!assertNotNull(file, "file").isFile())
+            throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
+        if (!file.canRead())
+            throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
+        this.file = file;
+    }
+
+    public File getFile() {
+        return file;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
new file mode 100644
index 000000000..8dcf9c777
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
@@ -0,0 +1,22 @@
+/*
+* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+*
+* This program is licensed to you under the Apache License Version 2.0,
+* and you may not use this file except in compliance with the Apache License Version 2.0.
+* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the Apache License Version 2.0 is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+*/
+package org.asynchttpclient.request.body.multipart;
+
+import java.io.IOException;
+
+/**
+ * @author Gail Hernandez
+ */
+@SuppressWarnings("serial")
+public class FileUploadStalledException extends IOException {
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
index f2d8eb959..16f590d06 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
@@ -13,122 +13,122 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.netty.request.body.BodyChunkedInput;
-import org.asynchttpclient.request.body.RandomAccessBody;
-import org.asynchttpclient.request.body.multipart.part.MultipartPart;
-import org.asynchttpclient.request.body.multipart.part.MultipartState;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.RandomAccessBody;
+import org.asynchttpclient.request.body.multipart.part.MultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MultipartState;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class MultipartBody implements RandomAccessBody {
 
-  private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
-
-  private final List<MultipartPart<? extends Part>> parts;
-  private final String contentType;
-  private final byte[] boundary;
-  private final long contentLength;
-  private int currentPartIndex;
-  private boolean done = false;
-  private AtomicBoolean closed = new AtomicBoolean();
-
-  public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
-    this.boundary = boundary;
-    this.contentType = contentType;
-    this.parts = assertNotNull(parts, "parts");
-    this.contentLength = computeContentLength();
-  }
-
-  private long computeContentLength() {
-    try {
-      long total = 0;
-      for (MultipartPart<? extends Part> part : parts) {
-        long l = part.length();
-        if (l < 0) {
-          return -1;
+    private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
+
+    private final List<MultipartPart<? extends Part>> parts;
+    private final String contentType;
+    private final byte[] boundary;
+    private final long contentLength;
+    private int currentPartIndex;
+    private boolean done = false;
+    private AtomicBoolean closed = new AtomicBoolean();
+
+    public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
+        this.boundary = boundary;
+        this.contentType = contentType;
+        this.parts = assertNotNull(parts, "parts");
+        this.contentLength = computeContentLength();
+    }
+
+    private long computeContentLength() {
+        try {
+            long total = 0;
+            for (MultipartPart<? extends Part> part : parts) {
+                long l = part.length();
+                if (l < 0) {
+                    return -1;
+                }
+                total += l;
+            }
+            return total;
+        } catch (Exception e) {
+            LOGGER.error("An exception occurred while getting the length of the parts", e);
+            return 0L;
         }
-        total += l;
-      }
-      return total;
-    } catch (Exception e) {
-      LOGGER.error("An exception occurred while getting the length of the parts", e);
-      return 0L;
     }
-  }
 
-  public void close() {
-    if (closed.compareAndSet(false, true)) {
-      for (MultipartPart<? extends Part> part : parts) {
-        closeSilently(part);
-      }
+    public void close() throws IOException {
+        if (closed.compareAndSet(false, true)) {
+            for (MultipartPart<? extends Part> part : parts) {
+                closeSilently(part);
+            }
+        }
     }
-  }
 
-  public long getContentLength() {
-    return contentLength;
-  }
+    public long getContentLength() {
+        return contentLength;
+    }
 
-  public String getContentType() {
-    return contentType;
-  }
+    public String getContentType() {
+        return contentType;
+    }
 
-  public byte[] getBoundary() {
-    return boundary;
-  }
+    public byte[] getBoundary() {
+        return boundary;
+    }
 
-  // Regular Body API
-  public BodyState transferTo(ByteBuf target) throws IOException {
+    // Regular Body API
+    public BodyState transferTo(ByteBuf target) throws IOException {
 
-    if (done)
-      return BodyState.STOP;
+        if (done)
+            return BodyState.STOP;
 
-    while (target.isWritable() && !done) {
-      MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
-      currentPart.transferTo(target);
+        while (target.isWritable() && !done) {
+            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+            currentPart.transferTo(target);
 
-      if (currentPart.getState() == MultipartState.DONE) {
-        currentPartIndex++;
-        if (currentPartIndex == parts.size()) {
-          done = true;
+            if (currentPart.getState() == MultipartState.DONE) {
+                currentPartIndex++;
+                if (currentPartIndex == parts.size()) {
+                    done = true;
+                }
+            }
         }
-      }
-    }
 
-    return BodyState.CONTINUE;
-  }
+        return BodyState.CONTINUE;
+    }
 
-  // RandomAccessBody API, suited for HTTP but not for HTTPS (zero-copy)
-  @Override
-  public long transferTo(WritableByteChannel target) throws IOException {
+    // RandomAccessBody API, suited for HTTP but not for HTTPS (zero-copy)
+    @Override
+    public long transferTo(WritableByteChannel target) throws IOException {
 
-    if (done)
-      return -1L;
+        if (done)
+            return -1L;
 
-    long transferred = 0L;
-    boolean slowTarget = false;
+        long transferred = 0L;
+        boolean slowTarget = false;
 
-    while (transferred < BodyChunkedInput.DEFAULT_CHUNK_SIZE && !done && !slowTarget) {
-      MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
-      transferred += currentPart.transferTo(target);
-      slowTarget = currentPart.isTargetSlow();
+        while (transferred < BodyChunkedInput.DEFAULT_CHUNK_SIZE && !done && !slowTarget) {
+            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+            transferred += currentPart.transferTo(target);
+            slowTarget = currentPart.isTargetSlow();
 
-      if (currentPart.getState() == MultipartState.DONE) {
-        currentPartIndex++;
-        if (currentPartIndex == parts.size()) {
-          done = true;
+            if (currentPart.getState() == MultipartState.DONE) {
+                currentPartIndex++;
+                if (currentPartIndex == parts.size()) {
+                    done = true;
+                }
+            }
         }
-      }
-    }
 
-    return transferred;
-  }
+        return transferred;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index 505d07e6b..de3f30b8e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -13,98 +13,102 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.request.body.multipart.part.*;
-import org.asynchttpclient.util.StringBuilderPool;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ThreadLocalRandom;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.request.body.multipart.part.ByteArrayMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.FileMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MessageEndMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MultipartPart;
+import org.asynchttpclient.request.body.multipart.part.StringMultipartPart;
+import org.asynchttpclient.util.StringBuilderPool;
 
 public class MultipartUtils {
 
-  /**
-   * The pool of ASCII chars to be used for generating a multipart boundary.
-   */
-  private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(US_ASCII);
-
-  /**
-   * Creates a new multipart entity containing the given parts.
-   *
-   * @param parts          the parts to include.
-   * @param requestHeaders the request headers
-   * @return a MultipartBody
-   */
-  public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders requestHeaders) {
-    assertNotNull(parts, "parts");
-
-    byte[] boundary;
-    String contentType;
-
-    String contentTypeHeader = requestHeaders.get(CONTENT_TYPE);
-    if (isNonEmpty(contentTypeHeader)) {
-      int boundaryLocation = contentTypeHeader.indexOf("boundary=");
-      if (boundaryLocation != -1) {
-        // boundary defined in existing Content-Type
-        contentType = contentTypeHeader;
-        boundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim()).getBytes(US_ASCII);
-      } else {
-        // generate boundary and append it to existing Content-Type
-        boundary = generateBoundary();
-        contentType = computeContentType(contentTypeHeader, boundary);
-      }
-    } else {
-      boundary = generateBoundary();
-      contentType = computeContentType(HttpHeaderValues.MULTIPART_FORM_DATA, boundary);
+    /**
+     * The pool of ASCII chars to be used for generating a multipart boundary.
+     */
+    private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(US_ASCII);
+
+    /**
+     * Creates a new multipart entity containing the given parts.
+     * 
+     * @param parts the parts to include.
+     * @param requestHeaders the request headers
+     * @return a MultipartBody
+     */
+    public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders requestHeaders) {
+        assertNotNull(parts, "parts");
+
+        byte[] boundary;
+        String contentType;
+
+        String contentTypeHeader = requestHeaders.get(CONTENT_TYPE);
+        if (isNonEmpty(contentTypeHeader)) {
+            int boundaryLocation = contentTypeHeader.indexOf("boundary=");
+            if (boundaryLocation != -1) {
+                // boundary defined in existing Content-Type
+                contentType = contentTypeHeader;
+                boundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim()).getBytes(US_ASCII);
+            } else {
+                // generate boundary and append it to existing Content-Type
+                boundary = generateBoundary();
+                contentType = computeContentType(contentTypeHeader, boundary);
+            }
+        } else {
+            boundary = generateBoundary();
+            contentType = computeContentType(HttpHeaderValues.MULTIPART_FORM_DATA, boundary);
+        }
+
+        List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
+
+        return new MultipartBody(multipartParts, contentType, boundary);
     }
 
-    List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
+    public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
+        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
+        for (Part part : parts) {
+            if (part instanceof FilePart) {
+                multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
 
-    return new MultipartBody(multipartParts, contentType, boundary);
-  }
+            } else if (part instanceof ByteArrayPart) {
+                multipartParts.add(new ByteArrayMultipartPart((ByteArrayPart) part, boundary));
 
-  public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
-    List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
-    for (Part part : parts) {
-      if (part instanceof FilePart) {
-        multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
+            } else if (part instanceof StringPart) {
+                multipartParts.add(new StringMultipartPart((StringPart) part, boundary));
 
-      } else if (part instanceof ByteArrayPart) {
-        multipartParts.add(new ByteArrayMultipartPart((ByteArrayPart) part, boundary));
+            } else {
+                throw new IllegalArgumentException("Unknown part type: " + part);
+            }
+        }
+        // add an extra fake part for terminating the message
+        multipartParts.add(new MessageEndMultipartPart(boundary));
 
-      } else if (part instanceof StringPart) {
-        multipartParts.add(new StringMultipartPart((StringPart) part, boundary));
+        return multipartParts;
+    }
 
-      } else {
-        throw new IllegalArgumentException("Unknown part type: " + part);
-      }
+    // a random size from 30 to 40
+    private static byte[] generateBoundary() {
+        ThreadLocalRandom random = ThreadLocalRandom.current();
+        byte[] bytes = new byte[random.nextInt(11) + 30];
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = MULTIPART_CHARS[random.nextInt(MULTIPART_CHARS.length)];
+        }
+        return bytes;
     }
-    // add an extra fake part for terminating the message
-    multipartParts.add(new MessageEndMultipartPart(boundary));
-
-    return multipartParts;
-  }
-
-  // a random size from 30 to 40
-  private static byte[] generateBoundary() {
-    ThreadLocalRandom random = ThreadLocalRandom.current();
-    byte[] bytes = new byte[random.nextInt(11) + 30];
-    for (int i = 0; i < bytes.length; i++) {
-      bytes[i] = MULTIPART_CHARS[random.nextInt(MULTIPART_CHARS.length)];
+
+    private static String computeContentType(CharSequence base, byte[] boundary) {
+        StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder().append(base);
+        if (base.length() != 0 && base.charAt(base.length() - 1) != ';')
+            buffer.append(';');
+        return buffer.append(" boundary=").append(new String(boundary, US_ASCII)).toString();
     }
-    return bytes;
-  }
-
-  private static String computeContentType(CharSequence base, byte[] boundary) {
-    StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder().append(base);
-    if (base.length() != 0 && base.charAt(base.length() - 1) != ';')
-      buffer.append(';');
-    return buffer.append(" boundary=").append(new String(boundary, US_ASCII)).toString();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
index 470ce6942..cb84fce34 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
@@ -12,70 +12,110 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import org.asynchttpclient.Param;
+import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import java.nio.charset.Charset;
 import java.util.List;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
+import org.asynchttpclient.Param;
 
 public interface Part {
 
-  /**
-   * Carriage return/linefeed as a byte array
-   */
-  byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
-
-  /**
-   * Extra characters as a byte array
-   */
-  byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
-
-  /**
-   * Return the name of this part.
-   *
-   * @return The name.
-   */
-  String getName();
-
-  /**
-   * Returns the content type of this part.
-   *
-   * @return the content type, or <code>null</code> to exclude the content
-   * type header
-   */
-  String getContentType();
-
-  /**
-   * Return the character encoding of this part.
-   *
-   * @return the character encoding, or <code>null</code> to exclude the
-   * character encoding header
-   */
-  Charset getCharset();
-
-  /**
-   * Return the transfer encoding of this part.
-   *
-   * @return the transfer encoding, or <code>null</code> to exclude the
-   * transfer encoding header
-   */
-  String getTransferEncoding();
-
-  /**
-   * Return the content ID of this part.
-   *
-   * @return the content ID, or <code>null</code> to exclude the content ID
-   * header
-   */
-  String getContentId();
-
-  /**
-   * Gets the disposition-type to be used in Content-Disposition header
-   *
-   * @return the disposition-type
-   */
-  String getDispositionType();
-
-  List<Param> getCustomHeaders();
+    /**
+     * Carriage return/linefeed as a byte array
+     */
+    byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
+
+    /**
+     * Content dispostion as a byte
+     */
+    byte QUOTE_BYTE = '\"';
+
+    /**
+     * Extra characters as a byte array
+     */
+    byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
+
+    /**
+     * Content dispostion as a byte array
+     */
+    byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
+
+    /**
+     * form-data as a byte array
+     */
+    byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
+
+    /**
+     * name as a byte array
+     */
+    byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
+
+    /**
+     * Content charset as a byte array
+     */
+    byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
+
+    /**
+     * Return the name of this part.
+     * 
+     * @return The name.
+     */
+    String getName();
+
+    /**
+     * Returns the content type of this part.
+     * 
+     * @return the content type, or <code>null</code> to exclude the content
+     *         type header
+     */
+    String getContentType();
+
+    /**
+     * Return the character encoding of this part.
+     * 
+     * @return the character encoding, or <code>null</code> to exclude the
+     *         character encoding header
+     */
+    Charset getCharset();
+
+    /**
+     * Return the transfer encoding of this part.
+     * 
+     * @return the transfer encoding, or <code>null</code> to exclude the
+     *         transfer encoding header
+     */
+    String getTransferEncoding();
+
+    /**
+     * Return the content ID of this part.
+     * 
+     * @return the content ID, or <code>null</code> to exclude the content ID
+     *         header
+     */
+    String getContentId();
+
+    /**
+     * Gets the disposition-type to be used in Content-Disposition header
+     * 
+     * @return the disposition-type
+     */
+    String getDispositionType();
+
+    List<Param> getCustomHeaders();
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index 950f3987e..ba487476c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -12,123 +12,125 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import org.asynchttpclient.Param;
-
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.asynchttpclient.Param;
+
 public abstract class PartBase implements Part {
 
-  /**
-   * The name of the form field, part of the Content-Disposition header
-   */
-  private final String name;
-
-  /**
-   * The main part of the Content-Type header
-   */
-  private final String contentType;
-
-  /**
-   * The charset (part of Content-Type header)
-   */
-  private final Charset charset;
-
-  /**
-   * The Content-Transfer-Encoding header value.
-   */
-  private final String transferEncoding;
-
-  /**
-   * The Content-Id
-   */
-  private final String contentId;
-
-  /**
-   * The disposition type (part of Content-Disposition)
-   */
-  private String dispositionType;
-
-  /**
-   * Additional part headers
-   */
-  private List<Param> customHeaders;
-
-  /**
-   * Constructor.
-   *
-   * @param name             The name of the part, or <code>null</code>
-   * @param contentType      The content type, or <code>null</code>
-   * @param charset          The character encoding, or <code>null</code>
-   * @param contentId        The content id, or <code>null</code>
-   * @param transferEncoding The transfer encoding, or <code>null</code>
-   */
-  public PartBase(String name, String contentType, Charset charset, String contentId, String transferEncoding) {
-    this.name = name;
-    this.contentType = contentType;
-    this.charset = charset;
-    this.contentId = contentId;
-    this.transferEncoding = transferEncoding;
-  }
-
-  @Override
-  public String getName() {
-    return this.name;
-  }
-
-  @Override
-  public String getContentType() {
-    return this.contentType;
-  }
-
-  @Override
-  public Charset getCharset() {
-    return this.charset;
-  }
-
-  @Override
-  public String getTransferEncoding() {
-    return transferEncoding;
-  }
-
-  @Override
-  public String getContentId() {
-    return contentId;
-  }
-
-  @Override
-  public String getDispositionType() {
-    return dispositionType;
-  }
-
-  public void setDispositionType(String dispositionType) {
-    this.dispositionType = dispositionType;
-  }
-
-  @Override
-  public List<Param> getCustomHeaders() {
-    return customHeaders;
-  }
-
-  public void setCustomHeaders(List<Param> customHeaders) {
-    this.customHeaders = customHeaders;
-  }
-
-  public void addCustomHeader(String name, String value) {
-    if (customHeaders == null) {
-      customHeaders = new ArrayList<>(2);
+    /**
+     * The name of the form field, part of the Content-Disposition header
+     */
+    private final String name;
+
+    /**
+     * The main part of the Content-Type header
+     */
+    private final String contentType;
+
+    /**
+     * The charset (part of Content-Type header)
+     */
+    private final Charset charset;
+
+    /**
+     * The Content-Transfer-Encoding header value.
+     */
+    private final String transferEncoding;
+
+    /**
+     * The Content-Id
+     */
+    private final String contentId;
+
+    /**
+     * The disposition type (part of Content-Disposition)
+     */
+    private String dispositionType;
+
+    /**
+     * Additional part headers
+     */
+    private List<Param> customHeaders;
+
+    /**
+     * Constructor.
+     * 
+     * @param name The name of the part, or <code>null</code>
+     * @param contentType The content type, or <code>null</code>
+     * @param charset The character encoding, or <code>null</code>
+     * @param contentId The content id, or <code>null</code>
+     * @param transferEncoding The transfer encoding, or <code>null</code>
+     */
+    public PartBase(String name, String contentType, Charset charset, String contentId, String transferEncoding) {
+        this.name = name;
+        this.contentType = contentType;
+        this.charset = charset;
+        this.contentId = contentId;
+        this.transferEncoding = transferEncoding;
+    }
+
+    @Override
+    public String getName() {
+        return this.name;
+    }
+
+    @Override
+    public String getContentType() {
+        return this.contentType;
+    }
+
+    @Override
+    public Charset getCharset() {
+        return this.charset;
+    }
+
+    @Override
+    public String getTransferEncoding() {
+        return transferEncoding;
+    }
+
+    @Override
+    public String getContentId() {
+        return contentId;
+    }
+
+    @Override
+    public String getDispositionType() {
+        return dispositionType;
+    }
+
+    @Override
+    public List<Param> getCustomHeaders() {
+        return customHeaders;
+    }
+
+    public void setDispositionType(String dispositionType) {
+        this.dispositionType = dispositionType;
+    }
+
+    public void addCustomHeader(String name, String value) {
+        if (customHeaders == null) {
+            customHeaders = new ArrayList<>(2);
+        }
+        customHeaders.add(new Param(name, value));
+    }
+
+    public void setCustomHeaders(List<Param> customHeaders) {
+        this.customHeaders = customHeaders;
+    }
+
+    public String toString() {
+        return new StringBuilder()//
+                .append(getClass().getSimpleName())//
+                .append(" name=").append(getName())//
+                .append(" contentType=").append(getContentType())//
+                .append(" charset=").append(getCharset())//
+                .append(" tranferEncoding=").append(getTransferEncoding())//
+                .append(" contentId=").append(getContentId())//
+                .append(" dispositionType=").append(getDispositionType())//
+                .toString();
     }
-    customHeaders.add(new Param(name, value));
-  }
-
-  public String toString() {
-    return getClass().getSimpleName() +
-            " name=" + getName() +
-            " contentType=" + getContentType() +
-            " charset=" + getCharset() +
-            " tranferEncoding=" + getTransferEncoding() +
-            " contentId=" + getContentId() +
-            " dispositionType=" + getDispositionType();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
index 6d2e078cb..5420000ab 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
@@ -12,56 +12,56 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import java.nio.charset.Charset;
-
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.MiscUtils.withDefault;
 
+import java.nio.charset.Charset;
+
 public class StringPart extends PartBase {
 
-  /**
-   * Default charset of string parameters
-   */
-  private static final Charset DEFAULT_CHARSET = UTF_8;
+    /**
+     * Default charset of string parameters
+     */
+    public static final Charset DEFAULT_CHARSET = UTF_8;
 
-  /**
-   * Contents of this StringPart.
-   */
-  private final String value;
+    /**
+     * Contents of this StringPart.
+     */
+    private final String value;
 
-  public StringPart(String name, String value) {
-    this(name, value, null);
-  }
+    private static Charset charsetOrDefault(Charset charset) {
+        return withDefault(charset, DEFAULT_CHARSET);
+    }
 
-  public StringPart(String name, String value, String contentType) {
-    this(name, value, contentType, null);
-  }
+    public StringPart(String name, String value) {
+        this(name, value, null);
+    }
 
-  public StringPart(String name, String value, String contentType, Charset charset) {
-    this(name, value, contentType, charset, null);
-  }
+    public StringPart(String name, String value, String contentType) {
+        this(name, value, contentType, null);
+    }
 
-  public StringPart(String name, String value, String contentType, Charset charset, String contentId) {
-    this(name, value, contentType, charset, contentId, null);
-  }
+    public StringPart(String name, String value, String contentType, Charset charset) {
+        this(name, value, contentType, charset, null);
+    }
 
-  public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
-    super(name, contentType, charsetOrDefault(charset), contentId, transferEncoding);
-    assertNotNull(value, "value");
+    public StringPart(String name, String value, String contentType, Charset charset, String contentId) {
+        this(name, value, contentType, charset, contentId, null);
+    }
 
-    if (value.indexOf(0) != -1)
-      // See RFC 2048, 2.8. "8bit Data"
-      throw new IllegalArgumentException("NULs may not be present in string parts");
+    public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
+        super(name, contentType, charsetOrDefault(charset), contentId, transferEncoding);
+        assertNotNull(value, "value");
 
-    this.value = value;
-  }
+        if (value.indexOf(0) != -1)
+            // See RFC 2048, 2.8. "8bit Data"
+            throw new IllegalArgumentException("NULs may not be present in string parts");
 
-  private static Charset charsetOrDefault(Charset charset) {
-    return withDefault(charset, DEFAULT_CHARSET);
-  }
+        this.value = value;
+    }
 
-  public String getValue() {
-    return value;
-  }
+    public String getValue() {
+        return value;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
index d54560107..4d44ee78c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
@@ -15,38 +15,39 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.request.body.multipart.ByteArrayPart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+
 public class ByteArrayMultipartPart extends FileLikeMultipartPart<ByteArrayPart> {
 
-  private final ByteBuf contentBuffer;
-
-  public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
-    super(part, boundary);
-    contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
-  }
-
-  @Override
-  protected long getContentLength() {
-    return part.getBytes().length;
-  }
-
-  @Override
-  protected long transferContentTo(ByteBuf target) {
-    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-  }
-
-  @Override
-  protected long transferContentTo(WritableByteChannel target) throws IOException {
-    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-  }
-
-  @Override
-  public void close() {
-    super.close();
-    contentBuffer.release();
-  }
+    private final ByteBuf contentBuffer;
+
+    public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
+        super(part, boundary);
+        contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
+    }
+
+    @Override
+    protected long getContentLength() {
+        return part.getBytes().length;
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        contentBuffer.release();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
index e3023cc62..c564a7259 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileLikeMultipartPart.java
@@ -1,27 +1,27 @@
 package org.asynchttpclient.request.body.multipart.part;
 
-import org.asynchttpclient.request.body.multipart.FileLikePart;
-
 import static java.nio.charset.StandardCharsets.*;
 
-public abstract class FileLikeMultipartPart<T extends FileLikePart> extends MultipartPart<T> {
-
-  /**
-   * Attachment's file name as a byte array
-   */
-  private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
+import org.asynchttpclient.request.body.multipart.FileLikePart;
 
-  FileLikeMultipartPart(T part, byte[] boundary) {
-    super(part, boundary);
-  }
+public abstract class FileLikeMultipartPart<T extends FileLikePart> extends MultipartPart<T> {
 
-  protected void visitDispositionHeader(PartVisitor visitor) {
-    super.visitDispositionHeader(visitor);
-    if (part.getFileName() != null) {
-      visitor.withBytes(FILE_NAME_BYTES);
-      visitor.withByte(QUOTE_BYTE);
-      visitor.withBytes(part.getFileName().getBytes(part.getCharset() != null ? part.getCharset() : UTF_8));
-      visitor.withByte(QUOTE_BYTE);
+    /**
+     * Attachment's file name as a byte array
+     */
+    private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
+    
+    public FileLikeMultipartPart(T part, byte[] boundary) {
+        super(part, boundary);
+    }
+    
+    protected void visitDispositionHeader(PartVisitor visitor) {
+        super.visitDispositionHeader(visitor);
+        if (part.getFileName() != null) {
+            visitor.withBytes(FILE_NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(part.getFileName().getBytes(part.getCharset() != null ? part.getCharset() : UTF_8));
+            visitor.withByte(QUOTE_BYTE);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
index 34e4f3c8d..70ebc4185 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
@@ -13,84 +13,68 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.buffer.ByteBuf;
-import org.asynchttpclient.netty.request.body.BodyChunkedInput;
-import org.asynchttpclient.request.body.multipart.FilePart;
 
-import java.io.*;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
 import java.nio.channels.WritableByteChannel;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.multipart.FilePart;
 
 public class FileMultipartPart extends FileLikeMultipartPart<FilePart> {
 
-  private final long length;
-  private FileChannel channel;
-  private long position = 0L;
+    private final FileChannel channel;
+    private final long length;
+    private long position = 0L;
 
-  public FileMultipartPart(FilePart part, byte[] boundary) {
-    super(part, boundary);
-    File file = part.getFile();
-    if (!file.exists()) {
-      throw new IllegalArgumentException("File part doesn't exist: " + file.getAbsolutePath());
-    } else if (!file.canRead()) {
-      throw new IllegalArgumentException("File part can't be read: " + file.getAbsolutePath());
+    public FileMultipartPart(FilePart part, byte[] boundary) {
+        super(part, boundary);
+        try {
+            channel = new RandomAccessFile(part.getFile(), "r").getChannel();
+        } catch (FileNotFoundException e) {
+            throw new IllegalArgumentException("File part doesn't exist: " + part.getFile().getAbsolutePath(), e);
+        }
+        length = part.getFile().length();
     }
-    length = file.length();
-  }
 
-  private FileChannel getChannel() throws IOException {
-    if (channel == null) {
-      channel = new RandomAccessFile(part.getFile(), "r").getChannel();
+    @Override
+    protected long getContentLength() {
+        return part.getFile().length();
     }
-    return channel;
-  }
-
-  @Override
-  protected long getContentLength() {
-    return part.getFile().length();
-  }
 
-  @Override
-  protected long transferContentTo(ByteBuf target) throws IOException {
-    // can return -1 if file is empty or FileChannel was closed
-    int transferred = target.writeBytes(getChannel(), target.writableBytes());
-    if (transferred > 0) {
-      position += transferred;
-    }
-    if (position == length || transferred < 0) {
-      state = MultipartState.POST_CONTENT;
-      if (channel.isOpen()) {
-        channel.close();
-      }
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        int transferred = target.writeBytes(channel, target.writableBytes());
+        position += transferred;
+        if (position == length) {
+            state = MultipartState.POST_CONTENT;
+            channel.close();
+        }
+        return transferred;
     }
-    return transferred;
-  }
 
-  @Override
-  protected long transferContentTo(WritableByteChannel target) throws IOException {
-    // WARN: don't use channel.position(), it's always 0 here
-    // from FileChannel javadoc: "This method does not modify this channel's
-    // position."
-    long transferred = getChannel().transferTo(position, BodyChunkedInput.DEFAULT_CHUNK_SIZE, target);
-    if (transferred > 0) {
-      position += transferred;
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        // WARN: don't use channel.position(), it's always 0 here
+        // from FileChannel javadoc: "This method does not modify this channel's position."
+        long transferred = channel.transferTo(position, BodyChunkedInput.DEFAULT_CHUNK_SIZE, target);
+        position += transferred;
+        if (position == length) {
+            state = MultipartState.POST_CONTENT;
+            channel.close();
+        } else {
+            slowTarget = true;
+        }
+        return transferred;
     }
-    if (position == length || transferred < 0) {
-      state = MultipartState.POST_CONTENT;
-      if (channel.isOpen()) {
-        channel.close();
-      }
-    } else {
-      slowTarget = true;
-    }
-    return transferred;
-  }
 
-  @Override
-  public void close() {
-    super.close();
-    closeSilently(channel);
-  }
+    @Override
+    public void close() {
+        super.close();
+        closeSilently(channel);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
index 78d78f4bd..6c3b20133 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
@@ -13,85 +13,84 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
+import static org.asynchttpclient.request.body.multipart.Part.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.request.body.multipart.FileLikePart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
-import static org.asynchttpclient.request.body.multipart.Part.CRLF_BYTES;
-import static org.asynchttpclient.request.body.multipart.Part.EXTRA_BYTES;
+import org.asynchttpclient.request.body.multipart.FileLikePart;
 
 public class MessageEndMultipartPart extends MultipartPart<FileLikePart> {
 
-  // lazy
-  private ByteBuf contentBuffer;
-
-  public MessageEndMultipartPart(byte[] boundary) {
-    super(null, boundary);
-    state = MultipartState.PRE_CONTENT;
-  }
-
-  @Override
-  public long transferTo(ByteBuf target) {
-    return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
-  }
-
-  @Override
-  public long transferTo(WritableByteChannel target) throws IOException {
-    slowTarget = false;
-    return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
-  }
-
-  private ByteBuf lazyLoadContentBuffer() {
-    if (contentBuffer == null) {
-      contentBuffer = ByteBufAllocator.DEFAULT.buffer((int) getContentLength());
-      contentBuffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
+    // lazy
+    private ByteBuf contentBuffer;
+
+    public MessageEndMultipartPart(byte[] boundary) {
+        super(null, boundary);
+        state = MultipartState.PRE_CONTENT;
+    }
+
+    @Override
+    public long transferTo(ByteBuf target) throws IOException {
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
+    }
+
+    @Override
+    public long transferTo(WritableByteChannel target) throws IOException {
+        slowTarget = false;
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
+    }
+
+    private ByteBuf lazyLoadContentBuffer() {
+        if (contentBuffer == null) {
+            contentBuffer = ByteBufAllocator.DEFAULT.buffer((int) getContentLength());
+            contentBuffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
+        }
+        return contentBuffer;
+    }
+
+    @Override
+    protected int computePreContentLength() {
+        return 0;
+    }
+
+    @Override
+    protected ByteBuf computePreContentBytes(int preContentLength) {
+        return Unpooled.EMPTY_BUFFER;
+    }
+
+    @Override
+    protected int computePostContentLength() {
+        return 0;
+    }
+
+    @Override
+    protected ByteBuf computePostContentBytes(int postContentLength) {
+        return Unpooled.EMPTY_BUFFER;
+    }
+
+    @Override
+    protected long getContentLength() {
+        return EXTRA_BYTES.length + boundary.length + EXTRA_BYTES.length + CRLF_BYTES.length;
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        throw new UnsupportedOperationException("Not supposed to be called");
+    }
+
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        throw new UnsupportedOperationException("Not supposed to be called");
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        if (contentBuffer != null)
+            contentBuffer.release();
     }
-    return contentBuffer;
-  }
-
-  @Override
-  protected int computePreContentLength() {
-    return 0;
-  }
-
-  @Override
-  protected ByteBuf computePreContentBytes(int preContentLength) {
-    return Unpooled.EMPTY_BUFFER;
-  }
-
-  @Override
-  protected int computePostContentLength() {
-    return 0;
-  }
-
-  @Override
-  protected ByteBuf computePostContentBytes(int postContentLength) {
-    return Unpooled.EMPTY_BUFFER;
-  }
-
-  @Override
-  protected long getContentLength() {
-    return EXTRA_BYTES.length + boundary.length + EXTRA_BYTES.length + CRLF_BYTES.length;
-  }
-
-  @Override
-  protected long transferContentTo(ByteBuf target) {
-    throw new UnsupportedOperationException("Not supposed to be called");
-  }
-
-  @Override
-  protected long transferContentTo(WritableByteChannel target) {
-    throw new UnsupportedOperationException("Not supposed to be called");
-  }
-
-  @Override
-  public void close() {
-    super.close();
-    if (contentBuffer != null)
-      contentBuffer.release();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
index 43f86efef..8f9d61081 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -13,12 +13,10 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.request.body.multipart.PartBase;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.ByteBufVisitor;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -27,307 +25,311 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.request.body.multipart.PartBase;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.ByteBufVisitor;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
 
 public abstract class MultipartPart<T extends PartBase> implements Closeable {
 
-  /**
-   * Content disposition as a byte
-   */
-  static final byte QUOTE_BYTE = '\"';
-  /**
-   * Carriage return/linefeed as a byte array
-   */
-  private static final byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
-  /**
-   * Extra characters as a byte array
-   */
-  private static final byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
-
-  /**
-   * Content disposition as a byte array
-   */
-  private static final byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
-
-  /**
-   * form-data as a byte array
-   */
-  private static final byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
-
-  /**
-   * name as a byte array
-   */
-  private static final byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
-
-  /**
-   * Content type header as a byte array
-   */
-  private static final byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
-
-  /**
-   * Content charset as a byte array
-   */
-  private static final byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
-
-  /**
-   * Content type header as a byte array
-   */
-  private static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
-
-  /**
-   * Content type header as a byte array
-   */
-  private static final byte[] HEADER_NAME_VALUE_SEPARATOR_BYTES = ": ".getBytes(US_ASCII);
-
-  /**
-   * Content type header as a byte array
-   */
-  private static final byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
-
-  protected final T part;
-  protected final byte[] boundary;
-
-  private final int preContentLength;
-  private final int postContentLength;
-  protected MultipartState state;
-  boolean slowTarget;
-
-  // lazy
-  private ByteBuf preContentBuffer;
-  private ByteBuf postContentBuffer;
-
-  MultipartPart(T part, byte[] boundary) {
-    this.part = part;
-    this.boundary = boundary;
-    preContentLength = computePreContentLength();
-    postContentLength = computePostContentLength();
-    state = MultipartState.PRE_CONTENT;
-  }
-
-  public long length() {
-    return preContentLength + postContentLength + getContentLength();
-  }
-
-  public MultipartState getState() {
-    return state;
-  }
-
-  public boolean isTargetSlow() {
-    return slowTarget;
-  }
-
-  public long transferTo(ByteBuf target) throws IOException {
-
-    switch (state) {
-      case DONE:
-        return 0L;
-
-      case PRE_CONTENT:
-        return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
-
-      case CONTENT:
-        return transferContentTo(target);
-
-      case POST_CONTENT:
-        return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
-
-      default:
-        throw new IllegalStateException("Unknown state " + state);
+    /**
+     * Carriage return/linefeed as a byte array
+     */
+    private static final byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
+
+    /**
+     * Content disposition as a byte
+     */
+    protected static final byte QUOTE_BYTE = '\"';
+
+    /**
+     * Extra characters as a byte array
+     */
+    private static final byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
+
+    /**
+     * Content disposition as a byte array
+     */
+    private static final byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
+
+    /**
+     * form-data as a byte array
+     */
+    private static final byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
+
+    /**
+     * name as a byte array
+     */
+    private static final byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
+
+    /**
+     * Content charset as a byte array
+     */
+    private static final byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
+    
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] HEADER_NAME_VALUE_SEPARATOR_BYTES = ": ".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
+
+    protected final T part;
+    protected final byte[] boundary;
+
+    private final int preContentLength;
+    private final int postContentLength;
+    protected MultipartState state;
+    protected boolean slowTarget;
+
+    // lazy
+    private ByteBuf preContentBuffer;
+    private ByteBuf postContentBuffer;
+
+    public MultipartPart(T part, byte[] boundary) {
+        this.part = part;
+        this.boundary = boundary;
+        preContentLength = computePreContentLength();
+        postContentLength = computePostContentLength();
+        state = MultipartState.PRE_CONTENT;
+    }
+
+    public long length() {
+        return preContentLength + postContentLength + getContentLength();
+    }
+
+    public MultipartState getState() {
+        return state;
+    }
+
+    public boolean isTargetSlow() {
+        return slowTarget;
     }
-  }
 
-  public long transferTo(WritableByteChannel target) throws IOException {
-    slowTarget = false;
+    public long transferTo(ByteBuf target) throws IOException {
 
-    switch (state) {
-      case DONE:
-        return 0L;
+        switch (state) {
+        case DONE:
+            return 0L;
 
-      case PRE_CONTENT:
-        return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
+        case PRE_CONTENT:
+            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
 
-      case CONTENT:
-        return transferContentTo(target);
+        case CONTENT:
+            return transferContentTo(target);
 
-      case POST_CONTENT:
-        return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
+        case POST_CONTENT:
+            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
 
-      default:
-        throw new IllegalStateException("Unknown state " + state);
+        default:
+            throw new IllegalStateException("Unknown state " + state);
+        }
     }
-  }
-
-  private ByteBuf lazyLoadPreContentBuffer() {
-    if (preContentBuffer == null)
-      preContentBuffer = computePreContentBytes(preContentLength);
-    return preContentBuffer;
-  }
-
-  private ByteBuf lazyLoadPostContentBuffer() {
-    if (postContentBuffer == null)
-      postContentBuffer = computePostContentBytes(postContentLength);
-    return postContentBuffer;
-  }
-
-  @Override
-  public void close() {
-    if (preContentBuffer != null)
-      preContentBuffer.release();
-    if (postContentBuffer != null)
-      postContentBuffer.release();
-  }
-
-  protected abstract long getContentLength();
-
-  protected abstract long transferContentTo(ByteBuf target) throws IOException;
-
-  protected abstract long transferContentTo(WritableByteChannel target) throws IOException;
-
-  protected long transfer(ByteBuf source, ByteBuf target, MultipartState sourceFullyWrittenState) {
-
-    int sourceRemaining = source.readableBytes();
-    int targetRemaining = target.writableBytes();
-
-    if (sourceRemaining <= targetRemaining) {
-      target.writeBytes(source);
-      state = sourceFullyWrittenState;
-      return sourceRemaining;
-    } else {
-      target.writeBytes(source, targetRemaining);
-      return targetRemaining;
+
+    public long transferTo(WritableByteChannel target) throws IOException {
+        slowTarget = false;
+
+        switch (state) {
+        case DONE:
+            return 0L;
+
+        case PRE_CONTENT:
+            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
+
+        case CONTENT:
+            return transferContentTo(target);
+
+        case POST_CONTENT:
+            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
+
+        default:
+            throw new IllegalStateException("Unknown state " + state);
+        }
     }
-  }
-
-  protected long transfer(ByteBuf source, WritableByteChannel target, MultipartState sourceFullyWrittenState) throws IOException {
-
-    int transferred = 0;
-    if (target instanceof GatheringByteChannel) {
-      transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
-    } else {
-      for (ByteBuffer byteBuffer : source.nioBuffers()) {
-        int len = byteBuffer.remaining();
-        int written = target.write(byteBuffer);
-        transferred += written;
-        if (written != len) {
-          // couldn't write full buffer, exit loop
-          break;
+
+    private ByteBuf lazyLoadPreContentBuffer() {
+        if (preContentBuffer == null)
+            preContentBuffer = computePreContentBytes(preContentLength);
+        return preContentBuffer;
+    }
+
+    private ByteBuf lazyLoadPostContentBuffer() {
+        if (postContentBuffer == null)
+            postContentBuffer = computePostContentBytes(postContentLength);
+        return postContentBuffer;
+    }
+
+    @Override
+    public void close() {
+        if (preContentBuffer != null)
+            preContentBuffer.release();
+        if (postContentBuffer != null)
+            postContentBuffer.release();
+    }
+
+    protected abstract long getContentLength();
+
+    protected abstract long transferContentTo(ByteBuf target) throws IOException;
+
+    protected abstract long transferContentTo(WritableByteChannel target) throws IOException;
+
+    protected long transfer(ByteBuf source, ByteBuf target, MultipartState sourceFullyWrittenState) {
+
+        int sourceRemaining = source.readableBytes();
+        int targetRemaining = target.writableBytes();
+
+        if (sourceRemaining <= targetRemaining) {
+            target.writeBytes(source);
+            state = sourceFullyWrittenState;
+            return sourceRemaining;
+        } else {
+            target.writeBytes(source, targetRemaining);
+            return targetRemaining;
+        }
+    }
+
+    protected long transfer(ByteBuf source, WritableByteChannel target, MultipartState sourceFullyWrittenState) throws IOException {
+
+        int transferred = 0;
+        if (target instanceof GatheringByteChannel) {
+            transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
+        } else {
+            for (ByteBuffer byteBuffer : source.nioBuffers()) {
+                int len = byteBuffer.remaining();
+                int written = target.write(byteBuffer);
+                transferred += written;
+                if (written != len) {
+                    // couldn't write full buffer, exit loop
+                    break;
+                }
+            }
+            // assume this is a basic single ByteBuf
+            source.readerIndex(source.readerIndex() + transferred);
+        }
+
+        if (source.isReadable()) {
+            slowTarget = true;
+        } else {
+            state = sourceFullyWrittenState;
+        }
+        return transferred;
+    }
+
+    protected int computePreContentLength() {
+        CounterPartVisitor counterVisitor = new CounterPartVisitor();
+        visitPreContent(counterVisitor);
+        return counterVisitor.getCount();
+    }
+
+    protected ByteBuf computePreContentBytes(int preContentLength) {
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(preContentLength);
+        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+        visitPreContent(bytesVisitor);
+        return buffer;
+    }
+
+    protected int computePostContentLength() {
+        CounterPartVisitor counterVisitor = new CounterPartVisitor();
+        visitPostContent(counterVisitor);
+        return counterVisitor.getCount();
+    }
+
+    protected ByteBuf computePostContentBytes(int postContentLength) {
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(postContentLength);
+        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+        visitPostContent(bytesVisitor);
+        return buffer;
+    }
+
+    protected void visitStart(PartVisitor visitor) {
+        visitor.withBytes(EXTRA_BYTES);
+        visitor.withBytes(boundary);
+    }
+
+    protected void visitDispositionHeader(PartVisitor visitor) {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CONTENT_DISPOSITION_BYTES);
+        visitor.withBytes(part.getDispositionType() != null ? part.getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
+        if (part.getName() != null) {
+            visitor.withBytes(NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(part.getName().getBytes(US_ASCII));
+            visitor.withByte(QUOTE_BYTE);
         }
-      }
-      // assume this is a basic single ByteBuf
-      source.readerIndex(source.readerIndex() + transferred);
     }
 
-    if (source.isReadable()) {
-      slowTarget = true;
-    } else {
-      state = sourceFullyWrittenState;
+    protected void visitContentTypeHeader(PartVisitor visitor) {
+        String contentType = part.getContentType();
+        if (contentType != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TYPE_BYTES);
+            visitor.withBytes(contentType.getBytes(US_ASCII));
+            Charset charSet = part.getCharset();
+            if (charSet != null) {
+                visitor.withBytes(CHARSET_BYTES);
+                visitor.withBytes(part.getCharset().name().getBytes(US_ASCII));
+            }
+        }
     }
-    return transferred;
-  }
-
-  protected int computePreContentLength() {
-    CounterPartVisitor counterVisitor = new CounterPartVisitor();
-    visitPreContent(counterVisitor);
-    return counterVisitor.getCount();
-  }
-
-  protected ByteBuf computePreContentBytes(int preContentLength) {
-    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(preContentLength);
-    ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
-    visitPreContent(bytesVisitor);
-    return buffer;
-  }
-
-  protected int computePostContentLength() {
-    CounterPartVisitor counterVisitor = new CounterPartVisitor();
-    visitPostContent(counterVisitor);
-    return counterVisitor.getCount();
-  }
-
-  protected ByteBuf computePostContentBytes(int postContentLength) {
-    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(postContentLength);
-    ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
-    visitPostContent(bytesVisitor);
-    return buffer;
-  }
-
-  protected void visitStart(PartVisitor visitor) {
-    visitor.withBytes(EXTRA_BYTES);
-    visitor.withBytes(boundary);
-  }
-
-  protected void visitDispositionHeader(PartVisitor visitor) {
-    visitor.withBytes(CRLF_BYTES);
-    visitor.withBytes(CONTENT_DISPOSITION_BYTES);
-    visitor.withBytes(part.getDispositionType() != null ? part.getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
-    if (part.getName() != null) {
-      visitor.withBytes(NAME_BYTES);
-      visitor.withByte(QUOTE_BYTE);
-      visitor.withBytes(part.getName().getBytes(US_ASCII));
-      visitor.withByte(QUOTE_BYTE);
+
+    protected void visitTransferEncodingHeader(PartVisitor visitor) {
+        String transferEncoding = part.getTransferEncoding();
+        if (transferEncoding != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
+            visitor.withBytes(transferEncoding.getBytes(US_ASCII));
+        }
     }
-  }
-
-  protected void visitContentTypeHeader(PartVisitor visitor) {
-    String contentType = part.getContentType();
-    if (contentType != null) {
-      visitor.withBytes(CRLF_BYTES);
-      visitor.withBytes(CONTENT_TYPE_BYTES);
-      visitor.withBytes(contentType.getBytes(US_ASCII));
-      Charset charSet = part.getCharset();
-      if (charSet != null) {
-        visitor.withBytes(CHARSET_BYTES);
-        visitor.withBytes(part.getCharset().name().getBytes(US_ASCII));
-      }
+
+    protected void visitContentIdHeader(PartVisitor visitor) {
+        String contentId = part.getContentId();
+        if (contentId != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_ID_BYTES);
+            visitor.withBytes(contentId.getBytes(US_ASCII));
+        }
+    }
+
+    protected void visitCustomHeaders(PartVisitor visitor) {
+        if (isNonEmpty(part.getCustomHeaders())) {
+            for (Param param : part.getCustomHeaders()) {
+                visitor.withBytes(CRLF_BYTES);
+                visitor.withBytes(param.getName().getBytes(US_ASCII));
+                visitor.withBytes(HEADER_NAME_VALUE_SEPARATOR_BYTES);
+                visitor.withBytes(param.getValue().getBytes(US_ASCII));
+            }
+        }
     }
-  }
-
-  protected void visitTransferEncodingHeader(PartVisitor visitor) {
-    String transferEncoding = part.getTransferEncoding();
-    if (transferEncoding != null) {
-      visitor.withBytes(CRLF_BYTES);
-      visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
-      visitor.withBytes(transferEncoding.getBytes(US_ASCII));
+
+    protected void visitEndOfHeaders(PartVisitor visitor) {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CRLF_BYTES);
     }
-  }
-
-  protected void visitContentIdHeader(PartVisitor visitor) {
-    String contentId = part.getContentId();
-    if (contentId != null) {
-      visitor.withBytes(CRLF_BYTES);
-      visitor.withBytes(CONTENT_ID_BYTES);
-      visitor.withBytes(contentId.getBytes(US_ASCII));
+
+    protected void visitPreContent(PartVisitor visitor) {
+        visitStart(visitor);
+        visitDispositionHeader(visitor);
+        visitContentTypeHeader(visitor);
+        visitTransferEncodingHeader(visitor);
+        visitContentIdHeader(visitor);
+        visitCustomHeaders(visitor);
+        visitEndOfHeaders(visitor);
     }
-  }
 
-  protected void visitCustomHeaders(PartVisitor visitor) {
-    if (isNonEmpty(part.getCustomHeaders())) {
-      for (Param param : part.getCustomHeaders()) {
+    protected void visitPostContent(PartVisitor visitor) {
         visitor.withBytes(CRLF_BYTES);
-        visitor.withBytes(param.getName().getBytes(US_ASCII));
-        visitor.withBytes(HEADER_NAME_VALUE_SEPARATOR_BYTES);
-        visitor.withBytes(param.getValue().getBytes(US_ASCII));
-      }
     }
-  }
-
-  protected void visitEndOfHeaders(PartVisitor visitor) {
-    visitor.withBytes(CRLF_BYTES);
-    visitor.withBytes(CRLF_BYTES);
-  }
-
-  protected void visitPreContent(PartVisitor visitor) {
-    visitStart(visitor);
-    visitDispositionHeader(visitor);
-    visitContentTypeHeader(visitor);
-    visitTransferEncodingHeader(visitor);
-    visitContentIdHeader(visitor);
-    visitCustomHeaders(visitor);
-    visitEndOfHeaders(visitor);
-  }
-
-  protected void visitPostContent(PartVisitor visitor) {
-    visitor.withBytes(CRLF_BYTES);
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
index 1d9f4b9de..6a44deac1 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
@@ -15,11 +15,11 @@
 
 public enum MultipartState {
 
-  PRE_CONTENT,
+    PRE_CONTENT,
 
-  CONTENT,
+    CONTENT,
 
-  POST_CONTENT,
+    POST_CONTENT,
 
-  DONE
+    DONE
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
index dd93b017b..ec3f57d1e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
@@ -18,63 +18,63 @@
 
 public interface PartVisitor {
 
-  void withBytes(byte[] bytes);
+    void withBytes(byte[] bytes);
 
-  void withByte(byte b);
+    void withByte(byte b);
 
-  class CounterPartVisitor implements PartVisitor {
+    class CounterPartVisitor implements PartVisitor {
 
-    private int count = 0;
+        private int count = 0;
 
-    @Override
-    public void withBytes(byte[] bytes) {
-      count += bytes.length;
-    }
-
-    @Override
-    public void withByte(byte b) {
-      count++;
-    }
-
-    public int getCount() {
-      return count;
-    }
-  }
+        @Override
+        public void withBytes(byte[] bytes) {
+            count += bytes.length;
+        }
 
-  class ByteBufferVisitor implements PartVisitor {
+        @Override
+        public void withByte(byte b) {
+            count++;
+        }
 
-    private final ByteBuffer target;
-
-    public ByteBufferVisitor(ByteBuffer target) {
-      this.target = target;
+        public int getCount() {
+            return count;
+        }
     }
 
-    @Override
-    public void withBytes(byte[] bytes) {
-      target.put(bytes);
-    }
+    class ByteBufferVisitor implements PartVisitor {
 
-    @Override
-    public void withByte(byte b) {
-      target.put(b);
-    }
-  }
+        private final ByteBuffer target;
 
-  class ByteBufVisitor implements PartVisitor {
-    private final ByteBuf target;
+        public ByteBufferVisitor(ByteBuffer target) {
+            this.target = target;
+        }
 
-    public ByteBufVisitor(ByteBuf target) {
-      this.target = target;
-    }
+        @Override
+        public void withBytes(byte[] bytes) {
+            target.put(bytes);
+        }
 
-    @Override
-    public void withBytes(byte[] bytes) {
-      target.writeBytes(bytes);
+        @Override
+        public void withByte(byte b) {
+            target.put(b);
+        }
     }
-
-    @Override
-    public void withByte(byte b) {
-      target.writeByte(b);
+    
+    class ByteBufVisitor implements PartVisitor {
+        private final ByteBuf target;
+
+        public ByteBufVisitor(ByteBuf target) {
+            this.target = target;
+        }
+
+        @Override
+        public void withBytes(byte[] bytes) {
+            target.writeBytes(bytes);
+        }
+
+        @Override
+        public void withByte(byte b) {
+            target.writeByte(b);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
index daf37a97c..73618a1eb 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/StringMultipartPart.java
@@ -15,38 +15,39 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.request.body.multipart.StringPart;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
 
+import org.asynchttpclient.request.body.multipart.StringPart;
+
 public class StringMultipartPart extends MultipartPart<StringPart> {
 
-  private final ByteBuf contentBuffer;
-
-  public StringMultipartPart(StringPart part, byte[] boundary) {
-    super(part, boundary);
-    contentBuffer = Unpooled.wrappedBuffer(part.getValue().getBytes(part.getCharset()));
-  }
-
-  @Override
-  protected long getContentLength() {
-    return contentBuffer.capacity();
-  }
-
-  @Override
-  protected long transferContentTo(ByteBuf target) {
-    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-  }
-
-  @Override
-  protected long transferContentTo(WritableByteChannel target) throws IOException {
-    return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
-  }
-
-  @Override
-  public void close() {
-    super.close();
-    contentBuffer.release();
-  }
+    private final ByteBuf contentBuffer;
+
+    public StringMultipartPart(StringPart part, byte[] boundary) {
+        super(part, boundary);
+        contentBuffer = Unpooled.wrappedBuffer(part.getValue().getBytes(part.getCharset()));
+    }
+
+    @Override
+    protected long getContentLength() {
+        return contentBuffer.capacity();
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        contentBuffer.release();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
index 3edf13ff1..ebeff4975 100644
--- a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -17,69 +17,76 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.netty.SimpleFutureListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.SimpleFutureListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public enum RequestHostnameResolver {
 
-  INSTANCE;
+    INSTANCE;
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(RequestHostnameResolver.class);
+    public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandlerExtensions asyncHandlerExtensions) {
 
-  public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandler<?> asyncHandler) {
+        final String hostname = unresolvedAddress.getHostName();
+        final int port = unresolvedAddress.getPort();
+        final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
-    final String hostname = unresolvedAddress.getHostName();
-    final int port = unresolvedAddress.getPort();
-    final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onHostnameResolutionAttempt(hostname);
+            } catch (Exception e) {
+                LOGGER.error("onHostnameResolutionAttempt crashed", e);
+                promise.tryFailure(e);
+                return promise;
+            }
+        }
 
-    try {
-      asyncHandler.onHostnameResolutionAttempt(hostname);
-    } catch (Exception e) {
-      LOGGER.error("onHostnameResolutionAttempt crashed", e);
-      promise.tryFailure(e);
-      return promise;
-    }
+        final Future<List<InetAddress>> whenResolved = nameResolver.resolveAll(hostname);
 
-    final Future<List<InetAddress>> whenResolved = nameResolver.resolveAll(hostname);
+        whenResolved.addListener(new SimpleFutureListener<List<InetAddress>>() {
 
-    whenResolved.addListener(new SimpleFutureListener<List<InetAddress>>() {
+            @Override
+            protected void onSuccess(List<InetAddress> value) throws Exception {
+                ArrayList<InetSocketAddress> socketAddresses = new ArrayList<>(value.size());
+                for (InetAddress a : value) {
+                    socketAddresses.add(new InetSocketAddress(a, port));
+                }
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onHostnameResolutionSuccess(hostname, socketAddresses);
+                    } catch (Exception e) {
+                        LOGGER.error("onHostnameResolutionSuccess crashed", e);
+                        promise.tryFailure(e);
+                        return;
+                    }
+                }
+                promise.trySuccess(socketAddresses);
+            }
 
-      @Override
-      protected void onSuccess(List<InetAddress> value) {
-        ArrayList<InetSocketAddress> socketAddresses = new ArrayList<>(value.size());
-        for (InetAddress a : value) {
-          socketAddresses.add(new InetSocketAddress(a, port));
-        }
-        try {
-          asyncHandler.onHostnameResolutionSuccess(hostname, socketAddresses);
-        } catch (Exception e) {
-          LOGGER.error("onHostnameResolutionSuccess crashed", e);
-          promise.tryFailure(e);
-          return;
-        }
-        promise.trySuccess(socketAddresses);
-      }
+            @Override
+            protected void onFailure(Throwable t) throws Exception {
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onHostnameResolutionFailure(hostname, t);
+                    } catch (Exception e) {
+                        LOGGER.error("onHostnameResolutionFailure crashed", e);
+                        promise.tryFailure(e);
+                        return;
+                    }
+                }
+                promise.tryFailure(t);
+            }
+        });
 
-      @Override
-      protected void onFailure(Throwable t) {
-        try {
-          asyncHandler.onHostnameResolutionFailure(hostname, t);
-        } catch (Exception e) {
-          LOGGER.error("onHostnameResolutionFailure crashed", e);
-          promise.tryFailure(e);
-          return;
-        }
-        promise.tryFailure(t);
-      }
-    });
+        return promise;
+    }
 
-    return promise;
-  }
+    private static final Logger LOGGER = LoggerFactory.getLogger(RequestHostnameResolver.class);
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index fc50a397f..53d97051a 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -38,7 +38,11 @@
 package org.asynchttpclient.spnego;
 
 import org.asynchttpclient.util.Base64;
-import org.ietf.jgss.*;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -46,122 +50,125 @@
 
 /**
  * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme.
- *
+ * 
  * @since 4.1
  */
 public class SpnegoEngine {
 
-  private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
-  private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
-  private static SpnegoEngine instance;
-  private final Logger log = LoggerFactory.getLogger(getClass());
-  private final SpnegoTokenGenerator spnegoGenerator;
-
-  public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
-    this.spnegoGenerator = spnegoGenerator;
-  }
-
-  public SpnegoEngine() {
-    this(null);
-  }
-
-  public static SpnegoEngine instance() {
-    if (instance == null)
-      instance = new SpnegoEngine();
-    return instance;
-  }
-
-  public String generateToken(String server) throws SpnegoEngineException {
-    GSSContext gssContext = null;
-    byte[] token = null; // base64 decoded challenge
-    Oid negotiationOid;
-
-    try {
-      log.debug("init {}", server);
-      /*
-       * Using the SPNEGO OID is the correct method. Kerberos v5 works for IIS but not JBoss. Unwrapping the initial token when using SPNEGO OID looks like what is described
-       * here...
-       *
-       * http://msdn.microsoft.com/en-us/library/ms995330.aspx
-       *
-       * Another helpful URL...
-       *
-       * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
-       *
-       * Unfortunately SPNEGO is JRE >=1.6.
-       */
-
-      // Try SPNEGO by default, fall back to Kerberos later if error
-      negotiationOid = new Oid(SPNEGO_OID);
-
-      boolean tryKerberos = false;
-      try {
-        GSSManager manager = GSSManager.getInstance();
-        GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-        gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
-                GSSContext.DEFAULT_LIFETIME);
-        gssContext.requestMutualAuth(true);
-        gssContext.requestCredDeleg(true);
-      } catch (GSSException ex) {
-        log.error("generateToken", ex);
-        // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
-        // Rethrow any other exception.
-        if (ex.getMajor() == GSSException.BAD_MECH) {
-          log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
-          tryKerberos = true;
-        } else {
-          throw ex;
-        }
+    private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
+    private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+
+    private final Logger log = LoggerFactory.getLogger(getClass());
+
+    private final SpnegoTokenGenerator spnegoGenerator;
+
+    public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
+        this.spnegoGenerator = spnegoGenerator;
+    }
 
-      }
-      if (tryKerberos) {
-        /* Kerberos v5 GSS-API mechanism defined in RFC 1964. */
-        log.debug("Using Kerberos MECH {}", KERBEROS_OID);
-        negotiationOid = new Oid(KERBEROS_OID);
-        GSSManager manager = GSSManager.getInstance();
-        GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
-        gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
-                GSSContext.DEFAULT_LIFETIME);
-        gssContext.requestMutualAuth(true);
-        gssContext.requestCredDeleg(true);
-      }
-
-      // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
-      if (token == null) {
-        token = new byte[0];
-      }
-
-      token = gssContext.initSecContext(token, 0, token.length);
-      if (token == null) {
-        throw new SpnegoEngineException("GSS security context initialization failed");
-      }
-
-      /*
-       * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish? seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
-       */
-      if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
-        token = spnegoGenerator.generateSpnegoDERObject(token);
-      }
-
-      gssContext.dispose();
-
-      String tokenstr = Base64.encode(token);
-      log.debug("Sending response '{}' back to the server", tokenstr);
-
-      return tokenstr;
-    } catch (GSSException gsse) {
-      log.error("generateToken", gsse);
-      if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
-        throw new SpnegoEngineException(gsse.getMessage(), gsse);
-      if (gsse.getMajor() == GSSException.NO_CRED)
-        throw new SpnegoEngineException(gsse.getMessage(), gsse);
-      if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
-              || gsse.getMajor() == GSSException.OLD_TOKEN)
-        throw new SpnegoEngineException(gsse.getMessage(), gsse);
-      // other error
-      throw new SpnegoEngineException(gsse.getMessage());
-    } catch (IOException ex) {
-      throw new SpnegoEngineException(ex.getMessage());
+    public SpnegoEngine() {
+        this(null);
+    }
+
+    private static SpnegoEngine instance;
+
+    public static SpnegoEngine instance() {
+        if (instance == null)
+            instance = new SpnegoEngine();
+        return instance;
+    }
+
+    public String generateToken(String server) throws SpnegoEngineException {
+        GSSContext gssContext = null;
+        byte[] token = null; // base64 decoded challenge
+        Oid negotiationOid;
+
+        try {
+            log.debug("init {}", server);
+            /*
+             * Using the SPNEGO OID is the correct method. Kerberos v5 works for IIS but not JBoss. Unwrapping the initial token when using SPNEGO OID looks like what is described
+             * here...
+             * 
+             * http://msdn.microsoft.com/en-us/library/ms995330.aspx
+             * 
+             * Another helpful URL...
+             * 
+             * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
+             * 
+             * Unfortunately SPNEGO is JRE >=1.6.
+             */
+
+            /** Try SPNEGO by default, fall back to Kerberos later if error */
+            negotiationOid = new Oid(SPNEGO_OID);
+
+            boolean tryKerberos = false;
+            try {
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            } catch (GSSException ex) {
+                log.error("generateToken", ex);
+                // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
+                // Rethrow any other exception.
+                if (ex.getMajor() == GSSException.BAD_MECH) {
+                    log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
+                    tryKerberos = true;
+                } else {
+                    throw ex;
+                }
+
+            }
+            if (tryKerberos) {
+                /* Kerberos v5 GSS-API mechanism defined in RFC 1964. */
+                log.debug("Using Kerberos MECH {}", KERBEROS_OID);
+                negotiationOid = new Oid(KERBEROS_OID);
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            }
+
+            // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
+            if (token == null) {
+                token = new byte[0];
+            }
+
+            token = gssContext.initSecContext(token, 0, token.length);
+            if (token == null) {
+                throw new SpnegoEngineException("GSS security context initialization failed");
+            }
+
+            /*
+             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish? seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
+             */
+            if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
+                token = spnegoGenerator.generateSpnegoDERObject(token);
+            }
+
+            gssContext.dispose();
+
+            String tokenstr = Base64.encode(token);
+            log.debug("Sending response '{}' back to the server", tokenstr);
+
+            return tokenstr;
+        } catch (GSSException gsse) {
+            log.error("generateToken", gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.NO_CRED)
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
+                    || gsse.getMajor() == GSSException.OLD_TOKEN)
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
+            // other error
+            throw new SpnegoEngineException(gsse.getMessage());
+        } catch (IOException ex) {
+            throw new SpnegoEngineException(ex.getMessage());
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
index 5e5570429..c7118d358 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
@@ -18,13 +18,13 @@
  */
 public class SpnegoEngineException extends Exception {
 
-  private static final long serialVersionUID = -3123799505052881438L;
+    private static final long serialVersionUID = -3123799505052881438L;
 
-  public SpnegoEngineException(String message) {
-    super(message);
-  }
+    public SpnegoEngineException(String message) {
+        super(message);
+    }
 
-  public SpnegoEngineException(String message, Throwable cause) {
-    super(message, cause);
-  }
+    public SpnegoEngineException(String message, Throwable cause) {
+        super(message, cause);
+    }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
index 5db40b184..3034b02cc 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoTokenGenerator.java
@@ -50,5 +50,5 @@
  */
 public interface SpnegoTokenGenerator {
 
-  byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
+    byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/uri/Uri.java b/client/src/main/java/org/asynchttpclient/uri/Uri.java
index 8735527c7..6075ca4f7 100644
--- a/client/src/main/java/org/asynchttpclient/uri/Uri.java
+++ b/client/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -12,235 +12,235 @@
  */
 package org.asynchttpclient.uri;
 
-import org.asynchttpclient.util.MiscUtils;
-import org.asynchttpclient.util.StringBuilderPool;
+import static org.asynchttpclient.util.Assertions.assertNotEmpty;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 import java.net.URI;
 import java.net.URISyntaxException;
 
-import static org.asynchttpclient.util.Assertions.assertNotEmpty;
-import static org.asynchttpclient.util.MiscUtils.isEmpty;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.util.MiscUtils;
+import org.asynchttpclient.util.StringBuilderPool;
 
 public class Uri {
 
-  public static final String HTTP = "http";
-  public static final String HTTPS = "https";
-  public static final String WS = "ws";
-  public static final String WSS = "wss";
-  private final String scheme;
-  private final String userInfo;
-  private final String host;
-  private final int port;
-  private final String query;
-  private final String path;
-  private String url;
-  private boolean secured;
-  private boolean webSocket;
-
-  public Uri(String scheme,
-             String userInfo,
-             String host,
-             int port,
-             String path,
-             String query) {
-
-    this.scheme = assertNotEmpty(scheme, "scheme");
-    this.userInfo = userInfo;
-    this.host = assertNotEmpty(host, "host");
-    this.port = port;
-    this.path = path;
-    this.query = query;
-    this.secured = HTTPS.equals(scheme) || WSS.equals(scheme);
-    this.webSocket = WS.equals(scheme) || WSS.equalsIgnoreCase(scheme);
-  }
-
-  public static Uri create(String originalUrl) {
-    return create(null, originalUrl);
-  }
-
-  public static Uri create(Uri context, final String originalUrl) {
-    UriParser parser = new UriParser();
-    parser.parse(context, originalUrl);
-
-    if (isEmpty(parser.scheme)) {
-      throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing scheme");
-    }
-    if (isEmpty(parser.host)) {
-      throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing host");
-    }
-
-    return new Uri(parser.scheme,
-            parser.userInfo,
-            parser.host,
-            parser.port,
-            parser.path,
-            parser.query);
-  }
-
-  public String getQuery() {
-    return query;
-  }
-
-  public String getPath() {
-    return path;
-  }
-
-  public String getUserInfo() {
-    return userInfo;
-  }
-
-  public int getPort() {
-    return port;
-  }
-
-  public String getScheme() {
-    return scheme;
-  }
-
-  public String getHost() {
-    return host;
-  }
-
-  public boolean isSecured() {
-    return secured;
-  }
-
-  public boolean isWebSocket() {
-    return webSocket;
-  }
-
-  public URI toJavaNetURI() throws URISyntaxException {
-    return new URI(toUrl());
-  }
-
-  public int getExplicitPort() {
-    return port == -1 ? getSchemeDefaultPort() : port;
-  }
-
-  public int getSchemeDefaultPort() {
-    return isSecured() ? 443 : 80;
-  }
-
-  public String toUrl() {
-    if (url == null) {
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      sb.append(scheme).append("://");
-      if (userInfo != null)
-        sb.append(userInfo).append('@');
-      sb.append(host);
-      if (port != -1)
-        sb.append(':').append(port);
-      if (path != null)
-        sb.append(path);
-      if (query != null)
-        sb.append('?').append(query);
-      url = sb.toString();
-      sb.setLength(0);
-    }
-    return url;
-  }
-
-  /**
-   * @return [scheme]://[hostname](:[port]). Port is omitted if it matches the scheme's default one.
-   */
-  public String toBaseUrl() {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    sb.append(scheme).append("://").append(host);
-    if (port != -1 && port != getSchemeDefaultPort()) {
-      sb.append(':').append(port);
-    }
-    if (isNonEmpty(path)) {
-      sb.append(path);
-    }
-    return sb.toString();
-  }
-
-  public String toRelativeUrl() {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    if (MiscUtils.isNonEmpty(path))
-      sb.append(path);
-    else
-      sb.append('/');
-    if (query != null)
-      sb.append('?').append(query);
-
-    return sb.toString();
-  }
-
-  @Override
-  public String toString() {
-    // for now, but might change
-    return toUrl();
-  }
-
-  public Uri withNewScheme(String newScheme) {
-    return new Uri(newScheme,
-            userInfo,
-            host,
-            port,
-            path,
-            query);
-  }
-
-  public Uri withNewQuery(String newQuery) {
-    return new Uri(scheme,
-            userInfo,
-            host,
-            port,
-            path,
-            newQuery);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((host == null) ? 0 : host.hashCode());
-    result = prime * result + ((path == null) ? 0 : path.hashCode());
-    result = prime * result + port;
-    result = prime * result + ((query == null) ? 0 : query.hashCode());
-    result = prime * result + ((scheme == null) ? 0 : scheme.hashCode());
-    result = prime * result + ((userInfo == null) ? 0 : userInfo.hashCode());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    Uri other = (Uri) obj;
-    if (host == null) {
-      if (other.host != null)
-        return false;
-    } else if (!host.equals(other.host))
-      return false;
-    if (path == null) {
-      if (other.path != null)
-        return false;
-    } else if (!path.equals(other.path))
-      return false;
-    if (port != other.port)
-      return false;
-    if (query == null) {
-      if (other.query != null)
-        return false;
-    } else if (!query.equals(other.query))
-      return false;
-    if (scheme == null) {
-      if (other.scheme != null)
-        return false;
-    } else if (!scheme.equals(other.scheme))
-      return false;
-    if (userInfo == null) {
-      if (other.userInfo != null)
-        return false;
-    } else if (!userInfo.equals(other.userInfo))
-      return false;
-    return true;
-  }
+    public static final String HTTP = "http";
+    public static final String HTTPS = "https";
+    public static final String WS = "ws";
+    public static final String WSS = "wss";
+
+    public static Uri create(String originalUrl) {
+        return create(null, originalUrl);
+    }
+
+    public static Uri create(Uri context, final String originalUrl) {
+        UriParser parser = new UriParser();
+        parser.parse(context, originalUrl);
+
+        if (isEmpty(parser.scheme)) {
+            throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing scheme");
+        }
+        if (isEmpty(parser.host)) {
+            throw new IllegalArgumentException(originalUrl + " could not be parsed into a proper Uri, missing host");
+        }
+
+        return new Uri(parser.scheme,//
+                parser.userInfo,//
+                parser.host,//
+                parser.port,//
+                parser.path,//
+                parser.query);
+    }
+
+    private final String scheme;
+    private final String userInfo;
+    private final String host;
+    private final int port;
+    private final String query;
+    private final String path;
+    private String url;
+    private boolean secured;
+    private boolean webSocket;
+
+    public Uri(String scheme,//
+            String userInfo,//
+            String host,//
+            int port,//
+            String path,//
+            String query) {
+
+        this.scheme = assertNotEmpty(scheme, "scheme");
+        this.userInfo = userInfo;
+        this.host = assertNotEmpty(host, "host");
+        this.port = port;
+        this.path = path;
+        this.query = query;
+        this.secured = HTTPS.equals(scheme) || WSS.equals(scheme);
+        this.webSocket = WS.equals(scheme) || WSS.equalsIgnoreCase(scheme);
+    }
+
+    public String getQuery() {
+        return query;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    public String getUserInfo() {
+        return userInfo;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public String getScheme() {
+        return scheme;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public boolean isSecured() {
+        return secured;
+    }
+
+    public boolean isWebSocket() {
+        return webSocket;
+    }
+
+    public URI toJavaNetURI() throws URISyntaxException {
+        return new URI(toUrl());
+    }
+
+    public int getExplicitPort() {
+        return port == -1 ? getSchemeDefaultPort() : port;
+    }
+
+    public int getSchemeDefaultPort() {
+        return isSecured() ? 443 : 80;
+    }
+
+    public String toUrl() {
+        if (url == null) {
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            sb.append(scheme).append("://");
+            if (userInfo != null)
+                sb.append(userInfo).append('@');
+            sb.append(host);
+            if (port != -1)
+                sb.append(':').append(port);
+            if (path != null)
+                sb.append(path);
+            if (query != null)
+                sb.append('?').append(query);
+            url = sb.toString();
+            sb.setLength(0);
+        }
+        return url;
+    }
+
+    /**
+     * @return [scheme]://[hostname](:[port]). Port is omitted if it matches the scheme's default one.
+     */
+    public String toBaseUrl() {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        sb.append(scheme).append("://").append(host);
+        if (port != -1 && port != getSchemeDefaultPort()) {
+            sb.append(':').append(port);
+        }
+        if (isNonEmpty(path)) {
+            sb.append(path);
+        }
+        return sb.toString();
+    }
+
+    public String toRelativeUrl() {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        if (MiscUtils.isNonEmpty(path))
+            sb.append(path);
+        else
+            sb.append('/');
+        if (query != null)
+            sb.append('?').append(query);
+
+        return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+        // for now, but might change
+        return toUrl();
+    }
+
+    public Uri withNewScheme(String newScheme) {
+        return new Uri(newScheme,//
+                userInfo,//
+                host,//
+                port,//
+                path,//
+                query);
+    }
+
+    public Uri withNewQuery(String newQuery) {
+        return new Uri(scheme,//
+                userInfo,//
+                host,//
+                port,//
+                path,//
+                newQuery);
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((host == null) ? 0 : host.hashCode());
+        result = prime * result + ((path == null) ? 0 : path.hashCode());
+        result = prime * result + port;
+        result = prime * result + ((query == null) ? 0 : query.hashCode());
+        result = prime * result + ((scheme == null) ? 0 : scheme.hashCode());
+        result = prime * result + ((userInfo == null) ? 0 : userInfo.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Uri other = (Uri) obj;
+        if (host == null) {
+            if (other.host != null)
+                return false;
+        } else if (!host.equals(other.host))
+            return false;
+        if (path == null) {
+            if (other.path != null)
+                return false;
+        } else if (!path.equals(other.path))
+            return false;
+        if (port != other.port)
+            return false;
+        if (query == null) {
+            if (other.query != null)
+                return false;
+        } else if (!query.equals(other.query))
+            return false;
+        if (scheme == null) {
+            if (other.scheme != null)
+                return false;
+        } else if (!scheme.equals(other.scheme))
+            return false;
+        if (userInfo == null) {
+            if (other.userInfo != null)
+                return false;
+        } else if (!userInfo.equals(other.userInfo))
+            return false;
+        return true;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/uri/UriParser.java b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
index 163f50c90..2ff07d6a7 100644
--- a/client/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -12,345 +12,345 @@
  */
 package org.asynchttpclient.uri;
 
-import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 final class UriParser {
 
-  public String scheme;
-  public String host;
-  public int port = -1;
-  public String query;
-  private String authority;
-  public String path;
-  public String userInfo;
+    public String scheme;
+    public String host;
+    public int port = -1;
+    public String query;
+    public String authority;
+    public String path;
+    public String userInfo;
 
-  private String originalUrl;
-  private int start, end, currentIndex = 0;
+    private String originalUrl;
+    private int start, end, currentIndex = 0;
 
-  private void trimLeft() {
-    while (start < end && originalUrl.charAt(start) <= ' ') {
-      start++;
+    private void trimLeft() {
+        while (start < end && originalUrl.charAt(start) <= ' ') {
+            start++;
+        }
+
+        if (originalUrl.regionMatches(true, start, "url:", 0, 4)) {
+            start += 4;
+        }
     }
 
-    if (originalUrl.regionMatches(true, start, "url:", 0, 4)) {
-      start += 4;
+    private void trimRight() {
+        end = originalUrl.length();
+        while (end > 0 && originalUrl.charAt(end - 1) <= ' ') {
+            end--;
+        }
     }
-  }
 
-  private void trimRight() {
-    end = originalUrl.length();
-    while (end > 0 && originalUrl.charAt(end - 1) <= ' ') {
-      end--;
+    private boolean isFragmentOnly() {
+        return start < originalUrl.length() && originalUrl.charAt(start) == '#';
     }
-  }
 
-  private boolean isFragmentOnly() {
-    return start < originalUrl.length() && originalUrl.charAt(start) == '#';
-  }
+    private boolean isValidProtocolChar(char c) {
+        return Character.isLetterOrDigit(c) && c != '.' && c != '+' && c != '-';
+    }
 
-  private boolean isValidProtocolChar(char c) {
-    return Character.isLetterOrDigit(c) && c != '.' && c != '+' && c != '-';
-  }
+    private boolean isValidProtocolChars(String protocol) {
+        for (int i = 1; i < protocol.length(); i++) {
+            if (!isValidProtocolChar(protocol.charAt(i))) {
+                return false;
+            }
+        }
+        return true;
+    }
 
-  private boolean isValidProtocolChars(String protocol) {
-    for (int i = 1; i < protocol.length(); i++) {
-      if (!isValidProtocolChar(protocol.charAt(i))) {
-        return false;
-      }
+    private boolean isValidProtocol(String protocol) {
+        return protocol.length() > 0 && Character.isLetter(protocol.charAt(0)) && isValidProtocolChars(protocol);
     }
-    return true;
-  }
-
-  private boolean isValidProtocol(String protocol) {
-    return protocol.length() > 0 && Character.isLetter(protocol.charAt(0)) && isValidProtocolChars(protocol);
-  }
-
-  private void computeInitialScheme() {
-    for (int i = currentIndex; i < end; i++) {
-      char c = originalUrl.charAt(i);
-      if (c == ':') {
-        String s = originalUrl.substring(currentIndex, i);
-        if (isValidProtocol(s)) {
-          scheme = s.toLowerCase();
-          currentIndex = i + 1;
+
+    private void computeInitialScheme() {
+        for (int i = currentIndex; i < end; i++) {
+            char c = originalUrl.charAt(i);
+            if (c == ':') {
+                String s = originalUrl.substring(currentIndex, i);
+                if (isValidProtocol(s)) {
+                    scheme = s.toLowerCase();
+                    currentIndex = i + 1;
+                }
+                break;
+            } else if (c == '/') {
+                break;
+            }
         }
-        break;
-      } else if (c == '/') {
-        break;
-      }
     }
-  }
 
-  private boolean overrideWithContext(Uri context) {
+    private boolean overrideWithContext(Uri context) {
 
-    boolean isRelative = false;
+        boolean isRelative = false;
 
-    // use context only if schemes match
-    if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {
+        // use context only if schemes match
+        if (context != null && (scheme == null || scheme.equalsIgnoreCase(context.getScheme()))) {
 
-      // see RFC2396 5.2.3
-      String contextPath = context.getPath();
-      if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/') {
-        scheme = null;
-      }
+            // see RFC2396 5.2.3
+            String contextPath = context.getPath();
+            if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/') {
+                scheme = null;
+            }
 
-      if (scheme == null) {
-        scheme = context.getScheme();
-        userInfo = context.getUserInfo();
-        host = context.getHost();
-        port = context.getPort();
-        path = contextPath;
-        isRelative = true;
-      }
-    }
-    return isRelative;
-  }
-
-  private int findWithinCurrentRange(char c) {
-    int pos = originalUrl.indexOf(c, currentIndex);
-    return pos > end ? -1 : pos;
-  }
-
-  private void trimFragment() {
-    int charpPosition = findWithinCurrentRange('#');
-    if (charpPosition >= 0) {
-      end = charpPosition;
+            if (scheme == null) {
+                scheme = context.getScheme();
+                userInfo = context.getUserInfo();
+                host = context.getHost();
+                port = context.getPort();
+                path = contextPath;
+                isRelative = true;
+            }
+        }
+        return isRelative;
     }
-  }
 
-  private void inheritContextQuery(Uri context, boolean isRelative) {
-    // see RFC2396 5.2.2: query and fragment inheritance
-    if (isRelative && currentIndex == end) {
-      query = context.getQuery();
+    private int findWithinCurrentRange(char c) {
+        int pos = originalUrl.indexOf(c, currentIndex);
+        return pos > end ? -1 : pos;
     }
-  }
-
-  private boolean computeQuery() {
-    if (currentIndex < end) {
-      int askPosition = findWithinCurrentRange('?');
-      if (askPosition != -1) {
-        query = originalUrl.substring(askPosition + 1, end);
-        if (end > askPosition) {
-          end = askPosition;
+
+    private void trimFragment() {
+        int charpPosition = findWithinCurrentRange('#');
+        if (charpPosition >= 0) {
+            end = charpPosition;
         }
-        return askPosition == currentIndex;
-      }
-    }
-    return false;
-  }
-
-  private boolean currentPositionStartsWith4Slashes() {
-    return originalUrl.regionMatches(currentIndex, "////", 0, 4);
-  }
-
-  private boolean currentPositionStartsWith2Slashes() {
-    return originalUrl.regionMatches(currentIndex, "//", 0, 2);
-  }
-
-  private void computeAuthority() {
-    int authorityEndPosition = findWithinCurrentRange('/');
-    if (authorityEndPosition == -1) {
-      authorityEndPosition = findWithinCurrentRange('?');
-      if (authorityEndPosition == -1) {
-        authorityEndPosition = end;
-      }
     }
-    host = authority = originalUrl.substring(currentIndex, authorityEndPosition);
-    currentIndex = authorityEndPosition;
-  }
-
-  private void computeUserInfo() {
-    int atPosition = authority.indexOf('@');
-    if (atPosition != -1) {
-      userInfo = authority.substring(0, atPosition);
-      host = authority.substring(atPosition + 1);
-    } else {
-      userInfo = null;
+
+    private void inheritContextQuery(Uri context, boolean isRelative) {
+        // see RFC2396 5.2.2: query and fragment inheritance
+        if (isRelative && currentIndex == end) {
+            query = context.getQuery();
+        }
     }
-  }
-
-  private boolean isMaybeIPV6() {
-    // If the host is surrounded by [ and ] then its an IPv6
-    // literal address as specified in RFC2732
-    return host.length() > 0 && host.charAt(0) == '[';
-  }
-
-  private void computeIPV6() {
-    int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
-    if (positionAfterClosingSquareBrace > 1) {
-
-      port = -1;
-
-      if (host.length() > positionAfterClosingSquareBrace) {
-        if (host.charAt(positionAfterClosingSquareBrace) == ':') {
-          // see RFC2396: port can be null
-          int portPosition = positionAfterClosingSquareBrace + 1;
-          if (host.length() > portPosition) {
-            port = Integer.parseInt(host.substring(portPosition));
-          }
-        } else {
-          throw new IllegalArgumentException("Invalid authority field: " + authority);
+
+    private boolean computeQuery() {
+        if (currentIndex < end) {
+            int askPosition = findWithinCurrentRange('?');
+            if (askPosition != -1) {
+                query = originalUrl.substring(askPosition + 1, end);
+                if (end > askPosition) {
+                    end = askPosition;
+                }
+                return askPosition == currentIndex;
+            }
         }
-      }
+        return false;
+    }
 
-      host = host.substring(0, positionAfterClosingSquareBrace);
+    private boolean currentPositionStartsWith4Slashes() {
+        return originalUrl.regionMatches(currentIndex, "////", 0, 4);
+    }
 
-    } else {
-      throw new IllegalArgumentException("Invalid authority field: " + authority);
+    private boolean currentPositionStartsWith2Slashes() {
+        return originalUrl.regionMatches(currentIndex, "//", 0, 2);
     }
-  }
-
-  private void computeRegularHostPort() {
-    int colonPosition = host.indexOf(':');
-    port = -1;
-    if (colonPosition >= 0) {
-      // see RFC2396: port can be null
-      int portPosition = colonPosition + 1;
-      if (host.length() > portPosition)
-        port = Integer.parseInt(host.substring(portPosition));
-      host = host.substring(0, colonPosition);
+
+    private void computeAuthority() {
+        int authorityEndPosition = findWithinCurrentRange('/');
+        if (authorityEndPosition == -1) {
+            authorityEndPosition = findWithinCurrentRange('?');
+            if (authorityEndPosition == -1) {
+                authorityEndPosition = end;
+            }
+        }
+        host = authority = originalUrl.substring(currentIndex, authorityEndPosition);
+        currentIndex = authorityEndPosition;
     }
-  }
-
-  // /./
-  private void removeEmbeddedDot() {
-    path = path.replace("/./", "/");
-  }
-
-  // /../
-  private void removeEmbedded2Dots() {
-    int i = 0;
-    while ((i = path.indexOf("/../", i)) >= 0) {
-      if (i > 0) {
-        end = path.lastIndexOf('/', i - 1);
-        if (end >= 0 && path.indexOf("/../", end) != 0) {
-          path = path.substring(0, end) + path.substring(i + 3);
-          i = 0;
-        } else if (end == 0) {
-          break;
+
+    private void computeUserInfo() {
+        int atPosition = authority.indexOf('@');
+        if (atPosition != -1) {
+            userInfo = authority.substring(0, atPosition);
+            host = authority.substring(atPosition + 1);
+        } else {
+            userInfo = null;
         }
-      } else {
-        i = i + 3;
-      }
     }
-  }
-
-  private void removeTailing2Dots() {
-    while (path.endsWith("/..")) {
-      end = path.lastIndexOf('/', path.length() - 4);
-      if (end >= 0) {
-        path = path.substring(0, end + 1);
-      } else {
-        break;
-      }
+
+    private boolean isMaybeIPV6() {
+        // If the host is surrounded by [ and ] then its an IPv6
+        // literal address as specified in RFC2732
+        return host.length() > 0 && host.charAt(0) == '[';
     }
-  }
 
-  private void removeStartingDot() {
-    if (path.startsWith("./") && path.length() > 2) {
-      path = path.substring(2);
+    private void computeIPV6() {
+        int positionAfterClosingSquareBrace = host.indexOf(']') + 1;
+        if (positionAfterClosingSquareBrace > 1) {
+
+            port = -1;
+
+            if (host.length() > positionAfterClosingSquareBrace) {
+                if (host.charAt(positionAfterClosingSquareBrace) == ':') {
+                    // see RFC2396: port can be null
+                    int portPosition = positionAfterClosingSquareBrace + 1;
+                    if (host.length() > portPosition) {
+                        port = Integer.parseInt(host.substring(portPosition));
+                    }
+                } else {
+                    throw new IllegalArgumentException("Invalid authority field: " + authority);
+                }
+            }
+
+            host = host.substring(0, positionAfterClosingSquareBrace);
+
+        } else {
+            throw new IllegalArgumentException("Invalid authority field: " + authority);
+        }
     }
-  }
 
-  private void removeTrailingDot() {
-    if (path.endsWith("/.")) {
-      path = path.substring(0, path.length() - 1);
+    private void computeRegularHostPort() {
+        int colonPosition = host.indexOf(':');
+        port = -1;
+        if (colonPosition >= 0) {
+            // see RFC2396: port can be null
+            int portPosition = colonPosition + 1;
+            if (host.length() > portPosition)
+                port = Integer.parseInt(host.substring(portPosition));
+            host = host.substring(0, colonPosition);
+        }
     }
-  }
 
-  private void handleRelativePath() {
-    int lastSlashPosition = path.lastIndexOf('/');
-    String pathEnd = originalUrl.substring(currentIndex, end);
+    // /./
+    private void removeEmbeddedDot() {
+        path = path.replace("/./", "/");
+    }
 
-    if (lastSlashPosition == -1) {
-      path = authority != null ? "/" + pathEnd : pathEnd;
-    } else {
-      path = path.substring(0, lastSlashPosition + 1) + pathEnd;
+    // /../
+    private void removeEmbedded2Dots() {
+        int i = 0;
+        while ((i = path.indexOf("/../", i)) >= 0) {
+            if (i > 0) {
+                end = path.lastIndexOf('/', i - 1);
+                if (end >= 0 && path.indexOf("/../", end) != 0) {
+                    path = path.substring(0, end) + path.substring(i + 3);
+                    i = 0;
+                } else if (end == 0) {
+                    break;
+                }
+            } else {
+                i = i + 3;
+            }
+        }
     }
-  }
-
-  private void handlePathDots() {
-    if (path.indexOf('.') != -1) {
-      removeEmbeddedDot();
-      removeEmbedded2Dots();
-      removeTailing2Dots();
-      removeStartingDot();
-      removeTrailingDot();
+
+    private void removeTailing2Dots() {
+        while (path.endsWith("/..")) {
+            end = path.lastIndexOf('/', path.length() - 4);
+            if (end >= 0) {
+                path = path.substring(0, end + 1);
+            } else {
+                break;
+            }
+        }
+    }
+
+    private void removeStartingDot() {
+        if (path.startsWith("./") && path.length() > 2) {
+            path = path.substring(2);
+        }
     }
-  }
 
-  private void parseAuthority() {
-    if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
-      currentIndex += 2;
+    private void removeTrailingDot() {
+        if (path.endsWith("/.")) {
+            path = path.substring(0, path.length() - 1);
+        }
+    }
 
-      computeAuthority();
-      computeUserInfo();
+    private void handleRelativePath() {
+        int lastSlashPosition = path.lastIndexOf('/');
+        String pathEnd = originalUrl.substring(currentIndex, end);
 
-      if (host != null) {
-        if (isMaybeIPV6()) {
-          computeIPV6();
+        if (lastSlashPosition == -1) {
+            path = authority != null ? "/" + pathEnd : pathEnd;
         } else {
-          computeRegularHostPort();
+            path = path.substring(0, lastSlashPosition + 1) + pathEnd;
         }
-      }
+    }
 
-      if (port < -1) {
-        throw new IllegalArgumentException("Invalid port number :" + port);
-      }
+    private void handlePathDots() {
+        if (path.indexOf('.') != -1) {
+            removeEmbeddedDot();
+            removeEmbedded2Dots();
+            removeTailing2Dots();
+            removeStartingDot();
+            removeTrailingDot();
+        }
+    }
 
-      // see RFC2396 5.2.4: ignore context path if authority is defined
-      if (isNonEmpty(authority)) {
-        path = "";
-      }
+    private void parseAuthority() {
+        if (!currentPositionStartsWith4Slashes() && currentPositionStartsWith2Slashes()) {
+            currentIndex += 2;
+
+            computeAuthority();
+            computeUserInfo();
+
+            if (host != null) {
+                if (isMaybeIPV6()) {
+                    computeIPV6();
+                } else {
+                    computeRegularHostPort();
+                }
+            }
+
+            if (port < -1) {
+                throw new IllegalArgumentException("Invalid port number :" + port);
+            }
+
+            // see RFC2396 5.2.4: ignore context path if authority is defined
+            if (isNonEmpty(authority)) {
+                path = "";
+            }
+        }
     }
-  }
-
-  private void computeRegularPath() {
-    if (originalUrl.charAt(currentIndex) == '/') {
-      path = originalUrl.substring(currentIndex, end);
-    } else if (isNonEmpty(path)) {
-      handleRelativePath();
-    } else {
-      String pathEnd = originalUrl.substring(currentIndex, end);
-      path = isNonEmpty(pathEnd) && pathEnd.charAt(0) != '/' ? "/" + pathEnd : pathEnd;
+
+    private void computeRegularPath() {
+        if (originalUrl.charAt(currentIndex) == '/') {
+            path = originalUrl.substring(currentIndex, end);
+        } else if (isNonEmpty(path)) {
+            handleRelativePath();
+        } else {
+            String pathEnd = originalUrl.substring(currentIndex, end);
+            path = isNonEmpty(pathEnd) && pathEnd.charAt(0) != '/' ? "/" + pathEnd : pathEnd;
+        }
+        handlePathDots();
+    }
+
+    private void computeQueryOnlyPath() {
+        int lastSlashPosition = path.lastIndexOf('/');
+        path = lastSlashPosition < 0 ? "/" : path.substring(0, lastSlashPosition) + "/";
     }
-    handlePathDots();
-  }
-
-  private void computeQueryOnlyPath() {
-    int lastSlashPosition = path.lastIndexOf('/');
-    path = lastSlashPosition < 0 ? "/" : path.substring(0, lastSlashPosition) + "/";
-  }
-
-  private void computePath(boolean queryOnly) {
-    // Parse the file path if any
-    if (currentIndex < end) {
-      computeRegularPath();
-    } else if (queryOnly && path != null) {
-      computeQueryOnlyPath();
-    } else if (path == null) {
-      path = "";
+
+    private void computePath(boolean queryOnly) {
+        // Parse the file path if any
+        if (currentIndex < end) {
+            computeRegularPath();
+        } else if (queryOnly && path != null) {
+            computeQueryOnlyPath();
+        } else if (path == null) {
+            path = "";
+        }
     }
-  }
 
-  public void parse(Uri context, final String originalUrl) {
+    public void parse(Uri context, final String originalUrl) {
 
-    assertNotNull(originalUrl, "orginalUri");
-    this.originalUrl = originalUrl;
-    this.end = originalUrl.length();
+        assertNotNull(originalUrl, "orginalUri");
+        this.originalUrl = originalUrl;
+        this.end = originalUrl.length();
 
-    trimLeft();
-    trimRight();
-    currentIndex = start;
-    if (!isFragmentOnly()) {
-      computeInitialScheme();
+        trimLeft();
+        trimRight();
+        currentIndex = start;
+        if (!isFragmentOnly()) {
+            computeInitialScheme();
+        }
+        boolean isRelative = overrideWithContext(context);
+        trimFragment();
+        inheritContextQuery(context, isRelative);
+        boolean queryOnly = computeQuery();
+        parseAuthority();
+        computePath(queryOnly);
     }
-    boolean isRelative = overrideWithContext(context);
-    trimFragment();
-    inheritContextQuery(context, isRelative);
-    boolean queryOnly = computeQuery();
-    parseAuthority();
-    computePath(queryOnly);
-  }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/util/Assertions.java b/client/src/main/java/org/asynchttpclient/util/Assertions.java
index 6d7d8ad23..3a4126fbb 100644
--- a/client/src/main/java/org/asynchttpclient/util/Assertions.java
+++ b/client/src/main/java/org/asynchttpclient/util/Assertions.java
@@ -15,20 +15,20 @@
 
 public final class Assertions {
 
-  private Assertions() {
-  }
+    private Assertions() {
+    }
 
-  public static <T> T assertNotNull(T value, String name) {
-    if (value == null)
-      throw new NullPointerException(name);
-    return value;
+    public static <T> T assertNotNull(T value, String name) {
+        if (value == null)
+            throw new NullPointerException(name);
+        return value;
 
-  }
+    }
 
-  public static String assertNotEmpty(String value, String name) {
-    assertNotNull(value, name);
-    if (value.length() == 0)
-      throw new IllegalArgumentException("empty " + name);
-    return value;
-  }
+    public static String assertNotEmpty(String value, String name) {
+        assertNotNull(value, name);
+        if (value.length() == 0)
+            throw new IllegalArgumentException("empty " + name);
+        return value;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index c0193466a..eea95f7dc 100644
--- a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -12,6 +12,15 @@
  */
 package org.asynchttpclient.util;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.HttpUtils.getNonEmptyPath;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import java.nio.charset.Charset;
+import java.util.List;
+
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.ntlm.NtlmEngine;
@@ -20,205 +29,196 @@
 import org.asynchttpclient.spnego.SpnegoEngineException;
 import org.asynchttpclient.uri.Uri;
 
-import java.nio.charset.Charset;
-import java.util.List;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.HttpUtils.getNonEmptyPath;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
 public final class AuthenticatorUtils {
 
-  public static final String NEGOTIATE = "Negotiate";
-
-  public static String getHeaderWithPrefix(List<String> authenticateHeaders, String prefix) {
-    if (authenticateHeaders != null) {
-      for (String authenticateHeader : authenticateHeaders) {
-        if (authenticateHeader.regionMatches(true, 0, prefix, 0, prefix.length()))
-          return authenticateHeader;
-      }
-    }
-
-    return null;
-  }
+    public static final String NEGOTIATE = "Negotiate";
 
-  private static String computeBasicAuthentication(Realm realm) {
-    return realm != null ? computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset()) : null;
-  }
+    public static String getHeaderWithPrefix(List<String> authenticateHeaders, String prefix) {
+        if (authenticateHeaders != null) {
+            for (String authenticateHeader : authenticateHeaders) {
+                if (authenticateHeader.regionMatches(true, 0, prefix, 0, prefix.length()))
+                    return authenticateHeader;
+            }
+        }
 
-  private static String computeBasicAuthentication(String principal, String password, Charset charset) {
-    String s = principal + ":" + password;
-    return "Basic " + Base64.encode(s.getBytes(charset));
-  }
-
-  public static String computeRealmURI(Uri uri, boolean useAbsoluteURI, boolean omitQuery) {
-    if (useAbsoluteURI) {
-      return omitQuery && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
-    } else {
-      String path = getNonEmptyPath(uri);
-      return omitQuery || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
+        return null;
     }
-  }
 
-  private static String computeDigestAuthentication(Realm realm) {
+    public static String computeBasicAuthentication(Realm realm) {
+        return realm != null ? computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset()) : null;
+    }
 
-    String realmUri = computeRealmURI(realm.getUri(), realm.isUseAbsoluteURI(), realm.isOmitQuery());
+    private static String computeBasicAuthentication(String principal, String password, Charset charset) {
+        String s = principal + ":" + password;
+        return "Basic " + Base64.encode(s.getBytes(charset));
+    }
 
-    StringBuilder builder = new StringBuilder().append("Digest ");
-    append(builder, "username", realm.getPrincipal(), true);
-    append(builder, "realm", realm.getRealmName(), true);
-    append(builder, "nonce", realm.getNonce(), true);
-    append(builder, "uri", realmUri, true);
-    if (isNonEmpty(realm.getAlgorithm()))
-      append(builder, "algorithm", realm.getAlgorithm(), false);
+    public static String computeRealmURI(Uri uri, boolean useAbsoluteURI, boolean omitQuery) {
+        if (useAbsoluteURI) {
+            return omitQuery && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
+        } else {
+            String path = getNonEmptyPath(uri);
+            return omitQuery || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
+        }
+    }
 
-    append(builder, "response", realm.getResponse(), true);
+    private static String computeDigestAuthentication(Realm realm) {
+        
+        String realmUri = computeRealmURI(realm.getUri(), realm.isUseAbsoluteURI(), realm.isOmitQuery());
+
+        StringBuilder builder = new StringBuilder().append("Digest ");
+        append(builder, "username", realm.getPrincipal(), true);
+        append(builder, "realm", realm.getRealmName(), true);
+        append(builder, "nonce", realm.getNonce(), true);
+        append(builder, "uri", realmUri, true);
+        if (isNonEmpty(realm.getAlgorithm()))
+            append(builder, "algorithm", realm.getAlgorithm(), false);
+
+        append(builder, "response", realm.getResponse(), true);
+
+        if (realm.getOpaque() != null)
+            append(builder, "opaque", realm.getOpaque(), true);
+
+        if (realm.getQop() != null) {
+            append(builder, "qop", realm.getQop(), false);
+            // nc and cnonce only sent if server sent qop
+            append(builder, "nc", realm.getNc(), false);
+            append(builder, "cnonce", realm.getCnonce(), true);
+        }
+        builder.setLength(builder.length() - 2); // remove tailing ", "
+
+        // FIXME isn't there a more efficient way?
+        return new String(StringUtils.charSequence2Bytes(builder, ISO_8859_1));
+    }
 
-    if (realm.getOpaque() != null)
-      append(builder, "opaque", realm.getOpaque(), true);
+    private static StringBuilder append(StringBuilder builder, String name, String value, boolean quoted) {
+        builder.append(name).append('=');
+        if (quoted)
+            builder.append('"').append(value).append('"');
+        else
+            builder.append(value);
 
-    if (realm.getQop() != null) {
-      append(builder, "qop", realm.getQop(), false);
-      // nc and cnonce only sent if server sent qop
-      append(builder, "nc", realm.getNc(), false);
-      append(builder, "cnonce", realm.getCnonce(), true);
-    }
-    builder.setLength(builder.length() - 2); // remove tailing ", "
-
-    // FIXME isn't there a more efficient way?
-    return new String(StringUtils.charSequence2Bytes(builder, ISO_8859_1));
-  }
-
-  private static void append(StringBuilder builder, String name, String value, boolean quoted) {
-    builder.append(name).append('=');
-    if (quoted)
-      builder.append('"').append(value).append('"');
-    else
-      builder.append(value);
-
-    builder.append(", ");
-  }
-
-  public static String perConnectionProxyAuthorizationHeader(Request request, Realm proxyRealm) {
-    String proxyAuthorization = null;
-    if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
-      switch (proxyRealm.getScheme()) {
-        case NTLM:
-        case KERBEROS:
-        case SPNEGO:
-          List<String> auth = request.getHeaders().getAll(PROXY_AUTHORIZATION);
-          if (getHeaderWithPrefix(auth, "NTLM") == null) {
-            String msg = NtlmEngine.INSTANCE.generateType1Msg();
-            proxyAuthorization = "NTLM " + msg;
-          }
-
-          break;
-        default:
-      }
+        return builder.append(", ");
     }
 
-    return proxyAuthorization;
-  }
-
-  public static String perRequestProxyAuthorizationHeader(Request request, Realm proxyRealm) {
-
-    String proxyAuthorization = null;
-    if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
-
-      switch (proxyRealm.getScheme()) {
-        case BASIC:
-          proxyAuthorization = computeBasicAuthentication(proxyRealm);
-          break;
-        case DIGEST:
-          if (isNonEmpty(proxyRealm.getNonce())) {
-            // update realm with request information
-            proxyRealm = realm(proxyRealm)
-                    .setUri(request.getUri())
-                    .setMethodName(request.getMethod())
-                    .build();
-            proxyAuthorization = computeDigestAuthentication(proxyRealm);
-          }
-          break;
-        case NTLM:
-        case KERBEROS:
-        case SPNEGO:
-          // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
-          // see perConnectionProxyAuthorizationHeader
-          break;
-        default:
-          throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
-      }
+    public static String perConnectionProxyAuthorizationHeader(Request request, Realm proxyRealm) {
+        String proxyAuthorization = null;
+        if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
+            switch (proxyRealm.getScheme()) {
+            case NTLM:
+            case KERBEROS:
+            case SPNEGO:
+                List<String> auth = request.getHeaders().getAll(PROXY_AUTHORIZATION);
+                if (getHeaderWithPrefix(auth, "NTLM") == null) {
+                    String msg = NtlmEngine.INSTANCE.generateType1Msg();
+                    proxyAuthorization = "NTLM " + msg;
+                }
+
+                break;
+            default:
+            }
+        }
+
+        return proxyAuthorization;
     }
 
-    return proxyAuthorization;
-  }
-
-  public static String perConnectionAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm) {
-    String authorizationHeader = null;
-
-    if (realm != null && realm.isUsePreemptiveAuth()) {
-      switch (realm.getScheme()) {
-        case NTLM:
-          String msg = NtlmEngine.INSTANCE.generateType1Msg();
-          authorizationHeader = "NTLM " + msg;
-          break;
-        case KERBEROS:
-        case SPNEGO:
-          String host;
-          if (proxyServer != null)
-            host = proxyServer.getHost();
-          else if (request.getVirtualHost() != null)
-            host = request.getVirtualHost();
-          else
-            host = request.getUri().getHost();
-
-          try {
-            authorizationHeader = NEGOTIATE + " " + SpnegoEngine.instance().generateToken(host);
-          } catch (SpnegoEngineException e) {
-            throw new RuntimeException(e);
-          }
-          break;
-        default:
-          break;
-      }
+    public static String perRequestProxyAuthorizationHeader(Request request, Realm proxyRealm) {
+
+        String proxyAuthorization = null;
+        if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
+
+            switch (proxyRealm.getScheme()) {
+            case BASIC:
+                proxyAuthorization = computeBasicAuthentication(proxyRealm);
+                break;
+            case DIGEST:
+                if (isNonEmpty(proxyRealm.getNonce())) {
+                    // update realm with request information
+                    proxyRealm = realm(proxyRealm)//
+                            .setUri(request.getUri())//
+                            .setMethodName(request.getMethod())//
+                            .build();
+                    proxyAuthorization = computeDigestAuthentication(proxyRealm);
+                }
+                break;
+            case NTLM:
+            case KERBEROS:
+            case SPNEGO:
+                // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
+                // see perConnectionProxyAuthorizationHeader
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
+            }
+        }
+
+        return proxyAuthorization;
     }
 
-    return authorizationHeader;
-  }
-
-  public static String perRequestAuthorizationHeader(Request request, Realm realm) {
-
-    String authorizationHeader = null;
-
-    if (realm != null && realm.isUsePreemptiveAuth()) {
-
-      switch (realm.getScheme()) {
-        case BASIC:
-          authorizationHeader = computeBasicAuthentication(realm);
-          break;
-        case DIGEST:
-          if (isNonEmpty(realm.getNonce())) {
-            // update realm with request information
-            realm = realm(realm)
-                    .setUri(request.getUri())
-                    .setMethodName(request.getMethod())
-                    .build();
-            authorizationHeader = computeDigestAuthentication(realm);
-          }
-          break;
-        case NTLM:
-        case KERBEROS:
-        case SPNEGO:
-          // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
-          // see perConnectionAuthorizationHeader
-          break;
-        default:
-          throw new IllegalStateException("Invalid Authentication " + realm);
-      }
+    public static String perConnectionAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm) {
+        String authorizationHeader = null;
+
+        if (realm != null && realm.isUsePreemptiveAuth()) {
+            switch (realm.getScheme()) {
+            case NTLM:
+                String msg = NtlmEngine.INSTANCE.generateType1Msg();
+                authorizationHeader = "NTLM " + msg;
+                break;
+            case KERBEROS:
+            case SPNEGO:
+                String host;
+                if (proxyServer != null)
+                    host = proxyServer.getHost();
+                else if (request.getVirtualHost() != null)
+                    host = request.getVirtualHost();
+                else
+                    host = request.getUri().getHost();
+
+                try {
+                    authorizationHeader = NEGOTIATE + " " + SpnegoEngine.instance().generateToken(host);
+                } catch (SpnegoEngineException e) {
+                    throw new RuntimeException(e);
+                }
+                break;
+            default:
+                break;
+            }
+        }
+
+        return authorizationHeader;
     }
 
-    return authorizationHeader;
-  }
+    public static String perRequestAuthorizationHeader(Request request, Realm realm) {
+
+        String authorizationHeader = null;
+
+        if (realm != null && realm.isUsePreemptiveAuth()) {
+
+            switch (realm.getScheme()) {
+            case BASIC:
+                authorizationHeader = computeBasicAuthentication(realm);
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce())) {
+                    // update realm with request information
+                    realm = realm(realm)//
+                            .setUri(request.getUri())//
+                            .setMethodName(request.getMethod())//
+                            .build();
+                    authorizationHeader = computeDigestAuthentication(realm);
+                }
+                break;
+            case NTLM:
+            case KERBEROS:
+            case SPNEGO:
+                // NTLM, KERBEROS and SPNEGO are only set on the first request with a connection,
+                // see perConnectionAuthorizationHeader
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication " + realm);
+            }
+        }
+
+        return authorizationHeader;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Base64.java b/client/src/main/java/org/asynchttpclient/util/Base64.java
index 87bc48635..757203387 100644
--- a/client/src/main/java/org/asynchttpclient/util/Base64.java
+++ b/client/src/main/java/org/asynchttpclient/util/Base64.java
@@ -17,120 +17,120 @@
  * Portions of code here are taken from Apache Pivot
  */
 public final class Base64 {
-  private static final StringBuilderPool SB_POOL = new StringBuilderPool();
-  private static final char[] LOOKUP = new char[64];
-  private static final byte[] REVERSE_LOOKUP = new byte[256];
+    private static final StringBuilderPool SB_POOL = new StringBuilderPool();
+    private static final char[] LOOKUP = new char[64];
+    private static final byte[] REVERSE_LOOKUP = new byte[256];
 
-  static {
-    // Populate the lookup array
+    static {
+        // Populate the lookup array
 
-    for (int i = 0; i < 26; i++) {
-      LOOKUP[i] = (char) ('A' + i);
-    }
+        for (int i = 0; i < 26; i++) {
+            LOOKUP[i] = (char) ('A' + i);
+        }
 
-    for (int i = 26, j = 0; i < 52; i++, j++) {
-      LOOKUP[i] = (char) ('a' + j);
-    }
+        for (int i = 26, j = 0; i < 52; i++, j++) {
+            LOOKUP[i] = (char) ('a' + j);
+        }
 
-    for (int i = 52, j = 0; i < 62; i++, j++) {
-      LOOKUP[i] = (char) ('0' + j);
-    }
+        for (int i = 52, j = 0; i < 62; i++, j++) {
+            LOOKUP[i] = (char) ('0' + j);
+        }
 
-    LOOKUP[62] = '+';
-    LOOKUP[63] = '/';
+        LOOKUP[62] = '+';
+        LOOKUP[63] = '/';
 
-    // Populate the reverse lookup array
+        // Populate the reverse lookup array
 
-    for (int i = 0; i < 256; i++) {
-      REVERSE_LOOKUP[i] = -1;
-    }
+        for (int i = 0; i < 256; i++) {
+            REVERSE_LOOKUP[i] = -1;
+        }
 
-    for (int i = 'Z'; i >= 'A'; i--) {
-      REVERSE_LOOKUP[i] = (byte) (i - 'A');
-    }
+        for (int i = 'Z'; i >= 'A'; i--) {
+            REVERSE_LOOKUP[i] = (byte) (i - 'A');
+        }
 
-    for (int i = 'z'; i >= 'a'; i--) {
-      REVERSE_LOOKUP[i] = (byte) (i - 'a' + 26);
-    }
+        for (int i = 'z'; i >= 'a'; i--) {
+            REVERSE_LOOKUP[i] = (byte) (i - 'a' + 26);
+        }
 
-    for (int i = '9'; i >= '0'; i--) {
-      REVERSE_LOOKUP[i] = (byte) (i - '0' + 52);
-    }
+        for (int i = '9'; i >= '0'; i--) {
+            REVERSE_LOOKUP[i] = (byte) (i - '0' + 52);
+        }
 
-    REVERSE_LOOKUP['+'] = 62;
-    REVERSE_LOOKUP['/'] = 63;
-    REVERSE_LOOKUP['='] = 0;
-  }
-
-  private Base64() {
-  }
-
-  /**
-   * Encodes the specified data into a base64 string.
-   *
-   * @param bytes The unencoded raw data.
-   * @return the encoded data
-   */
-  public static String encode(byte[] bytes) {
-    StringBuilder buf = SB_POOL.stringBuilder();
-
-    // first, handle complete chunks (fast loop)
-    int i = 0;
-    for (int end = bytes.length - 2; i < end; ) {
-      int chunk = ((bytes[i++] & 0xFF) << 16) | ((bytes[i++] & 0xFF) << 8) | (bytes[i++] & 0xFF);
-      buf.append(LOOKUP[chunk >> 18]);
-      buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-      buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
-      buf.append(LOOKUP[chunk & 0x3F]);
+        REVERSE_LOOKUP['+'] = 62;
+        REVERSE_LOOKUP['/'] = 63;
+        REVERSE_LOOKUP['='] = 0;
     }
 
-    // then leftovers, if any
-    int len = bytes.length;
-    if (i < len) { // 1 or 2 extra bytes?
-      int chunk = ((bytes[i++] & 0xFF) << 16);
-      buf.append(LOOKUP[chunk >> 18]);
-      if (i < len) { // 2 bytes
-        chunk |= ((bytes[i] & 0xFF) << 8);
-        buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-        buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
-      } else { // 1 byte
-        buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
-        buf.append('=');
-      }
-      buf.append('=');
+    private Base64() {
     }
-    return buf.toString();
-  }
-
-  /**
-   * Decodes the specified base64 string back into its raw data.
-   *
-   * @param encoded The base64 encoded string.
-   * @return the decoded data
-   */
-  public static byte[] decode(String encoded) {
-    int padding = 0;
-
-    for (int i = encoded.length() - 1; encoded.charAt(i) == '='; i--) {
-      padding++;
+
+    /**
+     * Encodes the specified data into a base64 string.
+     *
+     * @param bytes The unencoded raw data.
+     * @return the encoded data
+     */
+    public static String encode(byte[] bytes) {
+        StringBuilder buf = SB_POOL.stringBuilder();
+
+        // first, handle complete chunks (fast loop)
+        int i = 0;
+        for (int end = bytes.length - 2; i < end;) {
+            int chunk = ((bytes[i++] & 0xFF) << 16) | ((bytes[i++] & 0xFF) << 8) | (bytes[i++] & 0xFF);
+            buf.append(LOOKUP[chunk >> 18]);
+            buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
+            buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
+            buf.append(LOOKUP[chunk & 0x3F]);
+        }
+
+        // then leftovers, if any
+        int len = bytes.length;
+        if (i < len) { // 1 or 2 extra bytes?
+            int chunk = ((bytes[i++] & 0xFF) << 16);
+            buf.append(LOOKUP[chunk >> 18]);
+            if (i < len) { // 2 bytes
+                chunk |= ((bytes[i] & 0xFF) << 8);
+                buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
+                buf.append(LOOKUP[(chunk >> 6) & 0x3F]);
+            } else { // 1 byte
+                buf.append(LOOKUP[(chunk >> 12) & 0x3F]);
+                buf.append('=');
+            }
+            buf.append('=');
+        }
+        return buf.toString();
     }
 
-    int length = encoded.length() * 6 / 8 - padding;
-    byte[] bytes = new byte[length];
+    /**
+     * Decodes the specified base64 string back into its raw data.
+     *
+     * @param encoded The base64 encoded string.
+     * @return the decoded data
+     */
+    public static byte[] decode(String encoded) {
+        int padding = 0;
 
-    for (int i = 0, index = 0, n = encoded.length(); i < n; i += 4) {
-      int word = REVERSE_LOOKUP[encoded.charAt(i)] << 18;
-      word += REVERSE_LOOKUP[encoded.charAt(i + 1)] << 12;
-      word += REVERSE_LOOKUP[encoded.charAt(i + 2)] << 6;
-      word += REVERSE_LOOKUP[encoded.charAt(i + 3)];
+        for (int i = encoded.length() - 1; encoded.charAt(i) == '='; i--) {
+            padding++;
+        }
 
-      for (int j = 0; j < 3 && index + j < length; j++) {
-        bytes[index + j] = (byte) (word >> (8 * (2 - j)));
-      }
+        int length = encoded.length() * 6 / 8 - padding;
+        byte[] bytes = new byte[length];
 
-      index += 3;
-    }
+        for (int i = 0, index = 0, n = encoded.length(); i < n; i += 4) {
+            int word = REVERSE_LOOKUP[encoded.charAt(i)] << 18;
+            word += REVERSE_LOOKUP[encoded.charAt(i + 1)] << 12;
+            word += REVERSE_LOOKUP[encoded.charAt(i + 2)] << 6;
+            word += REVERSE_LOOKUP[encoded.charAt(i + 3)];
 
-    return bytes;
-  }
+            for (int j = 0; j < 3 && index + j < length; j++) {
+                bytes[index + j] = (byte) (word >> (8 * (2 - j)));
+            }
+
+            index += 3;
+        }
+
+        return bytes;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/DateUtils.java b/client/src/main/java/org/asynchttpclient/util/DateUtils.java
index b8bf42cd1..ec78648dd 100644
--- a/client/src/main/java/org/asynchttpclient/util/DateUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/DateUtils.java
@@ -15,10 +15,10 @@
 
 public final class DateUtils {
 
-  private DateUtils() {
-  }
-
-  public static long unpreciseMillisTime() {
-    return System.currentTimeMillis();
-  }
+    private DateUtils() {
+    }
+    
+    public static long unpreciseMillisTime() {
+        return System.currentTimeMillis();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
index e17681e6d..9e0f37b3d 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -18,37 +18,38 @@
 
 public final class HttpConstants {
 
-  private HttpConstants() {
-  }
+    public static final class Methods {
+        public static final String CONNECT = HttpMethod.CONNECT.name();
+        public static final String DELETE = HttpMethod.DELETE.name();
+        public static final String GET = HttpMethod.GET.name();
+        public static final String HEAD = HttpMethod.HEAD.name();
+        public static final String OPTIONS = HttpMethod.OPTIONS.name();
+        public static final String PATCH = HttpMethod.PATCH.name();
+        public static final String POST = HttpMethod.POST.name();
+        public static final String PUT = HttpMethod.PUT.name();
+        public static final String TRACE = HttpMethod.TRACE.name();
 
-  public static final class Methods {
-    public static final String CONNECT = HttpMethod.CONNECT.name();
-    public static final String DELETE = HttpMethod.DELETE.name();
-    public static final String GET = HttpMethod.GET.name();
-    public static final String HEAD = HttpMethod.HEAD.name();
-    public static final String OPTIONS = HttpMethod.OPTIONS.name();
-    public static final String PATCH = HttpMethod.PATCH.name();
-    public static final String POST = HttpMethod.POST.name();
-    public static final String PUT = HttpMethod.PUT.name();
-    public static final String TRACE = HttpMethod.TRACE.name();
-
-    private Methods() {
+        private Methods() {
+        }
     }
-  }
 
-  public static final class ResponseStatusCodes {
-    public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
-    public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
-    public static final int OK_200 = HttpResponseStatus.OK.code();
-    public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
-    public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
-    public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
-    public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
-    public static final int PERMANENT_REDIRECT_308 = HttpResponseStatus.PERMANENT_REDIRECT.code();
-    public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
-    public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
+    public static final class ResponseStatusCodes {
+        public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
+        public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
+        public static final int OK_200 = HttpResponseStatus.OK.code();
+        public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
+        public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
+        public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
+        public static final int NOT_MODIFIED_304 = HttpResponseStatus.NOT_MODIFIED.code();
+        public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
+        public static final int PERMANENT_REDIRECT_308 = HttpResponseStatus.PERMANENT_REDIRECT.code();
+        public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
+        public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
+
+        private ResponseStatusCodes() {
+        }
+    }
 
-    private ResponseStatusCodes() {
+    private HttpConstants() {
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index 6d4e7aa68..45b9c39cc 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -12,10 +12,8 @@
  */
 package org.asynchttpclient.util;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.uri.Uri;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
@@ -23,143 +21,121 @@
 import java.nio.charset.Charset;
 import java.util.List;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * {@link org.asynchttpclient.AsyncHttpClient} common utilities.
  */
 public class HttpUtils {
 
-  private static final String CONTENT_TYPE_CHARSET_ATTRIBUTE = "charset=";
+    public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
-  public static void validateSupportedScheme(Uri uri) {
-    final String scheme = uri.getScheme();
-    if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https")
-            && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
-      throw new IllegalArgumentException("The URI scheme, of the URI " + uri
-              + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
+    public static void validateSupportedScheme(Uri uri) {
+        final String scheme = uri.getScheme();
+        if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
+            throw new IllegalArgumentException("The URI scheme, of the URI " + uri + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
+        }
     }
-  }
-
-  public static String getBaseUrl(Uri uri) {
-    // getAuthority duplicate but we don't want to re-concatenate
-    return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
-  }
-
-  public static String getAuthority(Uri uri) {
-    return uri.getHost() + ":" + uri.getExplicitPort();
-  }
-
-  public static boolean isSameBase(Uri uri1, Uri uri2) {
-    return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost())
-            && uri1.getExplicitPort() == uri2.getExplicitPort();
-  }
-
-  /**
-   * @param uri the uri
-   * @return the raw path or "/" if it's null
-   */
-  public static String getNonEmptyPath(Uri uri) {
-    return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
-  }
-
-  public static Charset extractCharset(String contentType) {
-    if (contentType != null) {
-      for (int i = 0; i < contentType.length(); i++) {
-        if (contentType.regionMatches(true, i, CONTENT_TYPE_CHARSET_ATTRIBUTE, 0,
-                CONTENT_TYPE_CHARSET_ATTRIBUTE.length())) {
-          int start = i + CONTENT_TYPE_CHARSET_ATTRIBUTE.length();
-
-          // trim left
-          while (start < contentType.length()) {
-            char c = contentType.charAt(start);
-            if (c == ' ' || c == '\'' || c == '"') {
-              start++;
-            } else {
-              break;
-            }
-          }
-          if (start == contentType.length()) {
-            break;
-          }
-
-          // trim right
-          int end = start + 1;
-          while (end < contentType.length()) {
-            char c = contentType.charAt(end);
-            if (c == ' ' || c == '\'' || c == '"' || c == ';') {
-              break;
-            } else {
-              end++;
-            }
-          }
 
-          String charsetName = contentType.substring(start, end);
-          return Charset.forName(charsetName);
-        }
-      }
+    public static String getBaseUrl(Uri uri) {
+        // getAuthority duplicate but we don't want to re-concatenate
+        return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
     }
 
-    return null;
-  }
+    public static String getAuthority(Uri uri) {
+        return uri.getHost() + ":" + uri.getExplicitPort();
+    }
 
-  public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
-    return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
-  }
+    public static boolean isSameBase(Uri uri1, Uri uri2) {
+        return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost()) && uri1.getExplicitPort() == uri2.getExplicitPort();
+    }
 
-  public static ByteBuffer urlEncodeFormParams(List<Param> params, Charset charset) {
-    return StringUtils.charSequence2ByteBuffer(urlEncodeFormParams0(params, charset), US_ASCII);
-  }
+    /**
+     * @param uri the uri
+     * @return the raw path or "/" if it's null
+     */
+    public static String getNonEmptyPath(Uri uri) {
+        return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
+    }
 
-  private static StringBuilder urlEncodeFormParams0(List<Param> params, Charset charset) {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    for (Param param : params) {
-      encodeAndAppendFormParam(sb, param.getName(), param.getValue(), charset);
+    public static Charset parseCharset(String contentType) {
+        for (String part : contentType.split(";")) {
+            if (part.trim().startsWith("charset=")) {
+                String[] val = part.split("=");
+                if (val.length > 1) {
+                    String charset = val[1].trim();
+                    // Quite a lot of sites have charset="CHARSET",
+                    // e.g. charset="utf-8". Note the quotes. This is
+                    // not correct, but client should be able to handle
+                    // it (all browsers do, Grizzly strips it by default)
+                    // This is a poor man's trim("\"").trim("'")
+                    String charsetName = charset.replaceAll("\"", "").replaceAll("'", "");
+                    return Charset.forName(charsetName);
+                }
+            }
+        }
+        return null;
     }
-    sb.setLength(sb.length() - 1);
-    return sb;
-  }
-
-  private static void encodeAndAppendFormParam(StringBuilder sb, String name, String value, Charset charset) {
-    encodeAndAppendFormField(sb, name, charset);
-    if (value != null) {
-      sb.append('=');
-      encodeAndAppendFormField(sb, value, charset);
+
+    public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
+        return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
     }
-    sb.append('&');
-  }
-
-  private static void encodeAndAppendFormField(StringBuilder sb, String field, Charset charset) {
-    if (charset.equals(UTF_8)) {
-      Utf8UrlEncoder.encodeAndAppendFormElement(sb, field);
-    } else {
-      try {
-        // TODO there's probably room for perf improvements
-        sb.append(URLEncoder.encode(field, charset.name()));
-      } catch (UnsupportedEncodingException e) {
-        // can't happen, as Charset was already resolved
-      }
+
+    public static ByteBuffer urlEncodeFormParams(List<Param> params, Charset charset) {
+        return StringUtils.charSequence2ByteBuffer(urlEncodeFormParams0(params, charset), US_ASCII);
     }
-  }
-
-  public static String hostHeader(Request request, Uri uri) {
-    String virtualHost = request.getVirtualHost();
-    if (virtualHost != null)
-      return virtualHost;
-    else {
-      String host = uri.getHost();
-      int port = uri.getPort();
-      return port == -1 || port == uri.getSchemeDefaultPort() ? host : host + ":" + port;
+
+    private static StringBuilder urlEncodeFormParams0(List<Param> params, Charset charset) {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        for (Param param : params) {
+            encodeAndAppendFormParam(sb, param.getName(), param.getValue(), charset);
+        }
+        sb.setLength(sb.length() - 1);
+        return sb;
     }
-  }
 
-  public static String computeOriginHeader(Uri uri) {
-    StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-    sb.append(uri.isSecured() ? "https://" : "http://").append(uri.getHost());
-    if (uri.getExplicitPort() != uri.getSchemeDefaultPort()) {
-      sb.append(':').append(uri.getPort());
+    private static void encodeAndAppendFormParam(StringBuilder sb, String name, String value, Charset charset) {
+        encodeAndAppendFormField(sb, name, charset);
+        if (value != null) {
+            sb.append('=');
+            encodeAndAppendFormField(sb, value, charset);
+        }
+        sb.append('&');
+    }
+
+    private static void encodeAndAppendFormField(StringBuilder sb, String field, Charset charset) {
+        if (charset.equals(UTF_8)) {
+            Utf8UrlEncoder.encodeAndAppendFormElement(sb, field);
+        } else {
+            try {
+                // TODO there's probably room for perf improvements
+                sb.append(URLEncoder.encode(field, charset.name()));
+            } catch (UnsupportedEncodingException e) {
+                // can't happen, as Charset was already resolved
+            }
+        }
+    }
+
+    public static String hostHeader(Request request, Uri uri) {
+        String virtualHost = request.getVirtualHost();
+        if (virtualHost != null)
+            return virtualHost;
+        else {
+            String host = uri.getHost();
+            int port = uri.getPort();
+            return port == -1 || port == uri.getSchemeDefaultPort() ? host : host + ":" + port;
+        }
+    }
+    
+    public static String computeOriginHeader(Uri uri) {
+        StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+        sb.append(uri.isSecured() ? "https://" : "http://").append(uri.getHost());
+        if (uri.getExplicitPort() != uri.getSchemeDefaultPort()) {
+            sb.append(':').append(uri.getPort());
+        }
+        return sb.toString();
     }
-    return sb.toString();
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java b/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
deleted file mode 100644
index 3b5cfb426..000000000
--- a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public final class MessageDigestUtils {
-
-  private static final ThreadLocal<MessageDigest> MD5_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-    try {
-      return MessageDigest.getInstance("MD5");
-    } catch (NoSuchAlgorithmException e) {
-      throw new InternalError("MD5 not supported on this platform");
-    }
-  });
-
-  private static final ThreadLocal<MessageDigest> SHA1_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-    try {
-      return MessageDigest.getInstance("SHA1");
-    } catch (NoSuchAlgorithmException e) {
-      throw new InternalError("SHA1 not supported on this platform");
-    }
-  });
-
-  public static MessageDigest pooledMd5MessageDigest() {
-    MessageDigest md = MD5_MESSAGE_DIGESTS.get();
-    md.reset();
-    return md;
-  }
-
-  public static MessageDigest pooledSha1MessageDigest() {
-    MessageDigest md = SHA1_MESSAGE_DIGESTS.get();
-    md.reset();
-    return md;
-  }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
index 26e98fe9d..02cb28257 100644
--- a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -19,48 +19,52 @@
 
 public class MiscUtils {
 
-  private MiscUtils() {
-  }
+    private MiscUtils() {
+    }
 
-  public static boolean isNonEmpty(String string) {
-    return !isEmpty(string);
-  }
+    public static boolean isNonEmpty(String string) {
+        return !isEmpty(string);
+    }
+    
+    public static boolean isEmpty(String string) {
+        return string == null || string.isEmpty();
+    }
 
-  public static boolean isEmpty(String string) {
-    return string == null || string.isEmpty();
-  }
+    public static boolean isNonEmpty(Object[] array) {
+        return array != null && array.length != 0;
+    }
 
-  public static boolean isNonEmpty(Object[] array) {
-    return array != null && array.length != 0;
-  }
+    public static boolean isNonEmpty(byte[] array) {
+        return array != null && array.length != 0;
+    }
 
-  public static boolean isNonEmpty(byte[] array) {
-    return array != null && array.length != 0;
-  }
+    public static boolean isNonEmpty(Collection<?> collection) {
+        return collection != null && !collection.isEmpty();
+    }
 
-  public static boolean isNonEmpty(Collection<?> collection) {
-    return collection != null && !collection.isEmpty();
-  }
+    public static boolean isNonEmpty(Map<?, ?> map) {
+        return map != null && !map.isEmpty();
+    }
 
-  public static boolean isNonEmpty(Map<?, ?> map) {
-    return map != null && !map.isEmpty();
-  }
+    public static boolean getBoolean(String systemPropName, boolean defaultValue) {
+        String systemPropValue = System.getProperty(systemPropName);
+        return systemPropValue != null ? systemPropValue.equalsIgnoreCase("true") : defaultValue;
+    }
 
-  public static <T> T withDefault(T value, T def) {
-    return value == null ? def : value;
-  }
+    public static <T> T withDefault(T value, T def) {
+        return value == null ? def : value;
+    }
 
-  public static void closeSilently(Closeable closeable) {
-    if (closeable != null)
-      try {
-        closeable.close();
-      } catch (IOException e) {
-        //
-      }
-  }
+    public static void closeSilently(Closeable closeable) {
+        if (closeable != null)
+            try {
+                closeable.close();
+            } catch (IOException e) {
+            }
+    }
 
-  public static Throwable getCause(Throwable t) {
-    Throwable cause = t.getCause();
-    return cause != null ? getCause(cause) : t;
-  }
+    public static Throwable getCause(Throwable t) {
+        Throwable cause = t.getCause();
+        return cause != null ? getCause(cause) : t;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 5a22abc36..569c8e649 100644
--- a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -12,23 +12,27 @@
  */
 package org.asynchttpclient.util;
 
+import static org.asynchttpclient.Dsl.*;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Properties;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
+import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.net.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Properties;
-
-import static org.asynchttpclient.Dsl.basicAuthRealm;
-import static org.asynchttpclient.Dsl.proxyServer;
-
 /**
  * Utilities for Proxy handling.
  *
@@ -36,141 +40,144 @@
  */
 public final class ProxyUtils {
 
-  /**
-   * The host to use as proxy.
-   *
-   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-   */
-  public static final String PROXY_HOST = "http.proxyHost";
-  /**
-   * The port to use for the proxy.
-   *
-   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-   */
-  public static final String PROXY_PORT = "http.proxyPort";
-  /**
-   * A specification of non-proxy hosts.
-   *
-   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-   */
-  public static final String PROXY_NONPROXYHOSTS = "http.nonProxyHosts";
-  private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
-  private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
-
-  /**
-   * The username to use for authentication for the proxy server.
-   */
-  private static final String PROXY_USER = PROPERTY_PREFIX + "user";
-
-  /**
-   * The password to use for authentication for the proxy server.
-   */
-  private static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
-
-  private ProxyUtils() {
-  }
-
-  /**
-   * @param config  the global config
-   * @param request the request
-   * @return the proxy server to be used for this request (can be null)
-   */
-  public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
-    ProxyServer proxyServer = request.getProxyServer();
-    if (proxyServer == null) {
-      ProxyServerSelector selector = config.getProxyServerSelector();
-      if (selector != null) {
-        proxyServer = selector.select(request.getUri());
-      }
+    private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
+
+    /**
+     * The host to use as proxy.
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+     */
+    public static final String PROXY_HOST = "http.proxyHost";
+
+    /**
+     * The port to use for the proxy.
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+     */
+    public static final String PROXY_PORT = "http.proxyPort";
+
+    /**
+     * A specification of non-proxy hosts.
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+     */
+    public static final String PROXY_NONPROXYHOSTS = "http.nonProxyHosts";
+
+    private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
+
+    /**
+     * The username to use for authentication for the proxy server.
+     */
+    public static final String PROXY_USER = PROPERTY_PREFIX + "user";
+
+    /**
+     * The password to use for authentication for the proxy server.
+     */
+    public static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
+
+    private ProxyUtils() {
     }
-    return proxyServer != null && !proxyServer.isIgnoredForHost(request.getUri().getHost()) ? proxyServer : null;
-  }
-
-  /**
-   * Creates a proxy server instance from the given properties.
-   * Currently the default http.* proxy properties are supported as well as properties specific for AHC.
-   *
-   * @param properties the properties to evaluate. Must not be null.
-   * @return a ProxyServer instance or null, if no valid properties were set.
-   * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
-   * @see #PROXY_HOST
-   * @see #PROXY_PORT
-   * @see #PROXY_NONPROXYHOSTS
-   */
-  public static ProxyServerSelector createProxyServerSelector(Properties properties) {
-    String host = properties.getProperty(PROXY_HOST);
-
-    if (host != null) {
-      int port = Integer.valueOf(properties.getProperty(PROXY_PORT, "80"));
-
-      String principal = properties.getProperty(PROXY_USER);
-      String password = properties.getProperty(PROXY_PASSWORD);
-
-      Realm realm = null;
-      if (principal != null) {
-        realm = basicAuthRealm(principal, password).build();
-      }
-
-      ProxyServer.Builder proxyServer = proxyServer(host, port).setRealm(realm);
-
-      String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
-      if (nonProxyHosts != null) {
-        proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
-      }
-
-      ProxyServer proxy = proxyServer.build();
-      return uri -> proxy;
+    
+    /**
+     * @param config the global config
+     * @param request the request
+     * @return the proxy server to be used for this request (can be null)
+     */
+    public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
+        ProxyServer proxyServer = request.getProxyServer();
+        if (proxyServer == null) {
+            ProxyServerSelector selector = config.getProxyServerSelector();
+            if (selector != null) {
+                proxyServer = selector.select(request.getUri());
+            }
+        }
+        return proxyServer != null && !proxyServer.isIgnoredForHost(request.getUri().getHost()) ? proxyServer : null;
     }
+    
+    /**
+     * Creates a proxy server instance from the given properties.
+     * Currently the default http.* proxy properties are supported as well as properties specific for AHC.
+     *
+     * @param properties the properties to evaluate. Must not be null.
+     * @return a ProxyServer instance or null, if no valid properties were set.
+     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
+     * @see #PROXY_HOST
+     * @see #PROXY_PORT
+     * @see #PROXY_NONPROXYHOSTS
+     */
+    public static ProxyServerSelector createProxyServerSelector(Properties properties) {
+        String host = properties.getProperty(PROXY_HOST);
+
+        if (host != null) {
+            int port = Integer.valueOf(properties.getProperty(PROXY_PORT, "80"));
+
+            String principal = properties.getProperty(PROXY_USER);
+            String password = properties.getProperty(PROXY_PASSWORD);
+            
+            Realm realm = null;
+            if (principal != null) {
+                realm = basicAuthRealm(principal, password).build();
+            }
+            
+            ProxyServer.Builder proxyServer = proxyServer(host, port).setRealm(realm);
 
-    return ProxyServerSelector.NO_PROXY_SELECTOR;
-  }
-
-  /**
-   * Get a proxy server selector based on the JDK default proxy selector.
-   *
-   * @return The proxy server selector.
-   */
-  public static ProxyServerSelector getJdkDefaultProxyServerSelector() {
-    return createProxyServerSelector(ProxySelector.getDefault());
-  }
-
-  /**
-   * Create a proxy server selector based on the passed in JDK proxy selector.
-   *
-   * @param proxySelector The proxy selector to use.  Must not be null.
-   * @return The proxy server selector.
-   */
-  private static ProxyServerSelector createProxyServerSelector(final ProxySelector proxySelector) {
-    return uri -> {
-        try {
-          URI javaUri = uri.toJavaNetURI();
-
-          List<Proxy> proxies = proxySelector.select(javaUri);
-          if (proxies != null) {
-            // Loop through them until we find one that we know how to use
-            for (Proxy proxy : proxies) {
-              switch (proxy.type()) {
-                case HTTP:
-                  if (!(proxy.address() instanceof InetSocketAddress)) {
-                    logger.warn("Don't know how to connect to address " + proxy.address());
-                    return null;
-                  } else {
-                    InetSocketAddress address = (InetSocketAddress) proxy.address();
-                    return proxyServer(address.getHostName(), address.getPort()).build();
-                  }
-                case DIRECT:
-                  return null;
-                default:
-                  logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
-                  break;
-              }
+            String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
+            if (nonProxyHosts != null) {
+                proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
             }
-          }
-          return null;
-        } catch (URISyntaxException e) {
-          logger.warn(uri + " couldn't be turned into a java.net.URI", e);
-          return null;
+
+            ProxyServer proxy = proxyServer.build();
+            return uri -> proxy;
         }
-    };
-  }
+
+        return ProxyServerSelector.NO_PROXY_SELECTOR;
+    }
+
+    /**
+     * Get a proxy server selector based on the JDK default proxy selector.
+     *
+     * @return The proxy server selector.
+     */
+    public static ProxyServerSelector getJdkDefaultProxyServerSelector() {
+        return createProxyServerSelector(ProxySelector.getDefault());
+    }
+
+    /**
+     * Create a proxy server selector based on the passed in JDK proxy selector.
+     *
+     * @param proxySelector The proxy selector to use.  Must not be null.
+     * @return The proxy server selector.
+     */
+    public static ProxyServerSelector createProxyServerSelector(final ProxySelector proxySelector) {
+        return new ProxyServerSelector() {
+            public ProxyServer select(Uri uri) {
+                try {
+                    URI javaUri = uri.toJavaNetURI();
+
+                    List<Proxy> proxies = proxySelector.select(javaUri);
+                    if (proxies != null) {
+                        // Loop through them until we find one that we know how to use
+                        for (Proxy proxy : proxies) {
+                            switch (proxy.type()) {
+                            case HTTP:
+                                if (!(proxy.address() instanceof InetSocketAddress)) {
+                                    logger.warn("Don't know how to connect to address " + proxy.address());
+                                    return null;
+                                } else {
+                                    InetSocketAddress address = (InetSocketAddress) proxy.address();
+                                    return proxyServer(address.getHostName(), address.getPort()).build();
+                                }
+                            case DIRECT:
+                                return null;
+                            default:
+                                logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
+                                break;
+                            }
+                        }
+                    }
+                    return null;
+                } catch (URISyntaxException e) {
+                    logger.warn(uri + " couldn't be turned into a java.net.URI", e);
+                    return null;
+                }
+            }
+        };
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java b/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
index 2e89ad78d..98e5af398 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringBuilderPool.java
@@ -14,18 +14,18 @@
 
 public class StringBuilderPool {
 
-  public static final StringBuilderPool DEFAULT = new StringBuilderPool();
+    public static final StringBuilderPool DEFAULT = new StringBuilderPool();
 
-  private final ThreadLocal<StringBuilder> pool = ThreadLocal.withInitial(() -> new StringBuilder(512));
+    private final ThreadLocal<StringBuilder> pool = ThreadLocal.withInitial(() -> new StringBuilder(512));
 
-  /**
-   * BEWARE: MUSN'T APPEND TO ITSELF!
-   *
-   * @return a pooled StringBuilder
-   */
-  public StringBuilder stringBuilder() {
-    StringBuilder sb = pool.get();
-    sb.setLength(0);
-    return sb;
-  }
+    /**
+     * BEWARE: MUSN'T APPEND TO ITSELF!
+     * 
+     * @return a pooled StringBuilder
+     */
+    public StringBuilder stringBuilder() {
+        StringBuilder sb = pool.get();
+        sb.setLength(0);
+        return sb;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringUtils.java b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
index ef08f938d..e3f793769 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
@@ -18,45 +18,45 @@
 
 public final class StringUtils {
 
-  private StringUtils() {
-  }
-
-  public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
-    return charset.encode(CharBuffer.wrap(cs));
-  }
-
-  public static byte[] byteBuffer2ByteArray(ByteBuffer bb) {
-    byte[] rawBase = new byte[bb.remaining()];
-    bb.get(rawBase);
-    return rawBase;
-  }
-
-  public static byte[] charSequence2Bytes(CharSequence sb, Charset charset) {
-    ByteBuffer bb = charSequence2ByteBuffer(sb, charset);
-    return byteBuffer2ByteArray(bb);
-  }
-
-  public static String toHexString(byte[] data) {
-    StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder();
-    for (byte aData : data) {
-      buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
-      buffer.append(Integer.toHexString(aData & 0x0f));
+    private StringUtils() {
     }
-    return buffer.toString();
-  }
-
-  public static void appendBase16(StringBuilder buf, byte[] bytes) {
-    int base = 16;
-    for (byte b : bytes) {
-      int bi = 0xff & b;
-      int c = '0' + (bi / base) % base;
-      if (c > '9')
-        c = 'a' + (c - '0' - 10);
-      buf.append((char) c);
-      c = '0' + bi % base;
-      if (c > '9')
-        c = 'a' + (c - '0' - 10);
-      buf.append((char) c);
+
+    public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
+        return charset.encode(CharBuffer.wrap(cs));
+    }
+
+    public static byte[] byteBuffer2ByteArray(ByteBuffer bb) {
+        byte[] rawBase = new byte[bb.remaining()];
+        bb.get(rawBase);
+        return rawBase;
+    }
+
+    public static byte[] charSequence2Bytes(CharSequence sb, Charset charset) {
+        ByteBuffer bb = charSequence2ByteBuffer(sb, charset);
+        return byteBuffer2ByteArray(bb);
+    }
+
+    public static String toHexString(byte[] data) {
+        StringBuilder buffer = StringBuilderPool.DEFAULT.stringBuilder();
+        for (byte aData : data) {
+            buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
+            buffer.append(Integer.toHexString(aData & 0x0f));
+        }
+        return buffer.toString();
+    }
+
+    public static void appendBase16(StringBuilder buf, byte[] bytes) {
+        int base = 16;
+        for (byte b : bytes) {
+            int bi = 0xff & b;
+            int c = '0' + (bi / base) % base;
+            if (c > '9')
+                c = 'a' + (c - '0' - 10);
+            buf.append((char) c);
+            c = '0' + bi % base;
+            if (c > '9')
+                c = 'a' + (c - '0' - 10);
+            buf.append((char) c);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java b/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
index dd586658a..1a260f273 100644
--- a/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
+++ b/client/src/main/java/org/asynchttpclient/util/ThrowableUtil.java
@@ -14,18 +14,18 @@
 
 public final class ThrowableUtil {
 
-  private ThrowableUtil() {
-  }
+    private ThrowableUtil() {
+    }
 
-  /**
-   * @param <T>    the Throwable type
-   * @param t      the throwable whose stacktrace we want to remove
-   * @param clazz  the caller class
-   * @param method the caller method
-   * @return the input throwable with removed stacktrace
-   */
-  public static <T extends Throwable> T unknownStackTrace(T t, Class<?> clazz, String method) {
-    t.setStackTrace(new StackTraceElement[]{new StackTraceElement(clazz.getName(), method, null, -1)});
-    return t;
-  }
+    /**
+     * @param <T> the Throwable type
+     * @param t the throwable whose stacktrace we want to remove
+     * @param clazz the caller class
+     * @param method the caller method
+     * @return the input throwable with removed stacktrace
+     */
+    public static <T extends Throwable> T unknownStackTrace(T t, Class<?> clazz, String method) {
+        t.setStackTrace(new StackTraceElement[] { new StackTraceElement(clazz.getName(), method, null, -1) });
+        return t;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
index 8444a7bbc..0ef949839 100644
--- a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
@@ -12,133 +12,135 @@
  */
 package org.asynchttpclient.util;
 
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.Utf8UrlEncoder.encodeAndAppendQuery;
+
 import org.asynchttpclient.Param;
 import org.asynchttpclient.uri.Uri;
 
 import java.util.List;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.Utf8UrlEncoder.encodeAndAppendQuery;
-
 public enum UriEncoder {
 
-  FIXING {
-    public String encodePath(String path) {
-      return Utf8UrlEncoder.encodePath(path);
+    FIXING {
+
+        public String encodePath(String path) {
+            return Utf8UrlEncoder.encodePath(path);
+        }
+
+        private void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
+            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, name);
+            if (value != null) {
+                sb.append('=');
+                Utf8UrlEncoder.encodeAndAppendQueryElement(sb, value);
+            }
+            sb.append('&');
+        }
+
+        private void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+            for (Param param : queryParams)
+                encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
+        }
+
+        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
+            // concatenate encoded query + encoded query params
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            encodeAndAppendQuery(sb, query);
+            sb.append('&');
+            encodeAndAppendQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+
+        protected String withQueryWithoutParams(final String query) {
+            // encode query
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            encodeAndAppendQuery(sb, query);
+            return sb.toString();
+        }
+
+        protected String withoutQueryWithParams(final List<Param> queryParams) {
+            // concatenate encoded query params
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            encodeAndAppendQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+    }, //
+
+    RAW {
+
+        public String encodePath(String path) {
+            return path;
+        }
+
+        private void appendRawQueryParam(StringBuilder sb, String name, String value) {
+            sb.append(name);
+            if (value != null)
+                sb.append('=').append(value);
+            sb.append('&');
+        }
+
+        private void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+            for (Param param : queryParams)
+                appendRawQueryParam(sb, param.getName(), param.getValue());
+        }
+
+        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
+            // concatenate raw query + raw query params
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            sb.append(query);
+            appendRawQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+
+        protected String withQueryWithoutParams(final String query) {
+            // return raw query as is
+            return query;
+        }
+
+        protected String withoutQueryWithParams(final List<Param> queryParams) {
+            // concatenate raw queryParams
+            StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+            appendRawQueryParams(sb, queryParams);
+            sb.setLength(sb.length() - 1);
+            return sb.toString();
+        }
+    };
+
+    public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
+        return disableUrlEncoding ? RAW : FIXING;
     }
 
-    private void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
-      Utf8UrlEncoder.encodeAndAppendQueryElement(sb, name);
-      if (value != null) {
-        sb.append('=');
-        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, value);
-      }
-      sb.append('&');
-    }
+    protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
 
-    private void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
-      for (Param param : queryParams)
-        encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
-    }
-
-    protected String withQueryWithParams(final String query, final List<Param> queryParams) {
-      // concatenate encoded query + encoded query params
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      encodeAndAppendQuery(sb, query);
-      sb.append('&');
-      encodeAndAppendQueryParams(sb, queryParams);
-      sb.setLength(sb.length() - 1);
-      return sb.toString();
-    }
+    protected abstract String withQueryWithoutParams(final String query);
 
-    protected String withQueryWithoutParams(final String query) {
-      // encode query
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      encodeAndAppendQuery(sb, query);
-      return sb.toString();
-    }
+    protected abstract String withoutQueryWithParams(final List<Param> queryParams);
 
-    protected String withoutQueryWithParams(final List<Param> queryParams) {
-      // concatenate encoded query params
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      encodeAndAppendQueryParams(sb, queryParams);
-      sb.setLength(sb.length() - 1);
-      return sb.toString();
+    private String withQuery(final String query, final List<Param> queryParams) {
+        return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
     }
-  },
 
-  RAW {
-    public String encodePath(String path) {
-      return path;
+    private String withoutQuery(final List<Param> queryParams) {
+        return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
     }
 
-    private void appendRawQueryParam(StringBuilder sb, String name, String value) {
-      sb.append(name);
-      if (value != null)
-        sb.append('=').append(value);
-      sb.append('&');
+    public Uri encode(Uri uri, List<Param> queryParams) {
+        String newPath = encodePath(uri.getPath());
+        String newQuery = encodeQuery(uri.getQuery(), queryParams);
+        return new Uri(uri.getScheme(),//
+                uri.getUserInfo(),//
+                uri.getHost(),//
+                uri.getPort(),//
+                newPath,//
+                newQuery);
     }
 
-    private void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
-      for (Param param : queryParams)
-        appendRawQueryParam(sb, param.getName(), param.getValue());
-    }
+    protected abstract String encodePath(String path);
 
-    protected String withQueryWithParams(final String query, final List<Param> queryParams) {
-      // concatenate raw query + raw query params
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      sb.append(query);
-      appendRawQueryParams(sb, queryParams);
-      sb.setLength(sb.length() - 1);
-      return sb.toString();
+    private String encodeQuery(final String query, final List<Param> queryParams) {
+        return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
     }
-
-    protected String withQueryWithoutParams(final String query) {
-      // return raw query as is
-      return query;
-    }
-
-    protected String withoutQueryWithParams(final List<Param> queryParams) {
-      // concatenate raw queryParams
-      StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-      appendRawQueryParams(sb, queryParams);
-      sb.setLength(sb.length() - 1);
-      return sb.toString();
-    }
-  };
-
-  public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
-    return disableUrlEncoding ? RAW : FIXING;
-  }
-
-  protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
-
-  protected abstract String withQueryWithoutParams(final String query);
-
-  protected abstract String withoutQueryWithParams(final List<Param> queryParams);
-
-  private String withQuery(final String query, final List<Param> queryParams) {
-    return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
-  }
-
-  private String withoutQuery(final List<Param> queryParams) {
-    return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
-  }
-
-  public Uri encode(Uri uri, List<Param> queryParams) {
-    String newPath = encodePath(uri.getPath());
-    String newQuery = encodeQuery(uri.getQuery(), queryParams);
-    return new Uri(uri.getScheme(),
-            uri.getUserInfo(),
-            uri.getHost(),
-            uri.getPort(),
-            newPath,
-            newQuery);
-  }
-
-  protected abstract String encodePath(String path);
-
-  private String encodeQuery(final String query, final List<Param> queryParams) {
-    return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
index cdac64e11..7499b2567 100644
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -17,219 +17,219 @@
 
 public final class Utf8UrlEncoder {
 
-  // see http://tools.ietf.org/html/rfc3986#section-3.4
-  // ALPHA / DIGIT / "-" / "." / "_" / "~"
-  private static final BitSet RFC3986_UNRESERVED_CHARS = new BitSet();
-  // gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"
-  private static final BitSet RFC3986_GENDELIM_CHARS = new BitSet();
-  // "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
-  private static final BitSet RFC3986_SUBDELIM_CHARS = new BitSet();
-  // gen-delims / sub-delims
-  private static final BitSet RFC3986_RESERVED_CHARS = new BitSet();
-  // unreserved / pct-encoded / sub-delims / ":" / "@"
-  private static final BitSet RFC3986_PCHARS = new BitSet();
-  private static final BitSet BUILT_PATH_UNTOUCHED_CHARS = new BitSet();
-  private static final BitSet BUILT_QUERY_UNTOUCHED_CHARS = new BitSet();
-  // http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
-  private static final BitSet FORM_URL_ENCODED_SAFE_CHARS = new BitSet();
-  private static final char[] HEX = "0123456789ABCDEF".toCharArray();
-
-  static {
-    for (int i = 'a'; i <= 'z'; ++i) {
-      RFC3986_UNRESERVED_CHARS.set(i);
-    }
-    for (int i = 'A'; i <= 'Z'; ++i) {
-      RFC3986_UNRESERVED_CHARS.set(i);
-    }
-    for (int i = '0'; i <= '9'; ++i) {
-      RFC3986_UNRESERVED_CHARS.set(i);
-    }
-    RFC3986_UNRESERVED_CHARS.set('-');
-    RFC3986_UNRESERVED_CHARS.set('.');
-    RFC3986_UNRESERVED_CHARS.set('_');
-    RFC3986_UNRESERVED_CHARS.set('~');
-  }
-
-  static {
-    RFC3986_GENDELIM_CHARS.set(':');
-    RFC3986_GENDELIM_CHARS.set('/');
-    RFC3986_GENDELIM_CHARS.set('?');
-    RFC3986_GENDELIM_CHARS.set('#');
-    RFC3986_GENDELIM_CHARS.set('[');
-    RFC3986_GENDELIM_CHARS.set(']');
-    RFC3986_GENDELIM_CHARS.set('@');
-  }
-
-  static {
-    RFC3986_SUBDELIM_CHARS.set('!');
-    RFC3986_SUBDELIM_CHARS.set('$');
-    RFC3986_SUBDELIM_CHARS.set('&');
-    RFC3986_SUBDELIM_CHARS.set('\'');
-    RFC3986_SUBDELIM_CHARS.set('(');
-    RFC3986_SUBDELIM_CHARS.set(')');
-    RFC3986_SUBDELIM_CHARS.set('*');
-    RFC3986_SUBDELIM_CHARS.set('+');
-    RFC3986_SUBDELIM_CHARS.set(',');
-    RFC3986_SUBDELIM_CHARS.set(';');
-    RFC3986_SUBDELIM_CHARS.set('=');
-  }
-
-  static {
-    RFC3986_RESERVED_CHARS.or(RFC3986_GENDELIM_CHARS);
-    RFC3986_RESERVED_CHARS.or(RFC3986_SUBDELIM_CHARS);
-  }
-
-  static {
-    RFC3986_PCHARS.or(RFC3986_UNRESERVED_CHARS);
-    RFC3986_PCHARS.or(RFC3986_SUBDELIM_CHARS);
-    RFC3986_PCHARS.set(':');
-    RFC3986_PCHARS.set('@');
-  }
-
-  static {
-    BUILT_PATH_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
-    BUILT_PATH_UNTOUCHED_CHARS.set('%');
-    BUILT_PATH_UNTOUCHED_CHARS.set('/');
-  }
-
-  static {
-    BUILT_QUERY_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
-    BUILT_QUERY_UNTOUCHED_CHARS.set('%');
-    BUILT_QUERY_UNTOUCHED_CHARS.set('/');
-    BUILT_QUERY_UNTOUCHED_CHARS.set('?');
-  }
-
-  static {
-    for (int i = 'a'; i <= 'z'; ++i) {
-      FORM_URL_ENCODED_SAFE_CHARS.set(i);
-    }
-    for (int i = 'A'; i <= 'Z'; ++i) {
-      FORM_URL_ENCODED_SAFE_CHARS.set(i);
-    }
-    for (int i = '0'; i <= '9'; ++i) {
-      FORM_URL_ENCODED_SAFE_CHARS.set(i);
-    }
-
-    FORM_URL_ENCODED_SAFE_CHARS.set('-');
-    FORM_URL_ENCODED_SAFE_CHARS.set('.');
-    FORM_URL_ENCODED_SAFE_CHARS.set('_');
-    FORM_URL_ENCODED_SAFE_CHARS.set('*');
-  }
-
-  private Utf8UrlEncoder() {
-  }
-
-  public static String encodePath(String input) {
-    StringBuilder sb = lazyAppendEncoded(null, input, BUILT_PATH_UNTOUCHED_CHARS, false);
-    return sb == null ? input : sb.toString();
-  }
-
-  public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
-    return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
-  }
-
-  public static String encodeQueryElement(String input) {
-    StringBuilder sb = new StringBuilder(input.length() + 6);
-    encodeAndAppendQueryElement(sb, input);
-    return sb.toString();
-  }
-
-  public static StringBuilder encodeAndAppendQueryElement(StringBuilder sb, CharSequence input) {
-    return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, false);
-  }
-
-  public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSequence input) {
-    return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
-  }
-
-  public static String percentEncodeQueryElement(String input) {
-    if (input == null) {
-      return null;
-    }
-    StringBuilder sb = new StringBuilder(input.length() + 6);
-    encodeAndAppendPercentEncoded(sb, input);
-    return sb.toString();
-  }
-
-  public static StringBuilder encodeAndAppendPercentEncoded(StringBuilder sb, CharSequence input) {
-    return appendEncoded(sb, input, RFC3986_UNRESERVED_CHARS, false);
-  }
-
-  private static StringBuilder lazyInitStringBuilder(CharSequence input, int firstNonUsAsciiPosition) {
-    StringBuilder sb = new StringBuilder(input.length() + 6);
-    for (int i = 0; i < firstNonUsAsciiPosition; i++) {
-      sb.append(input.charAt(i));
-    }
-    return sb;
-  }
-
-  private static StringBuilder lazyAppendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
-    int c;
-    for (int i = 0; i < input.length(); i += Character.charCount(c)) {
-      c = Character.codePointAt(input, i);
-      if (c <= 127) {
-        if (dontNeedEncoding.get(c)) {
-          if (sb != null) {
-            sb.append((char) c);
-          }
-        } else {
-          if (sb == null) {
-            sb = lazyInitStringBuilder(input, i);
-          }
-          appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+    // see http://tools.ietf.org/html/rfc3986#section-3.4
+    // ALPHA / DIGIT / "-" / "." / "_" / "~"
+    private static final BitSet RFC3986_UNRESERVED_CHARS = new BitSet();
+    static {
+        for (int i = 'a'; i <= 'z'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+        }
+        for (int i = 'A'; i <= 'Z'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+        }
+        for (int i = '0'; i <= '9'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+        }
+        RFC3986_UNRESERVED_CHARS.set('-');
+        RFC3986_UNRESERVED_CHARS.set('.');
+        RFC3986_UNRESERVED_CHARS.set('_');
+        RFC3986_UNRESERVED_CHARS.set('~');
+    }
+
+    // gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+    private static final BitSet RFC3986_GENDELIM_CHARS = new BitSet();
+    static {
+        RFC3986_GENDELIM_CHARS.set(':');
+        RFC3986_GENDELIM_CHARS.set('/');
+        RFC3986_GENDELIM_CHARS.set('?');
+        RFC3986_GENDELIM_CHARS.set('#');
+        RFC3986_GENDELIM_CHARS.set('[');
+        RFC3986_GENDELIM_CHARS.set(']');
+        RFC3986_GENDELIM_CHARS.set('@');
+    }
+
+    // "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
+    private static final BitSet RFC3986_SUBDELIM_CHARS = new BitSet();
+    static {
+        RFC3986_SUBDELIM_CHARS.set('!');
+        RFC3986_SUBDELIM_CHARS.set('$');
+        RFC3986_SUBDELIM_CHARS.set('&');
+        RFC3986_SUBDELIM_CHARS.set('\'');
+        RFC3986_SUBDELIM_CHARS.set('(');
+        RFC3986_SUBDELIM_CHARS.set(')');
+        RFC3986_SUBDELIM_CHARS.set('*');
+        RFC3986_SUBDELIM_CHARS.set('+');
+        RFC3986_SUBDELIM_CHARS.set(',');
+        RFC3986_SUBDELIM_CHARS.set(';');
+        RFC3986_SUBDELIM_CHARS.set('=');
+    }
+
+    // gen-delims / sub-delims
+    private static final BitSet RFC3986_RESERVED_CHARS = new BitSet();
+    static {
+        RFC3986_RESERVED_CHARS.or(RFC3986_GENDELIM_CHARS);
+        RFC3986_RESERVED_CHARS.or(RFC3986_SUBDELIM_CHARS);
+    }
+
+    // unreserved / pct-encoded / sub-delims / ":" / "@"
+    private static final BitSet RFC3986_PCHARS = new BitSet();
+    static {
+        RFC3986_PCHARS.or(RFC3986_UNRESERVED_CHARS);
+        RFC3986_PCHARS.or(RFC3986_SUBDELIM_CHARS);
+        RFC3986_PCHARS.set(':');
+        RFC3986_PCHARS.set('@');
+    }
+
+    private static final BitSet BUILT_PATH_UNTOUCHED_CHARS = new BitSet();
+    static {
+        BUILT_PATH_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+        BUILT_PATH_UNTOUCHED_CHARS.set('%');
+        BUILT_PATH_UNTOUCHED_CHARS.set('/');
+    }
+
+    private static final BitSet BUILT_QUERY_UNTOUCHED_CHARS = new BitSet();
+    static {
+        BUILT_QUERY_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+        BUILT_QUERY_UNTOUCHED_CHARS.set('%');
+        BUILT_QUERY_UNTOUCHED_CHARS.set('/');
+        BUILT_QUERY_UNTOUCHED_CHARS.set('?');
+    }
+
+    // http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
+    private static final BitSet FORM_URL_ENCODED_SAFE_CHARS = new BitSet();
+    static {
+        for (int i = 'a'; i <= 'z'; ++i) {
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
         }
-      } else {
-        if (sb == null) {
-          sb = lazyInitStringBuilder(input, i);
+        for (int i = 'A'; i <= 'Z'; ++i) {
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
         }
-        appendMultiByteEncoded(sb, c);
-      }
-    }
-    return sb;
-  }
-
-  private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
-    int c;
-    for (int i = 0; i < input.length(); i += Character.charCount(c)) {
-      c = Character.codePointAt(input, i);
-      if (c <= 127) {
-        if (dontNeedEncoding.get(c)) {
-          sb.append((char) c);
+        for (int i = '0'; i <= '9'; ++i) {
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
+        }
+
+        FORM_URL_ENCODED_SAFE_CHARS.set('-');
+        FORM_URL_ENCODED_SAFE_CHARS.set('.');
+        FORM_URL_ENCODED_SAFE_CHARS.set('_');
+        FORM_URL_ENCODED_SAFE_CHARS.set('*');
+    }
+
+    private static final char[] HEX = "0123456789ABCDEF".toCharArray();
+
+    private Utf8UrlEncoder() {
+    }
+
+    public static String encodePath(String input) {
+        StringBuilder sb = lazyAppendEncoded(null, input, BUILT_PATH_UNTOUCHED_CHARS, false);
+        return sb == null ? input : sb.toString();
+    }
+
+    public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
+        return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
+    }
+
+    public static String encodeQueryElement(String input) {
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        encodeAndAppendQueryElement(sb, input);
+        return sb.toString();
+    }
+
+    public static StringBuilder encodeAndAppendQueryElement(StringBuilder sb, CharSequence input) {
+        return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, false);
+    }
+
+    public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSequence input) {
+        return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
+    }
+
+    public static String percentEncodeQueryElement(String input) {
+        if (input == null) {
+            return null;
+        }
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        encodeAndAppendPercentEncoded(sb, input);
+        return sb.toString();
+    }
+
+    public static StringBuilder encodeAndAppendPercentEncoded(StringBuilder sb, CharSequence input) {
+        return appendEncoded(sb, input, RFC3986_UNRESERVED_CHARS, false);
+    }
+
+    private static StringBuilder lazyInitStringBuilder(CharSequence input, int firstNonUsAsciiPosition) {
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        for (int i = 0; i < firstNonUsAsciiPosition; i++) {
+            sb.append(input.charAt(i));
+        }
+        return sb;
+    }
+
+    private static StringBuilder lazyAppendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+        int c;
+        for (int i = 0; i < input.length(); i += Character.charCount(c)) {
+            c = Character.codePointAt(input, i);
+            if (c <= 127) {
+                if (dontNeedEncoding.get(c)) {
+                    if (sb != null) {
+                        sb.append((char) c);
+                    }
+                } else {
+                    if (sb == null) {
+                        sb = lazyInitStringBuilder(input, i);
+                    }
+                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+                }
+            } else {
+                if (sb == null) {
+                    sb = lazyInitStringBuilder(input, i);
+                }
+                appendMultiByteEncoded(sb, c);
+            }
+        }
+        return sb;
+    }
+
+    private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+        int c;
+        for (int i = 0; i < input.length(); i += Character.charCount(c)) {
+            c = Character.codePointAt(input, i);
+            if (c <= 127) {
+                if (dontNeedEncoding.get(c)) {
+                    sb.append((char) c);
+                } else {
+                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+                }
+            } else {
+                appendMultiByteEncoded(sb, c);
+            }
+        }
+        return sb;
+    }
+
+    private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
+
+        if (value == ' ' && encodeSpaceAsPlus) {
+            sb.append('+');
+            return;
+        }
+
+        sb.append('%');
+        sb.append(HEX[value >> 4]);
+        sb.append(HEX[value & 0xF]);
+    }
+
+    private static void appendMultiByteEncoded(StringBuilder sb, int value) {
+        if (value < 0x800) {
+            appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+        } else if (value < 0x10000) {
+            appendSingleByteEncoded(sb, (0xe0 | (value >> 12)), false);
+            appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
         } else {
-          appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+            appendSingleByteEncoded(sb, (0xf0 | (value >> 18)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f), false);
+            appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
         }
-      } else {
-        appendMultiByteEncoded(sb, c);
-      }
-    }
-    return sb;
-  }
-
-  private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
-
-    if (value == ' ' && encodeSpaceAsPlus) {
-      sb.append('+');
-      return;
-    }
-
-    sb.append('%');
-    sb.append(HEX[value >> 4]);
-    sb.append(HEX[value & 0xF]);
-  }
-
-  private static void appendMultiByteEncoded(StringBuilder sb, int value) {
-    if (value < 0x800) {
-      appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
-      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
-    } else if (value < 0x10000) {
-      appendSingleByteEncoded(sb, (0xe0 | (value >> 12)), false);
-      appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)), false);
-      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
-    } else {
-      appendSingleByteEncoded(sb, (0xf0 | (value >> 18)), false);
-      appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f), false);
-      appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f), false);
-      appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
-    }
-  }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index a6df2fccf..551150933 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -14,6 +14,17 @@
 package org.asynchttpclient.webdav;
 
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -27,166 +38,164 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
 /**
  * Simple {@link AsyncHandler} that add support for WebDav's response manipulation.
  *
  * @param <T> the result type
  */
 public abstract class WebDavCompletionHandlerBase<T> implements AsyncHandler<T> {
-  private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
-  private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
-  private HttpResponseStatus status;
-  private HttpHeaders headers;
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final State onBodyPartReceived(final HttpResponseBodyPart content) {
-    bodyParts.add(content);
-    return State.CONTINUE;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final State onStatusReceived(final HttpResponseStatus status) {
-    this.status = status;
-    return State.CONTINUE;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final State onHeadersReceived(final HttpHeaders headers) {
-    this.headers = headers;
-    return State.CONTINUE;
-  }
-
-  private Document readXMLResponse(InputStream stream) {
-    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-    Document document;
-    try {
-      document = factory.newDocumentBuilder().parse(stream);
-      parse(document);
-    } catch (SAXException | IOException | ParserConfigurationException e) {
-      logger.error(e.getMessage(), e);
-      throw new RuntimeException(e);
-    }
-    return document;
-  }
-
-  private void parse(Document document) {
-    Element element = document.getDocumentElement();
-    NodeList statusNode = element.getElementsByTagName("status");
-    for (int i = 0; i < statusNode.getLength(); i++) {
-      Node node = statusNode.item(i);
-
-      String value = node.getFirstChild().getNodeValue();
-      int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
-      String statusText = value.substring(value.lastIndexOf(" "));
-      status = new HttpStatusWrapper(status, statusText, statusCode);
-    }
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final T onCompleted() throws Exception {
-    if (status != null) {
-      Document document = null;
-      if (status.getStatusCode() == 207) {
-        document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
-      }
-      // recompute response as readXMLResponse->parse might have updated it
-      return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
-    } else {
-      throw new IllegalStateException("Status is null");
-    }
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void onThrowable(Throwable t) {
-    logger.debug(t.getMessage(), t);
-  }
-
-  /**
-   * Invoked once the HTTP response has been fully read.
-   *
-   * @param response The {@link org.asynchttpclient.Response}
-   * @return Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
-   * @throws Exception if something wrong happens
-   */
-  abstract public T onCompleted(WebDavResponse response) throws Exception;
-
-  private class HttpStatusWrapper extends HttpResponseStatus {
-
-    private final HttpResponseStatus wrapped;
-
-    private final String statusText;
-
-    private final int statusCode;
-
-    HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int statusCode) {
-      super(wrapper.getUri());
-      this.wrapped = wrapper;
-      this.statusText = statusText;
-      this.statusCode = statusCode;
-    }
+    private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
 
-    @Override
-    public int getStatusCode() {
-      return (statusText == null ? wrapped.getStatusCode() : statusCode);
-    }
+    private HttpResponseStatus status;
+    private HttpHeaders headers;
+    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public String getStatusText() {
-      return (statusText == null ? wrapped.getStatusText() : statusText);
+    public final State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+        bodyParts.add(content);
+        return State.CONTINUE;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public String getProtocolName() {
-      return wrapped.getProtocolName();
+    public final State onStatusReceived(final HttpResponseStatus status) throws Exception {
+        this.status = status;
+        return State.CONTINUE;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public int getProtocolMajorVersion() {
-      return wrapped.getProtocolMajorVersion();
+    public final State onHeadersReceived(final HttpHeaders headers) throws Exception {
+        this.headers = headers;
+        return State.CONTINUE;
     }
 
-    @Override
-    public int getProtocolMinorVersion() {
-      return wrapped.getProtocolMinorVersion();
+    private Document readXMLResponse(InputStream stream) {
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        Document document = null;
+        try {
+            document = factory.newDocumentBuilder().parse(stream);
+            parse(document);
+        } catch (SAXException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (IOException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (ParserConfigurationException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        }
+        return document;
     }
 
+    private void parse(Document document) {
+        Element element = document.getDocumentElement();
+        NodeList statusNode = element.getElementsByTagName("status");
+        for (int i = 0; i < statusNode.getLength(); i++) {
+            Node node = statusNode.item(i);
+
+            String value = node.getFirstChild().getNodeValue();
+            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
+            String statusText = value.substring(value.lastIndexOf(" "));
+            status = new HttpStatusWrapper(status, statusText, statusCode);
+        }
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public String getProtocolText() {
-      return wrapped.getStatusText();
+    public final T onCompleted() throws Exception {
+        if (status != null) {
+            Document document = null;
+            if (status.getStatusCode() == 207) {
+                document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
+            }
+            // recompute response as readXMLResponse->parse might have updated it
+            return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
+        } else {
+            throw new IllegalStateException("Status is null");
+        }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public SocketAddress getRemoteAddress() {
-      return wrapped.getRemoteAddress();
+    public void onThrowable(Throwable t) {
+        logger.debug(t.getMessage(), t);
     }
 
-    @Override
-    public SocketAddress getLocalAddress() {
-      return wrapped.getLocalAddress();
+    /**
+     * Invoked once the HTTP response has been fully read.
+     *
+     * @param response The {@link org.asynchttpclient.Response}
+     * @return Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @throws Exception if something wrong happens
+     */
+    abstract public T onCompleted(WebDavResponse response) throws Exception;
+
+    private class HttpStatusWrapper extends HttpResponseStatus {
+
+        private final HttpResponseStatus wrapped;
+
+        private final String statusText;
+
+        private final int statusCode;
+
+        public HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int statusCode) {
+            super(wrapper.getUri());
+            this.wrapped = wrapper;
+            this.statusText = statusText;
+            this.statusCode = statusCode;
+        }
+
+        @Override
+        public int getStatusCode() {
+            return (statusText == null ? wrapped.getStatusCode() : statusCode);
+        }
+
+        @Override
+        public String getStatusText() {
+            return (statusText == null ? wrapped.getStatusText() : statusText);
+        }
+
+        @Override
+        public String getProtocolName() {
+            return wrapped.getProtocolName();
+        }
+
+        @Override
+        public int getProtocolMajorVersion() {
+            return wrapped.getProtocolMajorVersion();
+        }
+
+        @Override
+        public int getProtocolMinorVersion() {
+            return wrapped.getProtocolMinorVersion();
+        }
+
+        @Override
+        public String getProtocolText() {
+            return wrapped.getStatusText();
+        }
+
+        @Override
+        public SocketAddress getRemoteAddress() {
+            return wrapped.getRemoteAddress();
+        }
+        
+        @Override
+        public SocketAddress getLocalAddress() {
+            return wrapped.getLocalAddress();
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
index b5c4e23ec..78f26ac70 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
@@ -14,9 +14,6 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
-import org.w3c.dom.Document;
 
 import java.io.InputStream;
 import java.net.SocketAddress;
@@ -24,97 +21,101 @@
 import java.nio.charset.Charset;
 import java.util.List;
 
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.w3c.dom.Document;
+
 /**
  * Customized {@link Response} which add support for getting the response's body as an XML document (@link WebDavResponse#getBodyAsXML}
  */
 public class WebDavResponse implements Response {
 
-  private final Response response;
-  private final Document document;
+    private final Response response;
+    private final Document document;
 
-  WebDavResponse(Response response, Document document) {
-    this.response = response;
-    this.document = document;
-  }
+    public WebDavResponse(Response response, Document document) {
+        this.response = response;
+        this.document = document;
+    }
 
-  public int getStatusCode() {
-    return response.getStatusCode();
-  }
+    public int getStatusCode() {
+        return response.getStatusCode();
+    }
 
-  public String getStatusText() {
-    return response.getStatusText();
-  }
+    public String getStatusText() {
+        return response.getStatusText();
+    }
 
-  @Override
-  public byte[] getResponseBodyAsBytes() {
-    return response.getResponseBodyAsBytes();
-  }
+    @Override
+    public byte[] getResponseBodyAsBytes() {
+        return response.getResponseBodyAsBytes();
+    }
 
-  public ByteBuffer getResponseBodyAsByteBuffer() {
-    return response.getResponseBodyAsByteBuffer();
-  }
+    public ByteBuffer getResponseBodyAsByteBuffer() {
+        return response.getResponseBodyAsByteBuffer();
+    }
 
-  public InputStream getResponseBodyAsStream() {
-    return response.getResponseBodyAsStream();
-  }
+    public InputStream getResponseBodyAsStream() {
+        return response.getResponseBodyAsStream();
+    }
 
-  public String getResponseBody() {
-    return response.getResponseBody();
-  }
+    public String getResponseBody() {
+        return response.getResponseBody();
+    }
 
-  public String getResponseBody(Charset charset) {
-    return response.getResponseBody(charset);
-  }
+    public String getResponseBody(Charset charset) {
+        return response.getResponseBody(charset);
+    }
 
-  public Uri getUri() {
-    return response.getUri();
-  }
+    public Uri getUri() {
+        return response.getUri();
+    }
 
-  public String getContentType() {
-    return response.getContentType();
-  }
+    public String getContentType() {
+        return response.getContentType();
+    }
 
-  public String getHeader(CharSequence name) {
-    return response.getHeader(name);
-  }
+    public String getHeader(CharSequence name) {
+        return response.getHeader(name);
+    }
 
-  public List<String> getHeaders(CharSequence name) {
-    return response.getHeaders(name);
-  }
+    public List<String> getHeaders(CharSequence name) {
+        return response.getHeaders(name);
+    }
 
-  public HttpHeaders getHeaders() {
-    return response.getHeaders();
-  }
+    public HttpHeaders getHeaders() {
+        return response.getHeaders();
+    }
 
-  public boolean isRedirected() {
-    return response.isRedirected();
-  }
+    public boolean isRedirected() {
+        return response.isRedirected();
+    }
 
-  public List<Cookie> getCookies() {
-    return response.getCookies();
-  }
+    public List<Cookie> getCookies() {
+        return response.getCookies();
+    }
 
-  public boolean hasResponseStatus() {
-    return response.hasResponseStatus();
-  }
+    public boolean hasResponseStatus() {
+        return response.hasResponseStatus();
+    }
 
-  public boolean hasResponseHeaders() {
-    return response.hasResponseHeaders();
-  }
+    public boolean hasResponseHeaders() {
+        return response.hasResponseHeaders();
+    }
 
-  public boolean hasResponseBody() {
-    return response.hasResponseBody();
-  }
+    public boolean hasResponseBody() {
+        return response.hasResponseBody();
+    }
 
-  public SocketAddress getRemoteAddress() {
-    return response.getRemoteAddress();
-  }
+    public SocketAddress getRemoteAddress() {
+        return response.getRemoteAddress();
+    }
 
-  public SocketAddress getLocalAddress() {
-    return response.getLocalAddress();
-  }
+    public SocketAddress getLocalAddress() {
+        return response.getLocalAddress();
+    }
 
-  public Document getBodyAsXML() {
-    return document;
-  }
+    public Document getBodyAsXML() {
+        return document;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocket.java b/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
index 7b64468ba..e5dd664e4 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocket.java
@@ -13,202 +13,202 @@
  */
 package org.asynchttpclient.ws;
 
+import java.net.SocketAddress;
+
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.util.concurrent.Future;
 
-import java.net.SocketAddress;
-
 /**
  * A WebSocket client
  */
 public interface WebSocket {
 
-  /**
-   * @return the headers received in the Upgrade response
-   */
-  HttpHeaders getUpgradeHeaders();
-
-  /**
-   * Get remote address client initiated request to.
-   *
-   * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
-   */
-  SocketAddress getRemoteAddress();
-
-  /**
-   * Get local address client initiated request from.
-   *
-   * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
-   */
-  SocketAddress getLocalAddress();
-
-  /**
-   * Send a full text frame
-   *
-   * @param payload a text payload
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendTextFrame(String payload);
-
-  /**
-   * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-   *
-   * @param payload       a text fragment.
-   * @param finalFragment flag indicating whether or not this is the final fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv);
-
-  /**
-   * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-   *
-   * @param payload       a ByteBuf fragment.
-   * @param finalFragment flag indicating whether or not this is the final fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-  /**
-   * Send a full binary frame.
-   *
-   * @param payload a binary payload
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendBinaryFrame(byte[] payload);
-
-  /**
-   * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-   *
-   * @param payload       a binary payload
-   * @param finalFragment flag indicating whether or not this is the last fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv);
-
-  /**
-   * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
-   *
-   * @param payload       a ByteBuf payload
-   * @param finalFragment flag indicating whether or not this is the last fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-  /**
-   * Send a text continuation frame. The last fragment must have finalFragment set to true.
-   *
-   * @param payload       the text fragment
-   * @param finalFragment flag indicating whether or not this is the last fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv);
-
-  /**
-   * Send a binary continuation frame. The last fragment must have finalFragment set to true.
-   *
-   * @param payload       the binary fragment
-   * @param finalFragment flag indicating whether or not this is the last fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv);
-
-  /**
-   * Send a continuation frame (those are actually untyped as counterpart must have memorized first fragmented frame type). The last fragment must have finalFragment set to true.
-   *
-   * @param payload       a ByteBuf fragment
-   * @param finalFragment flag indicating whether or not this is the last fragment
-   * @param rsv           extension bits, 0 otherwise
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv);
-
-  /**
-   * Send a empty ping frame
-   *
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPingFrame();
-
-  /**
-   * Send a ping frame with a byte array payload (limited to 125 bytes or less).
-   *
-   * @param payload the payload.
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPingFrame(byte[] payload);
-
-  /**
-   * Send a ping frame with a ByteBuf payload (limited to 125 bytes or less).
-   *
-   * @param payload the payload.
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPingFrame(ByteBuf payload);
-
-  /**
-   * Send a empty pong frame
-   *
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPongFrame();
-
-  /**
-   * Send a pong frame with a byte array payload (limited to 125 bytes or less).
-   *
-   * @param payload the payload.
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPongFrame(byte[] payload);
-
-  /**
-   * Send a pong frame with a ByteBuf payload (limited to 125 bytes or less).
-   *
-   * @param payload the payload.
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendPongFrame(ByteBuf payload);
-
-  /**
-   * Send a empty close frame.
-   *
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendCloseFrame();
-
-  /**
-   * Send a empty close frame.
-   *
-   * @param statusCode a status code
-   * @param reasonText a reason
-   * @return a future that will be completed once the frame will be actually written on the wire
-   */
-  Future<Void> sendCloseFrame(int statusCode, String reasonText);
-
-  /**
-   * @return <code>true</code> if the WebSocket is open/connected.
-   */
-  boolean isOpen();
-
-  /**
-   * Add a {@link WebSocketListener}
-   *
-   * @param l a {@link WebSocketListener}
-   * @return this
-   */
-  WebSocket addWebSocketListener(WebSocketListener l);
-
-  /**
-   * Remove a {@link WebSocketListener}
-   *
-   * @param l a {@link WebSocketListener}
-   * @return this
-   */
-  WebSocket removeWebSocketListener(WebSocketListener l);
+    /**
+     * @return the headers received in the Upgrade response
+     */
+    HttpHeaders getUpgradeHeaders();
+
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
+     */
+    SocketAddress getRemoteAddress();
+
+    /**
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
+     */
+    SocketAddress getLocalAddress();
+
+    /**
+     * Send a full text frame
+     * 
+     * @param payload a text payload
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendTextFrame(String payload);
+
+    /**
+     * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+     * 
+     * @param payload a text fragment.
+     * @param finalFragment flag indicating whether or not this is the final fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendTextFrame(String payload, boolean finalFragment, int rsv);
+
+    /**
+     * Allows sending a text frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+     * 
+     * @param payload a ByteBuf fragment.
+     * @param finalFragment flag indicating whether or not this is the final fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendTextFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+    /**
+     * Send a full binary frame.
+     * 
+     * @param payload a binary payload
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendBinaryFrame(byte[] payload);
+
+    /**
+     * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+     * 
+     * @param payload a binary payload
+     * @param finalFragment flag indicating whether or not this is the last fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendBinaryFrame(byte[] payload, boolean finalFragment, int rsv);
+
+    /**
+     * Allows sending a binary frame with fragmentation or extension bits. When using fragmentation, the next fragments must be sent with sendContinuationFrame.
+     * 
+     * @param payload a ByteBuf payload
+     * @param finalFragment flag indicating whether or not this is the last fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendBinaryFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+    /**
+     * Send a text continuation frame. The last fragment must have finalFragment set to true.
+     * 
+     * @param payload the text fragment
+     * @param finalFragment flag indicating whether or not this is the last fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendContinuationFrame(String payload, boolean finalFragment, int rsv);
+
+    /**
+     * Send a binary continuation frame. The last fragment must have finalFragment set to true.
+     * 
+     * @param payload the binary fragment
+     * @param finalFragment flag indicating whether or not this is the last fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendContinuationFrame(byte[] payload, boolean finalFragment, int rsv);
+
+    /**
+     * Send a continuation frame (those are actually untyped as counterpart must have memorized first fragmented frame type). The last fragment must have finalFragment set to true.
+     * 
+     * @param payload a ByteBuf fragment
+     * @param finalFragment flag indicating whether or not this is the last fragment
+     * @param rsv extension bits, 0 otherwise
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendContinuationFrame(ByteBuf payload, boolean finalFragment, int rsv);
+
+    /**
+     * Send a empty ping frame
+     * 
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPingFrame();
+
+    /**
+     * Send a ping frame with a byte array payload (limited to 125 bytes or less).
+     * 
+     * @param payload the payload.
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPingFrame(byte[] payload);
+
+    /**
+     * Send a ping frame with a ByteBuf payload (limited to 125 bytes or less).
+     * 
+     * @param payload the payload.
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPingFrame(ByteBuf payload);
+
+    /**
+     * Send a empty pong frame
+     * 
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPongFrame();
+
+    /**
+     * Send a pong frame with a byte array payload (limited to 125 bytes or less).
+     * 
+     * @param payload the payload.
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPongFrame(byte[] payload);
+
+    /**
+     * Send a pong frame with a ByteBuf payload (limited to 125 bytes or less).
+     * 
+     * @param payload the payload.
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendPongFrame(ByteBuf payload);
+
+    /**
+     * Send a empty close frame.
+     *
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendCloseFrame();
+
+    /**
+     * Send a empty close frame.
+     *
+     * @param statusCode a status code
+     * @param reasonText a reason
+     * @return a future that will be completed once the frame will be actually written on the wire
+     */
+    Future<Void> sendCloseFrame(int statusCode, String reasonText);
+
+    /**
+     * @return <code>true</code> if the WebSocket is open/connected.
+     */
+    boolean isOpen();
+
+    /**
+     * Add a {@link WebSocketListener}
+     * 
+     * @param l a {@link WebSocketListener}
+     * @return this
+     */
+    WebSocket addWebSocketListener(WebSocketListener l);
+
+    /**
+     * Remove a {@link WebSocketListener}
+     * 
+     * @param l a {@link WebSocketListener}
+     * @return this
+     */
+    WebSocket removeWebSocketListener(WebSocketListener l);
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
index 330d2574b..6902ef8d9 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
@@ -17,65 +17,64 @@
  */
 public interface WebSocketListener {
 
-  /**
-   * Invoked when the {@link WebSocket} is open.
-   *
-   * @param websocket the WebSocket
-   */
-  void onOpen(WebSocket websocket);
+    /**
+     * Invoked when the {@link WebSocket} is open.
+     *
+     * @param websocket the WebSocket
+     */
+    void onOpen(WebSocket websocket);
 
-  /**
-   * Invoked when the {@link WebSocket} is closed.
-   *
-   * @param websocket the WebSocket
-   * @param code      the status code
-   * @param reason    the reason message
-   * @see "http://tools.ietf.org/html/rfc6455#section-5.5.1"
-   */
-  void onClose(WebSocket websocket, int code, String reason);
+    /**
+     * Invoked when the {@link WebSocket} is closed.
+     * 
+     * @see "http://tools.ietf.org/html/rfc6455#section-5.5.1"
+     *
+     * @param websocket the WebSocket
+     * @param code the status code
+     * @param reason the reason message
+     */
+    void onClose(WebSocket websocket, int code, String reason);
 
-  /**
-   * Invoked when the {@link WebSocket} crashes.
-   *
-   * @param t a {@link Throwable}
-   */
-  void onError(Throwable t);
+    /**
+     * Invoked when the {@link WebSocket} crashes.
+     *
+     * @param t a {@link Throwable}
+     */
+    void onError(Throwable t);
 
-  /**
-   * Invoked when a binary frame is received.
-   *
-   * @param payload       a byte array
-   * @param finalFragment true if this frame is the final fragment
-   * @param rsv           extension bits
-   */
-  default void onBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
-  }
+    /**
+     * Invoked when a binary frame is received.
+     * 
+     * @param payload a byte array
+     * @param finalFragment true if this frame is the final fragment
+     * @param rsv extension bits
+     */
+    default void onBinaryFrame(byte[] payload, boolean finalFragment, int rsv) {
+    };
 
-  /**
-   * Invoked when a text frame is received.
-   *
-   * @param payload       a UTF-8 {@link String} message
-   * @param finalFragment true if this frame is the final fragment
-   * @param rsv           extension bits
-   */
-  default void onTextFrame(String payload, boolean finalFragment, int rsv) {
-  }
+    /**
+     * Invoked when a text frame is received.
+     * 
+     * @param payload a UTF-8 {@link String} message
+     * @param finalFragment true if this frame is the final fragment
+     * @param rsv extension bits
+     */
+    default void onTextFrame(String payload, boolean finalFragment, int rsv) {
+    };
 
-  ;
+    /**
+     * Invoked when a ping frame is received
+     * 
+     * @param payload a byte array
+     */
+    default void onPingFrame(byte[] payload) {
+    };
 
-  /**
-   * Invoked when a ping frame is received
-   *
-   * @param payload a byte array
-   */
-  default void onPingFrame(byte[] payload) {
-  }
-
-  /**
-   * Invoked when a pong frame is received
-   *
-   * @param payload a byte array
-   */
-  default void onPongFrame(byte[] payload) {
-  }
+    /**
+     * Invoked when a pong frame is received
+     * 
+     * @param payload a byte array
+     */
+    default void onPongFrame(byte[] payload) {
+    };
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
index a4624d633..f6f1a3979 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
@@ -14,134 +14,122 @@
 package org.asynchttpclient.ws;
 
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.netty.ws.NettyWebSocket;
 
-import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.SWITCHING_PROTOCOLS_101;
-
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * An {@link AsyncHandler} which is able to execute WebSocket upgrade. Use the Builder for configuring WebSocket options.
  */
 public class WebSocketUpgradeHandler implements AsyncHandler<NettyWebSocket> {
 
-  private final List<WebSocketListener> listeners;
-  private NettyWebSocket webSocket;
-
-  public WebSocketUpgradeHandler(List<WebSocketListener> listeners) {
-    this.listeners = listeners;
-  }
-
-  protected void setWebSocket0(NettyWebSocket webSocket) {
-  }
-
-  protected void onStatusReceived0(HttpResponseStatus responseStatus) throws Exception {
-  }
-
-  protected void onHeadersReceived0(HttpHeaders headers) throws Exception {
-  }
-
-  protected void onBodyPartReceived0(HttpResponseBodyPart bodyPart) throws Exception {
-  }
-
-  protected void onCompleted0() throws Exception {
-  }
-
-  protected void onThrowable0(Throwable t) {
-  }
-
-  protected void onOpen0() {
-  }
-
-  @Override
-  public final State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-    onStatusReceived0(responseStatus);
-    return responseStatus.getStatusCode() == SWITCHING_PROTOCOLS_101 ? State.CONTINUE : State.ABORT;
-  }
-
-  @Override
-  public final State onHeadersReceived(HttpHeaders headers) throws Exception {
-    onHeadersReceived0(headers);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public final State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-    onBodyPartReceived0(bodyPart);
-    return State.CONTINUE;
-  }
-
-  @Override
-  public final NettyWebSocket onCompleted() throws Exception {
-    onCompleted0();
-    return webSocket;
-  }
-
-  @Override
-  public final void onThrowable(Throwable t) {
-    onThrowable0(t);
-    for (WebSocketListener listener : listeners) {
-      if (webSocket != null) {
-        webSocket.addWebSocketListener(listener);
-      }
-      listener.onError(t);
+    private static final int SWITCHING_PROTOCOLS = io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS.code();
+
+    private NettyWebSocket webSocket;
+    private final List<WebSocketListener> listeners;
+
+    public WebSocketUpgradeHandler(List<WebSocketListener> listeners) {
+        this.listeners = listeners;
     }
-  }
-
-  public final void setWebSocket(NettyWebSocket webSocket) {
-    this.webSocket = webSocket;
-    setWebSocket0(webSocket);
-  }
-
-  public final void onOpen() {
-    onOpen0();
-    for (WebSocketListener listener : listeners) {
-      webSocket.addWebSocketListener(listener);
-      listener.onOpen(webSocket);
+    
+    protected void setWebSocket0(NettyWebSocket webSocket) {}
+    protected void onStatusReceived0(HttpResponseStatus responseStatus) throws Exception {}
+    protected void onHeadersReceived0(HttpHeaders headers) throws Exception {}
+    protected void onBodyPartReceived0(HttpResponseBodyPart bodyPart) throws Exception {}
+    protected void onCompleted0() throws Exception {}
+    protected void onThrowable0(Throwable t) {}
+    protected void onOpen0() {}
+
+    @Override
+    public final State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+    	onStatusReceived0(responseStatus);
+        return responseStatus.getStatusCode() == SWITCHING_PROTOCOLS ? State.CONTINUE : State.ABORT;
     }
-    webSocket.processBufferedFrames();
-  }
 
-  /**
-   * Build a {@link WebSocketUpgradeHandler}
-   */
-  public final static class Builder {
+    @Override
+    public final State onHeadersReceived(HttpHeaders headers) throws Exception {
+    	onHeadersReceived0(headers);
+        return State.CONTINUE;
+    }
 
-    private List<WebSocketListener> listeners = new ArrayList<>(1);
+    @Override
+    public final State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    	onBodyPartReceived0(bodyPart);
+        return State.CONTINUE;
+    }
 
-    /**
-     * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
-     *
-     * @param listener a {@link WebSocketListener}
-     * @return this
-     */
-    public Builder addWebSocketListener(WebSocketListener listener) {
-      listeners.add(listener);
-      return this;
+    @Override
+    public final NettyWebSocket onCompleted() throws Exception {
+    	onCompleted0();
+        return webSocket;
     }
 
-    /**
-     * Remove a {@link WebSocketListener}
-     *
-     * @param listener a {@link WebSocketListener}
-     * @return this
-     */
-    public Builder removeWebSocketListener(WebSocketListener listener) {
-      listeners.remove(listener);
-      return this;
+    @Override
+    public final void onThrowable(Throwable t) {
+    	onThrowable0(t);
+        for (WebSocketListener listener : listeners) {
+            if (webSocket != null) {
+                webSocket.addWebSocketListener(listener);
+            }
+            listener.onError(t);
+        }
+    }
+
+    public final void setWebSocket(NettyWebSocket webSocket) {
+        this.webSocket = webSocket;
+        setWebSocket0(webSocket);
+    }
+    
+    public final void onOpen() {
+    	onOpen0();
+        for (WebSocketListener listener : listeners) {
+            webSocket.addWebSocketListener(listener);
+            listener.onOpen(webSocket);
+        }
+        webSocket.processBufferedFrames();
     }
 
     /**
      * Build a {@link WebSocketUpgradeHandler}
-     *
-     * @return a {@link WebSocketUpgradeHandler}
      */
-    public WebSocketUpgradeHandler build() {
-      return new WebSocketUpgradeHandler(listeners);
+    public final static class Builder {
+
+        private List<WebSocketListener> listeners = new ArrayList<>(1);
+
+        /**
+         * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
+         *
+         * @param listener a {@link WebSocketListener}
+         * @return this
+         */
+        public Builder addWebSocketListener(WebSocketListener listener) {
+            listeners.add(listener);
+            return this;
+        }
+
+        /**
+         * Remove a {@link WebSocketListener}
+         *
+         * @param listener a {@link WebSocketListener}
+         * @return this
+         */
+        public Builder removeWebSocketListener(WebSocketListener listener) {
+            listeners.remove(listener);
+            return this;
+        }
+
+        /**
+         * Build a {@link WebSocketUpgradeHandler}
+         *
+         * @return a {@link WebSocketUpgradeHandler}
+         */
+        public WebSocketUpgradeHandler build() {
+            return new WebSocketUpgradeHandler(listeners);
+        }
     }
-  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index a08bc2709..489e130c9 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -13,25 +13,58 @@
  */
 package org.asynchttpclient.ws;
 
-import io.netty.util.internal.ThreadLocalRandom;
-import org.asynchttpclient.util.Base64;
-
 import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledSha1MessageDigest;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.asynchttpclient.util.Base64;
 
 public final class WebSocketUtils {
-  private static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+    public static String getKey() {
+        byte[] nonce = createRandomBytes(16);
+        return Base64.encode(nonce);
+    }
+
+    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
+        String acceptSeed = key + MAGIC_GUID;
+        byte[] sha1 = sha1(acceptSeed.getBytes(US_ASCII));
+        return Base64.encode(sha1);
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("MD5 not supported on this platform");
+        }
+    }
+
+    public static byte[] sha1(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("SHA-1 not supported on this platform");
+        }
+    }
+
+    public static byte[] createRandomBytes(int size) {
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size; i++) {
+            bytes[i] = (byte) createRandomNumber(0, 255);
+        }
+
+        return bytes;
+    }
 
-  public static String getWebSocketKey() {
-    byte[] nonce = new byte[16];
-    ThreadLocalRandom random = ThreadLocalRandom.current();
-    for (int i = 0; i < nonce.length; i++) {
-      nonce[i] = (byte) random.nextInt(256);
+    public static int createRandomNumber(int min, int max) {
+        return (int) (Math.random() * max + min);
     }
-    return Base64.encode(nonce);
-  }
 
-  public static String getAcceptKey(String key) {
-    return Base64.encode(pooledSha1MessageDigest().digest((key + MAGIC_GUID).getBytes(US_ASCII)));
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
index 94b5c6d53..916b1f357 100644
--- a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
@@ -15,6 +15,10 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.fail;
+import io.netty.handler.codec.http.HttpHeaders;
+
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -24,61 +28,88 @@
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-
 public abstract class AbstractBasicTest {
 
-  protected final static int TIMEOUT = 30;
+    protected final static int TIMEOUT = 30;
 
-  protected final Logger logger = LoggerFactory.getLogger(getClass());
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
 
-  protected Server server;
-  protected int port1 = -1;
-  protected int port2 = -1;
+    protected Server server;
+    protected int port1 = -1;
+    protected int port2  =-1;
 
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    server.setHandler(configureHandler());
-    ServerConnector connector2 = addHttpConnector(server);
-    server.start();
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        server.setHandler(configureHandler());
+        ServerConnector connector2 = addHttpConnector(server);
+        server.start();
+        
+        port1 = connector1.getLocalPort();
+        port2 = connector2.getLocalPort();
 
-    port1 = connector1.getLocalPort();
-    port2 = connector2.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+    }
 
-    logger.info("Local HTTP server started successfully");
-  }
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        if (server != null) {
+            server.stop();
+        }
+    }
 
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    if (server != null) {
-      server.stop();
+    protected String getTargetUrl() {
+        return String.format("http://localhost:%d/foo/test", port1);
     }
-  }
 
-  protected String getTargetUrl() {
-    return String.format("http://localhost:%d/foo/test", port1);
-  }
+    protected String getTargetUrl2() {
+        return String.format("https://localhost:%d/foo/test", port2);
+    }
 
-  protected String getTargetUrl2() {
-    return String.format("https://localhost:%d/foo/test", port2);
-  }
+    public AbstractHandler configureHandler() throws Exception {
+        return new EchoHandler();
+    }
 
-  public AbstractHandler configureHandler() throws Exception {
-    return new EchoHandler();
-  }
+    public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
 
-  public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+            return response;
+        }
 
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-      return response;
+        @Override
+        public void onThrowable(Throwable t) {
+            t.printStackTrace();
+        }
     }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      t.printStackTrace();
+    public static class AsyncHandlerAdapter implements AsyncHandler<String> {
+
+        @Override
+        public void onThrowable(Throwable t) {
+            t.printStackTrace();
+            fail("Unexpected exception", t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public String onCompleted() throws Exception {
+            return "";
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index bbbb512a5..6aabb0ce1 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -13,6 +13,8 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
+
 import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.testng.Assert;
@@ -20,146 +22,144 @@
 
 import java.lang.reflect.Method;
 
-import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
-
 @Test
 public class AsyncHttpClientDefaultsTest {
 
-  public void testDefaultMaxTotalConnections() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(), -1);
-    testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
-  }
-
-  public void testDefaultMaxConnectionPerHost() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnectionsPerHost(), -1);
-    testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
-  }
-
-  public void testDefaultConnectTimeOut() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectTimeout(), 5 * 1000);
-    testIntegerSystemProperty("connectTimeout", "defaultConnectTimeout", "100");
-  }
-
-  public void testDefaultPooledConnectionIdleTimeout() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
-    testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
-  }
-
-  public void testDefaultReadTimeout() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
-    testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
-  }
-
-  public void testDefaultRequestTimeout() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
-    testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
-  }
-
-  public void testDefaultConnectionTtl() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTtl(), -1);
-    testIntegerSystemProperty("connectionTtl", "defaultConnectionTtl", "100");
-  }
-
-  public void testDefaultFollowRedirect() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultFollowRedirect());
-    testBooleanSystemProperty("followRedirect", "defaultFollowRedirect", "true");
-  }
-
-  public void testDefaultMaxRedirects() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRedirects(), 5);
-    testIntegerSystemProperty("maxRedirects", "defaultMaxRedirects", "100");
-  }
-
-  public void testDefaultCompressionEnforced() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultCompressionEnforced());
-    testBooleanSystemProperty("compressionEnforced", "defaultCompressionEnforced", "true");
-  }
-
-  public void testDefaultUserAgent() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.1");
-    testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
-  }
-
-  public void testDefaultUseProxySelector() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxySelector());
-    testBooleanSystemProperty("useProxySelector", "defaultUseProxySelector", "true");
-  }
-
-  public void testDefaultUseProxyProperties() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxyProperties());
-    testBooleanSystemProperty("useProxyProperties", "defaultUseProxyProperties", "true");
-  }
-
-  public void testDefaultStrict302Handling() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultStrict302Handling());
-    testBooleanSystemProperty("strict302Handling", "defaultStrict302Handling", "true");
-  }
-
-  public void testDefaultAllowPoolingConnection() {
-    Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultKeepAlive());
-    testBooleanSystemProperty("keepAlive", "defaultKeepAlive", "false");
-  }
-
-  public void testDefaultMaxRequestRetry() {
-    Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
-    testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
-  }
-
-  public void testDefaultDisableUrlEncodingForBoundRequests() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultDisableUrlEncodingForBoundRequests());
-    testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
-  }
-
-  public void testDefaultUseInsecureTrustManager() {
-    Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseInsecureTrustManager());
-    testBooleanSystemProperty("useInsecureTrustManager", "defaultUseInsecureTrustManager", "false");
-  }
-
-  private void testIntegerSystemProperty(String propertyName, String methodName, String value) {
-    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try {
-      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
-      Assert.assertEquals(method.invoke(null), Integer.parseInt(value));
-    } catch (Exception e) {
-      Assert.fail("Couldn't find or execute method : " + methodName, e);
-    }
-    if (previous != null)
-      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-    else
-      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-  }
-
-  private void testBooleanSystemProperty(String propertyName, String methodName, String value) {
-    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try {
-      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
-      Assert.assertEquals(method.invoke(null), Boolean.parseBoolean(value));
-    } catch (Exception e) {
-      Assert.fail("Couldn't find or execute method : " + methodName, e);
-    }
-    if (previous != null)
-      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-    else
-      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-  }
-
-  private void testStringSystemProperty(String propertyName, String methodName, String value) {
-    String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-    System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try {
-      Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName);
-      Assert.assertEquals(method.invoke(null), value);
-    } catch (Exception e) {
-      Assert.fail("Couldn't find or execute method : " + methodName, e);
-    }
-    if (previous != null)
-      System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
-    else
-      System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
-  }
+    public void testDefaultMaxTotalConnections() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(), -1);
+        testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
+    }
+
+    public void testDefaultMaxConnectionPerHost() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnectionsPerHost(), -1);
+        testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
+    }
+
+    public void testDefaultConnectTimeOut() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectTimeout(), 5 * 1000);
+        testIntegerSystemProperty("connectTimeout", "defaultConnectTimeout", "100");
+    }
+
+    public void testDefaultPooledConnectionIdleTimeout() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
+        testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
+    }
+
+    public void testDefaultReadTimeout() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
+        testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
+    }
+
+    public void testDefaultRequestTimeout() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
+        testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
+    }
+
+    public void testDefaultConnectionTtl() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTtl(), -1);
+        testIntegerSystemProperty("connectionTtl", "defaultConnectionTtl", "100");
+    }
+
+    public void testDefaultFollowRedirect() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultFollowRedirect());
+        testBooleanSystemProperty("followRedirect", "defaultFollowRedirect", "true");
+    }
+
+    public void testDefaultMaxRedirects() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRedirects(), 5);
+        testIntegerSystemProperty("maxRedirects", "defaultMaxRedirects", "100");
+    }
+
+    public void testDefaultCompressionEnforced() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultCompressionEnforced());
+        testBooleanSystemProperty("compressionEnforced", "defaultCompressionEnforced", "true");
+    }
+
+    public void testDefaultUserAgent() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.1");
+        testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
+    }
+
+    public void testDefaultUseProxySelector() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxySelector());
+        testBooleanSystemProperty("useProxySelector", "defaultUseProxySelector", "true");
+    }
+
+    public void testDefaultUseProxyProperties() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseProxyProperties());
+        testBooleanSystemProperty("useProxyProperties", "defaultUseProxyProperties", "true");
+    }
+
+    public void testDefaultStrict302Handling() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultStrict302Handling());
+        testBooleanSystemProperty("strict302Handling", "defaultStrict302Handling", "true");
+    }
+
+    public void testDefaultAllowPoolingConnection() {
+        Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultKeepAlive());
+        testBooleanSystemProperty("keepAlive", "defaultKeepAlive", "false");
+    }
+
+    public void testDefaultMaxRequestRetry() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
+        testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
+    }
+
+    public void testDefaultDisableUrlEncodingForBoundRequests() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultDisableUrlEncodingForBoundRequests());
+        testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
+    }
+
+    public void testDefaultUseInsecureTrustManager() {
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultUseInsecureTrustManager());
+        testBooleanSystemProperty("useInsecureTrustManager", "defaultUseInsecureTrustManager", "false");
+    }
+
+    private void testIntegerSystemProperty(String propertyName, String methodName, String value) {
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), Integer.parseInt(value));
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    }
+
+    private void testBooleanSystemProperty(String propertyName, String methodName, String value) {
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), Boolean.parseBoolean(value));
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    }
+
+    private void testStringSystemProperty(String propertyName, String methodName, String value) {
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try {
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), value);
+        } catch (Exception e) {
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
+        else
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index e5ec90657..110b5fe0e 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -15,14 +15,14 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.test.TestUtils.*;
-import org.asynchttpclient.testserver.HttpServer;
-import org.asynchttpclient.testserver.HttpTest;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
 
 import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
@@ -31,451 +31,462 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-import static org.testng.Assert.*;
+import org.asynchttpclient.test.TestUtils.AsyncHandlerAdapter;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public class AsyncStreamHandlerTest extends HttpTest {
 
-  private static final String RESPONSE = "param_1_";
-
-  private static HttpServer server;
-
-  @BeforeClass
-  public static void start() throws Throwable {
-    server = new HttpServer();
-    server.start();
-  }
-
-  @AfterClass
-  public static void stop() throws Throwable {
-    server.close();
-  }
-
-  private static String getTargetUrl() {
-    return server.getHttpUrl() + "/foo/bar";
-  }
-
-  @Test
-  public void getWithOnHeadersReceivedAbort() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            return State.ABORT;
-          }
-        }).get(5, TimeUnit.SECONDS);
-      }));
-  }
-
-  @Test
-  public void asyncStreamPOSTTest() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        server.enqueueEcho();
-
-        String responseBody = client.preparePost(getTargetUrl())
-                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
-                .addFormParam("param_1", "value_1")
-                .execute(new AsyncHandlerAdapter() {
-                  private StringBuilder builder = new StringBuilder();
-
-                  @Override
-                  public State onHeadersReceived(HttpHeaders headers) {
-                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    return State.CONTINUE;
-                  }
-
-                  @Override
-                  public State onBodyPartReceived(HttpResponseBodyPart content) {
-                    builder.append(new String(content.getBodyPartBytes(), US_ASCII));
-                    return State.CONTINUE;
-                  }
-
-                  @Override
-                  public String onCompleted() {
-                    return builder.toString().trim();
-                  }
-                }).get(10, TimeUnit.SECONDS);
-
-        assertEquals(responseBody, RESPONSE);
-      }));
-  }
-
-  @Test
-  public void asyncStreamInterruptTest() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        server.enqueueEcho();
-
-        final AtomicBoolean onHeadersReceived = new AtomicBoolean();
-        final AtomicBoolean onBodyPartReceived = new AtomicBoolean();
-        final AtomicBoolean onThrowable = new AtomicBoolean();
-
-        client.preparePost(getTargetUrl())
-                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
-                .addFormParam("param_1", "value_1")
-                .execute(new AsyncHandlerAdapter() {
-
-                  @Override
-                  public State onHeadersReceived(HttpHeaders headers) {
-                    onHeadersReceived.set(true);
-                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    return State.ABORT;
-                  }
-
-                  @Override
-                  public State onBodyPartReceived(final HttpResponseBodyPart content) {
-                    onBodyPartReceived.set(true);
-                    return State.ABORT;
-                  }
-
-                  @Override
-                  public void onThrowable(Throwable t) {
-                    onThrowable.set(true);
-                  }
-                }).get(5, TimeUnit.SECONDS);
-
-        assertTrue(onHeadersReceived.get(), "Headers weren't received");
-        assertFalse(onBodyPartReceived.get(), "Abort not working");
-        assertFalse(onThrowable.get(), "Shouldn't get an exception");
-      }));
-  }
-
-  @Test
-  public void asyncStreamFutureTest() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        server.enqueueEcho();
-
-        final AtomicBoolean onHeadersReceived = new AtomicBoolean();
-        final AtomicBoolean onThrowable = new AtomicBoolean();
-
-        String responseBody = client.preparePost(getTargetUrl())
-                .addFormParam("param_1", "value_1")
-                .execute(new AsyncHandlerAdapter() {
-                  private StringBuilder builder = new StringBuilder();
-
-                  @Override
-                  public State onHeadersReceived(HttpHeaders headers) {
-                    assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    onHeadersReceived.set(true);
-                    return State.CONTINUE;
-                  }
-
-                  @Override
-                  public State onBodyPartReceived(HttpResponseBodyPart content) {
-                    builder.append(new String(content.getBodyPartBytes()));
-                    return State.CONTINUE;
-                  }
-
-                  @Override
-                  public String onCompleted() {
-                    return builder.toString().trim();
-                  }
-
-                  @Override
-                  public void onThrowable(Throwable t) {
-                    onThrowable.set(true);
-                  }
-                }).get(5, TimeUnit.SECONDS);
-
-        assertTrue(onHeadersReceived.get(), "Headers weren't received");
-        assertFalse(onThrowable.get(), "Shouldn't get an exception");
-        assertEquals(responseBody, RESPONSE, "Unexpected response body");
-      }));
-  }
-
-  @Test
-  public void asyncStreamThrowableRefusedTest() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        server.enqueueEcho();
-
-        final CountDownLatch l = new CountDownLatch(1);
-        client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            throw unknownStackTrace(new RuntimeException("FOO"), AsyncStreamHandlerTest.class, "asyncStreamThrowableRefusedTest");
-          }
-
-          @Override
-          public void onThrowable(Throwable t) {
-            try {
-              if (t.getMessage() != null) {
-                assertEquals(t.getMessage(), "FOO");
-              }
-            } finally {
-              l.countDown();
-            }
-          }
-        });
-
-        if (!l.await(10, TimeUnit.SECONDS)) {
-          fail("Timed out");
-        }
-      }));
-  }
+    private static final String RESPONSE = "param_1_";
 
-  @Test
-  public void asyncStreamReusePOSTTest() throws Throwable {
+    private static HttpServer server;
 
-    withClient().run(client ->
-      withServer(server).run(server -> {
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
+    }
 
-        server.enqueueEcho();
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
+    }
 
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+    private static String getTargetUrl() {
+        return server.getHttpUrl() + "/foo/bar";
+    }
 
-        BoundRequestBuilder rb = client.preparePost(getTargetUrl())
-                .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)
-                .addFormParam("param_1", "value_1");
+    @Test
+    public void getWithOnHeadersReceivedAbort() throws Throwable {
 
-        Future<String> f = rb.execute(new AsyncHandlerAdapter() {
-          private StringBuilder builder = new StringBuilder();
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            responseHeaders.set(headers);
-            return State.CONTINUE;
-          }
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
-          @Override
-          public State onBodyPartReceived(HttpResponseBodyPart content) {
-            builder.append(new String(content.getBodyPartBytes()));
-            return State.CONTINUE;
-          }
-
-          @Override
-          public String onCompleted() {
-            return builder.toString();
-          }
+                    @Override
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                        return State.ABORT;
+                    }
+                }).get(5, TimeUnit.SECONDS);
+            });
         });
-
-        String r = f.get(5, TimeUnit.SECONDS);
-        HttpHeaders h = responseHeaders.get();
-        assertNotNull(h, "Should receive non null headers");
-        assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-        assertNotNull(r, "No response body");
-        assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-
-        responseHeaders.set(null);
-
-        server.enqueueEcho();
-
-        // Let do the same again
-        f = rb.execute(new AsyncHandlerAdapter() {
-          private StringBuilder builder = new StringBuilder();
-
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            responseHeaders.set(headers);
-            return State.CONTINUE;
-          }
-
-          @Override
-          public State onBodyPartReceived(HttpResponseBodyPart content) {
-            builder.append(new String(content.getBodyPartBytes()));
-            return State.CONTINUE;
-          }
-
-          @Override
-          public String onCompleted() {
-            return builder.toString();
-          }
+    }
+
+    @Test
+    public void asyncStreamPOSTTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                String responseBody = client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+                            private StringBuilder builder = new StringBuilder();
+
+                            @Override
+                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                                builder.append(new String(content.getBodyPartBytes(), US_ASCII));
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public String onCompleted() throws Exception {
+                                return builder.toString().trim();
+                            }
+                        }).get(10, TimeUnit.SECONDS);
+
+                assertEquals(responseBody, RESPONSE);
+            });
+        });
+    }
+
+    @Test
+    public void asyncStreamInterruptTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+                final AtomicBoolean onBodyPartReceived = new AtomicBoolean();
+                final AtomicBoolean onThrowable = new AtomicBoolean();
+
+                client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+
+                            @Override
+                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                                onHeadersReceived.set(true);
+                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                return State.ABORT;
+                            }
+
+                            @Override
+                            public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                                onBodyPartReceived.set(true);
+                                return State.ABORT;
+                            }
+
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                onThrowable.set(true);
+                            }
+                        }).get(5, TimeUnit.SECONDS);
+
+                assertTrue(onHeadersReceived.get(), "Headers weren't received");
+                assertFalse(onBodyPartReceived.get(), "Abort not working");
+                assertFalse(onThrowable.get(), "Shouldn't get an exception");
+            });
+        });
+    }
+
+    @Test
+    public void asyncStreamFutureTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+                final AtomicBoolean onThrowable = new AtomicBoolean();
+
+                String responseBody = client.preparePost(getTargetUrl())//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+                            private StringBuilder builder = new StringBuilder();
+
+                            @Override
+                            public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                                assertContentTypesEquals(headers.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                onHeadersReceived.set(true);
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                                builder.append(new String(content.getBodyPartBytes()));
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public String onCompleted() throws Exception {
+                                return builder.toString().trim();
+                            }
+
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                onThrowable.set(true);
+                            }
+                        }).get(5, TimeUnit.SECONDS);
+
+                assertTrue(onHeadersReceived.get(), "Headers weren't received");
+                assertFalse(onThrowable.get(), "Shouldn't get an exception");
+                assertEquals(responseBody, RESPONSE, "Unexpected response body");
+            });
+        });
+    }
+
+    @Test
+    public void asyncStreamThrowableRefusedTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final CountDownLatch l = new CountDownLatch(1);
+                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+                    @Override
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        throw unknownStackTrace(new RuntimeException("FOO"), AsyncStreamHandlerTest.class, "asyncStreamThrowableRefusedTest");
+                    }
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        try {
+                            if (t.getMessage() != null) {
+                                assertEquals(t.getMessage(), "FOO");
+                            }
+                        } finally {
+                            l.countDown();
+                        }
+                    }
+                });
+
+                if (!l.await(10, TimeUnit.SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
+    }
+
+    @Test
+    public void asyncStreamReusePOSTTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+
+                BoundRequestBuilder rb = client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1");
+
+                Future<String> f = rb.execute(new AsyncHandlerAdapter() {
+                    private StringBuilder builder = new StringBuilder();
+
+                    @Override
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        responseHeaders.set(headers);
+                        return State.CONTINUE;
+                    }
+
+                    @Override
+                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                        builder.append(new String(content.getBodyPartBytes()));
+                        return State.CONTINUE;
+                    }
+
+                    @Override
+                    public String onCompleted() throws Exception {
+                        return builder.toString();
+                    }
+                });
+
+                String r = f.get(5, TimeUnit.SECONDS);
+                HttpHeaders h = responseHeaders.get();
+                assertNotNull(h, "Should receive non null headers");
+                assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                assertNotNull(r, "No response body");
+                assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+
+                responseHeaders.set(null);
+
+                server.enqueueEcho();
+
+                // Let do the same again
+                    f = rb.execute(new AsyncHandlerAdapter() {
+                        private StringBuilder builder = new StringBuilder();
+
+                        @Override
+                        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                            responseHeaders.set(headers);
+                            return State.CONTINUE;
+                        }
+
+                        @Override
+                        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                            builder.append(new String(content.getBodyPartBytes()));
+                            return State.CONTINUE;
+                        }
+
+                        @Override
+                        public String onCompleted() throws Exception {
+                            return builder.toString();
+                        }
+                    });
+
+                    f.get(5, TimeUnit.SECONDS);
+                    h = responseHeaders.get();
+                    assertNotNull(h, "Should receive non null headers");
+                    assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    assertNotNull(r, "No response body");
+                    assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+                });
         });
+    }
 
-        f.get(5, TimeUnit.SECONDS);
-        h = responseHeaders.get();
-        assertNotNull(h, "Should receive non null headers");
-        assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-        assertNotNull(r, "No response body");
-        assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-      }));
-  }
+    @Test
+    public void asyncStream302RedirectWithBody() throws Throwable {
 
-  @Test
-  public void asyncStream302RedirectWithBody() throws Throwable {
+        withClient(config().setFollowRedirect(true)).run(client -> {
+            withServer(server).run(server -> {
 
-    withClient(config().setFollowRedirect(true)).run(client ->
-      withServer(server).run(server -> {
+                String originalUrl = server.getHttpUrl() + "/original";
+                String redirectUrl = server.getHttpUrl() + "/redirect";
 
-        String originalUrl = server.getHttpUrl() + "/original";
-        String redirectUrl = server.getHttpUrl() + "/redirect";
+                server.enqueueResponse(response -> {
+                    response.setStatus(302);
+                    response.setHeader(LOCATION.toString(), redirectUrl);
+                    response.getOutputStream().println("You are being asked to redirect to " + redirectUrl);
+                });
+                server.enqueueOk();
 
-        server.enqueueResponse(response -> {
-          response.setStatus(302);
-          response.setHeader(LOCATION.toString(), redirectUrl);
-          response.getOutputStream().println("You are being asked to redirect to " + redirectUrl);
+                Response response = client.prepareGet(originalUrl).execute().get(20, TimeUnit.SECONDS);
+
+                assertEquals(response.getStatusCode(), 200);
+                assertTrue(response.getResponseBody().isEmpty());
+            });
         });
-        server.enqueueOk();
-
-        Response response = client.prepareGet(originalUrl).execute().get(20, TimeUnit.SECONDS);
-
-        assertEquals(response.getStatusCode(), 200);
-        assertTrue(response.getResponseBody().isEmpty());
-      }));
-  }
-
-  @Test(timeOut = 3000)
-  public void asyncStreamJustStatusLine() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        server.enqueueEcho();
-
-        final int STATUS = 0;
-        final int COMPLETED = 1;
-        final int OTHER = 2;
-        final boolean[] whatCalled = new boolean[]{false, false, false};
-        final CountDownLatch latch = new CountDownLatch(1);
-        Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
-          private int status = -1;
-
-          @Override
-          public void onThrowable(Throwable t) {
-            whatCalled[OTHER] = true;
-            latch.countDown();
-          }
-
-          @Override
-          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
-            whatCalled[OTHER] = true;
-            latch.countDown();
-            return State.ABORT;
-          }
-
-          @Override
-          public State onStatusReceived(HttpResponseStatus responseStatus) {
-            whatCalled[STATUS] = true;
-            status = responseStatus.getStatusCode();
-            latch.countDown();
-            return State.ABORT;
-          }
-
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            whatCalled[OTHER] = true;
-            latch.countDown();
-            return State.ABORT;
-          }
-
-          @Override
-          public Integer onCompleted() {
-            whatCalled[COMPLETED] = true;
-            latch.countDown();
-            return status;
-          }
+    }
+
+    @Test(timeOut = 3000)
+    public void asyncStreamJustStatusLine() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final int STATUS = 0;
+                final int COMPLETED = 1;
+                final int OTHER = 2;
+                final boolean[] whatCalled = new boolean[] { false, false, false };
+                final CountDownLatch latch = new CountDownLatch(1);
+                Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
+                    private int status = -1;
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        whatCalled[STATUS] = true;
+                        status = responseStatus.getStatusCode();
+                        latch.countDown();
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public Integer onCompleted() throws Exception {
+                        whatCalled[COMPLETED] = true;
+                        latch.countDown();
+                        return status;
+                    }
+                });
+
+                if (!latch.await(2, TimeUnit.SECONDS)) {
+                    fail("Timeout");
+                    return;
+                }
+                Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
+                assertEquals((int) status, 200, "Expected status code failed.");
+
+                if (!whatCalled[STATUS]) {
+                    fail("onStatusReceived not called.");
+                }
+                if (!whatCalled[COMPLETED]) {
+                    fail("onCompleted not called.");
+                }
+                if (whatCalled[OTHER]) {
+                    fail("Other method of AsyncHandler got called.");
+                }
+            });
         });
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-          fail("Timeout");
-          return;
-        }
-        Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-        assertEquals((int) status, 200, "Expected status code failed.");
-
-        if (!whatCalled[STATUS]) {
-          fail("onStatusReceived not called.");
-        }
-        if (!whatCalled[COMPLETED]) {
-          fail("onCompleted not called.");
-        }
-        if (whatCalled[OTHER]) {
-          fail("Other method of AsyncHandler got called.");
-        }
-      }));
-  }
-
-  @Test(groups = "online")
-  public void asyncOptionsTest() throws Throwable {
-
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-
-        final String[] expected = {"GET", "HEAD", "OPTIONS", "POST"};
-        Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
-
-          @Override
-          public State onHeadersReceived(HttpHeaders headers) {
-            responseHeaders.set(headers);
-            return State.ABORT;
-          }
-
-          @Override
-          public String onCompleted() {
-            return "OK";
-          }
+    }
+
+    @Test(groups = "online")
+    public void asyncOptionsTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+
+                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST" };
+                Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+
+                    @Override
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        responseHeaders.set(headers);
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public String onCompleted() throws Exception {
+                        return "OK";
+                    }
+                });
+
+                f.get(20, TimeUnit.SECONDS);
+                HttpHeaders h = responseHeaders.get();
+                assertNotNull(h);
+                String[] values = h.get(ALLOW).split(",|, ");
+                assertNotNull(values);
+                assertEquals(values.length, expected.length);
+                Arrays.sort(values);
+                assertEquals(values, expected);
+            });
         });
+    }
 
-        f.get(20, TimeUnit.SECONDS);
-        HttpHeaders h = responseHeaders.get();
-        assertNotNull(h);
-        String[] values = h.get(ALLOW).split(",|, ");
-        assertNotNull(values);
-        assertEquals(values.length, expected.length);
-        Arrays.sort(values);
-        assertEquals(values, expected);
-      }));
-  }
+    @Test
+    public void closeConnectionTest() throws Throwable {
 
-  @Test
-  public void closeConnectionTest() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
 
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
+                Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
 
-        Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
+                    private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-          private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        builder.accumulate(headers);
+                        return State.CONTINUE;
+                    }
 
-          public State onHeadersReceived(HttpHeaders headers) {
-            builder.accumulate(headers);
-            return State.CONTINUE;
-          }
+                    public void onThrowable(Throwable t) {
+                    }
 
-          public void onThrowable(Throwable t) {
-          }
+                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                        builder.accumulate(content);
+                        return content.isLast() ? State.ABORT : State.CONTINUE;
+                    }
 
-          public State onBodyPartReceived(HttpResponseBodyPart content) {
-            builder.accumulate(content);
-            return content.isLast() ? State.ABORT : State.CONTINUE;
-          }
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        builder.accumulate(responseStatus);
 
-          public State onStatusReceived(HttpResponseStatus responseStatus) {
-            builder.accumulate(responseStatus);
+                        return State.CONTINUE;
+                    }
 
-            return State.CONTINUE;
-          }
+                    public Response onCompleted() throws Exception {
+                        return builder.build();
+                    }
+                }).get();
 
-          public Response onCompleted() {
-            return builder.build();
-          }
-        }).get();
-
-        assertNotNull(r);
-        assertEquals(r.getStatusCode(), 200);
-      }));
-  }
+                assertNotNull(r);
+                assertEquals(r.getStatusCode(), 200);
+            });
+        });
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index 2f3647cbc..d3c27d564 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -15,120 +15,132 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.Test;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.util.concurrent.*;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.Test;
 
 /**
  * Tests default asynchronous life cycle.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class AsyncStreamLifecycleTest extends AbstractBasicTest {
-  private ExecutorService executorService = Executors.newFixedThreadPool(2);
+    private ExecutorService executorService = Executors.newFixedThreadPool(2);
 
-  @AfterClass
-  @Override
-  public void tearDownGlobal() throws Exception {
-    super.tearDownGlobal();
-    executorService.shutdownNow();
-  }
+    @AfterClass
+    @Override
+    public void tearDownGlobal() throws Exception {
+        super.tearDownGlobal();
+        executorService.shutdownNow();
+    }
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new AbstractHandler() {
-      public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException {
-        resp.setContentType("text/plain;charset=utf-8");
-        resp.setStatus(200);
-        final AsyncContext asyncContext = request.startAsync();
-        final PrintWriter writer = resp.getWriter();
-        executorService.submit(() -> {
-            try {
-              Thread.sleep(100);
-            } catch (InterruptedException e) {
-              logger.error("Failed to sleep for 100 ms.", e);
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
+                resp.setContentType("text/plain;charset=utf-8");
+                resp.setStatus(200);
+                final Continuation continuation = ContinuationSupport.getContinuation(req);
+                continuation.suspend();
+                final PrintWriter writer = resp.getWriter();
+                executorService.submit(new Runnable() {
+                    public void run() {
+                        try {
+                            Thread.sleep(100);
+                        } catch (InterruptedException e) {
+                            logger.error("Failed to sleep for 100 ms.", e);
+                        }
+                        logger.info("Delivering part1.");
+                        writer.write("part1");
+                        writer.flush();
+                    }
+                });
+                executorService.submit(new Runnable() {
+                    public void run() {
+                        try {
+                            Thread.sleep(200);
+                        } catch (InterruptedException e) {
+                            logger.error("Failed to sleep for 200 ms.", e);
+                        }
+                        logger.info("Delivering part2.");
+                        writer.write("part2");
+                        writer.flush();
+                        continuation.complete();
+                    }
+                });
+                request.setHandled(true);
             }
-            logger.info("Delivering part1.");
-            writer.write("part1");
-            writer.flush();
-        });
-        executorService.submit(() -> {
-            try {
-              Thread.sleep(200);
-            } catch (InterruptedException e) {
-              logger.error("Failed to sleep for 200 ms.", e);
-            }
-            logger.info("Delivering part2.");
-            writer.write("part2");
-            writer.flush();
-            asyncContext.complete();
-        });
-        request.setHandled(true);
-      }
-    };
-  }
+        };
+    }
 
-  @Test
-  public void testStream() throws Exception {
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      final AtomicBoolean err = new AtomicBoolean(false);
-      final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
-      final AtomicBoolean status = new AtomicBoolean(false);
-      final AtomicInteger headers = new AtomicInteger(0);
-      final CountDownLatch latch = new CountDownLatch(1);
-      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-        public void onThrowable(Throwable t) {
-          fail("Got throwable.", t);
-          err.set(true);
-        }
+    @Test(groups = "standalone")
+    public void testStream() throws Exception {
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
 
-        public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-          if (e.length() != 0) {
-            String s = new String(e.getBodyPartBytes());
-            logger.info("got part: {}", s);
-            queue.put(s);
-          }
-          return State.CONTINUE;
-        }
+                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    if (e.length() != 0) {
+                        String s = new String(e.getBodyPartBytes());
+                        logger.info("got part: {}", s);
+                        queue.put(s);
+                    }
+                    return State.CONTINUE;
+                }
 
-        public State onStatusReceived(HttpResponseStatus e) {
-          status.set(true);
-          return State.CONTINUE;
-        }
+                public State onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return State.CONTINUE;
+                }
 
-        public State onHeadersReceived(HttpHeaders e) throws Exception {
-          if (headers.incrementAndGet() == 2) {
-            throw new Exception("Analyze this.");
-          }
-          return State.CONTINUE;
-        }
+                public State onHeadersReceived(HttpHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return State.CONTINUE;
+                }
 
-        public Object onCompleted() {
-          latch.countDown();
-          return null;
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            assertFalse(err.get());
+            assertEquals(queue.size(), 2);
+            assertTrue(queue.contains("part1"));
+            assertTrue(queue.contains("part2"));
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
         }
-      });
-      assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-      assertFalse(err.get());
-      assertEquals(queue.size(), 2);
-      assertTrue(queue.contains("part1"));
-      assertTrue(queue.contains("part2"));
-      assertTrue(status.get());
-      assertEquals(headers.get(), 1);
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 78af7855e..84e7f4aa6 100644
--- a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -12,6 +12,20 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -20,170 +34,156 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
+public class AuthTimeoutTest extends AbstractBasicTest {
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
+    private static final int REQUEST_TIMEOUT = 1000;
+    private static final int SHORT_FUTURE_TIMEOUT = 500; // shorter than REQUEST_TIMEOUT
+    private static final int LONG_FUTURE_TIMEOUT = 1500; // longer than REQUEST_TIMEOUT
 
-public class AuthTimeoutTest extends AbstractBasicTest {
+    private Server server2;
 
-  private static final int REQUEST_TIMEOUT = 1000;
-  private static final int SHORT_FUTURE_TIMEOUT = 500; // shorter than REQUEST_TIMEOUT
-  private static final int LONG_FUTURE_TIMEOUT = 1500; // longer than REQUEST_TIMEOUT
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
 
-  private Server server2;
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        addBasicAuthHandler(server, configureHandler());
+        server.start();
+        port1 = connector1.getLocalPort();
+
+        server2 = new Server();
+        ServerConnector connector2 = addHttpConnector(server2);
+        addDigestAuthHandler(server2, configureHandler());
+        server2.start();
+        port2 = connector2.getLocalPort();
+
+        logger.info("Local HTTP server started successfully");
+    }
 
-  @BeforeClass(alwaysRun = true)
-  @Override
-  public void setUpGlobal() throws Exception {
-
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    addBasicAuthHandler(server, configureHandler());
-    server.start();
-    port1 = connector1.getLocalPort();
-
-    server2 = new Server();
-    ServerConnector connector2 = addHttpConnector(server2);
-    addDigestAuthHandler(server2, configureHandler());
-    server2.start();
-    port2 = connector2.getLocalPort();
-
-    logger.info("Local HTTP server started successfully");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    super.tearDownGlobal();
-    server2.stop();
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void basicAuthTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, true, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    } catch (Exception e) {
-      throw e.getCause();
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void basicPreemptiveAuthTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, true, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    } catch (Exception e) {
-      throw e.getCause();
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void digestAuthTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, false, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    } catch (Exception e) {
-      throw e.getCause();
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class, enabled = false)
-  public void digestPreemptiveAuthTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, false, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    } catch (Exception e) {
-      throw e.getCause();
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void basicAuthFutureTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, true, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void basicPreemptiveAuthFutureTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, true, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void digestAuthFutureTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, false, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    }
-  }
-
-  @Test(expectedExceptions = TimeoutException.class, enabled = false)
-  public void digestPreemptiveAuthFutureTimeoutTest() throws Throwable {
-    try (AsyncHttpClient client = newClient()) {
-      execute(client, false, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
-    }
-  }
-
-  private AsyncHttpClient newClient() {
-    return asyncHttpClient(config().setRequestTimeout(REQUEST_TIMEOUT));
-  }
-
-  protected Future<Response> execute(AsyncHttpClient client, boolean basic, boolean preemptive) {
-    Realm.Builder realm;
-    String url;
-
-    if (basic) {
-      realm = basicAuthRealm(USER, ADMIN);
-      url = getTargetUrl();
-    } else {
-      realm = digestAuthRealm(USER, ADMIN);
-      url = getTargetUrl2();
-      if (preemptive) {
-        realm.setRealmName("MyRealm");
-        realm.setAlgorithm("MD5");
-        realm.setQop("auth");
-        realm.setNonce("fFDVc60re9zt8fFDvht0tNrYuvqrcchN");
-      }
-    }
-
-    return client.prepareGet(url).setRealm(realm.setUsePreemptiveAuth(preemptive).build()).execute();
-  }
-
-  @Override
-  protected String getTargetUrl() {
-    return "http://localhost:" + port1 + "/";
-  }
-
-  @Override
-  protected String getTargetUrl2() {
-    return "http://localhost:" + port2 + "/";
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new IncompleteResponseHandler();
-  }
-
-  private class IncompleteResponseHandler extends AbstractHandler {
-
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
-      response.setStatus(200);
-      OutputStream out = response.getOutputStream();
-      response.setIntHeader(CONTENT_LENGTH.toString(), 1000);
-      out.write(0);
-      out.flush();
-      try {
-        Thread.sleep(LONG_FUTURE_TIMEOUT + 100);
-      } catch (InterruptedException e) {
-        //
-      }
-    }
-  }
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        super.tearDownGlobal();
+        server2.stop();
+    }
+
+    private class IncompleteResponseHandler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
+            response.setStatus(200);
+            OutputStream out = response.getOutputStream();
+            response.setIntHeader(CONTENT_LENGTH.toString(), 1000);
+            out.write(0);
+            out.flush();
+            try {
+                Thread.sleep(LONG_FUTURE_TIMEOUT + 100);
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void basicAuthTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, true, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void basicPreemptiveAuthTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, true, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void digestAuthTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, false, false).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class, enabled = false)
+    public void digestPreemptiveAuthTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, false, true).get(LONG_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void basicAuthFutureTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, true, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void basicPreemptiveAuthFutureTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, true, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void digestAuthFutureTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, false, false).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    @Test(expectedExceptions = TimeoutException.class, enabled = false)
+    public void digestPreemptiveAuthFutureTimeoutTest() throws Throwable {
+        try (AsyncHttpClient client = newClient()) {
+            execute(client, false, true).get(SHORT_FUTURE_TIMEOUT, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    private AsyncHttpClient newClient() {
+        return asyncHttpClient(config().setRequestTimeout(REQUEST_TIMEOUT));
+    }
+
+    protected Future<Response> execute(AsyncHttpClient client, boolean basic, boolean preemptive) throws IOException {
+        Realm.Builder realm;
+        String url;
+
+        if (basic) {
+            realm = basicAuthRealm(USER, ADMIN);
+            url = getTargetUrl();
+        } else {
+            realm = digestAuthRealm(USER, ADMIN);
+            url = getTargetUrl2();
+            if (preemptive) {
+                realm.setRealmName("MyRealm");
+                realm.setAlgorithm("MD5");
+                realm.setQop("auth");
+                realm.setNonce("fFDVc60re9zt8fFDvht0tNrYuvqrcchN");
+            }
+        }
+
+        return client.prepareGet(url).setRealm(realm.setUsePreemptiveAuth(preemptive).build()).execute();
+    }
+
+    @Override
+    protected String getTargetUrl() {
+        return "http://localhost:" + port1 + "/";
+    }
+
+    @Override
+    protected String getTargetUrl2() {
+        return "http://localhost:" + port2 + "/";
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new IncompleteResponseHandler();
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
index f36ef7d48..defa24768 100644
--- a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -15,7 +15,24 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -26,312 +43,299 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
+public class BasicAuthTest extends AbstractBasicTest {
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+    protected static final String MY_MESSAGE = "my message";
 
-public class BasicAuthTest extends AbstractBasicTest {
+    private Server server2;
+    private Server serverNoAuth;
+    private int portNoAuth;
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
+
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        addBasicAuthHandler(server, configureHandler());
+        server.start();
+        port1 = connector1.getLocalPort();
+
+        server2 = new Server();
+        ServerConnector connector2 = addHttpConnector(server2);
+        addBasicAuthHandler(server2, new RedirectHandler());
+        server2.start();
+        port2 = connector2.getLocalPort();
 
-  private Server server2;
-  private Server serverNoAuth;
-  private int portNoAuth;
-
-  @BeforeClass(alwaysRun = true)
-  @Override
-  public void setUpGlobal() throws Exception {
-
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    addBasicAuthHandler(server, configureHandler());
-    server.start();
-    port1 = connector1.getLocalPort();
-
-    server2 = new Server();
-    ServerConnector connector2 = addHttpConnector(server2);
-    addBasicAuthHandler(server2, new RedirectHandler());
-    server2.start();
-    port2 = connector2.getLocalPort();
-
-    // need noAuth server to verify the preemptive auth mode (see basicAuthTestPreemtiveTest)
-    serverNoAuth = new Server();
-    ServerConnector connectorNoAuth = addHttpConnector(serverNoAuth);
-    serverNoAuth.setHandler(new SimpleHandler());
-    serverNoAuth.start();
-    portNoAuth = connectorNoAuth.getLocalPort();
-
-    logger.info("Local HTTP server started successfully");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    super.tearDownGlobal();
-    server2.stop();
-    serverNoAuth.stop();
-  }
-
-  @Override
-  protected String getTargetUrl() {
-    return "http://localhost:" + port1 + "/";
-  }
-
-  @Override
-  protected String getTargetUrl2() {
-    return "http://localhost:" + port2 + "/uff";
-  }
-
-  private String getTargetUrlNoAuth() {
-    return "http://localhost:" + portNoAuth + "/";
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new SimpleHandler();
-  }
-
-  @Test
-  public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet(getTargetUrl())
-              .setRealm(basicAuthRealm(USER, ADMIN).build())
-              .execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        // need noAuth server to verify the preemptive auth mode (see basicAuthTestPreemtiveTest)
+        serverNoAuth = new Server();
+        ServerConnector connectorNoAuth = addHttpConnector(serverNoAuth);
+        serverNoAuth.setHandler(new SimpleHandler());
+        serverNoAuth.start();
+        portNoAuth = connectorNoAuth.getLocalPort();
+
+        logger.info("Local HTTP server started successfully");
     }
-  }
-
-  @Test
-  public void redirectAndBasicAuthTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
-      Future<Response> f = client.prepareGet(getTargetUrl2())
-              .setRealm(basicAuthRealm(USER, ADMIN).build())
-              .execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        super.tearDownGlobal();
+        server2.stop();
+        serverNoAuth.stop();
     }
-  }
 
-  @Test
-  public void basic401Test() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-              .setHeader("X-401", "401")
-              .setRealm(basicAuthRealm(USER, ADMIN).build());
+    @Override
+    protected String getTargetUrl() {
+        return "http://localhost:" + port1 + "/";
+    }
 
-      Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
+    @Override
+    protected String getTargetUrl2() {
+        return "http://localhost:" + port2 + "/uff";
+    }
 
-        private HttpResponseStatus status;
+    protected String getTargetUrlNoAuth() {
+        return "http://localhost:" + portNoAuth + "/";
+    }
 
-        public void onThrowable(Throwable t) {
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SimpleHandler();
+    }
 
-        }
+    private static class RedirectHandler extends AbstractHandler {
 
-        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
-          return State.CONTINUE;
-        }
+        private static final Logger LOGGER = LoggerFactory.getLogger(RedirectHandler.class);
 
-        public State onStatusReceived(HttpResponseStatus responseStatus) {
-          this.status = responseStatus;
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-          if (status.getStatusCode() != 200) {
-            return State.ABORT;
-          }
-          return State.CONTINUE;
-        }
+            LOGGER.info("request: " + request.getRequestURI());
 
-        public State onHeadersReceived(HttpHeaders headers) {
-          return State.CONTINUE;
+            if ("/uff".equals(request.getRequestURI())) {
+                LOGGER.info("redirect to /bla");
+                response.setStatus(302);
+                response.setContentLength(0);
+                response.setHeader("Location", "/bla");
+
+            } else {
+                LOGGER.info("got redirected" + request.getRequestURI());
+                response.setStatus(200);
+                response.addHeader("X-Auth", request.getHeader("Authorization"));
+                response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
+                byte[] b = "content".getBytes(UTF_8);
+                response.setContentLength(b.length);
+                response.getOutputStream().write(b);
+            }
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
         }
+    }
 
-        public Integer onCompleted() {
-          return status.getStatusCode();
+    public static class SimpleHandler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+            if (request.getHeader("X-401") != null) {
+                response.setStatus(401);
+                response.setContentLength(0);
+
+            } else {
+                response.addHeader("X-Auth", request.getHeader("Authorization"));
+                response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
+                response.setIntHeader("X-" + CONTENT_LENGTH, request.getContentLength());
+                response.setStatus(200);
+
+                int size = 10 * 1024;
+                byte[] bytes = new byte[size];
+                int contentLength = 0;
+                if (bytes.length > 0) {
+                    int read = 0;
+                    do {
+                        read = request.getInputStream().read(bytes);
+                        if (read > 0) {
+                            contentLength += read;
+                            response.getOutputStream().write(bytes, 0, read);
+                        }
+                    } while (read >= 0);
+                }
+                response.setContentLength(contentLength);
+            }
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
         }
-      });
-      Integer statusCode = f.get(10, TimeUnit.SECONDS);
-      assertNotNull(statusCode);
-      assertEquals(statusCode.intValue(), 401);
     }
-  }
-
-  @Test
-  public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      // send the request to the no-auth endpoint to be able to verify the
-      // auth header is really sent preemptively for the initial call.
-      Future<Response> f = client.prepareGet(getTargetUrlNoAuth())
-              .setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true).build())
-              .execute();
-
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+
+    @Test(groups = "standalone")
+    public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet(getTargetUrl())//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                    .execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        }
     }
-  }
-
-  @Test
-  public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet(getTargetUrl())
-              .setRealm(basicAuthRealm("fake", ADMIN).build())
-              .execute();
-
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), 401);
+
+    @Test(groups = "standalone")
+    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
+            Future<Response> f = client.prepareGet(getTargetUrl2())//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                    .execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+        }
     }
-  }
-
-  @Test
-  public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost(getTargetUrl())
-              .setBody(new ByteArrayInputStream("test".getBytes()))
-              .setRealm(basicAuthRealm(USER, ADMIN).build())
-              .execute();
-
-      Response resp = f.get(30, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), "test");
+
+    @Test(groups = "standalone")
+    public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl())//
+                    .setHeader("X-401", "401")//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build());
+
+            Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
+
+                private HttpResponseStatus status;
+
+                public void onThrowable(Throwable t) {
+
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    this.status = responseStatus;
+
+                    if (status.getStatusCode() != 200) {
+                        return State.ABORT;
+                    }
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public Integer onCompleted() throws Exception {
+                    return status.getStatusCode();
+                }
+            });
+            Integer statusCode = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(statusCode);
+            assertEquals(statusCode.intValue(), 401);
+        }
     }
-  }
-
-  @Test
-  public void basicAuthFileTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost(getTargetUrl())
-              .setBody(SIMPLE_TEXT_FILE)
-              .setRealm(basicAuthRealm(USER, ADMIN).build())
-              .execute();
-
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+
+    @Test(groups = "standalone")
+    public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            // send the request to the no-auth endpoint to be able to verify the
+            // auth header is really sent preemptively for the initial call.
+            Future<Response> f = client.prepareGet(getTargetUrlNoAuth())//
+                    .setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true).build())//
+                    .execute();
+
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        }
     }
-  }
-
-  @Test
-  public void basicAuthAsyncConfigTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN)))) {
-      Future<Response> f = client.preparePost(getTargetUrl())
-              .setBody(SIMPLE_TEXT_FILE_STRING)
-              .execute();
-
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+
+    @Test(groups = "standalone")
+    public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet(getTargetUrl())//
+                    .setRealm(basicAuthRealm("fake", ADMIN).build())//
+                    .execute();
+
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        }
     }
-  }
-
-  @Test
-  public void basicAuthFileNoKeepAliveTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
-
-      Future<Response> f = client.preparePost(getTargetUrl())
-              .setBody(SIMPLE_TEXT_FILE)
-              .setRealm(basicAuthRealm(USER, ADMIN).build())
-              .execute();
-
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+
+    @Test(groups = "standalone")
+    public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(new ByteArrayInputStream("test".getBytes()))//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                    .execute();
+
+            Response resp = f.get(30, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "test");
+        }
     }
-  }
-
-  @Test
-  public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(basicAuthRealm(USER, ADMIN).build());
-
-      Future<Response> f = r.execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertNotNull(resp.getHeader("X-Auth"));
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+
+    @Test(groups = "standalone")
+    public void basicAuthFileTest() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                    .execute();
+
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+        }
     }
-  }
 
-  private static class RedirectHandler extends AbstractHandler {
+    @Test(groups = "standalone")
+    public void basicAuthAsyncConfigTest() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN)))) {
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE_STRING)//
+                    .execute();
+
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+        }
+    }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(RedirectHandler.class);
+    @Test(groups = "standalone")
+    public void basicAuthFileNoKeepAliveTest() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
 
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            Future<Response> f = client.preparePost(getTargetUrl())//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                    .execute();
 
-      LOGGER.info("request: " + request.getRequestURI());
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+        }
+    }
 
-      if ("/uff".equals(request.getRequestURI())) {
-        LOGGER.info("redirect to /bla");
-        response.setStatus(302);
-        response.setContentLength(0);
-        response.setHeader("Location", "/bla");
+    @Test(groups = "standalone")
+    public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(basicAuthRealm(USER, ADMIN).build());
 
-      } else {
-        LOGGER.info("got redirected" + request.getRequestURI());
-        response.setStatus(200);
-        response.addHeader("X-Auth", request.getHeader("Authorization"));
-        response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
-        byte[] b = "content".getBytes(UTF_8);
-        response.setContentLength(b.length);
-        response.getOutputStream().write(b);
-      }
-      response.getOutputStream().flush();
-      response.getOutputStream().close();
-    }
-  }
-
-  public static class SimpleHandler extends AbstractHandler {
-
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-
-      if (request.getHeader("X-401") != null) {
-        response.setStatus(401);
-        response.setContentLength(0);
-
-      } else {
-        response.addHeader("X-Auth", request.getHeader("Authorization"));
-        response.addHeader("X-" + CONTENT_LENGTH, String.valueOf(request.getContentLength()));
-        response.setIntHeader("X-" + CONTENT_LENGTH, request.getContentLength());
-        response.setStatus(200);
-
-        int size = 10 * 1024;
-        byte[] bytes = new byte[size];
-        int contentLength = 0;
-        int read;
-        do {
-          read = request.getInputStream().read(bytes);
-          if (read > 0) {
-            contentLength += read;
-            response.getOutputStream().write(bytes, 0, read);
-          }
-        } while (read >= 0);
-        response.setContentLength(contentLength);
-      }
-      response.getOutputStream().flush();
-      response.getOutputStream().close();
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
index 758e03960..1c9170ffc 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpTest.java
@@ -13,6 +13,18 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ProxyServlet;
@@ -27,106 +39,94 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-
 /**
  * Test that validates that when having an HTTP proxy and trying to access an HTTP through the proxy the proxy credentials should be passed after it gets a 407 response.
  */
 public class BasicHttpProxyToHttpTest {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpTest.class);
-
-  private int httpPort;
-  private int proxyPort;
-
-  private Server httpServer;
-  private Server proxy;
-
-  @BeforeClass
-  public void setUpGlobal() throws Exception {
-
-    httpServer = new Server();
-    ServerConnector connector1 = addHttpConnector(httpServer);
-    httpServer.setHandler(new EchoHandler());
-    httpServer.start();
-    httpPort = connector1.getLocalPort();
-
-    proxy = new Server();
-    ServerConnector connector2 = addHttpConnector(proxy);
-    ServletHandler servletHandler = new ServletHandler();
-    ServletHolder servletHolder = servletHandler.addServletWithMapping(BasicAuthProxyServlet.class, "/*");
-    servletHolder.setInitParameter("maxThreads", "20");
-    proxy.setHandler(servletHandler);
-    proxy.start();
-    proxyPort = connector2.getLocalPort();
-
-    LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() {
-    if (proxy != null) {
-      try {
-        proxy.stop();
-      } catch (Exception e) {
-        LOGGER.error("Failed to properly close proxy", e);
-      }
-    }
-    if (httpServer != null) {
-      try {
-        httpServer.stop();
-      } catch (Exception e) {
-        LOGGER.error("Failed to properly close server", e);
-      }
-    }
-  }
-
-  @Test
-  public void nonPreemptiveProxyAuthWithPlainHttpTarget() throws IOException, InterruptedException, ExecutionException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String targetUrl = "http://localhost:" + httpPort + "/foo/bar";
-      Request request = get(targetUrl)
-              .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))
-              // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))
-              .build();
-      Future<Response> responseFuture = client.executeRequest(request);
-      Response response = responseFuture.get();
-
-      Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-      Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
-    }
-  }
+    private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpTest.class);
 
-  @SuppressWarnings("serial")
-  public static class BasicAuthProxyServlet extends ProxyServlet {
+    private int httpPort;
+    private int proxyPort;
 
-    @Override
-    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
-      LOGGER.debug(">>> got a request !");
+    private Server httpServer;
+    private Server proxy;
 
-      String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
-      if (authorization == null) {
-        response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
-        response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
-        response.getOutputStream().flush();
+    @SuppressWarnings("serial")
+    public static class BasicAuthProxyServlet extends ProxyServlet {
 
-      } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
-        super.service(request, response);
+        @Override
+        protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
+            LOGGER.debug(">>> got a request !");
+
+            String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
+            if (authorization == null) {
+                response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
+                response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
+                response.getOutputStream().flush();
+
+            } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
+                super.service(request, response);
+
+            } else {
+                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+                response.getOutputStream().flush();
+            }
+        }
+    }
+
+    @BeforeClass
+    public void setUpGlobal() throws Exception {
+
+        httpServer = new Server();
+        ServerConnector connector1 = addHttpConnector(httpServer);
+        httpServer.setHandler(new EchoHandler());
+        httpServer.start();
+        httpPort = connector1.getLocalPort();
+
+        proxy = new Server();
+        ServerConnector connector2 = addHttpConnector(proxy);
+        ServletHandler servletHandler = new ServletHandler();
+        ServletHolder servletHolder = servletHandler.addServletWithMapping(BasicAuthProxyServlet.class, "/*");
+        servletHolder.setInitParameter("maxThreads", "20");
+        proxy.setHandler(servletHandler);
+        proxy.start();
+        proxyPort = connector2.getLocalPort();
+
+        LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        if (proxy != null) {
+            try {
+                proxy.stop();
+            } catch (Exception e) {
+                LOGGER.error("Failed to properly close proxy", e);
+            }
+        }
+        if (httpServer != null) {
+            try {
+                httpServer.stop();
+            } catch (Exception e) {
+                LOGGER.error("Failed to properly close server", e);
+            }
+        }
+    }
 
-      } else {
-        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
-        response.getOutputStream().flush();
-      }
+    @Test
+    public void nonPreemptiveProxyAuthWithPlainHttpTarget() throws IOException, InterruptedException, ExecutionException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String targetUrl = "http://localhost:" + httpPort + "/foo/bar";
+            Request request = get(targetUrl)//
+                    .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))//
+                    // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))//
+                    .build();
+            Future<Response> responseFuture = client.executeRequest(request);
+            Response response = responseFuture.get();
+
+            Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+            Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
+        }
     }
-  }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
index a1919f6f4..4df3dc866 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpProxyToHttpsTest.java
@@ -13,6 +13,17 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
@@ -25,86 +36,74 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHENTICATE;
-import static io.netty.handler.codec.http.HttpHeaderNames.PROXY_AUTHORIZATION;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
-
 /**
  * Test that validates that when having an HTTP proxy and trying to access an HTTPS through the proxy the proxy credentials should be passed during the CONNECT request.
  */
 public class BasicHttpProxyToHttpsTest {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpsTest.class);
-
-  private int httpPort;
-  private int proxyPort;
-
-  private Server httpServer;
-  private Server proxy;
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-
-    // HTTP server
-    httpServer = new Server();
-    ServerConnector connector1 = addHttpsConnector(httpServer);
-    httpServer.setHandler(new EchoHandler());
-    httpServer.start();
-    httpPort = connector1.getLocalPort();
-
-    // proxy
-    proxy = new Server();
-    ServerConnector connector2 = addHttpConnector(proxy);
-    ConnectHandler connectHandler = new ConnectHandler() {
-
-      @Override
-      protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {
-        String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
-        if (authorization == null) {
-          response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
-          response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
-          return false;
-        } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
-          return true;
+    private static final Logger LOGGER = LoggerFactory.getLogger(BasicHttpProxyToHttpsTest.class);
+
+    private int httpPort;
+    private int proxyPort;
+
+    private Server httpServer;
+    private Server proxy;
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+
+        // HTTP server
+        httpServer = new Server();
+        ServerConnector connector1 = addHttpsConnector(httpServer);
+        httpServer.setHandler(new EchoHandler());
+        httpServer.start();
+        httpPort = connector1.getLocalPort();
+
+        // proxy
+        proxy = new Server();
+        ServerConnector connector2 = addHttpConnector(proxy);
+        ConnectHandler connectHandler = new ConnectHandler() {
+
+            @Override
+            protected boolean handleAuthentication(HttpServletRequest request, HttpServletResponse response, String address) {
+                String authorization = request.getHeader(PROXY_AUTHORIZATION.toString());
+                if (authorization == null) {
+                    response.setStatus(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);
+                    response.setHeader(PROXY_AUTHENTICATE.toString(), "Basic realm=\"Fake Realm\"");
+                    return false;
+                } else if (authorization.equals("Basic am9obmRvZTpwYXNz")) {
+                    return true;
+                }
+                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+                return false;
+            }
+        };
+        proxy.setHandler(connectHandler);
+        proxy.start();
+        proxyPort = connector2.getLocalPort();
+
+        LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        httpServer.stop();
+        proxy.stop();
+    }
+
+    @Test
+    public void nonPreemptiveProxyAuthWithHttpsTarget() throws IOException, InterruptedException, ExecutionException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setUseInsecureTrustManager(true))) {
+            String targetUrl = "https://localhost:" + httpPort + "/foo/bar";
+            Request request = get(targetUrl)//
+                    .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))//
+                    // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))//
+                    .build();
+            Future<Response> responseFuture = client.executeRequest(request);
+            Response response = responseFuture.get();
+
+            Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+            Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
         }
-        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
-        return false;
-      }
-    };
-    proxy.setHandler(connectHandler);
-    proxy.start();
-    proxyPort = connector2.getLocalPort();
-
-    LOGGER.info("Local HTTP Server (" + httpPort + "), Proxy (" + proxyPort + ") started successfully");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    httpServer.stop();
-    proxy.stop();
-  }
-
-  @Test
-  public void nonPreemptiveProxyAuthWithHttpsTarget() throws IOException, InterruptedException, ExecutionException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setUseInsecureTrustManager(true))) {
-      String targetUrl = "https://localhost:" + httpPort + "/foo/bar";
-      Request request = get(targetUrl)
-              .setProxyServer(proxyServer("127.0.0.1", proxyPort).setRealm(realm(AuthScheme.BASIC, "johndoe", "pass")))
-              // .setRealm(realm(AuthScheme.BASIC, "user", "passwd"))
-              .build();
-      Future<Response> responseFuture = client.executeRequest(request);
-      Response response = responseFuture.get();
-
-      Assert.assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-      Assert.assertEquals("/foo/bar", response.getHeader("X-pathInfo"));
     }
-  }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index e76293bd9..dee17f46a 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -13,16 +13,49 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.codec.http.cookie.DefaultCookie;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.ConnectException;
+import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.net.ssl.SSLException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
 import org.asynchttpclient.request.body.multipart.StringPart;
 import org.asynchttpclient.test.EventCollectingHandler;
-import org.asynchttpclient.test.TestUtils.*;
+import org.asynchttpclient.test.TestUtils.AsyncCompletionHandlerAdapter;
 import org.asynchttpclient.testserver.HttpServer;
 import org.asynchttpclient.testserver.HttpServer.EchoHandler;
 import org.asynchttpclient.testserver.HttpTest;
@@ -31,919 +64,936 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.net.ssl.SSLException;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ConnectException;
-import java.net.UnknownHostException;
-import java.nio.charset.StandardCharsets;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
+public class BasicHttpTest extends HttpTest {
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
-import static org.testng.Assert.*;
+    private static HttpServer server;
+
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
+    }
+
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
+    }
+
+    private static String getTargetUrl() {
+        return server.getHttpUrl() + "/foo/bar";
+    }
+
+    @Test
+    public void getRootUrl() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String url = server.getHttpUrl();
+                server.enqueueOk();
+
+                Response response = client.executeRequest(get(url), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), url);
+            });
+        });
+    }
 
-public class BasicHttpTest extends HttpTest {
+    @Test
+    public void getUrlWithPathWithoutQuery() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
 
-  private static HttpServer server;
-
-  @BeforeClass
-  public static void start() throws Throwable {
-    server = new HttpServer();
-    server.start();
-  }
-
-  @AfterClass
-  public static void stop() throws Throwable {
-    server.close();
-  }
-
-  private static String getTargetUrl() {
-    return server.getHttpUrl() + "/foo/bar";
-  }
-
-  @Test
-  public void getRootUrl() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        String url = server.getHttpUrl();
-        server.enqueueOk();
-
-        Response response = client.executeRequest(get(url), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-        assertEquals(response.getUri().toUrl(), url);
-      }));
-  }
-
-  @Test
-  public void getUrlWithPathWithoutQuery() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueOk();
-
-        Response response = client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-        assertEquals(response.getUri().toUrl(), getTargetUrl());
-      }));
-  }
-
-  @Test
-  public void getUrlWithPathWithQuery() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        String targetUrl = getTargetUrl() + "?q=+%20x";
-        Request request = get(targetUrl).build();
-        assertEquals(request.getUrl(), targetUrl);
-        server.enqueueOk();
-
-        Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-        assertEquals(response.getUri().toUrl(), targetUrl);
-      }));
-  }
-
-  @Test
-  public void getUrlWithPathWithQueryParams() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueOk();
-
-        Response response = client.executeRequest(get(getTargetUrl()).addQueryParam("q", "a b"), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-        assertEquals(response.getUri().toUrl(), getTargetUrl() + "?q=a%20b");
-      }));
-  }
-
-  @Test
-  public void getResponseBody() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final String body = "Hello World";
-
-        server.enqueueResponse(response -> {
-          response.setStatus(200);
-          response.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-          writeResponseBody(response, body);
-        });
-
-        client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public Response onCompleted(Response response) {
-            assertEquals(response.getStatusCode(), 200);
-            String contentLengthHeader = response.getHeader(CONTENT_LENGTH);
-            assertNotNull(contentLengthHeader);
-            assertEquals(Integer.parseInt(contentLengthHeader), body.length());
-            assertContentTypesEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            assertEquals(response.getResponseBody(), body);
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void getWithHeaders() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        for (int i = 1; i < 5; i++) {
-          h.add("Test" + i, "Test" + i);
-        }
-
-        server.enqueueEcho();
-
-        client.executeRequest(get(getTargetUrl()).setHeaders(h), new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public Response onCompleted(Response response) {
-            assertEquals(response.getStatusCode(), 200);
-            for (int i = 1; i < 5; i++) {
-              assertEquals(response.getHeader("X-Test" + i), "Test" + i);
-            }
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void postWithHeadersAndFormParams() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-
-        Map<String, List<String>> m = new HashMap<>();
-        for (int i = 0; i < 5; i++) {
-          m.put("param_" + i, Collections.singletonList("value_" + i));
-        }
-
-        Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
-
-        server.enqueueEcho();
-
-        client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public Response onCompleted(Response response) {
-            assertEquals(response.getStatusCode(), 200);
-            for (int i = 1; i < 5; i++) {
-              assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-            }
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void headHasEmptyBody() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueOk();
-
-        Response response = client.executeRequest(head(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-          @Override
-          public Response onCompleted(Response response) {
-            assertEquals(response.getStatusCode(), 200);
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-
-        assertTrue(response.getResponseBody().isEmpty());
-      }));
-  }
-
-  @Test(expectedExceptions = IllegalArgumentException.class)
-  public void nullSchemeThrowsNPE() throws Throwable {
-    withClient().run(client -> client.prepareGet("gatling.io").execute());
-  }
-
-  @Test
-  public void jettyRespondsWithChunkedTransferEncoding() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        client.prepareGet(getTargetUrl())
-                .execute(new AsyncCompletionHandlerAdapter() {
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader(TRANSFER_ENCODING), HttpHeaderValues.CHUNKED.toString());
-                    return response;
-                  }
-                }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void getWithCookies() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final Cookie coo = new DefaultCookie("foo", "value");
-        coo.setDomain("/");
-        coo.setPath("/");
-        server.enqueueEcho();
-
-        client.prepareGet(getTargetUrl())
-                .addCookie(coo)
-                .execute(new AsyncCompletionHandlerAdapter() {
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    List<Cookie> cookies = response.getCookies();
-                    assertEquals(cookies.size(), 1);
-                    assertEquals(cookies.get(0).toString(), "foo=value");
-                    return response;
-                  }
-                }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void defaultRequestBodyEncodingIsUtf8() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        Response response = client.preparePost(getTargetUrl())
-                .setBody("\u017D\u017D\u017D\u017D\u017D\u017D")
-                .execute().get();
-        assertEquals(response.getResponseBodyAsBytes(), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes(UTF_8));
-      }));
-  }
-
-  @Test
-  public void postFormParametersAsBodyString() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-          sb.append("param_").append(i).append("=value_").append(i).append("&");
-        }
-        sb.setLength(sb.length() - 1);
-
-        server.enqueueEcho();
-        client.preparePost(getTargetUrl())
-                .setHeaders(h)
-                .setBody(sb.toString())
-                .execute(new AsyncCompletionHandlerAdapter() {
-
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                Response response = client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), getTargetUrl());
+            });
+        });
+    }
+
+    @Test
+    public void getUrlWithPathWithQuery() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String targetUrl = getTargetUrl() + "?q=+%20x";
+                Request request = get(targetUrl).build();
+                assertEquals(request.getUrl(), targetUrl);
+                server.enqueueOk();
+
+                Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), targetUrl);
+            });
+        });
+    }
 
+    @Test
+    public void getUrlWithPathWithQueryParams() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+
+                Response response = client.executeRequest(get(getTargetUrl()).addQueryParam("q", "a b"), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), getTargetUrl() + "?q=a%20b");
+            });
+        });
+    }
+
+    @Test
+    public void getResponseBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final String body = "Hello World";
+
+                server.enqueueResponse(response -> {
+                    response.setStatus(200);
+                    response.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    writeResponseBody(response, body);
+                });
+
+                client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        String contentLengthHeader = response.getHeader(CONTENT_LENGTH);
+                        assertNotNull(contentLengthHeader);
+                        assertEquals(Integer.parseInt(contentLengthHeader), body.length());
+                        assertContentTypesEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                        assertEquals(response.getResponseBody(), body);
+                        return response;
                     }
-                    return response;
-                  }
                 }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void postFormParametersAsBodyStream() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-          sb.append("param_").append(i).append("=value_").append(i).append("&");
-        }
-        sb.setLength(sb.length() - 1);
-
-        server.enqueueEcho();
-        client.preparePost(getTargetUrl())
-                .setHeaders(h)
-                .setBody(new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8)))
-                .execute(new AsyncCompletionHandlerAdapter() {
-
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
+            });
+        });
+    }
+
+    @Test
+    public void getWithHeaders() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                for (int i = 1; i < 5; i++) {
+                    h.add("Test" + i, "Test" + i);
+                }
+
+                server.enqueueEcho();
+
+                client.executeRequest(get(getTargetUrl()).setHeaders(h), new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                        }
+                        return response;
                     }
-                    return response;
-                  }
                 }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void putFormParametersAsBodyStream() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-          sb.append("param_").append(i).append("=value_").append(i).append("&");
-        }
-        sb.setLength(sb.length() - 1);
-        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-        server.enqueueEcho();
-        client.preparePut(getTargetUrl())
-                .setHeaders(h)
-                .setBody(is)
-                .execute(new AsyncCompletionHandlerAdapter() {
-
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                      assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            });
+        });
+    }
+
+    @Test
+    public void postWithHeadersAndFormParams() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+
+                Map<String, List<String>> m = new HashMap<>();
+                for (int i = 0; i < 5; i++) {
+                    m.put("param_" + i, Arrays.asList("value_" + i));
+                }
+
+                Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
+
+                server.enqueueEcho();
+
+                client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                        }
+                        return response;
                     }
-                    return response;
-                  }
                 }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void postSingleStringPart() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        client.preparePost(getTargetUrl())
-                .addBodyPart(new StringPart("foo", "bar"))
-                .execute(new AsyncCompletionHandlerAdapter() {
-                  @Override
-                  public Response onCompleted(Response response) {
-                    String requestContentType = response.getHeader("X-" + CONTENT_TYPE);
-                    String boundary = requestContentType.substring((requestContentType.indexOf("boundary") + "boundary".length() + 1));
-                    assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
-                    return response;
-                  }
+            });
+        });
+    }
+
+    @Test
+    public void headHasEmptyBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+
+                Response response = client.executeRequest(head(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        return response;
+                    }
                 }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void getVirtualHost() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        String virtualHost = "localhost:" + server.getHttpPort();
-
-        server.enqueueEcho();
-        Response response = client.prepareGet(getTargetUrl())
-                .setVirtualHost(virtualHost)
-                .execute(new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
-
-        assertEquals(response.getStatusCode(), 200);
-        if (response.getHeader("X-" + HOST) == null) {
-          System.err.println(response);
-        }
-        assertEquals(response.getHeader("X-" + HOST), virtualHost);
-      }));
-  }
-
-  @Test(expectedExceptions = CancellationException.class)
-  public void cancelledFutureThrowsCancellationException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders headers = new DefaultHttpHeaders();
-        headers.add("X-Delay", 5_000);
-        server.enqueueEcho();
-
-        Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public void onThrowable(Throwable t) {
-          }
-        });
-        future.cancel(true);
-        future.get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void futureTimeOutThrowsTimeoutException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders headers = new DefaultHttpHeaders();
-        headers.add("X-Delay", 5_000);
-
-        server.enqueueEcho();
-        Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public void onThrowable(Throwable t) {
-          }
-        });
-
-        future.get(2, SECONDS);
-      }));
-  }
-
-  @Test(expectedExceptions = ConnectException.class)
-  public void connectFailureThrowsConnectException() throws Throwable {
-    withClient().run(client -> {
-      int dummyPort = findFreePort();
-      try {
-        client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public void onThrowable(Throwable t) {
-          }
-        }).get(TIMEOUT, SECONDS);
-      } catch (ExecutionException ex) {
-        throw ex.getCause();
-      }
-    });
-  }
-
-  @Test
-  public void connectFailureNotifiesHandlerWithConnectException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final CountDownLatch l = new CountDownLatch(1);
-        int port = findFreePort();
-
-        client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public void onThrowable(Throwable t) {
-            try {
-              assertTrue(t instanceof ConnectException);
-            } finally {
-              l.countDown();
-            }
-          }
-        });
-
-        if (!l.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-      }));
-  }
-
-  @Test(expectedExceptions = UnknownHostException.class)
-  public void unknownHostThrowsUnknownHostException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        try {
-          client.prepareGet("http://null.gatling.io").execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-          }).get(TIMEOUT, SECONDS);
-        } catch (ExecutionException e) {
-          throw e.getCause();
-        }
-      }));
-  }
-
-  @Test
-  public void getEmptyBody() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueOk();
-        Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter())
-                .get(TIMEOUT, SECONDS);
-        assertTrue(response.getResponseBody().isEmpty());
-      }));
-  }
-
-  @Test
-  public void getEmptyBodyNotifiesHandler() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final AtomicBoolean handlerWasNotified = new AtomicBoolean();
-
-        server.enqueueOk();
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public Response onCompleted(Response response) {
-            assertEquals(response.getStatusCode(), 200);
-            handlerWasNotified.set(true);
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-        assertTrue(handlerWasNotified.get());
-      }));
-  }
-
-  @Test
-  public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> message = new AtomicReference<>();
-
-        server.enqueueOk();
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public Response onCompleted(Response response) {
-            throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToOnThrowable");
-
-          }
-
-          @Override
-          public void onThrowable(Throwable t) {
-            message.set(t.getMessage());
-            latch.countDown();
-          }
-        });
-
-        if (!latch.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-
-        assertEquals(message.get(), "FOO");
-      }));
-  }
-
-  @Test(expectedExceptions = IllegalStateException.class)
-  public void exceptionInOnCompletedGetNotifiedToFuture() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueOk();
-        Future<Response> whenResponse = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public Response onCompleted(Response response) {
-            throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToFuture");
-          }
-
-          @Override
-          public void onThrowable(Throwable t) {
-          }
-        });
-
-        try {
-          whenResponse.get(TIMEOUT, SECONDS);
-        } catch (ExecutionException e) {
-          throw e.getCause();
-        }
-      }));
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void configTimeoutNotifiesOnThrowableAndFuture() throws Throwable {
-    withClient(config().setRequestTimeout(1_000)).run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders headers = new DefaultHttpHeaders();
-        headers.add("X-Delay", 5_000); // delay greater than timeout
-
-        final AtomicBoolean onCompletedWasNotified = new AtomicBoolean();
-        final AtomicBoolean onThrowableWasNotifiedWithTimeoutException = new AtomicBoolean();
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        server.enqueueEcho();
-        Future<Response> whenResponse = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public Response onCompleted(Response response) {
-            onCompletedWasNotified.set(true);
-            latch.countDown();
-            return response;
-          }
-
-          @Override
-          public void onThrowable(Throwable t) {
-            onThrowableWasNotifiedWithTimeoutException.set(t instanceof TimeoutException);
-            latch.countDown();
-          }
-        });
-
-        if (!latch.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-
-        assertFalse(onCompletedWasNotified.get());
-        assertTrue(onThrowableWasNotifiedWithTimeoutException.get());
-
-        try {
-          whenResponse.get(TIMEOUT, SECONDS);
-        } catch (ExecutionException e) {
-          throw e.getCause();
-        }
-      }));
-  }
-
-  @Test(expectedExceptions = TimeoutException.class)
-  public void configRequestTimeoutHappensInDueTime() throws Throwable {
-    withClient(config().setRequestTimeout(1_000)).run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-        h.add("X-Delay", 2_000);
-
-        server.enqueueEcho();
-        long start = unpreciseMillisTime();
-        try {
-          client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
-        } catch (Throwable ex) {
-          final long elapsedTime = unpreciseMillisTime() - start;
-          assertTrue(elapsedTime >= 1_000 && elapsedTime <= 1_500);
-          throw ex.getCause();
-        }
-      }));
-  }
-
-  @Test
-  public void getProperPathAndQueryString() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        client.prepareGet(getTargetUrl() + "?foo=bar").execute(new AsyncCompletionHandlerAdapter() {
-          @Override
-          public Response onCompleted(Response response) {
-            assertTrue(response.getHeader("X-PathInfo") != null);
-            assertTrue(response.getHeader("X-QueryString") != null);
-            return response;
-          }
-        }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void connectionIsReusedForSequentialRequests() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        final CountDownLatch l = new CountDownLatch(2);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-          volatile String clientPort;
-
-          @Override
-          public Response onCompleted(Response response) {
+
+                assertTrue(response.getResponseBody().isEmpty());
+            });
+        });
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void nullSchemeThrowsNPE() throws Throwable {
+        withClient().run(client -> client.prepareGet("gatling.io").execute());
+    }
+
+    @Test
+    public void jettyRespondsWithChunkedTransferEncoding() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl())//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                assertEquals(response.getHeader(TRANSFER_ENCODING), HttpHeaderValues.CHUNKED.toString());
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void getWithCookies() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final Cookie coo = new DefaultCookie("foo", "value");
+                coo.setDomain("/");
+                coo.setPath("/");
+                server.enqueueEcho();
+
+                client.prepareGet(getTargetUrl())//
+                        .addCookie(coo)//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                List<Cookie> cookies = response.getCookies();
+                                assertEquals(cookies.size(), 1);
+                                assertEquals(cookies.get(0).toString(), "foo=value");
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void defaultRequestBodyEncodingIsIso() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.preparePost(getTargetUrl())//
+                        .setBody("\u017D\u017D\u017D\u017D\u017D\u017D")//
+                        .execute().get();
+                assertEquals(response.getResponseBodyAsBytes(), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes(ISO_8859_1));
+            });
+        });
+    }
+
+    @Test
+    public void postFormParametersAsBodyString() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(sb.toString())//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postFormParametersAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8)))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void putFormParametersAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+                ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
+
+                server.enqueueEcho();
+                client.preparePut(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(is)//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postSingleStringPart() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .addBodyPart(new StringPart("foo", "bar"))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                String requestContentType = response.getHeader("X-" + CONTENT_TYPE);
+                                String boundary = requestContentType.substring((requestContentType.indexOf("boundary") + "boundary".length() + 1));
+                                assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void getVirtualHost() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String virtualHost = "localhost:" + server.getHttpPort();
+
+                server.enqueueEcho();
+                Response response = client.prepareGet(getTargetUrl())//
+                        .setVirtualHost(virtualHost)//
+                        .execute(new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+
+                assertEquals(response.getStatusCode(), 200);
+                if (response.getHeader("X-" + HOST) == null) {
+                    System.err.println(response);
+                }
+                assertEquals(response.getHeader("X-" + HOST), virtualHost);
+            });
+        });
+    }
+
+    @Test(expectedExceptions = CancellationException.class)
+    public void cancelledFutureThrowsCancellationException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000);
+                server.enqueueEcho();
+
+                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                    }
+                });
+                future.cancel(true);
+                future.get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void futureTimeOutThrowsTimeoutException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000);
+
+                server.enqueueEcho();
+                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                    }
+                });
+
+                future.get(2, SECONDS);
+            });
+        });
+    }
+
+    @Test(expectedExceptions = ConnectException.class)
+    public void connectFailureThrowsConnectException() throws Throwable {
+        withClient().run(client -> {
+            int dummyPort = findFreePort();
             try {
-              assertEquals(response.getStatusCode(), 200);
-              if (clientPort == null) {
-                clientPort = response.getHeader("X-ClientPort");
-              } else {
-                // verify that the server saw the same client remote address/port
-                // so the same connection was used
-                assertEquals(response.getHeader("X-ClientPort"), clientPort);
-              }
-            } finally {
-              l.countDown();
-            }
-            return response;
-          }
-        };
-
-        server.enqueueEcho();
-        client.prepareGet(getTargetUrl()).execute(handler).get(TIMEOUT, SECONDS);
-        server.enqueueEcho();
-        client.prepareGet(getTargetUrl()).execute(handler);
-
-        if (!l.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-      }));
-  }
-
-  @Test(expectedExceptions = MaxRedirectException.class)
-  public void reachingMaxRedirectThrowsMaxRedirectException() throws Throwable {
-    withClient(config().setMaxRedirects(1).setFollowRedirect(true)).run(client ->
-      withServer(server).run(server -> {
-        try {
-          // max redirect is 1, so second redirect will fail
-          server.enqueueRedirect(301, getTargetUrl());
-          server.enqueueRedirect(301, getTargetUrl());
-          client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) {
-              fail("Should not be here");
-              return response;
+                client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                    }
+                }).get(TIMEOUT, SECONDS);
+            } catch (ExecutionException ex) {
+                throw ex.getCause();
             }
+        });
+    }
+
+    @Test
+    public void connectFailureNotifiesHandlerWithConnectException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch l = new CountDownLatch(1);
+                int port = findFreePort();
+
+                client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        try {
+                            assertTrue(t instanceof ConnectException);
+                        } finally {
+                            l.countDown();
+                        }
+                    }
+                });
 
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-          }).get(TIMEOUT, SECONDS);
-        } catch (ExecutionException e) {
-          throw e.getCause();
-        }
-      }));
-  }
+                if (!l.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
+    }
+
+    @Test(expectedExceptions = UnknownHostException.class)
+    public void unknownHostThrowsUnknownHostException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                try {
+                    client.prepareGet("http://null.gatling.io").execute(new AsyncCompletionHandlerAdapter() {
+                        @Override
+                        public void onThrowable(Throwable t) {
+                        }
+                    }).get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
+                }
+            });
+        });
+    }
+
+    @Test
+    public void getEmptyBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+                Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter())//
+                        .get(TIMEOUT, SECONDS);
+                assertTrue(response.getResponseBody().isEmpty());
+            });
+        });
+    }
+
+    @Test
+    public void getEmptyBodyNotifiesHandler() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final AtomicBoolean handlerWasNotified = new AtomicBoolean();
+
+                server.enqueueOk();
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        handlerWasNotified.set(true);
+                        return response;
+                    }
+                }).get(TIMEOUT, SECONDS);
+                assertTrue(handlerWasNotified.get());
+            });
+        });
+    }
 
-  @Test
-  public void nonBlockingNestedRequetsFromIoThreadAreFine() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
+    @Test
+    public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch latch = new CountDownLatch(1);
+                final AtomicReference<String> message = new AtomicReference<>();
 
-        final int maxNested = 5;
+                server.enqueueOk();
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToOnThrowable");
 
-        final CountDownLatch latch = new CountDownLatch(2);
+                    }
 
-        final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        message.set(t.getMessage());
+                        latch.countDown();
+                    }
+                });
 
-          private AtomicInteger nestedCount = new AtomicInteger(0);
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
 
-          @Override
-          public Response onCompleted(Response response) {
-            try {
-              if (nestedCount.getAndIncrement() < maxNested) {
-                client.prepareGet(getTargetUrl()).execute(this);
-              }
-            } finally {
-              latch.countDown();
-            }
-            return response;
-          }
-        };
-
-        for (int i = 0; i < maxNested + 1; i++) {
-          server.enqueueOk();
-        }
-
-        client.prepareGet(getTargetUrl()).execute(handler);
-
-        if (!latch.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-      }));
-  }
-
-  @Test
-  public void optionsIsSupported() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        Response response = client.prepareOptions(getTargetUrl()).execute().get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
-      }));
-  }
-
-  @Test
-  public void cancellingFutureNotifiesOnThrowableWithCancellationException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
-        h.add("X-Delay", 2_000);
-
-        CountDownLatch latch = new CountDownLatch(1);
-
-        Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody("Body").execute(new AsyncCompletionHandlerAdapter() {
-
-          @Override
-          public void onThrowable(Throwable t) {
-            if (t instanceof CancellationException) {
-              latch.countDown();
-            }
-          }
-        });
-
-        future.cancel(true);
-        if (!latch.await(TIMEOUT, SECONDS)) {
-          fail("Timed out");
-        }
-      }));
-  }
-
-  @Test
-  public void getShouldAllowBody() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server ->
-        client.prepareGet(getTargetUrl()).setBody("Boo!").execute()));
-  }
-
-  @Test(expectedExceptions = IllegalArgumentException.class)
-  public void malformedUriThrowsException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> client.prepareGet(String.format("http:localhost:%d/foo/test", server.getHttpPort())).build()));
-  }
-
-  @Test
-  public void emptyResponseBodyBytesAreEmpty() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        Response response = client.prepareGet(getTargetUrl()).execute().get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBodyAsBytes(), new byte[]{});
-      }));
-  }
-
-  @Test
-  public void newConnectionEventsAreFired() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-
-        Request request = get(getTargetUrl()).build();
-
-        EventCollectingHandler handler = new EventCollectingHandler();
-        client.executeRequest(request, handler).get(3, SECONDS);
-        handler.waitForCompletion(3, SECONDS);
-
-        Object[] expectedEvents = new Object[]{
-                CONNECTION_POOL_EVENT,
-                HOSTNAME_RESOLUTION_EVENT,
-                HOSTNAME_RESOLUTION_SUCCESS_EVENT,
-                CONNECTION_OPEN_EVENT,
-                CONNECTION_SUCCESS_EVENT,
-                REQUEST_SEND_EVENT,
-                HEADERS_WRITTEN_EVENT,
-                STATUS_RECEIVED_EVENT,
-                HEADERS_RECEIVED_EVENT,
-                CONNECTION_OFFER_EVENT,
-                COMPLETED_EVENT};
-
-        assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-      }));
-  }
-
-  @Test
-  public void requestingPlainHttpEndpointOverHttpsThrowsSslException() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        try {
-          client.prepareGet(getTargetUrl().replace("http", "https")).execute().get();
-          fail("Request shouldn't succeed");
-        } catch (ExecutionException e) {
-          assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
-          assertTrue(e.getCause().getCause() instanceof SSLException, "Root cause should be a SslException");
-        }
-      }));
-  }
-
-  @Test
-  public void postUnboundedInputStreamAsBodyStream() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
-        server.enqueue(new AbstractHandler() {
-          EchoHandler chain = new EchoHandler();
-
-          @Override
-          public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
-                  throws IOException, ServletException {
-            assertEquals(request.getHeader(TRANSFER_ENCODING.toString()), HttpHeaderValues.CHUNKED.toString());
-            assertNull(request.getHeader(CONTENT_LENGTH.toString()));
-            chain.handle(target, request, httpServletRequest, httpServletResponse);
-          }
-        });
-        server.enqueueEcho();
-
-        client.preparePost(getTargetUrl())
-                .setHeaders(h)
-                .setBody(new ByteArrayInputStream("{}".getBytes(StandardCharsets.ISO_8859_1)))
-                .execute(new AsyncCompletionHandlerAdapter() {
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getResponseBody(), "{}");
-                    return response;
-                  }
-                }).get(TIMEOUT, SECONDS);
-      }));
-  }
-
-  @Test
-  public void postInputStreamWithContentLengthAsBodyGenerator() throws Throwable {
-    withClient().run(client ->
-      withServer(server).run(server -> {
-        HttpHeaders h = new DefaultHttpHeaders();
-        h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
-        server.enqueue(new AbstractHandler() {
-          EchoHandler chain = new EchoHandler();
-
-          @Override
-          public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
-                  throws IOException, ServletException {
-            assertNull(request.getHeader(TRANSFER_ENCODING.toString()));
-            assertEquals(request.getHeader(CONTENT_LENGTH.toString()),
-                    Integer.toString("{}".getBytes(StandardCharsets.ISO_8859_1).length));
-            chain.handle(target, request, httpServletRequest, httpServletResponse);
-          }
-        });
-
-        byte[] bodyBytes = "{}".getBytes(StandardCharsets.ISO_8859_1);
-        InputStream bodyStream = new ByteArrayInputStream(bodyBytes);
-
-        client.preparePost(getTargetUrl())
-                .setHeaders(h)
-                .setBody(new InputStreamBodyGenerator(bodyStream, bodyBytes.length))
-                .execute(new AsyncCompletionHandlerAdapter() {
-
-                  @Override
-                  public Response onCompleted(Response response) {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getResponseBody(), "{}");
-                    return response;
-                  }
+                assertEquals(message.get(), "FOO");
+            });
+        });
+    }
+
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void exceptionInOnCompletedGetNotifiedToFuture() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+                Future<Response> whenResponse = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw unknownStackTrace(new IllegalStateException("FOO"), BasicHttpTest.class, "exceptionInOnCompletedGetNotifiedToFuture");
+                    }
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                    }
+                });
+
+                try {
+                    whenResponse.get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
+                }
+            });
+        });
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void configTimeoutNotifiesOnThrowableAndFuture() throws Throwable {
+        withClient(config().setRequestTimeout(1_000)).run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000); // delay greater than timeout
+
+                    final AtomicBoolean onCompletedWasNotified = new AtomicBoolean();
+                    final AtomicBoolean onThrowableWasNotifiedWithTimeoutException = new AtomicBoolean();
+                    final CountDownLatch latch = new CountDownLatch(1);
+
+                    server.enqueueEcho();
+                    Future<Response> whenResponse = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+
+                        @Override
+                        public Response onCompleted(Response response) throws Exception {
+                            onCompletedWasNotified.set(true);
+                            latch.countDown();
+                            return response;
+                        }
+
+                        @Override
+                        public void onThrowable(Throwable t) {
+                            onThrowableWasNotifiedWithTimeoutException.set(t instanceof TimeoutException);
+                            latch.countDown();
+                        }
+                    });
+
+                    if (!latch.await(TIMEOUT, SECONDS)) {
+                        fail("Timed out");
+                    }
+
+                    assertFalse(onCompletedWasNotified.get());
+                    assertTrue(onThrowableWasNotifiedWithTimeoutException.get());
+
+                    try {
+                        whenResponse.get(TIMEOUT, SECONDS);
+                    } catch (ExecutionException e) {
+                        throw e.getCause();
+                    }
+                });
+        });
+    }
+
+    @Test(expectedExceptions = TimeoutException.class)
+    public void configRequestTimeoutHappensInDueTime() throws Throwable {
+        withClient(config().setRequestTimeout(1_000)).run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+                h.add("X-Delay", 2_000);
+
+                server.enqueueEcho();
+                long start = unpreciseMillisTime();
+                try {
+                    client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
+                } catch (Throwable ex) {
+                    final long elapsedTime = unpreciseMillisTime() - start;
+                    assertTrue(elapsedTime >= 1_000 && elapsedTime <= 1_500);
+                    throw ex.getCause();
+                }
+            });
+        });
+    }
+
+    @Test
+    public void getProperPathAndQueryString() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl() + "?foo=bar").execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertTrue(response.getHeader("X-PathInfo") != null);
+                        assertTrue(response.getHeader("X-QueryString") != null);
+                        return response;
+                    }
                 }).get(TIMEOUT, SECONDS);
-      }));
-  }
+            });
+        });
+    }
+
+    @Test
+    public void connectionIsReusedForSequentialRequests() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch l = new CountDownLatch(2);
+
+                AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                    volatile String clientPort;
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        try {
+                            assertEquals(response.getStatusCode(), 200);
+                            if (clientPort == null) {
+                                clientPort = response.getHeader("X-ClientPort");
+                            } else {
+                                // verify that the server saw the same client remote address/port
+                                // so the same connection was used
+                                assertEquals(response.getHeader("X-ClientPort"), clientPort);
+                            }
+                        } finally {
+                            l.countDown();
+                        }
+                        return response;
+                    }
+                };
+
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(handler).get(TIMEOUT, SECONDS);
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(handler);
+
+                if (!l.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
+    }
+
+    @Test(expectedExceptions = MaxRedirectException.class)
+    public void reachingMaxRedirectThrowsMaxRedirectException() throws Throwable {
+        withClient(config().setMaxRedirects(1).setFollowRedirect(true)).run(client -> {
+            withServer(server).run(server -> {
+                try {
+                    // max redirect is 1, so second redirect will fail
+                    server.enqueueRedirect(301, getTargetUrl());
+                    server.enqueueRedirect(301, getTargetUrl());
+                    client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                        @Override
+                        public Response onCompleted(Response response) throws Exception {
+                            fail("Should not be here");
+                            return response;
+                        }
+
+                        @Override
+                        public void onThrowable(Throwable t) {
+                        }
+                    }).get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
+                }
+            });
+        });
+    }
+
+    @Test
+    public void nonBlockingNestedRequetsFromIoThreadAreFine() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                final int maxNested = 5;
+
+                final CountDownLatch latch = new CountDownLatch(2);
+
+                final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
+
+                    private AtomicInteger nestedCount = new AtomicInteger(0);
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        try {
+                            if (nestedCount.getAndIncrement() < maxNested) {
+                                client.prepareGet(getTargetUrl()).execute(this);
+                            }
+                        } finally {
+                            latch.countDown();
+                        }
+                        return response;
+                    }
+                };
+
+                for (int i = 0; i < maxNested + 1; i++) {
+                    server.enqueueOk();
+                }
+
+                client.prepareGet(getTargetUrl()).execute(handler);
+
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
+    }
+
+    @Test
+    public void optionsIsSupported() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.prepareOptions(getTargetUrl()).execute().get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+            });
+        });
+    }
+
+    @Test
+    public void cancellingFutureNotifiesOnThrowableWithCancellationException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+                h.add("X-Delay", 2_000);
+
+                CountDownLatch latch = new CountDownLatch(1);
+
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody("Body").execute(new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        if (t instanceof CancellationException) {
+                            latch.countDown();
+                        }
+                    }
+                });
+
+                future.cancel(true);
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
+    }
+
+    @Test
+    public void getShouldAllowBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
+            });
+        });
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void malformedUriThrowsException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                client.prepareGet(String.format("http:localhost:%d/foo/test", server.getHttpPort())).build();
+            });
+        });
+    }
+
+    @Test
+    public void emptyResponseBodyBytesAreEmpty() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.prepareGet(getTargetUrl()).execute().get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
+            });
+        });
+    }
+
+    @Test
+    public void newConnectionEventsAreFired() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                Request request = get(getTargetUrl()).build();
+
+                EventCollectingHandler handler = new EventCollectingHandler();
+                client.executeRequest(request, handler).get(3, SECONDS);
+                handler.waitForCompletion(3, SECONDS);
+
+                Object[] expectedEvents = new Object[] {//
+                CONNECTION_POOL_EVENT,//
+                        HOSTNAME_RESOLUTION_EVENT,//
+                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
+                        CONNECTION_OPEN_EVENT,//
+                        CONNECTION_SUCCESS_EVENT,//
+                        REQUEST_SEND_EVENT,//
+                        HEADERS_WRITTEN_EVENT,//
+                        STATUS_RECEIVED_EVENT,//
+                        HEADERS_RECEIVED_EVENT,//
+                        CONNECTION_OFFER_EVENT,//
+                        COMPLETED_EVENT };
+
+                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+            });
+        });
+    }
+
+    @Test
+    public void requestingPlainHttpEndpointOverHttpsThrowsSslException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                try {
+                    client.prepareGet(getTargetUrl().replace("http", "https")).execute().get();
+                    fail("Request shouldn't succeed");
+                } catch (ExecutionException e) {
+                    assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
+                    assertTrue(e.getCause().getCause() instanceof SSLException, "Root cause should be a SslException");
+                }
+            });
+        });
+    }
+
+    @Test
+    public void postUnboundedInputStreamAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
+                server.enqueue(new AbstractHandler() {
+                    EchoHandler chain = new EchoHandler();
+
+                    @Override
+                    public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
+                            throws IOException, ServletException {
+                        assertEquals(request.getHeader(TRANSFER_ENCODING.toString()), HttpHeaderValues.CHUNKED.toString());
+                        assertNull(request.getHeader(CONTENT_LENGTH.toString()));
+                        chain.handle(target, request, httpServletRequest, httpServletResponse);
+                    }
+                });
+                server.enqueueEcho();
+
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(new ByteArrayInputStream("{}".getBytes(StandardCharsets.ISO_8859_1)))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                assertEquals(response.getResponseBody(), "{}");
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postInputStreamWithContentLengthAsBodyGenerator() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);
+                server.enqueue(new AbstractHandler() {
+                    EchoHandler chain = new EchoHandler();
+
+                    @Override
+                    public void handle(String target, org.eclipse.jetty.server.Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)
+                            throws IOException, ServletException {
+                        assertNull(request.getHeader(TRANSFER_ENCODING.toString()));
+                        assertEquals(request.getHeader(CONTENT_LENGTH.toString()),//
+                                Integer.toString("{}".getBytes(StandardCharsets.ISO_8859_1).length));
+                        chain.handle(target, request, httpServletRequest, httpServletResponse);
+                    }
+                });
+
+                byte[] bodyBytes = "{}".getBytes(StandardCharsets.ISO_8859_1);
+                InputStream bodyStream = new ByteArrayInputStream(bodyBytes);
+
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(new InputStreamBodyGenerator(bodyStream, bodyBytes.length))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                assertEquals(response.getResponseBody(), "{}");
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 216e26043..40c01f048 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -15,6 +15,21 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLHandshakeException;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.asynchttpclient.testserver.HttpServer;
@@ -23,186 +38,185 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.net.ssl.SSLHandshakeException;
-import javax.servlet.http.HttpServletResponse;
-import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public class BasicHttpsTest extends HttpTest {
 
-  private static HttpServer server;
-
-  @BeforeClass
-  public static void start() throws Throwable {
-    server = new HttpServer();
-    server.start();
-  }
-
-  @AfterClass
-  public static void stop() throws Throwable {
-    server.close();
-  }
-
-  private static String getTargetUrl() {
-    return server.getHttpsUrl() + "/foo/bar";
-  }
-
-  @Test
-  public void postFileOverHttps() throws Throwable {
-    logger.debug(">>> postBodyOverHttps");
-    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-
-        Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader(CONTENT_TYPE, "text/html").execute().get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-      }));
-    logger.debug("<<< postBodyOverHttps");
-  }
-
-  @Test
-  public void postLargeFileOverHttps() throws Throwable {
-    logger.debug(">>> postLargeFileOverHttps");
-    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-
-        Response resp = client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_FILE).setHeader(CONTENT_TYPE, "image/png").execute().get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBodyAsBytes().length, LARGE_IMAGE_FILE.length());
-      }));
-    logger.debug("<<< postLargeFileOverHttps");
-  }
-
-  @Test
-  public void multipleSequentialPostRequestsOverHttps() throws Throwable {
-    logger.debug(">>> multipleSequentialPostRequestsOverHttps");
-    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        server.enqueueEcho();
-
-        String body = "hello there";
-        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-        assertEquals(response.getResponseBody(), body);
-
-        response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-        assertEquals(response.getResponseBody(), body);
-      }));
-    logger.debug("<<< multipleSequentialPostRequestsOverHttps");
-  }
-
-  @Test
-  public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
-    logger.debug(">>> multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
-
-    KeepAliveStrategy keepAliveStrategy = (ahcRequest, nettyRequest, nettyResponse) -> !ahcRequest.getUri().isSecured();
-
-    withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        server.enqueueEcho();
-        server.enqueueEcho();
-
-        String body = "hello there";
-
-        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
-        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
-
-        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get();
-        assertEquals(response.getResponseBody(), body);
-      }));
-
-    logger.debug("<<< multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
-  }
-
-  @Test
-  public void reconnectAfterFailedCertificationPath() throws Throwable {
-    logger.debug(">>> reconnectAfterFailedCertificationPath");
-
-    AtomicBoolean trust = new AtomicBoolean();
-
-    withClient(config().setMaxRequestRetry(0).setSslEngineFactory(createSslEngineFactory(trust))).run(client ->
-      withServer(server).run(server -> {
-        server.enqueueEcho();
-        server.enqueueEcho();
-
-        String body = "hello there";
-
-        // first request fails because server certificate is rejected
-        Throwable cause = null;
-        try {
-          client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-        } catch (final ExecutionException e) {
-          cause = e.getCause();
-        }
-        assertNotNull(cause);
-
-        // second request should succeed
-        trust.set(true);
-        Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-      }));
-    logger.debug("<<< reconnectAfterFailedCertificationPath");
-  }
-
-  @Test(timeOut = 2000, expectedExceptions = SSLHandshakeException.class)
-  public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
-    logger.debug(">>> failInstantlyIfNotAllowedSelfSignedCertificate");
-
-    withClient(config().setMaxRequestRetry(0).setRequestTimeout(2000)).run(client ->
-      withServer(server).run(server -> {
-        try {
-          client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, SECONDS);
-        } catch (ExecutionException e) {
-          throw e.getCause().getCause();
-        }
-      }));
-    logger.debug("<<< failInstantlyIfNotAllowedSelfSignedCertificate");
-
-  }
-
-  @Test
-  public void testNormalEventsFired() throws Throwable {
-    logger.debug(">>> testNormalEventsFired");
-
-    withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client ->
-      withServer(server).run(server -> {
-        EventCollectingHandler handler = new EventCollectingHandler();
-
-        server.enqueueEcho();
-        client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, SECONDS);
-        handler.waitForCompletion(3, SECONDS);
-
-        Object[] expectedEvents = new Object[]{
-                CONNECTION_POOL_EVENT,
-                HOSTNAME_RESOLUTION_EVENT,
-                HOSTNAME_RESOLUTION_SUCCESS_EVENT,
-                CONNECTION_OPEN_EVENT,
-                CONNECTION_SUCCESS_EVENT,
-                TLS_HANDSHAKE_EVENT,
-                TLS_HANDSHAKE_SUCCESS_EVENT,
-                REQUEST_SEND_EVENT,
-                HEADERS_WRITTEN_EVENT,
-                STATUS_RECEIVED_EVENT,
-                HEADERS_RECEIVED_EVENT,
-                CONNECTION_OFFER_EVENT,
-                COMPLETED_EVENT};
-
-        assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-      }));
-    logger.debug("<<< testNormalEventsFired");
-  }
+    private static HttpServer server;
+
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
+    }
+
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
+    }
+
+    private static String getTargetUrl() {
+        return server.getHttpsUrl() + "/foo/bar";
+    }
+
+    @Test
+    public void postFileOverHttps() throws Throwable {
+        logger.debug(">>> postBodyOverHttps");
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+
+                Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader(CONTENT_TYPE, "text/html").execute().get();
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+            });
+        });
+        logger.debug("<<< postBodyOverHttps");
+    }
+    
+    @Test
+    public void postLargeFileOverHttps() throws Throwable {
+        logger.debug(">>> postLargeFileOverHttps");
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+
+                Response resp = client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_FILE).setHeader(CONTENT_TYPE, "image/png").execute().get();
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getResponseBodyAsBytes().length, LARGE_IMAGE_FILE.length());
+            });
+        });
+        logger.debug("<<< postLargeFileOverHttps");
+    }
+
+    @Test
+    public void multipleSequentialPostRequestsOverHttps() throws Throwable {
+        logger.debug(">>> multipleSequentialPostRequestsOverHttps");
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
+
+                String body = "hello there";
+                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                assertEquals(response.getResponseBody(), body);
+
+                response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                assertEquals(response.getResponseBody(), body);
+            });
+        });
+        logger.debug("<<< multipleSequentialPostRequestsOverHttps");
+    }
+
+    @Test
+    public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
+        logger.debug(">>> multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
+
+        KeepAliveStrategy keepAliveStrategy = new KeepAliveStrategy() {
+            @Override
+            public boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse) {
+                return !ahcRequest.getUri().isSecured();
+            }
+        };
+
+        withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
+                server.enqueueEcho();
+
+                String body = "hello there";
+
+                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
+                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
+
+                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get();
+                assertEquals(response.getResponseBody(), body);
+            });
+        });
+
+        logger.debug("<<< multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
+    }
+
+    @Test
+    public void reconnectAfterFailedCertificationPath() throws Throwable {
+        logger.debug(">>> reconnectAfterFailedCertificationPath");
+
+        AtomicBoolean trust = new AtomicBoolean();
+
+        withClient(config().setMaxRequestRetry(0).setSslEngineFactory(createSslEngineFactory(trust))).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
+
+                String body = "hello there";
+
+                // first request fails because server certificate is rejected
+                    Throwable cause = null;
+                    try {
+                        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                    } catch (final ExecutionException e) {
+                        cause = e.getCause();
+                    }
+                    assertNotNull(cause);
+
+                    // second request should succeed
+                    trust.set(true);
+                    Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+
+                    assertEquals(response.getResponseBody(), body);
+                });
+        });
+        logger.debug("<<< reconnectAfterFailedCertificationPath");
+    }
+
+    @Test(timeOut = 2000, expectedExceptions = SSLHandshakeException.class)
+    public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
+        logger.debug(">>> failInstantlyIfNotAllowedSelfSignedCertificate");
+
+        withClient(config().setMaxRequestRetry(0).setRequestTimeout(2000)).run(client -> {
+            withServer(server).run(server -> {
+                try {
+                    client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause().getCause();
+                }
+            });
+        });
+        logger.debug("<<< failInstantlyIfNotAllowedSelfSignedCertificate");
+
+    }
+
+    @Test(groups = "standalone")
+    public void testNormalEventsFired() throws Throwable {
+        logger.debug(">>> testNormalEventsFired");
+
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                EventCollectingHandler handler = new EventCollectingHandler();
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, SECONDS);
+                handler.waitForCompletion(3, SECONDS);
+
+                Object[] expectedEvents = new Object[] { //
+                CONNECTION_POOL_EVENT,//
+                        HOSTNAME_RESOLUTION_EVENT,//
+                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
+                        CONNECTION_OPEN_EVENT,//
+                        CONNECTION_SUCCESS_EVENT,//
+                        TLS_HANDSHAKE_EVENT,//
+                        TLS_HANDSHAKE_SUCCESS_EVENT,//
+                        REQUEST_SEND_EVENT,//
+                        HEADERS_WRITTEN_EVENT,//
+                        STATUS_RECEIVED_EVENT,//
+                        HEADERS_RECEIVED_EVENT,//
+                        CONNECTION_OFFER_EVENT,//
+                        COMPLETED_EVENT };
+
+                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+            });
+        });
+        logger.debug("<<< testNormalEventsFired");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 4a60e6521..487faa8de 100644
--- a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
+++ b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -12,13 +12,10 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -26,72 +23,75 @@
 import java.util.Enumeration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class ByteBufferCapacityTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new BasicHandler();
-  }
-
-  @Test
-  public void basicByteBufferTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      File largeFile = createTempFile(1024 * 100 * 10);
-      final AtomicInteger byteReceived = new AtomicInteger();
-
-      Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
-        @Override
-        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-          byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
-          return super.onBodyPartReceived(content);
-        }
+    private class BasicHandler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-      }).get();
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            String param;
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+            }
 
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(byteReceived.get(), largeFile.length());
-      assertEquals(response.getResponseBody().length(), largeFile.length());
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                final InputStream in = httpRequest.getInputStream();
+                final OutputStream out = httpResponse.getOutputStream();
+                int read;
+                while ((read = in.read(bytes)) != -1) {
+                    out.write(bytes, 0, read);
+                }
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  public String getTargetUrl() {
-    return String.format("http://localhost:%d/foo/test", port1);
-  }
-
-  private class BasicHandler extends AbstractHandler {
-
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      String param;
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
-        httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-      }
-
-      int size = 10 * 1024;
-      if (httpRequest.getContentLength() > 0) {
-        size = httpRequest.getContentLength();
-      }
-      byte[] bytes = new byte[size];
-      if (bytes.length > 0) {
-        final InputStream in = httpRequest.getInputStream();
-        final OutputStream out = httpResponse.getOutputStream();
-        int read;
-        while ((read = in.read(bytes)) != -1) {
-          out.write(bytes, 0, read);
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new BasicHandler();
+    }
+
+    @Test(groups = "standalone")
+    public void basicByteBufferTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            File largeFile = createTempFile(1024 * 100 * 10);
+            final AtomicInteger byteReceived = new AtomicInteger();
+
+            Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                    byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
+                    return super.onBodyPartReceived(content);
+                }
+
+            }).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(byteReceived.get(), largeFile.length());
+            assertEquals(response.getResponseBody().length(), largeFile.length());
         }
-      }
+    }
 
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    public String getTargetUrl() {
+        return String.format("http://localhost:%d/foo/test", port1);
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ClientStatsTest.java b/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
index 64dfff737..10c04d10d 100644
--- a/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
+++ b/client/src/test/java/org/asynchttpclient/ClientStatsTest.java
@@ -13,173 +13,173 @@
  */
 package org.asynchttpclient;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.Dsl.config;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
+import org.testng.annotations.Test;
 
 /**
  * Created by grenville on 9/25/16.
  */
 public class ClientStatsTest extends AbstractBasicTest {
 
-  private final static String hostname = "localhost";
+    private final static String hostname = "localhost";
 
-  @Test
-  public void testClientStatus() throws Throwable {
-    try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setPooledConnectionIdleTimeout(5000))) {
-      final String url = getTargetUrl();
+    @Test(groups = "standalone")
+    public void testClientStatus() throws Throwable {
+        try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setPooledConnectionIdleTimeout(5000))) {
+            final String url = getTargetUrl();
 
-      final ClientStats emptyStats = client.getClientStats();
+            final ClientStats emptyStats = client.getClientStats();
 
-      assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-      assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(emptyStats.getTotalConnectionCount(), 0);
-      assertNull(emptyStats.getStatsPerHost().get(hostname));
+            assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+            assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(emptyStats.getTotalConnectionCount(), 0);
+            assertNull(emptyStats.getStatsPerHost().get(hostname));
 
-      final List<ListenableFuture<Response>> futures =
-              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
-                      .limit(5)
-                      .collect(Collectors.toList());
+            final List<ListenableFuture<Response>> futures =
+                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
+                            .limit(5)
+                            .collect(Collectors.toList());
 
-      Thread.sleep(2000);
+            Thread.sleep(2000);
 
-      final ClientStats activeStats = client.getClientStats();
+            final ClientStats activeStats = client.getClientStats();
 
-      assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
-      assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
-      assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(activeStats.getTotalConnectionCount(), 5);
-      assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+            assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
+            assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
+            assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(activeStats.getTotalConnectionCount(), 5);
+            assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-      futures.forEach(future -> future.toCompletableFuture().join());
+            futures.forEach(future -> future.toCompletableFuture().join());
 
-      Thread.sleep(1000);
+            Thread.sleep(1000);
 
-      final ClientStats idleStats = client.getClientStats();
+            final ClientStats idleStats = client.getClientStats();
 
-      assertEquals(idleStats.toString(), "There are 5 total connections, 0 are active and 5 are idle.");
-      assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(idleStats.getTotalIdleConnectionCount(), 5);
-      assertEquals(idleStats.getTotalConnectionCount(), 5);
-      assertEquals(idleStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+            assertEquals(idleStats.toString(), "There are 5 total connections, 0 are active and 5 are idle.");
+            assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(idleStats.getTotalIdleConnectionCount(), 5);
+            assertEquals(idleStats.getTotalConnectionCount(), 5);
+            assertEquals(idleStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-      // Let's make sure the active count is correct when reusing cached connections.
+            // Let's make sure the active count is correct when reusing cached connections.
 
-      final List<ListenableFuture<Response>> repeatedFutures =
-              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
-                      .limit(3)
-                      .collect(Collectors.toList());
+            final List<ListenableFuture<Response>> repeatedFutures =
+                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
+                            .limit(3)
+                            .collect(Collectors.toList());
 
-      Thread.sleep(2000);
+            Thread.sleep(2000);
 
-      final ClientStats activeCachedStats = client.getClientStats();
+            final ClientStats activeCachedStats = client.getClientStats();
 
-      assertEquals(activeCachedStats.toString(), "There are 5 total connections, 3 are active and 2 are idle.");
-      assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
-      assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 2);
-      assertEquals(activeCachedStats.getTotalConnectionCount(), 5);
-      assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+            assertEquals(activeCachedStats.toString(), "There are 5 total connections, 3 are active and 2 are idle.");
+            assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
+            assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 2);
+            assertEquals(activeCachedStats.getTotalConnectionCount(), 5);
+            assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-      repeatedFutures.forEach(future -> future.toCompletableFuture().join());
+            repeatedFutures.forEach(future -> future.toCompletableFuture().join());
 
-      Thread.sleep(1000);
+            Thread.sleep(1000);
 
-      final ClientStats idleCachedStats = client.getClientStats();
+            final ClientStats idleCachedStats = client.getClientStats();
 
-      assertEquals(idleCachedStats.toString(), "There are 3 total connections, 0 are active and 3 are idle.");
-      assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 3);
-      assertEquals(idleCachedStats.getTotalConnectionCount(), 3);
-      assertEquals(idleCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
+            assertEquals(idleCachedStats.toString(), "There are 3 total connections, 0 are active and 3 are idle.");
+            assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 3);
+            assertEquals(idleCachedStats.getTotalConnectionCount(), 3);
+            assertEquals(idleCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
 
-      Thread.sleep(5000);
+            Thread.sleep(5000);
 
-      final ClientStats timeoutStats = client.getClientStats();
+            final ClientStats timeoutStats = client.getClientStats();
 
-      assertEquals(timeoutStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-      assertEquals(timeoutStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(timeoutStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(timeoutStats.getTotalConnectionCount(), 0);
-      assertNull(timeoutStats.getStatsPerHost().get(hostname));
+            assertEquals(timeoutStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+            assertEquals(timeoutStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(timeoutStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(timeoutStats.getTotalConnectionCount(), 0);
+            assertNull(timeoutStats.getStatsPerHost().get(hostname));
+        }
     }
-  }
 
-  @Test
-  public void testClientStatusNoKeepalive() throws Throwable {
-    try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
-      final String url = getTargetUrl();
+    @Test(groups = "standalone")
+    public void testClientStatusNoKeepalive() throws Throwable {
+        try (final AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
+            final String url = getTargetUrl();
 
-      final ClientStats emptyStats = client.getClientStats();
+            final ClientStats emptyStats = client.getClientStats();
 
-      assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-      assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(emptyStats.getTotalConnectionCount(), 0);
-      assertNull(emptyStats.getStatsPerHost().get(hostname));
+            assertEquals(emptyStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+            assertEquals(emptyStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(emptyStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(emptyStats.getTotalConnectionCount(), 0);
+            assertNull(emptyStats.getStatsPerHost().get(hostname));
 
-      final List<ListenableFuture<Response>> futures =
-              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
-                      .limit(5)
-                      .collect(Collectors.toList());
+            final List<ListenableFuture<Response>> futures =
+                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
+                            .limit(5)
+                            .collect(Collectors.toList());
 
-      Thread.sleep(2000);
+            Thread.sleep(2000);
 
-      final ClientStats activeStats = client.getClientStats();
+            final ClientStats activeStats = client.getClientStats();
 
-      assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
-      assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
-      assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(activeStats.getTotalConnectionCount(), 5);
-      assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
+            assertEquals(activeStats.toString(), "There are 5 total connections, 5 are active and 0 are idle.");
+            assertEquals(activeStats.getTotalActiveConnectionCount(), 5);
+            assertEquals(activeStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(activeStats.getTotalConnectionCount(), 5);
+            assertEquals(activeStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 5);
 
-      futures.forEach(future -> future.toCompletableFuture().join());
+            futures.forEach(future -> future.toCompletableFuture().join());
 
-      Thread.sleep(1000);
+            Thread.sleep(1000);
 
-      final ClientStats idleStats = client.getClientStats();
+            final ClientStats idleStats = client.getClientStats();
 
-      assertEquals(idleStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-      assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(idleStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(idleStats.getTotalConnectionCount(), 0);
-      assertNull(idleStats.getStatsPerHost().get(hostname));
+            assertEquals(idleStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+            assertEquals(idleStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(idleStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(idleStats.getTotalConnectionCount(), 0);
+            assertNull(idleStats.getStatsPerHost().get(hostname));
 
-      // Let's make sure the active count is correct when reusing cached connections.
+            // Let's make sure the active count is correct when reusing cached connections.
 
-      final List<ListenableFuture<Response>> repeatedFutures =
-              Stream.generate(() -> client.prepareGet(url).setHeader("LockThread", "6").execute())
-                      .limit(3)
-                      .collect(Collectors.toList());
+            final List<ListenableFuture<Response>> repeatedFutures =
+                    Stream.generate(() -> client.prepareGet(url).setHeader("LockThread","6").execute())
+                            .limit(3)
+                            .collect(Collectors.toList());
 
-      Thread.sleep(2000);
+            Thread.sleep(2000);
 
-      final ClientStats activeCachedStats = client.getClientStats();
+            final ClientStats activeCachedStats = client.getClientStats();
 
-      assertEquals(activeCachedStats.toString(), "There are 3 total connections, 3 are active and 0 are idle.");
-      assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
-      assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(activeCachedStats.getTotalConnectionCount(), 3);
-      assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
+            assertEquals(activeCachedStats.toString(), "There are 3 total connections, 3 are active and 0 are idle.");
+            assertEquals(activeCachedStats.getTotalActiveConnectionCount(), 3);
+            assertEquals(activeCachedStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(activeCachedStats.getTotalConnectionCount(), 3);
+            assertEquals(activeCachedStats.getStatsPerHost().get(hostname).getHostConnectionCount(), 3);
 
-      repeatedFutures.forEach(future -> future.toCompletableFuture().join());
+            repeatedFutures.forEach(future -> future.toCompletableFuture().join());
 
-      Thread.sleep(1000);
+            Thread.sleep(1000);
 
-      final ClientStats idleCachedStats = client.getClientStats();
+            final ClientStats idleCachedStats = client.getClientStats();
 
-      assertEquals(idleCachedStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
-      assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
-      assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 0);
-      assertEquals(idleCachedStats.getTotalConnectionCount(), 0);
-      assertNull(idleCachedStats.getStatsPerHost().get(hostname));
+            assertEquals(idleCachedStats.toString(), "There are 0 total connections, 0 are active and 0 are idle.");
+            assertEquals(idleCachedStats.getTotalActiveConnectionCount(), 0);
+            assertEquals(idleCachedStats.getTotalIdleConnectionCount(), 0);
+            assertEquals(idleCachedStats.getTotalConnectionCount(), 0);
+            assertNull(idleCachedStats.getStatsPerHost().get(hostname));
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
index 1189ef1fd..eb054629e 100644
--- a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
+++ b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -15,38 +15,38 @@
  */
 package org.asynchttpclient;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
 
 import java.util.concurrent.TimeUnit;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
+import org.testng.annotations.Test;
 
 public class ComplexClientTest extends AbstractBasicTest {
 
-  @Test
-  public void multipleRequestsTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      String body = "hello there";
+    @Test(groups = "standalone")
+    public void multipleRequestsTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String body = "hello there";
 
-      // once
-      Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-      assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
 
-      // twice
-      response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // twice
+            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-      assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
+        }
     }
-  }
-
-  @Test
-  public void urlWithoutSlashTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      String body = "hello there";
-      Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(response.getResponseBody(), body);
+
+    @Test(groups = "standalone")
+    public void urlWithoutSlashTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String body = "hello there";
+            Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/CookieStoreTest.java b/client/src/test/java/org/asynchttpclient/CookieStoreTest.java
deleted file mode 100644
index e16a477c2..000000000
--- a/client/src/test/java/org/asynchttpclient/CookieStoreTest.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient;
-
-import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
-import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
-import io.netty.handler.codec.http.cookie.Cookie;
-import org.asynchttpclient.cookie.CookieStore;
-import org.asynchttpclient.cookie.ThreadSafeCookieStore;
-import org.asynchttpclient.uri.Uri;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-import java.util.List;
-
-import static org.testng.Assert.assertTrue;
-
-public class CookieStoreTest {
-
-  private final Logger logger = LoggerFactory.getLogger(getClass());
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() {
-    logger.info("Local HTTP server started successfully");
-    System.out.println("--Start");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() {
-    System.out.println("--Stop");
-  }
-
-  @Test
-  public void runAllSequentiallyBecauseNotThreadSafe() {
-    addCookieWithEmptyPath();
-    dontReturnCookieForAnotherDomain();
-    returnCookieWhenItWasSetOnSamePath();
-    returnCookieWhenItWasSetOnParentPath();
-    dontReturnCookieWhenDomainMatchesButPathIsDifferent();
-    dontReturnCookieWhenDomainMatchesButPathIsParent();
-    returnCookieWhenDomainMatchesAndPathIsChild();
-    returnCookieWhenItWasSetOnSubdomain();
-    replaceCookieWhenSetOnSameDomainAndPath();
-    dontReplaceCookiesWhenTheyHaveDifferentName();
-    expireCookieWhenSetWithDateInThePast();
-    cookieWithSameNameMustCoexistIfSetOnDifferentDomains();
-    handleMissingDomainAsRequestHost();
-    handleMissingPathAsSlash();
-    returnTheCookieWheniTSissuedFromRequestWithSubpath();
-    handleMissingPathAsRequestPathWhenFromRootDir();
-    handleMissingPathAsRequestPathWhenPathIsNotEmpty();
-    handleDomainInCaseInsensitiveManner();
-    handleCookieNameInCaseInsensitiveManner();
-    handleCookiePathInCaseSensitiveManner();
-    ignoreQueryParametersInUri();
-    shouldServerOnSubdomainWhenDomainMatches();
-    replaceCookieWhenSetOnSamePathBySameUri();
-    handleMultipleCookieOfSameNameOnDifferentPaths();
-    handleTrailingSlashesInPaths();
-    returnMultipleCookiesEvenIfTheyHaveSameName();
-    shouldServeCookiesBasedOnTheUriScheme();
-    shouldAlsoServeNonSecureCookiesBasedOnTheUriScheme();
-    shouldNotServeSecureCookiesForDefaultRetrievedHttpUriScheme();
-    shouldServeSecureCookiesForSpecificallyRetrievedHttpUriScheme();
-  }
-
-  private void addCookieWithEmptyPath() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path="));
-    assertTrue(store.get(uri).size() > 0);
-  }
-
-  private void dontReturnCookieForAnotherDomain() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path="));
-    assertTrue(store.get(Uri.create("http://www.bar.com")).isEmpty());
-  }
-
-  private void returnCookieWhenItWasSetOnSamePath() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; path=/bar/"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/bar/")).size() == 1);
-  }
-
-  private void returnCookieWhenItWasSetOnParentPath() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/bar/baz")).size() == 1);
-  }
-
-  private void dontReturnCookieWhenDomainMatchesButPathIsDifferent() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/baz")).isEmpty());
-  }
-
-  private void dontReturnCookieWhenDomainMatchesButPathIsParent() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(Uri.create("http://www.foo.com")).isEmpty());
-  }
-
-  private void returnCookieWhenDomainMatchesAndPathIsChild() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/bar/baz")).size() == 1);
-  }
-
-  private void returnCookieWhenItWasSetOnSubdomain() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=.foo.com"));
-    assertTrue(store.get(Uri.create("http://bar.foo.com")).size() == 1);
-  }
-
-  private void replaceCookieWhenSetOnSameDomainAndPath() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com/bar/baz");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE2"));
-  }
-
-  private void dontReplaceCookiesWhenTheyHaveDifferentName() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com/bar/baz");
-    store.add(uri, ClientCookieDecoder.LAX.decode("BETA=VALUE1; Domain=www.foo.com; path=/bar"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(uri).size() == 2);
-  }
-
-  private void expireCookieWhenSetWithDateInThePast() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com/bar");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=EXPIRED; Domain=www.foo.com; Path=/bar; Expires=Sun, 06 Nov 1994 08:49:37 GMT"));
-    assertTrue(store.getAll().isEmpty());
-  }
-
-  private void cookieWithSameNameMustCoexistIfSetOnDifferentDomains() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri1 = Uri.create("http://www.foo.com");
-    store.add(uri1, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com"));
-    Uri uri2 = Uri.create("http://www.bar.com");
-    store.add(uri2, ClientCookieDecoder.LAX.decode("ALPHA=VALUE2; Domain=www.bar.com"));
-
-    assertTrue(store.get(uri1).size() == 1);
-    assertTrue(store.get(uri1).get(0).value().equals("VALUE1"));
-
-    assertTrue(store.get(uri2).size() == 1);
-    assertTrue(store.get(uri2).get(0).value().equals("VALUE2"));
-  }
-
-  private void handleMissingDomainAsRequestHost() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Path=/"));
-    assertTrue(store.get(uri).size() == 1);
-  }
-
-  private void handleMissingPathAsSlash() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com");
-    store.add(uri, ClientCookieDecoder.LAX.decode("tooe_token=0b1d81dd02d207491a6e9b0a2af9470da9eb1dad"));
-    assertTrue(store.get(uri).size() == 1);
-  }
-
-  private void returnTheCookieWheniTSissuedFromRequestWithSubpath() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE; path=/"));
-    assertTrue(store.get(Uri.create("http://www.foo.com")).size() == 1);
-  }
-
-  private void handleMissingPathAsRequestPathWhenFromRootDir() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
-    assertTrue(store.get(uri).size() == 1);
-  }
-
-  private void handleMissingPathAsRequestPathWhenPathIsNotEmpty() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/baz")).isEmpty());
-  }
-
-  // RFC 2965 sec. 3.3.3
-  private void handleDomainInCaseInsensitiveManner() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
-    assertTrue(store.get(Uri.create("http://www.FoO.com/bar")).size() == 1);
-  }
-
-  // RFC 2965 sec. 3.3.3
-  private void handleCookieNameInCaseInsensitiveManner() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("http://www.foo.com/bar/baz");
-    store.add(uri, ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/bar"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("alpha=VALUE2; Domain=www.foo.com; path=/bar"));
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE2"));
-  }
-
-  // RFC 2965 sec. 3.3.3
-  private void handleCookiePathInCaseSensitiveManner() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/foo/bar"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1"));
-    assertTrue(store.get(Uri.create("http://www.FoO.com/Foo/bAr")).isEmpty());
-  }
-
-  private void ignoreQueryParametersInUri() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com/bar?query1"), ClientCookieDecoder.LAX.decode("ALPHA=VALUE1; Domain=www.foo.com; path=/"));
-    assertTrue(store.get(Uri.create("http://www.foo.com/bar?query2")).size() == 1);
-  }
-
-  // RFC 6265, 5.1.3.  Domain Matching
-  private void shouldServerOnSubdomainWhenDomainMatches() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("https://x.foo.org/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/; Domain=foo.org;"));
-    assertTrue(store.get(Uri.create("https://y.x.foo.org/")).size() == 1);
-  }
-
-  // NOTE: Similar to replaceCookieWhenSetOnSameDomainAndPath()
-  private void replaceCookieWhenSetOnSamePathBySameUri() {
-    CookieStore store = new ThreadSafeCookieStore();
-    Uri uri = Uri.create("https://foo.org/");
-    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
-    store.add(uri, ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/"));
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
-  }
-
-  private void handleMultipleCookieOfSameNameOnDifferentPaths() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://www.foo.com"), ClientCookieDecoder.LAX.decode("cookie=VALUE0; path=/"));
-    store.add(Uri.create("http://www.foo.com/foo/bar"), ClientCookieDecoder.LAX.decode("cookie=VALUE1; path=/foo/bar/"));
-    store.add(Uri.create("http://www.foo.com/foo/baz"), ClientCookieDecoder.LAX.decode("cookie=VALUE2; path=/foo/baz/"));
-
-    Uri uri1 = Uri.create("http://www.foo.com/foo/bar/");
-    List<Cookie> cookies1 = store.get(uri1);
-    assertTrue(cookies1.size() == 2);
-    assertTrue(cookies1.stream().filter(c -> c.value().equals("VALUE0") || c.value().equals("VALUE1")).count() == 2);
-
-    Uri uri2 = Uri.create("http://www.foo.com/foo/baz/");
-    List<Cookie> cookies2 = store.get(uri2);
-    assertTrue(cookies2.size() == 2);
-    assertTrue(cookies2.stream().filter(c -> c.value().equals("VALUE0") || c.value().equals("VALUE2")).count() == 2);
-  }
-
-  private void handleTrailingSlashesInPaths() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(
-            Uri.create("https://vagrant.moolb.com/app/consumer/j_spring_cas_security_check?ticket=ST-5-Q7gzqPpvG3N3Bb02bm3q-llinder-vagrantmgr.moolb.com"),
-            ClientCookieDecoder.LAX.decode("JSESSIONID=211D17F016132BCBD31D9ABB31D90960; Path=/app/consumer/; HttpOnly"));
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(Uri.create("https://vagrant.moolb.com/app/consumer/")).get(0).value().equals("211D17F016132BCBD31D9ABB31D90960"));
-  }
-
-  private void returnMultipleCookiesEvenIfTheyHaveSameName() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("http://foo.com"), ClientCookieDecoder.LAX.decode("JSESSIONID=FOO; Domain=.foo.com"));
-    store.add(Uri.create("http://sub.foo.com"), ClientCookieDecoder.LAX.decode("JSESSIONID=BAR; Domain=sub.foo.com"));
-
-    Uri uri1 = Uri.create("http://sub.foo.com");
-    List<Cookie> cookies1 = store.get(uri1);
-    assertTrue(cookies1.size() == 2);
-    assertTrue(cookies1.stream().filter(c -> c.value().equals("FOO") || c.value().equals("BAR")).count() == 2);
-
-    String result = ClientCookieEncoder.LAX.encode(cookies1.get(0), cookies1.get(1));
-    assertTrue(result.equals("JSESSIONID=FOO; JSESSIONID=BAR"));
-  }
-
-  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
-  private void shouldServeCookiesBasedOnTheUriScheme() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
-
-    Uri uri = Uri.create("https://foo.org/moodle/login");
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
-    assertTrue(store.get(uri).get(0).isSecure());
-  }
-
-  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
-  private void shouldAlsoServeNonSecureCookiesBasedOnTheUriScheme() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; HttpOnly"));
-
-    Uri uri = Uri.create("https://foo.org/moodle/login");
-    assertTrue(store.getAll().size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
-    assertTrue(!store.get(uri).get(0).isSecure());
-  }
-
-  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
-  private void shouldNotServeSecureCookiesForDefaultRetrievedHttpUriScheme() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
-
-    Uri uri = Uri.create("http://foo.org/moodle/login");
-    assertTrue(store.get(uri).isEmpty());
-  }
-
-  // rfc6265#section-1 Cookies for a given host are shared  across all the ports on that host
-  private void shouldServeSecureCookiesForSpecificallyRetrievedHttpUriScheme() {
-    CookieStore store = new ThreadSafeCookieStore();
-    store.add(Uri.create("https://foo.org/moodle/"), ClientCookieDecoder.LAX.decode("cookie1=VALUE1; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE2; Path=/"));
-    store.add(Uri.create("https://foo.org:443/moodle/login"), ClientCookieDecoder.LAX.decode("cookie1=VALUE3; Path=/; Secure"));
-
-    Uri uri = Uri.create("https://foo.org/moodle/login");
-    assertTrue(store.get(uri).size() == 1);
-    assertTrue(store.get(uri).get(0).value().equals("VALUE3"));
-    assertTrue(store.get(uri).get(0).isSecure());
-  }
-}
diff --git a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
index 55e1d0d88..323b1a108 100644
--- a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -12,90 +12,89 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.digestAuthRealm;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public class DigestAuthTest extends AbstractBasicTest {
 
-  @BeforeClass(alwaysRun = true)
-  @Override
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    addDigestAuthHandler(server, configureHandler());
-    server.start();
-    port1 = connector.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        addDigestAuthHandler(server, configureHandler());
+        server.start();
+        port1 = connector.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+    }
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new SimpleHandler();
-  }
+    private static class SimpleHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            response.addHeader("X-Auth", request.getHeader("Authorization"));
+            response.setStatus(200);
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
+        }
+    }
 
-  @Test
-  public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
-              .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())
-              .execute();
-      Response resp = f.get(60, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertNotNull(resp.getHeader("X-Auth"));
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SimpleHandler();
     }
-  }
 
-  @Test
-  public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
-              .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())
-              .execute();
-      Response resp = f.get(60, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertNotNull(resp.getHeader("X-Auth"));
+    @Test(groups = "standalone")
+    public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
+                    .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
+                    .execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        }
     }
-  }
 
-  @Test
-  public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")
-              .setRealm(digestAuthRealm("fake", ADMIN).build())
-              .execute();
-      Response resp = f.get(20, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), 401);
+    @Test(groups = "standalone")
+    public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
+                    .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
+                    .execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        }
     }
-  }
 
-  private static class SimpleHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      response.addHeader("X-Auth", request.getHeader("Authorization"));
-      response.setStatus(200);
-      response.getOutputStream().flush();
-      response.getOutputStream().close();
+    @Test(groups = "standalone")
+    public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
+                    .setRealm(digestAuthRealm("fake", ADMIN).build())//
+                    .execute();
+            Response resp = f.get(20, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
index 739dfb7ef..9b5b224e2 100644
--- a/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
+++ b/client/src/test/java/org/asynchttpclient/EofTerminatedTest.java
@@ -13,47 +13,46 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.handler.gzip.GzipHandler;
-import org.testng.annotations.Test;
+
+import java.io.IOException;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT_ENCODING;
-import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.eclipse.jetty.server.handler.gzip.GzipHandler;
+import org.testng.annotations.Test;
 
 public class EofTerminatedTest extends AbstractBasicTest {
 
-  protected String getTargetUrl() {
-    return String.format("http://localhost:%d/", port1);
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    GzipHandler gzipHandler = new GzipHandler();
-    gzipHandler.setHandler(new StreamHandler());
-    return gzipHandler;
-  }
-
-  @Test
-  public void testEolTerminatedResponse() throws Exception {
-    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
-      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).setHeader(ACCEPT_ENCODING, HttpHeaderValues.GZIP_DEFLATE).setHeader(CONNECTION, HttpHeaderValues.CLOSE).build())
-              .get();
+    private static class StreamHandler extends AbstractHandler {
+        @Override
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+            request.getResponse().getHttpOutput().sendContent(EofTerminatedTest.class.getClassLoader().getResourceAsStream("SimpleTextFile.txt"));
+        }
+    }
+
+    protected String getTargetUrl() {
+        return String.format("http://localhost:%d/", port1);
     }
-  }
 
-  private static class StreamHandler extends AbstractHandler {
     @Override
-    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-      request.getResponse().getHttpOutput().sendContent(EofTerminatedTest.class.getClassLoader().getResourceAsStream("SimpleTextFile.txt"));
+    public AbstractHandler configureHandler() throws Exception {
+        GzipHandler gzipHandler = new GzipHandler();
+        gzipHandler.setHandler(new StreamHandler());
+        return gzipHandler;
+    }
+
+    @Test
+    public void testEolTerminatedResponse() throws Exception {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).setHeader(ACCEPT_ENCODING, HttpHeaderValues.GZIP_DEFLATE).setHeader(CONNECTION, HttpHeaderValues.CLOSE).build())
+                    .get();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index 9edf6e2d9..f69406696 100644
--- a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -16,59 +16,58 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Tests to reproduce issues with handling of error responses
- *
+ * 
  * @author Tatu Saloranta
  */
 public class ErrorResponseTest extends AbstractBasicTest {
-  final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
+    final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new ErrorHandler();
-  }
+    private static class ErrorHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            try {
+                Thread.sleep(210L);
+            } catch (InterruptedException e) {
+            }
+            response.setContentType("text/plain");
+            response.setStatus(400);
+            OutputStream out = response.getOutputStream();
+            out.write(BAD_REQUEST_STR.getBytes(UTF_8));
+            out.flush();
+        }
+    }
 
-  @Test(groups = "standalone")
-  public void testQueryParameters() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), 400);
-      assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ErrorHandler();
     }
-  }
 
-  private static class ErrorHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      try {
-        Thread.sleep(210L);
-      } catch (InterruptedException e) {
-        //
-      }
-      response.setContentType("text/plain");
-      response.setStatus(400);
-      OutputStream out = response.getOutputStream();
-      out.write(BAD_REQUEST_STR.getBytes(UTF_8));
-      out.flush();
+    @Test(groups = "standalone")
+    public void testQueryParameters() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 400);
+            assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index 0aad5721f..ed43033cc 100644
--- a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
+++ b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -15,63 +15,62 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaderValues;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.util.concurrent.Future;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.Future;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Test the Expect: 100-Continue.
  */
 public class Expect100ContinueTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new ZeroCopyHandler();
-  }
+    private static class ZeroCopyHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-  @Test
-  public void Expect100Continue() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")
-              .setHeader(EXPECT, HttpHeaderValues.CONTINUE)
-              .setBody(SIMPLE_TEXT_FILE)
-              .execute();
-      Response resp = f.get();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-    }
-  }
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                final int read = httpRequest.getInputStream().read(bytes);
+                httpResponse.getOutputStream().write(bytes, 0, read);
+            }
 
-  private static class ZeroCopyHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+        }
+    }
 
-      int size = 10 * 1024;
-      if (httpRequest.getContentLength() > 0) {
-        size = httpRequest.getContentLength();
-      }
-      byte[] bytes = new byte[size];
-      if (bytes.length > 0) {
-        final int read = httpRequest.getInputStream().read(bytes);
-        httpResponse.getOutputStream().write(bytes, 0, read);
-      }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ZeroCopyHandler();
+    }
 
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
+    @Test(groups = "standalone")
+    public void Expect100Continue() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")//
+                    .setHeader(EXPECT, HttpHeaderValues.CONTINUE)//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
index e7eeec8e3..f36abf6ce 100644
--- a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
+++ b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
@@ -15,74 +15,78 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.testng.annotations.Test;
 
-import java.util.concurrent.*;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
+import org.testng.annotations.Test;
 
 /**
  * Simple stress test for exercising the follow redirect.
  */
 public class FollowingThreadTest extends AbstractBasicTest {
 
-  private static final int COUNT = 10;
+    private static final int COUNT = 10;
 
-  @Test(groups = "online", timeOut = 30 * 1000)
-  public void testFollowRedirect() throws InterruptedException {
+    @Test(groups = "online", timeOut = 30 * 1000)
+    public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-    final CountDownLatch countDown = new CountDownLatch(COUNT);
-    ExecutorService pool = Executors.newCachedThreadPool();
-    try {
-      for (int i = 0; i < COUNT; i++) {
-        pool.submit(new Runnable() {
+        final CountDownLatch countDown = new CountDownLatch(COUNT);
+        ExecutorService pool = Executors.newCachedThreadPool();
+        try {
+            for (int i = 0; i < COUNT; i++) {
+                pool.submit(new Runnable() {
 
-          private int status;
+                    private int status;
 
-          public void run() {
-            final CountDownLatch l = new CountDownLatch(1);
-            try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true))) {
-              ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
+                    public void run() {
+                        final CountDownLatch l = new CountDownLatch(1);
+                        try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true))) {
+                            ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
 
-                public void onThrowable(Throwable t) {
-                  t.printStackTrace();
-                }
+                                public void onThrowable(Throwable t) {
+                                    t.printStackTrace();
+                                }
 
-                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
-                  System.out.println(new String(bodyPart.getBodyPartBytes()));
-                  return State.CONTINUE;
-                }
+                                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                                    System.out.println(new String(bodyPart.getBodyPartBytes()));
+                                    return State.CONTINUE;
+                                }
 
-                public State onStatusReceived(HttpResponseStatus responseStatus) {
-                  status = responseStatus.getStatusCode();
-                  System.out.println(responseStatus.getStatusText());
-                  return State.CONTINUE;
-                }
+                                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                                    status = responseStatus.getStatusCode();
+                                    System.out.println(responseStatus.getStatusText());
+                                    return State.CONTINUE;
+                                }
 
-                public State onHeadersReceived(HttpHeaders headers) {
-                  return State.CONTINUE;
-                }
+                                public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                                    return State.CONTINUE;
+                                }
 
-                public Integer onCompleted() {
-                  l.countDown();
-                  return status;
-                }
-              });
+                                public Integer onCompleted() throws Exception {
+                                    l.countDown();
+                                    return status;
+                                }
+                            });
 
-              l.await();
-            } catch (Exception e) {
-              e.printStackTrace();
-            } finally {
-              countDown.countDown();
+                            l.await();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        } finally {
+                            countDown.countDown();
+                        }
+                    }
+                });
             }
-          }
-        });
-      }
-      countDown.await();
-    } finally {
-      pool.shutdown();
+            countDown.await();
+        } finally {
+            pool.shutdown();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Head302Test.java b/client/src/test/java/org/asynchttpclient/Head302Test.java
index 2072f3dbb..2512b9cb1 100644
--- a/client/src/test/java/org/asynchttpclient/Head302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Head302Test.java
@@ -15,70 +15,76 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.io.IOException;
+import java.util.concurrent.BrokenBarrierException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.*;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.head;
-import static org.testng.Assert.*;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Tests HEAD request that gets 302 response.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class Head302Test extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new Head302handler();
-  }
-
-  @Test
-  public void testHEAD302() throws IOException, InterruptedException, ExecutionException, TimeoutException {
-    AsyncHttpClientConfig clientConfig = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-    try (AsyncHttpClient client = asyncHttpClient(clientConfig)) {
-      final CountDownLatch l = new CountDownLatch(1);
-      Request request = head("http://localhost:" + port1 + "/Test").build();
+    /**
+     * Handler that does Found (302) in response to HEAD method.
+     */
+    private static class Head302handler extends AbstractHandler {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("HEAD".equalsIgnoreCase(request.getMethod())) {
+                response.setStatus(HttpServletResponse.SC_FOUND); // 302
+                response.setHeader("Location", request.getPathInfo() + "_moved");
+            } else if ("GET".equalsIgnoreCase(request.getMethod())) {
+                response.setStatus(HttpServletResponse.SC_OK);
+            } else {
+                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
+            }
 
-      Response response = client.executeRequest(request, new AsyncCompletionHandlerBase() {
-        @Override
-        public Response onCompleted(Response response) throws Exception {
-          l.countDown();
-          return super.onCompleted(response);
+            r.setHandled(true);
         }
-      }).get(3, TimeUnit.SECONDS);
+    }
 
-      if (l.await(TIMEOUT, TimeUnit.SECONDS)) {
-        assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-        assertTrue(response.getUri().getPath().endsWith("_moved"));
-      } else {
-        fail("Timeout out");
-      }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new Head302handler();
     }
-  }
 
-  /**
-   * Handler that does Found (302) in response to HEAD method.
-   */
-  private static class Head302handler extends AbstractHandler {
-    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("HEAD".equalsIgnoreCase(request.getMethod())) {
-        response.setStatus(HttpServletResponse.SC_FOUND); // 302
-        response.setHeader("Location", request.getPathInfo() + "_moved");
-      } else if ("GET".equalsIgnoreCase(request.getMethod())) {
-        response.setStatus(HttpServletResponse.SC_OK);
-      } else {
-        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
-      }
+    @Test(groups = "standalone")
+    public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
+        AsyncHttpClientConfig clientConfig = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+        try (AsyncHttpClient client = asyncHttpClient(clientConfig)) {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = head("http://localhost:" + port1 + "/Test").build();
+
+            Response response = client.executeRequest(request, new AsyncCompletionHandlerBase() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    l.countDown();
+                    return super.onCompleted(response);
+                }
+            }).get(3, TimeUnit.SECONDS);
 
-      r.setHandled(true);
+            if (l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+                assertTrue(response.getUri().getPath().endsWith("_moved"));
+            } else {
+                fail("Timeout out");
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
index cb6910e2b..39ab2c3e2 100644
--- a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
@@ -15,6 +15,18 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -22,128 +34,115 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.concurrent.atomic.AtomicBoolean;
+public class HttpToHttpsRedirectTest extends AbstractBasicTest {
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+    // FIXME super NOT threadsafe!!!
+    private final AtomicBoolean redirectDone = new AtomicBoolean(false);
 
-public class HttpToHttpsRedirectTest extends AbstractBasicTest {
+    private class Relative302Handler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-  // FIXME super NOT threadsafe!!!
-  private final AtomicBoolean redirectDone = new AtomicBoolean(false);
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    ServerConnector connector2 = addHttpsConnector(server);
-    server.setHandler(new Relative302Handler());
-    server.start();
-    port1 = connector1.getLocalPort();
-    port2 = connector2.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
-
-  @Test
-  // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
-  public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
-    httpToHttpsRedirect();
-    httpToHttpsProperConfig();
-    relativeLocationUrl();
-  }
-
-  @Test(enabled = false)
-  public void httpToHttpsRedirect() throws Exception {
-    redirectDone.getAndSet(false);
-
-    AsyncHttpClientConfig cg = config()
-            .setMaxRedirects(5)
-            .setFollowRedirect(true)
-            .setUseInsecureTrustManager(true)
-            .build();
-    try (AsyncHttpClient c = asyncHttpClient(cg)) {
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+            String param;
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+
+                if (param.startsWith("X-redirect") && !redirectDone.getAndSet(true)) {
+                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
+                    httpResponse.setStatus(302);
+                    httpResponse.getOutputStream().flush();
+                    httpResponse.getOutputStream().close();
+                    return;
+                }
+            }
+
+            if (r.getScheme().equalsIgnoreCase("https")) {
+                httpResponse.addHeader("X-httpToHttps", "PASS");
+                redirectDone.getAndSet(false);
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void httpToHttpsProperConfig() throws Exception {
-    redirectDone.getAndSet(false);
-
-    AsyncHttpClientConfig cg = config()
-            .setMaxRedirects(5)
-            .setFollowRedirect(true)
-            .setUseInsecureTrustManager(true)
-            .build();
-    try (AsyncHttpClient c = asyncHttpClient(cg)) {
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-
-      // Test if the internal channel is downgraded to clean http.
-      response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        ServerConnector connector2 = addHttpsConnector(server);
+        server.setHandler(new Relative302Handler());
+        server.start();
+        port1 = connector1.getLocalPort();
+        port2 = connector2.getLocalPort();
+        logger.info("Local HTTP server started successfully");
     }
-  }
-
-  @Test(enabled = false)
-  public void relativeLocationUrl() throws Exception {
-    redirectDone.getAndSet(false);
-
-    AsyncHttpClientConfig cg = config()
-            .setMaxRedirects(5)
-            .setFollowRedirect(true)
-            .setUseInsecureTrustManager(true)
-            .build();
-    try (AsyncHttpClient c = asyncHttpClient(cg)) {
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getUri().toString(), getTargetUrl());
+
+    @Test(groups = "standalone")
+    // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
+    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        httpToHttpsRedirect();
+        httpToHttpsProperConfig();
+        relativeLocationUrl();
     }
-  }
 
-  private class Relative302Handler extends AbstractHandler {
+    // @Test(groups = "standalone")
+    public void httpToHttpsRedirect() throws Exception {
+        redirectDone.getAndSet(false);
 
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+        AsyncHttpClientConfig cg = config()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setUseInsecureTrustManager(true)//
+                .build();
+        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+        }
+    }
 
-      String param;
-      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
+    // @Test(groups = "standalone")
+    public void httpToHttpsProperConfig() throws Exception {
+        redirectDone.getAndSet(false);
 
-        if (param.startsWith("X-redirect") && !redirectDone.getAndSet(true)) {
-          httpResponse.addHeader("Location", httpRequest.getHeader(param));
-          httpResponse.setStatus(302);
-          httpResponse.getOutputStream().flush();
-          httpResponse.getOutputStream().close();
-          return;
+        AsyncHttpClientConfig cg = config()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setUseInsecureTrustManager(true)//
+                .build();
+        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+
+            // Test if the internal channel is downgraded to clean http.
+            response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
         }
-      }
+    }
 
-      if (r.getScheme().equalsIgnoreCase("https")) {
-        httpResponse.addHeader("X-httpToHttps", "PASS");
+    // @Test(groups = "standalone")
+    public void relativeLocationUrl() throws Exception {
         redirectDone.getAndSet(false);
-      }
 
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+        AsyncHttpClientConfig cg = config()//
+                .setMaxRedirects(5)//
+                .setFollowRedirect(true)//
+                .setUseInsecureTrustManager(true)//
+                .build();
+        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), getTargetUrl());
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
index 0ee80f419..39d702728 100644
--- a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
@@ -15,6 +15,17 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.fail;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -22,50 +33,39 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.fail;
-
 public class IdleStateHandlerTest extends AbstractBasicTest {
 
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(new IdleStateHandler());
-    server.start();
-    port1 = connector.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
+    private class IdleStateHandler extends AbstractHandler {
 
-  @Test
-  public void idleStateTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setPooledConnectionIdleTimeout(10 * 1000))) {
-      c.prepareGet(getTargetUrl()).execute().get();
-    } catch (ExecutionException e) {
-      fail("Should allow to finish processing request.", e);
-    }
-  }
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-  private class IdleStateHandler extends AbstractHandler {
+            try {
+                Thread.sleep(20 * 1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
+    }
 
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(new IdleStateHandler());
+        server.start();
+        port1 = connector.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+    }
 
-      try {
-        Thread.sleep(20 * 1000);
-      } catch (InterruptedException e) {
-        e.printStackTrace();
-      }
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    @Test(groups = "standalone")
+    public void idleStateTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setPooledConnectionIdleTimeout(10 * 1000))) {
+            c.prepareGet(getTargetUrl()).execute().get();
+        } catch (ExecutionException e) {
+            fail("Should allow to finish processing request.", e);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 9138fc059..71e612d46 100644
--- a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -12,7 +12,8 @@
  */
 package org.asynchttpclient;
 
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -20,57 +21,56 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
+import org.testng.annotations.Test;
 
 public class ListenableFutureTest extends AbstractBasicTest {
 
-  @Test
-  public void testListenableFuture() throws Exception {
-    final AtomicInteger statusCode = new AtomicInteger(500);
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-      future.addListener(() -> {
-        try {
-          statusCode.set(future.get().getStatusCode());
-          latch.countDown();
-        } catch (InterruptedException | ExecutionException e) {
-          e.printStackTrace();
-        }
-      }, Executors.newFixedThreadPool(1));
+    @Test
+    public void testListenableFuture() throws Exception {
+        final AtomicInteger statusCode = new AtomicInteger(500);
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+            future.addListener(() -> {
+                try {
+                    statusCode.set(future.get().getStatusCode());
+                    latch.countDown();
+                } catch (InterruptedException | ExecutionException e) {
+                    e.printStackTrace();
+                }
+            }, Executors.newFixedThreadPool(1));
 
-      latch.await(10, TimeUnit.SECONDS);
-      assertEquals(statusCode.get(), 200);
+            latch.await(10, TimeUnit.SECONDS);
+            assertEquals(statusCode.get(), 200);
+        }
     }
-  }
 
-  @Test
-  public void testListenableFutureAfterCompletion() throws Exception {
+    @Test
+    public void testListenableFutureAfterCompletion() throws Exception {
+
+        final CountDownLatch latch = new CountDownLatch(1);
 
-    final CountDownLatch latch = new CountDownLatch(1);
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+            future.get();
+            future.addListener(() -> latch.countDown(), Runnable::run);
+        }
 
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-      future.get();
-      future.addListener(latch::countDown, Runnable::run);
+        latch.await(10, TimeUnit.SECONDS);
     }
 
-    latch.await(10, TimeUnit.SECONDS);
-  }
+    @Test
+    public void testListenableFutureBeforeAndAfterCompletion() throws Exception {
 
-  @Test
-  public void testListenableFutureBeforeAndAfterCompletion() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(2);
 
-    final CountDownLatch latch = new CountDownLatch(2);
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+            future.addListener(() -> latch.countDown(), Runnable::run);
+            future.get();
+            future.addListener(() -> latch.countDown(), Runnable::run);
+        }
 
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-      future.addListener(latch::countDown, Runnable::run);
-      future.get();
-      future.addListener(latch::countDown, Runnable::run);
+        latch.await(10, TimeUnit.SECONDS);
     }
-
-    latch.await(10, TimeUnit.SECONDS);
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
index 0bad2af9b..273309faf 100644
--- a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
+++ b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
@@ -12,170 +12,183 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
 
-import javax.net.ServerSocketFactory;
-import java.io.*;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.util.concurrent.*;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.get;
-import static org.testng.Assert.*;
+import javax.net.ServerSocketFactory;
+
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 /**
  * @author Hubert Iwaniuk
  */
 public class MultipleHeaderTest extends AbstractBasicTest {
-  private ExecutorService executorService;
-  private ServerSocket serverSocket;
-  private Future<?> voidFuture;
-
-  @BeforeClass
-  public void setUpGlobal() throws Exception {
-    serverSocket = ServerSocketFactory.getDefault().createServerSocket(0);
-    port1 = serverSocket.getLocalPort();
-    executorService = Executors.newFixedThreadPool(1);
-    voidFuture = executorService.submit(() -> {
-        Socket socket;
-        while ((socket = serverSocket.accept()) != null) {
-          InputStream inputStream = socket.getInputStream();
-          BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-          String req = reader.readLine().split(" ")[1];
-          int i = inputStream.available();
-          long l = inputStream.skip(i);
-          assertEquals(l, i);
-          socket.shutdownInput();
-          if (req.endsWith("MultiEnt")) {
-            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-            outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n"
-                    + "Content-Length: 1\n" + "\n0\n");
-            outputStreamWriter.flush();
-            socket.shutdownOutput();
-          } else if (req.endsWith("MultiOther")) {
-            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-            outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n"
-                    + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
-            outputStreamWriter.flush();
-            socket.shutdownOutput();
-          }
-        }
-        return null;
-      });
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    voidFuture.cancel(true);
-    executorService.shutdownNow();
-    serverSocket.close();
-  }
-
-  @Test
-  public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    final String[] xffHeaders = new String[]{null, null};
-
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      Request req = get("http://localhost:" + port1 + "/MultiOther").build();
-      final CountDownLatch latch = new CountDownLatch(1);
-      ahc.executeRequest(req, new AsyncHandler<Void>() {
-        public void onThrowable(Throwable t) {
-          t.printStackTrace(System.out);
-        }
-
-        public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) {
-          return State.CONTINUE;
-        }
-
-        public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) {
-          return State.CONTINUE;
-        }
-
-        public State onHeadersReceived(HttpHeaders response) {
-          int i = 0;
-          for (String header : response.getAll("X-Forwarded-For")) {
-            xffHeaders[i++] = header;
-          }
-          latch.countDown();
-          return State.CONTINUE;
-        }
-
-        public Void onCompleted() {
-          return null;
-        }
-      }).get(3, TimeUnit.SECONDS);
-
-      if (!latch.await(2, TimeUnit.SECONDS)) {
-        fail("Time out");
-      }
-      assertNotNull(xffHeaders[0]);
-      assertNotNull(xffHeaders[1]);
-      try {
-        assertEquals(xffHeaders[0], "abc");
-        assertEquals(xffHeaders[1], "def");
-      } catch (AssertionError ex) {
-        assertEquals(xffHeaders[1], "abc");
-        assertEquals(xffHeaders[0], "def");
-      }
+    private ExecutorService executorService;
+    private ServerSocket serverSocket;
+    private Future<?> voidFuture;
+
+    @BeforeClass
+    public void setUpGlobal() throws Exception {
+        serverSocket = ServerSocketFactory.getDefault().createServerSocket(0);
+        port1 = serverSocket.getLocalPort();
+        executorService = Executors.newFixedThreadPool(1);
+        voidFuture = executorService.submit(new Callable<Void>() {
+            public Void call() throws Exception {
+                Socket socket;
+                while ((socket = serverSocket.accept()) != null) {
+                    InputStream inputStream = socket.getInputStream();
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+                    String req = reader.readLine().split(" ")[1];
+                    int i = inputStream.available();
+                    long l = inputStream.skip(i);
+                    assertEquals(l, i);
+                    socket.shutdownInput();
+                    if (req.endsWith("MultiEnt")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n"
+                                + "Content-Length: 1\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    } else if (req.endsWith("MultiOther")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n"
+                                + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    }
+                }
+                return null;
+            }
+        });
     }
-  }
-
-  @Test
-  public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    final String[] clHeaders = new String[]{null, null};
-
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      Request req = get("http://localhost:" + port1 + "/MultiEnt").build();
-      final CountDownLatch latch = new CountDownLatch(1);
-      ahc.executeRequest(req, new AsyncHandler<Void>() {
-        public void onThrowable(Throwable t) {
-          t.printStackTrace(System.out);
-        }
 
-        public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) {
-          return State.CONTINUE;
-        }
-
-        public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) {
-          return State.CONTINUE;
-        }
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        voidFuture.cancel(true);
+        executorService.shutdownNow();
+        serverSocket.close();
+    }
 
-        public State onHeadersReceived(HttpHeaders response) {
-          try {
-            int i = 0;
-            for (String header : response.getAll(CONTENT_LENGTH)) {
-              clHeaders[i++] = header;
+    @Test(groups = "standalone")
+    public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] xffHeaders = new String[] { null, null };
+
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            Request req = get("http://localhost:" + port1 + "/MultiOther").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders response) throws Exception {
+                    int i = 0;
+                    for (String header : response.getAll("X-Forwarded-For")) {
+                        xffHeaders[i++] = header;
+                    }
+                    latch.countDown();
+                    return State.CONTINUE;
+                }
+
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
+
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                fail("Time out");
+            }
+            assertNotNull(xffHeaders[0]);
+            assertNotNull(xffHeaders[1]);
+            try {
+                assertEquals(xffHeaders[0], "abc");
+                assertEquals(xffHeaders[1], "def");
+            } catch (AssertionError ex) {
+                assertEquals(xffHeaders[1], "abc");
+                assertEquals(xffHeaders[0], "def");
             }
-          } finally {
-            latch.countDown();
-          }
-          return State.CONTINUE;
         }
+    }
 
-        public Void onCompleted() {
-          return null;
+    @Test(groups = "standalone")
+    public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] clHeaders = new String[] { null, null };
+
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            Request req = get("http://localhost:" + port1 + "/MultiEnt").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders response) throws Exception {
+                    try {
+                        int i = 0;
+                        for (String header : response.getAll(CONTENT_LENGTH)) {
+                            clHeaders[i++] = header;
+                        }
+                    } finally {
+                        latch.countDown();
+                    }
+                    return State.CONTINUE;
+                }
+
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
+
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                fail("Time out");
+            }
+            assertNotNull(clHeaders[0]);
+            assertNotNull(clHeaders[1]);
+
+            // We can predict the order
+            try {
+                assertEquals(clHeaders[0], "2");
+                assertEquals(clHeaders[1], "1");
+            } catch (Throwable ex) {
+                assertEquals(clHeaders[0], "1");
+                assertEquals(clHeaders[1], "2");
+            }
         }
-      }).get(3, TimeUnit.SECONDS);
-
-      if (!latch.await(2, TimeUnit.SECONDS)) {
-        fail("Time out");
-      }
-      assertNotNull(clHeaders[0]);
-      assertNotNull(clHeaders[1]);
-
-      // We can predict the order
-      try {
-        assertEquals(clHeaders[0], "2");
-        assertEquals(clHeaders[1], "1");
-      } catch (Throwable ex) {
-        assertEquals(clHeaders[0], "1");
-        assertEquals(clHeaders[1], "2");
-      }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
index 696ca6697..7d01d2360 100644
--- a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
@@ -16,35 +16,34 @@
  */
 package org.asynchttpclient;
 
-import org.testng.annotations.Test;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
+import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.assertNotNull;
 
+import org.testng.annotations.Test;
+
 public class NoNullResponseTest extends AbstractBasicTest {
-  private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
+    private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
 
-  @Test(groups = "online", invocationCount = 4)
-  public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
+    @Test(groups = "online", invocationCount = 4)
+    public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
 
-    AsyncHttpClientConfig config = config()
-            .setFollowRedirect(true)
-            .setKeepAlive(true)
-            .setConnectTimeout(10000)
-            .setPooledConnectionIdleTimeout(60000)
-            .setRequestTimeout(10000)
-            .setMaxConnectionsPerHost(-1)
-            .setMaxConnections(-1)
-            .build();
+        AsyncHttpClientConfig config = config()//
+                .setFollowRedirect(true)//
+                .setKeepAlive(true)//
+                .setConnectTimeout(10000)//
+                .setPooledConnectionIdleTimeout(60000)//
+                .setRequestTimeout(10000)//
+                .setMaxConnectionsPerHost(-1)//
+                .setMaxConnections(-1)//
+                .build();
 
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
-      final Response response1 = builder.execute().get();
-      Thread.sleep(4000);
-      final Response response2 = builder.execute().get();
-      assertNotNull(response1);
-      assertNotNull(response2);
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
+            final Response response1 = builder.execute().get();
+            Thread.sleep(4000);
+            final Response response2 = builder.execute().get();
+            assertNotNull(response1);
+            assertNotNull(response2);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
index d59285531..aec48d83f 100644
--- a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
+++ b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
@@ -12,71 +12,72 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 
 import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public class NonAsciiContentLengthTest extends AbstractBasicTest {
 
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(new AbstractHandler() {
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(new AbstractHandler() {
 
-      public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
-        int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
-        byte[] b = new byte[MAX_BODY_SIZE];
-        int offset = 0;
-        int numBytesRead;
-        try (ServletInputStream is = request.getInputStream()) {
-          while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
-            offset += numBytesRead;
-          }
-        }
-        assertEquals(request.getContentLength(), offset);
-        response.setStatus(200);
-        response.setCharacterEncoding(request.getCharacterEncoding());
-        response.setContentLength(request.getContentLength());
-        try (ServletOutputStream os = response.getOutputStream()) {
-          os.write(b, 0, offset);
-        }
-      }
-    });
-    server.start();
-    port1 = connector.getLocalPort();
-  }
+            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
+                byte[] b = new byte[MAX_BODY_SIZE];
+                int offset = 0;
+                int numBytesRead;
+                try (ServletInputStream is = request.getInputStream()) {
+                    while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
+                        offset += numBytesRead;
+                    }
+                }
+                assertEquals(request.getContentLength(), offset);
+                response.setStatus(200);
+                response.setCharacterEncoding(request.getCharacterEncoding());
+                response.setContentLength(request.getContentLength());
+                try (ServletOutputStream os = response.getOutputStream()) {
+                    os.write(b, 0, offset);
+                }
+            }
+        });
+        server.start();
+        port1 = connector.getLocalPort();
+    }
 
-  @Test
-  public void testNonAsciiContentLength() throws Exception {
-    execute("test");
-    execute("\u4E00"); // Unicode CJK ideograph for one
-  }
+    @Test(groups = "standalone")
+    public void testNonAsciiContentLength() throws Exception {
+        execute("test");
+        execute("\u4E00"); // Unicode CJK ideograph for one
+    }
 
-  protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setCharset(UTF_8);
-      Future<Response> f = r.execute();
-      Response resp = f.get();
-      assertEquals(resp.getStatusCode(), 200);
-      assertEquals(body, resp.getResponseBody(UTF_8));
+    protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setCharset(UTF_8);
+            Future<Response> f = r.execute();
+            Response resp = f.get();
+            assertEquals(resp.getStatusCode(), 200);
+            assertEquals(body, resp.getResponseBody(UTF_8));
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index 43783647e..790b3109b 100644
--- a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -15,59 +15,59 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-public class ParamEncodingTest extends AbstractBasicTest {
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
-  @Test
-  public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+public class ParamEncodingTest extends AbstractBasicTest {
 
-    String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
-      Response resp = f.get(10, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("X-Param"), value.trim());
+    private class ParamEncoding extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("POST".equalsIgnoreCase(request.getMethod())) {
+                String p = request.getParameter("test");
+                if (isNonEmpty(p)) {
+                    response.setStatus(HttpServletResponse.SC_OK);
+                    response.addHeader("X-Param", p);
+                } else {
+                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+                }
+            } else { // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
+        }
     }
-  }
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new ParamEncoding();
-  }
+    @Test(groups = "standalone")
+    public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-  private class ParamEncoding extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("POST".equalsIgnoreCase(request.getMethod())) {
-        String p = request.getParameter("test");
-        if (isNonEmpty(p)) {
-          response.setStatus(HttpServletResponse.SC_OK);
-          response.addHeader("X-Param", p);
-        } else {
-          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+        String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
+            Response resp = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), value.trim());
         }
-      } else { // this handler is to handle POST request
-        response.sendError(HttpServletResponse.SC_FORBIDDEN);
-      }
-      response.getOutputStream().flush();
-      response.getOutputStream().close();
     }
-  }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ParamEncoding();
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index e8433fa48..8156aa0e3 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -15,6 +15,20 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.util.Enumeration;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.uri.Uri;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -23,139 +37,125 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.util.Enumeration;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicBoolean;
+public class PerRequestRelative302Test extends AbstractBasicTest {
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+ // FIXME super NOT threadsafe!!!
+    private final AtomicBoolean isSet = new AtomicBoolean(false);
+
+    private class Relative302Handler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            String param;
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+
+                if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
+                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
+                    httpResponse.setStatus(302);
+                    httpResponse.getOutputStream().flush();
+                    httpResponse.getOutputStream().close();
+                    return;
+                }
+            }
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
+    }
 
-public class PerRequestRelative302Test extends AbstractBasicTest {
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+
+        server.setHandler(new Relative302Handler());
+        server.start();
+        port1 = connector.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
+    }
 
-  // FIXME super NOT threadsafe!!!
-  private final AtomicBoolean isSet = new AtomicBoolean(false);
-
-  private static int getPort(Uri uri) {
-    int port = uri.getPort();
-    if (port == -1)
-      port = uri.getScheme().equals("http") ? 80 : 443;
-    return port;
-  }
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-
-    server.setHandler(new Relative302Handler());
-    server.start();
-    port1 = connector.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-    port2 = findFreePort();
-  }
-
-  @Test(groups = "online")
-  // FIXME threadsafe
-  public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
-    redirected302Test();
-    notRedirected302Test();
-    relativeLocationUrl();
-    redirected302InvalidTest();
-  }
-
-  @Test(groups = "online", enabled = false)
-  public void redirected302Test() throws Exception {
-    isSet.getAndSet(false);
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "https://www.microsoft.com/").execute().get();
-
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-
-      String anyMicrosoftPage = "https://www.microsoft.com[^:]*:443";
-      String baseUrl = getBaseUrl(response.getUri());
-
-      assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+    @Test(groups = "online")
+    // FIXME threadsafe
+    public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        redirected302Test();
+        notRedirected302Test();
+        relativeLocationUrl();
+        redirected302InvalidTest();
     }
-  }
-
-  @Test(groups = "online", enabled = false)
-  public void notRedirected302Test() throws Exception {
-    isSet.getAndSet(false);
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 302);
+
+    // @Test(groups = "online")
+    public void redirected302Test() throws Exception {
+        isSet.getAndSet(false);
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "https://www.microsoft.com/").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+
+            String anyMicrosoftPage = "https://www.microsoft.com[^:]*:443";
+            String baseUrl = getBaseUrl(response.getUri());
+
+            assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+        }
     }
-  }
-
-  private String getBaseUrl(Uri uri) {
-    String url = uri.toString();
-    int port = uri.getPort();
-    if (port == -1) {
-      port = getPort(uri);
-      url = url.substring(0, url.length() - 1) + ":" + port;
+
+    // @Test(groups = "online")
+    public void notRedirected302Test() throws Exception {
+        isSet.getAndSet(false);
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
     }
-    return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
-  }
-
-  @Test(groups = "online", enabled = false)
-  public void redirected302InvalidTest() throws Exception {
-    isSet.getAndSet(false);
-    Exception e = null;
-
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-    } catch (ExecutionException ex) {
-      e = ex;
+
+    private String getBaseUrl(Uri uri) {
+        String url = uri.toString();
+        int port = uri.getPort();
+        if (port == -1) {
+            port = getPort(uri);
+            url = url.substring(0, url.length() - 1) + ":" + port;
+        }
+        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
     }
 
-    assertNotNull(e);
-    Throwable cause = e.getCause();
-    assertTrue(cause instanceof ConnectException);
-    assertTrue(cause.getMessage().contains(":" + port2));
-  }
-
-  @Test(enabled = false)
-  public void relativeLocationUrl() throws Exception {
-    isSet.getAndSet(false);
-
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getUri().toString(), getTargetUrl());
+    private static int getPort(Uri uri) {
+        int port = uri.getPort();
+        if (port == -1)
+            port = uri.getScheme().equals("http") ? 80 : 443;
+        return port;
     }
-  }
 
-  private class Relative302Handler extends AbstractHandler {
+    // @Test(groups = "standalone")
+    public void redirected302InvalidTest() throws Exception {
+        isSet.getAndSet(false);
+        Exception e = null;
 
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+        } catch (ExecutionException ex) {
+            e = ex;
+        }
+
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
+    }
 
-      String param;
-      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
+    // @Test(groups = "standalone")
+    public void relativeLocationUrl() throws Exception {
+        isSet.getAndSet(false);
 
-        if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
-          httpResponse.addHeader("Location", httpRequest.getHeader(param));
-          httpResponse.setStatus(302);
-          httpResponse.getOutputStream().flush();
-          httpResponse.getOutputStream().close();
-          return;
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), getTargetUrl());
         }
-      }
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 219860292..f8b783d37 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -15,167 +15,177 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import static org.testng.Assert.*;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Per request timeout configuration test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class PerRequestTimeoutTest extends AbstractBasicTest {
-  private static final String MSG = "Enough is enough.";
-
-  private void checkTimeoutMessage(String message, boolean requestTimeout) {
-    if (requestTimeout)
-      assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
-    else
-      assertTrue(message.startsWith("Read timeout"), "error message indicates reason of error but got: " + message);
-    assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
-    assertTrue(message.contains("after 100 ms"), "error message contains timeout configuration value but got: " + message);
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new SlowHandler();
-  }
-
-  @Test
-  public void testRequestTimeout() throws IOException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
-      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-      assertNull(response);
-    } catch (InterruptedException e) {
-      fail("Interrupted.", e);
-    } catch (ExecutionException e) {
-      assertTrue(e.getCause() instanceof TimeoutException);
-      checkTimeoutMessage(e.getCause().getMessage(), true);
-    } catch (TimeoutException e) {
-      fail("Timeout.", e);
-    }
-  }
-
-  @Test
-  public void testReadTimeout() throws IOException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setReadTimeout(100))) {
-      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
-      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-      assertNull(response);
-    } catch (InterruptedException e) {
-      fail("Interrupted.", e);
-    } catch (ExecutionException e) {
-      assertTrue(e.getCause() instanceof TimeoutException);
-      checkTimeoutMessage(e.getCause().getMessage(), false);
-    } catch (TimeoutException e) {
-      fail("Timeout.", e);
+    private static final String MSG = "Enough is enough.";
+
+    private void checkTimeoutMessage(String message, boolean requestTimeout) {
+        if (requestTimeout)
+            assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
+        else
+            assertTrue(message.startsWith("Read timeout"), "error message indicates reason of error but got: " + message);
+        assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
+        assertTrue(message.contains("after 100 ms"), "error message contains timeout configuration value but got: " + message);
     }
-  }
-
-  @Test
-  public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
-      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
-      Response response = responseFuture.get();
-      assertNotNull(response);
-    } catch (InterruptedException e) {
-      fail("Interrupted.", e);
-    } catch (ExecutionException e) {
-      assertTrue(e.getCause() instanceof TimeoutException);
-      checkTimeoutMessage(e.getCause().getMessage(), true);
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
     }
-  }
-
-  @Test
-  public void testGlobalRequestTimeout() throws IOException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
-      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
-      Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
-      assertNull(response);
-    } catch (InterruptedException e) {
-      fail("Interrupted.", e);
-    } catch (ExecutionException e) {
-      assertTrue(e.getCause() instanceof TimeoutException);
-      checkTimeoutMessage(e.getCause().getMessage(), true);
-    } catch (TimeoutException e) {
-      fail("Timeout.", e);
+
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(1500);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                    } catch (InterruptedException e) {
+                        logger.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        logger.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(3000);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        logger.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        logger.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
     }
-  }
 
-  @Test
-  public void testGlobalIdleTimeout() throws IOException {
-    final long times[] = new long[]{-1, -1};
+    @Test(groups = "standalone")
+    public void testRequestTimeout() throws IOException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
+            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+            assertNull(response);
+        } catch (InterruptedException e) {
+            fail("Interrupted.", e);
+        } catch (ExecutionException e) {
+            assertTrue(e.getCause() instanceof TimeoutException);
+            checkTimeoutMessage(e.getCause().getMessage(), true);
+        } catch (TimeoutException e) {
+            fail("Timeout.", e);
+        }
+    }
 
-    try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000))) {
-      Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
-        @Override
-        public Response onCompleted(Response response) {
-          return response;
+    @Test(groups = "standalone")
+    public void testReadTimeout() throws IOException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setReadTimeout(100))) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
+            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+            assertNull(response);
+        } catch (InterruptedException e) {
+            fail("Interrupted.", e);
+        } catch (ExecutionException e) {
+            assertTrue(e.getCause() instanceof TimeoutException);
+            checkTimeoutMessage(e.getCause().getMessage(), false);
+        } catch (TimeoutException e) {
+            fail("Timeout.", e);
         }
+    }
 
-        @Override
-        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-          times[0] = unpreciseMillisTime();
-          return super.onBodyPartReceived(content);
+    @Test(groups = "standalone")
+    public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
+            Response response = responseFuture.get();
+            assertNotNull(response);
+        } catch (InterruptedException e) {
+            fail("Interrupted.", e);
+        } catch (ExecutionException e) {
+            assertTrue(e.getCause() instanceof TimeoutException);
+            checkTimeoutMessage(e.getCause().getMessage(), true);
         }
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-          times[1] = unpreciseMillisTime();
-          super.onThrowable(t);
+    @Test(groups = "standalone")
+    public void testGlobalRequestTimeout() throws IOException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
+            Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
+            assertNull(response);
+        } catch (InterruptedException e) {
+            fail("Interrupted.", e);
+        } catch (ExecutionException e) {
+            assertTrue(e.getCause() instanceof TimeoutException);
+            checkTimeoutMessage(e.getCause().getMessage(), true);
+        } catch (TimeoutException e) {
+            fail("Timeout.", e);
         }
-      });
-      Response response = responseFuture.get();
-      assertNotNull(response);
-      assertEquals(response.getResponseBody(), MSG + MSG);
-    } catch (InterruptedException e) {
-      fail("Interrupted.", e);
-    } catch (ExecutionException e) {
-      logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
-      fail("Timeouted on idle.", e);
     }
-  }
-
-  private class SlowHandler extends AbstractHandler {
-    public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
-      response.setStatus(HttpServletResponse.SC_OK);
-      final AsyncContext asyncContext = request.startAsync();
-      new Thread(() -> {
-          try {
-            Thread.sleep(1500);
-            response.getOutputStream().print(MSG);
-            response.getOutputStream().flush();
-          } catch (InterruptedException | IOException e) {
-            logger.error(e.getMessage(), e);
-          }
-      }).start();
-      new Thread(() -> {
-          try {
-            Thread.sleep(3000);
-            response.getOutputStream().print(MSG);
-            response.getOutputStream().flush();
-            asyncContext.complete();
-          } catch (InterruptedException | IOException e) {
-            logger.error(e.getMessage(), e);
-          }
-      }).start();
-      baseRequest.setHandled(true);
+
+    @Test(groups = "standalone")
+    public void testGlobalIdleTimeout() throws IOException {
+        final long times[] = new long[] { -1, -1 };
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000))) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+
+                @Override
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    times[0] = unpreciseMillisTime();
+                    return super.onBodyPartReceived(content);
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    times[1] = unpreciseMillisTime();
+                    super.onThrowable(t);
+                }
+            });
+            Response response = responseFuture.get();
+            assertNotNull(response);
+            assertEquals(response.getResponseBody(), MSG + MSG);
+        } catch (InterruptedException e) {
+            fail("Interrupted.", e);
+        } catch (ExecutionException e) {
+            logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
+            fail("Timeouted on idle.", e);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
index c231b3761..4762556fb 100644
--- a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
@@ -12,186 +12,191 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class PostRedirectGetTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new PostRedirectGetHandler();
-  }
-
-  @Test
-  public void postRedirectGet302Test() throws Exception {
-    doTestPositive(302);
-  }
-
-  @Test
-  public void postRedirectGet302StrictTest() throws Exception {
-    doTestNegative(302, true);
-  }
-
-  @Test
-  public void postRedirectGet303Test() throws Exception {
-    doTestPositive(303);
-  }
-
-  @Test
-  public void postRedirectGet301Test() throws Exception {
-    doTestPositive(301);
-  }
-
-  @Test
-  public void postRedirectGet307Test() throws Exception {
-    doTestNegative(307, false);
-  }
-
-  // --------------------------------------------------------- Private Methods
-
-  private void doTestNegative(final int status, boolean strict) throws Exception {
-
-    ResponseFilter responseFilter = new ResponseFilter() {
-      @Override
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        // pass on the x-expect-get and remove the x-redirect
-        // headers if found in the response
-        ctx.getResponseHeaders().get("x-expect-post");
-        ctx.getRequest().getHeaders().add("x-expect-post", "true");
-        ctx.getRequest().getHeaders().remove("x-redirect");
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(responseFilter))) {
-      Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
-      Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+    // ------------------------------------------------------ Test Configuration
 
-        @Override
-        public Integer onCompleted(Response response) {
-          return response.getStatusCode();
-        }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new PostRedirectGetHandler();
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-          t.printStackTrace();
-          fail("Unexpected exception: " + t.getMessage(), t);
-        }
+    // ------------------------------------------------------------ Test Methods
 
-      });
-      int statusCode = responseFuture.get();
-      assertEquals(statusCode, 200);
+    @Test(groups = "standalone")
+    public void postRedirectGet302Test() throws Exception {
+        doTestPositive(302);
     }
-  }
-
-  private void doTestPositive(final int status) throws Exception {
-
-    ResponseFilter responseFilter = new ResponseFilter() {
-      @Override
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        // pass on the x-expect-get and remove the x-redirect
-        // headers if found in the response
-        ctx.getResponseHeaders().get("x-expect-get");
-        ctx.getRequest().getHeaders().add("x-expect-get", "true");
-        ctx.getRequest().getHeaders().remove("x-redirect");
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(responseFilter))) {
-      Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
-      Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
-        @Override
-        public Integer onCompleted(Response response) {
-          return response.getStatusCode();
-        }
+    @Test(groups = "standalone")
+    public void postRedirectGet302StrictTest() throws Exception {
+        doTestNegative(302, true);
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-          t.printStackTrace();
-          fail("Unexpected exception: " + t.getMessage(), t);
+    @Test(groups = "standalone")
+    public void postRedirectGet303Test() throws Exception {
+        doTestPositive(303);
+    }
+
+    @Test(groups = "standalone")
+    public void postRedirectGet301Test() throws Exception {
+        doTestPositive(301);
+    }
+
+    @Test(groups = "standalone")
+    public void postRedirectGet307Test() throws Exception {
+        doTestNegative(307, false);
+    }
+
+    // --------------------------------------------------------- Private Methods
+
+    private void doTestNegative(final int status, boolean strict) throws Exception {
+
+        ResponseFilter responseFilter = new ResponseFilter() {
+            @Override
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().get("x-expect-post");
+                ctx.getRequest().getHeaders().add("x-expect-post", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(responseFilter))) {
+            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    fail("Unexpected exception: " + t.getMessage(), t);
+                }
+
+            });
+            int statusCode = responseFuture.get();
+            assertEquals(statusCode, 200);
         }
+    }
 
-      });
-      int statusCode = responseFuture.get();
-      assertEquals(statusCode, 200);
+    private void doTestPositive(final int status) throws Exception {
+
+        ResponseFilter responseFilter = new ResponseFilter() {
+            @Override
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().get("x-expect-get");
+                ctx.getRequest().getHeaders().add("x-expect-get", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(responseFilter))) {
+            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    fail("Unexpected exception: " + t.getMessage(), t);
+                }
+
+            });
+            int statusCode = responseFuture.get();
+            assertEquals(statusCode, 200);
+        }
     }
-  }
 
-  // ---------------------------------------------------------- Nested Classes
+    // ---------------------------------------------------------- Nested Classes
 
-  public static class PostRedirectGetHandler extends AbstractHandler {
+    public static class PostRedirectGetHandler extends AbstractHandler {
 
-    final AtomicInteger counter = new AtomicInteger();
+        final AtomicInteger counter = new AtomicInteger();
 
-    @Override
-    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-      final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
-      final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
-      if (expectGet) {
-        final String method = request.getMethod();
-        if (!"GET".equals(method)) {
-          httpResponse.sendError(500, "Incorrect method.  Expected GET, received " + method);
-          return;
-        }
-        httpResponse.setStatus(200);
-        httpResponse.getOutputStream().write("OK".getBytes());
-        httpResponse.getOutputStream().flush();
-        return;
-      } else if (expectPost) {
-        final String method = request.getMethod();
-        if (!"POST".equals(method)) {
-          httpResponse.sendError(500, "Incorrect method.  Expected POST, received " + method);
-          return;
-        }
-        httpResponse.setStatus(200);
-        httpResponse.getOutputStream().write("OK".getBytes());
-        httpResponse.getOutputStream().flush();
-        return;
-      }
-
-      String header = httpRequest.getHeader("x-redirect");
-      if (header != null) {
-        // format for header is <status code>|<location url>
-        String[] parts = header.split("@");
-        int redirectCode;
-        try {
-          redirectCode = Integer.parseInt(parts[0]);
-        } catch (Exception ex) {
-          ex.printStackTrace();
-          httpResponse.sendError(500, "Unable to parse redirect code");
-          return;
-        }
-        httpResponse.setStatus(redirectCode);
-        if (httpRequest.getHeader("x-negative") == null) {
-          httpResponse.addHeader("x-expect-get", "true");
-        } else {
-          httpResponse.addHeader("x-expect-post", "true");
+        @Override
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
+            final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
+            if (expectGet) {
+                final String method = request.getMethod();
+                if (!"GET".equals(method)) {
+                    httpResponse.sendError(500, "Incorrect method.  Expected GET, received " + method);
+                    return;
+                }
+                httpResponse.setStatus(200);
+                httpResponse.getOutputStream().write("OK".getBytes());
+                httpResponse.getOutputStream().flush();
+                return;
+            } else if (expectPost) {
+                final String method = request.getMethod();
+                if (!"POST".equals(method)) {
+                    httpResponse.sendError(500, "Incorrect method.  Expected POST, received " + method);
+                    return;
+                }
+                httpResponse.setStatus(200);
+                httpResponse.getOutputStream().write("OK".getBytes());
+                httpResponse.getOutputStream().flush();
+                return;
+            }
+
+            String header = httpRequest.getHeader("x-redirect");
+            if (header != null) {
+                // format for header is <status code>|<location url>
+                String[] parts = header.split("@");
+                int redirectCode;
+                try {
+                    redirectCode = Integer.parseInt(parts[0]);
+                } catch (Exception ex) {
+                    ex.printStackTrace();
+                    httpResponse.sendError(500, "Unable to parse redirect code");
+                    return;
+                }
+                httpResponse.setStatus(redirectCode);
+                if (httpRequest.getHeader("x-negative") == null) {
+                    httpResponse.addHeader("x-expect-get", "true");
+                } else {
+                    httpResponse.addHeader("x-expect-post", "true");
+                }
+                httpResponse.setContentLength(0);
+                httpResponse.addHeader("Location", parts[1] + counter.getAndIncrement());
+                httpResponse.getOutputStream().flush();
+                return;
+            }
+
+            httpResponse.sendError(500);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
         }
-        httpResponse.setContentLength(0);
-        httpResponse.addHeader("Location", parts[1] + counter.getAndIncrement());
-        httpResponse.getOutputStream().flush();
-        return;
-      }
-
-      httpResponse.sendError(500);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
index affd2802a..3ac1f67e8 100644
--- a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
@@ -15,130 +15,130 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Tests POST request with Query String.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class PostWithQSTest extends AbstractBasicTest {
 
-  @Test
-  public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-    }
-  }
-
-  @Test
-  public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-        @Override
-        public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-          if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=")) {
-            throw new IOException(status.getUri().toUrl());
-          }
-          return super.onStatusReceived(status);
+    /**
+     * POST with QS server part.
+     */
+    private class PostWithQSHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("POST".equalsIgnoreCase(request.getMethod())) {
+                String qs = request.getQueryString();
+                if (isNonEmpty(qs) && request.getContentLength() == 3) {
+                    ServletInputStream is = request.getInputStream();
+                    response.setStatus(HttpServletResponse.SC_OK);
+                    byte buf[] = new byte[is.available()];
+                    is.readLine(buf, 0, is.available());
+                    ServletOutputStream os = response.getOutputStream();
+                    os.println(new String(buf));
+                    os.flush();
+                    os.close();
+                } else {
+                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+                }
+            } else { // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
         }
-
-      });
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
     }
-  }
-
-  @Test
-  public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-        @Override
-        public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-          if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
-            throw new IOException("failed to parse the query properly");
-          }
-          return super.onStatusReceived(status);
-        }
 
-      });
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+    @Test(groups = "standalone")
+    public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        }
     }
-  }
-
-  @Test
-  public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-        @Override
-        public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-          if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
-            throw new IOException("failed to parse the query properly");
-          }
-          return super.onStatusReceived(status);
+
+    @Test(groups = "standalone")
+    public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                @Override
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=")) {
+                        throw new IOException(status.getUri().toUrl());
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
         }
+    }
 
-      });
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+    @Test(groups = "standalone")
+    public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                @Override
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
+                        throw new IOException("failed to parse the query properly");
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        }
     }
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new PostWithQSHandler();
-  }
-
-  /**
-   * POST with QS server part.
-   */
-  private class PostWithQSHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("POST".equalsIgnoreCase(request.getMethod())) {
-        String qs = request.getQueryString();
-        if (isNonEmpty(qs) && request.getContentLength() == 3) {
-          ServletInputStream is = request.getInputStream();
-          response.setStatus(HttpServletResponse.SC_OK);
-          byte buf[] = new byte[is.available()];
-          is.readLine(buf, 0, is.available());
-          ServletOutputStream os = response.getOutputStream();
-          os.println(new String(buf));
-          os.flush();
-          os.close();
-        } else {
-          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+
+    @Test(groups = "standalone")
+    public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                @Override
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
+                        throw new IOException("failed to parse the query properly");
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
         }
-      } else { // this handler is to handle POST request
-        response.sendError(HttpServletResponse.SC_FORBIDDEN);
-      }
     }
-  }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new PostWithQSHandler();
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
index 1691e8138..d724dd35b 100644
--- a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
+++ b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -15,13 +15,11 @@
  */
 package org.asynchttpclient;
 
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
@@ -30,76 +28,78 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Testing query parameters support.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class QueryParametersTest extends AbstractBasicTest {
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new QueryStringHandler();
-  }
-
-  @Test
-  public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("a"), "1");
-      assertEquals(resp.getHeader("b"), "2");
+    private class QueryStringHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("GET".equalsIgnoreCase(request.getMethod())) {
+                String qs = request.getQueryString();
+                if (isNonEmpty(qs)) {
+                    for (String qnv : qs.split("&")) {
+                        String nv[] = qnv.split("=");
+                        response.addHeader(nv[0], nv[1]);
+                    }
+                    response.setStatus(HttpServletResponse.SC_OK);
+                } else {
+                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+                }
+            } else { // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
+            r.setHandled(true);
+        }
     }
-  }
 
-  @Test
-  public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
-    String URL = getTargetUrl() + "?q=";
-    String REQUEST_PARAM = "github github \ngithub";
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new QueryStringHandler();
+    }
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
-      logger.info("Executing request [{}] ...", requestUrl2);
-      Response response = client.prepareGet(requestUrl2).execute().get();
-      String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
-      assertEquals(s, REQUEST_PARAM);
+    @Test(groups = "standalone")
+    public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("a"), "1");
+            assertEquals(resp.getHeader("b"), "2");
+        }
     }
-  }
 
-  @Test
-  public void urlWithColonTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      String query = "test:colon:";
-      Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+    @Test(groups = "standalone")
+    public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
+        String URL = getTargetUrl() + "?q=";
+        String REQUEST_PARAM = "github github \ngithub";
 
-      assertEquals(response.getHeader("q"), query);
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
+            logger.info("Executing request [{}] ...", requestUrl2);
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
+            assertEquals(s, REQUEST_PARAM);
+        }
     }
-  }
 
-  private class QueryStringHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("GET".equalsIgnoreCase(request.getMethod())) {
-        String qs = request.getQueryString();
-        if (isNonEmpty(qs)) {
-          for (String qnv : qs.split("&")) {
-            String nv[] = qnv.split("=");
-            response.addHeader(nv[0], nv[1]);
-          }
-          response.setStatus(HttpServletResponse.SC_OK);
-        } else {
-          response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+    @Test(groups = "standalone")
+    public void urlWithColonTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String query = "test:colon:";
+            Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getHeader("q"), query);
         }
-      } else { // this handler is to handle POST request
-        response.sendError(HttpServletResponse.SC_FORBIDDEN);
-      }
-      r.setHandled(true);
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RC1KTest.java b/client/src/test/java/org/asynchttpclient/RC1KTest.java
index 93ac24545..fd2b043b4 100644
--- a/client/src/test/java/org/asynchttpclient/RC1KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC1KTest.java
@@ -15,125 +15,126 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 /**
  * Reverse C1K Problem test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class RC1KTest extends AbstractBasicTest {
-  private static final int C1K = 1000;
-  private static final String ARG_HEADER = "Arg";
-  private static final int SRV_COUNT = 10;
-  private Server[] servers = new Server[SRV_COUNT];
-  private int[] ports = new int[SRV_COUNT];
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    ports = new int[SRV_COUNT];
-    for (int i = 0; i < SRV_COUNT; i++) {
-      Server server = new Server();
-      ServerConnector connector = addHttpConnector(server);
-      server.setHandler(configureHandler());
-      server.start();
-      servers[i] = server;
-      ports[i] = connector.getLocalPort();
-    }
-    logger.info("Local HTTP servers started successfully");
-  }
+    private static final int C1K = 1000;
+    private static final String ARG_HEADER = "Arg";
+    private static final int SRV_COUNT = 10;
+    protected Server[] servers = new Server[SRV_COUNT];
+    private int[] ports = new int[SRV_COUNT];
 
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    for (Server srv : servers) {
-      srv.stop();
-    }
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new AbstractHandler() {
-      public void handle(String s, Request r, HttpServletRequest req, HttpServletResponse resp) throws IOException {
-        resp.setContentType("text/pain");
-        String arg = s.substring(1);
-        resp.setHeader(ARG_HEADER, arg);
-        resp.setStatus(200);
-        resp.getOutputStream().print(arg);
-        resp.getOutputStream().flush();
-        resp.getOutputStream().close();
-      }
-    };
-  }
-
-  @Test(timeOut = 10 * 60 * 1000)
-  public void rc10kProblem() throws IOException, ExecutionException, InterruptedException {
-    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C1K).setKeepAlive(true))) {
-      List<Future<Integer>> resps = new ArrayList<>(C1K);
-      int i = 0;
-      while (i < C1K) {
-        resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
-      }
-      i = 0;
-      for (Future<Integer> fResp : resps) {
-        Integer resp = fResp.get();
-        assertNotNull(resp);
-        assertEquals(resp.intValue(), i++);
-      }
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        ports = new int[SRV_COUNT];
+        for (int i = 0; i < SRV_COUNT; i++) {
+            Server server = new Server();
+            ServerConnector connector = addHttpConnector(server);
+            server.setHandler(configureHandler());
+            server.start();
+            servers[i] = server;
+            ports[i] = connector.getLocalPort();
+        }
+        logger.info("Local HTTP servers started successfully");
     }
-  }
 
-  private class MyAsyncHandler implements AsyncHandler<Integer> {
-    private String arg;
-    private AtomicInteger result = new AtomicInteger(-1);
-
-    MyAsyncHandler(int i) {
-      arg = String.format("%d", i);
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        for (Server srv : servers) {
+            srv.stop();
+        }
     }
 
-    public void onThrowable(Throwable t) {
-      logger.warn("onThrowable called.", t);
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+            public void handle(String s, Request r, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+                resp.setContentType("text/pain");
+                String arg = s.substring(1);
+                resp.setHeader(ARG_HEADER, arg);
+                resp.setStatus(200);
+                resp.getOutputStream().print(arg);
+                resp.getOutputStream().flush();
+                resp.getOutputStream().close();
+            }
+        };
     }
 
-    public State onBodyPartReceived(HttpResponseBodyPart event) {
-      String s = new String(event.getBodyPartBytes());
-      result.compareAndSet(-1, new Integer(s.trim().equals("") ? "-1" : s));
-      return State.CONTINUE;
+    @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
+    public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C1K).setKeepAlive(true))) {
+            List<Future<Integer>> resps = new ArrayList<>(C1K);
+            int i = 0;
+            while (i < C1K) {
+                resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+            }
+            i = 0;
+            for (Future<Integer> fResp : resps) {
+                Integer resp = fResp.get();
+                assertNotNull(resp);
+                assertEquals(resp.intValue(), i++);
+            }
+        }
     }
 
-    public State onStatusReceived(HttpResponseStatus event) {
-      assertEquals(event.getStatusCode(), 200);
-      return State.CONTINUE;
-    }
+    private class MyAsyncHandler implements AsyncHandler<Integer> {
+        private String arg;
+        private AtomicInteger result = new AtomicInteger(-1);
 
-    public State onHeadersReceived(HttpHeaders event) {
-      assertEquals(event.get(ARG_HEADER), arg);
-      return State.CONTINUE;
-    }
+        public MyAsyncHandler(int i) {
+            arg = String.format("%d", i);
+        }
+
+        public void onThrowable(Throwable t) {
+            logger.warn("onThrowable called.", t);
+        }
+
+        public State onBodyPartReceived(HttpResponseBodyPart event) throws Exception {
+            String s = new String(event.getBodyPartBytes());
+            result.compareAndSet(-1, new Integer(s.trim().equals("") ? "-1" : s));
+            return State.CONTINUE;
+        }
+
+        public State onStatusReceived(HttpResponseStatus event) throws Exception {
+            assertEquals(event.getStatusCode(), 200);
+            return State.CONTINUE;
+        }
+
+        public State onHeadersReceived(HttpHeaders event) throws Exception {
+            assertEquals(event.get(ARG_HEADER), arg);
+            return State.CONTINUE;
+        }
 
-    public Integer onCompleted() {
-      return result.get();
+        public Integer onCompleted() throws Exception {
+            return result.get();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RealmTest.java b/client/src/test/java/org/asynchttpclient/RealmTest.java
index 5f17a9b6f..cb079189c 100644
--- a/client/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/client/src/test/java/org/asynchttpclient/RealmTest.java
@@ -12,97 +12,97 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.StringUtils;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.UTF_16;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
 
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 
-import static java.nio.charset.StandardCharsets.UTF_16;
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.StringUtils;
+import org.testng.annotations.Test;
 
 public class RealmTest {
-  @Test
-  public void testClone() {
-    Realm orig = basicAuthRealm("user", "pass").setCharset(UTF_16)
-            .setUsePreemptiveAuth(true)
-            .setRealmName("realm")
-            .setAlgorithm("algo").build();
+    @Test(groups = "standalone")
+    public void testClone() {
+        Realm orig = basicAuthRealm("user", "pass").setCharset(UTF_16)//
+                .setUsePreemptiveAuth(true)//
+                .setRealmName("realm")//
+                .setAlgorithm("algo").build();
 
-    Realm clone = realm(orig).build();
-    assertEquals(clone.getPrincipal(), orig.getPrincipal());
-    assertEquals(clone.getPassword(), orig.getPassword());
-    assertEquals(clone.getCharset(), orig.getCharset());
-    assertEquals(clone.isUsePreemptiveAuth(), orig.isUsePreemptiveAuth());
-    assertEquals(clone.getRealmName(), orig.getRealmName());
-    assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
-    assertEquals(clone.getScheme(), orig.getScheme());
-  }
+        Realm clone = realm(orig).build();
+        assertEquals(clone.getPrincipal(), orig.getPrincipal());
+        assertEquals(clone.getPassword(), orig.getPassword());
+        assertEquals(clone.getCharset(), orig.getCharset());
+        assertEquals(clone.isUsePreemptiveAuth(), orig.isUsePreemptiveAuth());
+        assertEquals(clone.getRealmName(), orig.getRealmName());
+        assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
+        assertEquals(clone.getScheme(), orig.getScheme());
+    }
 
-  @Test
-  public void testOldDigestEmptyString() throws Exception {
-    testOldDigest("");
-  }
+    @Test(groups = "standalone")
+    public void testOldDigestEmptyString() throws Exception {
+        testOldDigest("");
+    }
 
-  @Test
-  public void testOldDigestNull() throws Exception {
-    testOldDigest(null);
-  }
+    @Test(groups = "standalone")
+    public void testOldDigestNull() throws Exception {
+        testOldDigest(null);
+    }
 
-  private void testOldDigest(String qop) throws Exception {
-    String user = "user";
-    String pass = "pass";
-    String realm = "realm";
-    String nonce = "nonce";
-    String method = "GET";
-    Uri uri = Uri.create("http://ahc.io/foo");
-    Realm orig = digestAuthRealm(user, pass)
-            .setNonce(nonce)
-            .setUri(uri)
-            .setMethodName(method)
-            .setRealmName(realm)
-            .setQop(qop)
-            .build();
+    private void testOldDigest(String qop) throws Exception {
+        String user = "user";
+        String pass = "pass";
+        String realm = "realm";
+        String nonce = "nonce";
+        String method = "GET";
+        Uri uri = Uri.create("http://ahc.io/foo");
+        Realm orig = digestAuthRealm(user, pass)//
+                .setNonce(nonce)//
+                .setUri(uri)//
+                .setMethodName(method)//
+                .setRealmName(realm)//
+                .setQop(qop)//
+                .build();
 
-    String ha1 = getMd5(user + ":" + realm + ":" + pass);
-    String ha2 = getMd5(method + ":" + uri.getPath());
-    String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
+        String ha1 = getMd5(user + ":" + realm + ":" + pass);
+        String ha2 = getMd5(method + ":" + uri.getPath());
+        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
 
-    assertEquals(orig.getResponse(), expectedResponse);
-  }
+        assertEquals(orig.getResponse(), expectedResponse);
+    }
 
-  @Test
-  public void testStrongDigest() throws Exception {
-    String user = "user";
-    String pass = "pass";
-    String realm = "realm";
-    String nonce = "nonce";
-    String method = "GET";
-    Uri uri = Uri.create("http://ahc.io/foo");
-    String qop = "auth";
-    Realm orig = digestAuthRealm(user, pass)
-            .setNonce(nonce)
-            .setUri(uri)
-            .setMethodName(method)
-            .setRealmName(realm)
-            .setQop(qop)
-            .build();
+    @Test(groups = "standalone")
+    public void testStrongDigest() throws Exception {
+        String user = "user";
+        String pass = "pass";
+        String realm = "realm";
+        String nonce = "nonce";
+        String method = "GET";
+        Uri uri = Uri.create("http://ahc.io/foo");
+        String qop = "auth";
+        Realm orig = digestAuthRealm(user, pass)//
+                .setNonce(nonce)//
+                .setUri(uri)//
+                .setMethodName(method)//
+                .setRealmName(realm)//
+                .setQop(qop)//
+                .build();
 
-    String nc = orig.getNc();
-    String cnonce = orig.getCnonce();
-    String ha1 = getMd5(user + ":" + realm + ":" + pass);
-    String ha2 = getMd5(method + ":" + uri.getPath());
-    String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
+        String nc = orig.getNc();
+        String cnonce = orig.getCnonce();
+        String ha1 = getMd5(user + ":" + realm + ":" + pass);
+        String ha2 = getMd5(method + ":" + uri.getPath());
+        String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
 
-    assertEquals(orig.getResponse(), expectedResponse);
-  }
+        assertEquals(orig.getResponse(), expectedResponse);
+    }
 
-  private String getMd5(String what) throws Exception {
-    MessageDigest md = MessageDigest.getInstance("MD5");
-    md.update(what.getBytes(StandardCharsets.ISO_8859_1));
-    byte[] hash = md.digest();
-    return StringUtils.toHexString(hash);
-  }
+    private String getMd5(String what) throws Exception {
+        MessageDigest md = MessageDigest.getInstance("MD5");
+        md.update(what.getBytes(StandardCharsets.ISO_8859_1));
+        byte[] hash = md.digest();
+        return StringUtils.toHexString(hash);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index 935c51cef..8de3d2b98 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -13,110 +13,117 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.commons.io.IOUtils;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
+public class RedirectBodyTest extends AbstractBasicTest {
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
+    private String receivedContentType;
 
-public class RedirectBodyTest extends AbstractBasicTest {
+    @BeforeMethod
+    public void setUp() throws Exception {
+        receivedContentType = null;
+    }
 
-  private volatile boolean redirectAlreadyPerformed;
-  private volatile String receivedContentType;
-
-  @BeforeMethod
-  public void setUp() {
-    redirectAlreadyPerformed = false;
-    receivedContentType = null;
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new AbstractHandler() {
-      @Override
-      public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException {
-
-        String redirectHeader = httpRequest.getHeader("X-REDIRECT");
-        if (redirectHeader != null && !redirectAlreadyPerformed) {
-          redirectAlreadyPerformed = true;
-          httpResponse.setStatus(Integer.valueOf(redirectHeader));
-          httpResponse.setContentLength(0);
-          httpResponse.setHeader(LOCATION.toString(), getTargetUrl());
-
-        } else {
-          receivedContentType = request.getContentType();
-          httpResponse.setStatus(200);
-          int len = request.getContentLength();
-          httpResponse.setContentLength(len);
-          if (len > 0) {
-            byte[] buffer = new byte[len];
-            IOUtils.read(request.getInputStream(), buffer);
-            httpResponse.getOutputStream().write(buffer);
-          }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+            @Override
+            public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+                String redirectHeader = httpRequest.getHeader("X-REDIRECT");
+                if (redirectHeader != null) {
+                    httpResponse.setStatus(Integer.valueOf(redirectHeader));
+                    httpResponse.setContentLength(0);
+                    httpResponse.setHeader("Location", getTargetUrl());
+
+                } else {
+                    httpResponse.setStatus(200);
+                    int len = request.getContentLength();
+                    httpResponse.setContentLength(len);
+                    if (len > 0) {
+                        byte[] buffer = new byte[len];
+                        IOUtils.read(request.getInputStream(), buffer);
+                        httpResponse.getOutputStream().write(buffer);
+                    }
+                    receivedContentType = request.getContentType();
+                }
+                httpResponse.getOutputStream().flush();
+                httpResponse.getOutputStream().close();
+            }
+        };
+    }
+
+    private ResponseFilter redirectOnce = new ResponseFilter() {
+        @Override
+        public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+            ctx.getRequest().getHeaders().remove("X-REDIRECT");
+            return ctx;
         }
-        httpResponse.getOutputStream().flush();
-        httpResponse.getOutputStream().close();
-      }
     };
-  }
 
-  @Test
-  public void regular301LosesBody() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      String body = "hello there";
-      String contentType = "text/plain; charset=UTF-8";
+    @Test(groups = "standalone")
+    public void regular301LosesBody() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
+            String body = "hello there";
+            String contentType = "text/plain";
 
-      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(response.getResponseBody(), "");
-      assertNull(receivedContentType);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
+        }
     }
-  }
 
-  @Test
-  public void regular302LosesBody() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      String body = "hello there";
-      String contentType = "text/plain; charset=UTF-8";
+    @Test(groups = "standalone")
+    public void regular302LosesBody() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
+            String body = "hello there";
+            String contentType = "text/plain";
 
-      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(response.getResponseBody(), "");
-      assertNull(receivedContentType);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
+        }
     }
-  }
 
-  @Test
-  public void regular302StrictKeepsBody() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true))) {
-      String body = "hello there";
-      String contentType = "text/plain; charset=UTF-8";
+    @Test(groups = "standalone")
+    public void regular302StrictKeepsBody() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce))) {
+            String body = "hello there";
+            String contentType = "text/plain";
 
-      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(response.getResponseBody(), body);
-      assertEquals(receivedContentType, contentType);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
+        }
     }
-  }
 
-  @Test
-  public void regular307KeepsBody() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      String body = "hello there";
-      String contentType = "text/plain; charset=UTF-8";
+    @Test(groups = "standalone")
+    public void regular307KeepsBody() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
+            String body = "hello there";
+            String contentType = "text/plain";
 
-      Response response = c.preparePost(getTargetUrl()).setHeader(CONTENT_TYPE, contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(response.getResponseBody(), body);
-      assertEquals(receivedContentType, contentType);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
index 70a76f2b8..ce495d1b9 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
@@ -15,6 +15,19 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Date;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
@@ -22,98 +35,87 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Date;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 /**
  * Test for multithreaded url fetcher calls that use two separate sets of ssl certificates. This then tests that the certificate settings do not clash (override each other),
  * resulting in the peer not authenticated exception
- *
+ * 
  * @author dominict
  */
 public class RedirectConnectionUsageTest extends AbstractBasicTest {
-  private String BASE_URL;
-
-  private String servletEndpointRedirectUrl;
-
-  @BeforeClass
-  public void setUp() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-
-    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-    context.addServlet(new ServletHolder(new MockRedirectHttpServlet()), "/redirect/*");
-    context.addServlet(new ServletHolder(new MockFullResponseHttpServlet()), "/*");
-    server.setHandler(context);
-
-    server.start();
-    port1 = connector.getLocalPort();
-
-    BASE_URL = "http://localhost" + ":" + port1;
-    servletEndpointRedirectUrl = BASE_URL + "/redirect";
-  }
-
-  /**
-   * Tests that after a redirect the final url in the response reflect the redirect
-   */
-  @Test
-  public void testGetRedirectFinalUrl() throws Exception {
-
-    AsyncHttpClientConfig config = config()
-            .setKeepAlive(true)
-            .setMaxConnectionsPerHost(1)
-            .setMaxConnections(1)
-            .setConnectTimeout(1000)
-            .setRequestTimeout(1000)
-            .setFollowRedirect(true)
-            .build();
-
-    try (AsyncHttpClient c = asyncHttpClient(config)) {
-      ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));
-      Response res = response.get();
-      assertNotNull(res.getResponseBody());
-      assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
+    private String BASE_URL;
+
+    private String servletEndpointRedirectUrl;
+
+    @BeforeClass
+    public void setUp() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+        context.addServlet(new ServletHolder(new MockRedirectHttpServlet()), "/redirect/*");
+        context.addServlet(new ServletHolder(new MockFullResponseHttpServlet()), "/*");
+        server.setHandler(context);
+
+        server.start();
+        port1 = connector.getLocalPort();
+
+        BASE_URL = "http://localhost" + ":" + port1;
+        servletEndpointRedirectUrl = BASE_URL + "/redirect";
+    }
+
+    /**
+     * Tests that after a redirect the final url in the response reflect the redirect
+     */
+    @Test(groups = "standalone")
+    public void testGetRedirectFinalUrl() throws Exception {
+
+        AsyncHttpClientConfig config = config()//
+                .setKeepAlive(true)//
+                .setMaxConnectionsPerHost(1)//
+                .setMaxConnections(1)//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(1000)//
+                .setFollowRedirect(true)//
+                .build();
+
+        try (AsyncHttpClient c = asyncHttpClient(config)) {
+            ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));
+            Response res = null;
+            res = response.get();
+            assertNotNull(res.getResponseBody());
+            assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
+        }
     }
-  }
 
-  @SuppressWarnings("serial")
-  class MockRedirectHttpServlet extends HttpServlet {
-    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
-      res.sendRedirect("/overthere");
+    @SuppressWarnings("serial")
+    class MockRedirectHttpServlet extends HttpServlet {
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+            res.sendRedirect("/overthere");
+        }
     }
-  }
 
-  @SuppressWarnings("serial")
-  class MockFullResponseHttpServlet extends HttpServlet {
+    @SuppressWarnings("serial")
+    class MockFullResponseHttpServlet extends HttpServlet {
 
-    private static final String contentType = "text/xml";
-    private static final String xml = "<?xml version=\"1.0\"?><hello date=\"%s\"></hello>";
+        private static final String contentType = "text/xml";
+        private static final String xml = "<?xml version=\"1.0\"?><hello date=\"%s\"></hello>";
 
-    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
-      String xmlToReturn = String.format(xml, new Date().toString());
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+            String xmlToReturn = String.format(xml, new Object[] { new Date().toString() });
 
-      res.setStatus(200);
-      res.addHeader("Content-Type", contentType);
-      res.addHeader("X-Method", req.getMethod());
-      res.addHeader("MultiValue", "1");
-      res.addHeader("MultiValue", "2");
-      res.addHeader("MultiValue", "3");
+            res.setStatus(200);
+            res.addHeader("Content-Type", contentType);
+            res.addHeader("X-Method", req.getMethod());
+            res.addHeader("MultiValue", "1");
+            res.addHeader("MultiValue", "2");
+            res.addHeader("MultiValue", "3");
 
-      OutputStream os = res.getOutputStream();
+            OutputStream os = res.getOutputStream();
 
-      byte[] retVal = xmlToReturn.getBytes();
-      res.setContentLength(retVal.length);
-      os.write(retVal);
-      os.close();
+            byte[] retVal = xmlToReturn.getBytes();
+            res.setContentLength(retVal.length);
+            os.write(retVal);
+            os.close();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index af141a158..d978be2a5 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -15,17 +15,10 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.uri.Uri;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.URI;
@@ -33,136 +26,143 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.uri.Uri;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 public class Relative302Test extends AbstractBasicTest {
-  private final AtomicBoolean isSet = new AtomicBoolean(false);
-
-  private static int getPort(Uri uri) {
-    int port = uri.getPort();
-    if (port == -1)
-      port = uri.getScheme().equals("http") ? 80 : 443;
-    return port;
-  }
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(new Relative302Handler());
-    server.start();
-    port1 = connector.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-    port2 = findFreePort();
-  }
-
-  @Test(groups = "online")
-  public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
-    redirected302Test();
-    redirected302InvalidTest();
-    absolutePathRedirectTest();
-    relativePathRedirectTest();
-  }
-
-  @Test(groups = "online", enabled = false)
-  public void redirected302Test() throws Exception {
-    isSet.getAndSet(false);
-
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-
-      String baseUrl = getBaseUrl(response.getUri());
-      assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
+    private final AtomicBoolean isSet = new AtomicBoolean(false);
+
+    private class Relative302Handler extends AbstractHandler {
+
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            String param;
+            httpResponse.setStatus(200);
+            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+
+                if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
+                    httpResponse.addHeader("Location", httpRequest.getHeader(param));
+                    httpResponse.setStatus(302);
+                    break;
+                }
+            }
+            httpResponse.setContentLength(0);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void redirected302InvalidTest() throws Exception {
-    isSet.getAndSet(false);
 
-    Exception e = null;
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(new Relative302Handler());
+        server.start();
+        port1 = connector.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
+    }
 
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-    } catch (ExecutionException ex) {
-      e = ex;
+    @Test(groups = "online")
+    public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
+        redirected302Test();
+        redirected302InvalidTest();
+        absolutePathRedirectTest();
+        relativePathRedirectTest();
     }
 
-    assertNotNull(e);
-    Throwable cause = e.getCause();
-    assertTrue(cause instanceof ConnectException);
-    assertTrue(cause.getMessage().contains(":" + port2));
-  }
+    // @Test(groups = "online")
+    public void redirected302Test() throws Exception {
+        isSet.getAndSet(false);
 
-  @Test(enabled = false)
-  public void absolutePathRedirectTest() throws Exception {
-    isSet.getAndSet(false);
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
 
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      String redirectTarget = "/bar/test";
-      String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
+            String baseUrl = getBaseUrl(response.getUri());
+            assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
+        }
+    }
 
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getUri().toString(), destinationUrl);
+//     @Test(groups = "standalone")
+    public void redirected302InvalidTest() throws Exception {
+        isSet.getAndSet(false);
+        
+        Exception e = null;
 
-      logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+        } catch (ExecutionException ex) {
+            e = ex;
+        }
+        
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
     }
-  }
 
-  @Test(enabled = false)
-  public void relativePathRedirectTest() throws Exception {
-    isSet.getAndSet(false);
+    // @Test(groups = "standalone")
+    public void absolutePathRedirectTest() throws Exception {
+        isSet.getAndSet(false);
 
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      String redirectTarget = "bar/test1";
-      String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            String redirectTarget = "/bar/test";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-      Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getUri().toString(), destinationUrl);
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
 
-      logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-    }
-  }
-
-  private String getBaseUrl(Uri uri) {
-    String url = uri.toString();
-    int port = uri.getPort();
-    if (port == -1) {
-      port = getPort(uri);
-      url = url.substring(0, url.length() - 1) + ":" + port;
+            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        }
     }
-    return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
-  }
 
-  private class Relative302Handler extends AbstractHandler {
+    // @Test(groups = "standalone")
+    public void relativePathRedirectTest() throws Exception {
+        isSet.getAndSet(false);
 
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            String redirectTarget = "bar/test1";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-      String param;
-      httpResponse.setStatus(200);
-      httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
 
-        if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
-          httpResponse.addHeader("Location", httpRequest.getHeader(param));
-          httpResponse.setStatus(302);
-          break;
+            logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
         }
-      }
-      httpResponse.setContentLength(0);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
     }
-  }
+
+    private String getBaseUrl(Uri uri) {
+        String url = uri.toString();
+        int port = uri.getPort();
+        if (port == -1) {
+            port = getPort(uri);
+            url = url.substring(0, url.length() - 1) + ":" + port;
+        }
+        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
+    }
+
+    private static int getPort(Uri uri) {
+        int port = uri.getPort();
+        if (port == -1)
+            port = uri.getScheme().equals("http") ? 80 : 443;
+        return port;
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
new file mode 100644
index 000000000..60f369d55
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * This program is licensed to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.cookie.Cookie;
+import io.netty.handler.codec.http.cookie.DefaultCookie;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.io.IOUtils;
+import org.testng.annotations.Test;
+
+/**
+ * Unit tests for remote site. <br>
+ * see http://github.com/MSch/ning-async-http-client-bug/tree/master
+ * 
+ * @author Martin Schurrer
+ */
+public class RemoteSiteTest extends AbstractBasicTest {
+
+    public static final String URL = "http://google.com?q=";
+    public static final String REQUEST_PARAM = "github github \n" + "github";
+
+    @Test(groups = "online")
+    public void testGoogleCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testWwwMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testUpdateMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void testGoogleComWithTimeout() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncStatusHEADContentLenghtTest() throws Exception {
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true))) {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            p.executeRequest(head("http://www.google.com/"), new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        return response;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            }).get();
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void invalidStreamTest2() throws Exception {
+        AsyncHttpClientConfig config = config()//
+                .setRequestTimeout(10000)//
+                .setFollowRedirect(true)//
+                .setKeepAlive(false)//
+                .setMaxRedirects(6)//
+                .build();
+
+        try (AsyncHttpClient c = asyncHttpClient(config)) {
+            Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
+            if (response != null) {
+                System.out.println(response);
+            }
+        } catch (Throwable t) {
+            t.printStackTrace();
+            assertNotNull(t.getCause());
+            assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncFullBodyProperlyRead() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Response r = client.prepareGet("http://www.typesafe.com/").execute().get();
+
+            InputStream stream = r.getResponseBodyAsStream();
+            int contentLength = Integer.valueOf(r.getHeader(CONTENT_LENGTH));
+
+            assertEquals(contentLength, IOUtils.toByteArray(stream).length);
+        }
+    }
+
+    // FIXME Get a 302 in France...
+    @Test(groups = "online", enabled = false)
+    public void testUrlRequestParametersEncoding() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
+            logger.info(String.format("Executing request [%s] ...", requestUrl2));
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void stripQueryStringTest() throws Exception {
+
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online")
+    public void evilCookieTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Cookie cookie = new DefaultCookie("evilcookie", "test");
+            cookie.setDomain(".google.com");
+            cookie.setPath("/");
+
+            RequestBuilder builder = get("http://localhost")//
+                    .setFollowRedirect(true)//
+                    .setUrl("http://www.google.com/")//
+                    .addHeader("Content-Type", "text/plain")//
+                    .addCookie(cookie);
+
+            Response response = c.executeRequest(builder.build()).get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void testAHC62Com() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    builder.accumulate(bodyPart);
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return State.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getResponseBody().length() >= 3870);
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
index 8ffb9494f..051867bdc 100644
--- a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
+++ b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
@@ -15,163 +15,165 @@
  */
 package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Collections.singletonList;
+import static org.asynchttpclient.Dsl.get;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.codec.http.cookie.DefaultCookie;
-import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.util.*;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Collections.singletonList;
-import static org.asynchttpclient.Dsl.get;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
+import org.testng.annotations.Test;
 
 public class RequestBuilderTest {
 
-  private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_*.";
-  private final static String HEX_CHARS = "0123456789ABCDEF";
-
-  @Test
-  public void testEncodesQueryParameters() {
-    String[] values = new String[]{"abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKQLMNOPQRSTUVWXYZ", "1234567890", "1234567890", "`~!@#$%^&*()", "`~!@#$%^&*()", "_+-=,.<>/?",
-            "_+-=,.<>/?", ";:'\"[]{}\\| ", ";:'\"[]{}\\| "};
-
-    /*
-     * as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
-     * encode everything except for "safe" characters; and nothing but them.
-     * Safe includes ascii letters (upper and lower case), digits (0 - 9)
-     * and FOUR special characters: hyphen ('-'), underscore ('_'), tilde
-     * ('~') and period ('.')). Everything else must be percent-encoded,
-     * byte-by-byte, using UTF-8 encoding (meaning three-byte Unicode/UTF-8
-     * code points are encoded as three three-letter percent-encode
-     * entities).
-     */
-    for (String value : values) {
-      RequestBuilder builder = get("http://example.com/").addQueryParam("name", value);
-
-      StringBuilder sb = new StringBuilder();
-      for (int i = 0, len = value.length(); i < len; ++i) {
-        char c = value.charAt(i);
-        if (SAFE_CHARS.indexOf(c) >= 0) {
-          sb.append(c);
-        } else {
-          int hi = (c >> 4);
-          int lo = c & 0xF;
-          sb.append('%').append(HEX_CHARS.charAt(hi)).append(HEX_CHARS.charAt(lo));
+    private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_*.";
+    private final static String HEX_CHARS = "0123456789ABCDEF";
+
+    @Test(groups = "standalone")
+    public void testEncodesQueryParameters() throws UnsupportedEncodingException {
+        String[] values = new String[] { "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKQLMNOPQRSTUVWXYZ", "1234567890", "1234567890", "`~!@#$%^&*()", "`~!@#$%^&*()", "_+-=,.<>/?",
+                "_+-=,.<>/?", ";:'\"[]{}\\| ", ";:'\"[]{}\\| " };
+
+        /*
+         * as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
+         * encode everything except for "safe" characters; and nothing but them.
+         * Safe includes ascii letters (upper and lower case), digits (0 - 9)
+         * and FOUR special characters: hyphen ('-'), underscore ('_'), tilde
+         * ('~') and period ('.')). Everything else must be percent-encoded,
+         * byte-by-byte, using UTF-8 encoding (meaning three-byte Unicode/UTF-8
+         * code points are encoded as three three-letter percent-encode
+         * entities).
+         */
+        for (String value : values) {
+            RequestBuilder builder = get("http://example.com/").addQueryParam("name", value);
+
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0, len = value.length(); i < len; ++i) {
+                char c = value.charAt(i);
+                if (SAFE_CHARS.indexOf(c) >= 0) {
+                    sb.append(c);
+                } else {
+                    int hi = (c >> 4);
+                    int lo = c & 0xF;
+                    sb.append('%').append(HEX_CHARS.charAt(hi)).append(HEX_CHARS.charAt(lo));
+                }
+            }
+            String expValue = sb.toString();
+            Request request = builder.build();
+            assertEquals(request.getUrl(), "http://example.com/?name=" + expValue);
         }
-      }
-      String expValue = sb.toString();
-      Request request = builder.build();
-      assertEquals(request.getUrl(), "http://example.com/?name=" + expValue);
     }
-  }
-
-  @Test
-  public void testChaining() {
-    Request request = get("http://foo.com").addQueryParam("x", "value").build();
-
-    Request request2 = new RequestBuilder(request).build();
-
-    assertEquals(request2.getUri(), request.getUri());
-  }
-
-  @Test
-  public void testParsesQueryParams() {
-    Request request = get("http://foo.com/?param1=value1").addQueryParam("param2", "value2").build();
-
-    assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
-    List<Param> params = request.getQueryParams();
-    assertEquals(params.size(), 2);
-    assertEquals(params.get(0), new Param("param1", "value1"));
-    assertEquals(params.get(1), new Param("param2", "value2"));
-  }
-
-  @Test
-  public void testUserProvidedRequestMethod() {
-    Request req = new RequestBuilder("ABC").setUrl("http://foo.com").build();
-    assertEquals(req.getMethod(), "ABC");
-    assertEquals(req.getUrl(), "http://foo.com");
-  }
-
-  @Test
-  public void testPercentageEncodedUserInfo() {
-    final Request req = get("http://hello:wor%20ld@foo.com").build();
-    assertEquals(req.getMethod(), "GET");
-    assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
-  }
-
-  @Test
-  public void testContentTypeCharsetToBodyEncoding() {
-    final Request req = get("http://localhost").setHeader("Content-Type", "application/json; charset=utf-8").build();
-    assertEquals(req.getCharset(), UTF_8);
-    final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
-    assertEquals(req2.getCharset(), UTF_8);
-  }
-
-  @Test
-  public void testDefaultMethod() {
-    RequestBuilder requestBuilder = new RequestBuilder();
-    String defaultMethodName = HttpMethod.GET.name();
-    assertEquals(requestBuilder.method, defaultMethodName, "Default HTTP method should be " + defaultMethodName);
-  }
-
-  @Test
-  public void testSetHeaders() {
-    RequestBuilder requestBuilder = new RequestBuilder();
-    assertTrue(requestBuilder.headers.isEmpty(), "Headers should be empty by default.");
-
-    Map<CharSequence, Collection<?>> headers = new HashMap<>();
-    headers.put("Content-Type", Collections.singleton("application/json"));
-    requestBuilder.setHeaders(headers);
-    assertTrue(requestBuilder.headers.contains("Content-Type"), "headers set by setHeaders have not been set");
-    assertEquals(requestBuilder.headers.get("Content-Type"), "application/json", "header value incorrect");
-  }
-
-  @Test
-  public void testAddOrReplaceCookies() {
-    RequestBuilder requestBuilder = new RequestBuilder();
-    Cookie cookie = new DefaultCookie("name", "value");
-    cookie.setDomain("google.com");
-    cookie.setPath("/");
-    cookie.setMaxAge(1000);
-    cookie.setSecure(true);
-    cookie.setHttpOnly(true);
-    requestBuilder.addOrReplaceCookie(cookie);
-    assertEquals(requestBuilder.cookies.size(), 1, "cookies size should be 1 after adding one cookie");
-    assertEquals(requestBuilder.cookies.get(0), cookie, "cookie does not match");
-
-    Cookie cookie2 = new DefaultCookie("name", "value");
-    cookie2.setDomain("google2.com");
-    cookie2.setPath("/path");
-    cookie2.setMaxAge(1001);
-    cookie2.setSecure(false);
-    cookie2.setHttpOnly(false);
-
-    requestBuilder.addOrReplaceCookie(cookie2);
-    assertEquals(requestBuilder.cookies.size(), 1, "cookies size should remain 1 as we just replaced a cookie with same name");
-    assertEquals(requestBuilder.cookies.get(0), cookie2, "cookie does not match");
-
-    Cookie cookie3 = new DefaultCookie("name2", "value");
-    cookie3.setDomain("google.com");
-    cookie3.setPath("/");
-    cookie3.setMaxAge(1000);
-    cookie3.setSecure(true);
-    cookie3.setHttpOnly(true);
-    requestBuilder.addOrReplaceCookie(cookie3);
-    assertEquals(requestBuilder.cookies.size(), 2, "cookie size must be 2 after adding 1 more cookie i.e. cookie3");
-  }
-
-  @Test
-  public void testSettingQueryParamsBeforeUrlShouldNotProduceNPE() {
-    RequestBuilder requestBuilder = new RequestBuilder();
-    requestBuilder.setQueryParams(singletonList(new Param("key", "value")));
-    requestBuilder.setUrl("http://localhost");
-    Request request = requestBuilder.build();
-    assertEquals(request.getUrl(), "http://localhost?key=value");
-  }
+
+    @Test(groups = "standalone")
+    public void testChaining() throws IOException, ExecutionException, InterruptedException {
+        Request request = get("http://foo.com").addQueryParam("x", "value").build();
+
+        Request request2 = new RequestBuilder(request).build();
+
+        assertEquals(request2.getUri(), request.getUri());
+    }
+
+    @Test(groups = "standalone")
+    public void testParsesQueryParams() throws IOException, ExecutionException, InterruptedException {
+        Request request = get("http://foo.com/?param1=value1").addQueryParam("param2", "value2").build();
+
+        assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
+        List<Param> params = request.getQueryParams();
+        assertEquals(params.size(), 2);
+        assertEquals(params.get(0), new Param("param1", "value1"));
+        assertEquals(params.get(1), new Param("param2", "value2"));
+    }
+
+    @Test(groups = "standalone")
+    public void testUserProvidedRequestMethod() {
+        Request req = new RequestBuilder("ABC").setUrl("http://foo.com").build();
+        assertEquals(req.getMethod(), "ABC");
+        assertEquals(req.getUrl(), "http://foo.com");
+    }
+
+    @Test(groups = "standalone")
+    public void testPercentageEncodedUserInfo() {
+        final Request req = get("http://hello:wor%20ld@foo.com").build();
+        assertEquals(req.getMethod(), "GET");
+        assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
+    }
+
+    @Test(groups = "standalone")
+    public void testContentTypeCharsetToBodyEncoding() {
+        final Request req = get("http://localhost").setHeader("Content-Type", "application/json; charset=utf-8").build();
+        assertEquals(req.getCharset(), UTF_8);
+        final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
+        assertEquals(req2.getCharset(), UTF_8);
+    }
+    
+    @Test
+    public void testDefaultMethod() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        String defaultMethodName = HttpMethod.GET.name();
+        assertEquals(requestBuilder.method, defaultMethodName, "Default HTTP method should be " + defaultMethodName);
+    }
+
+    @Test
+    public void testSetHeaders() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        assertTrue(requestBuilder.headers.isEmpty(), "Headers should be empty by default.");
+
+        Map<CharSequence, Collection<?>> headers = new HashMap<>();
+        headers.put("Content-Type", Collections.singleton("application/json"));
+        requestBuilder.setHeaders(headers);
+        assertTrue(requestBuilder.headers.contains("Content-Type"), "headers set by setHeaders have not been set");
+        assertEquals(requestBuilder.headers.get("Content-Type"), "application/json", "header value incorrect");
+    }
+
+    public void testAddOrReplaceCookies() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        Cookie cookie = new DefaultCookie("name", "value");
+        cookie.setDomain("google.com");
+        cookie.setPath("/");
+        cookie.setMaxAge(1000);
+        cookie.setSecure(true);
+        cookie.setHttpOnly(true);
+        requestBuilder.addOrReplaceCookie(cookie);
+        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should be 1 after adding one cookie");
+        assertEquals(requestBuilder.cookies.get(0), cookie, "cookie does not match");
+
+        Cookie cookie2 = new DefaultCookie("name", "value");
+        cookie2.setDomain("google2.com");
+        cookie2.setPath("/path");
+        cookie2.setMaxAge(1001);
+        cookie2.setSecure(false);
+        cookie2.setHttpOnly(false);
+                
+        requestBuilder.addOrReplaceCookie(cookie2);
+        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should remain 1 as we just replaced a cookie with same name");
+        assertEquals(requestBuilder.cookies.get(0), cookie2, "cookie does not match");
+
+        Cookie cookie3 = new DefaultCookie("name", "value");
+        cookie3.setDomain("google.com");
+        cookie3.setPath("/");
+        cookie3.setMaxAge(1000);
+        cookie3.setSecure(true);
+        cookie3.setHttpOnly(true);
+        requestBuilder.addOrReplaceCookie(cookie3);
+        assertEquals(requestBuilder.cookies.size(), 2, "cookie size must be 2 after adding 1 more cookie i.e. cookie3");
+    }
+
+    @Test
+    public void testSettingQueryParamsBeforeUrlShouldNotProduceNPE() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        requestBuilder.setQueryParams(singletonList(new Param("key", "value")));
+        requestBuilder.setUrl("http://localhost");
+        Request request = requestBuilder.build();
+        assertEquals(request.getUrl(), "http://localhost?key=value");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
index e7fd6dbaf..826ee9b42 100644
--- a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
+++ b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -12,70 +12,69 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.exception.RemotelyClosedException;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.io.OutputStream;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+import org.asynchttpclient.exception.RemotelyClosedException;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class RetryRequestTest extends AbstractBasicTest {
-  protected String getTargetUrl() {
-    return String.format("http://localhost:%d/", port1);
-  }
+    public static class SlowAndBigHandler extends AbstractHandler {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new SlowAndBigHandler();
-  }
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-  @Test
-  public void testMaxRetry() {
-    try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
-      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
-      fail();
-    } catch (Exception t) {
-      assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
-    }
-  }
+            int load = 100;
+            httpResponse.setStatus(200);
+            httpResponse.setContentLength(load);
+            httpResponse.setContentType("application/octet-stream");
 
-  public static class SlowAndBigHandler extends AbstractHandler {
+            httpResponse.flushBuffer();
 
-    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+            OutputStream os = httpResponse.getOutputStream();
+            for (int i = 0; i < load; i++) {
+                os.write(i % 255);
 
-      int load = 100;
-      httpResponse.setStatus(200);
-      httpResponse.setContentLength(load);
-      httpResponse.setContentType("application/octet-stream");
+                try {
+                    Thread.sleep(300);
+                } catch (InterruptedException ex) {
+                    // nuku
+                }
 
-      httpResponse.flushBuffer();
+                if (i > load / 10) {
+                    httpResponse.sendError(500);
+                }
+            }
 
-      OutputStream os = httpResponse.getOutputStream();
-      for (int i = 0; i < load; i++) {
-        os.write(i % 255);
-
-        try {
-          Thread.sleep(300);
-        } catch (InterruptedException ex) {
-          // nuku
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
         }
+    }
 
-        if (i > load / 10) {
-          httpResponse.sendError(500);
-        }
-      }
+    protected String getTargetUrl() {
+        return String.format("http://localhost:%d/", port1);
+    }
 
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowAndBigHandler();
+    }
+
+    @Test(groups = "standalone")
+    public void testMaxRetry() throws Exception {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
+            fail();
+        } catch (Exception t) {
+            assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
index 453c882af..f3b68cd30 100644
--- a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
+++ b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -13,16 +13,15 @@
  */
 package org.asynchttpclient;
 
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
 
 import java.util.Arrays;
 import java.util.Random;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
 /**
  * Tests configured client name is used for thread names.
@@ -31,37 +30,37 @@
  */
 public class ThreadNameTest extends AbstractBasicTest {
 
-  private static Thread[] getThreads() {
-    int count = Thread.activeCount() + 1;
-    for (; ; ) {
-      Thread[] threads = new Thread[count];
-      int filled = Thread.enumerate(threads);
-      if (filled < threads.length) {
-        return Arrays.copyOf(threads, filled);
-      }
+    private static Thread[] getThreads() {
+        int count = Thread.activeCount() + 1;
+        for (;;) {
+            Thread[] threads = new Thread[count];
+            int filled = Thread.enumerate(threads);
+            if (filled < threads.length) {
+                return Arrays.copyOf(threads, filled);
+            }
 
-      count *= 2;
+            count *= 2;
+        }
     }
-  }
 
-  @Test
-  public void testThreadName() throws Exception {
-    String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
-    try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
-      Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
-      f.get(3, TimeUnit.SECONDS);
+    @Test(groups = "standalone")
+    public void testThreadName() throws Exception {
+        String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
+        try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
+            f.get(3, TimeUnit.SECONDS);
 
-      // We cannot assert that all threads are created with specified name,
-      // so we checking that at least one thread is.
-      boolean found = false;
-      for (Thread thread : getThreads()) {
-        if (thread.getName().startsWith(threadPoolName)) {
-          found = true;
-          break;
-        }
-      }
+            // We cannot assert that all threads are created with specified name,
+            // so we checking that at least one thread is.
+            boolean found = false;
+            for (Thread thread : getThreads()) {
+                if (thread.getName().startsWith(threadPoolName)) {
+                    found = true;
+                    break;
+                }
+            }
 
-      Assert.assertTrue(found, "must found threads starting with random string " + threadPoolName);
+            Assert.assertTrue(found, "must found threads starting with random string " + threadPoolName);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
index 4130fce8f..16f8990bc 100644
--- a/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
@@ -15,12 +15,9 @@
  */
 package org.asynchttpclient.channel;
 
-import org.asynchttpclient.*;
-import org.asynchttpclient.exception.TooManyConnectionsException;
-import org.asynchttpclient.test.EventCollectingHandler;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.EventCollectingHandler.*;
+import static org.testng.Assert.*;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,263 +30,266 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.EventCollectingHandler.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.test.EventCollectingHandler;
+import org.eclipse.jetty.server.ServerConnector;
+import org.testng.annotations.Test;
 
 public class ConnectionPoolTest extends AbstractBasicTest {
 
-  @Test
-  public void testMaxTotalConnections() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
-      String url = getTargetUrl();
-      int i;
-      Exception exception = null;
-      for (i = 0; i < 3; i++) {
-        try {
-          logger.info("{} requesting url [{}]...", i, url);
-          Response response = client.prepareGet(url).execute().get();
-          logger.info("{} response [{}].", i, response);
-        } catch (Exception ex) {
-          exception = ex;
+    @Test(groups = "standalone")
+    public void testMaxTotalConnections() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 3; i++) {
+                try {
+                    logger.info("{} requesting url [{}]...", i, url);
+                    Response response = client.prepareGet(url).execute().get();
+                    logger.info("{} response [{}].", i, response);
+                } catch (Exception ex) {
+                    exception = ex;
+                }
+            }
+            assertNull(exception);
         }
-      }
-      assertNull(exception);
     }
-  }
-
-  @Test(expectedExceptions = TooManyConnectionsException.class)
-  public void testMaxTotalConnectionsException() throws Throwable {
-    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
-      String url = getTargetUrl();
-
-      List<ListenableFuture<Response>> futures = new ArrayList<>();
-      for (int i = 0; i < 5; i++) {
-        logger.info("{} requesting url [{}]...", i, url);
-        futures.add(client.prepareGet(url).execute());
-      }
-
-      Exception exception = null;
-      for (ListenableFuture<Response> future : futures) {
-        try {
-          future.get();
-        } catch (Exception ex) {
-          exception = ex;
-          break;
-        }
-      }
 
-      assertNotNull(exception);
-      throw exception.getCause();
-    }
-  }
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void testMaxTotalConnectionsException() throws Throwable {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
+            String url = getTargetUrl();
 
-  @Test(invocationCount = 100)
-  public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
+            List<ListenableFuture<Response>> futures = new ArrayList<>();
+            for (int i = 0; i < 5; i++) {
+                logger.info("{} requesting url [{}]...", i, url);
+                futures.add(client.prepareGet(url).execute());
+            }
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      // Use a l in case the assert fail
-      final CountDownLatch l = new CountDownLatch(2);
+            Exception exception = null;
+            for (ListenableFuture<Response> future : futures) {
+                try {
+                    future.get();
+                } catch (Exception ex) {
+                    exception = ex;
+                    break;
+                }
+            }
 
-      final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<>();
+            assertNotNull(exception);
+            throw exception.getCause();
+        }
+    }
 
-      AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+    @Test(groups = "standalone", invocationCount = 100)
+    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
+
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
+
+            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<>();
+
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    logger.debug("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        super.onThrowable(t);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            };
+
+            client.prepareGet(getTargetUrl()).execute(handler).get();
+            server.stop();
+
+            // make sure connector will restart with the port as it's originally dynamically allocated
+            ServerConnector connector = (ServerConnector) server.getConnectors()[0];
+            connector.setPort(port1);
+
+            server.start();
+            client.prepareGet(getTargetUrl()).execute(handler);
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                fail("Timed out");
+            }
 
-        @Override
-        public Response onCompleted(Response response) {
-          logger.debug("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
-          try {
-            assertEquals(response.getStatusCode(), 200);
-            remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
-          } finally {
-            l.countDown();
-          }
-          return response;
+            assertEquals(remoteAddresses.size(), 2);
         }
+    }
 
-        @Override
-        public void onThrowable(Throwable t) {
-          try {
-            super.onThrowable(t);
-          } finally {
-            l.countDown();
-          }
-        }
-      };
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void multipleMaxConnectionOpenTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
+            String body = "hello there";
+
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-      client.prepareGet(getTargetUrl()).execute(handler).get();
-      server.stop();
+            assertEquals(response.getResponseBody(), body);
 
-      // Jetty 9.4.8 doesn't properly stop and restart (recreates ReservedThreadExecutors on start but still point to old offers threads to old ones)
-      // instead of restarting, we create a fresh new one and have it bind on the same port
-      server = new Server();
-      ServerConnector newConnector = addHttpConnector(server);
-      // make sure connector will restart with the port as it's originally dynamically allocated
-      newConnector.setPort(port1);
-      server.setHandler(configureHandler());
-      server.start();
+            // twice
+            Exception exception = null;
+            try {
+                c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                fail("Should throw exception. Too many connections issued.");
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            throw exception.getCause();
+        }
+    }
 
-      client.prepareGet(getTargetUrl()).execute(handler);
+    @Test(groups = "standalone")
+    public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
+            String body = "hello there";
 
-      if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-        fail("Timed out");
-      }
+            // once
+            Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-      assertEquals(remoteAddresses.size(), 2);
-    }
-  }
-
-  @Test(expectedExceptions = TooManyConnectionsException.class)
-  public void multipleMaxConnectionOpenTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
-      String body = "hello there";
-
-      // once
-      Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-      assertEquals(response.getResponseBody(), body);
-
-      // twice
-      Exception exception = null;
-      try {
-        c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        fail("Should throw exception. Too many connections issued.");
-      } catch (Exception ex) {
-        ex.printStackTrace();
-        exception = ex;
-      }
-      assertNotNull(exception);
-      throw exception.getCause();
-    }
-  }
-
-  @Test
-  public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
-      String body = "hello there";
-
-      // once
-      Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-      assertEquals(response.getResponseBody(), "foo_" + body);
-
-      // twice
-      Exception exception = null;
-      try {
-        response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-      } catch (Exception ex) {
-        ex.printStackTrace();
-        exception = ex;
-      }
-      assertNull(exception);
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), "foo_" + body);
+
+            // twice
+            Exception exception = null;
+            try {
+                response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
     }
-  }
-
-  /**
-   * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
-   *
-   * @throws Exception if something wrong happens.
-   */
-  @Test
-  public void win7DisconnectTest() throws Exception {
-    final AtomicInteger count = new AtomicInteger(0);
-
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-        @Override
-        public Response onCompleted(Response response) throws Exception {
-
-          count.incrementAndGet();
-          StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-          IOException t = new IOException();
-          t.setStackTrace(new StackTraceElement[]{e});
-          throw t;
+
+    /**
+     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
+     * 
+     * @throws Exception if something wrong happens.
+     */
+    @Test(groups = "standalone")
+    public void win7DisconnectTest() throws Exception {
+        final AtomicInteger count = new AtomicInteger(0);
+
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+
+                    count.incrementAndGet();
+                    StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
+                    IOException t = new IOException();
+                    t.setStackTrace(new StackTraceElement[] { e });
+                    throw t;
+                }
+            };
+
+            try {
+                client.prepareGet(getTargetUrl()).execute(handler).get();
+                fail("Must have received an exception");
+            } catch (ExecutionException ex) {
+                assertNotNull(ex);
+                assertNotNull(ex.getCause());
+                assertEquals(ex.getCause().getClass(), IOException.class);
+                assertEquals(count.get(), 1);
+            }
         }
-      };
-
-      try {
-        client.prepareGet(getTargetUrl()).execute(handler).get();
-        fail("Must have received an exception");
-      } catch (ExecutionException ex) {
-        assertNotNull(ex);
-        assertNotNull(ex.getCause());
-        assertEquals(ex.getCause().getClass(), IOException.class);
-        assertEquals(count.get(), 1);
-      }
     }
-  }
-
-  @Test
-  public void asyncHandlerOnThrowableTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final AtomicInteger count = new AtomicInteger();
-      final String THIS_IS_NOT_FOR_YOU = "This is not for you";
-      final CountDownLatch latch = new CountDownLatch(16);
-      for (int i = 0; i < 16; i++) {
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-          @Override
-          public Response onCompleted(Response response) throws Exception {
-            throw new Exception(THIS_IS_NOT_FOR_YOU);
-          }
-        });
-
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-          @Override
-          public void onThrowable(Throwable t) {
-            if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
-              count.incrementAndGet();
+
+    @Test(groups = "standalone")
+    public void asyncHandlerOnThrowableTest() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final AtomicInteger count = new AtomicInteger();
+            final String THIS_IS_NOT_FOR_YOU = "This is not for you";
+            final CountDownLatch latch = new CountDownLatch(16);
+            for (int i = 0; i < 16; i++) {
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw new Exception(THIS_IS_NOT_FOR_YOU);
+                    }
+                });
+
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
+                            count.incrementAndGet();
+                        }
+                    }
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        latch.countDown();
+                        return response;
+                    }
+                });
             }
-          }
-
-          @Override
-          public Response onCompleted(Response response) {
-            latch.countDown();
-            return response;
-          }
-        });
-      }
-      latch.await(TIMEOUT, TimeUnit.SECONDS);
-      assertEquals(count.get(), 0);
+            latch.await(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(count.get(), 0);
+        }
     }
-  }
 
-  @Test
-  public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
+    @Test(groups = "standalone")
+    public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
 
-    RequestBuilder request = get(getTargetUrl()).setHeader("Connection", "close");
+        RequestBuilder request = get(getTargetUrl()).setHeader("Connection", "close");
 
-    try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(6).setMaxConnectionsPerHost(3))) {
-      client.executeRequest(request).get();
-      Thread.sleep(1000);
-      client.executeRequest(request).get();
-      Thread.sleep(1000);
-      client.executeRequest(request).get();
-      Thread.sleep(1000);
-      client.executeRequest(request).get();
+        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(6).setMaxConnectionsPerHost(3))) {
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+        }
     }
-  }
 
-  @Test
-  public void testPooledEventsFired() throws Exception {
-    RequestBuilder request = get("http://localhost:" + port1 + "/Test");
+    @Test(groups = "standalone")
+    public void testPooledEventsFired() throws Exception {
+        RequestBuilder request = get("http://localhost:" + port1 + "/Test");
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      EventCollectingHandler firstHandler = new EventCollectingHandler();
-      client.executeRequest(request, firstHandler).get(3, TimeUnit.SECONDS);
-      firstHandler.waitForCompletion(3, TimeUnit.SECONDS);
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            EventCollectingHandler firstHandler = new EventCollectingHandler();
+            client.executeRequest(request, firstHandler).get(3, TimeUnit.SECONDS);
+            firstHandler.waitForCompletion(3, TimeUnit.SECONDS);
 
-      EventCollectingHandler secondHandler = new EventCollectingHandler();
-      client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
-      secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
+            EventCollectingHandler secondHandler = new EventCollectingHandler();
+            client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
+            secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
 
-      Object[] expectedEvents = new Object[]{CONNECTION_POOL_EVENT, CONNECTION_POOLED_EVENT, REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT,
-              HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT};
+            Object[] expectedEvents = new Object[] { CONNECTION_POOL_EVENT, CONNECTION_POOLED_EVENT, REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT,
+                    HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT };
 
-      assertEquals(secondHandler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
+            assertEquals(secondHandler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index 114115af3..34c8b152b 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -16,7 +16,25 @@
  */
 package org.asynchttpclient.channel;
 
-import org.asynchttpclient.*;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.servlet.ServletContextHandler;
@@ -26,146 +44,133 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
+public class MaxConnectionsInThreads extends AbstractBasicTest {
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
+    @Test(groups = "standalone")
+    public void testMaxConnectionsWithinThreads() throws Exception {
+
+        String[] urls = new String[] { getTargetUrl(), getTargetUrl() };
+
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(true)//
+                .setMaxConnections(1)//
+                .setMaxConnectionsPerHost(1)//
+                .build();
+
+        final CountDownLatch inThreadsLatch = new CountDownLatch(2);
+        final AtomicInteger failedCount = new AtomicInteger();
+
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            for (final String url : urls) {
+                Thread t = new Thread() {
+                    public void run() {
+                        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                Response r = super.onCompleted(response);
+                                inThreadsLatch.countDown();
+                                return r;
+                            }
+
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                super.onThrowable(t);
+                                failedCount.incrementAndGet();
+                                inThreadsLatch.countDown();
+                            }
+                        });
+                    }
+                };
+                t.start();
+            }
+
+            inThreadsLatch.await();
+
+            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from concurrent threads");
+
+            final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
+            failedCount.set(0);
+            for (final String url : urls) {
+                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        Response r = super.onCompleted(response);
+                        notInThreadsLatch.countDown();
+                        return r;
+                    }
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        super.onThrowable(t);
+                        failedCount.incrementAndGet();
+                        notInThreadsLatch.countDown();
+                    }
+                });
+            }
+
+            notInThreadsLatch.await();
+
+            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
+        }
+    }
 
-public class MaxConnectionsInThreads extends AbstractBasicTest {
+    @Override
+    @BeforeClass
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+        context.setContextPath("/");
+        server.setHandler(context);
+        context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
+
+        server.start();
+        port1 = connector.getLocalPort();
+    }
 
-  @Test
-  public void testMaxConnectionsWithinThreads() throws Exception {
-
-    String[] urls = new String[]{getTargetUrl(), getTargetUrl()};
-
-    AsyncHttpClientConfig config = config()
-            .setConnectTimeout(1000)
-            .setRequestTimeout(5000)
-            .setKeepAlive(true)
-            .setMaxConnections(1)
-            .setMaxConnectionsPerHost(1)
-            .build();
-
-    final CountDownLatch inThreadsLatch = new CountDownLatch(2);
-    final AtomicInteger failedCount = new AtomicInteger();
-
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      for (final String url : urls) {
-        Thread t = new Thread() {
-          public void run() {
-            client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-              @Override
-              public Response onCompleted(Response response) throws Exception {
-                Response r = super.onCompleted(response);
-                inThreadsLatch.countDown();
-                return r;
-              }
-
-              @Override
-              public void onThrowable(Throwable t) {
-                super.onThrowable(t);
-                failedCount.incrementAndGet();
-                inThreadsLatch.countDown();
-              }
-            });
-          }
-        };
-        t.start();
-      }
-
-      inThreadsLatch.await();
-
-      assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from concurrent threads");
-
-      final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
-      failedCount.set(0);
-      for (final String url : urls) {
-        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-          @Override
-          public Response onCompleted(Response response) throws Exception {
-            Response r = super.onCompleted(response);
-            notInThreadsLatch.countDown();
-            return r;
-          }
-
-          @Override
-          public void onThrowable(Throwable t) {
-            super.onThrowable(t);
-            failedCount.incrementAndGet();
-            notInThreadsLatch.countDown();
-          }
-        });
-      }
-
-      notInThreadsLatch.await();
-
-      assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
+    public String getTargetUrl() {
+        return "http://localhost:" + port1 + "/timeout/";
     }
-  }
-
-  @Override
-  @BeforeClass
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-    context.setContextPath("/");
-    server.setHandler(context);
-    context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
-
-    server.start();
-    port1 = connector.getLocalPort();
-  }
-
-  public String getTargetUrl() {
-    return "http://localhost:" + port1 + "/timeout/";
-  }
-
-  @SuppressWarnings("serial")
-  public static class MockTimeoutHttpServlet extends HttpServlet {
-    private static final Logger LOGGER = LoggerFactory.getLogger(MockTimeoutHttpServlet.class);
-    private static final String contentType = "text/plain";
-    static long DEFAULT_TIMEOUT = 2000;
-
-    public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
-      res.setStatus(200);
-      res.addHeader("Content-Type", contentType);
-      long sleepTime = DEFAULT_TIMEOUT;
-      try {
-        sleepTime = Integer.parseInt(req.getParameter("timeout"));
-
-      } catch (NumberFormatException e) {
-        sleepTime = DEFAULT_TIMEOUT;
-      }
-
-      try {
-        LOGGER.debug("=======================================");
-        LOGGER.debug("Servlet is sleeping for: " + sleepTime);
-        LOGGER.debug("=======================================");
-        Thread.sleep(sleepTime);
-        LOGGER.debug("=======================================");
-        LOGGER.debug("Servlet is awake for");
-        LOGGER.debug("=======================================");
-      } catch (Exception e) {
-        //
-      }
-
-      res.setHeader("XXX", "TripleX");
-
-      byte[] retVal = "1".getBytes();
-      OutputStream os = res.getOutputStream();
-
-      res.setContentLength(retVal.length);
-      os.write(retVal);
-      os.close();
+
+    @SuppressWarnings("serial")
+    public static class MockTimeoutHttpServlet extends HttpServlet {
+        private static final Logger LOGGER = LoggerFactory.getLogger(MockTimeoutHttpServlet.class);
+        private static final String contentType = "text/plain";
+        public static long DEFAULT_TIMEOUT = 2000;
+
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+            res.setStatus(200);
+            res.addHeader("Content-Type", contentType);
+            long sleepTime = DEFAULT_TIMEOUT;
+            try {
+                sleepTime = Integer.parseInt(req.getParameter("timeout"));
+
+            } catch (NumberFormatException e) {
+                sleepTime = DEFAULT_TIMEOUT;
+            }
+
+            try {
+                LOGGER.debug("=======================================");
+                LOGGER.debug("Servlet is sleeping for: " + sleepTime);
+                LOGGER.debug("=======================================");
+                Thread.sleep(sleepTime);
+                LOGGER.debug("=======================================");
+                LOGGER.debug("Servlet is awake for");
+                LOGGER.debug("=======================================");
+            } catch (Exception e) {
+
+            }
+
+            res.setHeader("XXX", "TripleX");
+
+            byte[] retVal = "1".getBytes();
+            OutputStream os = res.getOutputStream();
+
+            res.setContentLength(retVal.length);
+            os.write(retVal);
+            os.close();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 5992bf3ed..387d9caac 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -15,9 +15,8 @@
  */
 package org.asynchttpclient.channel;
 
-import org.asynchttpclient.*;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertNull;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -25,88 +24,93 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertNull;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
 public class MaxTotalConnectionTest extends AbstractBasicTest {
 
-  @Test(groups = "online")
-  public void testMaxTotalConnectionsExceedingException() throws IOException {
-    String[] urls = new String[]{"http://google.com", "http://github.com/"};
+    @Test(groups = "online")
+    public void testMaxTotalConnectionsExceedingException() throws IOException {
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
 
-    AsyncHttpClientConfig config = config()
-            .setConnectTimeout(1000)
-            .setRequestTimeout(5000)
-            .setKeepAlive(false)
-            .setMaxConnections(1)
-            .setMaxConnectionsPerHost(1)
-            .build();
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(false)//
+                .setMaxConnections(1)//
+                .setMaxConnectionsPerHost(1)//
+                .build();
 
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      List<ListenableFuture<Response>> futures = new ArrayList<>();
-      for (String url : urls) {
-        futures.add(client.prepareGet(url).execute());
-      }
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            List<ListenableFuture<Response>> futures = new ArrayList<>();
+            for (String url : urls) {
+                futures.add(client.prepareGet(url).execute());
+            }
 
-      boolean caughtError = false;
-      int i;
-      for (i = 0; i < urls.length; i++) {
-        try {
-          futures.get(i).get();
-        } catch (Exception e) {
-          // assert that 2nd request fails, because
-          // maxTotalConnections=1
-          caughtError = true;
-          break;
-        }
-      }
+            boolean caughtError = false;
+            int i;
+            for (i = 0; i < urls.length; i++) {
+                try {
+                    futures.get(i).get();
+                } catch (Exception e) {
+                    // assert that 2nd request fails, because
+                    // maxTotalConnections=1
+                    caughtError = true;
+                    break;
+                }
+            }
 
-      Assert.assertEquals(1, i);
-      Assert.assertTrue(caughtError);
+            Assert.assertEquals(1, i);
+            Assert.assertTrue(caughtError);
+        }
     }
-  }
 
-  @Test(groups = "online")
-  public void testMaxTotalConnections() throws Exception {
-    String[] urls = new String[]{"http://google.com", "http://gatling.io"};
+    @Test(groups = "online")
+    public void testMaxTotalConnections() throws Exception {
+        String[] urls = new String[] { "http://google.com", "http://gatling.io" };
 
-    final CountDownLatch latch = new CountDownLatch(2);
-    final AtomicReference<Throwable> ex = new AtomicReference<>();
-    final AtomicReference<String> failedUrl = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+        final AtomicReference<Throwable> ex = new AtomicReference<>();
+        final AtomicReference<String> failedUrl = new AtomicReference<>();
 
-    AsyncHttpClientConfig config = config()
-            .setConnectTimeout(1000)
-            .setRequestTimeout(5000)
-            .setKeepAlive(false)
-            .setMaxConnections(2)
-            .setMaxConnectionsPerHost(1)
-            .build();
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(false)//
+                .setMaxConnections(2)//
+                .setMaxConnectionsPerHost(1)//
+                .build();
 
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      for (String url : urls) {
-        final String thisUrl = url;
-        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
-          @Override
-          public Response onCompleted(Response response) throws Exception {
-            Response r = super.onCompleted(response);
-            latch.countDown();
-            return r;
-          }
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            for (String url : urls) {
+                final String thisUrl = url;
+                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        Response r = super.onCompleted(response);
+                        latch.countDown();
+                        return r;
+                    }
 
-          @Override
-          public void onThrowable(Throwable t) {
-            super.onThrowable(t);
-            ex.set(t);
-            failedUrl.set(thisUrl);
-            latch.countDown();
-          }
-        });
-      }
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        super.onThrowable(t);
+                        ex.set(t);
+                        failedUrl.set(thisUrl);
+                        latch.countDown();
+                    }
+                });
+            }
 
-      latch.await();
-      assertNull(ex.get());
-      assertNull(failedUrl.get());
+            latch.await();
+            assertNull(ex.get());
+            assertNull(failedUrl.get());
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
index 10b36507a..becf9d249 100644
--- a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
+++ b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -12,13 +12,9 @@
  */
 package org.asynchttpclient.filter;
 
-import org.asynchttpclient.*;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Enumeration;
@@ -27,153 +23,161 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class FilterTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new BasicHandler();
-  }
-
-  public String getTargetUrl() {
-    return String.format("http://localhost:%d/foo/test", port1);
-  }
-
-  @Test
-  public void basicTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(100)))) {
-      Response response = c.preparePost(getTargetUrl()).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-    }
-  }
-
-  @Test
-  public void loadThrottleTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(10)))) {
-      List<Future<Response>> futures = new ArrayList<>();
-      for (int i = 0; i < 200; i++) {
-        futures.add(c.preparePost(getTargetUrl()).execute());
-      }
-
-      for (Future<Response> f : futures) {
-        Response r = f.get();
-        assertNotNull(f.get());
-        assertEquals(r.getStatusCode(), 200);
-      }
-    }
-  }
-
-  @Test
-  public void maxConnectionsText() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(0, 1000)))) {
-      c.preparePost(getTargetUrl()).execute().get();
-      fail("Should have timed out");
-    } catch (ExecutionException ex) {
-      assertTrue(ex.getCause() instanceof FilterException);
+    private static class BasicHandler extends AbstractHandler {
+
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            String param;
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+                httpResponse.addHeader(param, httpRequest.getHeader(param));
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  @Test
-  public void basicResponseFilterTest() throws Exception {
-
-    ResponseFilter responseFilter = new ResponseFilter() {
-      @Override
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-      Response response = c.preparePost(getTargetUrl()).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new BasicHandler();
     }
-  }
 
-  @Test
-  public void replayResponseFilterTest() throws Exception {
+    public String getTargetUrl() {
+        return String.format("http://localhost:%d/foo/test", port1);
+    }
 
-    final AtomicBoolean replay = new AtomicBoolean(true);
-    ResponseFilter responseFilter = new ResponseFilter() {
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        if (replay.getAndSet(false)) {
-          Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
-          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+    @Test(groups = "standalone")
+    public void basicTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(100)))) {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
         }
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-      Response response = c.preparePost(getTargetUrl()).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("X-Replay"), "true");
     }
-  }
 
-  @Test
-  public void replayStatusCodeResponseFilterTest() throws Exception {
+    @Test(groups = "standalone")
+    public void loadThrottleTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(10)))) {
+            List<Future<Response>> futures = new ArrayList<>();
+            for (int i = 0; i < 200; i++) {
+                futures.add(c.preparePost(getTargetUrl()).execute());
+            }
+
+            for (Future<Response> f : futures) {
+                Response r = f.get();
+                assertNotNull(f.get());
+                assertEquals(r.getStatusCode(), 200);
+            }
+        }
+    }
 
-    final AtomicBoolean replay = new AtomicBoolean(true);
-    ResponseFilter responseFilter = new ResponseFilter() {
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        if (ctx.getResponseStatus() != null && ctx.getResponseStatus().getStatusCode() == 200 && replay.getAndSet(false)) {
-          Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
-          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+    @Test(groups = "standalone")
+    public void maxConnectionsText() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(0, 1000)))) {
+            c.preparePost(getTargetUrl()).execute().get();
+            fail("Should have timed out");
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof FilterException);
         }
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-      Response response = c.preparePost(getTargetUrl()).execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("X-Replay"), "true");
     }
-  }
 
-  @Test
-  public void replayHeaderResponseFilterTest() throws Exception {
+    @Test(groups = "standalone")
+    public void basicResponseFilterTest() throws Exception {
 
-    final AtomicBoolean replay = new AtomicBoolean(true);
-    ResponseFilter responseFilter = new ResponseFilter() {
-      public <T> FilterContext<T> filter(FilterContext<T> ctx) {
-        if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().get("Ping").equals("Pong") && replay.getAndSet(false)) {
-          Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
-          return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+        ResponseFilter responseFilter = new ResponseFilter() {
+            @Override
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
         }
-        return ctx;
-      }
-    };
-
-    try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
-      Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getHeader("Ping"), "Pong");
     }
-  }
-
-  private static class BasicHandler extends AbstractHandler {
 
-    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+    @Test(groups = "standalone")
+    public void replayResponseFilterTest() throws Exception {
+
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                if (replay.getAndSet(false)) {
+                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
+                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+                }
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-Replay"), "true");
+        }
+    }
 
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      String param;
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
-        httpResponse.addHeader(param, httpRequest.getHeader(param));
-      }
+    @Test(groups = "standalone")
+    public void replayStatusCodeResponseFilterTest() throws Exception {
+
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                if (ctx.getResponseStatus() != null && ctx.getResponseStatus().getStatusCode() == 200 && replay.getAndSet(false)) {
+                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
+                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+                }
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-Replay"), "true");
+        }
+    }
 
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    @Test(groups = "standalone")
+    public void replayHeaderResponseFilterTest() throws Exception {
+
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().get("Ping").equals("Pong") && replay.getAndSet(false)) {
+                    Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
+                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
+                }
+                return ctx;
+            }
+        };
+
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
+            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("Ping"), "Pong");
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index 58da3e2e8..9e91261b1 100644
--- a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -12,17 +12,13 @@
  */
 package org.asynchttpclient.handler;
 
-import org.apache.commons.io.IOUtils;
-import org.asynchttpclient.*;
-import org.asynchttpclient.exception.RemotelyClosedException;
-import org.asynchttpclient.handler.BodyDeferringAsyncHandler.BodyDeferringInputStream;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
+import static org.apache.commons.io.IOUtils.copy;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PipedInputStream;
@@ -32,232 +28,241 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
-import static org.apache.commons.io.IOUtils.copy;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.findFreePort;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.io.IOUtils;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.exception.RemotelyClosedException;
+import org.asynchttpclient.handler.BodyDeferringAsyncHandler.BodyDeferringInputStream;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class BodyDeferringAsyncHandlerTest extends AbstractBasicTest {
 
-  static final int CONTENT_LENGTH_VALUE = 100000;
-
-  public AbstractHandler configureHandler() throws Exception {
-    return new SlowAndBigHandler();
-  }
-
-  private AsyncHttpClientConfig getAsyncHttpClientConfig() {
-    // for this test brevity's sake, we are limiting to 1 retries
-    return config().setMaxRequestRetry(0).setRequestTimeout(10000).build();
-  }
-
-  @Test
-  public void deferredSimple() throws IOException, ExecutionException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl());
-
-      CountingOutputStream cos = new CountingOutputStream();
-      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-      Future<Response> f = r.execute(bdah);
-      Response resp = bdah.getResponse();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-      // we got headers only, it's probably not all yet here (we have BIG file
-      // downloading)
-      assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
-
-      // now be polite and wait for body arrival too (otherwise we would be
-      // dropping the "line" on server)
-      f.get();
-      // it all should be here now
-      assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
-    }
-  }
-
-  @Test(expectedExceptions = RemotelyClosedException.class)
-  public void deferredSimpleWithFailure() throws Throwable {
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-
-      CountingOutputStream cos = new CountingOutputStream();
-      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-      Future<Response> f = r.execute(bdah);
-      Response resp = bdah.getResponse();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-      // we got headers only, it's probably not all yet here (we have BIG file
-      // downloading)
-      assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
-
-      // now be polite and wait for body arrival too (otherwise we would be
-      // dropping the "line" on server)
-      try {
-        f.get();
-      } catch (ExecutionException e) {
-        // good
-        // it's incomplete, there was an error
-        assertNotEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
-        throw e.getCause();
-      }
-    }
-  }
-
-  @Test
-  public void deferredInputStreamTrick() throws IOException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl());
-
-      PipedOutputStream pos = new PipedOutputStream();
-      PipedInputStream pis = new PipedInputStream(pos);
-      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-      Future<Response> f = r.execute(bdah);
-
-      BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-      Response resp = is.getAsapResponse();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-      // "consume" the body, but our code needs input stream
-      CountingOutputStream cos = new CountingOutputStream();
-      try {
-        copy(is, cos);
-      } finally {
-        is.close();
-        cos.close();
-      }
-
-      // now we don't need to be polite, since consuming and closing
-      // BodyDeferringInputStream does all.
-      // it all should be here now
-      assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
-    }
-  }
-
-  @Test(expectedExceptions = RemotelyClosedException.class)
-  public void deferredInputStreamTrickWithFailure() throws Throwable {
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-      PipedOutputStream pos = new PipedOutputStream();
-      PipedInputStream pis = new PipedInputStream(pos);
-      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-      Future<Response> f = r.execute(bdah);
-
-      BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-      Response resp = is.getAsapResponse();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
-      // "consume" the body, but our code needs input stream
-      CountingOutputStream cos = new CountingOutputStream();
-      try {
-        try {
-          copy(is, cos);
-        } finally {
-          is.close();
-          cos.close();
-        }
-      } catch (IOException e) {
-        throw e.getCause();
-      }
-    }
-  }
-
-  @Test(expectedExceptions = IOException.class)
-  public void testConnectionRefused() throws IOException, InterruptedException {
-    int newPortWithoutAnyoneListening = findFreePort();
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
-
-      CountingOutputStream cos = new CountingOutputStream();
-      BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-      r.execute(bdah);
-      bdah.getResponse();
-    }
-  }
-
-  @Test
-  public void testPipedStreams() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-      PipedOutputStream pout = new PipedOutputStream();
-      try (PipedInputStream pin = new PipedInputStream(pout)) {
-        BodyDeferringAsyncHandler handler = new BodyDeferringAsyncHandler(pout);
-        ListenableFuture<Response> respFut = client.prepareGet(getTargetUrl()).execute(handler);
-
-        Response resp = handler.getResponse();
-
-        if (resp.getStatusCode() == 200) {
-          try (BodyDeferringInputStream is = new BodyDeferringInputStream(respFut, handler, pin)) {
-            String body = IOUtils.toString(is, StandardCharsets.UTF_8);
-            assertTrue(body.contains("ABCDEF"));
-          }
-        } else {
-          throw new IOException("HTTP error " + resp.getStatusCode());
+    protected static final int CONTENT_LENGTH_VALUE = 100000;
+
+    public static class SlowAndBigHandler extends AbstractHandler {
+
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            httpResponse.setStatus(200);
+            httpResponse.setContentLength(CONTENT_LENGTH_VALUE);
+            httpResponse.setContentType(APPLICATION_OCTET_STREAM.toString());
+
+            httpResponse.flushBuffer();
+
+            final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
+            final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
+
+            OutputStream os = httpResponse.getOutputStream();
+            for (int i = 0; i < CONTENT_LENGTH_VALUE; i++) {
+                os.write(i % 255);
+
+                if (wantSlow) {
+                    try {
+                        Thread.sleep(300);
+                    } catch (InterruptedException ex) {
+                        // nuku
+                    }
+                }
+
+                if (wantFailure) {
+                    if (i > CONTENT_LENGTH_VALUE / 2) {
+                        // kaboom
+                        // yes, response is committed, but Jetty does aborts and
+                        // drops connection
+                        httpResponse.sendError(500);
+                        break;
+                    }
+                }
+            }
+
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
         }
-      }
     }
-  }
 
-  public static class SlowAndBigHandler extends AbstractHandler {
+    // a /dev/null but counting how many bytes it ditched
+    public static class CountingOutputStream extends OutputStream {
+        private int byteCount = 0;
 
-    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+        @Override
+        public void write(int b) throws IOException {
+            // /dev/null
+            byteCount++;
+        }
 
-      httpResponse.setStatus(200);
-      httpResponse.setContentLength(CONTENT_LENGTH_VALUE);
-      httpResponse.setContentType(APPLICATION_OCTET_STREAM.toString());
+        public int getByteCount() {
+            return byteCount;
+        }
+    }
 
-      httpResponse.flushBuffer();
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowAndBigHandler();
+    }
 
-      final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
-      final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
+    public AsyncHttpClientConfig getAsyncHttpClientConfig() {
+        // for this test brevity's sake, we are limiting to 1 retries
+        return config().setMaxRequestRetry(0).setRequestTimeout(10000).build();
+    }
 
-      OutputStream os = httpResponse.getOutputStream();
-      for (int i = 0; i < CONTENT_LENGTH_VALUE; i++) {
-        os.write(i % 255);
+    @Test(groups = "standalone")
+    public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl());
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            f.get();
+            // it all should be here now
+            assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+        }
+    }
 
-        if (wantSlow) {
-          try {
-            Thread.sleep(300);
-          } catch (InterruptedException ex) {
-            // nuku
-          }
+    @Test(groups = "standalone", expectedExceptions = RemotelyClosedException.class)
+    public void deferredSimpleWithFailure() throws Throwable {
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertTrue(cos.getByteCount() <= CONTENT_LENGTH_VALUE);
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            try {
+                f.get();
+            } catch (ExecutionException e) {
+                // good
+                // it's incomplete, there was an error
+                assertNotEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
+                throw e.getCause();
+            }
         }
+    }
 
-        if (wantFailure) {
-          if (i > CONTENT_LENGTH_VALUE / 2) {
-            // kaboom
-            // yes, response is committed, but Jetty does aborts and
-            // drops connection
-            httpResponse.sendError(500);
-            break;
-          }
+    @Test(groups = "standalone")
+    public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl());
+
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+            Future<Response> f = r.execute(bdah);
+
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            try {
+                copy(is, cos);
+            } finally {
+                is.close();
+                cos.close();
+            }
+
+            // now we don't need to be polite, since consuming and closing
+            // BodyDeferringInputStream does all.
+            // it all should be here now
+            assertEquals(cos.getByteCount(), CONTENT_LENGTH_VALUE);
         }
-      }
+    }
 
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    @Test(groups = "standalone", expectedExceptions = RemotelyClosedException.class)
+    public void deferredInputStreamTrickWithFailure() throws Throwable {
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            BoundRequestBuilder r = client.prepareGet(getTargetUrl()).addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+            Future<Response> f = r.execute(bdah);
+
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader(CONTENT_LENGTH), String.valueOf(CONTENT_LENGTH_VALUE));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            try {
+                try {
+                    copy(is, cos);
+                } finally {
+                    is.close();
+                    cos.close();
+                }
+            } catch (IOException e) {
+                throw e.getCause();
+            }
+        }
     }
-  }
 
-  // a /dev/null but counting how many bytes it ditched
-  public static class CountingOutputStream extends OutputStream {
-    private int byteCount = 0;
+    @Test(groups = "standalone", expectedExceptions = IOException.class)
+    public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        int newPortWithoutAnyoneListening = findFreePort();
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
 
-    @Override
-    public void write(int b) {
-      // /dev/null
-      byteCount++;
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            r.execute(bdah);
+            bdah.getResponse();
+        }
     }
 
-    int getByteCount() {
-      return byteCount;
+    @Test(groups = "standalone")
+    public void testPipedStreams() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
+            PipedOutputStream pout = new PipedOutputStream();
+            try (PipedInputStream pin = new PipedInputStream(pout)) {
+                BodyDeferringAsyncHandler handler = new BodyDeferringAsyncHandler(pout);
+                ListenableFuture<Response> respFut = client.prepareGet(getTargetUrl()).execute(handler);
+
+                Response resp = handler.getResponse();
+
+                if (resp.getStatusCode() == 200) {
+                    try (BodyDeferringInputStream is = new BodyDeferringInputStream(respFut, handler, pin)) {
+                        String body = IOUtils.toString(is, StandardCharsets.UTF_8);
+                        assertTrue(body.contains("ABCDEF"));
+                    }
+                } else {
+                    throw new IOException("HTTP error " + resp.getStatusCode());
+                }
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
index 140159617..fdb120d88 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
@@ -24,27 +24,27 @@
 public class MapResumableProcessor
         implements ResumableProcessor {
 
-  private Map<String, Long> map = new HashMap<>();
+    Map<String, Long> map = new HashMap<>();
 
-  public void put(String key, long transferredBytes) {
-    map.put(key, transferredBytes);
-  }
+    public void put(String key, long transferredBytes) {
+        map.put(key, transferredBytes);
+    }
 
-  public void remove(String key) {
-    map.remove(key);
-  }
+    public void remove(String key) {
+        map.remove(key);
+    }
 
-  /**
-   * NOOP
-   */
-  public void save(Map<String, Long> map) {
+    /**
+     * NOOP
+     */
+    public void save(Map<String, Long> map) {
 
-  }
+    }
 
-  /**
-   * NOOP
-   */
-  public Map<String, Long> load() {
-    return map;
-  }
+    /**
+     * NOOP
+     */
+    public Map<String, Long> load() {
+        return map;
+    }
 }
\ No newline at end of file
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index 883a2bb97..9935a853e 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -1,51 +1,52 @@
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * This program is licensed to you under the Apache License Version 2.0, 
+ * and you may not use this file except in compliance with the Apache License Version 2.0. 
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * Unless required by applicable law or agreed to in writing, 
+ * software distributed under the Apache License Version 2.0 is distributed on an 
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.handler.resumable;
 
+import static org.testng.Assert.assertEquals;
+
+import org.asynchttpclient.handler.resumable.PropertiesBasedResumableProcessor;
 import org.testng.annotations.Test;
 
 import java.util.Map;
 
-import static org.testng.Assert.assertEquals;
-
 /**
  * @author Benjamin Hanzelmann
  */
 public class PropertiesBasedResumableProcesserTest {
-
-  @Test
-  public void testSaveLoad() {
-    PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
-    p.put("http://localhost/test.url", 15L);
-    p.put("http://localhost/test2.url", 50L);
-    p.save(null);
-    p = new PropertiesBasedResumableProcessor();
-    Map<String, Long> m = p.load();
-    assertEquals(m.size(), 2);
-    assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
-    assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
-  }
-
-  @Test
-  public void testRemove() {
-    PropertiesBasedResumableProcessor propertiesProcessor = new PropertiesBasedResumableProcessor();
-    propertiesProcessor.put("http://localhost/test.url", 15L);
-    propertiesProcessor.put("http://localhost/test2.url", 50L);
-    propertiesProcessor.remove("http://localhost/test.url");
-    propertiesProcessor.save(null);
-    propertiesProcessor = new PropertiesBasedResumableProcessor();
-    Map<String, Long> propertiesMap = propertiesProcessor.load();
-    assertEquals(propertiesMap.size(), 1);
-    assertEquals(propertiesMap.get("http://localhost/test2.url"), Long.valueOf(50L));
-  }
+    
+    @Test(groups = "standalone")
+    public void testSaveLoad() throws Exception {
+        PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
+        p.put("http://localhost/test.url", 15L);
+        p.put("http://localhost/test2.url", 50L);
+        p.save(null);
+        p = new PropertiesBasedResumableProcessor();
+        Map<String, Long> m = p.load();
+        assertEquals(m.size(), 2);
+        assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
+        assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
+    }
+    
+    @Test
+    public void testRemove() {
+        PropertiesBasedResumableProcessor propertiesProcessor = new PropertiesBasedResumableProcessor();
+        propertiesProcessor.put("http://localhost/test.url", 15L);
+        propertiesProcessor.put("http://localhost/test2.url", 50L);
+        propertiesProcessor.remove("http://localhost/test.url");
+        propertiesProcessor.save(null);
+        propertiesProcessor = new PropertiesBasedResumableProcessor();
+        Map<String, Long> propertiesMap = propertiesProcessor.load();
+        assertEquals(propertiesMap.size(), 1);
+        assertEquals(propertiesMap.get("http://localhost/test2.url"), Long.valueOf(50L));
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index 4fd77666a..ff762a72f 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -1,195 +1,195 @@
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * This program is licensed to you under the Apache License Version 2.0, 
+ * and you may not use this file except in compliance with the Apache License Version 2.0. 
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * Unless required by applicable law or agreed to in writing, 
+ * software distributed under the Apache License Version 2.0 is distributed on an 
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.handler.resumable;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.get;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Mockito.*;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.*;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.uri.Uri;
 import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.modules.testng.PowerMockTestCase;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderNames.RANGE;
-import static org.asynchttpclient.Dsl.get;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.powermock.api.mockito.PowerMockito.mock;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-
 /**
  * @author Benjamin Hanzelmann
  */
-@PrepareForTest({HttpResponseStatus.class, State.class})
+@PrepareForTest({ HttpResponseStatus.class, State.class })
 public class ResumableAsyncHandlerTest extends PowerMockTestCase {
-  @Test
-  public void testAdjustRange() {
-    MapResumableProcessor proc = new MapResumableProcessor();
-
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(proc);
-    Request request = get("http://test/url").build();
-    Request newRequest = handler.adjustRequestRange(request);
-    assertEquals(newRequest.getUri(), request.getUri());
-    String rangeHeader = newRequest.getHeaders().get(RANGE);
-    assertNull(rangeHeader);
-
-    proc.put("http://test/url", 5000);
-    newRequest = handler.adjustRequestRange(request);
-    assertEquals(newRequest.getUri(), request.getUri());
-    rangeHeader = newRequest.getHeaders().get(RANGE);
-    assertEquals(rangeHeader, "bytes=5000-");
-  }
-
-  @Test
-  public void testOnStatusReceivedOkStatus() throws Exception {
-    MapResumableProcessor processor = new MapResumableProcessor();
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-    HttpResponseStatus responseStatus200 = mock(HttpResponseStatus.class);
-    when(responseStatus200.getStatusCode()).thenReturn(200);
-    when(responseStatus200.getUri()).thenReturn(mock(Uri.class));
-    State state = handler.onStatusReceived(responseStatus200);
-    assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a OK response");
-  }
-
-  @Test
-  public void testOnStatusReceived206Status() throws Exception {
-    MapResumableProcessor processor = new MapResumableProcessor();
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-    HttpResponseStatus responseStatus206 = mock(HttpResponseStatus.class);
-    when(responseStatus206.getStatusCode()).thenReturn(206);
-    when(responseStatus206.getUri()).thenReturn(mock(Uri.class));
-    State state = handler.onStatusReceived(responseStatus206);
-    assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a 'Partial Content' response");
-  }
-
-  @Test
-  public void testOnStatusReceivedOkStatusWithDecoratedAsyncHandler() throws Exception {
-    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-    when(mockResponseStatus.getStatusCode()).thenReturn(200);
-    when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
-
-    @SuppressWarnings("unchecked")
-    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-    State mockState = mock(State.class);
-    when(decoratedAsyncHandler.onStatusReceived(mockResponseStatus)).thenReturn(mockState);
-
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-
-    State state = handler.onStatusReceived(mockResponseStatus);
-    verify(decoratedAsyncHandler).onStatusReceived(mockResponseStatus);
-    assertEquals(state, mockState, "State returned should be equal to the one returned from decoratedAsyncHandler");
-  }
-
-  @Test
-  public void testOnStatusReceived500Status() throws Exception {
-    MapResumableProcessor processor = new MapResumableProcessor();
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
-    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-    when(mockResponseStatus.getStatusCode()).thenReturn(500);
-    when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
-    State state = handler.onStatusReceived(mockResponseStatus);
-    assertEquals(state, AsyncHandler.State.ABORT, "State should be ABORT for Internal Server Error status");
-  }
-
-  @Test
-  public void testOnBodyPartReceived() throws Exception {
-    ResumableAsyncHandler handler = new ResumableAsyncHandler();
-    HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-    when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
-    ByteBuffer buffer = ByteBuffer.allocate(0);
-    when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
-    State state = handler.onBodyPartReceived(bodyPart);
-    assertEquals(state, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onBodyPartReceived");
-  }
-
-  @Test
-  public void testOnBodyPartReceivedWithResumableListenerThrowsException() throws Exception {
-    ResumableAsyncHandler handler = new ResumableAsyncHandler();
-
-    ResumableListener resumableListener = PowerMockito.mock(ResumableListener.class);
-    doThrow(new IOException()).when(resumableListener).onBytesReceived(anyObject());
-    handler.setResumableListener(resumableListener);
-
-    HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-    State state = handler.onBodyPartReceived(bodyPart);
-    assertEquals(state, AsyncHandler.State.ABORT,
-            "State should be ABORT if the resumableListener threw an exception in onBodyPartReceived");
-  }
-
-  @Test
-  public void testOnBodyPartReceivedWithDecoratedAsyncHandler() throws Exception {
-    HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
-    when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
-    ByteBuffer buffer = ByteBuffer.allocate(0);
-    when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
-
-    @SuppressWarnings("unchecked")
-    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-    State mockState = mock(State.class);
-    when(decoratedAsyncHandler.onBodyPartReceived(bodyPart)).thenReturn(mockState);
-
-    // following is needed to set the url variable
-    HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
-    when(mockResponseStatus.getStatusCode()).thenReturn(200);
-    Uri mockUri = mock(Uri.class);
-    when(mockUri.toUrl()).thenReturn("http://non.null");
-    when(mockResponseStatus.getUri()).thenReturn(mockUri);
-
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-    handler.onStatusReceived(mockResponseStatus);
-
-    State state = handler.onBodyPartReceived(bodyPart);
-    assertEquals(state, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
-
-  }
-
-  @Test
-  public void testOnHeadersReceived() throws Exception {
-    ResumableAsyncHandler handler = new ResumableAsyncHandler();
-    HttpHeaders responseHeaders = new DefaultHttpHeaders();
-    State status = handler.onHeadersReceived(responseHeaders);
-    assertEquals(status, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onHeadersReceived");
-  }
-
-  @Test
-  public void testOnHeadersReceivedWithDecoratedAsyncHandler() throws Exception {
-    HttpHeaders responseHeaders = new DefaultHttpHeaders();
-
-    @SuppressWarnings("unchecked")
-    AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
-    State mockState = mock(State.class);
-    when(decoratedAsyncHandler.onHeadersReceived(responseHeaders)).thenReturn(mockState);
-
-    ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
-    State status = handler.onHeadersReceived(responseHeaders);
-    assertEquals(status, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
-  }
-
-  @Test
-  public void testOnHeadersReceivedContentLengthMinus() throws Exception {
-    ResumableAsyncHandler handler = new ResumableAsyncHandler();
-    HttpHeaders responseHeaders = new DefaultHttpHeaders();
-    responseHeaders.add(CONTENT_LENGTH, -1);
-    State status = handler.onHeadersReceived(responseHeaders);
-    assertEquals(status, AsyncHandler.State.ABORT, "State should be ABORT for content length -1");
-  }
+    @Test
+    public void testAdjustRange() {
+        MapResumableProcessor proc = new MapResumableProcessor();
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(proc);
+        Request request = get("http://test/url").build();
+        Request newRequest = handler.adjustRequestRange(request);
+        assertEquals(newRequest.getUri(), request.getUri());
+        String rangeHeader = newRequest.getHeaders().get(RANGE);
+        assertNull(rangeHeader);
+
+        proc.put("http://test/url", 5000);
+        newRequest = handler.adjustRequestRange(request);
+        assertEquals(newRequest.getUri(), request.getUri());
+        rangeHeader = newRequest.getHeaders().get(RANGE);
+        assertEquals(rangeHeader, "bytes=5000-");
+    }
+
+    @Test
+    public void testOnStatusReceivedOkStatus() throws Exception {
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus responseStatus200 = mock(HttpResponseStatus.class);
+        when(responseStatus200.getStatusCode()).thenReturn(200);
+        when(responseStatus200.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(responseStatus200);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a OK response");
+    }
+    
+    @Test
+    public void testOnStatusReceived206Status() throws Exception {
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus responseStatus206 = mock(HttpResponseStatus.class);
+        when(responseStatus206.getStatusCode()).thenReturn(206);
+        when(responseStatus206.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(responseStatus206);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a 'Partial Content' response");
+    }
+    
+    @Test
+    public void testOnStatusReceivedOkStatusWithDecoratedAsyncHandler() throws Exception {
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(200);
+        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onStatusReceived(mockResponseStatus)).thenReturn(mockState);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+
+        State state = handler.onStatusReceived(mockResponseStatus);
+        verify(decoratedAsyncHandler).onStatusReceived(mockResponseStatus);
+        assertEquals(state, mockState, "State returned should be equal to the one returned from decoratedAsyncHandler");
+    }
+    
+    @Test
+    public void testOnStatusReceived500Status() throws Exception{
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(500);
+        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(mockResponseStatus);
+        assertEquals(state, AsyncHandler.State.ABORT, "State should be ABORT for Internal Server Error status");
+    }
+    
+    @Test
+    public void testOnBodyPartReceived() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+        ByteBuffer buffer = ByteBuffer.allocate(0);
+        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onBodyPartReceived");
+    }
+    
+    @Test
+    public void testOnBodyPartReceivedWithResumableListenerThrowsException() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+
+        ResumableListener resumableListener = PowerMockito.mock(ResumableListener.class);
+        doThrow(new IOException()).when(resumableListener).onBytesReceived(anyObject());
+        handler.setResumableListener(resumableListener);
+
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, AsyncHandler.State.ABORT,
+                "State should be ABORT if the resumableListener threw an exception in onBodyPartReceived");
+    }
+    
+    @Test
+    public void testOnBodyPartReceivedWithDecoratedAsyncHandler() throws Exception {
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+        ByteBuffer buffer = ByteBuffer.allocate(0);
+        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onBodyPartReceived(bodyPart)).thenReturn(mockState);
+
+        // following is needed to set the url variable
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(200);
+        Uri mockUri = mock(Uri.class);
+        when(mockUri.toUrl()).thenReturn("http://non.null");
+        when(mockResponseStatus.getUri()).thenReturn(mockUri);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+        handler.onStatusReceived(mockResponseStatus);
+
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
+
+    }
+    
+    @Test
+    public void testOnHeadersReceived() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+        State status = handler.onHeadersReceived(responseHeaders);
+        assertEquals(status, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onHeadersReceived");
+    }
+    
+    @Test
+    public void testOnHeadersReceivedWithDecoratedAsyncHandler() throws Exception {
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onHeadersReceived(responseHeaders)).thenReturn(mockState);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+        State status = handler.onHeadersReceived(responseHeaders);
+        assertEquals(status, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
+    }
+    
+    @Test
+    public void testOnHeadersReceivedContentLengthMinus() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+        responseHeaders.add(CONTENT_LENGTH, -1);
+        State status = handler.onHeadersReceived(responseHeaders);
+        assertEquals(status, AsyncHandler.State.ABORT, "State should be ABORT for content length -1");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
index cb0ebec28..663143371 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
@@ -13,38 +13,38 @@
  */
 package org.asynchttpclient.handler.resumable;
 
-import org.powermock.api.mockito.PowerMockito;
-import org.testng.annotations.Test;
+import static org.mockito.Mockito.*;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
-import static org.mockito.Mockito.verify;
+import org.powermock.api.mockito.PowerMockito;
+import org.testng.annotations.Test;
 
 public class ResumableRandomAccessFileListenerTest {
 
-  @Test
-  public void testOnBytesReceivedBufferHasArray() throws IOException {
-    RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
-    ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
-    byte[] array = new byte[]{1, 2, 23, 33};
-    ByteBuffer buf = ByteBuffer.wrap(array);
-    listener.onBytesReceived(buf);
-    verify(file).write(array, 0, 4);
-  }
-
-  @Test
-  public void testOnBytesReceivedBufferHasNoArray() throws IOException {
-    RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
-    ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
-
-    byte[] byteArray = new byte[]{1, 2, 23, 33};
-    ByteBuffer buf = ByteBuffer.allocateDirect(4);
-    buf.put(byteArray);
-    buf.flip();
-    listener.onBytesReceived(buf);
-    verify(file).write(byteArray);
-  }
+    @Test
+    public void testOnBytesReceivedBufferHasArray() throws IOException {
+        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
+        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+        byte[] array = new byte[] { 1, 2, 23, 33 };
+        ByteBuffer buf = ByteBuffer.wrap(array);
+        listener.onBytesReceived(buf);
+        verify(file).write(array, 0, 4);
+    }
+
+    @Test
+    public void testOnBytesReceivedBufferHasNoArray() throws IOException {
+        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
+        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+
+        byte[] byteArray = new byte[] { 1, 2, 23, 33 };
+        ByteBuffer buf = ByteBuffer.allocateDirect(4);
+        buf.put(byteArray);
+        buf.flip();
+        listener.onBytesReceived(buf);
+        verify(file).write(byteArray);
+    }
 
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
index 8a3c6e43f..ac51e2a23 100644
--- a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
@@ -12,63 +12,64 @@
  */
 package org.asynchttpclient.netty;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.HttpMessage;
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-import java.util.function.Consumer;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.testng.annotations.Test;
 
 public class EventPipelineTest extends AbstractBasicTest {
 
-  @Test
-  public void asyncPipelineTest() throws Exception {
+    @Test(groups = "standalone")
+    public void asyncPipelineTest() throws Exception {
 
-    Consumer<Channel> httpAdditionalPipelineInitializer = channel -> channel.pipeline().addBefore("inflater",
-            "copyEncodingHeader", new CopyEncodingHandler());
+        AsyncHttpClientConfig.AdditionalChannelInitializer httpAdditionalPipelineInitializer = new AsyncHttpClientConfig.AdditionalChannelInitializer() {
+            public void initChannel(Channel channel) throws Exception {
+                channel.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+            }
+        };
 
-    try (AsyncHttpClient p = asyncHttpClient(
-            config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
-      final CountDownLatch l = new CountDownLatch(1);
-      p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-        @Override
-        public Response onCompleted(Response response) {
-          try {
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
-          } finally {
-            l.countDown();
-          }
-          return response;
+        try (AsyncHttpClient p = asyncHttpClient(config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
+            final CountDownLatch l = new CountDownLatch(1);
+            p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
         }
-      }).get();
-      if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-        fail("Timeout out");
-      }
     }
-  }
 
-  private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
-    @Override
-    public void channelRead(ChannelHandlerContext ctx, Object e) {
-      if (e instanceof HttpMessage) {
-        HttpMessage m = (HttpMessage) e;
-        // for test there is no Content-Encoding header so just hard
-        // coding value
-        // for verification
-        m.headers().set("X-Original-Content-Encoding", "<original encoding>");
-      }
-      ctx.fireChannelRead(e);
+    private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object e) {
+            if (e instanceof HttpMessage) {
+                HttpMessage m = (HttpMessage) e;
+                // for test there is no Content-Encoding header so just hard
+                // coding value
+                // for verification
+                m.headers().set("X-Original-Content-Encoding", "<original encoding>");
+            }
+            ctx.fireChannelRead(e);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 0ce1f9535..12bec3449 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -12,10 +12,11 @@
  */
 package org.asynchttpclient.netty;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
-import org.testng.annotations.Test;
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -23,54 +24,52 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
+import org.testng.annotations.Test;
 
 public class NettyAsyncResponseTest {
 
-  @Test
-  public void testCookieParseExpires() {
-    // e.g. "Tue, 27 Oct 2015 12:54:24 GMT";
-    SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
-    sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
-
-    Date date = new Date(System.currentTimeMillis() + 60000);
-    final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
+    @Test(groups = "standalone")
+    public void testCookieParseExpires() {
+        // e.g. "Tue, 27 Oct 2015 12:54:24 GMT";
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
+        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
 
-    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+        Date date = new Date(System.currentTimeMillis() + 60000);
+        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-    List<Cookie> cookies = response.getCookies();
-    assertEquals(cookies.size(), 1);
+        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
 
-    Cookie cookie = cookies.get(0);
-    assertTrue(cookie.maxAge() >= 58 && cookie.maxAge() <= 60);
-  }
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
 
-  @Test
-  public void testCookieParseMaxAge() {
-    final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
+        Cookie cookie = cookies.get(0);
+        assertTrue(cookie.maxAge() >= 58 && cookie.maxAge() <= 60);
+    }
 
-    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
-    List<Cookie> cookies = response.getCookies();
-    assertEquals(cookies.size(), 1);
+    @Test(groups = "standalone")
+    public void testCookieParseMaxAge() {
+        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
+        
+        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
 
-    Cookie cookie = cookies.get(0);
-    assertEquals(cookie.maxAge(), 60);
-  }
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.maxAge(), 60);
+    }
 
-  @Test
-  public void testCookieParseWeirdExpiresValue() {
-    final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-    HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
-    NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
+    @Test(groups = "standalone")
+    public void testCookieParseWeirdExpiresValue() {
+        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
+        HttpHeaders responseHeaders = new DefaultHttpHeaders().add(SET_COOKIE, cookieDef);
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), responseHeaders, null);
 
-    List<Cookie> cookies = response.getCookies();
-    assertEquals(cookies.size(), 1);
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
 
-    Cookie cookie = cookies.get(0);
-    assertEquals(cookie.maxAge(), Long.MIN_VALUE);
-  }
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.maxAge(), Long.MIN_VALUE);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index f1c719ef9..b58644a00 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -12,18 +12,9 @@
  */
 package org.asynchttpclient.netty;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -33,98 +24,114 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
-  private static final String MSG = "Enough is enough.";
-  private static final int SLEEPTIME_MS = 1000;
+    private static final String MSG = "Enough is enough.";
+    private static final int SLEEPTIME_MS = 1000;
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new SlowHandler();
-  }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
+    }
 
-  @Test
-  public void testRequestTimeout() throws IOException {
-    final Semaphore requestThrottle = new Semaphore(1);
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
+                throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(SLEEPTIME_MS);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        logger.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        logger.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
 
-    int samples = 10;
+    @Test(groups = "standalone")
+    public void testRequestTimeout() throws IOException {
+        final Semaphore requestThrottle = new Semaphore(1);
+
+        int samples = 10;
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
+            final CountDownLatch latch = new CountDownLatch(samples);
+            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
+
+            for (int i = 0; i < samples; i++) {
+                new Thread(new Runnable() {
+
+                    public void run() {
+                        try {
+                            requestThrottle.acquire();
+                            Future<Response> responseFuture = null;
+                            try {
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
+                                        .execute(new AsyncCompletionHandler<Response>() {
+
+                                            @Override
+                                            public Response onCompleted(Response response) throws Exception {
+                                                return response;
+                                            }
+
+                                            @Override
+                                            public void onThrowable(Throwable t) {
+                                                logger.error("onThrowable got an error", t);
+                                                try {
+                                                    Thread.sleep(100);
+                                                } catch (InterruptedException e) {
+                                                }
+                                                requestThrottle.release();
+                                            }
+                                        });
+                            } catch (Exception e) {
+                                tooManyConnections.add(e);
+                            }
+
+                            if (responseFuture != null)
+                                responseFuture.get();
+                        } catch (Exception e) {
+                        } finally {
+                            latch.countDown();
+                        }
 
-    try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
-      final CountDownLatch latch = new CountDownLatch(samples);
-      final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
+                    }
+                }).start();
+            }
 
-      for (int i = 0; i < samples; i++) {
-        new Thread(() -> {
-          try {
-            requestThrottle.acquire();
-            Future<Response> responseFuture = null;
             try {
-              responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
-                      .execute(new AsyncCompletionHandler<Response>() {
-
-                        @Override
-                        public Response onCompleted(Response response) {
-                          return response;
-                        }
-
-                        @Override
-                        public void onThrowable(Throwable t) {
-                          logger.error("onThrowable got an error", t);
-                          try {
-                            Thread.sleep(100);
-                          } catch (InterruptedException e) {
-                            //
-                          }
-                          requestThrottle.release();
-                        }
-                      });
+                latch.await(30, TimeUnit.SECONDS);
             } catch (Exception e) {
-              tooManyConnections.add(e);
+                fail("failed to wait for requests to complete");
             }
 
-            if (responseFuture != null)
-              responseFuture.get();
-          } catch (Exception e) {
-            //
-          } finally {
-            latch.countDown();
-          }
-        }).start();
-      }
-
-      try {
-        latch.await(30, TimeUnit.SECONDS);
-      } catch (Exception e) {
-        fail("failed to wait for requests to complete");
-      }
-
-      for (Exception e : tooManyConnections)
-        logger.error("Exception while calling execute", e);
-
-      assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
-    }
-  }
-
-  private class SlowHandler extends AbstractHandler {
-    public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
-            throws IOException, ServletException {
-      response.setStatus(HttpServletResponse.SC_OK);
-      final AsyncContext asyncContext = request.startAsync();
-      new Thread(() -> {
-        try {
-          Thread.sleep(SLEEPTIME_MS);
-          response.getOutputStream().print(MSG);
-          response.getOutputStream().flush();
-          asyncContext.complete();
-        } catch (InterruptedException | IOException e) {
-          logger.error(e.getMessage(), e);
+            for (Exception e : tooManyConnections)
+                logger.error("Exception while calling execute", e);
+
+            assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
         }
-      }).start();
-      baseRequest.setHandled(true);
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
index f496deec2..a453683de 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
@@ -13,74 +13,75 @@
  */
 package org.asynchttpclient.netty;
 
-import org.asynchttpclient.AsyncHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 
 import static org.mockito.Mockito.*;
-import static org.testng.Assert.*;
+
+import org.asynchttpclient.AsyncHandler;
+import org.testng.annotations.Test;
 
 public class NettyResponseFutureTest {
 
-  @Test
-  public void testCancel() {
-    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    boolean result = nettyResponseFuture.cancel(false);
-    verify(asyncHandler).onThrowable(anyObject());
-    assertTrue(result, "Cancel should return true if the Future was cancelled successfully");
-    assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
-  }
+    @Test
+    public void testCancel() {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        boolean result = nettyResponseFuture.cancel(false);
+        verify(asyncHandler).onThrowable(anyObject());
+        assertTrue(result, "Cancel should return true if the Future was cancelled successfully");
+        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+    }
 
-  @Test
-  public void testCancelOnAlreadyCancelled() {
-    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    nettyResponseFuture.cancel(false);
-    boolean result = nettyResponseFuture.cancel(false);
-    assertFalse(result, "cancel should return false for an already cancelled Future");
-    assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
-  }
+    @Test
+    public void testCancelOnAlreadyCancelled() {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        nettyResponseFuture.cancel(false);
+        boolean result = nettyResponseFuture.cancel(false);
+        assertFalse(result, "cancel should return false for an already cancelled Future");
+        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+    }
 
-  @Test(expectedExceptions = CancellationException.class)
-  public void testGetContentThrowsCancellationExceptionIfCancelled() throws InterruptedException, ExecutionException {
-    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    nettyResponseFuture.cancel(false);
-    nettyResponseFuture.get();
-    fail("A CancellationException must have occurred by now as 'cancel' was called before 'get'");
-  }
+    @Test(expectedExceptions = CancellationException.class)
+    public void testGetContentThrowsCancellationExceptionIfCancelled() throws InterruptedException, ExecutionException {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        nettyResponseFuture.cancel(false);
+        nettyResponseFuture.get();
+        fail("A CancellationException must have occurred by now as 'cancel' was called before 'get'");
+    }
 
-  @Test
-  public void testGet() throws Exception {
-    @SuppressWarnings("unchecked")
-    AsyncHandler<Object> asyncHandler = mock(AsyncHandler.class);
-    Object value = new Object();
-    when(asyncHandler.onCompleted()).thenReturn(value);
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    nettyResponseFuture.done();
-    Object result = nettyResponseFuture.get();
-    assertEquals(result, value, "The Future should return the value given by asyncHandler#onCompleted");
-  }
+    @Test
+    public void testGet() throws Exception {
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Object> asyncHandler = mock(AsyncHandler.class);
+        Object value = new Object();
+        when(asyncHandler.onCompleted()).thenReturn(value);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        nettyResponseFuture.done();
+        Object result = nettyResponseFuture.get();
+        assertEquals(result, value, "The Future should return the value given by asyncHandler#onCompleted");
+    }
 
-  @Test(expectedExceptions = ExecutionException.class)
-  public void testGetThrowsExceptionThrownByAsyncHandler() throws Exception {
-    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-    when(asyncHandler.onCompleted()).thenThrow(new RuntimeException());
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    nettyResponseFuture.done();
-    nettyResponseFuture.get();
-    fail("An ExecutionException must have occurred by now as asyncHandler threw an exception in 'onCompleted'");
-  }
+    @Test(expectedExceptions = ExecutionException.class)
+    public void testGetThrowsExceptionThrownByAsyncHandler() throws Exception {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        when(asyncHandler.onCompleted()).thenThrow(new RuntimeException());
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        nettyResponseFuture.done();
+        nettyResponseFuture.get();
+        fail("An ExecutionException must have occurred by now as asyncHandler threw an exception in 'onCompleted'");
+    }
 
-  @Test(expectedExceptions = ExecutionException.class)
-  public void testGetThrowsExceptionOnAbort() throws InterruptedException, ExecutionException {
-    AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
-    NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
-    nettyResponseFuture.abort(new RuntimeException());
-    nettyResponseFuture.get();
-    fail("An ExecutionException must have occurred by now as 'abort' was called before 'get'");
-  }
+    @Test(expectedExceptions = ExecutionException.class)
+    public void testGetThrowsExceptionOnAbort() throws InterruptedException, ExecutionException {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null, null);
+        nettyResponseFuture.abort(new RuntimeException());
+        nettyResponseFuture.get();
+        fail("An ExecutionException must have occurred by now as 'abort' was called before 'get'");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index 05fbfa78d..863b71fe5 100644
--- a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -12,19 +12,11 @@
  */
 package org.asynchttpclient.netty;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.*;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.servlet.ServletContextHandler;
-import org.eclipse.jetty.servlet.ServletHolder;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -33,164 +25,185 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
 //FIXME there's no retry actually
 public class RetryNonBlockingIssue extends AbstractBasicTest {
 
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-
-    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-    context.setContextPath("/");
-    context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
-    server.setHandler(context);
-
-    server.start();
-    port1 = connector.getLocalPort();
-  }
-
-  protected String getTargetUrl() {
-    return String.format("http://localhost:%d/", port1);
-  }
-
-  private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) {
-    RequestBuilder r = get(getTargetUrl())
-            .addQueryParam(action, "1")
-            .addQueryParam("maxRequests", "" + requests)
-            .addQueryParam("id", id);
-    return client.executeRequest(r);
-  }
-
-  @Test
-  public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
-
-    AsyncHttpClientConfig config = config()
-            .setKeepAlive(true)
-            .setMaxConnections(100)
-            .setConnectTimeout(60000)
-            .setRequestTimeout(30000)
-            .build();
-
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      List<ListenableFuture<Response>> res = new ArrayList<>();
-      for (int i = 0; i < 32; i++) {
-        res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
-      }
-
-      StringBuilder b = new StringBuilder();
-      for (ListenableFuture<Response> r : res) {
-        Response theres = r.get();
-        assertEquals(200, theres.getStatusCode());
-        b.append("==============\r\n")
-                .append("Response Headers\r\n");
-        HttpHeaders heads = theres.getHeaders();
-        b.append(heads).append("\r\n")
-                .append("==============\r\n");
-      }
-      System.out.println(b.toString());
-      System.out.flush();
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+        context.setContextPath("/");
+        context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
+        server.setHandler(context);
+        
+        server.start();
+        port1 = connector.getLocalPort();
+    }
+
+    protected String getTargetUrl() {
+        return String.format("http://localhost:%d/", port1);
     }
-  }
-
-  @Test
-  public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
-
-    AsyncHttpClientConfig config = config()
-            .setKeepAlive(true)
-            .setMaxConnections(100)
-            .setConnectTimeout(60000)
-            .setRequestTimeout(30000)
-            .build();
-
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      List<ListenableFuture<Response>> res = new ArrayList<>();
-      for (int i = 0; i < 32; i++) {
-        res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
-      }
-
-      StringBuilder b = new StringBuilder();
-      for (ListenableFuture<Response> r : res) {
-        Response theres = r.get();
-        assertEquals(theres.getStatusCode(), 200);
-        b.append("==============\r\n")
-                .append("Response Headers\r\n");
-        HttpHeaders heads = theres.getHeaders();
-        b.append(heads).append("\r\n")
-                .append("==============\r\n");
-      }
-      System.out.println(b.toString());
-      System.out.flush();
+
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
+        RequestBuilder r = get(getTargetUrl())//
+                .addQueryParam(action, "1")//
+                .addQueryParam("maxRequests", "" + requests)//
+                .addQueryParam("id", id);
+        return client.executeRequest(r);
     }
-  }
-
-  @SuppressWarnings("serial")
-  public class MockExceptionServlet extends HttpServlet {
-
-    private Map<String, Integer> requests = new ConcurrentHashMap<>();
-
-    private synchronized int increment(String id) {
-      int val;
-      if (requests.containsKey(id)) {
-        Integer i = requests.get(id);
-        val = i + 1;
-        requests.put(id, val);
-      } else {
-        requests.put(id, 1);
-        val = 1;
-      }
-      System.out.println("REQUESTS: " + requests);
-      return val;
+
+    /**
+     * Tests that a head request can be made
+     * 
+     * @throws IOException
+     * @throws ExecutionException
+     * @throws InterruptedException
+     */
+    @Test(groups = "standalone")
+    public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
+
+        AsyncHttpClientConfig config = config()//
+                .setKeepAlive(true)//
+                .setMaxConnections(100)//
+                .setConnectTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
+
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                assertEquals(200, theres.getStatusCode());
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                HttpHeaders heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
+
+        AsyncHttpClientConfig config = config()//
+                .setKeepAlive(true)//
+                .setMaxConnections(100)//
+                .setConnectTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
+
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                assertEquals(theres.getStatusCode(), 200);
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                HttpHeaders heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+        }
     }
 
-    public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-      String maxRequests = req.getParameter("maxRequests");
-      int max;
-      try {
-        max = Integer.parseInt(maxRequests);
-      } catch (NumberFormatException e) {
-        max = 3;
-      }
-      String id = req.getParameter("id");
-      int requestNo = increment(id);
-      String servlet = req.getParameter("servlet");
-      String io = req.getParameter("io");
-      String error = req.getParameter("500");
-
-      if (requestNo >= max) {
-        res.setHeader("Success-On-Attempt", "" + requestNo);
-        res.setHeader("id", id);
-        if (servlet != null && servlet.trim().length() > 0)
-          res.setHeader("type", "servlet");
-        if (error != null && error.trim().length() > 0)
-          res.setHeader("type", "500");
-        if (io != null && io.trim().length() > 0)
-          res.setHeader("type", "io");
-        res.setStatus(200);
-        res.setContentLength(0);
-        res.flushBuffer();
-        return;
-      }
-
-      res.setStatus(200);
-      res.setContentLength(100);
-      res.setContentType("application/octet-stream");
-      res.flushBuffer();
-
-      // error after flushing the status
-      if (servlet != null && servlet.trim().length() > 0)
-        throw new ServletException("Servlet Exception");
-
-      if (io != null && io.trim().length() > 0)
-        throw new IOException("IO Exception");
-
-      if (error != null && error.trim().length() > 0) {
-        res.sendError(500, "servlet process was 500");
-      }
+    @SuppressWarnings("serial")
+    public class MockExceptionServlet extends HttpServlet {
+
+        private Map<String, Integer> requests = new ConcurrentHashMap<>();
+
+        private synchronized int increment(String id) {
+            int val = 0;
+            if (requests.containsKey(id)) {
+                Integer i = requests.get(id);
+                val = i + 1;
+                requests.put(id, val);
+            } else {
+                requests.put(id, 1);
+                val = 1;
+            }
+            System.out.println("REQUESTS: " + requests);
+            return val;
+        }
+
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+            String maxRequests = req.getParameter("maxRequests");
+            int max = 0;
+            try {
+                max = Integer.parseInt(maxRequests);
+            } catch (NumberFormatException e) {
+                max = 3;
+            }
+            String id = req.getParameter("id");
+            int requestNo = increment(id);
+            String servlet = req.getParameter("servlet");
+            String io = req.getParameter("io");
+            String error = req.getParameter("500");
+
+            if (requestNo >= max) {
+                res.setHeader("Success-On-Attempt", "" + requestNo);
+                res.setHeader("id", id);
+                if (servlet != null && servlet.trim().length() > 0)
+                    res.setHeader("type", "servlet");
+                if (error != null && error.trim().length() > 0)
+                    res.setHeader("type", "500");
+                if (io != null && io.trim().length() > 0)
+                    res.setHeader("type", "io");
+                res.setStatus(200);
+                res.setContentLength(0);
+                res.flushBuffer();
+                return;
+            }
+
+            res.setStatus(200);
+            res.setContentLength(100);
+            res.setContentType("application/octet-stream");
+            res.flushBuffer();
+
+            // error after flushing the status
+            if (servlet != null && servlet.trim().length() > 0)
+                throw new ServletException("Servlet Exception");
+
+            if (io != null && io.trim().length() > 0)
+                throw new IOException("IO Exception");
+
+            if (error != null && error.trim().length() > 0) {
+                res.sendError(500, "servlet process was 500");
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java b/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
index b4d904d6b..3b18b7800 100644
--- a/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/TimeToLiveIssue.java
@@ -12,36 +12,39 @@
  */
 package org.asynchttpclient.netty;
 
-import org.asynchttpclient.*;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
 
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.testng.annotations.Test;
 
 public class TimeToLiveIssue extends AbstractBasicTest {
-  @Test(enabled = false, description = "https://github.com/AsyncHttpClient/async-http-client/issues/1113")
-  public void testTTLBug() throws Throwable {
-    // The purpose of this test is to reproduce two issues:
-    // 1) Connections that are rejected by the pool are not closed and eventually use all available sockets.
-    // 2) It is possible for a connection to be closed while active by the timer task that checks for expired connections.
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setConnectionTtl(1).setPooledConnectionIdleTimeout(1))) {
-
-      for (int i = 0; i < 200000; ++i) {
-        Request request = new RequestBuilder().setUrl(String.format("http://localhost:%d/", port1)).build();
-
-        Future<Response> future = client.executeRequest(request);
-        future.get(5, TimeUnit.SECONDS);
-
-        // This is to give a chance to the timer task that removes expired connection
-        // from sometimes winning over poll for the ownership of a connection.
-        if (System.currentTimeMillis() % 100 == 0) {
-          Thread.sleep(5);
+    @Test(enabled = false, description = "https://github.com/AsyncHttpClient/async-http-client/issues/1113")
+    public void testTTLBug() throws Throwable {
+        // The purpose of this test is to reproduce two issues:
+        // 1) Connections that are rejected by the pool are not closed and eventually use all available sockets.
+        // 2) It is possible for a connection to be closed while active by the timer task that checks for expired connections.
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setConnectionTtl(1).setPooledConnectionIdleTimeout(1))) {
+
+            for (int i = 0; i < 200000; ++i) {
+                Request request = new RequestBuilder().setUrl(String.format("http://localhost:%d/", port1)).build();
+
+                Future<Response> future = client.executeRequest(request);
+                future.get(5, TimeUnit.SECONDS);
+
+                // This is to give a chance to the timer task that removes expired connection
+                // from sometimes winning over poll for the ownership of a connection.
+                if (System.currentTimeMillis() % 100 == 0) {
+                    Thread.sleep(5);
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java b/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java
index a387ba408..e7475eef1 100644
--- a/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/channel/NonBlockingSemaphoreTest.java
@@ -13,10 +13,10 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import org.testng.annotations.Test;
-
 import java.util.concurrent.Semaphore;
 
+import org.testng.annotations.Test;
+
 import static org.testng.Assert.*;
 
 /**
@@ -24,53 +24,53 @@
  */
 public class NonBlockingSemaphoreTest {
 
-  @Test
-  public void test0() {
-    Mirror mirror = new Mirror(0);
-    assertFalse(mirror.tryAcquire());
-  }
+    private static class Mirror {
+        private final Semaphore real;
+        private final NonBlockingSemaphore nonBlocking;
 
-  @Test
-  public void three() {
-    Mirror mirror = new Mirror(3);
-    for (int i = 0; i < 3; ++i) {
-      assertTrue(mirror.tryAcquire());
-    }
-    assertFalse(mirror.tryAcquire());
-    mirror.release();
-    assertTrue(mirror.tryAcquire());
-  }
+        public Mirror(int permits) {
+            real = new Semaphore(permits);
+            nonBlocking = new NonBlockingSemaphore(permits);
+        }
 
-  @Test
-  public void negative() {
-    Mirror mirror = new Mirror(-1);
-    assertFalse(mirror.tryAcquire());
-    mirror.release();
-    assertFalse(mirror.tryAcquire());
-    mirror.release();
-    assertTrue(mirror.tryAcquire());
-  }
+        public boolean tryAcquire() {
+            boolean a = real.tryAcquire();
+            boolean b = nonBlocking.tryAcquire();
+            assertEquals(a, b);
+            return a;
+        }
 
-  private static class Mirror {
-    private final Semaphore real;
-    private final NonBlockingSemaphore nonBlocking;
+        public void release() {
+            real.release();
+            nonBlocking.release();
+        }
+    }
 
-    Mirror(int permits) {
-      real = new Semaphore(permits);
-      nonBlocking = new NonBlockingSemaphore(permits);
+    @Test
+    public void test0() {
+        Mirror mirror = new Mirror(0);
+        assertFalse(mirror.tryAcquire());
     }
 
-    boolean tryAcquire() {
-      boolean a = real.tryAcquire();
-      boolean b = nonBlocking.tryAcquire();
-      assertEquals(a, b);
-      return a;
+    @Test
+    public void three() {
+        Mirror mirror = new Mirror(3);
+        for (int i = 0; i < 3; ++i) {
+            assertTrue(mirror.tryAcquire());
+        }
+        assertFalse(mirror.tryAcquire());
+        mirror.release();
+        assertTrue(mirror.tryAcquire());
     }
 
-    void release() {
-      real.release();
-      nonBlocking.release();
+    @Test
+    public void negative() {
+        Mirror mirror = new Mirror(-1);
+        assertFalse(mirror.tryAcquire());
+        mirror.release();
+        assertFalse(mirror.tryAcquire());
+        mirror.release();
+        assertTrue(mirror.tryAcquire());
     }
-  }
 
 }
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 93f9362da..5f922175c 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -13,6 +13,19 @@
  */
 package org.asynchttpclient.ntlm;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.commons.io.output.ByteArrayOutputStream;
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
@@ -24,197 +37,184 @@
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
+public class NtlmTest extends AbstractBasicTest {
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+    public static class NTLMHandler extends AbstractHandler {
 
-public class NtlmTest extends AbstractBasicTest {
+        @Override
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
+                ServletException {
+
+            String authorization = httpRequest.getHeader("Authorization");
+            if (authorization == null) {
+                httpResponse.setStatus(401);
+                httpResponse.setHeader("WWW-Authenticate", "NTLM");
+
+            } else if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
+                httpResponse.setStatus(401);
+                httpResponse.setHeader("WWW-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
 
-  private static byte[] longToBytes(long x) {
-    ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
-    buffer.putLong(x);
-    return buffer.array();
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new NTLMHandler();
-  }
-
-  private Realm.Builder realmBuilderBase() {
-    return ntlmAuthRealm("Zaphod", "Beeblebrox")
-            .setNtlmDomain("Ursa-Minor")
-            .setNtlmHost("LightCity");
-  }
-
-  private void ntlmAuthTest(Realm.Builder realmBuilder) throws IOException, InterruptedException, ExecutionException {
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder))) {
-      Future<Response> responseFuture = client.executeRequest(get(getTargetUrl()));
-      int status = responseFuture.get().getStatusCode();
-      Assert.assertEquals(status, 200);
+            } else if (authorization
+                    .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
+                httpResponse.setStatus(200);
+            } else {
+                httpResponse.setStatus(401);
+            }
+
+            httpResponse.setContentLength(0);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  @Test
-  public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
-    ntlmAuthTest(realmBuilderBase());
-  }
-
-  @Test
-  public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
-    ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
-  }
-
-  @Test
-  public void testGenerateType1Msg() {
-    NtlmEngine engine = new NtlmEngine();
-    String message = engine.generateType1Msg();
-    assertEquals(message, "TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==", "Incorrect type1 message generated");
-  }
-
-  @Test(expectedExceptions = NtlmEngineException.class)
-  public void testGenerateType3MsgThrowsExceptionWhenChallengeTooShort() {
-    NtlmEngine engine = new NtlmEngine();
-    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("a".getBytes()));
-    fail("An NtlmEngineException must have occurred as challenge length is too short");
-  }
-
-  @Test(expectedExceptions = NtlmEngineException.class)
-  public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrectFormat() {
-    NtlmEngine engine = new NtlmEngine();
-    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("challenge".getBytes()));
-    fail("An NtlmEngineException must have occurred as challenge format is not correct");
-  }
-
-  @Test(expectedExceptions = NtlmEngineException.class)
-  public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
-    ByteArrayOutputStream buf = new ByteArrayOutputStream();
-    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-    buf.write(0);
-    // type 2 indicator
-    buf.write(3);
-    buf.write(0);
-    buf.write(0);
-    buf.write(0);
-    buf.write("challenge".getBytes());
-    NtlmEngine engine = new NtlmEngine();
-    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-    buf.close();
-    fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
-  }
-
-  @Test(expectedExceptions = NtlmEngineException.class)
-  public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
-    ByteArrayOutputStream buf = new ByteArrayOutputStream();
-    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-    buf.write(0);
-    // type 2 indicator
-    buf.write(2);
-    buf.write(0);
-    buf.write(0);
-    buf.write(0);
-
-    buf.write(longToBytes(1L)); // we want to write a Long
-
-    // flags
-    buf.write(0);// unicode support indicator
-    buf.write(0);
-    buf.write(0);
-    buf.write(0);
-
-    buf.write(longToBytes(1L));// challenge
-    NtlmEngine engine = new NtlmEngine();
-    engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-    buf.close();
-    fail("An NtlmEngineException must have occurred as unicode support is not indicated");
-  }
-
-  @Test
-  public void testGenerateType2Msg() {
-    Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
-    Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
-  }
-
-  @Test
-  public void testGenerateType3Msg() throws IOException {
-    ByteArrayOutputStream buf = new ByteArrayOutputStream();
-    buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-    buf.write(0);
-    // type 2 indicator
-    buf.write(2);
-    buf.write(0);
-    buf.write(0);
-    buf.write(0);
-
-    buf.write(longToBytes(0L)); // we want to write a Long
-
-    // flags
-    buf.write(1);// unicode support indicator
-    buf.write(0);
-    buf.write(0);
-    buf.write(0);
-
-    buf.write(longToBytes(1L));// challenge
-    NtlmEngine engine = new NtlmEngine();
-    String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
-    buf.close();
-    assertEquals(
-            type3Msg,
-            "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
-            "Incorrect type3 message generated");
-  }
-
-  @Test
-  public void testWriteULong() {
-    // test different combinations so that different positions in the byte array will be written
-    byte[] buffer = new byte[4];
-    NtlmEngine.writeULong(buffer, 1, 0);
-    assertEquals(buffer, new byte[]{1, 0, 0, 0}, "Unsigned long value 1 was not written correctly to the buffer");
-
-    buffer = new byte[4];
-    NtlmEngine.writeULong(buffer, 257, 0);
-    assertEquals(buffer, new byte[]{1, 1, 0, 0}, "Unsigned long value 257 was not written correctly to the buffer");
-
-    buffer = new byte[4];
-    NtlmEngine.writeULong(buffer, 16777216, 0);
-    assertEquals(buffer, new byte[]{0, 0, 0, 1}, "Unsigned long value 16777216 was not written correctly to the buffer");
-  }
-
-  public static class NTLMHandler extends AbstractHandler {
 
     @Override
-    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
-            ServletException {
-
-      String authorization = httpRequest.getHeader("Authorization");
-      if (authorization == null) {
-        httpResponse.setStatus(401);
-        httpResponse.setHeader("WWW-Authenticate", "NTLM");
-
-      } else if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
-        httpResponse.setStatus(401);
-        httpResponse.setHeader("WWW-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
-
-      } else if (authorization
-              .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
-        httpResponse.setStatus(200);
-      } else {
-        httpResponse.setStatus(401);
-      }
-
-      httpResponse.setContentLength(0);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    public AbstractHandler configureHandler() throws Exception {
+        return new NTLMHandler();
+    }
+
+    private Realm.Builder realmBuilderBase() {
+        return ntlmAuthRealm("Zaphod", "Beeblebrox")//
+                .setNtlmDomain("Ursa-Minor")//
+                .setNtlmHost("LightCity");
+    }
+
+    private void ntlmAuthTest(Realm.Builder realmBuilder) throws IOException, InterruptedException, ExecutionException {
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder))) {
+            Future<Response> responseFuture = client.executeRequest(get(getTargetUrl()));
+            int status = responseFuture.get().getStatusCode();
+            Assert.assertEquals(status, 200);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+        ntlmAuthTest(realmBuilderBase());
+    }
+
+    @Test(groups = "standalone")
+    public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+        ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
+    }
+
+    @Test
+    public void testGenerateType1Msg() {
+        NtlmEngine engine = new NtlmEngine();
+        String message = engine.generateType1Msg();
+        assertEquals(message, "TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==", "Incorrect type1 message generated");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenChallengeTooShort() {
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("a".getBytes()));
+        fail("An NtlmEngineException must have occurred as challenge length is too short");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrectFormat() {
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode("challenge".getBytes()));
+        fail("An NtlmEngineException must have occurred as challenge format is not correct");
+    }
+
+    private static byte[] longToBytes(long x) {
+        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
+        buffer.putLong(x);
+        return buffer.array();
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
+        // type 2 indicator
+        buf.write(3);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+        buf.write("challenge".getBytes());
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
+        fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
+        // type 2 indicator
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L)); // we want to write a Long
+
+        // flags
+        buf.write(0);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
+        fail("An NtlmEngineException must have occurred as unicode support is not indicated");
+    }
+
+    @Test(groups = "standalone")
+    public void testGenerateType2Msg() {
+        Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+        Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
+    }
+
+    @Test
+    public void testGenerateType3Msg() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
+        // type 2 indicator
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(0L)); // we want to write a Long
+
+        // flags
+        buf.write(1);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
+        NtlmEngine engine = new NtlmEngine();
+        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
+        assertEquals(
+                type3Msg,
+                "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
+                "Incorrect type3 message generated");
+    }
+
+    @Test
+    public void testWriteULong() {
+        // test different combinations so that different positions in the byte array will be written
+        byte[] buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 1, 0);
+        assertEquals(buffer, new byte[] { 1, 0, 0, 0 }, "Unsigned long value 1 was not written correctly to the buffer");
+
+        buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 257, 0);
+        assertEquals(buffer, new byte[] { 1, 1, 0, 0 }, "Unsigned long value 257 was not written correctly to the buffer");
+
+        buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 16777216, 0);
+        assertEquals(buffer, new byte[] { 0, 0, 0, 1 }, "Unsigned long value 16777216 was not written correctly to the buffer");
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
index 9f87760d5..e93f7f9dc 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
@@ -13,11 +13,9 @@
  */
 package org.asynchttpclient.oauth;
 
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.util.Utf8UrlEncoder;
-import org.testng.annotations.Test;
+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
@@ -27,305 +25,309 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;
-import static org.asynchttpclient.Dsl.get;
-import static org.asynchttpclient.Dsl.post;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.util.Utf8UrlEncoder;
+import org.testng.annotations.Test;
 
 /**
  * Tests the OAuth signature behavior.
- * <p>
+ *
  * See <a href= "https://oauth.googlecode.com/svn/code/javascript/example/signature.html" >Signature Tester</a> for an online oauth signature checker.
+ *
  */
 public class OAuthSignatureCalculatorTest {
-  private static final String TOKEN_KEY = "nnch734d00sl2jdk";
-  private static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
-  private static final String NONCE = "kllo9940pd9333jh";
-  private static final long TIMESTAMP = 1191242096;
-  private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
-  private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
-
-  // sample from RFC https://tools.ietf.org/html/rfc5849#section-3.4.1
-  private void testSignatureBaseString(Request request) throws NoSuchAlgorithmException {
-    String signatureBaseString = new OAuthSignatureCalculatorInstance()
-            .signatureBaseString(//
-                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
-                    new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),
-                    request,
-                    137131201,
-                    "7d8f3e4a").toString();
-
-    assertEquals(signatureBaseString, "POST&"
-            + "http%3A%2F%2Fexample.com%2Frequest"
-            + "&a2%3Dr%2520b%26"
-            + "a3%3D2%2520q%26"
-            + "a3%3Da%26"
-            + "b5%3D%253D%25253D%26"
-            + "c%2540%3D%26"
-            + "c2%3D%26"
-            + "oauth_consumer_key%3D9djdj82h48djs9d2%26"
-            + "oauth_nonce%3D7d8f3e4a%26"
-            + "oauth_signature_method%3DHMAC-SHA1%26"
-            + "oauth_timestamp%3D137131201%26"
-            + "oauth_token%3Dkkk9d7dh3k39sjv7%26"
-            + "oauth_version%3D1.0");
-  }
-
-  // fork above test with an OAuth token that requires encoding
-  private void testSignatureBaseStringWithEncodableOAuthToken(Request request) throws NoSuchAlgorithmException {
-    String signatureBaseString = new OAuthSignatureCalculatorInstance()
-            .signatureBaseString(//
-                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
-                    new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),
-                    request,
-                    137131201,
-                    Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
-
-    assertEquals(signatureBaseString, "POST&"
-            + "http%3A%2F%2Fexample.com%2Frequest"
-            + "&a2%3Dr%2520b%26"
-            + "a3%3D2%2520q%26"
-            + "a3%3Da%26"
-            + "b5%3D%253D%25253D%26"
-            + "c%2540%3D%26"
-            + "c2%3D%26"
-            + "oauth_consumer_key%3D9djdj82h48djs9d2%26"
-            + "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26"
-            + "oauth_signature_method%3DHMAC-SHA1%26"
-            + "oauth_timestamp%3D137131201%26"
-            + "oauth_token%3Dkkk9d7dh3k39sjv7%26"
-            + "oauth_version%3D1.0");
-  }
-
-  @Test
-  public void testSignatureBaseStringWithProperlyEncodedUri() throws NoSuchAlgorithmException {
-    Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")
-            .addFormParam("c2", "")
-            .addFormParam("a3", "2 q")
-            .build();
-
-    testSignatureBaseString(request);
-    testSignatureBaseStringWithEncodableOAuthToken(request);
-  }
-
-  @Test
-  public void testSignatureBaseStringWithRawUri() throws NoSuchAlgorithmException {
-    // note: @ is legal so don't decode it into %40 because it won't be
-    // encoded back
-    // note: we don't know how to fix a = that should have been encoded as
-    // %3D but who would be stupid enough to do that?
-    Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")
-            .addFormParam("c2", "")
-            .addFormParam("a3", "2 q")
-            .build();
-
-    testSignatureBaseString(request);
-    testSignatureBaseStringWithEncodableOAuthToken(request);
-  }
-
-  // based on the reference test case from
-  // http://oauth.pbwiki.com/TestCases
-  @Test
-  public void testGetCalculateSignature() throws NoSuchAlgorithmException, InvalidKeyException {
-
-    Request request = get("http://photos.example.net/photos")
-            .addQueryParam("file", "vacation.jpg")
-            .addQueryParam("size", "original")
-            .build();
-
-    String signature = new OAuthSignatureCalculatorInstance()
-            .calculateSignature(new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
-                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
-                    request,
-                    TIMESTAMP,
-                    NONCE);
-
-    assertEquals(signature, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-  }
-
-  @Test
-  public void testPostCalculateSignature() throws UnsupportedEncodingException {
-    StaticOAuthSignatureCalculator calc = //
-            new StaticOAuthSignatureCalculator(//
-                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
-                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
-                    NONCE,
-                    TIMESTAMP);
-
-    final Request req = post("http://photos.example.net/photos")
-            .addFormParam("file", "vacation.jpg")
-            .addFormParam("size", "original")
-            .setSignatureCalculator(calc)
-            .build();
-
-    // From the signature tester, POST should look like:
-    // normalized parameters:
-    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-    // signature base string:
-    // POST&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-    // signature: wPkvxykrw+BTdCcGqKr+3I+PsiM=
-    // header: OAuth
-    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
-
-    String authHeader = req.getHeaders().get(AUTHORIZATION);
-    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-    assertEquals(m.find(), true);
-    String encodedSig = m.group(1);
-    String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-    assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
-  }
-
-  @Test
-  public void testGetWithRequestBuilder() throws UnsupportedEncodingException {
-    StaticOAuthSignatureCalculator calc =
-            new StaticOAuthSignatureCalculator(
-                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
-                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
-                    NONCE,
-                    TIMESTAMP);
-
-    final Request req = get("http://photos.example.net/photos")
-            .addQueryParam("file", "vacation.jpg")
-            .addQueryParam("size", "original")
-            .setSignatureCalculator(calc)
-            .build();
-
-    final List<Param> params = req.getQueryParams();
-    assertEquals(params.size(), 2);
-
-    // From the signature tester, the URL should look like:
-    // normalized parameters:
-    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-    // signature base string:
-    // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-    // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
-    // Authorization header: OAuth
-    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
-
-    String authHeader = req.getHeaders().get(AUTHORIZATION);
-    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-    assertEquals(m.find(), true);
-    String encodedSig = m.group(1);
-    String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-    assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-    assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
-  }
-
-  @Test
-  public void testGetWithRequestBuilderAndQuery() throws UnsupportedEncodingException {
-    StaticOAuthSignatureCalculator calc = //
-            new StaticOAuthSignatureCalculator(//
-                    new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),
-                    new RequestToken(TOKEN_KEY, TOKEN_SECRET),
-                    NONCE,
-                    TIMESTAMP);
-
-    final Request req = get("http://photos.example.net/photos?file=vacation.jpg&size=original")
-            .setSignatureCalculator(calc)
-            .build();
-
-    final List<Param> params = req.getQueryParams();
-    assertEquals(params.size(), 2);
-
-    // From the signature tester, the URL should look like:
-    // normalized parameters:
-    // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
-    // signature base string:
-    // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
-    // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
-    // Authorization header: OAuth
-    // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
-
-    String authHeader = req.getHeaders().get(AUTHORIZATION);
-    Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
-    assertTrue(m.find());
-    String encodedSig = m.group(1);
-    String sig = URLDecoder.decode(encodedSig, "UTF-8");
-
-    assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-    assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
-    assertEquals(
-            authHeader,
-            "OAuth oauth_consumer_key=\"dpf43f3p2l4k3l03\", oauth_token=\"nnch734d00sl2jdk\", oauth_signature_method=\"HMAC-SHA1\", oauth_signature=\"tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D\", oauth_timestamp=\"1191242096\", oauth_nonce=\"kllo9940pd9333jh\", oauth_version=\"1.0\"");
-  }
-
-  @Test
-  public void testWithNullRequestToken() throws NoSuchAlgorithmException {
-
-    final Request request = get("http://photos.example.net/photos?file=vacation.jpg&size=original").build();
-
-    String signatureBaseString = new OAuthSignatureCalculatorInstance()
-            .signatureBaseString(//
-                    new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),
-                    new RequestToken(null, null),
-                    request,
-                    137131201,
-                    Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
-
-    assertEquals(signatureBaseString, "GET&" +
-            "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" +
-            "oauth_consumer_key%3D9djdj82h48djs9d2%26" +
-            "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26" +
-            "oauth_signature_method%3DHMAC-SHA1%26" +
-            "oauth_timestamp%3D137131201%26" +
-            "oauth_version%3D1.0%26size%3Doriginal");
-  }
-
-  @Test
-  public void testWithStarQueryParameterValue() throws NoSuchAlgorithmException {
-    final Request request = get("http://term.ie/oauth/example/request_token.php?testvalue=*").build();
-
-    String signatureBaseString = new OAuthSignatureCalculatorInstance()
-            .signatureBaseString(
-                    new ConsumerKey("key", "secret"),
-                    new RequestToken(null, null),
-                    request,
-                    1469019732,
-                    "6ad17f97334700f3ec2df0631d5b7511").toString();
-
-    assertEquals(signatureBaseString, "GET&" +
-            "http%3A%2F%2Fterm.ie%2Foauth%2Fexample%2Frequest_token.php&"
-            + "oauth_consumer_key%3Dkey%26"
-            + "oauth_nonce%3D6ad17f97334700f3ec2df0631d5b7511%26"
-            + "oauth_signature_method%3DHMAC-SHA1%26"
-            + "oauth_timestamp%3D1469019732%26"
-            + "oauth_version%3D1.0%26"
-            + "testvalue%3D%252A");
-  }
-
-  @Test
-  public void testSignatureGenerationWithAsteriskInPath() throws InvalidKeyException, NoSuchAlgorithmException {
-    ConsumerKey consumerKey = new ConsumerKey("key", "secret");
-    RequestToken requestToken = new RequestToken(null, null);
-    String nonce = "6ad17f97334700f3ec2df0631d5b7511";
-    long timestamp = 1469019732;
-
-    final Request request = get("http://example.com/oauth/example/*path/wi*th/asterisks*").build();
-
-    String expectedSignature = "cswi/v3ZqhVkTyy5MGqW841BxDA=";
-    String actualSignature = new OAuthSignatureCalculatorInstance().calculateSignature(consumerKey, requestToken, request, timestamp, nonce);
-    assertEquals(actualSignature, expectedSignature);
-
-    String generatedAuthHeader = new OAuthSignatureCalculatorInstance().constructAuthHeader(consumerKey, requestToken, actualSignature, timestamp, nonce);
-    assertTrue(generatedAuthHeader.contains("oauth_signature=\"cswi%2Fv3ZqhVkTyy5MGqW841BxDA%3D\""));
-  }
-
-  @Test
-  public void testPercentEncodeKeyValues() {
-    // see https://github.com/AsyncHttpClient/async-http-client/issues/1415
-    String keyValue = "\u3b05\u000c\u375b";
-
-    ConsumerKey consumer = new ConsumerKey(keyValue, "secret");
-    RequestToken reqToken = new RequestToken(keyValue, "secret");
-    OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, reqToken);
-
-    RequestBuilder reqBuilder = new RequestBuilder()
-            .setUrl("https://api.dropbox.com/1/oauth/access_token?oauth_token=%EC%AD%AE%E3%AC%82%EC%BE%B8%E7%9C%9A%E8%BD%BD%E1%94%A5%E8%AD%AF%E8%98%93%E0%B9%99%E5%9E%96%EF%92%A2%EA%BC%97%EA%90%B0%E4%8A%91%E8%97%BF%EF%A8%BB%E5%B5%B1%DA%98%E2%90%87%E2%96%96%EE%B5%B5%E7%B9%AD%E9%AD%87%E3%BE%93%E5%AF%92%EE%BC%8F%E3%A0%B2%E8%A9%AB%E1%8B%97%EC%BF%80%EA%8F%AE%ED%87%B0%E5%97%B7%E9%97%BF%E8%BF%87%E6%81%A3%E5%BB%A1%EC%86%92%E8%92%81%E2%B9%94%EB%B6%86%E9%AE%8A%E6%94%B0%EE%AC%B5%E6%A0%99%EB%8B%AD%EB%BA%81%E7%89%9F%E5%B3%B7%EA%9D%B7%EC%A4%9C%E0%BC%BA%EB%BB%B9%ED%84%A9%E8%A5%B9%E8%AF%A0%E3%AC%85%0C%E3%9D%9B%E8%B9%8B%E6%BF%8C%EB%91%98%E7%8B%B3%E7%BB%A8%E2%A7%BB%E6%A3%84%E1%AB%B2%E8%8D%93%E4%BF%98%E9%B9%B9%EF%9A%8B%E8%A5%93");
-    Request req = reqBuilder.build();
-
-    calc.calculateAndAddSignature(req, reqBuilder);
-  }
+    private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
+
+    private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
+
+    public static final String TOKEN_KEY = "nnch734d00sl2jdk";
+
+    public static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
+
+    public static final String NONCE = "kllo9940pd9333jh";
+
+    final static long TIMESTAMP = 1191242096;
+
+    // sample from RFC https://tools.ietf.org/html/rfc5849#section-3.4.1
+    private void testSignatureBaseString(Request request) throws NoSuchAlgorithmException {
+        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
+                .signatureBaseString(//
+                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
+                        new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),//
+                        request,//
+                        137131201,//
+                        "7d8f3e4a").toString();
+
+        assertEquals(signatureBaseString, "POST&" //
+                + "http%3A%2F%2Fexample.com%2Frequest" //
+                + "&a2%3Dr%2520b%26"//
+                + "a3%3D2%2520q%26" + "a3%3Da%26"//
+                + "b5%3D%253D%25253D%26"//
+                + "c%2540%3D%26"//
+                + "c2%3D%26"//
+                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
+                + "oauth_nonce%3D7d8f3e4a%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D137131201%26"//
+                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
+                + "oauth_version%3D1.0");
+    }
+
+    // fork above test with an OAuth token that requires encoding
+    private void testSignatureBaseStringWithEncodableOAuthToken(Request request) throws NoSuchAlgorithmException {
+        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
+                .signatureBaseString(//
+                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
+                        new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET),//
+                        request,//
+                        137131201,//
+                        Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
+
+        assertEquals(signatureBaseString, "POST&" //
+                + "http%3A%2F%2Fexample.com%2Frequest" //
+                + "&a2%3Dr%2520b%26"//
+                + "a3%3D2%2520q%26" + "a3%3Da%26"//
+                + "b5%3D%253D%25253D%26"//
+                + "c%2540%3D%26"//
+                + "c2%3D%26"//
+                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
+                + "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D137131201%26"//
+                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
+                + "oauth_version%3D1.0");
+    }
+
+    @Test
+    public void testSignatureBaseStringWithProperlyEncodedUri() throws NoSuchAlgorithmException {
+        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
+                .addFormParam("c2", "")//
+                .addFormParam("a3", "2 q")//
+                .build();
+
+        testSignatureBaseString(request);
+        testSignatureBaseStringWithEncodableOAuthToken(request);
+    }
+
+    @Test
+    public void testSignatureBaseStringWithRawUri() throws NoSuchAlgorithmException {
+        // note: @ is legal so don't decode it into %40 because it won't be
+        // encoded back
+        // note: we don't know how to fix a = that should have been encoded as
+        // %3D but who would be stupid enough to do that?
+        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")//
+                .addFormParam("c2", "")//
+                .addFormParam("a3", "2 q")//
+                .build();
+
+        testSignatureBaseString(request);
+        testSignatureBaseStringWithEncodableOAuthToken(request);
+    }
+
+    // based on the reference test case from
+    // http://oauth.pbwiki.com/TestCases
+    @Test
+    public void testGetCalculateSignature() throws NoSuchAlgorithmException, InvalidKeyException {
+
+        Request request = get("http://photos.example.net/photos")//
+                .addQueryParam("file", "vacation.jpg")//
+                .addQueryParam("size", "original")//
+                .build();
+
+        String signature = new OAuthSignatureCalculatorInstance()//
+                .calculateSignature(new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
+                        new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
+                        request,//
+                        TIMESTAMP,//
+                        NONCE);
+
+        assertEquals(signature, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+    }
+
+    @Test
+    public void testPostCalculateSignature() throws UnsupportedEncodingException {
+        StaticOAuthSignatureCalculator calc = //
+        new StaticOAuthSignatureCalculator(//
+                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
+                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
+                NONCE,//
+                TIMESTAMP);
+
+        final Request req = post("http://photos.example.net/photos")//
+                .addFormParam("file", "vacation.jpg")//
+                .addFormParam("size", "original")//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        // From the signature tester, POST should look like:
+        // normalized parameters:
+        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        // signature base string:
+        // POST&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        // signature: wPkvxykrw+BTdCcGqKr+3I+PsiM=
+        // header: OAuth
+        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
+
+        String authHeader = req.getHeaders().get(AUTHORIZATION);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertEquals(m.find(), true);
+        String encodedSig = m.group(1);
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+        assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
+    }
+
+    @Test
+    public void testGetWithRequestBuilder() throws UnsupportedEncodingException {
+        StaticOAuthSignatureCalculator calc = //
+        new StaticOAuthSignatureCalculator(//
+                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
+                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
+                NONCE,//
+                TIMESTAMP);
+
+        final Request req = get("http://photos.example.net/photos")//
+                .addQueryParam("file", "vacation.jpg")//
+                .addQueryParam("size", "original")//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        final List<Param> params = req.getQueryParams();
+        assertEquals(params.size(), 2);
+
+        // From the signature tester, the URL should look like:
+        // normalized parameters:
+        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        // signature base string:
+        // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+        // Authorization header: OAuth
+        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+        String authHeader = req.getHeaders().get(AUTHORIZATION);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertEquals(m.find(), true);
+        String encodedSig = m.group(1);
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+    }
+
+    @Test
+    public void testGetWithRequestBuilderAndQuery() throws UnsupportedEncodingException {
+        StaticOAuthSignatureCalculator calc = //
+        new StaticOAuthSignatureCalculator(//
+                new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET),//
+                new RequestToken(TOKEN_KEY, TOKEN_SECRET),//
+                NONCE,//
+                TIMESTAMP);
+
+        final Request req = get("http://photos.example.net/photos?file=vacation.jpg&size=original")//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        final List<Param> params = req.getQueryParams();
+        assertEquals(params.size(), 2);
+
+        // From the signature tester, the URL should look like:
+        // normalized parameters:
+        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        // signature base string:
+        // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+        // Authorization header: OAuth
+        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+        String authHeader = req.getHeaders().get(AUTHORIZATION);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertTrue(m.find());
+        String encodedSig = m.group(1);
+        String sig = URLDecoder.decode(encodedSig, "UTF-8");
+
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+        assertEquals(
+                authHeader,
+                "OAuth oauth_consumer_key=\"dpf43f3p2l4k3l03\", oauth_token=\"nnch734d00sl2jdk\", oauth_signature_method=\"HMAC-SHA1\", oauth_signature=\"tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D\", oauth_timestamp=\"1191242096\", oauth_nonce=\"kllo9940pd9333jh\", oauth_version=\"1.0\"");
+    }
+
+    @Test
+    public void testWithNullRequestToken() throws NoSuchAlgorithmException {
+
+        final Request request = get("http://photos.example.net/photos?file=vacation.jpg&size=original").build();
+
+        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
+                .signatureBaseString(//
+                        new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET),//
+                        new RequestToken(null, null),//
+                        request,//
+                        137131201,//
+                        Utf8UrlEncoder.percentEncodeQueryElement("ZLc92RAkooZcIO/0cctl0Q==")).toString();
+
+        assertEquals(signatureBaseString, "GET&" + //
+                "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" + //
+                "oauth_consumer_key%3D9djdj82h48djs9d2%26" + //
+                "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26" + //
+                "oauth_signature_method%3DHMAC-SHA1%26" + //
+                "oauth_timestamp%3D137131201%26" + //
+                "oauth_version%3D1.0%26size%3Doriginal");
+    }
+
+    @Test
+    public void testWithStarQueryParameterValue() throws NoSuchAlgorithmException {
+        final Request request = get("http://term.ie/oauth/example/request_token.php?testvalue=*").build();
+
+        String signatureBaseString = new OAuthSignatureCalculatorInstance()//
+                .signatureBaseString(//
+                        new ConsumerKey("key", "secret"),//
+                        new RequestToken(null, null),//
+                        request,//
+                        1469019732,//
+                        "6ad17f97334700f3ec2df0631d5b7511").toString();
+
+        assertEquals(signatureBaseString, "GET&" + //
+                "http%3A%2F%2Fterm.ie%2Foauth%2Fexample%2Frequest_token.php&"//
+                + "oauth_consumer_key%3Dkey%26"//
+                + "oauth_nonce%3D6ad17f97334700f3ec2df0631d5b7511%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D1469019732%26"//
+                + "oauth_version%3D1.0%26"//
+                + "testvalue%3D%252A");
+    }
+
+    @Test
+    public void testSignatureGenerationWithAsteriskInPath() throws InvalidKeyException, NoSuchAlgorithmException {
+        ConsumerKey consumerKey = new ConsumerKey("key", "secret");
+        RequestToken requestToken = new RequestToken(null, null);
+        String nonce = "6ad17f97334700f3ec2df0631d5b7511";
+        long timestamp = 1469019732;
+
+        final Request request = get("http://example.com/oauth/example/*path/wi*th/asterisks*").build();
+
+        String expectedSignature = "cswi/v3ZqhVkTyy5MGqW841BxDA=";
+        String actualSignature = new OAuthSignatureCalculatorInstance().calculateSignature(consumerKey, requestToken, request, timestamp, nonce);
+        assertEquals(actualSignature, expectedSignature);
+
+        String generatedAuthHeader = new OAuthSignatureCalculatorInstance().constructAuthHeader(consumerKey, requestToken, actualSignature, timestamp, nonce);
+        assertTrue(generatedAuthHeader.contains("oauth_signature=\"cswi%2Fv3ZqhVkTyy5MGqW841BxDA%3D\""));
+    }
+
+    @Test
+    public void testPercentEncodeKeyValues() throws NoSuchAlgorithmException {
+        // see https://github.com/AsyncHttpClient/async-http-client/issues/1415
+        String keyValue = "\u3b05\u000c\u375b";
+
+        ConsumerKey consumer = new ConsumerKey(keyValue, "secret");
+        RequestToken reqToken = new RequestToken(keyValue, "secret");
+        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, reqToken);
+
+        RequestBuilder reqBuilder = new RequestBuilder()
+                .setUrl("https://api.dropbox.com/1/oauth/access_token?oauth_token=%EC%AD%AE%E3%AC%82%EC%BE%B8%E7%9C%9A%E8%BD%BD%E1%94%A5%E8%AD%AF%E8%98%93%E0%B9%99%E5%9E%96%EF%92%A2%EA%BC%97%EA%90%B0%E4%8A%91%E8%97%BF%EF%A8%BB%E5%B5%B1%DA%98%E2%90%87%E2%96%96%EE%B5%B5%E7%B9%AD%E9%AD%87%E3%BE%93%E5%AF%92%EE%BC%8F%E3%A0%B2%E8%A9%AB%E1%8B%97%EC%BF%80%EA%8F%AE%ED%87%B0%E5%97%B7%E9%97%BF%E8%BF%87%E6%81%A3%E5%BB%A1%EC%86%92%E8%92%81%E2%B9%94%EB%B6%86%E9%AE%8A%E6%94%B0%EE%AC%B5%E6%A0%99%EB%8B%AD%EB%BA%81%E7%89%9F%E5%B3%B7%EA%9D%B7%EC%A4%9C%E0%BC%BA%EB%BB%B9%ED%84%A9%E8%A5%B9%E8%AF%A0%E3%AC%85%0C%E3%9D%9B%E8%B9%8B%E6%BF%8C%EB%91%98%E7%8B%B3%E7%BB%A8%E2%A7%BB%E6%A3%84%E1%AB%B2%E8%8D%93%E4%BF%98%E9%B9%B9%EF%9A%8B%E8%A5%93");
+        Request req = reqBuilder.build();
+
+        calc.calculateAndAddSignature(req, reqBuilder);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java b/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
index 0083d97ac..726a6bea6 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/StaticOAuthSignatureCalculator.java
@@ -13,33 +13,33 @@
  */
 package org.asynchttpclient.oauth;
 
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
 
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-
 class StaticOAuthSignatureCalculator implements SignatureCalculator {
 
-  private final ConsumerKey consumerKey;
-  private final RequestToken requestToken;
-  private final String nonce;
-  private final long timestamp;
+    private final ConsumerKey consumerKey;
+    private final RequestToken requestToken;
+    private final String nonce;
+    private final long timestamp;
 
-  StaticOAuthSignatureCalculator(ConsumerKey consumerKey, RequestToken requestToken, String nonce, long timestamp) {
-    this.consumerKey = consumerKey;
-    this.requestToken = requestToken;
-    this.nonce = nonce;
-    this.timestamp = timestamp;
-  }
+    public StaticOAuthSignatureCalculator(ConsumerKey consumerKey, RequestToken requestToken, String nonce, long timestamp) {
+        this.consumerKey = consumerKey;
+        this.requestToken = requestToken;
+        this.nonce = nonce;
+        this.timestamp = timestamp;
+    }
 
-  @Override
-  public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
-    try {
-      new OAuthSignatureCalculatorInstance().sign(consumerKey, requestToken, request, requestBuilder, timestamp, nonce);
-    } catch (InvalidKeyException | NoSuchAlgorithmException e) {
-      throw new IllegalArgumentException(e);
+    @Override
+    public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
+        try {
+            new OAuthSignatureCalculatorInstance().sign(consumerKey, requestToken, request, requestBuilder, timestamp, nonce);
+        } catch (InvalidKeyException | NoSuchAlgorithmException e) {
+            throw new IllegalArgumentException(e);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
index 481767022..07fd4e080 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
@@ -12,7 +12,15 @@
  */
 package org.asynchttpclient.proxy;
 
-import org.asynchttpclient.*;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
 import org.eclipse.jetty.server.Server;
@@ -22,79 +30,74 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
-import static org.testng.Assert.assertEquals;
-
 /**
  * Proxy usage tests.
  */
 public class HttpsProxyTest extends AbstractBasicTest {
 
-  private Server server2;
-
-  public AbstractHandler configureHandler() throws Exception {
-    return new ConnectHandler();
-  }
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(configureHandler());
-    server.start();
-    port1 = connector.getLocalPort();
-
-    server2 = new Server();
-    ServerConnector connector2 = addHttpsConnector(server2);
-    server2.setHandler(new EchoHandler());
-    server2.start();
-    port2 = connector2.getLocalPort();
-
-    logger.info("Local HTTP server started successfully");
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    server.stop();
-    server2.stop();
-  }
-
-  @Test
-  public void testRequestProxy() throws Exception {
-
-    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true))) {
-      RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
-      Response r = asyncHttpClient.executeRequest(rb.build()).get();
-      assertEquals(r.getStatusCode(), 200);
+    private Server server2;
+
+    public AbstractHandler configureHandler() throws Exception {
+        return new ConnectHandler();
     }
-  }
-
-  @Test
-  public void testConfigProxy() throws Exception {
-    AsyncHttpClientConfig config = config()
-            .setFollowRedirect(true)
-            .setProxyServer(proxyServer("localhost", port1).build())
-            .setUseInsecureTrustManager(true)
-            .build();
-    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
-      Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
-      assertEquals(r.getStatusCode(), 200);
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(configureHandler());
+        server.start();
+        port1 = connector.getLocalPort();
+
+        server2 = new Server();
+        ServerConnector connector2 = addHttpsConnector(server2);
+        server2.setHandler(new EchoHandler());
+        server2.start();
+        port2 = connector2.getLocalPort();
+
+        logger.info("Local HTTP server started successfully");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        server.stop();
+        server2.stop();
+    }
+
+    @Test(groups = "standalone")
+    public void testRequestProxy() throws Exception {
+
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true))) {
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
+            Response r = asyncHttpClient.executeRequest(rb.build()).get();
+            assertEquals(r.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testConfigProxy() throws Exception {
+        AsyncHttpClientConfig config = config()//
+                .setFollowRedirect(true)//
+                .setProxyServer(proxyServer("localhost", port1).build())//
+                .setUseInsecureTrustManager(true)//
+                .build();
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
+            Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
+            assertEquals(r.getStatusCode(), 200);
+        }
     }
-  }
 
-  @Test
-  public void testPooledConnectionsWithProxy() throws Exception {
+    @Test(groups = "standalone")
+    public void testPooledConnectionsWithProxy() throws Exception {
 
-    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true).setKeepAlive(true))) {
-      RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setUseInsecureTrustManager(true).setKeepAlive(true))) {
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
 
-      Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
-      assertEquals(r1.getStatusCode(), 200);
+            Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
+            assertEquals(r1.getStatusCode(), 200);
 
-      Response r2 = asyncHttpClient.executeRequest(rb.build()).get();
-      assertEquals(r2.getStatusCode(), 200);
+            Response r2 = asyncHttpClient.executeRequest(rb.build()).get();
+            assertEquals(r2.getStatusCode(), 200);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
index 60f361560..66eb67217 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
@@ -13,94 +13,100 @@
  */
 package org.asynchttpclient.proxy;
 
-import org.asynchttpclient.*;
-import org.eclipse.jetty.http.HttpStatus;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
+import java.net.UnknownHostException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.*;
-
-public class NTLMProxyTest extends AbstractBasicTest {
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new NTLMProxyHandler();
-  }
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.http.HttpStatus;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.Assert;
+import org.testng.annotations.Test;
 
-  @Test
-  public void ntlmProxyTest() throws IOException, InterruptedException, ExecutionException {
+public class NTLMProxyTest extends AbstractBasicTest {
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Request request = get("http://localhost").setProxyServer(ntlmProxy()).build();
-      Future<Response> responseFuture = client.executeRequest(request);
-      int status = responseFuture.get().getStatusCode();
-      Assert.assertEquals(status, 200);
+    public static class NTLMProxyHandler extends AbstractHandler {
+        
+        private AtomicInteger state = new AtomicInteger();
+
+        @Override
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
+                ServletException {
+            
+            String authorization = httpRequest.getHeader("Proxy-Authorization");
+
+            boolean asExpected = false;
+            
+            switch (state.getAndIncrement()) {
+                case 0:
+                    if (authorization == null) {
+                        httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
+                        httpResponse.setHeader("Proxy-Authenticate", "NTLM");
+                        asExpected = true;
+                    }
+                    break;
+                    
+                case 1:
+                    if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
+                        httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
+                        httpResponse.setHeader("Proxy-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+                        asExpected = true;
+                    }
+                    break;
+                    
+                case 2:
+                    if (authorization
+                            .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
+                        httpResponse.setStatus(HttpStatus.OK_200);
+                        asExpected = true;
+                    }
+                    break;
+                
+                default:
+            }
+            
+            if (!asExpected) {
+                httpResponse.setStatus(HttpStatus.FORBIDDEN_403);
+            }
+            httpResponse.setContentLength(0);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
     }
-  }
-
-  private ProxyServer ntlmProxy() {
-    Realm realm = ntlmAuthRealm("Zaphod", "Beeblebrox")
-            .setNtlmDomain("Ursa-Minor")
-            .setNtlmHost("LightCity")
-            .build();
-    return proxyServer("localhost", port2).setRealm(realm).build();
-  }
-
-  public static class NTLMProxyHandler extends AbstractHandler {
-
-    private AtomicInteger state = new AtomicInteger();
 
     @Override
-    public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
-            ServletException {
-
-      String authorization = httpRequest.getHeader("Proxy-Authorization");
-
-      boolean asExpected = false;
-
-      switch (state.getAndIncrement()) {
-        case 0:
-          if (authorization == null) {
-            httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
-            httpResponse.setHeader("Proxy-Authenticate", "NTLM");
-            asExpected = true;
-          }
-          break;
-
-        case 1:
-          if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
-            httpResponse.setStatus(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407);
-            httpResponse.setHeader("Proxy-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
-            asExpected = true;
-          }
-          break;
+    public AbstractHandler configureHandler() throws Exception {
+        return new NTLMProxyHandler();
+    }
 
-        case 2:
-          if (authorization
-                  .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAEkARwBIAFQAQwBJAFQAWQA=")) {
-            httpResponse.setStatus(HttpStatus.OK_200);
-            asExpected = true;
-          }
-          break;
+    @Test(groups = "standalone")
+    public void ntlmProxyTest() throws IOException, InterruptedException, ExecutionException {
 
-        default:
-      }
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Request request = get("http://localhost").setProxyServer(ntlmProxy()).build();
+            Future<Response> responseFuture = client.executeRequest(request);
+            int status = responseFuture.get().getStatusCode();
+            Assert.assertEquals(status, 200);
+        }
+    }
 
-      if (!asExpected) {
-        httpResponse.setStatus(HttpStatus.FORBIDDEN_403);
-      }
-      httpResponse.setContentLength(0);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
+    private ProxyServer ntlmProxy() throws UnknownHostException {
+        Realm realm = ntlmAuthRealm("Zaphod", "Beeblebrox")//
+                .setNtlmDomain("Ursa-Minor")//
+                .setNtlmHost("LightCity")//
+                .build();
+        return proxyServer("localhost", port2).setRealm(realm).build();
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index 0dd33ae20..d4a29e87b 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -15,24 +15,17 @@
  */
 package org.asynchttpclient.proxy;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
-import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
-import org.asynchttpclient.testserver.SocksProxy;
-import org.asynchttpclient.util.ProxyUtils;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.net.*;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.ExecutionException;
@@ -40,318 +33,311 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
+import org.asynchttpclient.util.ProxyUtils;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Proxy usage tests.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class ProxyTest extends AbstractBasicTest {
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new ProxyHandler();
-  }
-
-  @Test
-  public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String target = "http://localhost:1234/";
-      Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
+    public static class ProxyHandler extends AbstractHandler {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("GET".equalsIgnoreCase(request.getMethod())) {
+                response.addHeader("target", r.getHttpURI().getPath());
+                response.setStatus(HttpServletResponse.SC_OK);
+            } else {
+                // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
+            r.setHandled(true);
+        }
     }
-  }
-
-  // @Test
-  // public void asyncDoPostProxyTest() throws Throwable {
-  // try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
-  // HttpHeaders h = new DefaultHttpHeaders();
-  // h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
-  // StringBuilder sb = new StringBuilder();
-  // for (int i = 0; i < 5; i++) {
-  // sb.append("param_").append(i).append("=value_").append(i).append("&");
-  // }
-  // sb.setLength(sb.length() - 1);
-  //
-  // Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
-  // @Override
-  // public Response onCompleted(Response response) throws Throwable {
-  // return response;
-  // }
-  //
-  // @Override
-  // public void onThrowable(Throwable t) {
-  // }
-  // }).get();
-  //
-  // assertEquals(response.getStatusCode(), 200);
-  // assertEquals(response.getHeader("X-" + CONTENT_TYPE), APPLICATION_X_WWW_FORM_URLENCODED);
-  // }
-  // }
-
-  @Test
-  public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
-      String target = "http://localhost:1234/";
-      Future<Response> f = client.prepareGet(target).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ProxyHandler();
     }
-  }
-
-  @Test
-  public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
-      String target = "http://localhost:1234/";
-      Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
+
+    // @Test
+    // public void asyncDoPostProxyTest() throws Throwable {
+    // try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
+    // HttpHeaders h = new DefaultHttpHeaders();
+    // h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+    // StringBuilder sb = new StringBuilder();
+    // for (int i = 0; i < 5; i++) {
+    // sb.append("param_").append(i).append("=value_").append(i).append("&");
+    // }
+    // sb.setLength(sb.length() - 1);
+    //
+    // Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+    // @Override
+    // public Response onCompleted(Response response) throws Throwable {
+    // return response;
+    // }
+    //
+    // @Override
+    // public void onThrowable(Throwable t) {
+    // }
+    // }).get();
+    //
+    // assertEquals(response.getStatusCode(), 200);
+    // assertEquals(response.getHeader("X-" + CONTENT_TYPE), APPLICATION_X_WWW_FORM_URLENCODED);
+    // }
+    // }
+    
+    @Test(groups = "standalone")
+    public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        }
     }
-  }
 
-  @Test
-  public void testNonProxyHost() {
+    @Test(groups = "standalone")
+    public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        }
+    }
 
-    // // should avoid, it's in non-proxy hosts
-    Request req = get("http://somewhere.com/foo").build();
-    ProxyServer proxyServer = proxyServer("localhost", 1234).setNonProxyHost("somewhere.com").build();
-    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
-    //
-    // // should avoid, it's in non-proxy hosts (with "*")
-    req = get("http://sub.somewhere.com/foo").build();
-    proxyServer = proxyServer("localhost", 1234).setNonProxyHost("*.somewhere.com").build();
-    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
-
-    // should use it
-    req = get("http://sub.somewhere.com/foo").build();
-    proxyServer = proxyServer("localhost", 1234).setNonProxyHost("*.somewhere.com").build();
-    assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
-  }
-
-  @Test
-  public void testNonProxyHostsRequestOverridesConfig() {
-
-    ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
-    ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
-      String target = "http://localhost:1234/";
-      client.prepareGet(target).setProxyServer(requestProxy).execute().get();
-      assertFalse(true);
-    } catch (Throwable e) {
-      assertNotNull(e.getCause());
-      assertEquals(e.getCause().getClass(), ConnectException.class);
+    @Test(groups = "standalone")
+    public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        }
     }
-  }
-
-  @Test
-  public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-
-    ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String target = "http://localhost:" + port1 + "/";
-      Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
+
+    @Test(groups = "standalone")
+    public void testNonProxyHost() {
+
+        // // should avoid, it's in non-proxy hosts
+        Request req = get("http://somewhere.com/foo").build();
+        ProxyServer proxyServer = proxyServer("foo", 1234).setNonProxyHost("somewhere.com").build();
+        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+        //
+        // // should avoid, it's in non-proxy hosts (with "*")
+        req = get("http://sub.somewhere.com/foo").build();
+        proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
+        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
+
+        // should use it
+        req = get("http://sub.somewhere.com/foo").build();
+        proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
+        assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
     }
-  }
-
-  @Test
-  public void runSequentiallyBecauseNotThreadSafe() throws Exception {
-    testProxyProperties();
-    testIgnoreProxyPropertiesByDefault();
-    testProxyActivationProperty();
-    testWildcardNonProxyHosts();
-    testUseProxySelector();
-  }
-
-  @Test(enabled = false)
-  public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    // FIXME not threadsafe!
-    Properties originalProps = new Properties();
-    originalProps.putAll(System.getProperties());
-    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-    AsyncHttpClientConfigHelper.reloadProperties();
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-      String proxifiedtarget = "http://127.0.0.1:1234/";
-      Future<Response> f = client.prepareGet(proxifiedtarget).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
-
-      String nonProxifiedtarget = "http://localhost:1234/";
-      f = client.prepareGet(nonProxifiedtarget).execute();
-      try {
-        f.get(3, TimeUnit.SECONDS);
-        fail("should not be able to connect");
-      } catch (ExecutionException e) {
-        // ok, no proxy used
-      }
-    } finally {
-      System.setProperties(originalProps);
+
+    @Test(groups = "standalone")
+    public void testNonProxyHostsRequestOverridesConfig() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+
+        ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
+        ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
+            String target = "http://localhost:1234/";
+            client.prepareGet(target).setProxyServer(requestProxy).execute().get();
+            assertFalse(true);
+        } catch (Throwable e) {
+            assertNotNull(e.getCause());
+            assertEquals(e.getCause().getClass(), ConnectException.class);
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void testIgnoreProxyPropertiesByDefault() throws IOException, TimeoutException, InterruptedException {
-    // FIXME not threadsafe!
-    Properties originalProps = new Properties();
-    originalProps.putAll(System.getProperties());
-    System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
-    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-    AsyncHttpClientConfigHelper.reloadProperties();
-
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String target = "http://localhost:1234/";
-      Future<Response> f = client.prepareGet(target).execute();
-      try {
-        f.get(3, TimeUnit.SECONDS);
-        fail("should not be able to connect");
-      } catch (ExecutionException e) {
-        // ok, no proxy used
-      }
-    } finally {
-      System.setProperties(originalProps);
+
+    @Test(groups = "standalone")
+    public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+
+        ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String target = "http://localhost:" + port1 + "/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    // FIXME not threadsafe!
-    Properties originalProps = new Properties();
-    originalProps.putAll(System.getProperties());
-    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
-    System.setProperty(AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties", "true");
-    AsyncHttpClientConfigHelper.reloadProperties();
-
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String proxifiedTarget = "http://127.0.0.1:1234/";
-      Future<Response> f = client.prepareGet(proxifiedTarget).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
-
-      String nonProxifiedTarget = "http://localhost:1234/";
-      f = client.prepareGet(nonProxifiedTarget).execute();
-      try {
-        f.get(3, TimeUnit.SECONDS);
-        fail("should not be able to connect");
-      } catch (ExecutionException e) {
-        // ok, no proxy used
-      }
-    } finally {
-      System.setProperties(originalProps);
+
+    @Test(groups = "standalone")
+    public void runSequentiallyBecauseNotThreadSafe() throws Exception {
+        testProxyProperties();
+        testIgnoreProxyPropertiesByDefault();
+        testProxyActivationProperty();
+        testWildcardNonProxyHosts();
+        testUseProxySelector();
+    }
+
+    // @Test(groups = "standalone")
+    public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
+            String proxifiedtarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedtarget).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+
+            String nonProxifiedtarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedtarget).execute();
+            try {
+                resp = f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
+            }
+        } finally {
+            System.setProperties(originalProps);
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void testWildcardNonProxyHosts() throws IOException, TimeoutException, InterruptedException {
-    // FIXME not threadsafe!
-    Properties originalProps = new Properties();
-    originalProps.putAll(System.getProperties());
-    System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
-    System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
-    System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "127.*");
-    AsyncHttpClientConfigHelper.reloadProperties();
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-      String nonProxifiedTarget = "http://127.0.0.1:1234/";
-      Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
-      try {
-        f.get(3, TimeUnit.SECONDS);
-        fail("should not be able to connect");
-      } catch (ExecutionException e) {
-        // ok, no proxy used
-      }
-    } finally {
-      System.setProperties(originalProps);
+
+    // @Test(groups = "standalone")
+    public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            try {
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
+            }
+        } finally {
+            System.setProperties(originalProps);
+        }
     }
-  }
-
-  @Test(enabled = false)
-  public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-    ProxySelector originalProxySelector = ProxySelector.getDefault();
-    ProxySelector.setDefault(new ProxySelector() {
-      public List<Proxy> select(URI uri) {
-        if (uri.getHost().equals("127.0.0.1")) {
-          return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", port1)));
-        } else {
-          return Collections.singletonList(Proxy.NO_PROXY);
+
+    @Test(groups = "standalone", enabled = false)
+    public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        System.setProperty(AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties", "true");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
+            try {
+                resp = f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
+            }
+        } finally {
+            System.setProperties(originalProps);
         }
-      }
-
-      public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-      }
-    });
-
-    try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
-      String proxifiedTarget = "http://127.0.0.1:1234/";
-      Future<Response> f = client.prepareGet(proxifiedTarget).execute();
-      Response resp = f.get(3, TimeUnit.SECONDS);
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("target"), "/");
-
-      String nonProxifiedTarget = "http://localhost:1234/";
-      f = client.prepareGet(nonProxifiedTarget).execute();
-      try {
-        f.get(3, TimeUnit.SECONDS);
-        fail("should not be able to connect");
-      } catch (ExecutionException e) {
-        // ok, no proxy used
-      }
-    } finally {
-      // FIXME not threadsafe
-      ProxySelector.setDefault(originalProxySelector);
     }
-  }
-
-  @Test
-  public void runSocksProxy() throws Exception {
-    new Thread(() -> {
-      try {
-        new SocksProxy(60000);
-      } catch (IOException e) {
-        e.printStackTrace();
-      }
-    }).start();
-
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      String target = "http://localhost:" + port1 + "/";
-      Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer.Builder("localhost", 8000).setProxyType(ProxyType.SOCKS_V4)).execute();
-
-      assertEquals(200, f.get(60, TimeUnit.SECONDS).getStatusCode());
+
+    // @Test(groups = "standalone")
+    public void testWildcardNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "127.*");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
+            String nonProxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
+            try {
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
+            }
+        } finally {
+            System.setProperties(originalProps);
+        }
     }
-  }
-
-  public static class ProxyHandler extends AbstractHandler {
-    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("GET".equalsIgnoreCase(request.getMethod())) {
-        response.addHeader("target", r.getHttpURI().getPath());
-        response.setStatus(HttpServletResponse.SC_OK);
-      } else {
-        // this handler is to handle POST request
-        response.sendError(HttpServletResponse.SC_FORBIDDEN);
-      }
-      r.setHandled(true);
+
+    // @Test(groups = "standalone")
+    public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        ProxySelector originalProxySelector = ProxySelector.getDefault();
+        ProxySelector.setDefault(new ProxySelector() {
+            public List<Proxy> select(URI uri) {
+                if (uri.getHost().equals("127.0.0.1")) {
+                    return Arrays.asList(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", port1)));
+                } else {
+                    return Arrays.asList(Proxy.NO_PROXY);
+                }
+            }
+
+            public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+            }
+        });
+
+        try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
+            try {
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
+            }
+        } finally {
+            // FIXME not threadsafe
+            ProxySelector.setDefault(originalProxySelector);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
index 860678b35..cc3626360 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
@@ -12,11 +12,25 @@
  */
 package org.asynchttpclient.reactivestreams;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.testng.Assert.assertTrue;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.handler.StreamedResponsePublisher;
+import org.asynchttpclient.netty.request.NettyRequest;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleStreamedAsyncHandler;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleSubscriber;
 import org.reactivestreams.Publisher;
@@ -24,101 +38,150 @@
 import org.slf4j.LoggerFactory;
 import org.testng.annotations.Test;
 
-import java.lang.reflect.Field;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
+public class FailingReactiveStreamsTest extends AbstractBasicTest {
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
-import static org.testng.Assert.assertTrue;
+    @Test(groups = "standalone")
+    public void testRetryingOnFailingStream() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
+            final CountDownLatch streamOnHold = new CountDownLatch(1); // allows us to hold the subscriber from processing further body chunks
+            final CountDownLatch replayingRequest = new CountDownLatch(1); // allows us to block until the request is being replayed ( this is what we want to test here!)
+
+            // a ref to the publisher is needed to get a hold on the channel (if there is a better way, this should be changed)
+            final AtomicReference<StreamedResponsePublisher> publisherRef = new AtomicReference<>(null);
+
+            // executing the request
+            client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
+                    .execute(new ReplayedSimpleAsyncHandler(replayingRequest, new BlockedStreamSubscriber(streamStarted, streamOnHold)) {
+                        @Override
+                        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+                            if (!(publisher instanceof StreamedResponsePublisher)) {
+                                throw new IllegalStateException(String.format("publisher %s is expected to be an instance of %s", publisher, StreamedResponsePublisher.class));
+                            } else if (!publisherRef.compareAndSet(null, (StreamedResponsePublisher) publisher)) {
+                                // abort on retry
+                                return State.ABORT;
+                            }
+                            return super.onStream(publisher);
+                        }
+                    });
+
+            // before proceeding, wait for the subscriber to receive at least one body chunk
+            streamStarted.await();
+            // The stream has started, hence `StreamedAsyncHandler.onStream(publisher)` was called, and `publisherRef` was initialized with the `publisher` passed to `onStream`
+            assertTrue(publisherRef.get() != null, "Expected a not null publisher.");
+
+            // close the channel to emulate a connection crash while the response body chunks were being received.
+            StreamedResponsePublisher publisher = publisherRef.get();
+            final CountDownLatch channelClosed = new CountDownLatch(1);
+
+            getChannel(publisher).close().addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    channelClosed.countDown();
+                }
+            });
+            streamOnHold.countDown(); // the subscriber is set free to process new incoming body chunks.
+            channelClosed.await(); // the channel is confirmed to be closed
 
-public class FailingReactiveStreamsTest extends AbstractBasicTest {
+            // now we expect a new connection to be created and AHC retry logic to kick-in automatically
+            replayingRequest.await(); // wait until we are notified the request is being replayed
 
-  @Test
-  public void testRetryingOnFailingStream() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
-      final CountDownLatch streamOnHold = new CountDownLatch(1); // allows us to hold the subscriber from processing further body chunks
-      final CountDownLatch replayingRequest = new CountDownLatch(1); // allows us to block until the request is being replayed ( this is what we want to test here!)
+            // Change this if there is a better way of stating the test succeeded
+            assertTrue(true);
+        }
+    }
 
-      // a ref to the publisher is needed to get a hold on the channel (if there is a better way, this should be changed)
-      final AtomicReference<StreamedResponsePublisher> publisherRef = new AtomicReference<>(null);
+    private Channel getChannel(StreamedResponsePublisher publisher) throws Exception {
+        Field field = publisher.getClass().getDeclaredField("channel");
+        field.setAccessible(true);
+        return (Channel) field.get(publisher);
+    }
 
-      // executing the request
-      client.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
-              .execute(new ReplayedSimpleAsyncHandler(replayingRequest, new BlockedStreamSubscriber(streamStarted, streamOnHold)) {
-                @Override
-                public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-                  if (!(publisher instanceof StreamedResponsePublisher)) {
-                    throw new IllegalStateException(String.format("publisher %s is expected to be an instance of %s", publisher, StreamedResponsePublisher.class));
-                  } else if (!publisherRef.compareAndSet(null, (StreamedResponsePublisher) publisher)) {
-                    // abort on retry
-                    return State.ABORT;
-                  }
-                  return super.onStream(publisher);
-                }
-              });
+    private static class BlockedStreamSubscriber extends SimpleSubscriber<HttpResponseBodyPart> {
+        private static final Logger LOGGER = LoggerFactory.getLogger(BlockedStreamSubscriber.class);
+        private final CountDownLatch streamStarted;
+        private final CountDownLatch streamOnHold;
+
+        public BlockedStreamSubscriber(CountDownLatch streamStarted, CountDownLatch streamOnHold) {
+            this.streamStarted = streamStarted;
+            this.streamOnHold = streamOnHold;
+        }
+
+        @Override
+        public void onNext(HttpResponseBodyPart t) {
+            streamStarted.countDown();
+            try {
+                streamOnHold.await();
+            } catch (InterruptedException e) {
+                LOGGER.error("`streamOnHold` latch was interrupted", e);
+            }
+            super.onNext(t);
+        }
+    }
 
-      // before proceeding, wait for the subscriber to receive at least one body chunk
-      streamStarted.await();
-      // The stream has started, hence `StreamedAsyncHandler.onStream(publisher)` was called, and `publisherRef` was initialized with the `publisher` passed to `onStream`
-      assertTrue(publisherRef.get() != null, "Expected a not null publisher.");
+    private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler implements AsyncHandlerExtensions {
+        private final CountDownLatch replaying;
 
-      // close the channel to emulate a connection crash while the response body chunks were being received.
-      StreamedResponsePublisher publisher = publisherRef.get();
-      final CountDownLatch channelClosed = new CountDownLatch(1);
+        public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            super(subscriber);
+            this.replaying = replaying;
+        }
 
-      getChannel(publisher).close().addListener(future-> channelClosed.countDown());
-      streamOnHold.countDown(); // the subscriber is set free to process new incoming body chunks.
-      channelClosed.await(); // the channel is confirmed to be closed
+        @Override
+        public void onHostnameResolutionAttempt(String name) {
+        }
 
-      // now we expect a new connection to be created and AHC retry logic to kick-in automatically
-      replayingRequest.await(); // wait until we are notified the request is being replayed
+        @Override
+        public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+        }
 
-      // Change this if there is a better way of stating the test succeeded
-      assertTrue(true);
-    }
-  }
-
-  private Channel getChannel(StreamedResponsePublisher publisher) throws Exception {
-    Field field = publisher.getClass().getDeclaredField("channel");
-    field.setAccessible(true);
-    return (Channel) field.get(publisher);
-  }
-
-  private static class BlockedStreamSubscriber extends SimpleSubscriber<HttpResponseBodyPart> {
-    private static final Logger LOGGER = LoggerFactory.getLogger(BlockedStreamSubscriber.class);
-    private final CountDownLatch streamStarted;
-    private final CountDownLatch streamOnHold;
-
-    BlockedStreamSubscriber(CountDownLatch streamStarted, CountDownLatch streamOnHold) {
-      this.streamStarted = streamStarted;
-      this.streamOnHold = streamOnHold;
-    }
+        @Override
+        public void onHostnameResolutionFailure(String name, Throwable cause) {
+        }
 
-    @Override
-    public void onNext(HttpResponseBodyPart t) {
-      streamStarted.countDown();
-      try {
-        streamOnHold.await();
-      } catch (InterruptedException e) {
-        LOGGER.error("`streamOnHold` latch was interrupted", e);
-      }
-      super.onNext(t);
-    }
-  }
+        @Override
+        public void onTcpConnectAttempt(InetSocketAddress address) {
+        }
 
-  private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler {
-    private final CountDownLatch replaying;
+        @Override
+        public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
+        }
 
-    ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-      super(subscriber);
-      this.replaying = replaying;
-    }
+        @Override
+        public void onTcpConnectFailure(InetSocketAddress address, Throwable cause) {
+        }
+
+        @Override
+        public void onTlsHandshakeAttempt() {
+        }
+
+        @Override
+        public void onTlsHandshakeSuccess() {
+        }
+
+        @Override
+        public void onTlsHandshakeFailure(Throwable cause) {
+        }
+
+        @Override
+        public void onConnectionPoolAttempt() {
+        }
+
+        @Override
+        public void onConnectionPooled(Channel connection) {
+        }
+
+        @Override
+        public void onConnectionOffer(Channel connection) {
+        }
+
+        @Override
+        public void onRequestSend(NettyRequest request) {
+        }
 
-    @Override
-    public void onRetry() {
-      replaying.countDown();
+        @Override
+        public void onRetry() {
+            replaying.countDown();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
index 47ee73f3c..1a10e2896 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
@@ -22,37 +22,38 @@
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.util.concurrent.Future;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public final class HttpStaticFileServer {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(HttpStaticFileServer.class);
-
-  static private EventLoopGroup bossGroup;
-  static private EventLoopGroup workerGroup;
-
-  public static void start(int port) throws Exception {
-    bossGroup = new NioEventLoopGroup(1);
-    workerGroup = new NioEventLoopGroup();
-    ServerBootstrap b = new ServerBootstrap();
-    b.group(bossGroup, workerGroup)
-            .channel(NioServerSocketChannel.class)
-            .handler(new LoggingHandler(LogLevel.INFO))
-            .childHandler(new HttpStaticFileServerInitializer());
-
-    b.bind(port).sync().channel();
-    LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
-  }
-
-  public static void shutdown() {
-    Future<?> bossFuture = bossGroup.shutdownGracefully();
-    Future<?> workerFuture = workerGroup.shutdownGracefully();
-    try {
-      bossFuture.await();
-      workerFuture.await();
-    } catch (InterruptedException e) {
-      e.printStackTrace();
+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpStaticFileServer.class);
+
+    static private EventLoopGroup bossGroup;
+    static private EventLoopGroup workerGroup;
+
+    public static void start(int port) throws Exception {
+        bossGroup = new NioEventLoopGroup(1);
+        workerGroup = new NioEventLoopGroup();
+        ServerBootstrap b = new ServerBootstrap();
+        b.group(bossGroup, workerGroup)//
+                .channel(NioServerSocketChannel.class)//
+                .handler(new LoggingHandler(LogLevel.INFO))//
+                .childHandler(new HttpStaticFileServerInitializer());
+
+        b.bind(port).sync().channel();
+        LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
+    }
+
+    public static void shutdown() {
+        Future<?> bossFuture = bossGroup.shutdownGracefully();
+        Future<?> workerFuture = workerGroup.shutdownGracefully();
+        try {
+            bossFuture.await();
+            workerFuture.await();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
index 4e930b191..3f8cbde6c 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
@@ -15,29 +15,49 @@
  */
 package org.asynchttpclient.reactivestreams;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static io.netty.handler.codec.http.HttpMethod.GET;
+import static io.netty.handler.codec.http.HttpResponseStatus.*;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.*;
-import io.netty.handler.codec.http.*;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelProgressiveFuture;
+import io.netty.channel.ChannelProgressiveFutureListener;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpChunkedInput;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpUtil;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedFile;
 import io.netty.util.CharsetUtil;
-import org.asynchttpclient.test.TestUtils;
 
-import javax.activation.MimetypesFileTypeMap;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.RandomAccessFile;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
 import java.util.regex.Pattern;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpMethod.GET;
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+import javax.activation.MimetypesFileTypeMap;
+
+import org.asynchttpclient.test.TestUtils;
 
 
 /**
@@ -45,22 +65,22 @@
  * HTTP responses.  It also implements {@code 'If-Modified-Since'} header to
  * take advantage of browser cache, as described in
  * <a href="http://tools.ietf.org/html/rfc2616#section-14.25">RFC 2616</a>.
- * <p>
+ *
  * <h3>How Browser Caching Works</h3>
- * <p>
+ *
  * Web browser caching works with HTTP headers as illustrated by the following
  * sample:
  * <ol>
  * <li>Request #1 returns the content of {@code /file1.txt}.</li>
  * <li>Contents of {@code /file1.txt} is cached by the browser.</li>
  * <li>Request #2 for {@code /file1.txt} does return the contents of the
- * file again. Rather, a 304 Not Modified is returned. This tells the
- * browser to use the contents stored in its cache.</li>
+ *     file again. Rather, a 304 Not Modified is returned. This tells the
+ *     browser to use the contents stored in its cache.</li>
  * <li>The server knows the file has not been modified because the
- * {@code If-Modified-Since} date is the same as the file's last
- * modified date.</li>
+ *     {@code If-Modified-Since} date is the same as the file's last
+ *     modified date.</li>
  * </ol>
- * <p>
+ *
  * <pre>
  * Request #1 Headers
  * ===================
@@ -88,46 +108,170 @@
  */
 public class HttpStaticFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {
 
-  private static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
-  private static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
-  private static final int HTTP_CACHE_SECONDS = 60;
-  private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
-  private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9.]*");
-
-  private static String sanitizeUri(String uri) {
-    // Decode the path.
-    try {
-      uri = URLDecoder.decode(uri, "UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new Error(e);
+    public static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
+    public static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
+    public static final int HTTP_CACHE_SECONDS = 60;
+
+    @Override
+    public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
+        if (!request.decoderResult().isSuccess()) {
+            sendError(ctx, BAD_REQUEST);
+            return;
+        }
+
+        if (request.method() != GET) {
+            sendError(ctx, METHOD_NOT_ALLOWED);
+            return;
+        }
+
+        final String uri = request.uri();
+        final String path = sanitizeUri(uri);
+        if (path == null) {
+            sendError(ctx, FORBIDDEN);
+            return;
+        }
+
+        File file = new File(path);
+        if (file.isHidden() || !file.exists()) {
+            sendError(ctx, NOT_FOUND);
+            return;
+        }
+
+        if (file.isDirectory()) {
+            if (uri.endsWith("/")) {
+                sendListing(ctx, file);
+            } else {
+                sendRedirect(ctx, uri + '/');
+            }
+            return;
+        }
+
+        if (!file.isFile()) {
+            sendError(ctx, FORBIDDEN);
+            return;
+        }
+
+        // Cache Validation
+        String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
+        if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
+            SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
+
+            // Only compare up to the second because the datetime format we send to the client
+            // does not have milliseconds
+            long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
+            long fileLastModifiedSeconds = file.lastModified() / 1000;
+            if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
+                sendNotModified(ctx);
+                return;
+            }
+        }
+
+        RandomAccessFile raf;
+        try {
+            raf = new RandomAccessFile(file, "r");
+        } catch (FileNotFoundException ignore) {
+            sendError(ctx, NOT_FOUND);
+            return;
+        }
+        long fileLength = raf.length();
+
+        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
+        HttpUtil.setContentLength(response, fileLength);
+        setContentTypeHeader(response, file);
+        setDateAndCacheHeaders(response, file);
+        if (HttpUtil.isKeepAlive(request)) {
+            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
+        }
+
+        // Write the initial line and the header.
+        ctx.write(response);
+
+        // Write the content.
+        ChannelFuture sendFileFuture;
+        ChannelFuture lastContentFuture;
+        if (ctx.pipeline().get(SslHandler.class) == null) {
+            sendFileFuture =
+                    ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
+            // Write the end marker.
+            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
+        } else {
+            sendFileFuture =
+                    ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),
+                            ctx.newProgressivePromise());
+            // HttpChunkedInput will write the end marker (LastHttpContent) for us.
+            lastContentFuture = sendFileFuture;
+        }
+
+        sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
+            @Override
+            public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
+                if (total < 0) { // total unknown
+                    System.err.println(future.channel() + " Transfer progress: " + progress);
+                } else {
+                    System.err.println(future.channel() + " Transfer progress: " + progress + " / " + total);
+                }
+            }
+
+            @Override
+            public void operationComplete(ChannelProgressiveFuture future) {
+                System.err.println(future.channel() + " Transfer complete.");
+            }
+        });
+
+        // Decide whether to close the connection or not.
+        if (!HttpUtil.isKeepAlive(request)) {
+            // Close the connection when the whole content is written out.
+            lastContentFuture.addListener(ChannelFutureListener.CLOSE);
+        }
     }
 
-    if (uri.isEmpty() || uri.charAt(0) != '/') {
-      return null;
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
+        if (ctx.channel().isActive()) {
+            sendError(ctx, INTERNAL_SERVER_ERROR);
+        }
     }
 
-    // Convert file separators.
-    uri = uri.replace('/', File.separatorChar);
+    private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
+
+    private static String sanitizeUri(String uri) {
+        // Decode the path.
+        try {
+            uri = URLDecoder.decode(uri, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new Error(e);
+        }
+
+        if (uri.isEmpty() || uri.charAt(0) != '/') {
+            return null;
+        }
+
+        // Convert file separators.
+        uri = uri.replace('/', File.separatorChar);
 
-    // Simplistic dumb security check.
-    // You will have to do something serious in the production environment.
-    if (uri.contains(File.separator + '.') ||
+        // Simplistic dumb security check.
+        // You will have to do something serious in the production environment.
+        if (uri.contains(File.separator + '.') ||
             uri.contains('.' + File.separator) ||
             uri.charAt(0) == '.' || uri.charAt(uri.length() - 1) == '.' ||
             INSECURE_URI.matcher(uri).matches()) {
-      return null;
+            return null;
+        }
+
+        // Convert to absolute path.
+        return TestUtils.TMP_DIR + File.separator + uri;
     }
 
-    // Convert to absolute path.
-    return TestUtils.TMP_DIR + File.separator + uri;
-  }
+    private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
 
-  private static void sendListing(ChannelHandlerContext ctx, File dir) {
-    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
-    response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
+    private static void sendListing(ChannelHandlerContext ctx, File dir) {
+        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
+        response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
 
-    String dirPath = dir.getPath();
-    StringBuilder buf = new StringBuilder()
+        String dirPath = dir.getPath();
+        StringBuilder buf = new StringBuilder()
             .append("<!DOCTYPE html>\r\n")
             .append("<html><head><title>")
             .append("Listing of: ")
@@ -141,227 +285,111 @@ private static void sendListing(ChannelHandlerContext ctx, File dir) {
             .append("<ul>")
             .append("<li><a href=\"../\">..</a></li>\r\n");
 
-    for (File f : dir.listFiles()) {
-      if (f.isHidden() || !f.canRead()) {
-        continue;
-      }
-
-      String name = f.getName();
-      if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
-        continue;
-      }
-
-      buf.append("<li><a href=\"")
-              .append(name)
-              .append("\">")
-              .append(name)
-              .append("</a></li>\r\n");
-    }
-
-    buf.append("</ul></body></html>\r\n");
-    ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);
-    response.content().writeBytes(buffer);
-    buffer.release();
-
-    // Close the connection as soon as the error message is sent.
-    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-  }
-
-  private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
-    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
-    response.headers().set(LOCATION, newUri);
-
-    // Close the connection as soon as the error message is sent.
-    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-  }
-
-  private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
-    FullHttpResponse response = new DefaultFullHttpResponse(
-            HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8));
-    response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
-
-    // Close the connection as soon as the error message is sent.
-    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-  }
-
-  /**
-   * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified"
-   *
-   * @param ctx Context
-   */
-  private static void sendNotModified(ChannelHandlerContext ctx) {
-    FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED);
-    setDateHeader(response);
-
-    // Close the connection as soon as the error message is sent.
-    ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-  }
-
-  /**
-   * Sets the Date header for the HTTP response
-   *
-   * @param response HTTP response
-   */
-  private static void setDateHeader(FullHttpResponse response) {
-    SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-    dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
-
-    Calendar time = new GregorianCalendar();
-    response.headers().set(DATE, dateFormatter.format(time.getTime()));
-  }
-
-  /**
-   * Sets the Date and Cache headers for the HTTP Response
-   *
-   * @param response    HTTP response
-   * @param fileToCache file to extract content type
-   */
-  private static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {
-    SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-    dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
-
-    // Date header
-    Calendar time = new GregorianCalendar();
-    response.headers().set(DATE, dateFormatter.format(time.getTime()));
-
-    // Add cache headers
-    time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);
-    response.headers().set(EXPIRES, dateFormatter.format(time.getTime()));
-    response.headers().set(CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS);
-    response.headers().set(
-            LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));
-  }
-
-  /**
-   * Sets the content type header for the HTTP Response
-   *
-   * @param response HTTP response
-   * @param file     file to extract content type
-   */
-  private static void setContentTypeHeader(HttpResponse response, File file) {
-    MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
-    response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
-  }
-
-  @Override
-  public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
-    if (!request.decoderResult().isSuccess()) {
-      sendError(ctx, BAD_REQUEST);
-      return;
-    }
+        for (File f: dir.listFiles()) {
+            if (f.isHidden() || !f.canRead()) {
+                continue;
+            }
+
+            String name = f.getName();
+            if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
+                continue;
+            }
+
+            buf.append("<li><a href=\"")
+               .append(name)
+               .append("\">")
+               .append(name)
+               .append("</a></li>\r\n");
+        }
 
-    if (request.method() != GET) {
-      sendError(ctx, METHOD_NOT_ALLOWED);
-      return;
-    }
+        buf.append("</ul></body></html>\r\n");
+        ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);
+        response.content().writeBytes(buffer);
+        buffer.release();
 
-    final String uri = request.uri();
-    final String path = sanitizeUri(uri);
-    if (path == null) {
-      sendError(ctx, FORBIDDEN);
-      return;
+        // Close the connection as soon as the error message is sent.
+        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
-    File file = new File(path);
-    if (file.isHidden() || !file.exists()) {
-      sendError(ctx, NOT_FOUND);
-      return;
-    }
+    private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
+        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
+        response.headers().set(LOCATION, newUri);
 
-    if (file.isDirectory()) {
-      if (uri.endsWith("/")) {
-        sendListing(ctx, file);
-      } else {
-        sendRedirect(ctx, uri + '/');
-      }
-      return;
+        // Close the connection as soon as the error message is sent.
+        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
-    if (!file.isFile()) {
-      sendError(ctx, FORBIDDEN);
-      return;
-    }
+    private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
+        FullHttpResponse response = new DefaultFullHttpResponse(
+                HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8));
+        response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
 
-    // Cache Validation
-    String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
-    if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
-      SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-      Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
-
-      // Only compare up to the second because the datetime format we send to the client
-      // does not have milliseconds
-      long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
-      long fileLastModifiedSeconds = file.lastModified() / 1000;
-      if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
-        sendNotModified(ctx);
-        return;
-      }
+        // Close the connection as soon as the error message is sent.
+        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
-    RandomAccessFile raf;
-    try {
-      raf = new RandomAccessFile(file, "r");
-    } catch (FileNotFoundException ignore) {
-      sendError(ctx, NOT_FOUND);
-      return;
-    }
-    long fileLength = raf.length();
-
-    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
-    HttpUtil.setContentLength(response, fileLength);
-    setContentTypeHeader(response, file);
-    setDateAndCacheHeaders(response, file);
-    if (HttpUtil.isKeepAlive(request)) {
-      response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
+    /**
+     * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified"
+     *
+     * @param ctx
+     *            Context
+     */
+    private static void sendNotModified(ChannelHandlerContext ctx) {
+        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED);
+        setDateHeader(response);
+
+        // Close the connection as soon as the error message is sent.
+        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
-    // Write the initial line and the header.
-    ctx.write(response);
-
-    // Write the content.
-    ChannelFuture sendFileFuture;
-    ChannelFuture lastContentFuture;
-    if (ctx.pipeline().get(SslHandler.class) == null) {
-      sendFileFuture =
-              ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
-      // Write the end marker.
-      lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
-    } else {
-      sendFileFuture =
-              ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),
-                      ctx.newProgressivePromise());
-      // HttpChunkedInput will write the end marker (LastHttpContent) for us.
-      lastContentFuture = sendFileFuture;
+    /**
+     * Sets the Date header for the HTTP response
+     *
+     * @param response
+     *            HTTP response
+     */
+    private static void setDateHeader(FullHttpResponse response) {
+        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
+
+        Calendar time = new GregorianCalendar();
+        response.headers().set(DATE, dateFormatter.format(time.getTime()));
     }
 
-    sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
-      @Override
-      public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
-        if (total < 0) { // total unknown
-          System.err.println(future.channel() + " Transfer progress: " + progress);
-        } else {
-          System.err.println(future.channel() + " Transfer progress: " + progress + " / " + total);
-        }
-      }
-
-      @Override
-      public void operationComplete(ChannelProgressiveFuture future) {
-        System.err.println(future.channel() + " Transfer complete.");
-      }
-    });
-
-    // Decide whether to close the connection or not.
-    if (!HttpUtil.isKeepAlive(request)) {
-      // Close the connection when the whole content is written out.
-      lastContentFuture.addListener(ChannelFutureListener.CLOSE);
+    /**
+     * Sets the Date and Cache headers for the HTTP Response
+     *
+     * @param response
+     *            HTTP response
+     * @param fileToCache
+     *            file to extract content type
+     */
+    private static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {
+        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));
+
+        // Date header
+        Calendar time = new GregorianCalendar();
+        response.headers().set(DATE, dateFormatter.format(time.getTime()));
+
+        // Add cache headers
+        time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);
+        response.headers().set(EXPIRES, dateFormatter.format(time.getTime()));
+        response.headers().set(CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS);
+        response.headers().set(
+                LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));
     }
-  }
 
-  @Override
-  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
-    cause.printStackTrace();
-    if (ctx.channel().isActive()) {
-      sendError(ctx, INTERNAL_SERVER_ERROR);
+    /**
+     * Sets the content type header for the HTTP Response
+     *
+     * @param response
+     *            HTTP response
+     * @param file
+     *            file to extract content type
+     */
+    private static void setContentTypeHeader(HttpResponse response, File file) {
+        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
+        response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
index f7521811d..003cd23a1 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
@@ -24,12 +24,12 @@
 
 public class HttpStaticFileServerInitializer extends ChannelInitializer<SocketChannel> {
 
-  @Override
-  public void initChannel(SocketChannel ch) {
-    ChannelPipeline pipeline = ch.pipeline();
-    pipeline.addLast(new HttpServerCodec());
-    pipeline.addLast(new HttpObjectAggregator(65536));
-    pipeline.addLast(new ChunkedWriteHandler());
-    pipeline.addLast(new HttpStaticFileServerHandler());
-  }
+    @Override
+    public void initChannel(SocketChannel ch) {
+        ChannelPipeline pipeline = ch.pipeline();
+        pipeline.addLast(new HttpServerCodec());
+        pipeline.addLast(new HttpObjectAggregator(65536));
+        pipeline.addLast(new ChunkedWriteHandler());
+        pipeline.addLast(new HttpStaticFileServerHandler());
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index 9a782bfcf..909ca8115 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -13,7 +13,17 @@
  */
 package org.asynchttpclient.reactivestreams;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
@@ -29,155 +39,145 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-
 public class ReactiveStreamsDownLoadTest {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsDownLoadTest.class);
-
-  private int serverPort = 8080;
-  private File largeFile;
-  private File smallFile;
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpBeforeTest() throws Exception {
-    largeFile = TestUtils.createTempFile(15 * 1024);
-    smallFile = TestUtils.createTempFile(20);
-    HttpStaticFileServer.start(serverPort);
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDown() {
-    HttpStaticFileServer.shutdown();
-  }
-
-  @Test
-  public void streamedResponseLargeFileTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
-      ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
-      byte[] result = future.get().getBytes();
-      assertEquals(result.length, largeFile.length());
-    }
-  }
-
-  @Test
-  public void streamedResponseSmallFileTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
-      ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
-      byte[] result = future.get().getBytes();
-      LOGGER.debug("Result file size: " + result.length);
-      assertEquals(result.length, smallFile.length());
-    }
-  }
-
-  static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
-    private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
-
-    SimpleStreamedAsyncHandler() {
-      this(new SimpleSubscriber<>());
-    }
-
-    SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-      this.subscriber = subscriber;
-    }
-
-    @Override
-    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onStream");
-      publisher.subscribe(subscriber);
-      return State.CONTINUE;
-    }
-
-    @Override
-    public void onThrowable(Throwable t) {
-      throw new AssertionError(t);
-    }
-
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
-      throw new AssertionError("Should not have received body part");
-    }
-
-    @Override
-    public State onStatusReceived(HttpResponseStatus responseStatus) {
-      return State.CONTINUE;
-    }
-
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-      return State.CONTINUE;
-    }
-
-    @Override
-    public SimpleStreamedAsyncHandler onCompleted() throws Exception {
-      LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onSubscribe");
-      return this;
-    }
-
-    public byte[] getBytes() throws Throwable {
-      List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
-      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-      for (HttpResponseBodyPart part : bodyParts) {
-        bytes.write(part.getBodyPartBytes());
-      }
-      return bytes.toByteArray();
-    }
-  }
-
-  /**
-   * Simple subscriber that requests and buffers one element at a time.
-   */
-  static protected class SimpleSubscriber<T> implements Subscriber<T> {
-    private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
-    private final CountDownLatch latch = new CountDownLatch(1);
-    private volatile Subscription subscription;
-    private volatile Throwable error;
-
-    @Override
-    public void onSubscribe(Subscription subscription) {
-      LOGGER.debug("SimpleSubscriber onSubscribe");
-      this.subscription = subscription;
-      subscription.request(1);
-    }
-
-    @Override
-    public void onNext(T t) {
-      LOGGER.debug("SimpleSubscriber onNext");
-      elements.add(t);
-      subscription.request(1);
-    }
-
-    @Override
-    public void onError(Throwable error) {
-      LOGGER.error("SimpleSubscriber onError");
-      this.error = error;
-      latch.countDown();
-    }
-
-    @Override
-    public void onComplete() {
-      LOGGER.debug("SimpleSubscriber onComplete");
-      latch.countDown();
-    }
-
-    public List<T> getElements() throws Throwable {
-      latch.await();
-      if (error != null) {
-        throw error;
-      } else {
-        return elements;
-      }
+    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsDownLoadTest.class);
+
+    private int serverPort = 8080;
+    private File largeFile;
+    private File smallFile;
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpBeforeTest() throws Exception {
+        largeFile = TestUtils.createTempFile(15 * 1024);
+        smallFile = TestUtils.createTempFile(20);
+        HttpStaticFileServer.start(serverPort);
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDown() throws Exception {
+        HttpStaticFileServer.shutdown();
+    }
+
+    @Test(groups = "standalone")
+    public void streamedResponseLargeFileTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
+            byte[] result = future.get().getBytes();
+            assertEquals(result.length, largeFile.length());
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void streamedResponseSmallFileTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
+            byte[] result = future.get().getBytes();
+            LOGGER.debug("Result file size: " + result.length);
+            assertEquals(result.length, smallFile.length());
+        }
+    }
+
+    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
+        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+
+        public SimpleStreamedAsyncHandler() {
+            this(new SimpleSubscriber<>());
+        }
+
+        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            this.subscriber = subscriber;
+        }
+
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onStream");
+            publisher.subscribe(subscriber);
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onSubscribe");
+            return this;
+        }
+
+        public byte[] getBytes() throws Throwable {
+            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            for (HttpResponseBodyPart part : bodyParts) {
+                bytes.write(part.getBodyPartBytes());
+            }
+            return bytes.toByteArray();
+        }
+    }
+
+    /**
+     * Simple subscriber that requests and buffers one element at a time.
+     */
+    static protected class SimpleSubscriber<T> implements Subscriber<T> {
+        private volatile Subscription subscription;
+        private volatile Throwable error;
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
+        private final CountDownLatch latch = new CountDownLatch(1);
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            LOGGER.debug("SimpleSubscriber onSubscribe");
+            this.subscription = subscription;
+            subscription.request(1);
+        }
+
+        @Override
+        public void onNext(T t) {
+            LOGGER.debug("SimpleSubscriber onNext");
+            elements.add(t);
+            subscription.request(1);
+        }
+
+        @Override
+        public void onError(Throwable error) {
+            LOGGER.error("SimpleSubscriber onError");
+            this.error = error;
+            latch.countDown();
+        }
+
+        @Override
+        public void onComplete() {
+            LOGGER.debug("SimpleSubscriber onComplete");
+            latch.countDown();
+        }
+
+        public List<T> getElements() throws Throwable {
+            latch.await();
+            if (error != null) {
+                throw error;
+            } else {
+                return elements;
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index 9d7531f64..c54b89180 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -12,14 +12,44 @@
  */
 package org.asynchttpclient.reactivestreams;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.Flowable;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.ReadListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.catalina.Context;
 import org.apache.catalina.Wrapper;
 import org.apache.catalina.startup.Tomcat;
-import org.asynchttpclient.*;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
 import org.asynchttpclient.test.TestUtils;
 import org.reactivestreams.Publisher;
@@ -31,489 +61,472 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ReadListener;
-import javax.servlet.ServletInputStream;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_MD5;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES_MD5;
-import static org.testng.Assert.assertEquals;
-
 public class ReactiveStreamsTest {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
-  private Tomcat tomcat;
-  private int port1;
-
-  private static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
-    return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
-  }
-
-  private static byte[] getBytes(List<HttpResponseBodyPart> bodyParts) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    for (HttpResponseBodyPart part : bodyParts) {
-      bytes.write(part.getBodyPartBytes());
+    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
+
+    public static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
+        return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
+    }
+
+    private Tomcat tomcat;
+    private int port1;
+
+    @SuppressWarnings("serial")
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+
+        String path = new File(".").getAbsolutePath() + "/target";
+
+        tomcat = new Tomcat();
+        tomcat.setHostname("localhost");
+        tomcat.setPort(0);
+        tomcat.setBaseDir(path);
+        Context ctx = tomcat.addContext("", path);
+
+        Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
+
+            @Override
+            public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
+                LOGGER.debug("Echo received request {} on path {}", httpRequest, httpRequest.getServletContext().getContextPath());
+
+                if (httpRequest.getHeader("X-HEAD") != null) {
+                    httpResponse.setContentLength(1);
+                }
+
+                if (httpRequest.getHeader("X-ISO") != null) {
+                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+                } else {
+                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                }
+
+                if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
+                    httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+                }
+
+                Enumeration<String> e = httpRequest.getHeaderNames();
+                String headerName;
+                while (e.hasMoreElements()) {
+                    headerName = e.nextElement();
+                    if (headerName.startsWith("LockThread")) {
+                        final int sleepTime = httpRequest.getIntHeader(headerName);
+                        try {
+                            Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
+                        } catch (InterruptedException ex) {
+                        }
+                    }
+
+                    if (headerName.startsWith("X-redirect")) {
+                        httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+                        return;
+                    }
+                    httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
+                }
+
+                String pathInfo = httpRequest.getPathInfo();
+                if (pathInfo != null)
+                    httpResponse.addHeader("X-pathInfo", pathInfo);
+
+                String queryString = httpRequest.getQueryString();
+                if (queryString != null)
+                    httpResponse.addHeader("X-queryString", queryString);
+
+                httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+
+                Cookie[] cs = httpRequest.getCookies();
+                if (cs != null) {
+                    for (Cookie c : cs) {
+                        httpResponse.addCookie(c);
+                    }
+                }
+
+                Enumeration<String> i = httpRequest.getParameterNames();
+                if (i.hasMoreElements()) {
+                    StringBuilder requestBody = new StringBuilder();
+                    while (i.hasMoreElements()) {
+                        headerName = i.nextElement();
+                        httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
+                        requestBody.append(headerName);
+                        requestBody.append("_");
+                    }
+
+                    if (requestBody.length() > 0) {
+                        String body = requestBody.toString();
+                        httpResponse.getOutputStream().write(body.getBytes());
+                    }
+                }
+
+                final AsyncContext context = httpRequest.startAsync();
+                final ServletInputStream input = httpRequest.getInputStream();
+                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+                input.setReadListener(new ReadListener() {
+
+                    byte[] buffer = new byte[5 * 1024];
+
+                    @Override
+                    public void onError(Throwable t) {
+                        t.printStackTrace();
+                        httpResponse.setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
+                        context.complete();
+                    }
+
+                    @Override
+                    public void onDataAvailable() throws IOException {
+                        int len = -1;
+                        while (input.isReady() && (len = input.read(buffer)) != -1) {
+                            baos.write(buffer, 0, len);
+                        }
+                    }
+
+                    @Override
+                    public void onAllDataRead() throws IOException {
+                        byte[] requestBodyBytes = baos.toByteArray();
+                        int total = requestBodyBytes.length;
+
+                        httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
+                        String md5 = TestUtils.md5(requestBodyBytes, 0, total);
+                        httpResponse.addHeader(CONTENT_MD5.toString(), md5);
+
+                        httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
+                        context.complete();
+                    }
+                });
+            }
+        });
+        wrapper.setAsyncSupported(true);
+        ctx.addServletMappingDecoded("/*", "webdav");
+        tomcat.start();
+        port1 = tomcat.getConnector().getLocalPort();
     }
-    return bytes.toByteArray();
-  }
-
-  @SuppressWarnings("serial")
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-
-    String path = new File(".").getAbsolutePath() + "/target";
-
-    tomcat = new Tomcat();
-    tomcat.setHostname("localhost");
-    tomcat.setPort(0);
-    tomcat.setBaseDir(path);
-    Context ctx = tomcat.addContext("", path);
 
-    Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
-
-      @Override
-      public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-              throws IOException {
-        LOGGER.debug("Echo received request {} on path {}", httpRequest,
-                httpRequest.getServletContext().getContextPath());
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws InterruptedException, Exception {
+        tomcat.stop();
+    }
 
-        if (httpRequest.getHeader("X-HEAD") != null) {
-          httpResponse.setContentLength(1);
-        }
+    private String getTargetUrl() {
+        return String.format("http://localhost:%d/foo/test", port1);
+    }
 
-        if (httpRequest.getHeader("X-ISO") != null) {
-          httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
-        } else {
-          httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+    @Test(groups = "standalone")
+    public void testStreamingPutImage() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
         }
+    }
 
-        if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
-          httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-        }
+    @Test(groups = "standalone")
+    public void testConnectionDoesNotGetClosed() throws Exception {
+        // test that we can stream the same request multiple times
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            String expectedMd5 = TestUtils.md5(LARGE_IMAGE_BYTES);
+            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())//
+                    .setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))//
+                    .setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)//
+                    .setHeader("X-" + CONTENT_MD5, expectedMd5);
+
+            Response response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
+
+            byte[] responseBody = response.getResponseBodyAsBytes();
+            responseBody = response.getResponseBodyAsBytes();
+            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+            assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
+            assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
+            assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
+
+            response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            responseBody = response.getResponseBodyAsBytes();
+            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
 
-        Enumeration<String> e = httpRequest.getHeaderNames();
-        String headerName;
-        while (e.hasMoreElements()) {
-          headerName = e.nextElement();
-          if (headerName.startsWith("LockThread")) {
-            final int sleepTime = httpRequest.getIntHeader(headerName);
             try {
-              Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
-            } catch (InterruptedException ex) {
-              //
+                assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
+                assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
+                assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
+            } catch (AssertionError e) {
+                e.printStackTrace();
+                for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
+                    assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
+                }
+                throw e;
             }
-          }
-
-          if (headerName.startsWith("X-redirect")) {
-            httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-            return;
-          }
-          httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
         }
+    }
 
-        String pathInfo = httpRequest.getPathInfo();
-        if (pathInfo != null)
-          httpResponse.addHeader("X-pathInfo", pathInfo);
-
-        String queryString = httpRequest.getQueryString();
-        if (queryString != null)
-          httpResponse.addHeader("X-queryString", queryString);
-
-        httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-        Cookie[] cs = httpRequest.getCookies();
-        if (cs != null) {
-          for (Cookie c : cs) {
-            httpResponse.addCookie(c);
-          }
+    public static void main(String[] args) throws Exception {
+        ReactiveStreamsTest test = new ReactiveStreamsTest();
+        test.setUpGlobal();
+        try {
+            for (int i = 0; i < 1000; i++) {
+                test.testConnectionDoesNotGetClosed();
+            }
+        } finally {
+            test.tearDownGlobal();
         }
+    }
 
-        Enumeration<String> i = httpRequest.getParameterNames();
-        if (i.hasMoreElements()) {
-          StringBuilder requestBody = new StringBuilder();
-          while (i.hasMoreElements()) {
-            headerName = i.nextElement();
-            httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
-            requestBody.append(headerName);
-            requestBody.append("_");
-          }
-
-          if (requestBody.length() > 0) {
-            String body = requestBody.toString();
-            httpResponse.getOutputStream().write(body.getBytes());
-          }
+    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
+    public void testFailingStream() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
+            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
         }
-
-        final AsyncContext context = httpRequest.startAsync();
-        final ServletInputStream input = httpRequest.getInputStream();
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-
-        input.setReadListener(new ReadListener() {
-
-          byte[] buffer = new byte[5 * 1024];
-
-          @Override
-          public void onError(Throwable t) {
-            t.printStackTrace();
-            httpResponse
-                    .setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
-            context.complete();
-          }
-
-          @Override
-          public void onDataAvailable() throws IOException {
-            int len;
-            while (input.isReady() && (len = input.read(buffer)) != -1) {
-              baos.write(buffer, 0, len);
-            }
-          }
-
-          @Override
-          public void onAllDataRead() throws IOException {
-            byte[] requestBodyBytes = baos.toByteArray();
-            int total = requestBodyBytes.length;
-
-            httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
-            String md5 = TestUtils.md5(requestBodyBytes, 0, total);
-            httpResponse.addHeader(CONTENT_MD5.toString(), md5);
-
-            httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
-            context.complete();
-          }
-        });
-      }
-    });
-    wrapper.setAsyncSupported(true);
-    ctx.addServletMappingDecoded("/*", "webdav");
-    tomcat.start();
-    port1 = tomcat.getConnector().getLocalPort();
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    tomcat.stop();
-  }
-
-  private String getTargetUrl() {
-    return String.format("http://localhost:%d/foo/test", port1);
-  }
-
-  @Test
-  public void testStreamingPutImage() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-      Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342))
-              .execute().get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
     }
-  }
-
-  @Test
-  public void testConnectionDoesNotGetClosed() throws Exception {
-    // test that we can stream the same request multiple times
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-      BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())
-              .setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))
-              .setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)
-              .setHeader("X-" + CONTENT_MD5, LARGE_IMAGE_BYTES_MD5);
-
-      Response response = requestBuilder.execute().get();
-      assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
-
-      byte[] responseBody = response.getResponseBodyAsBytes();
-      assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-              LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-      assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-      assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-      assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
-      assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
-
-      response = requestBuilder.execute().get();
-      assertEquals(response.getStatusCode(), 200);
-      responseBody = response.getResponseBodyAsBytes();
-      assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-              LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-      assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-
-      try {
-        assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-        assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
-        assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
-      } catch (AssertionError e) {
-        e.printStackTrace();
-        for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
-          assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
-        }
-        throw e;
-      }
-    }
-  }
 
-  @Test(expectedExceptions = ExecutionException.class)
-  public void testFailingStream() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-      Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
-      client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
+    @SuppressWarnings("serial")
+    private class FailedStream extends RuntimeException {
     }
-  }
 
-  @Test
-  public void streamedResponseTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
+    @Test(groups = "standalone")
+    public void streamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
 
-      SimpleSubscriber<HttpResponseBodyPart> subscriber = new SimpleSubscriber<>();
-      ListenableFuture<Void> future = c.preparePost(getTargetUrl())
-              .setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
 
-      // block
-      future.get();
-      assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
 
-      // Run it again to check that the pipeline is in a good state
-      subscriber = new SimpleSubscriber<>();
-      future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
+            // Run it again to check that the pipeline is in a good state
+            future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
 
-      future.get();
-      assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
 
-      // Make sure a regular request still works
-      assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+            // Make sure a regular request still works
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
 
+        }
     }
-  }
 
-  @Test
-  public void cancelStreamedResponseTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
+    @Test(groups = "standalone")
+    public void cancelStreamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
 
-      // Cancel immediately
-      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0))
-              .get();
+            // Cancel immediately
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0)).get();
 
-      // Cancel after 1 element
-      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1))
-              .get();
+            // Cancel after 1 element
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1)).get();
 
-      // Cancel after 10 elements
-      c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10))
-              .get();
+            // Cancel after 10 elements
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10)).get();
 
-      // Make sure a regular request works
-      assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+            // Make sure a regular request works
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+        }
     }
-  }
 
-  static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<Void> {
-    private final Subscriber<HttpResponseBodyPart> subscriber;
+    static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
+        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
-    SimpleStreamedAsyncHandler(Subscriber<HttpResponseBodyPart> subscriber) {
-      this.subscriber = subscriber;
-    }
+        public SimpleStreamedAsyncHandler() {
+            this(new SimpleSubscriber<>());
+        }
 
-    @Override
-    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-      publisher.subscribe(subscriber);
-      return State.CONTINUE;
-    }
+        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            this.subscriber = subscriber;
+        }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      throw new AssertionError(t);
-    }
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(subscriber);
+            return State.CONTINUE;
+        }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
-      throw new AssertionError("Should not have received body part");
-    }
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus responseStatus) {
-      return State.CONTINUE;
-    }
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) {
-      return State.CONTINUE;
-    }
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public Void onCompleted() {
-      return null;
-    }
-  }
-
-  /**
-   * Simple subscriber that requests and buffers one element at a time.
-   */
-  static class SimpleSubscriber<T> implements Subscriber<T> {
-    private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
-    private final CountDownLatch latch = new CountDownLatch(1);
-    private volatile Subscription subscription;
-    private volatile Throwable error;
-
-    @Override
-    public void onSubscribe(Subscription subscription) {
-      this.subscription = subscription;
-      subscription.request(1);
-    }
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public void onNext(T t) {
-      elements.add(t);
-      subscription.request(1);
-    }
+        @Override
+        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+            return this;
+        }
 
-    @Override
-    public void onError(Throwable error) {
-      this.error = error;
-      latch.countDown();
+        public byte[] getBytes() throws Throwable {
+            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            for (HttpResponseBodyPart part : bodyParts) {
+                bytes.write(part.getBodyPartBytes());
+            }
+            return bytes.toByteArray();
+        }
     }
 
-    @Override
-    public void onComplete() {
-      latch.countDown();
-    }
+    /**
+     * Simple subscriber that requests and buffers one element at a time.
+     */
+    static class SimpleSubscriber<T> implements Subscriber<T> {
+        private volatile Subscription subscription;
+        private volatile Throwable error;
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
+        private final CountDownLatch latch = new CountDownLatch(1);
 
-    List<T> getElements() throws Throwable {
-      latch.await();
-      if (error != null) {
-        throw error;
-      } else {
-        return elements;
-      }
-    }
-  }
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            subscription.request(1);
+        }
 
-  static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
-    private final int cancelAfter;
+        @Override
+        public void onNext(T t) {
+            elements.add(t);
+            subscription.request(1);
+        }
 
-    CancellingStreamedAsyncProvider(int cancelAfter) {
-      this.cancelAfter = cancelAfter;
-    }
+        @Override
+        public void onError(Throwable error) {
+            this.error = error;
+            latch.countDown();
+        }
 
-    @Override
-    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-      publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
-      return State.CONTINUE;
-    }
+        @Override
+        public void onComplete() {
+            latch.countDown();
+        }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      throw new AssertionError(t);
+        public List<T> getElements() throws Throwable {
+            latch.await();
+            if (error != null) {
+                throw error;
+            } else {
+                return elements;
+            }
+        }
     }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) {
-      throw new AssertionError("Should not have received body part");
-    }
+    static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
+        private final int cancelAfter;
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus responseStatus) {
-      return State.CONTINUE;
-    }
+        public CancellingStreamedAsyncProvider(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) {
-      return State.CONTINUE;
-    }
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
+            return State.CONTINUE;
+        }
 
-    @Override
-    public CancellingStreamedAsyncProvider onCompleted() {
-      return this;
-    }
-  }
-
-  /**
-   * Simple subscriber that cancels after receiving n elements.
-   */
-  static class CancellingSubscriber<T> implements Subscriber<T> {
-    private final int cancelAfter;
-    private volatile Subscription subscription;
-    private AtomicInteger count = new AtomicInteger(0);
-
-    CancellingSubscriber(int cancelAfter) {
-      this.cancelAfter = cancelAfter;
-    }
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
 
-    @Override
-    public void onSubscribe(Subscription subscription) {
-      this.subscription = subscription;
-      if (cancelAfter == 0) {
-        subscription.cancel();
-      } else {
-        subscription.request(1);
-      }
-    }
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
 
-    @Override
-    public void onNext(T t) {
-      if (count.incrementAndGet() == cancelAfter) {
-        subscription.cancel();
-      } else {
-        subscription.request(1);
-      }
-    }
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public void onError(Throwable error) {
-    }
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public void onComplete() {
+        @Override
+        public CancellingStreamedAsyncProvider onCompleted() throws Exception {
+            return this;
+        }
     }
-  }
 
-  static class ByteBufIterable implements Iterable<ByteBuf> {
-    private final byte[] payload;
-    private final int chunkSize;
+    /**
+     * Simple subscriber that cancels after receiving n elements.
+     */
+    static class CancellingSubscriber<T> implements Subscriber<T> {
+        private final int cancelAfter;
 
-    ByteBufIterable(byte[] payload, int chunkSize) {
-      this.payload = payload;
-      this.chunkSize = chunkSize;
-    }
+        public CancellingSubscriber(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
 
-    @Override
-    public Iterator<ByteBuf> iterator() {
-      return new Iterator<ByteBuf>() {
-        private int currentIndex = 0;
+        private volatile Subscription subscription;
+        private volatile int count;
 
         @Override
-        public boolean hasNext() {
-          return currentIndex != payload.length;
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            if (cancelAfter == 0) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
         }
 
         @Override
-        public ByteBuf next() {
-          int thisCurrentIndex = currentIndex;
-          int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
-          currentIndex += length;
-          return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
+        public void onNext(T t) {
+            count++;
+            if (count == cancelAfter) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
         }
 
         @Override
-        public void remove() {
-          throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
+        public void onError(Throwable error) {
+        }
+
+        @Override
+        public void onComplete() {
         }
-      };
     }
-  }
 
-  @SuppressWarnings("serial")
-  private class FailedStream extends RuntimeException {
-  }
+    static class ByteBufIterable implements Iterable<ByteBuf> {
+        private final byte[] payload;
+        private final int chunkSize;
+
+        public ByteBufIterable(byte[] payload, int chunkSize) {
+            this.payload = payload;
+            this.chunkSize = chunkSize;
+        }
+
+        @Override
+        public Iterator<ByteBuf> iterator() {
+            return new Iterator<ByteBuf>() {
+                private int currentIndex = 0;
+
+                @Override
+                public boolean hasNext() {
+                    return currentIndex != payload.length;
+                }
+
+                @Override
+                public ByteBuf next() {
+                    int thisCurrentIndex = currentIndex;
+                    int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
+                    currentIndex += length;
+                    return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
+                }
+
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
+                }
+            };
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
index 89b801771..fb0d66933 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
@@ -15,40 +15,44 @@
  */
 package org.asynchttpclient.request.body;
 
-import org.asynchttpclient.*;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.assertEquals;
 
 import java.io.ByteArrayInputStream;
 import java.util.concurrent.Future;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.testng.annotations.Test;
 
 public class BodyChunkTest extends AbstractBasicTest {
 
-  private static final String MY_MESSAGE = "my message";
+    private static final String MY_MESSAGE = "my message";
 
-  @Test
-  public void negativeContentTypeTest() throws Exception {
+    @Test(groups = "standalone")
+    public void negativeContentTypeTest() throws Exception {
 
-    AsyncHttpClientConfig config = config()
-            .setConnectTimeout(100)
-            .setMaxConnections(50)
-            .setRequestTimeout(5 * 60 * 1000) // 5 minutes
-            .build();
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000) // 5 minutes
+                .build();
 
-    try (AsyncHttpClient client = asyncHttpClient(config)) {
-      RequestBuilder requestBuilder = post(getTargetUrl())
-              .setHeader("Content-Type", "message/rfc822")
-              .setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+        try (AsyncHttpClient client = asyncHttpClient(config)) {
+            RequestBuilder requestBuilder = post(getTargetUrl())//
+                    .setHeader("Content-Type", "message/rfc822")//
+                    .setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-      Future<Response> future = client.executeRequest(requestBuilder.build());
+            Future<Response> future = client.executeRequest(requestBuilder.build());
 
-      System.out.println("waiting for response");
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getResponseBody(), MY_MESSAGE);
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
index 538488c2e..648163aaa 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -12,108 +12,114 @@
  */
 package org.asynchttpclient.request.body;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+import static org.testng.FileAssert.fail;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.*;
-import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
-import org.testng.annotations.Test;
 
 import java.io.BufferedInputStream;
+import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.FileAssert.fail;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
+import org.testng.annotations.Test;
 
 public class ChunkingTest extends AbstractBasicTest {
 
-  // So we can just test the returned data is the image,
-  // and doesn't contain the chunked delimeters.
-  @Test
-  public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
-    doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath()), 400000));
-  }
-
-  @Test
-  public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
-    doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath())));
-  }
+    // So we can just test the returned data is the image,
+    // and doesn't contain the chunked delimeters.
+    @Test(groups = "standalone")
+    public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath()), 400000));
+    }
 
-  @Test
-  public void testDirectFileWithStreamBodyGenerator() throws Throwable {
-    doTestWithInputStreamBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
-  }
+    @Test(groups = "standalone")
+    public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(new BufferedInputStream(Files.newInputStream(LARGE_IMAGE_FILE.toPath())));
+    }
 
-  @Test
-  public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
-    doTestWithFeedableBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
-  }
+    @Test(groups = "standalone")
+    public void testDirectFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
+    }
 
-  private void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
-    try {
-      try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
-        ListenableFuture<Response> responseFuture = c.executeRequest(post(getTargetUrl()).setBody(new InputStreamBodyGenerator(is)));
-        waitForAndAssertResponse(responseFuture);
-      }
-    } finally {
-      is.close();
+    @Test(groups = "standalone")
+    public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
+        doTestWithFeedableBodyGenerator(Files.newInputStream(LARGE_IMAGE_FILE.toPath()));
     }
-  }
 
-  private void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
-    try {
-      try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
-        final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-        Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
-        ListenableFuture<Response> responseFuture = c.executeRequest(r);
-        feed(feedableBodyGenerator, is);
-        waitForAndAssertResponse(responseFuture);
-      }
-    } finally {
-      is.close();
+    public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
+        try {
+            try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
+                ListenableFuture<Response> responseFuture = c.executeRequest(post(getTargetUrl()).setBody(new InputStreamBodyGenerator(is)));
+                waitForAndAssertResponse(responseFuture);
+            }
+        } finally {
+            is.close();
+        }
     }
-  }
 
-  private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
-    try (InputStream inputStream = is) {
-      byte[] buffer = new byte[512];
-      for (int i; (i = inputStream.read(buffer)) > -1; ) {
-        byte[] chunk = new byte[i];
-        System.arraycopy(buffer, 0, chunk, 0, i);
-        feedableBodyGenerator.feed(Unpooled.wrappedBuffer(chunk), false);
-      }
+    public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
+        try {
+            try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
+                final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+                Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
+                ListenableFuture<Response> responseFuture = c.executeRequest(r);
+                feed(feedableBodyGenerator, is);
+                waitForAndAssertResponse(responseFuture);
+            }
+        } finally {
+            is.close();
+        }
     }
-    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
 
-  }
+    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
+        try (InputStream inputStream = is) {
+            byte[] buffer = new byte[512];
+            for (int i = 0; (i = inputStream.read(buffer)) > -1;) {
+                byte[] chunk = new byte[i];
+                System.arraycopy(buffer, 0, chunk, 0, i);
+                feedableBodyGenerator.feed(Unpooled.wrappedBuffer(chunk), false);
+            }
+        }
+        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
+
+    }
 
-  private DefaultAsyncHttpClientConfig.Builder httpClientBuilder() {
-    return config()
-            .setKeepAlive(true)
-            .setMaxConnectionsPerHost(1)
-            .setMaxConnections(1)
-            .setConnectTimeout(1000)
-            .setRequestTimeout(1000)
-            .setFollowRedirect(true);
-  }
+    private DefaultAsyncHttpClientConfig.Builder httpClientBuilder() {
+        return config()//
+                .setKeepAlive(true)//
+                .setMaxConnectionsPerHost(1)//
+                .setMaxConnections(1)//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(1000)//
+                .setFollowRedirect(true);
+    }
 
-  private void waitForAndAssertResponse(ListenableFuture<Response> responseFuture) throws InterruptedException, java.util.concurrent.ExecutionException {
-    Response response = responseFuture.get();
-    if (500 == response.getStatusCode()) {
-      logger.debug("==============\n" +
-              "500 response from call\n" +
-              "Headers:" + response.getHeaders() + "\n" +
-              "==============\n");
-      assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
-      assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
-      fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
-    } else {
-      assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+    private void waitForAndAssertResponse(ListenableFuture<Response> responseFuture) throws InterruptedException, java.util.concurrent.ExecutionException, IOException {
+        Response response = responseFuture.get();
+        if (500 == response.getStatusCode()) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("==============\n");
+            sb.append("500 response from call\n");
+            sb.append("Headers:" + response.getHeaders() + "\n");
+            sb.append("==============\n");
+            logger.debug(sb.toString());
+            assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
+            assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
+            fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
+        } else {
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
index 9c2973c8a..304723cfd 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
@@ -15,113 +15,120 @@
  */
 package org.asynchttpclient.request.body;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.*;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Tests case where response doesn't have body.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public class EmptyBodyTest extends AbstractBasicTest {
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new NoBodyResponseHandler();
-  }
+    private class NoBodyResponseHandler extends AbstractHandler {
+        public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
-  @Test
-  public void testEmptyBody() throws IOException {
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      final AtomicBoolean err = new AtomicBoolean(false);
-      final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
-      final AtomicBoolean status = new AtomicBoolean(false);
-      final AtomicInteger headers = new AtomicInteger(0);
-      final CountDownLatch latch = new CountDownLatch(1);
-      ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-        public void onThrowable(Throwable t) {
-          fail("Got throwable.", t);
-          err.set(true);
+            if (!req.getMethod().equalsIgnoreCase("PUT")) {
+                resp.setStatus(HttpServletResponse.SC_OK);
+            } else {
+                resp.setStatus(204);
+            }
+            request.setHandled(true);
         }
+    }
 
-        public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-          byte[] bytes = e.getBodyPartBytes();
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new NoBodyResponseHandler();
+    }
 
-          if (bytes.length != 0) {
-            String s = new String(bytes);
-            logger.info("got part: {}", s);
-            logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
-            queue.put(s);
-          }
-          return State.CONTINUE;
-        }
+    @Test(groups = "standalone")
+    public void testEmptyBody() throws IOException {
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
 
-        public State onStatusReceived(HttpResponseStatus e) {
-          status.set(true);
-          return AsyncHandler.State.CONTINUE;
-        }
+                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    byte[] bytes = e.getBodyPartBytes();
 
-        public State onHeadersReceived(HttpHeaders e) throws Exception {
-          if (headers.incrementAndGet() == 2) {
-            throw new Exception("Analyze this.");
-          }
-          return State.CONTINUE;
-        }
+                    if (bytes.length != 0) {
+                        String s = new String(bytes);
+                        logger.info("got part: {}", s);
+                        logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                        queue.put(s);
+                    }
+                    return State.CONTINUE;
+                }
 
-        public Object onCompleted() {
-          latch.countDown();
-          return null;
-        }
-      });
-      try {
-        assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-      } catch (InterruptedException e) {
-        fail("Interrupted.", e);
-      }
-      assertFalse(err.get());
-      assertEquals(queue.size(), 0);
-      assertTrue(status.get());
-      assertEquals(headers.get(), 1);
-    }
-  }
+                public State onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return AsyncHandler.State.CONTINUE;
+                }
 
-  @Test
-  public void testPutEmptyBody() throws Exception {
-    try (AsyncHttpClient ahc = asyncHttpClient()) {
-      Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
+                public State onHeadersReceived(HttpHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return State.CONTINUE;
+                }
 
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 204);
-      assertEquals(response.getResponseBody(), "");
-      assertNotNull(response.getResponseBodyAsStream());
-      assertEquals(response.getResponseBodyAsStream().read(), -1);
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            try {
+                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
+            }
+            assertFalse(err.get());
+            assertEquals(queue.size(), 0);
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
+        }
     }
-  }
 
-  private class NoBodyResponseHandler extends AbstractHandler {
-    public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+    @Test(groups = "standalone")
+    public void testPutEmptyBody() throws Exception {
+        try (AsyncHttpClient ahc = asyncHttpClient()) {
+            Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
 
-      if (!req.getMethod().equalsIgnoreCase("PUT")) {
-        resp.setStatus(HttpServletResponse.SC_OK);
-      } else {
-        resp.setStatus(204);
-      }
-      request.setHandled(true);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 204);
+            assertEquals(response.getResponseBody(), "");
+            assertTrue(response.getResponseBodyAsStream() instanceof InputStream);
+            assertEquals(response.getResponseBodyAsStream().read(), -1);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
index 06e33c95a..0945c2e24 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
@@ -12,6 +12,19 @@
  */
 package org.asynchttpclient.request.body;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
@@ -20,61 +33,48 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletInputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.File;
-import java.io.IOException;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.assertEquals;
-
 public class FilePartLargeFileTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new AbstractHandler() {
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
 
-      public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException {
+            public void handle(String target, Request baseRequest, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
-        ServletInputStream in = req.getInputStream();
-        byte[] b = new byte[8192];
+                ServletInputStream in = req.getInputStream();
+                byte[] b = new byte[8192];
 
-        int count;
-        int total = 0;
-        while ((count = in.read(b)) != -1) {
-          b = new byte[8192];
-          total += count;
-        }
-        resp.setStatus(200);
-        resp.addHeader("X-TRANFERED", String.valueOf(total));
-        resp.getOutputStream().flush();
-        resp.getOutputStream().close();
+                int count = -1;
+                int total = 0;
+                while ((count = in.read(b)) != -1) {
+                    b = new byte[8192];
+                    total += count;
+                }
+                resp.setStatus(200);
+                resp.addHeader("X-TRANFERED", String.valueOf(total));
+                resp.getOutputStream().flush();
+                resp.getOutputStream().close();
 
-        baseRequest.setHandled(true);
-      }
-    };
-  }
+                baseRequest.setHandled(true);
+            }
+        };
+    }
 
-  @Test
-  public void testPutImageFile() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-      Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
-      assertEquals(response.getStatusCode(), 200);
+    @Test(groups = "standalone")
+    public void testPutImageFile() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+        }
     }
-  }
 
-  @Test
-  public void testPutLargeTextFile() throws Exception {
-    File file = createTempFile(1024 * 1024);
+    @Test(groups = "standalone")
+    public void testPutLargeTextFile() throws Exception {
+        File file = createTempFile(1024 * 1024);
 
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-      Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
-      assertEquals(response.getStatusCode(), 200);
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
index d7c21b618..beff9d762 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
@@ -15,93 +15,94 @@
  */
 package org.asynchttpclient.request.body;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class InputStreamTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new InputStreamHandler();
-  }
+    private static class InputStreamHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("POST".equalsIgnoreCase(request.getMethod())) {
+                byte[] bytes = new byte[3];
+                ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                int read = 0;
+                while (read > -1) {
+                    read = request.getInputStream().read(bytes);
+                    if (read > 0) {
+                        bos.write(bytes, 0, read);
+                    }
+                }
 
-  @Test
-  public void testInvalidInputStream() throws IOException, ExecutionException, InterruptedException {
+                response.setStatus(HttpServletResponse.SC_OK);
+                response.addHeader("X-Param", new String(bos.toByteArray()));
+            } else { // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
+        }
+    }
 
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      HttpHeaders h = new DefaultHttpHeaders().add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new InputStreamHandler();
+    }
 
-      InputStream is = new InputStream() {
+    @Test(groups = "standalone")
+    public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        int readAllowed;
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            HttpHeaders h = new DefaultHttpHeaders().add(CONTENT_TYPE, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED);
 
-        @Override
-        public int available() {
-          return 1; // Fake
-        }
+            InputStream is = new InputStream() {
 
-        @Override
-        public int read() {
-          int fakeCount = readAllowed++;
-          if (fakeCount == 0) {
-            return (int) 'a';
-          } else if (fakeCount == 1) {
-            return (int) 'b';
-          } else if (fakeCount == 2) {
-            return (int) 'c';
-          } else {
-            return -1;
-          }
-        }
-      };
+                public int readAllowed;
 
-      Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getHeader("X-Param"), "abc");
-    }
-  }
+                @Override
+                public int available() {
+                    return 1; // Fake
+                }
 
-  private static class InputStreamHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      if ("POST".equalsIgnoreCase(request.getMethod())) {
-        byte[] bytes = new byte[3];
-        ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        int read = 0;
-        while (read > -1) {
-          read = request.getInputStream().read(bytes);
-          if (read > 0) {
-            bos.write(bytes, 0, read);
-          }
-        }
+                @Override
+                public int read() throws IOException {
+                    int fakeCount = readAllowed++;
+                    if (fakeCount == 0) {
+                        return (int) 'a';
+                    } else if (fakeCount == 1) {
+                        return (int) 'b';
+                    } else if (fakeCount == 2) {
+                        return (int) 'c';
+                    } else {
+                        return -1;
+                    }
+                }
+            };
 
-        response.setStatus(HttpServletResponse.SC_OK);
-        response.addHeader("X-Param", new String(bos.toByteArray()));
-      } else { // this handler is to handle POST request
-        response.sendError(HttpServletResponse.SC_FORBIDDEN);
-      }
-      response.getOutputStream().flush();
-      response.getOutputStream().close();
+            Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), "abc");
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
index 88e371bb5..9dab207a4 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/PutFileTest.java
@@ -12,6 +12,18 @@
  */
 package org.asynchttpclient.request.body;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
@@ -19,55 +31,45 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.assertEquals;
-
 public class PutFileTest extends AbstractBasicTest {
 
-  private void put(int fileSize) throws Exception {
-    File file = createTempFile(fileSize);
-    try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(2000))) {
-      Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
-      assertEquals(response.getStatusCode(), 200);
+    private void put(int fileSize) throws Exception {
+        File file = createTempFile(fileSize);
+        int timeout = (int) file.length() / 1000;
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(timeout))) {
+            Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+        }
     }
-  }
 
-  @Test
-  public void testPutLargeFile() throws Exception {
-    put(1024 * 1024);
-  }
+    @Test(groups = "standalone")
+    public void testPutLargeFile() throws Exception {
+        put(1024 * 1024);
+    }
 
-  @Test
-  public void testPutSmallFile() throws Exception {
-    put(1024);
-  }
+    @Test(groups = "standalone")
+    public void testPutSmallFile() throws Exception {
+        put(1024);
+    }
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new AbstractHandler() {
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
 
-      public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
+            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-        InputStream is = baseRequest.getInputStream();
-        int read;
-        do {
-          // drain upload
-          read = is.read();
-        } while (read >= 0);
+                InputStream is = baseRequest.getInputStream();
+                int read = 0;
+                do {
+                    // drain upload
+                    read = is.read();
+                } while (read >= 0);
 
-        response.setStatus(200);
-        response.getOutputStream().flush();
-        response.getOutputStream().close();
-        baseRequest.setHandled(true);
-      }
-    };
-  }
+                response.setStatus(200);
+                response.getOutputStream().flush();
+                response.getOutputStream().close();
+                baseRequest.setHandled(true);
+            }
+        };
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
index b4df376ca..1852a6f34 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
@@ -12,19 +12,11 @@
  */
 package org.asynchttpclient.request.body;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.handler.TransferCompletionHandler;
-import org.asynchttpclient.handler.TransferListener;
-import org.asynchttpclient.request.body.generator.FileBodyGenerator;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.util.Enumeration;
@@ -33,201 +25,209 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.createTempFile;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.asynchttpclient.handler.TransferListener;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 public class TransferListenerTest extends AbstractBasicTest {
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new BasicHandler();
-  }
-
-  @Test
-  public void basicGetTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final AtomicReference<Throwable> throwable = new AtomicReference<>();
-      final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-      final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-      final AtomicReference<byte[]> bb = new AtomicReference<>();
-      final AtomicBoolean completed = new AtomicBoolean(false);
-
-      TransferCompletionHandler tl = new TransferCompletionHandler();
-      tl.addTransferListener(new TransferListener() {
-
-        public void onRequestHeadersSent(HttpHeaders headers) {
-          hSent.set(headers);
+    private class BasicHandler extends AbstractHandler {
+
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            String param;
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+            }
+
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                int read = 0;
+                while (read != -1) {
+                    read = httpRequest.getInputStream().read(bytes);
+                    if (read > 0) {
+                        httpResponse.getOutputStream().write(bytes, 0, read);
+                    }
+                }
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
         }
+    }
 
-        public void onResponseHeadersReceived(HttpHeaders headers) {
-          hRead.set(headers);
-        }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new BasicHandler();
+    }
 
-        public void onBytesReceived(byte[] b) {
-          if (b.length != 0)
-            bb.set(b);
-        }
+    @Test(groups = "standalone")
+    public void basicGetTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+            final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+            final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+            final AtomicReference<byte[]> bb = new AtomicReference<>();
+            final AtomicBoolean completed = new AtomicBoolean(false);
 
-        public void onBytesSent(long amount, long current, long total) {
-        }
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
 
-        public void onRequestResponseCompleted() {
-          completed.set(true);
-        }
+                public void onRequestHeadersSent(HttpHeaders headers) {
+                    hSent.set(headers);
+                }
 
-        public void onThrowable(Throwable t) {
-          throwable.set(t);
-        }
-      });
+                public void onResponseHeadersReceived(HttpHeaders headers) {
+                    hRead.set(headers);
+                }
 
-      Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
+                public void onBytesReceived(byte[] b) {
+                    if (b.length != 0)
+                        bb.set(b);
+                }
 
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertNotNull(hRead.get());
-      assertNotNull(hSent.get());
-      assertNull(bb.get());
-      assertNull(throwable.get());
+                public void onBytesSent(long amount, long current, long total) {
+                }
+
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
+
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
+
+            Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertNull(bb.get());
+            assertNull(throwable.get());
+        }
     }
-  }
 
-  @Test
-  public void basicPutFileTest() throws Exception {
-    final AtomicReference<Throwable> throwable = new AtomicReference<>();
-    final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-    final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-    final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-    final AtomicLong bbSentLenght = new AtomicLong(0L);
+    @Test(groups = "standalone")
+    public void basicPutFileTest() throws Exception {
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+        final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+        final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+        final AtomicLong bbSentLenght = new AtomicLong(0L);
 
-    final AtomicBoolean completed = new AtomicBoolean(false);
+        final AtomicBoolean completed = new AtomicBoolean(false);
 
-    File file = createTempFile(1024 * 100 * 10);
+        File file = createTempFile(1024 * 100 * 10);
 
-    int timeout = (int) (file.length() / 1000);
+        int timeout = (int) (file.length() / 1000);
 
-    try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
-      TransferCompletionHandler tl = new TransferCompletionHandler();
-      tl.addTransferListener(new TransferListener() {
+        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
 
-        public void onRequestHeadersSent(HttpHeaders headers) {
-          hSent.set(headers);
-        }
+                public void onRequestHeadersSent(HttpHeaders headers) {
+                    hSent.set(headers);
+                }
 
-        public void onResponseHeadersReceived(HttpHeaders headers) {
-          hRead.set(headers);
-        }
+                public void onResponseHeadersReceived(HttpHeaders headers) {
+                    hRead.set(headers);
+                }
 
-        public void onBytesReceived(byte[] b) {
-          bbReceivedLenght.addAndGet(b.length);
-        }
+                public void onBytesReceived(byte[] b) {
+                    bbReceivedLenght.addAndGet(b.length);
+                }
 
-        public void onBytesSent(long amount, long current, long total) {
-          bbSentLenght.addAndGet(amount);
-        }
+                public void onBytesSent(long amount, long current, long total) {
+                    bbSentLenght.addAndGet(amount);
+                }
 
-        public void onRequestResponseCompleted() {
-          completed.set(true);
-        }
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
 
-        public void onThrowable(Throwable t) {
-          throwable.set(t);
-        }
-      });
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
 
-      Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
+            Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
 
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertNotNull(hRead.get());
-      assertNotNull(hSent.get());
-      assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-      assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
+        }
     }
-  }
 
-  @Test
-  public void basicPutFileBodyGeneratorTest() throws Exception {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final AtomicReference<Throwable> throwable = new AtomicReference<>();
-      final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
-      final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
-      final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-      final AtomicLong bbSentLenght = new AtomicLong(0L);
+    @Test(groups = "standalone")
+    public void basicPutFileBodyGeneratorTest() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+            final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
+            final AtomicReference<HttpHeaders> hRead = new AtomicReference<>();
+            final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+            final AtomicLong bbSentLenght = new AtomicLong(0L);
 
-      final AtomicBoolean completed = new AtomicBoolean(false);
+            final AtomicBoolean completed = new AtomicBoolean(false);
 
-      File file = createTempFile(1024 * 100 * 10);
+            File file = createTempFile(1024 * 100 * 10);
 
-      TransferCompletionHandler tl = new TransferCompletionHandler();
-      tl.addTransferListener(new TransferListener() {
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
 
-        public void onRequestHeadersSent(HttpHeaders headers) {
-          hSent.set(headers);
-        }
+                public void onRequestHeadersSent(HttpHeaders headers) {
+                    hSent.set(headers);
+                }
 
-        public void onResponseHeadersReceived(HttpHeaders headers) {
-          hRead.set(headers);
-        }
+                public void onResponseHeadersReceived(HttpHeaders headers) {
+                    hRead.set(headers);
+                }
 
-        public void onBytesReceived(byte[] b) {
-          bbReceivedLenght.addAndGet(b.length);
-        }
+                public void onBytesReceived(byte[] b) {
+                    bbReceivedLenght.addAndGet(b.length);
+                }
 
-        public void onBytesSent(long amount, long current, long total) {
-          bbSentLenght.addAndGet(amount);
-        }
+                public void onBytesSent(long amount, long current, long total) {
+                    bbSentLenght.addAndGet(amount);
+                }
 
-        public void onRequestResponseCompleted() {
-          completed.set(true);
-        }
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
 
-        public void onThrowable(Throwable t) {
-          throwable.set(t);
-        }
-      });
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
 
-      Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
+            Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
 
-      assertNotNull(response);
-      assertEquals(response.getStatusCode(), 200);
-      assertNotNull(hRead.get());
-      assertNotNull(hSent.get());
-      assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-      assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
-    }
-  }
-
-  private class BasicHandler extends AbstractHandler {
-
-    public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-      Enumeration<?> e = httpRequest.getHeaderNames();
-      String param;
-      while (e.hasMoreElements()) {
-        param = e.nextElement().toString();
-        httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-      }
-
-      int size = 10 * 1024;
-      if (httpRequest.getContentLength() > 0) {
-        size = httpRequest.getContentLength();
-      }
-      byte[] bytes = new byte[size];
-      if (bytes.length > 0) {
-        int read = 0;
-        while (read != -1) {
-          read = httpRequest.getInputStream().read(bytes);
-          if (read > 0) {
-            httpResponse.getOutputStream().write(bytes, 0, read);
-          }
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
         }
-      }
-
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
-      httpResponse.getOutputStream().close();
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index f3e59fd55..306ccb17a 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -12,166 +12,175 @@
  */
 package org.asynchttpclient.request.body;
 
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.*;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.net.URISyntaxException;
 import java.nio.file.Files;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BasicHttpsTest;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * Zero copy test which use FileChannel.transfer under the hood . The same SSL test is also covered in {@link BasicHttpsTest}
  */
 public class ZeroCopyFileTest extends AbstractBasicTest {
 
-  @Test
-  public void zeroCopyPostTest() throws IOException, ExecutionException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final AtomicBoolean headerSent = new AtomicBoolean(false);
-      final AtomicBoolean operationCompleted = new AtomicBoolean(false);
+    private class ZeroCopyHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-      Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                httpRequest.getInputStream().read(bytes);
+                httpResponse.getOutputStream().write(bytes);
+            }
 
-        public State onHeadersWritten() {
-          headerSent.set(true);
-          return State.CONTINUE;
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
         }
+    }
 
-        public State onContentWritten() {
-          operationCompleted.set(true);
-          return State.CONTINUE;
+    @Test(groups = "standalone")
+    public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final AtomicBoolean headerSent = new AtomicBoolean(false);
+            final AtomicBoolean operationCompleted = new AtomicBoolean(false);
+
+            Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
+
+                public State onHeadersWritten() {
+                    headerSent.set(true);
+                    return State.CONTINUE;
+                }
+
+                public State onContentWritten() {
+                    operationCompleted.set(true);
+                    return State.CONTINUE;
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            }).get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+            assertTrue(operationCompleted.get());
+            assertTrue(headerSent.get());
         }
+    }
 
-        @Override
-        public Response onCompleted(Response response) {
-          return response;
+    @Test(groups = "standalone")
+    public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
         }
-      }).get();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-      assertTrue(operationCompleted.get());
-      assertTrue(headerSent.get());
-    }
-  }
-
-  @Test
-  public void zeroCopyPutTest() throws IOException, ExecutionException, InterruptedException {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
-      Response resp = f.get();
-      assertNotNull(resp);
-      assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-      assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
     }
-  }
-
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new ZeroCopyHandler();
-  }
-
-  @Test
-  public void zeroCopyFileTest() throws IOException, ExecutionException, InterruptedException {
-    File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-    tmp.deleteOnExit();
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
-        Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-          public void onThrowable(Throwable t) {
-          }
-
-          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            stream.write(bodyPart.getBodyPartBytes());
-            return State.CONTINUE;
-          }
-
-          public State onStatusReceived(HttpResponseStatus responseStatus) {
-            return State.CONTINUE;
-          }
-
-          public State onHeadersReceived(HttpHeaders headers) {
-            return State.CONTINUE;
-          }
-
-          public Response onCompleted() {
-            return null;
-          }
-        }).get();
-        assertNull(resp);
-        assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
-      }
-    }
-  }
-
-  @Test
-  public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, InterruptedException {
-    File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-    tmp.deleteOnExit();
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
-        Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-          public void onThrowable(Throwable t) {
-          }
-
-          public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            stream.write(bodyPart.getBodyPartBytes());
-
-            if (bodyPart.getBodyPartBytes().length == 0) {
-              return State.ABORT;
-            }
 
-            return State.CONTINUE;
-          }
-
-          public State onStatusReceived(HttpResponseStatus responseStatus) {
-            return State.CONTINUE;
-          }
-
-          public State onHeadersReceived(HttpHeaders headers) {
-            return State.CONTINUE;
-          }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ZeroCopyHandler();
+    }
 
-          public Response onCompleted() {
-            return null;
-          }
-        }).get();
-        assertNull(resp);
-        assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
-      }
+    @Test(groups = "standalone")
+    public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+        tmp.deleteOnExit();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                    public void onThrowable(Throwable t) {
+                    }
+
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        stream.write(bodyPart.getBodyPartBytes());
+                        return State.CONTINUE;
+                    }
+
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        return State.CONTINUE;
+                    }
+
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        return State.CONTINUE;
+                    }
+
+                    public Response onCompleted() throws Exception {
+                        return null;
+                    }
+                }).get();
+                assertNull(resp);
+                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+            }
+        }
     }
-  }
-
-  private class ZeroCopyHandler extends AbstractHandler {
-    public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
-
-      int size = 10 * 1024;
-      if (httpRequest.getContentLength() > 0) {
-        size = httpRequest.getContentLength();
-      }
-      byte[] bytes = new byte[size];
-      if (bytes.length > 0) {
-        httpRequest.getInputStream().read(bytes);
-        httpResponse.getOutputStream().write(bytes);
-      }
-
-      httpResponse.setStatus(200);
-      httpResponse.getOutputStream().flush();
+
+    @Test(groups = "standalone")
+    public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+        tmp.deleteOnExit();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            try (OutputStream stream = Files.newOutputStream(tmp.toPath())) {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                    public void onThrowable(Throwable t) {
+                    }
+
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        stream.write(bodyPart.getBodyPartBytes());
+
+                        if (bodyPart.getBodyPartBytes().length == 0) {
+                            return State.ABORT;
+                        }
+
+                        return State.CONTINUE;
+                    }
+
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        return State.CONTINUE;
+                    }
+
+                    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                        return State.CONTINUE;
+                    }
+
+                    public Response onCompleted() throws Exception {
+                        return null;
+                    }
+                }).get();
+                assertNull(resp);
+                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
index f3ac9b1f3..ed1419caf 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGeneratorTest.java
@@ -12,71 +12,72 @@
  */
 package org.asynchttpclient.request.body.generator;
 
+import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.request.body.Body;
-import org.asynchttpclient.request.body.Body.BodyState;
-import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.Random;
 
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.BodyState;
+import org.asynchttpclient.request.body.generator.ByteArrayBodyGenerator;
+import org.testng.annotations.Test;
 
 /**
  * @author Bryan Davis bpd@keynetics.com
  */
 public class ByteArrayBodyGeneratorTest {
 
-  private final Random random = new Random();
-  private final int chunkSize = 1024 * 8;
+    private final Random random = new Random();
+    private final int chunkSize = 1024 * 8;
 
-  @Test
-  public void testSingleRead() throws IOException {
-    final int srcArraySize = chunkSize - 1;
-    final byte[] srcArray = new byte[srcArraySize];
-    random.nextBytes(srcArray);
+    @Test(groups = "standalone")
+    public void testSingleRead() throws IOException {
+        final int srcArraySize = chunkSize - 1;
+        final byte[] srcArray = new byte[srcArraySize];
+        random.nextBytes(srcArray);
 
-    final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
-    final Body body = babGen.createBody();
+        final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
+        final Body body = babGen.createBody();
 
-    final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
+        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
-    try {
-      // should take 1 read to get through the srcArray
-      body.transferTo(chunkBuffer);
-      assertEquals(chunkBuffer.readableBytes(), srcArraySize, "bytes read");
-      chunkBuffer.clear();
+        try {
+            // should take 1 read to get through the srcArray
+            body.transferTo(chunkBuffer);
+            assertEquals(chunkBuffer.readableBytes(), srcArraySize, "bytes read");
+            chunkBuffer.clear();
 
-      assertEquals(body.transferTo(chunkBuffer), BodyState.STOP, "body at EOF");
-    } finally {
-      chunkBuffer.release();
+            assertEquals(body.transferTo(chunkBuffer), BodyState.STOP, "body at EOF");
+        } finally {
+            chunkBuffer.release();
+        }
     }
-  }
 
-  @Test
-  public void testMultipleReads() throws IOException {
-    final int srcArraySize = (3 * chunkSize) + 42;
-    final byte[] srcArray = new byte[srcArraySize];
-    random.nextBytes(srcArray);
+    @Test(groups = "standalone")
+    public void testMultipleReads() throws IOException {
+        final int srcArraySize = (3 * chunkSize) + 42;
+        final byte[] srcArray = new byte[srcArraySize];
+        random.nextBytes(srcArray);
 
-    final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
-    final Body body = babGen.createBody();
+        final ByteArrayBodyGenerator babGen = new ByteArrayBodyGenerator(srcArray);
+        final Body body = babGen.createBody();
 
-    final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
+        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
-    try {
-      int reads = 0;
-      int bytesRead = 0;
-      while (body.transferTo(chunkBuffer) != BodyState.STOP) {
-        reads += 1;
-        bytesRead += chunkBuffer.readableBytes();
-        chunkBuffer.clear();
-      }
-      assertEquals(reads, 4, "reads to drain generator");
-      assertEquals(bytesRead, srcArraySize, "bytes read");
-    } finally {
-      chunkBuffer.release();
+        try {
+            int reads = 0;
+            int bytesRead = 0;
+            while (body.transferTo(chunkBuffer) != BodyState.STOP) {
+                reads += 1;
+                bytesRead += chunkBuffer.readableBytes();
+                chunkBuffer.clear();
+            }
+            assertEquals(reads, 4, "reads to drain generator");
+            assertEquals(bytesRead, srcArraySize, "bytes read");
+        } finally {
+            chunkBuffer.release();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
index 97bba7c09..463eddd9f 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -13,101 +13,101 @@
  */
 package org.asynchttpclient.request.body.generator;
 
+import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
 import org.asynchttpclient.request.body.Body;
 import org.asynchttpclient.request.body.Body.BodyState;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
+public class FeedableBodyGeneratorTest {
 
-import static org.testng.Assert.assertEquals;
+    private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
+    private TestFeedListener listener;
 
-public class FeedableBodyGeneratorTest {
+    @BeforeMethod
+    public void setUp() throws Exception {
+        feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
+        listener = new TestFeedListener();
+        feedableBodyGenerator.setListener(listener);
+    }
+
+    @Test(groups = "standalone")
+    public void feedNotifiesListener() throws Exception {
+        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, false);
+        feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
+        assertEquals(listener.getCalls(), 2);
+    }
 
-  private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
-  private TestFeedListener listener;
-
-  @BeforeMethod
-  public void setUp() {
-    feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
-    listener = new TestFeedListener();
-    feedableBodyGenerator.setListener(listener);
-  }
-
-  @Test
-  public void feedNotifiesListener() throws Exception {
-    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, false);
-    feedableBodyGenerator.feed(Unpooled.EMPTY_BUFFER, true);
-    assertEquals(listener.getCalls(), 2);
-  }
-
-  @Test
-  public void readingBytesReturnsFedContentWithoutChunkBoundaries() throws Exception {
-    byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
-
-    ByteBuf source = Unpooled.wrappedBuffer(content);
-    ByteBuf target = Unpooled.buffer(1);
-
-    try {
-      feedableBodyGenerator.feed(source, true);
-      Body body = feedableBodyGenerator.createBody();
-      assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
-      assertEquals(body.transferTo(target), BodyState.STOP);
-    } finally {
-      source.release();
-      target.release();
+    @Test(groups = "standalone")
+    public void readingBytesReturnsFedContentWithoutChunkBoundaries() throws Exception {
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+
+        ByteBuf source = Unpooled.wrappedBuffer(content);
+        ByteBuf target = Unpooled.buffer(1);
+
+        try {
+            feedableBodyGenerator.feed(source, true);
+            Body body = feedableBodyGenerator.createBody();
+            assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+            assertEquals(body.transferTo(target), BodyState.STOP);
+        } finally {
+            source.release();
+            target.release();
+        }
     }
-  }
 
-  @Test
-  public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
-    byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+    @Test(groups = "standalone")
+    public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
 
-    ByteBuf source = Unpooled.wrappedBuffer(content);
-    ByteBuf target = Unpooled.buffer(1);
+        ByteBuf source = Unpooled.wrappedBuffer(content);
+        ByteBuf target = Unpooled.buffer(1);
 
-    try {
-      feedableBodyGenerator.feed(source, false);
+        try {
+            feedableBodyGenerator.feed(source, false);
 
-      Body body = feedableBodyGenerator.createBody();
-      assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
-      assertEquals(body.transferTo(target), BodyState.SUSPEND);
-    } finally {
-      source.release();
-      target.release();
+            Body body = feedableBodyGenerator.createBody();
+            assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+            assertEquals(body.transferTo(target), BodyState.SUSPEND);
+        } finally {
+            source.release();
+            target.release();
+        }
     }
-  }
-
-  private byte[] readFromBody(Body body) throws IOException {
-    ByteBuf byteBuf = Unpooled.buffer(512);
-    try {
-      body.transferTo(byteBuf);
-      byte[] readBytes = new byte[byteBuf.readableBytes()];
-      byteBuf.readBytes(readBytes);
-      return readBytes;
-    } finally {
-      byteBuf.release();
+
+    private byte[] readFromBody(Body body) throws IOException {
+        ByteBuf byteBuf = Unpooled.buffer(512);
+        try {
+            body.transferTo(byteBuf);
+            byte[] readBytes = new byte[byteBuf.readableBytes()];
+            byteBuf.readBytes(readBytes);
+            return readBytes;
+        } finally {
+            byteBuf.release();
+        }
     }
-  }
 
-  private static class TestFeedListener implements FeedListener {
+    private static class TestFeedListener implements FeedListener {
 
-    private int calls;
+        private int calls;
 
-    @Override
-    public void onContentAdded() {
-      calls++;
-    }
+        @Override
+        public void onContentAdded() {
+            calls++;
+        }
 
-    @Override
-    public void onError(Throwable t) {
-    }
+        @Override
+        public void onError(Throwable t) {
+        }
 
-    int getCalls() {
-      return calls;
+        public int getCalls() {
+            return calls;
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
index 45c354ad0..297fd9d24 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
@@ -13,97 +13,69 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import org.asynchttpclient.*;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Function;
-
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
 import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
-import static io.netty.handler.codec.http.HttpHeaderValues.CONTINUE;
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.basicAuthRealm;
+import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
 
-public class MultipartBasicAuthTest extends AbstractBasicTest {
+import java.io.File;
 
-  @BeforeClass(alwaysRun = true)
-  @Override
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    addBasicAuthHandler(server, configureHandler());
-    server.start();
-    port1 = connector1.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BasicAuthTest;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
 
-  @Override
-  public AbstractHandler configureHandler() throws Exception {
-    return new BasicAuthTest.SimpleHandler();
-  }
+public class MultipartBasicAuthTest extends AbstractBasicTest {
 
-  private void expectBrokenPipe(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
-    File file = createTempFile(1024 * 1024);
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
 
-    Throwable cause = null;
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      try {
-        for (int i = 0; i < 20; i++) {
-          f.apply(client.preparePut(getTargetUrl())
-                  .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))
-                  .execute().get();
-        }
-      } catch (ExecutionException e) {
-        cause = e.getCause();
-      }
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        addBasicAuthHandler(server, configureHandler());
+        server.start();
+        port1 = connector1.getLocalPort();
+        logger.info("Local HTTP server started successfully");
     }
 
-    assertTrue(cause instanceof IOException, "Expected an IOException");
-  }
-
-  @Test
-  public void noRealmCausesServerToCloseSocket() throws Exception {
-    expectBrokenPipe(rb -> rb);
-  }
-
-  @Test
-  public void unauthorizedNonPreemptiveRealmCausesServerToCloseSocket() throws Exception {
-    expectBrokenPipe(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)));
-  }
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new BasicAuthTest.SimpleHandler();
+    }
 
-  private void expectSuccess(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
-    File file = createTempFile(1024 * 1024);
+    @Test(groups = "standalone", enabled = false)
+    public void testNoRealm() throws Exception {
+        File file = createTempFile(1024 * 1024);
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      for (int i = 0; i < 20; i++) {
-        Response response = f.apply(client.preparePut(getTargetUrl())
-                .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))
-                .execute().get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
-      }
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            for (int i = 0; i < 20; i++) {
+                Response response = client.preparePut(getTargetUrl())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
+                assertEquals(response.getStatusCode(), 401);
+            }
+        }
     }
-  }
 
-  @Test
-  public void authorizedPreemptiveRealmWorks() throws Exception {
-    expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true)));
-  }
+    @Test(groups = "standalone", enabled = false)
+    public void testAuthorizedRealm() throws Exception {
+        File file = createTempFile(1024 * 1024);
 
-  @Test
-  public void authorizedNonPreemptiveRealmWorksWithExpectContinue() throws Exception {
-    expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)).setHeader(EXPECT, CONTINUE));
-  }
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            for (int i = 0; i < 20; i++) {
+                Response response = client.preparePut(getTargetUrl())//
+                        .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
+            }
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 0b6c5fe6f..5572571ff 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -13,11 +13,11 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
-import org.asynchttpclient.request.body.Body.BodyState;
-import org.testng.annotations.Test;
 
 import java.io.File;
 import java.io.IOException;
@@ -29,105 +29,107 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import org.asynchttpclient.request.body.Body.BodyState;
+import org.testng.annotations.Test;
 
 public class MultipartBodyTest {
 
-  private static final List<Part> PARTS = new ArrayList<>();
-  private static long MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE;
+    private static final List<Part> PARTS = new ArrayList<>();
+
+    static {
+        try {
+            PARTS.add(new FilePart("filePart", getTestfile()));
+        } catch (URISyntaxException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+        PARTS.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
+        PARTS.add(new StringPart("stringPart", "testString"));
+    }
+
+    private static File getTestfile() throws URISyntaxException {
+        final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
+        final URL url = cl.getResource("textfile.txt");
+        assertNotNull(url);
+        return new File(url.toURI());
+    }
+
+    private static long MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE;
 
-  static {
-    try {
-      PARTS.add(new FilePart("filePart", getTestfile()));
-    } catch (URISyntaxException e) {
-      throw new ExceptionInInitializerError(e);
+    static {
+        try (MultipartBody dummyBody = buildMultipart()) {
+            // separator is random
+            MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE = dummyBody.getContentLength() + 100;
+        } catch (IOException e) {
+            throw new ExceptionInInitializerError(e);
+        }
     }
-    PARTS.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
-    PARTS.add(new StringPart("stringPart", "testString"));
-  }
-
-  static {
-    try (MultipartBody dummyBody = buildMultipart()) {
-      // separator is random
-      MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE = dummyBody.getContentLength() + 100;
+
+    private static MultipartBody buildMultipart() {
+        return MultipartUtils.newMultipartBody(PARTS, EmptyHttpHeaders.INSTANCE);
     }
-  }
-
-  private static File getTestfile() throws URISyntaxException {
-    final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
-    final URL url = cl.getResource("textfile.txt");
-    assertNotNull(url);
-    return new File(url.toURI());
-  }
-
-  private static MultipartBody buildMultipart() {
-    return MultipartUtils.newMultipartBody(PARTS, EmptyHttpHeaders.INSTANCE);
-  }
-
-  private static long transferWithCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
-    long transferred = 0;
-    final ByteBuf buffer = Unpooled.buffer(bufferSize);
-    try {
-      while (multipartBody.transferTo(buffer) != BodyState.STOP) {
-        transferred += buffer.readableBytes();
-        buffer.clear();
-      }
-      return transferred;
-    } finally {
-      buffer.release();
+
+    @Test
+    public void transferWithCopy() throws Exception {
+        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+            try (MultipartBody multipartBody = buildMultipart()) {
+                long tranferred = transferWithCopy(multipartBody, bufferLength);
+                assertEquals(tranferred, multipartBody.getContentLength());
+            }
+        }
     }
-  }
-
-  private static long transferZeroCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
-
-    final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
-    final AtomicLong transferred = new AtomicLong();
-
-    WritableByteChannel mockChannel = new WritableByteChannel() {
-      @Override
-      public boolean isOpen() {
-        return true;
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public int write(ByteBuffer src) {
-        int written = src.remaining();
-        transferred.set(transferred.get() + written);
-        src.position(src.limit());
-        return written;
-      }
-    };
-
-    while (transferred.get() < multipartBody.getContentLength()) {
-      multipartBody.transferTo(mockChannel);
-      buffer.clear();
+
+    @Test
+    public void transferZeroCopy() throws Exception {
+        for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
+            try (MultipartBody multipartBody = buildMultipart()) {
+                long tranferred = transferZeroCopy(multipartBody, bufferLength);
+                assertEquals(tranferred, multipartBody.getContentLength());
+            }
+        }
     }
-    return transferred.get();
-  }
-
-  @Test
-  public void transferWithCopy() throws Exception {
-    for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
-      try (MultipartBody multipartBody = buildMultipart()) {
-        long tranferred = transferWithCopy(multipartBody, bufferLength);
-        assertEquals(tranferred, multipartBody.getContentLength());
-      }
+
+    private static long transferWithCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
+        long transferred = 0;
+        final ByteBuf buffer = Unpooled.buffer(bufferSize);
+        try {
+            while (multipartBody.transferTo(buffer) != BodyState.STOP) {
+                transferred += buffer.readableBytes();
+                buffer.clear();
+            }
+            return transferred;
+        } finally {
+            buffer.release();
+        }
     }
-  }
-
-  @Test
-  public void transferZeroCopy() throws Exception {
-    for (int bufferLength = 1; bufferLength < MAX_MULTIPART_CONTENT_LENGTH_ESTIMATE + 1; bufferLength++) {
-      try (MultipartBody multipartBody = buildMultipart()) {
-        long tranferred = transferZeroCopy(multipartBody, bufferLength);
-        assertEquals(tranferred, multipartBody.getContentLength());
-      }
+
+    private static long transferZeroCopy(MultipartBody multipartBody, int bufferSize) throws IOException {
+
+        final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
+        final AtomicLong transferred = new AtomicLong();
+
+        WritableByteChannel mockChannel = new WritableByteChannel() {
+            @Override
+            public boolean isOpen() {
+                return true;
+            }
+
+            @Override
+            public void close() throws IOException {
+            }
+
+            @Override
+            public int write(ByteBuffer src) throws IOException {
+                int written = src.remaining();
+                transferred.set(transferred.get() + written);
+                src.position(src.limit());
+                return written;
+            }
+        };
+
+        while (transferred.get() < multipartBody.getContentLength()) {
+            multipartBody.transferTo(mockChannel);
+            buffer.clear();
+        }
+        return transferred.get();
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
index 77584ecdf..cc69fbe2d 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
@@ -12,6 +12,30 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.UUID;
+import java.util.zip.GZIPInputStream;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.commons.fileupload.FileItemIterator;
 import org.apache.commons.fileupload.FileItemStream;
 import org.apache.commons.fileupload.FileUploadException;
@@ -22,6 +46,7 @@
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -32,313 +57,327 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.*;
-import java.nio.file.Files;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.UUID;
-import java.util.zip.GZIPInputStream;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.asynchttpclient.test.TestUtils.getClasspathFile;
-import static org.testng.Assert.*;
-
 /**
  * @author dominict
  */
 public class MultipartUploadTest extends AbstractBasicTest {
-
-  @BeforeClass
-  public void setUp() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
-    context.addServlet(new ServletHolder(new MockMultipartUploadServlet()), "/upload");
-    server.setHandler(context);
-    server.start();
-    port1 = connector.getLocalPort();
-  }
-
-  @Test
-  public void testSendingSmallFilesAndByteArray() throws Exception {
-    String expectedContents = "filecontent: hello";
-    String expectedContents2 = "gzipcontent: hello";
-    String expectedContents3 = "filecontent: hello2";
-    String testResource1 = "textfile.txt";
-    String testResource2 = "gzip.txt.gz";
-    String testResource3 = "textfile2.txt";
-
-    File testResource1File = getClasspathFile(testResource1);
-    File testResource2File = getClasspathFile(testResource2);
-    File testResource3File = getClasspathFile(testResource3);
-
-    List<File> testFiles = new ArrayList<>();
-    testFiles.add(testResource1File);
-    testFiles.add(testResource2File);
-    testFiles.add(testResource3File);
-
-    List<String> expected = new ArrayList<>();
-    expected.add(expectedContents);
-    expected.add(expectedContents2);
-    expected.add(expectedContents3);
-
-    List<Boolean> gzipped = new ArrayList<>();
-    gzipped.add(false);
-    gzipped.add(true);
-    gzipped.add(false);
-
-    File tmpFile = File.createTempFile("textbytearray", ".txt");
-    try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
-      IOUtils.write(expectedContents.getBytes(UTF_8), os);
-
-      testFiles.add(tmpFile);
-      expected.add(expectedContents);
-      gzipped.add(false);
+    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48,
+            58, 54, 6, 0, 0, 0 };
+
+    @BeforeClass
+    public void setUp() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+        context.addServlet(new ServletHolder(new MockMultipartUploadServlet()), "/upload/*");
+        server.setHandler(context);
+        server.start();
+        port1 = connector.getLocalPort();
     }
 
-    try (AsyncHttpClient c = asyncHttpClient(config())) {
-      Request r = post("http://localhost" + ":" + port1 + "/upload")
-              .addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8))
-              .addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null))
-              .addBodyPart(new StringPart("Name", "Dominic"))
-              .addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8))
-              .addBodyPart(new StringPart("Age", "3")).addBodyPart(new StringPart("Height", "shrimplike"))
-              .addBodyPart(new StringPart("Hair", "ridiculous")).addBodyPart(new ByteArrayPart("file4",
-                      expectedContents.getBytes(UTF_8), "text/plain", UTF_8, "bytearray.txt"))
-              .build();
-
-      Response res = c.executeRequest(r).get();
+    /**
+     * Tests that the streaming of a file works.
+     * @throws IOException 
+     */
+    @Test(groups = "standalone")
+    public void testSendingSmallFilesAndByteArray() throws IOException {
+        String expectedContents = "filecontent: hello";
+        String expectedContents2 = "gzipcontent: hello";
+        String expectedContents3 = "filecontent: hello2";
+        String testResource1 = "textfile.txt";
+        String testResource2 = "gzip.txt.gz";
+        String testResource3 = "textfile2.txt";
+
+        File testResource1File = null;
+        try {
+            testResource1File = getClasspathFile(testResource1);
+        } catch (FileNotFoundException e) {
+            // TODO Auto-generated catch block
+            fail("unable to find " + testResource1);
+        }
 
-      assertEquals(res.getStatusCode(), 200);
+        File testResource2File = null;
+        try {
+            testResource2File = getClasspathFile(testResource2);
+        } catch (FileNotFoundException e) {
+            // TODO Auto-generated catch block
+            fail("unable to find " + testResource2);
+        }
 
-      testSentFile(expected, testFiles, res, gzipped);
-    }
-  }
+        File testResource3File = null;
+        try {
+            testResource3File = getClasspathFile(testResource3);
+        } catch (FileNotFoundException e) {
+            // TODO Auto-generated catch block
+            fail("unable to find " + testResource3);
+        }
 
-  private void sendEmptyFile0(boolean disableZeroCopy) throws Exception {
-    File file = getClasspathFile("empty.txt");
-    try (AsyncHttpClient c = asyncHttpClient(config().setDisableZeroCopy(disableZeroCopy))) {
-      Request r = post("http://localhost" + ":" + port1 + "/upload")
-              .addBodyPart(new FilePart("file", file, "text/plain", UTF_8)).build();
+        List<File> testFiles = new ArrayList<>();
+        testFiles.add(testResource1File);
+        testFiles.add(testResource2File);
+        testFiles.add(testResource3File);
+
+        List<String> expected = new ArrayList<>();
+        expected.add(expectedContents);
+        expected.add(expectedContents2);
+        expected.add(expectedContents3);
+
+        List<Boolean> gzipped = new ArrayList<>();
+        gzipped.add(false);
+        gzipped.add(true);
+        gzipped.add(false);
+
+        boolean tmpFileCreated = false;
+        File tmpFile = File.createTempFile("textbytearray", ".txt");
+        try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
+            IOUtils.write(expectedContents.getBytes(UTF_8), os);
+            tmpFileCreated = true;
+
+            testFiles.add(tmpFile);
+            expected.add(expectedContents);
+            gzipped.add(false);
+
+        } catch (FileNotFoundException e1) {
+            // TODO Auto-generated catch block
+            e1.printStackTrace();
+        } catch (IOException e1) {
+            // TODO Auto-generated catch block
+            e1.printStackTrace();
+        }
 
-      Response res = c.executeRequest(r).get();
-      assertEquals(res.getStatusCode(), 200);
-    }
-  }
-
-  @Test
-  public void sendEmptyFile() throws Exception {
-    sendEmptyFile0(true);
-  }
-
-  @Test
-  public void sendEmptyFileZeroCopy() throws Exception {
-    sendEmptyFile0(false);
-  }
-
-  /**
-   * Test that the files were sent, based on the response from the servlet
-   */
-  private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r,
-                            List<Boolean> deflate) {
-    String content = r.getResponseBody();
-    assertNotNull(content);
-    logger.debug(content);
-
-    String[] contentArray = content.split("\\|\\|");
-    // TODO: this fail on win32
-    assertEquals(contentArray.length, 2);
-
-    String tmpFiles = contentArray[1];
-    assertNotNull(tmpFiles);
-    assertTrue(tmpFiles.trim().length() > 2);
-    tmpFiles = tmpFiles.substring(1, tmpFiles.length() - 1);
-
-    String[] responseFiles = tmpFiles.split(",");
-    assertNotNull(responseFiles);
-    assertEquals(responseFiles.length, sourceFiles.size());
-
-    logger.debug(Arrays.toString(responseFiles));
-
-    int i = 0;
-    for (File sourceFile : sourceFiles) {
-
-      File tmp = null;
-      try {
-
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        byte[] sourceBytes;
-        try (InputStream instream = Files.newInputStream(sourceFile.toPath())) {
-          byte[] buf = new byte[8092];
-          int len;
-          while ((len = instream.read(buf)) > 0) {
-            baos.write(buf, 0, len);
-          }
-          logger.debug("================");
-          logger.debug("Length of file: " + baos.toByteArray().length);
-          logger.debug("Contents: " + Arrays.toString(baos.toByteArray()));
-          logger.debug("================");
-          System.out.flush();
-          sourceBytes = baos.toByteArray();
+        if (!tmpFileCreated) {
+            fail("Unable to test ByteArrayMultiPart, as unable to write to filesystem the tmp test content");
         }
 
-        tmp = new File(responseFiles[i].trim());
-        logger.debug("==============================");
-        logger.debug(tmp.getAbsolutePath());
-        logger.debug("==============================");
-        System.out.flush();
-        assertTrue(tmp.exists());
-
-        byte[] bytes;
-        try (InputStream instream = Files.newInputStream(tmp.toPath())) {
-          ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
-          byte[] buf = new byte[8092];
-          int len;
-          while ((len = instream.read(buf)) > 0) {
-            baos2.write(buf, 0, len);
-          }
-          bytes = baos2.toByteArray();
-          assertEquals(bytes, sourceBytes);
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+
+            RequestBuilder builder = post("http://localhost" + ":" + port1 + "/upload/bob");
+            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8));
+            builder.addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null));
+            builder.addBodyPart(new StringPart("Name", "Dominic"));
+            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8));
+            builder.addBodyPart(new StringPart("Age", "3"));
+            builder.addBodyPart(new StringPart("Height", "shrimplike"));
+            builder.addBodyPart(new StringPart("Hair", "ridiculous"));
+
+            builder.addBodyPart(new ByteArrayPart("file4", expectedContents.getBytes(UTF_8), "text/plain", UTF_8, "bytearray.txt"));
+
+            Request r = builder.build();
+
+            Response res = c.executeRequest(r).get();
+
+            assertEquals(res.getStatusCode(), 200);
+
+            testSentFile(expected, testFiles, res, gzipped);
+
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail("Download Exception");
+        } finally {
+            FileUtils.deleteQuietly(tmpFile);
         }
+    }
 
-        if (!deflate.get(i)) {
-          String helloString = new String(bytes);
-          assertEquals(helloString, expectedContents.get(i));
-        } else {
-          try (InputStream instream = Files.newInputStream(tmp.toPath())) {
-            ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
-            GZIPInputStream deflater = new GZIPInputStream(instream);
+    /**
+     * Test that the files were sent, based on the response from the servlet
+     * 
+     * @param expectedContents
+     * @param sourceFiles
+     * @param r
+     * @param deflate
+     */
+    private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r, List<Boolean> deflate) {
+        String content = r.getResponseBody();
+        assertNotNull("===>" + content);
+        logger.debug(content);
+
+        String[] contentArray = content.split("\\|\\|");
+        // TODO: this fail on win32
+        assertEquals(contentArray.length, 2);
+
+        String tmpFiles = contentArray[1];
+        assertNotNull(tmpFiles);
+        assertTrue(tmpFiles.trim().length() > 2);
+        tmpFiles = tmpFiles.substring(1, tmpFiles.length() - 1);
+
+        String[] responseFiles = tmpFiles.split(",");
+        assertNotNull(responseFiles);
+        assertEquals(responseFiles.length, sourceFiles.size());
+
+        logger.debug(Arrays.toString(responseFiles));
+
+        int i = 0;
+        for (File sourceFile : sourceFiles) {
+
+            File tmp = null;
             try {
-              byte[] buf3 = new byte[8092];
-              int len3;
-              while ((len3 = deflater.read(buf3)) > 0) {
-                baos3.write(buf3, 0, len3);
-              }
-            } finally {
-              deflater.close();
-            }
 
-            String helloString = new String(baos3.toByteArray());
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                byte[] sourceBytes = null;
+                try (InputStream instream = Files.newInputStream(sourceFile.toPath())) {
+                    byte[] buf = new byte[8092];
+                    int len = 0;
+                    while ((len = instream.read(buf)) > 0) {
+                        baos.write(buf, 0, len);
+                    }
+                    logger.debug("================");
+                    logger.debug("Length of file: " + baos.toByteArray().length);
+                    logger.debug("Contents: " + Arrays.toString(baos.toByteArray()));
+                    logger.debug("================");
+                    System.out.flush();
+                    sourceBytes = baos.toByteArray();
+                }
+
+                tmp = new File(responseFiles[i].trim());
+                logger.debug("==============================");
+                logger.debug(tmp.getAbsolutePath());
+                logger.debug("==============================");
+                System.out.flush();
+                assertTrue(tmp.exists());
+
+                byte[] bytes;
+                try (InputStream instream = Files.newInputStream(tmp.toPath())) {
+                    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+                    byte[] buf = new byte[8092];
+                    int len = 0;
+                    while ((len = instream.read(buf)) > 0) {
+                        baos2.write(buf, 0, len);
+                    }
+                    bytes = baos2.toByteArray();
+                    assertEquals(bytes, sourceBytes);
+                }
+
 
-            assertEquals(expectedContents.get(i), helloString);
-          }
+                if (!deflate.get(i)) {
+                    String helloString = new String(bytes);
+                    assertEquals(helloString, expectedContents.get(i));
+                } else {
+                    try (InputStream instream = Files.newInputStream(tmp.toPath())) {
+                        ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
+                        GZIPInputStream deflater = new GZIPInputStream(instream);
+                        try {
+                            byte[] buf3 = new byte[8092];
+                            int len3 = 0;
+                            while ((len3 = deflater.read(buf3)) > 0) {
+                                baos3.write(buf3, 0, len3);
+                            }
+                        } finally {
+                            deflater.close();
+                        }
+    
+                        String helloString = new String(baos3.toByteArray());
+    
+                        assertEquals(expectedContents.get(i), helloString);
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                fail("Download Exception");
+            } finally {
+                if (tmp != null)
+                    FileUtils.deleteQuietly(tmp);
+                i++;
+            }
         }
-      } catch (Exception e) {
-        e.printStackTrace();
-        fail("Download Exception");
-      } finally {
-        if (tmp != null)
-          FileUtils.deleteQuietly(tmp);
-        i++;
-      }
     }
-  }
 
-  /**
-   * Takes the content that is being passed to it, and streams to a file on disk
-   *
-   * @author dominict
-   */
-  public static class MockMultipartUploadServlet extends HttpServlet {
+    /**
+     * Takes the content that is being passed to it, and streams to a file on disk
+     * 
+     * @author dominict
+     */
+    public static class MockMultipartUploadServlet extends HttpServlet {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(MockMultipartUploadServlet.class);
+        private static final Logger LOGGER = LoggerFactory.getLogger(MockMultipartUploadServlet.class);
 
-    private static final long serialVersionUID = 1L;
-    private int filesProcessed = 0;
-    private int stringsProcessed = 0;
+        private static final long serialVersionUID = 1L;
+        private int filesProcessed = 0;
+        private int stringsProcessed = 0;
 
-    MockMultipartUploadServlet() {
+        public MockMultipartUploadServlet() {
 
-    }
+        }
 
-    synchronized void resetFilesProcessed() {
-      filesProcessed = 0;
-    }
+        public synchronized void resetFilesProcessed() {
+            filesProcessed = 0;
+        }
 
-    private synchronized int incrementFilesProcessed() {
-      return ++filesProcessed;
-    }
+        private synchronized int incrementFilesProcessed() {
+            return ++filesProcessed;
 
-    int getFilesProcessed() {
-      return filesProcessed;
-    }
+        }
 
-    synchronized void resetStringsProcessed() {
-      stringsProcessed = 0;
-    }
+        public int getFilesProcessed() {
+            return filesProcessed;
+        }
 
-    private synchronized int incrementStringsProcessed() {
-      return ++stringsProcessed;
+        public synchronized void resetStringsProcessed() {
+            stringsProcessed = 0;
+        }
 
-    }
+        private synchronized int incrementStringsProcessed() {
+            return ++stringsProcessed;
 
-    public int getStringsProcessed() {
-      return stringsProcessed;
-    }
+        }
+
+        public int getStringsProcessed() {
+            return stringsProcessed;
+        }
+
+        @Override
+        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+            // Check that we have a file upload request
+            boolean isMultipart = ServletFileUpload.isMultipartContent(request);
+            if (isMultipart) {
+                List<String> files = new ArrayList<>();
+                ServletFileUpload upload = new ServletFileUpload();
+                // Parse the request
+                FileItemIterator iter = null;
+                try {
+                    iter = upload.getItemIterator(request);
+                    while (iter.hasNext()) {
+                        FileItemStream item = iter.next();
+                        String name = item.getFieldName();
+                        try (InputStream stream = item.openStream()) {
+
+                            if (item.isFormField()) {
+                                LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
+                                incrementStringsProcessed();
+                            } else {
+                                LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
+                                // Process the input stream
+                                File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet", ".tmp");
+                                tmpFile.deleteOnExit();
+                                try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
+                                    byte[] buffer = new byte[4096];
+                                    int bytesRead;
+                                    while ((bytesRead = stream.read(buffer)) != -1) {
+                                        os.write(buffer, 0, bytesRead);
+                                    }
+                                    incrementFilesProcessed();
+                                    files.add(tmpFile.getAbsolutePath());
+                                }
+                            }
+                        }
+                    }
+                } catch (FileUploadException e) {
 
-    @Override
-    public void service(HttpServletRequest request, HttpServletResponse response)
-            throws IOException {
-      // Check that we have a file upload request
-      boolean isMultipart = ServletFileUpload.isMultipartContent(request);
-      if (isMultipart) {
-        List<String> files = new ArrayList<>();
-        ServletFileUpload upload = new ServletFileUpload();
-        // Parse the request
-        FileItemIterator iter;
-        try {
-          iter = upload.getItemIterator(request);
-          while (iter.hasNext()) {
-            FileItemStream item = iter.next();
-            String name = item.getFieldName();
-            try (InputStream stream = item.openStream()) {
-
-              if (item.isFormField()) {
-                LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream)
-                        + " detected.");
-                incrementStringsProcessed();
-              } else {
-                LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
-                // Process the input stream
-                File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet",
-                        ".tmp");
-                tmpFile.deleteOnExit();
-                try (OutputStream os = Files.newOutputStream(tmpFile.toPath())) {
-                  byte[] buffer = new byte[4096];
-                  int bytesRead;
-                  while ((bytesRead = stream.read(buffer)) != -1) {
-                    os.write(buffer, 0, bytesRead);
-                  }
-                  incrementFilesProcessed();
-                  files.add(tmpFile.getAbsolutePath());
                 }
-              }
+                try (Writer w = response.getWriter()) {
+                    w.write(Integer.toString(getFilesProcessed()));
+                    resetFilesProcessed();
+                    resetStringsProcessed();
+                    w.write("||");
+                    w.write(files.toString());
+                }
+            } else {
+                try (Writer w = response.getWriter()) {
+                    w.write(Integer.toString(getFilesProcessed()));
+                    resetFilesProcessed();
+                    resetStringsProcessed();
+                    w.write("||");
+                }
             }
-          }
-        } catch (FileUploadException e) {
-          //
-        }
-        try (Writer w = response.getWriter()) {
-          w.write(Integer.toString(getFilesProcessed()));
-          resetFilesProcessed();
-          resetStringsProcessed();
-          w.write("||");
-          w.write(files.toString());
-        }
-      } else {
-        try (Writer w = response.getWriter()) {
-          w.write(Integer.toString(getFilesProcessed()));
-          resetFilesProcessed();
-          resetStringsProcessed();
-          w.write("||");
         }
-      }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
index b66c7975f..b7b9890ce 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -13,15 +13,12 @@
  */
 package org.asynchttpclient.request.body.multipart.part;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.apache.commons.io.FileUtils;
-import org.asynchttpclient.request.body.multipart.*;
-import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
-import org.asynchttpclient.test.TestUtils;
-import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.net.URISyntaxException;
@@ -31,245 +28,255 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.request.body.multipart.FileLikePart;
+import org.asynchttpclient.request.body.multipart.MultipartBody;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
+import org.asynchttpclient.test.TestUtils;
+import org.testng.annotations.Test;
 
 public class MultipartPartTest {
 
-  @Test
-  public void testVisitStart() {
-    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[10])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitStart(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 12, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count plus boundary bytes count");
+    @Test
+    public void testVisitStart() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[10])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitStart(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 12, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count plus boundary bytes count");
+        }
     }
-  }
-
-  @Test
-  public void testVisitStartZeroSizedByteArray() {
-    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitStart(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count when boundary byte array is of size zero");
-    }
-  }
-
-  @Test
-  public void testVisitDispositionHeaderWithoutFileName() {
-    TestFileLikePart fileLikePart = new TestFileLikePart("Name");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitDispositionHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length when file name is not specified");
+
+    @Test
+    public void testVisitStartZeroSizedByteArray() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitStart(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitStart should match EXTRA_BYTES count when boundary byte array is of size zero");
+        }
     }
-  }
-
-  @Test
-  public void testVisitDispositionHeaderWithFileName() {
-    TestFileLikePart fileLikePart = new TestFileLikePart("baPart", null, null, null, null, "fileName");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitDispositionHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 68, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length + file name length when" + " both part name and file name are present");
+
+    @Test
+    public void testVisitDispositionHeaderWithoutFileName() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length when file name is not specified");
+        }
     }
-  }
-
-  @Test
-  public void testVisitDispositionHeaderWithoutName() {
-    // with fileName
-    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, null, "fileName");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitDispositionHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 53, "CounterPartVisitor count for visitDispositionHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + file name length when part name is not specified");
+
+    @Test
+    public void testVisitDispositionHeaderWithFileName() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("baPart", null, null, null, null, "fileName");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 68, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length + file name length when" + " both part name and file name are present");
+        }
     }
-  }
-
-  @Test
-  public void testVisitContentTypeHeaderWithCharset() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test", UTF_8, null, null);
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitContentTypeHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 47, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length + charset length");
+
+    @Test
+    public void testVisitDispositionHeaderWithoutName() {
+        // with fileName
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, null, "fileName");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 53, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + file name length when part name is not specified");
+        }
     }
-  }
-
-  @Test
-  public void testVisitContentTypeHeaderWithoutCharset() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitContentTypeHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 32, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length when charset is not specified");
+
+    @Test
+    public void testVisitContentTypeHeaderWithCharset() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test", UTF_8, null, null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentTypeHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 47, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length + charset length");
+        }
     }
-  }
-
-  @Test
-  public void testVisitTransferEncodingHeader() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, "transferEncoding");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitTransferEncodingHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitTransferEncodingHeader should be equal to "
-              + "CRLF_BYTES length + CONTENT_TRANSFER_ENCODING_BYTES length + transferEncoding length");
+
+    @Test
+    public void testVisitContentTypeHeaderWithoutCharset() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentTypeHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 32, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length when charset is not specified");
+        }
     }
-  }
-
-  @Test
-  public void testVisitContentIdHeader() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, "contentId");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitContentIdHeader(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 23, "CounterPartVisitor count for visitContentIdHeader should be equal to"
-              + "CRLF_BYTES length + CONTENT_ID_BYTES length + contentId length");
+
+    @Test
+    public void testVisitTransferEncodingHeader() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, "transferEncoding");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitTransferEncodingHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitTransferEncodingHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TRANSFER_ENCODING_BYTES length + transferEncoding length");
+        }
     }
-  }
-
-  @Test
-  public void testVisitCustomHeadersWhenNoCustomHeaders() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null);
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitCustomHeaders(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 0, "CounterPartVisitor count for visitCustomHeaders should be zero for visitCustomHeaders "
-              + "when there are no custom headers");
+
+    @Test
+    public void testVisitContentIdHeader() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, "contentId");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentIdHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 23, "CounterPartVisitor count for visitContentIdHeader should be equal to"
+                    + "CRLF_BYTES length + CONTENT_ID_BYTES length + contentId length");
+        }
     }
-  }
-
-  @Test
-  public void testVisitCustomHeaders() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null);
-    fileLikePart.addCustomHeader("custom-header", "header-value");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitCustomHeaders(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 29, "CounterPartVisitor count for visitCustomHeaders should include the length of the custom headers");
+
+    @Test
+    public void testVisitCustomHeadersWhenNoCustomHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitCustomHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 0, "CounterPartVisitor count for visitCustomHeaders should be zero for visitCustomHeaders "
+                    + "when there are no custom headers");
+        }
     }
-  }
-
-  @Test
-  public void testVisitEndOfHeaders() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null);
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitEndOfHeaders(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 4, "CounterPartVisitor count for visitEndOfHeaders should be equal to 4");
+
+    @Test
+    public void testVisitCustomHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        fileLikePart.addCustomHeader("custom-header", "header-value");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitCustomHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 29, "CounterPartVisitor count for visitCustomHeaders should include the length of the custom headers");
+        }
     }
-  }
-
-  @Test
-  public void testVisitPreContent() {
-    TestFileLikePart fileLikePart = new TestFileLikePart("Name", "application/test", UTF_8, "contentId", "transferEncoding", "fileName");
-    fileLikePart.addCustomHeader("custom-header", "header-value");
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitPreContent(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 216, "CounterPartVisitor count for visitPreContent should " + "be equal to the sum of the lengths of precontent");
+
+    @Test
+    public void testVisitEndOfHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitEndOfHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 4, "CounterPartVisitor count for visitEndOfHeaders should be equal to 4");
+        }
     }
-  }
-
-  @Test
-  public void testVisitPostContents() {
-    TestFileLikePart fileLikePart = new TestFileLikePart(null);
-    try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
-      CounterPartVisitor counterVisitor = new CounterPartVisitor();
-      multipartPart.visitPostContent(counterVisitor);
-      assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitPostContent should be equal to 2");
+
+    @Test
+    public void testVisitPreContent() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name", "application/test", UTF_8, "contentId", "transferEncoding", "fileName");
+        fileLikePart.addCustomHeader("custom-header", "header-value");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitPreContent(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 216, "CounterPartVisitor count for visitPreContent should " + "be equal to the sum of the lengths of precontent");
+        }
     }
-  }
-
-  @Test
-  public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
-    String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"), UTF_8);
-
-    List<Part> parts = new ArrayList<>();
-    parts.add(new StringPart("test_sample_message.eml", text));
-
-    HttpHeaders headers = new DefaultHttpHeaders();
-    headers.set(
-            "Cookie",
-            "open-xchange-public-session-d41d8cd98f00b204e9800998ecf8427e=bfb98150b24f42bd844fc9ef2a9eaad5; open-xchange-secret-TSlq4Cm4nCBnDpBL1Px2A=9a49b76083e34c5ba2ef5c47362313fd; JSESSIONID=6883138728830405130.OX2");
-    headers.set("Content-Length", "9241");
-    headers.set("Content-Type", "multipart/form-data; boundary=5gigAKQyqDCVdlZ1fCkeLlEDDauTNoOOEhRnFg");
-    headers.set("Host", "appsuite.qa.open-xchange.com");
-    headers.set("Accept", "*/*");
-
-    String boundary = "uwyqQolZaSmme019O2kFKvAeHoC14Npp";
-
-    List<MultipartPart<? extends Part>> multipartParts = MultipartUtils.generateMultipartParts(parts, boundary.getBytes());
-    try (MultipartBody multipartBody = new MultipartBody(multipartParts, "multipart/form-data; boundary=" + boundary, boundary.getBytes())) {
-
-      ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(8 * 1024);
-      multipartBody.transferTo(byteBuf);
-      try {
-        byteBuf.toString(StandardCharsets.UTF_8);
-      } finally {
-        byteBuf.release();
-      }
+
+    @Test
+    public void testVisitPostContents() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitPostContent(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitPostContent should be equal to 2");
+        }
     }
-  }
 
-  /**
-   * Concrete implementation of {@link FileLikePart} for use in unit tests
-   */
-  private class TestFileLikePart extends FileLikePart {
+    @Test
+    public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
+        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"));
 
-    TestFileLikePart(String name) {
-      this(name, null, null, null, null);
-    }
+        List<Part> parts = new ArrayList<>();
+        parts.add(new StringPart("test_sample_message.eml", text));
 
-    TestFileLikePart(String name, String contentType) {
-      this(name, contentType, null);
-    }
+        HttpHeaders headers = new DefaultHttpHeaders();
+        headers.set(
+                "Cookie",
+                "open-xchange-public-session-d41d8cd98f00b204e9800998ecf8427e=bfb98150b24f42bd844fc9ef2a9eaad5; open-xchange-secret-TSlq4Cm4nCBnDpBL1Px2A=9a49b76083e34c5ba2ef5c47362313fd; JSESSIONID=6883138728830405130.OX2");
+        headers.set("Content-Length", "9241");
+        headers.set("Content-Type", "multipart/form-data; boundary=5gigAKQyqDCVdlZ1fCkeLlEDDauTNoOOEhRnFg");
+        headers.set("Host", "appsuite.qa.open-xchange.com");
+        headers.set("Accept", "*/*");
 
-    TestFileLikePart(String name, String contentType, Charset charset) {
-      this(name, contentType, charset, null);
-    }
+        String boundary = "uwyqQolZaSmme019O2kFKvAeHoC14Npp";
 
-    TestFileLikePart(String name, String contentType, Charset charset, String contentId) {
-      this(name, contentType, charset, contentId, null);
-    }
+        List<MultipartPart<? extends Part>> multipartParts = MultipartUtils.generateMultipartParts(parts, boundary.getBytes());
+        MultipartBody multipartBody = new MultipartBody(multipartParts, "multipart/form-data; boundary=" + boundary, boundary.getBytes());
 
-    TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
-      this(name, contentType, charset, contentId, transfertEncoding, null);
-    }
+        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(8 * 1024);
 
-    TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding, String fileName) {
-      super(name, contentType, charset, fileName, contentId, transfertEncoding);
+        try {
+            multipartBody.transferTo(byteBuf);
+            byteBuf.toString(StandardCharsets.UTF_8);
+        } finally {
+            multipartBody.close();
+            byteBuf.release();
+        }
     }
-  }
 
-  /**
-   * Concrete implementation of MultipartPart for use in unit tests.
-   */
-  private class TestMultipartPart extends FileLikeMultipartPart<TestFileLikePart> {
+    /**
+     * Concrete implementation of {@link FileLikePart} for use in unit tests
+     * 
+     */
+    private class TestFileLikePart extends FileLikePart {
 
-    TestMultipartPart(TestFileLikePart part, byte[] boundary) {
-      super(part, boundary);
-    }
+        public TestFileLikePart(String name) {
+            this(name, null, null, null, null);
+        }
 
-    @Override
-    protected long getContentLength() {
-      return 0;
-    }
+        public TestFileLikePart(String name, String contentType) {
+            this(name, contentType, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset) {
+            this(name, contentType, charset, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId) {
+            this(name, contentType, charset, contentId, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
+            this(name, contentType, charset, contentId, transfertEncoding, null);
+        }
 
-    @Override
-    protected long transferContentTo(ByteBuf target) {
-      return 0;
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding, String fileName) {
+            super(name, contentType, charset, fileName, contentId, transfertEncoding);
+        }
     }
 
-    @Override
-    protected long transferContentTo(WritableByteChannel target) {
-      return 0;
+    /**
+     * Concrete implementation of MultipartPart for use in unit tests.
+     *
+     */
+    private class TestMultipartPart extends FileLikeMultipartPart<TestFileLikePart> {
+
+        public TestMultipartPart(TestFileLikePart part, byte[] boundary) {
+            super(part, boundary);
+        }
+
+        @Override
+        protected long getContentLength() {
+            return 0;
+        }
+
+        @Override
+        protected long transferContentTo(ByteBuf target) throws IOException {
+            return 0;
+        }
+
+        @Override
+        protected long transferContentTo(WritableByteChannel target) throws IOException {
+            return 0;
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
index ee19f2ee0..48744f408 100644
--- a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
@@ -13,129 +13,128 @@
  */
 package org.asynchttpclient.test;
 
-import org.apache.commons.io.IOUtils;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static io.netty.handler.codec.http.HttpHeaderNames.*;
+
+import java.io.IOException;
+import java.util.Enumeration;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.Enumeration;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_MD5;
+import org.apache.commons.io.IOUtils;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class EchoHandler extends AbstractHandler {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(EchoHandler.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(EchoHandler.class);
 
-  @Override
-  public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+    @Override
+    public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
-    LOGGER.debug("Echo received request {} on path {}", request, pathInContext);
+        LOGGER.debug("Echo received request {} on path {}", request, pathInContext);
 
-    if (httpRequest.getHeader("X-HEAD") != null) {
-      httpResponse.setContentLength(1);
-    }
-
-    if (httpRequest.getHeader("X-ISO") != null) {
-      httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
-    } else {
-      httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-    }
+        if (httpRequest.getHeader("X-HEAD") != null) {
+            httpResponse.setContentLength(1);
+        }
 
-    if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
-      httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-    }
+        if (httpRequest.getHeader("X-ISO") != null) {
+            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+        } else {
+            httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+        }
 
-    Enumeration<String> e = httpRequest.getHeaderNames();
-    String headerName;
-    while (e.hasMoreElements()) {
-      headerName = e.nextElement();
-      if (headerName.startsWith("LockThread")) {
-        final int sleepTime = httpRequest.getIntHeader(headerName);
-        try {
-          Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
-        } catch (InterruptedException ex) {
-          //
+        if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+            httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
         }
-      }
 
-      if (headerName.startsWith("X-redirect")) {
-        httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-        return;
-      }
-      httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
-    }
+        Enumeration<String> e = httpRequest.getHeaderNames();
+        String headerName;
+        while (e.hasMoreElements()) {
+            headerName = e.nextElement();
+            if (headerName.startsWith("LockThread")) {
+                final int sleepTime = httpRequest.getIntHeader(headerName);
+                try {
+                    Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
+                } catch (InterruptedException ex) {
+                }
+            }
+
+            if (headerName.startsWith("X-redirect")) {
+                httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+                return;
+            }
+            httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
+        }
 
-    String pathInfo = httpRequest.getPathInfo();
-    if (pathInfo != null)
-      httpResponse.addHeader("X-pathInfo", pathInfo);
+        String pathInfo = httpRequest.getPathInfo();
+        if (pathInfo != null)
+            httpResponse.addHeader("X-pathInfo", pathInfo);
 
-    String queryString = httpRequest.getQueryString();
-    if (queryString != null)
-      httpResponse.addHeader("X-queryString", queryString);
+        String queryString = httpRequest.getQueryString();
+        if (queryString != null)
+            httpResponse.addHeader("X-queryString", queryString);
 
-    httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+        httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
 
-    Cookie[] cs = httpRequest.getCookies();
-    if (cs != null) {
-      for (Cookie c : cs) {
-        httpResponse.addCookie(c);
-      }
-    }
+        Cookie[] cs = httpRequest.getCookies();
+        if (cs != null) {
+            for (Cookie c : cs) {
+                httpResponse.addCookie(c);
+            }
+        }
 
-    Enumeration<String> i = httpRequest.getParameterNames();
-    if (i.hasMoreElements()) {
-      StringBuilder requestBody = new StringBuilder();
-      while (i.hasMoreElements()) {
-        headerName = i.nextElement();
-        httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
-        requestBody.append(headerName);
-        requestBody.append("_");
-      }
-
-      if (requestBody.length() > 0) {
-        String body = requestBody.toString();
-        httpResponse.getOutputStream().write(body.getBytes());
-      }
-    }
+        Enumeration<String> i = httpRequest.getParameterNames();
+        if (i.hasMoreElements()) {
+            StringBuilder requestBody = new StringBuilder();
+            while (i.hasMoreElements()) {
+                headerName = i.nextElement();
+                httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
+                requestBody.append(headerName);
+                requestBody.append("_");
+            }
+
+            if (requestBody.length() > 0) {
+                String body = requestBody.toString();
+                httpResponse.getOutputStream().write(body.getBytes());
+            }
+        }
 
-    String requestBodyLength = httpRequest.getHeader("X-" + CONTENT_LENGTH);
-
-    if (requestBodyLength != null) {
-      byte[] requestBodyBytes = IOUtils.toByteArray(httpRequest.getInputStream());
-      int total = requestBodyBytes.length;
-
-      httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
-      String md5 = TestUtils.md5(requestBodyBytes, 0, total);
-      httpResponse.addHeader(CONTENT_MD5.toString(), md5);
-
-      httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
-    } else {
-      int size = 16384;
-      if (httpRequest.getContentLength() > 0) {
-        size = httpRequest.getContentLength();
-      }
-      if (size > 0) {
-        int read = 0;
-        while (read > -1) {
-          byte[] bytes = new byte[size];
-          read = httpRequest.getInputStream().read(bytes);
-          if (read > 0) {
-            httpResponse.getOutputStream().write(bytes, 0, read);
-          }
+        String requestBodyLength = httpRequest.getHeader("X-" + CONTENT_LENGTH);
+
+        if (requestBodyLength != null) {
+            byte[] requestBodyBytes = IOUtils.toByteArray(httpRequest.getInputStream());
+            int total = requestBodyBytes.length;
+
+            httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
+            String md5 = TestUtils.md5(requestBodyBytes, 0, total);
+            httpResponse.addHeader(CONTENT_MD5.toString(), md5);
+
+            httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
+        } else {
+            int size = 16384;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            if (size > 0) {
+                int read = 0;
+                while (read > -1) {
+                    byte[] bytes = new byte[size];
+                    read = httpRequest.getInputStream().read(bytes);
+                    if (read > 0) {
+                        httpResponse.getOutputStream().write(bytes, 0, read);
+                    }
+                }
+            }
         }
-      }
-    }
 
-    request.setHandled(true);
-    httpResponse.getOutputStream().flush();
-    // FIXME don't always close, depends on the test, cf ReactiveStreamsTest
-    httpResponse.getOutputStream().close();
-  }
+        request.setHandled(true);
+        httpResponse.getOutputStream().flush();
+        // FIXME don't always close, depends on the test, cf ReactiveStreamsTest
+        httpResponse.getOutputStream().close();
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
index 252de4191..0e0b594ed 100644
--- a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -14,11 +14,6 @@
 
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AsyncCompletionHandlerBase;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.netty.request.NettyRequest;
-import org.testng.Assert;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -27,138 +22,145 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-public class EventCollectingHandler extends AsyncCompletionHandlerBase {
-
-  public static final String COMPLETED_EVENT = "Completed";
-  public static final String STATUS_RECEIVED_EVENT = "StatusReceived";
-  public static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
-  public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
-  private static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
-  private static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-  private static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
-  private static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
-  private static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
-  private static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
-  private static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
-  private static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
-  private static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
-  private static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
-  public static final String CONNECTION_POOL_EVENT = "ConnectionPool";
-  public static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
-  public static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
-  public static final String REQUEST_SEND_EVENT = "RequestSend";
-  private static final String RETRY_EVENT = "Retry";
-
-  public Queue<String> firedEvents = new ConcurrentLinkedQueue<>();
-  private CountDownLatch completionLatch = new CountDownLatch(1);
-
-  public void waitForCompletion(int timeout, TimeUnit unit) throws InterruptedException {
-    if (!completionLatch.await(timeout, unit)) {
-      Assert.fail("Timeout out");
-    }
-  }
-
-  @Override
-  public Response onCompleted(Response response) throws Exception {
-    firedEvents.add(COMPLETED_EVENT);
-    try {
-      return super.onCompleted(response);
-    } finally {
-      completionLatch.countDown();
-    }
-  }
-
-  @Override
-  public State onStatusReceived(HttpResponseStatus status) throws Exception {
-    firedEvents.add(STATUS_RECEIVED_EVENT);
-    return super.onStatusReceived(status);
-  }
-
-  @Override
-  public State onHeadersReceived(HttpHeaders headers) throws Exception {
-    firedEvents.add(HEADERS_RECEIVED_EVENT);
-    return super.onHeadersReceived(headers);
-  }
-
-  @Override
-  public State onHeadersWritten() {
-    firedEvents.add(HEADERS_WRITTEN_EVENT);
-    return super.onHeadersWritten();
-  }
-
-  @Override
-  public State onContentWritten() {
-    firedEvents.add(CONTENT_WRITTEN_EVENT);
-    return super.onContentWritten();
-  }
-
-  @Override
-  public void onTcpConnectAttempt(InetSocketAddress address) {
-    firedEvents.add(CONNECTION_OPEN_EVENT);
-  }
-
-  @Override
-  public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
-    firedEvents.add(CONNECTION_SUCCESS_EVENT);
-  }
-
-  @Override
-  public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
-    firedEvents.add(CONNECTION_FAILURE_EVENT);
-  }
-
-  @Override
-  public void onHostnameResolutionAttempt(String name) {
-    firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
-  }
-
-  @Override
-  public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-    firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
-  }
-
-  @Override
-  public void onHostnameResolutionFailure(String name, Throwable cause) {
-    firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
-  }
-
-  @Override
-  public void onTlsHandshakeAttempt() {
-    firedEvents.add(TLS_HANDSHAKE_EVENT);
-  }
-
-  @Override
-  public void onTlsHandshakeSuccess() {
-    firedEvents.add(TLS_HANDSHAKE_SUCCESS_EVENT);
-  }
-
-  @Override
-  public void onTlsHandshakeFailure(Throwable cause) {
-    firedEvents.add(TLS_HANDSHAKE_FAILURE_EVENT);
-  }
-
-  @Override
-  public void onConnectionPoolAttempt() {
-    firedEvents.add(CONNECTION_POOL_EVENT);
-  }
-
-  @Override
-  public void onConnectionPooled(Channel connection) {
-    firedEvents.add(CONNECTION_POOLED_EVENT);
-  }
-
-  @Override
-  public void onConnectionOffer(Channel connection) {
-    firedEvents.add(CONNECTION_OFFER_EVENT);
-  }
-
-  @Override
-  public void onRequestSend(NettyRequest request) {
-    firedEvents.add(REQUEST_SEND_EVENT);
-  }
-
-  @Override
-  public void onRetry() {
-    firedEvents.add(RETRY_EVENT);
-  }
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.request.NettyRequest;
+import org.testng.Assert;
+
+public class EventCollectingHandler extends AsyncCompletionHandlerBase implements AsyncHandlerExtensions {
+
+    public static final String COMPLETED_EVENT = "Completed";
+    public static final String STATUS_RECEIVED_EVENT = "StatusReceived";
+    public static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
+    public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
+    public static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
+    public static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
+    public static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+    public static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+    public static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
+    public static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
+    public static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
+    public static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+    public static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+    public static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
+    public static final String CONNECTION_POOL_EVENT = "ConnectionPool";
+    public static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
+    public static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
+    public static final String REQUEST_SEND_EVENT = "RequestSend";
+    public static final String RETRY_EVENT = "Retry";
+
+    public Queue<String> firedEvents = new ConcurrentLinkedQueue<>();
+    private CountDownLatch completionLatch = new CountDownLatch(1);
+
+    public void waitForCompletion(int timeout, TimeUnit unit) throws InterruptedException {
+        if (!completionLatch.await(timeout, unit)) {
+            Assert.fail("Timeout out");
+        }
+    }
+
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+        firedEvents.add(COMPLETED_EVENT);
+        try {
+            return super.onCompleted(response);
+        } finally {
+            completionLatch.countDown();
+        }
+    }
+
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+        firedEvents.add(STATUS_RECEIVED_EVENT);
+        return super.onStatusReceived(status);
+    }
+
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        firedEvents.add(HEADERS_RECEIVED_EVENT);
+        return super.onHeadersReceived(headers);
+    }
+
+    @Override
+    public State onHeadersWritten() {
+        firedEvents.add(HEADERS_WRITTEN_EVENT);
+        return super.onHeadersWritten();
+    }
+
+    @Override
+    public State onContentWritten() {
+        firedEvents.add(CONTENT_WRITTEN_EVENT);
+        return super.onContentWritten();
+    }
+
+    @Override
+    public void onTcpConnectAttempt(InetSocketAddress address) {
+        firedEvents.add(CONNECTION_OPEN_EVENT);
+    }
+
+    @Override
+    public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
+        firedEvents.add(CONNECTION_SUCCESS_EVENT);
+    }
+
+    @Override
+    public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
+        firedEvents.add(CONNECTION_FAILURE_EVENT);
+    }
+
+    @Override
+    public void onHostnameResolutionAttempt(String name) {
+        firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
+    }
+
+    @Override
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+        firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
+    }
+
+    @Override
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+        firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
+    }
+
+    @Override
+    public void onTlsHandshakeAttempt() {
+        firedEvents.add(TLS_HANDSHAKE_EVENT);
+    }
+
+    @Override
+    public void onTlsHandshakeSuccess() {
+        firedEvents.add(TLS_HANDSHAKE_SUCCESS_EVENT);
+    }
+
+    @Override
+    public void onTlsHandshakeFailure(Throwable cause) {
+        firedEvents.add(TLS_HANDSHAKE_FAILURE_EVENT);
+    }
+
+    @Override
+    public void onConnectionPoolAttempt() {
+        firedEvents.add(CONNECTION_POOL_EVENT);
+    }
+
+    @Override
+    public void onConnectionPooled(Channel connection) {
+        firedEvents.add(CONNECTION_POOLED_EVENT);
+    }
+
+    @Override
+    public void onConnectionOffer(Channel connection) {
+        firedEvents.add(CONNECTION_OFFER_EVENT);
+    }
+
+    @Override
+    public void onRequestSend(NettyRequest request) {
+        firedEvents.add(REQUEST_SEND_EVENT);
+    }
+
+    @Override
+    public void onRetry() {
+        firedEvents.add(RETRY_EVENT);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java b/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
index 0f08ffe52..f3994ece5 100644
--- a/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
+++ b/client/src/test/java/org/asynchttpclient/test/Slf4jJuliLog.java
@@ -19,105 +19,105 @@
 
 public class Slf4jJuliLog implements Log {
 
-  private final Logger logger;
-
-  // just so that ServiceLoader doesn't crash, unused
-  public Slf4jJuliLog() {
-    logger = null;
-  }
-
-  // actual constructor
-  public Slf4jJuliLog(String name) {
-    logger = LoggerFactory.getLogger(name);
-  }
-
-  @Override
-  public void debug(Object arg0) {
-    logger.debug(arg0.toString());
-  }
-
-  @Override
-  public void debug(Object arg0, Throwable arg1) {
-    logger.debug(arg0.toString(), arg1);
-  }
-
-  @Override
-  public void error(Object arg0) {
-    logger.error(arg0.toString());
-  }
-
-  @Override
-  public void error(Object arg0, Throwable arg1) {
-    logger.error(arg0.toString(), arg1);
-  }
-
-  @Override
-  public void fatal(Object arg0) {
-    logger.error(arg0.toString());
-  }
-
-  @Override
-  public void fatal(Object arg0, Throwable arg1) {
-    logger.error(arg0.toString(), arg1);
-  }
-
-  @Override
-  public void info(Object arg0) {
-    logger.info(arg0.toString());
-  }
-
-  @Override
-  public void info(Object arg0, Throwable arg1) {
-    logger.info(arg0.toString(), arg1);
-  }
-
-  @Override
-  public boolean isDebugEnabled() {
-    return logger.isDebugEnabled();
-  }
-
-  @Override
-  public boolean isErrorEnabled() {
-    return logger.isErrorEnabled();
-  }
-
-  @Override
-  public boolean isFatalEnabled() {
-    return logger.isErrorEnabled();
-  }
-
-  @Override
-  public boolean isInfoEnabled() {
-    return logger.isInfoEnabled();
-  }
-
-  @Override
-  public boolean isTraceEnabled() {
-    return logger.isTraceEnabled();
-  }
-
-  @Override
-  public boolean isWarnEnabled() {
-    return logger.isWarnEnabled();
-  }
-
-  @Override
-  public void trace(Object arg0) {
-    logger.trace(arg0.toString());
-  }
-
-  @Override
-  public void trace(Object arg0, Throwable arg1) {
-    logger.trace(arg0.toString(), arg1);
-  }
-
-  @Override
-  public void warn(Object arg0) {
-    logger.warn(arg0.toString());
-  }
-
-  @Override
-  public void warn(Object arg0, Throwable arg1) {
-    logger.warn(arg0.toString(), arg1);
-  }
+    private final Logger logger;
+
+    // just so that ServiceLoader doesn't crash, unused
+    public Slf4jJuliLog() {
+        logger = null;
+    }
+
+    // actual constructor
+    public Slf4jJuliLog(String name) {
+        logger = LoggerFactory.getLogger(name);
+    }
+
+    @Override
+    public void debug(Object arg0) {
+        logger.debug(arg0.toString());
+    }
+
+    @Override
+    public void debug(Object arg0, Throwable arg1) {
+        logger.debug(arg0.toString(), arg1);
+    }
+
+    @Override
+    public void error(Object arg0) {
+        logger.error(arg0.toString());
+    }
+
+    @Override
+    public void error(Object arg0, Throwable arg1) {
+        logger.error(arg0.toString(), arg1);
+    }
+
+    @Override
+    public void fatal(Object arg0) {
+        logger.error(arg0.toString());
+    }
+
+    @Override
+    public void fatal(Object arg0, Throwable arg1) {
+        logger.error(arg0.toString(), arg1);
+    }
+
+    @Override
+    public void info(Object arg0) {
+        logger.info(arg0.toString());
+    }
+
+    @Override
+    public void info(Object arg0, Throwable arg1) {
+        logger.info(arg0.toString(), arg1);
+    }
+
+    @Override
+    public boolean isDebugEnabled() {
+        return logger.isDebugEnabled();
+    }
+
+    @Override
+    public boolean isErrorEnabled() {
+        return logger.isErrorEnabled();
+    }
+
+    @Override
+    public boolean isFatalEnabled() {
+        return logger.isErrorEnabled();
+    }
+
+    @Override
+    public boolean isInfoEnabled() {
+        return logger.isInfoEnabled();
+    }
+
+    @Override
+    public boolean isTraceEnabled() {
+        return logger.isTraceEnabled();
+    }
+
+    @Override
+    public boolean isWarnEnabled() {
+        return logger.isWarnEnabled();
+    }
+
+    @Override
+    public void trace(Object arg0) {
+        logger.trace(arg0.toString());
+    }
+
+    @Override
+    public void trace(Object arg0, Throwable arg1) {
+        logger.trace(arg0.toString(), arg1);
+    }
+
+    @Override
+    public void warn(Object arg0) {
+        logger.warn(arg0.toString());
+    }
+
+    @Override
+    public void warn(Object arg0, Throwable arg1) {
+        logger.warn(arg0.toString(), arg1);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index 58f358969..90e4341ff 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -13,28 +13,15 @@
  */
 package org.asynchttpclient.test;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.apache.commons.io.FileUtils;
-import org.asynchttpclient.*;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
-import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.MessageDigestUtils;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.BasicAuthenticator;
-import org.eclipse.jetty.security.authentication.DigestAuthenticator;
-import org.eclipse.jetty.security.authentication.LoginAuthenticator;
-import org.eclipse.jetty.server.*;
-import org.eclipse.jetty.util.security.Constraint;
-import org.eclipse.jetty.util.ssl.SslContextFactory;
 
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.*;
-import javax.servlet.http.HttpServletResponse;
-import java.io.*;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.net.ServerSocket;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -47,312 +34,350 @@
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SslEngineFactory;
+import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
+import org.asynchttpclient.util.Base64;
+import org.eclipse.jetty.security.ConstraintMapping;
+import org.eclipse.jetty.security.ConstraintSecurityHandler;
+import org.eclipse.jetty.security.HashLoginService;
+import org.eclipse.jetty.security.LoginService;
+import org.eclipse.jetty.security.authentication.BasicAuthenticator;
+import org.eclipse.jetty.security.authentication.DigestAuthenticator;
+import org.eclipse.jetty.security.authentication.LoginAuthenticator;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpConfiguration;
+import org.eclipse.jetty.server.HttpConnectionFactory;
+import org.eclipse.jetty.server.SecureRequestCustomizer;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.SslConnectionFactory;
+import org.eclipse.jetty.util.security.Constraint;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
 
 public class TestUtils {
 
-  public final static int TIMEOUT = 30;
-  public static final String USER = "user";
-  public static final String ADMIN = "admin";
-  public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html;charset=UTF-8";
-  public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html;charset=ISO-8859-1";
-  public static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
-  private static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
-  public static final File LARGE_IMAGE_FILE;
-  public static final byte[] LARGE_IMAGE_BYTES;
-  public static final String LARGE_IMAGE_BYTES_MD5;
-  public static final File SIMPLE_TEXT_FILE;
-  public static final String SIMPLE_TEXT_FILE_STRING;
-  private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
-
-  static {
-    try {
-      TMP_DIR.mkdirs();
-      TMP_DIR.deleteOnExit();
-      LARGE_IMAGE_FILE = resourceAsFile("300k.png");
-      LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
-      LARGE_IMAGE_BYTES_MD5 = TestUtils.md5(LARGE_IMAGE_BYTES);
-      SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
-      SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
-    } catch (Exception e) {
-      throw new ExceptionInInitializerError(e);
+    public final static int TIMEOUT = 30;
+    public static final String USER = "user";
+    public static final String ADMIN = "admin";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html;charset=UTF-8";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html;charset=ISO-8859-1";
+    public static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
+    public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
+    public static final File LARGE_IMAGE_FILE;
+    public static final byte[] LARGE_IMAGE_BYTES;
+    public static final File SIMPLE_TEXT_FILE;
+    public static final String SIMPLE_TEXT_FILE_STRING;
+    private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
+
+    static {
+        try {
+            TMP_DIR.mkdirs();
+            TMP_DIR.deleteOnExit();
+            LARGE_IMAGE_FILE = resourceAsFile("300k.png");
+            LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
+            SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
+            SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
+        }
     }
-  }
 
-  public static synchronized int findFreePort() throws IOException {
-    try (ServerSocket socket = ServerSocketFactory.getDefault().createServerSocket(0)) {
-      return socket.getLocalPort();
+    public static synchronized int findFreePort() throws IOException {
+        try (ServerSocket socket = ServerSocketFactory.getDefault().createServerSocket(0)) {
+            return socket.getLocalPort();
+        }
     }
-  }
-
-  public static File resourceAsFile(String path) throws URISyntaxException, IOException {
-    ClassLoader cl = TestUtils.class.getClassLoader();
-    URI uri = cl.getResource(path).toURI();
-    if (uri.isAbsolute() && !uri.isOpaque()) {
-      return new File(uri);
-    } else {
-      File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
-      tmpFile.deleteOnExit();
-      try (InputStream is = cl.getResourceAsStream(path)) {
-        FileUtils.copyInputStreamToFile(is, tmpFile);
-        return tmpFile;
-      }
+
+    public static File resourceAsFile(String path) throws URISyntaxException, IOException {
+        ClassLoader cl = TestUtils.class.getClassLoader();
+        URI uri = cl.getResource(path).toURI();
+        if (uri.isAbsolute() && !uri.isOpaque()) {
+            return new File(uri);
+        } else {
+            File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+            tmpFile.deleteOnExit();
+            try (InputStream is = cl.getResourceAsStream(path)) {
+                FileUtils.copyInputStreamToFile(is, tmpFile);
+                return tmpFile;
+            }
+        }
     }
-  }
 
-  public static File createTempFile(int approxSize) throws IOException {
-    long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
-    File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
-    tmpFile.deleteOnExit();
-    try (OutputStream out = Files.newOutputStream(tmpFile.toPath())) {
-      for (int i = 0; i < repeats; i++) {
-        out.write(PATTERN_BYTES);
-      }
+    public static File createTempFile(int approxSize) throws IOException {
+        long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
+        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+        tmpFile.deleteOnExit();
+        try (OutputStream out = Files.newOutputStream(tmpFile.toPath())) {
+            for (int i = 0; i < repeats; i++) {
+                out.write(PATTERN_BYTES);
+            }
 
-      long expectedFileSize = PATTERN_BYTES.length * repeats;
-      assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
+            long expectedFileSize = PATTERN_BYTES.length * repeats;
+            assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
 
-      return tmpFile;
+            return tmpFile;
+        }
     }
-  }
 
-  public static ServerConnector addHttpConnector(Server server) {
-    ServerConnector connector = new ServerConnector(server);
-    server.addConnector(connector);
-    return connector;
-  }
-
-  public static ServerConnector addHttpsConnector(Server server) throws IOException, URISyntaxException {
+    public static ServerConnector addHttpConnector(Server server) {
+        ServerConnector connector = new ServerConnector(server);
+        server.addConnector(connector);
+        return connector;
+    }
 
-    String keyStoreFile = resourceAsFile("ssltest-keystore.jks").getAbsolutePath();
-    SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
-    sslContextFactory.setKeyStorePassword("changeit");
+    public static ServerConnector addHttpsConnector(Server server) throws IOException, URISyntaxException {
 
-    String trustStoreFile = resourceAsFile("ssltest-cacerts.jks").getAbsolutePath();
-    sslContextFactory.setTrustStorePath(trustStoreFile);
-    sslContextFactory.setTrustStorePassword("changeit");
+        String keyStoreFile = resourceAsFile("ssltest-keystore.jks").getAbsolutePath();
+        SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
+        sslContextFactory.setKeyStorePassword("changeit");
 
-    HttpConfiguration httpsConfig = new HttpConfiguration();
-    httpsConfig.setSecureScheme("https");
-    httpsConfig.addCustomizer(new SecureRequestCustomizer());
+        String trustStoreFile = resourceAsFile("ssltest-cacerts.jks").getAbsolutePath();
+        sslContextFactory.setTrustStorePath(trustStoreFile);
+        sslContextFactory.setTrustStorePassword("changeit");
 
-    ServerConnector connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, "http/1.1"), new HttpConnectionFactory(httpsConfig));
+        HttpConfiguration httpsConfig = new HttpConfiguration();
+        httpsConfig.setSecureScheme("https");
+        httpsConfig.addCustomizer(new SecureRequestCustomizer());
 
-    server.addConnector(connector);
+        ServerConnector connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, "http/1.1"), new HttpConnectionFactory(httpsConfig));
 
-    return connector;
-  }
+        server.addConnector(connector);
 
-  public static void addBasicAuthHandler(Server server, Handler handler) {
-    addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), handler);
-  }
+        return connector;
+    }
 
-  public static void addDigestAuthHandler(Server server, Handler handler) {
-    addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), handler);
-  }
+    public static void addBasicAuthHandler(Server server, Handler handler) {
+        addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), handler);
+    }
 
-  private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, Handler handler) {
+    public static void addDigestAuthHandler(Server server, Handler handler) {
+        addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), handler);
+    }
 
-    server.addBean(LOGIN_SERVICE);
+    private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, Handler handler) {
 
-    Constraint constraint = new Constraint();
-    constraint.setName(auth);
-    constraint.setRoles(new String[]{USER, ADMIN});
-    constraint.setAuthenticate(true);
+        server.addBean(LOGIN_SERVICE);
 
-    ConstraintMapping mapping = new ConstraintMapping();
-    mapping.setConstraint(constraint);
-    mapping.setPathSpec("/*");
+        Constraint constraint = new Constraint();
+        constraint.setName(auth);
+        constraint.setRoles(new String[] { USER, ADMIN });
+        constraint.setAuthenticate(true);
 
-    Set<String> knownRoles = new HashSet<>();
-    knownRoles.add(USER);
-    knownRoles.add(ADMIN);
+        ConstraintMapping mapping = new ConstraintMapping();
+        mapping.setConstraint(constraint);
+        mapping.setPathSpec("/*");
 
-    List<ConstraintMapping> cm = new ArrayList<>();
-    cm.add(mapping);
+        Set<String> knownRoles = new HashSet<>();
+        knownRoles.add(USER);
+        knownRoles.add(ADMIN);
 
-    ConstraintSecurityHandler security = new ConstraintSecurityHandler();
-    security.setConstraintMappings(cm, knownRoles);
-    security.setAuthenticator(authenticator);
-    security.setLoginService(LOGIN_SERVICE);
-    security.setHandler(handler);
-    server.setHandler(security);
-  }
+        List<ConstraintMapping> cm = new ArrayList<>();
+        cm.add(mapping);
 
-  private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
-    KeyStore ks = KeyStore.getInstance("JKS");
-    try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-cacerts.jks")) {
-      char[] keyStorePassword = "changeit".toCharArray();
-      ks.load(keyStoreStream, keyStorePassword);
+        ConstraintSecurityHandler security = new ConstraintSecurityHandler();
+        security.setConstraintMappings(cm, knownRoles);
+        security.setAuthenticator(authenticator);
+        security.setLoginService(LOGIN_SERVICE);
+        security.setHandler(handler);
+        server.setHandler(security);
     }
-    assert (ks.size() > 0);
-
-    // Set up key manager factory to use our key store
-    char[] certificatePassword = "changeit".toCharArray();
-    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
-    kmf.init(ks, certificatePassword);
-
-    // Initialize the SSLContext to work with our key managers.
-    return kmf.getKeyManagers();
-  }
-
-  private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
-    KeyStore ks = KeyStore.getInstance("JKS");
-    try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-keystore.jks")) {
-      char[] keyStorePassword = "changeit".toCharArray();
-      ks.load(keyStoreStream, keyStorePassword);
+
+    private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
+        KeyStore ks = KeyStore.getInstance("JKS");
+        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-cacerts.jks")) {
+            char[] keyStorePassword = "changeit".toCharArray();
+            ks.load(keyStoreStream, keyStorePassword);
+        }
+        assert (ks.size() > 0);
+
+        // Set up key manager factory to use our key store
+        char[] certificatePassword = "changeit".toCharArray();
+        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
+        kmf.init(ks, certificatePassword);
+
+        // Initialize the SSLContext to work with our key managers.
+        return kmf.getKeyManagers();
     }
-    assert (ks.size() > 0);
 
-    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-    tmf.init(ks);
-    return tmf.getTrustManagers();
-  }
+    private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
+        KeyStore ks = KeyStore.getInstance("JKS");
+        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-keystore.jks")) {
+            char[] keyStorePassword = "changeit".toCharArray();
+            ks.load(keyStoreStream, keyStorePassword);
+        }
+        assert (ks.size() > 0);
+
+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+        tmf.init(ks);
+        return tmf.getTrustManagers();
+    }
 
-  public static SslEngineFactory createSslEngineFactory() {
-    return createSslEngineFactory(new AtomicBoolean(true));
-  }
+    public static SslEngineFactory createSslEngineFactory() throws SSLException {
+        return createSslEngineFactory(new AtomicBoolean(true));
+    }
 
-  public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) {
+    public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) throws SSLException {
 
-    try {
-      KeyManager[] keyManagers = createKeyManagers();
-      TrustManager[] trustManagers = new TrustManager[]{dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0])};
-      SecureRandom secureRandom = new SecureRandom();
+        try {
+            KeyManager[] keyManagers = createKeyManagers();
+            TrustManager[] trustManagers = new TrustManager[] { dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0]) };
+            SecureRandom secureRandom = new SecureRandom();
 
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(keyManagers, trustManagers, secureRandom);
+            SSLContext sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(keyManagers, trustManagers, secureRandom);
 
-      return new JsseSslEngineFactory(sslContext);
+            return new JsseSslEngineFactory(sslContext);
 
-    } catch (Exception e) {
-      throw new ExceptionInInitializerError(e);
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
+        }
     }
-  }
 
-  private static TrustManager dummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
-    return new DummyTrustManager(trust, tm);
+    public static class DummyTrustManager implements X509TrustManager {
+
+        private final X509TrustManager tm;
+        private final AtomicBoolean trust;
+
+        public DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+            this.trust = trust;
+            this.tm = tm;
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            tm.checkClientTrusted(chain, authType);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            if (!trust.get()) {
+                throw new CertificateException("Server certificate not trusted.");
+            }
+            tm.checkServerTrusted(chain, authType);
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return tm.getAcceptedIssuers();
+        }
+    }
 
-  }
+    private static TrustManager dummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
+        return new DummyTrustManager(trust, tm);
 
-  public static File getClasspathFile(String file) throws FileNotFoundException {
-    ClassLoader cl = null;
-    try {
-      cl = Thread.currentThread().getContextClassLoader();
-    } catch (Throwable ex) {
-      //
-    }
-    if (cl == null) {
-      cl = TestUtils.class.getClassLoader();
     }
-    URL resourceUrl = cl.getResource(file);
 
-    try {
-      return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
-    } catch (URISyntaxException e) {
-      throw new FileNotFoundException(file);
+    public static File getClasspathFile(String file) throws FileNotFoundException {
+        ClassLoader cl = null;
+        try {
+            cl = Thread.currentThread().getContextClassLoader();
+        } catch (Throwable ex) {
+        }
+        if (cl == null) {
+            cl = TestUtils.class.getClassLoader();
+        }
+        URL resourceUrl = cl.getResource(file);
+
+        try {
+            return new File(new URI(resourceUrl.toString()).getSchemeSpecificPart());
+        } catch (URISyntaxException e) {
+            throw new FileNotFoundException(file);
+        }
     }
-  }
-
-  public static void assertContentTypesEquals(String actual, String expected) {
-    assertEquals(actual.replace("; ", "").toLowerCase(Locale.ENGLISH), expected.replace("; ", "").toLowerCase(Locale.ENGLISH), "Unexpected content-type");
-  }
-
-  public static void writeResponseBody(HttpServletResponse response, String body) {
-    response.setContentLength(body.length());
-    try {
-      response.getOutputStream().print(body);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static String md5(byte[] bytes) {
-    return md5(bytes, 0, bytes.length);
-  }
-
-  public static String md5(byte[] bytes, int offset, int len) {
-    try {
-      MessageDigest md = MessageDigestUtils.pooledMd5MessageDigest();
-      md.update(bytes, offset, len);
-      return Base64.encode(md.digest());
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static class DummyTrustManager implements X509TrustManager {
 
-    private final X509TrustManager tm;
-    private final AtomicBoolean trust;
-
-    DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
-      this.trust = trust;
-      this.tm = tm;
+    public static void assertContentTypesEquals(String actual, String expected) {
+        assertEquals(actual.replace("; ", "").toLowerCase(Locale.ENGLISH), expected.replace("; ", "").toLowerCase(Locale.ENGLISH), "Unexpected content-type");
     }
 
-    @Override
-    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-      tm.checkClientTrusted(chain, authType);
+    public static String getLocalhostIp() {
+        return "127.0.0.1";
     }
 
-    @Override
-    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
-      if (!trust.get()) {
-        throw new CertificateException("Server certificate not trusted.");
-      }
-      tm.checkServerTrusted(chain, authType);
-    }
+    public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+            return response;
+        }
 
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-      return tm.getAcceptedIssuers();
+        @Override
+        public void onThrowable(Throwable t) {
+            fail("Unexpected exception: " + t.getMessage(), t);
+        }
     }
-  }
 
-  public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+    public static class AsyncHandlerAdapter implements AsyncHandler<String> {
 
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-      return response;
-    }
+        @Override
+        public void onThrowable(Throwable t) {
+            fail("Unexpected exception", t);
+        }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      fail("Unexpected exception: " + t.getMessage(), t);
-    }
-  }
+        @Override
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+            return State.CONTINUE;
+        }
 
-  public static class AsyncHandlerAdapter implements AsyncHandler<String> {
+        @Override
+        public State onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      fail("Unexpected exception", t);
-    }
+        @Override
+        public State onHeadersReceived(final HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
 
-    @Override
-    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-      return State.CONTINUE;
+        @Override
+        public String onCompleted() throws Exception {
+            return "";
+        }
     }
 
-    @Override
-    public State onStatusReceived(final HttpResponseStatus responseStatus) {
-      return State.CONTINUE;
+    public static void writeResponseBody(HttpServletResponse response, String body) {
+        response.setContentLength(body.length());
+        try {
+            response.getOutputStream().print(body);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 
-    @Override
-    public State onHeadersReceived(final HttpHeaders headers) throws Exception {
-      return State.CONTINUE;
+    public static String md5(byte[] bytes) {
+        return md5(bytes, 0, bytes.length);
     }
 
-    @Override
-    public String onCompleted() throws Exception {
-      return "";
+    public static String md5(byte[] bytes, int offset, int len) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            md.update(bytes, offset, len);
+            return Base64.encode(md.digest());
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
index ae387469a..06c65487f 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
@@ -13,255 +13,256 @@
  */
 package org.asynchttpclient.testserver;
 
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.handler.AbstractHandler;
+import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
+import static org.asynchttpclient.test.TestUtils.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.Enumeration;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.LOCATION;
-import static org.asynchttpclient.test.TestUtils.*;
-
-public class HttpServer implements Closeable {
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-  private final ConcurrentLinkedQueue<Handler> handlers = new ConcurrentLinkedQueue<>();
-  private int httpPort;
-  private int httpsPort;
-  private Server server;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.handler.AbstractHandler;
 
-  public HttpServer() {
-  }
+public class HttpServer implements Closeable {
 
-  public HttpServer(int httpPort, int httpsPort) {
-    this.httpPort = httpPort;
-    this.httpsPort = httpsPort;
-  }
+    private int httpPort;
+    private int httpsPort;
+    private Server server;
+    private final ConcurrentLinkedQueue<Handler> handlers = new ConcurrentLinkedQueue<>();
 
-  public void start() throws Exception {
-    server = new Server();
+    @FunctionalInterface
+    public interface HttpServletResponseConsumer {
 
-    ServerConnector httpConnector = addHttpConnector(server);
-    if (httpPort != 0) {
-      httpConnector.setPort(httpPort);
+        void apply(HttpServletResponse response) throws IOException, ServletException;
     }
 
-    server.setHandler(new QueueHandler());
-    ServerConnector httpsConnector = addHttpsConnector(server);
-    if (httpsPort != 0) {
-      httpsConnector.setPort(httpsPort);
+    public HttpServer() {
     }
 
-    server.start();
-
-    httpPort = httpConnector.getLocalPort();
-    httpsPort = httpsConnector.getLocalPort();
-  }
-
-  public void enqueue(Handler handler) {
-    handlers.offer(handler);
-  }
-
-  public void enqueueOk() {
-    enqueueResponse(response -> response.setStatus(200));
-  }
-
-  public void enqueueResponse(HttpServletResponseConsumer c) {
-    handlers.offer(new ConsumerHandler(c));
-  }
-
-  public void enqueueEcho() {
-    handlers.offer(new EchoHandler());
-  }
-
-  public void enqueueRedirect(int status, String location) {
-    enqueueResponse(response -> {
-      response.setStatus(status);
-      response.setHeader(LOCATION.toString(), location);
-    });
-  }
-
-  public int getHttpPort() {
-    return httpPort;
-  }
-
-  public int getsHttpPort() {
-    return httpsPort;
-  }
-
-  public String getHttpUrl() {
-    return "http://localhost:" + httpPort;
-  }
-
-  public String getHttpsUrl() {
-    return "https://localhost:" + httpsPort;
-  }
-
-  public void reset() {
-    handlers.clear();
-  }
-
-  @Override
-  public void close() throws IOException {
-    if (server != null) {
-      try {
-        server.stop();
-      } catch (Exception e) {
-        throw new IOException(e);
-      }
+    public HttpServer(int httpPort, int httpsPort) {
+        this.httpPort = httpPort;
+        this.httpsPort = httpsPort;
     }
-  }
 
-  @FunctionalInterface
-  public interface HttpServletResponseConsumer {
+    public void start() throws Exception {
+        server = new Server();
 
-    void apply(HttpServletResponse response) throws IOException, ServletException;
-  }
+        ServerConnector httpConnector = addHttpConnector(server);
+        if (httpPort != 0) {
+            httpConnector.setPort(httpPort);
+        }
 
-  public static abstract class AutoFlushHandler extends AbstractHandler {
+        server.setHandler(new QueueHandler());
+        ServerConnector httpsConnector = addHttpsConnector(server);
+        if (httpsPort != 0) {
+            httpsConnector.setPort(httpsPort);
+        }
 
-    private final boolean closeAfterResponse;
+        server.start();
 
-    AutoFlushHandler() {
-      this(false);
+        httpPort = httpConnector.getLocalPort();
+        httpsPort = httpsConnector.getLocalPort();
     }
 
-    AutoFlushHandler(boolean closeAfterResponse) {
-      this.closeAfterResponse = closeAfterResponse;
+    public void enqueue(Handler handler) {
+        handlers.offer(handler);
     }
 
-    @Override
-    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      handle0(target, baseRequest, request, response);
-      response.getOutputStream().flush();
-      if (closeAfterResponse) {
-        response.getOutputStream().close();
-      }
+    public void enqueueOk() {
+        enqueueResponse(response -> response.setStatus(200));
     }
 
-    protected abstract void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
-  }
+    public void enqueueResponse(HttpServletResponseConsumer c) {
+        handlers.offer(new ConsumerHandler(c));
+    }
 
-  private static class ConsumerHandler extends AutoFlushHandler {
+    public void enqueueEcho() {
+        handlers.offer(new EchoHandler());
+    }
 
-    private final HttpServletResponseConsumer c;
+    public void enqueueRedirect(int status, String location) {
+        enqueueResponse(response -> {
+            response.setStatus(status);
+            response.setHeader(LOCATION.toString(), location);
+        });
+    }
 
-    ConsumerHandler(HttpServletResponseConsumer c) {
-      this(c, false);
+    public int getHttpPort() {
+        return httpPort;
     }
 
-    ConsumerHandler(HttpServletResponseConsumer c, boolean closeAfterResponse) {
-      super(closeAfterResponse);
-      this.c = c;
+    public int getsHttpPort() {
+        return httpsPort;
     }
 
-    @Override
-    protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-      c.apply(response);
+    public String getHttpUrl() {
+        return "http://localhost:" + httpPort;
     }
-  }
 
-  public static class EchoHandler extends AutoFlushHandler {
+    public String getHttpsUrl() {
+        return "https://localhost:" + httpsPort;
+    }
+
+    public void reset() {
+        handlers.clear();
+    }
 
     @Override
-    protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
-
-      String delay = request.getHeader("X-Delay");
-      if (delay != null) {
-        try {
-          Thread.sleep(Long.parseLong(delay));
-        } catch (NumberFormatException | InterruptedException e1) {
-          throw new ServletException(e1);
+    public void close() throws IOException {
+        if (server != null) {
+            try {
+                server.stop();
+            } catch (Exception e) {
+                throw new IOException(e);
+            }
         }
-      }
-
-      response.setStatus(200);
+    }
 
-      if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
-        response.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-      }
+    private class QueueHandler extends AbstractHandler {
 
-      response.setContentType(request.getHeader("X-IsoCharset") != null ? TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET : TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+        @Override
+        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
-      response.addHeader("X-ClientPort", String.valueOf(request.getRemotePort()));
+            Handler handler = HttpServer.this.handlers.poll();
+            if (handler == null) {
+                response.sendError(500, "No handler enqueued");
+                response.getOutputStream().flush();
+                response.getOutputStream().close();
 
-      String pathInfo = request.getPathInfo();
-      if (pathInfo != null)
-        response.addHeader("X-PathInfo", pathInfo);
+            } else {
+                handler.handle(target, baseRequest, request, response);
+            }
+        }
+    }
 
-      String queryString = request.getQueryString();
-      if (queryString != null)
-        response.addHeader("X-QueryString", queryString);
+    public static abstract class AutoFlushHandler extends AbstractHandler {
 
-      Enumeration<String> headerNames = request.getHeaderNames();
-      while (headerNames.hasMoreElements()) {
-        String headerName = headerNames.nextElement();
-        response.addHeader("X-" + headerName, request.getHeader(headerName));
-      }
+        private final boolean closeAfterResponse;
 
-      for (Entry<String, String[]> e : baseRequest.getParameterMap().entrySet()) {
-        response.addHeader("X-" + e.getKey(), e.getValue()[0]);
-      }
+        public AutoFlushHandler() {
+            this(false);
+        }
 
-      Cookie[] cs = request.getCookies();
-      if (cs != null) {
-        for (Cookie c : cs) {
-          response.addCookie(c);
+        public AutoFlushHandler(boolean closeAfterResponse) {
+            this.closeAfterResponse = closeAfterResponse;
         }
-      }
-
-      Enumeration<String> parameterNames = request.getParameterNames();
-      StringBuilder requestBody = new StringBuilder();
-      while (parameterNames.hasMoreElements()) {
-        String param = parameterNames.nextElement();
-        response.addHeader("X-" + param, request.getParameter(param));
-        requestBody.append(param);
-        requestBody.append("_");
-      }
-      if (requestBody.length() > 0) {
-        response.getOutputStream().write(requestBody.toString().getBytes());
-      }
-
-      int size = 16384;
-      if (request.getContentLength() > 0) {
-        size = request.getContentLength();
-      }
-      if (size > 0) {
-        int read = 0;
-        while (read > -1) {
-          byte[] bytes = new byte[size];
-          read = request.getInputStream().read(bytes);
-          if (read > 0) {
-            response.getOutputStream().write(bytes, 0, read);
-          }
+
+        @Override
+        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            handle0(target, baseRequest, request, response);
+            response.getOutputStream().flush();
+            if (closeAfterResponse) {
+                response.getOutputStream().close();
+            }
         }
-      }
+
+        protected abstract void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
     }
-  }
 
-  private class QueueHandler extends AbstractHandler {
+    private static class ConsumerHandler extends AutoFlushHandler {
 
-    @Override
-    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        private final HttpServletResponseConsumer c;
+
+        public ConsumerHandler(HttpServletResponseConsumer c) {
+            this(c, false);
+        }
+
+        public ConsumerHandler(HttpServletResponseConsumer c, boolean closeAfterResponse) {
+            super(closeAfterResponse);
+            this.c = c;
+        }
 
-      Handler handler = HttpServer.this.handlers.poll();
-      if (handler == null) {
-        response.sendError(500, "No handler enqueued");
-        response.getOutputStream().flush();
-        response.getOutputStream().close();
+        @Override
+        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            c.apply(response);
+        }
+    }
 
-      } else {
-        handler.handle(target, baseRequest, request, response);
-      }
+    public static class EchoHandler extends AutoFlushHandler {
+
+        @Override
+        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+            String delay = request.getHeader("X-Delay");
+            if (delay != null) {
+                try {
+                    Thread.sleep(Long.parseLong(delay));
+                } catch (NumberFormatException | InterruptedException e1) {
+                    throw new ServletException(e1);
+                }
+            }
+
+            response.setStatus(200);
+
+            if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+                response.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+            }
+
+            response.setContentType(request.getHeader("X-IsoCharset") != null ? TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET : TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+
+            response.addHeader("X-ClientPort", String.valueOf(request.getRemotePort()));
+
+            String pathInfo = request.getPathInfo();
+            if (pathInfo != null)
+                response.addHeader("X-PathInfo", pathInfo);
+
+            String queryString = request.getQueryString();
+            if (queryString != null)
+                response.addHeader("X-QueryString", queryString);
+
+            Enumeration<String> headerNames = request.getHeaderNames();
+            while (headerNames.hasMoreElements()) {
+                String headerName = headerNames.nextElement();
+                response.addHeader("X-" + headerName, request.getHeader(headerName));
+            }
+
+            for (Entry<String, String[]> e : baseRequest.getParameterMap().entrySet()) {
+                response.addHeader("X-" + e.getKey(), e.getValue()[0]);
+            }
+
+            Cookie[] cs = request.getCookies();
+            if (cs != null) {
+                for (Cookie c : cs) {
+                    response.addCookie(c);
+                }
+            }
+
+            Enumeration<String> parameterNames = request.getParameterNames();
+            StringBuilder requestBody = new StringBuilder();
+            while (parameterNames.hasMoreElements()) {
+                String param = parameterNames.nextElement();
+                response.addHeader("X-" + param, request.getParameter(param));
+                requestBody.append(param);
+                requestBody.append("_");
+            }
+            if (requestBody.length() > 0) {
+                response.getOutputStream().write(requestBody.toString().getBytes());
+            }
+
+            int size = 16384;
+            if (request.getContentLength() > 0) {
+                size = request.getContentLength();
+            }
+            if (size > 0) {
+                int read = 0;
+                while (read > -1) {
+                    byte[] bytes = new byte[size];
+                    read = request.getInputStream().read(bytes);
+                    if (read > 0) {
+                        response.getOutputStream().write(bytes, 0, read);
+                    }
+                }
+            }
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
index 20c8b3f47..edabb46bc 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
@@ -13,87 +13,93 @@
  */
 package org.asynchttpclient.testserver;
 
+import static org.asynchttpclient.Dsl.*;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-
 public abstract class HttpTest {
+    
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected static final String COMPLETED_EVENT = "Completed";
+    protected static final String STATUS_RECEIVED_EVENT = "StatusReceived";
+    protected static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
+    protected static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
+    protected static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
+    protected static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
+    protected static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+    protected static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+    protected static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
+    protected static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
+    protected static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
+    protected static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+    protected static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+    protected static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
+    protected static final String CONNECTION_POOL_EVENT = "ConnectionPool";
+    protected static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
+    protected static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
+    protected static final String REQUEST_SEND_EVENT = "RequestSend";
+    protected static final String RETRY_EVENT = "Retry";
+
+    @FunctionalInterface
+    protected interface ClientFunction {
+        void apply(AsyncHttpClient client) throws Throwable;
+    }
 
-  protected static final String COMPLETED_EVENT = "Completed";
-  protected static final String STATUS_RECEIVED_EVENT = "StatusReceived";
-  protected static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
-  protected static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
-  protected static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-  protected static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
-  protected static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
-  protected static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
-  protected static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
-  protected static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
-  protected static final String CONNECTION_POOL_EVENT = "ConnectionPool";
-  protected static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
-  protected static final String REQUEST_SEND_EVENT = "RequestSend";
-  protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-  protected ClientTestBody withClient() {
-    return withClient(config().setMaxRedirects(0));
-  }
-
-  protected ClientTestBody withClient(DefaultAsyncHttpClientConfig.Builder builder) {
-    return withClient(builder.build());
-  }
-
-  private ClientTestBody withClient(AsyncHttpClientConfig config) {
-    return new ClientTestBody(config);
-  }
-
-  protected ServerTestBody withServer(HttpServer server) {
-    return new ServerTestBody(server);
-  }
-
-  @FunctionalInterface
-  protected interface ClientFunction {
-    void apply(AsyncHttpClient client) throws Throwable;
-  }
-
-  @FunctionalInterface
-  protected interface ServerFunction {
-    void apply(HttpServer server) throws Throwable;
-  }
-
-  protected static class ClientTestBody {
-
-    private final AsyncHttpClientConfig config;
-
-    private ClientTestBody(AsyncHttpClientConfig config) {
-      this.config = config;
+    @FunctionalInterface
+    protected interface ServerFunction {
+        void apply(HttpServer server) throws Throwable;
     }
 
-    public void run(ClientFunction f) throws Throwable {
-      try (AsyncHttpClient client = asyncHttpClient(config)) {
-        f.apply(client);
-      }
+    protected static class ClientTestBody {
+
+        private final AsyncHttpClientConfig config;
+
+        private ClientTestBody(AsyncHttpClientConfig config) {
+            this.config = config;
+        }
+
+        public void run(ClientFunction f) throws Throwable {
+            try (AsyncHttpClient client = asyncHttpClient(config)) {
+                f.apply(client);
+            }
+        }
     }
-  }
 
-  protected static class ServerTestBody {
+    protected static class ServerTestBody {
+
+        private final HttpServer server;
 
-    private final HttpServer server;
+        private ServerTestBody(HttpServer server) {
+            this.server = server;
+        }
+
+        public void run(ServerFunction f) throws Throwable {
+            try {
+                f.apply(server);
+            } finally {
+                server.reset();
+            }
+        }
+    }
+
+    protected ClientTestBody withClient() {
+        return withClient(config().setMaxRedirects(0));
+    }
+
+    protected ClientTestBody withClient(DefaultAsyncHttpClientConfig.Builder builder) {
+        return withClient(builder.build());
+    }
 
-    private ServerTestBody(HttpServer server) {
-      this.server = server;
+    protected ClientTestBody withClient(AsyncHttpClientConfig config) {
+        return new ClientTestBody(config);
     }
 
-    public void run(ServerFunction f) throws Throwable {
-      try {
-        f.apply(server);
-      } finally {
-        server.reset();
-      }
+    protected ServerTestBody withServer(HttpServer server) {
+        return new ServerTestBody(server);
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java b/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java
deleted file mode 100644
index 1d3fab069..000000000
--- a/client/src/test/java/org/asynchttpclient/testserver/SocksProxy.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * SOCKS Proxy in JAVA
- * By Gareth Owen
- * drgowen@gmail.com
- * MIT Licence
- */
-
-package org.asynchttpclient.testserver;
-
-// NOTES : LISTENS ON PORT 8000
-
-import java.io.*;
-import java.net.*;
-import java.nio.ByteBuffer;
-import java.nio.channels.*;
-import java.util.ArrayList;
-import java.util.Set;
-
-public class SocksProxy {
-
-  private static ArrayList<SocksClient> clients = new ArrayList<>();
-
-  public SocksProxy(int runningTime) throws IOException {
-    ServerSocketChannel socks = ServerSocketChannel.open();
-    socks.socket().bind(new InetSocketAddress(8000));
-    socks.configureBlocking(false);
-    Selector select = Selector.open();
-    socks.register(select, SelectionKey.OP_ACCEPT);
-
-    int lastClients = clients.size();
-    // select loop
-    for (long end = System.currentTimeMillis() + runningTime; System.currentTimeMillis() < end; ) {
-      select.select(5000);
-
-      Set<SelectionKey> keys = select.selectedKeys();
-      for (SelectionKey k : keys) {
-
-        if (!k.isValid())
-          continue;
-
-        // new connection?
-        if (k.isAcceptable() && k.channel() == socks) {
-          // server socket
-          SocketChannel csock = socks.accept();
-          if (csock == null)
-            continue;
-          addClient(csock);
-          csock.register(select, SelectionKey.OP_READ);
-        } else if (k.isReadable()) {
-          // new data on a client/remote socket
-          for (int i = 0; i < clients.size(); i++) {
-            SocksClient cl = clients.get(i);
-            try {
-              if (k.channel() == cl.client) // from client (e.g. socks client)
-                cl.newClientData(select);
-              else if (k.channel() == cl.remote) {  // from server client is connected to (e.g. website)
-                cl.newRemoteData();
-              }
-            } catch (IOException e) { // error occurred - remove client
-              cl.client.close();
-              if (cl.remote != null)
-                cl.remote.close();
-              k.cancel();
-              clients.remove(cl);
-            }
-
-          }
-        }
-      }
-
-      // client timeout check
-      for (int i = 0; i < clients.size(); i++) {
-        SocksClient cl = clients.get(i);
-        if ((System.currentTimeMillis() - cl.lastData) > 30000L) {
-          cl.client.close();
-          if (cl.remote != null)
-            cl.remote.close();
-          clients.remove(cl);
-        }
-      }
-      if (clients.size() != lastClients) {
-        System.out.println(clients.size());
-        lastClients = clients.size();
-      }
-    }
-  }
-
-  // utility function
-  private void addClient(SocketChannel s) {
-    SocksClient cl;
-    try {
-      cl = new SocksClient(s);
-    } catch (IOException e) {
-      e.printStackTrace();
-      return;
-    }
-    clients.add(cl);
-  }
-
-  // socks client class - one per client connection
-  class SocksClient {
-    SocketChannel client, remote;
-    boolean connected;
-    long lastData;
-
-    SocksClient(SocketChannel c) throws IOException {
-      client = c;
-      client.configureBlocking(false);
-      lastData = System.currentTimeMillis();
-    }
-
-    void newRemoteData() throws IOException {
-      ByteBuffer buf = ByteBuffer.allocate(1024);
-      if (remote.read(buf) == -1)
-        throw new IOException("disconnected");
-      lastData = System.currentTimeMillis();
-      buf.flip();
-      client.write(buf);
-    }
-
-    void newClientData(Selector selector) throws IOException {
-      if (!connected) {
-        ByteBuffer inbuf = ByteBuffer.allocate(512);
-        if (client.read(inbuf) < 1)
-          return;
-        inbuf.flip();
-
-        // read socks header
-        int ver = inbuf.get();
-        if (ver != 4) {
-          throw new IOException("incorrect version" + ver);
-        }
-        int cmd = inbuf.get();
-
-        // check supported command
-        if (cmd != 1) {
-          throw new IOException("incorrect version");
-        }
-
-        final int port = inbuf.getShort() & 0xffff;
-
-        final byte ip[] = new byte[4];
-        // fetch IP
-        inbuf.get(ip);
-
-        InetAddress remoteAddr = InetAddress.getByAddress(ip);
-
-        while ((inbuf.get()) != 0); // username
-
-        // hostname provided, not IP
-        if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] != 0) { // host provided
-          StringBuilder host = new StringBuilder();
-          byte b;
-          while ((b = inbuf.get()) != 0) {
-            host.append(b);
-          }
-          remoteAddr = InetAddress.getByName(host.toString());
-          System.out.println(host.toString() + remoteAddr);
-        }
-
-        remote = SocketChannel.open(new InetSocketAddress(remoteAddr, port));
-
-        ByteBuffer out = ByteBuffer.allocate(20);
-        out.put((byte) 0);
-        out.put((byte) (remote.isConnected() ? 0x5a : 0x5b));
-        out.putShort((short) port);
-        out.put(remoteAddr.getAddress());
-        out.flip();
-        client.write(out);
-
-        if (!remote.isConnected())
-          throw new IOException("connect failed");
-
-        remote.configureBlocking(false);
-        remote.register(selector, SelectionKey.OP_READ);
-
-        connected = true;
-      } else {
-        ByteBuffer buf = ByteBuffer.allocate(1024);
-        if (client.read(buf) == -1)
-          throw new IOException("disconnected");
-        lastData = System.currentTimeMillis();
-        buf.flip();
-        remote.write(buf);
-      }
-    }
-  }
-}
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
index 5314542ac..8b1fe2166 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
@@ -13,110 +13,111 @@
  */
 package org.asynchttpclient.uri;
 
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
+import java.net.MalformedURLException;
 import java.net.URI;
 
-import static org.testng.Assert.assertEquals;
+import org.testng.annotations.Test;
 
 public class UriParserTest {
 
-  private static void assertUriEquals(UriParser parser, URI uri) {
-    assertEquals(parser.scheme, uri.getScheme());
-    assertEquals(parser.userInfo, uri.getUserInfo());
-    assertEquals(parser.host, uri.getHost());
-    assertEquals(parser.port, uri.getPort());
-    assertEquals(parser.path, uri.getPath());
-    assertEquals(parser.query, uri.getQuery());
-  }
-
-  private static void validateAgainstAbsoluteURI(String url) {
-    UriParser parser = new UriParser();
-    parser.parse(null, url);
-    assertUriEquals(parser, URI.create(url));
-  }
-
-  private static void validateAgainstRelativeURI(Uri uriContext, String urlContext, String url) {
-    UriParser parser = new UriParser();
-    parser.parse(uriContext, url);
-    assertUriEquals(parser, URI.create(urlContext).resolve(URI.create(url)));
-  }
-
-  @Test
-  public void testUrlWithPathAndQuery() {
-    validateAgainstAbsoluteURI("http://example.com:8080/test?q=1");
-  }
-
-  @Test
-  public void testFragmentTryingToTrickAuthorityAsBasicAuthCredentials() {
-    validateAgainstAbsoluteURI("http://1.2.3.4:81#@5.6.7.8:82/aaa/b?q=xxx");
-  }
-
-  @Test
-  public void testUrlHasLeadingAndTrailingWhiteSpace() {
-    UriParser parser = new UriParser();
-    String url = "  http://user@example.com:8080/test?q=1  ";
-    parser.parse(null, url);
-    assertUriEquals(parser, URI.create(url.trim()));
-  }
-
-  @Test
-  public void testResolveAbsoluteUriAgainstContext() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "");
-    validateAgainstRelativeURI(context, "https://example.com:80/path", "http://example.com/path");
-  }
-
-  @Test
-  public void testRootRelativePath() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativeUrl");
-  }
-
-  @Test
-  public void testCurrentDirRelativePath() {
-    Uri context = new Uri("https", null, "example.com", 80, "/foo/bar", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/foo/bar?q=2", "relativeUrl");
-  }
-
-  @Test
-  public void testFragmentOnly() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "#test");
-  }
-
-  @Test
-  public void testRelativeUrlWithQuery() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativePath?q=3");
-  }
-
-  @Test
-  public void testRelativeUrlWithQueryOnly() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "?q=3");
-  }
-
-  @Test
-  public void testRelativeURLWithDots() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/./url");
-  }
-
-  @Test
-  public void testRelativeURLWithTwoEmbeddedDots() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/../url");
-  }
-
-  @Test
-  public void testRelativeURLWithTwoTrailingDots() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/..");
-  }
-
-  @Test
-  public void testRelativeURLWithOneTrailingDot() {
-    Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
-    validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/.");
-  }
+    private static void assertUriEquals(UriParser parser, URI uri) {
+        assertEquals(parser.scheme, uri.getScheme());
+        assertEquals(parser.userInfo, uri.getUserInfo());
+        assertEquals(parser.host, uri.getHost());
+        assertEquals(parser.port, uri.getPort());
+        assertEquals(parser.path, uri.getPath());
+        assertEquals(parser.query, uri.getQuery());
+    }
+
+    private static void validateAgainstAbsoluteURI(String url) throws MalformedURLException {
+        UriParser parser = new UriParser();
+        parser.parse(null, url);
+        assertUriEquals(parser, URI.create(url));
+    }
+
+    @Test
+    public void testUrlWithPathAndQuery() throws MalformedURLException {
+        validateAgainstAbsoluteURI("http://example.com:8080/test?q=1");
+    }
+
+    @Test
+    public void testFragmentTryingToTrickAuthorityAsBasicAuthCredentials() throws MalformedURLException {
+        validateAgainstAbsoluteURI("http://1.2.3.4:81#@5.6.7.8:82/aaa/b?q=xxx");
+    }
+
+    @Test
+    public void testUrlHasLeadingAndTrailingWhiteSpace() {
+        UriParser parser = new UriParser();
+        String url = "  http://user@example.com:8080/test?q=1  ";
+        parser.parse(null, url);
+        assertUriEquals(parser, URI.create(url.trim()));
+    }
+
+    private static void validateAgainstRelativeURI(Uri uriContext, String urlContext, String url) {
+        UriParser parser = new UriParser();
+        parser.parse(uriContext, url);
+        assertUriEquals(parser, URI.create(urlContext).resolve(URI.create(url)));
+    }
+
+    @Test
+    public void testResolveAbsoluteUriAgainstContext() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "");
+        validateAgainstRelativeURI(context, "https://example.com:80/path", "http://example.com/path");
+    }
+
+    @Test
+    public void testRootRelativePath() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativeUrl");
+    }
+
+    @Test
+    public void testCurrentDirRelativePath() {
+        Uri context = new Uri("https", null, "example.com", 80, "/foo/bar", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/foo/bar?q=2", "relativeUrl");
+    }
+
+    @Test
+    public void testFragmentOnly() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "#test");
+    }
+
+    @Test
+    public void testRelativeUrlWithQuery() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "/relativePath?q=3");
+    }
+
+    @Test
+    public void testRelativeUrlWithQueryOnly() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "?q=3");
+    }
+
+    @Test
+    public void testRelativeURLWithDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/./url");
+    }
+
+    @Test
+    public void testRelativeURLWithTwoEmbeddedDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/../url");
+    }
+
+    @Test
+    public void testRelativeURLWithTwoTrailingDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/..");
+    }
+
+    @Test
+    public void testRelativeURLWithOneTrailingDot() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        validateAgainstRelativeURI(context, "https://example.com:80/path?q=2", "./relative/url/.");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriTest.java b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
index 5772abed5..2cf79e2c0 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -12,261 +12,261 @@
  */
 package org.asynchttpclient.uri;
 
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
+import java.net.MalformedURLException;
 import java.net.URI;
 
-import static org.testng.Assert.*;
+import org.testng.annotations.Test;
 
 public class UriTest {
 
-  private static void assertUriEquals(Uri uri, URI javaUri) {
-    assertEquals(uri.getScheme(), javaUri.getScheme());
-    assertEquals(uri.getUserInfo(), javaUri.getUserInfo());
-    assertEquals(uri.getHost(), javaUri.getHost());
-    assertEquals(uri.getPort(), javaUri.getPort());
-    assertEquals(uri.getPath(), javaUri.getPath());
-    assertEquals(uri.getQuery(), javaUri.getQuery());
-  }
-
-  private static void validateAgainstAbsoluteURI(String url) {
-    assertUriEquals(Uri.create(url), URI.create(url));
-  }
-
-  private static void validateAgainstRelativeURI(String context, String url) {
-    assertUriEquals(Uri.create(Uri.create(context), url), URI.create(context).resolve(URI.create(url)));
-  }
-
-  @Test
-  public void testSimpleParsing() {
-    validateAgainstAbsoluteURI("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test
-  public void testRootRelativeURIWithRootContext() {
-    validateAgainstRelativeURI("https://graph.facebook.com", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test
-  public void testRootRelativeURIWithNonRootContext() {
-    validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test
-  public void testNonRootRelativeURIWithNonRootContext() {
-    validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test(enabled = false)
-  // FIXME weird: java.net.URI#getPath return "750198471659552/accounts/test-users" without a "/"?!
-  public void testNonRootRelativeURIWithRootContext() {
-    validateAgainstRelativeURI("https://graph.facebook.com", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test
-  public void testAbsoluteURIWithContext() {
-    validateAgainstRelativeURI("https://hello.com/foo/bar",
-            "https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
-  }
-
-  @Test
-  public void testRelativeUriWithDots() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2/", "../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithDotsAboveRoot() {
-    validateAgainstRelativeURI("https://hello.com/level1", "../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithAbsoluteDots() {
-    validateAgainstRelativeURI("https://hello.com/level1/", "/../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDots() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2/", "../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDotsAboveRoot() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2", "../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithAbsoluteConsecutiveDots() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2/", "/../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDotsFromRoot() {
-    validateAgainstRelativeURI("https://hello.com/", "../../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDotsFromRootResource() {
-    validateAgainstRelativeURI("https://hello.com/level1", "../../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDotsFromSubrootResource() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2", "../../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() {
-    validateAgainstRelativeURI("https://hello.com/level1/level2/level3", "../../../other/content/img.png");
-  }
-
-  @Test
-  public void testRelativeUriWithNoScheme() {
-    validateAgainstRelativeURI("https://hello.com/level1", "//world.org/content/img.png");
-  }
-
-  @Test
-  public void testCreateAndToUrl() {
-    String url = "https://hello.com/level1/level2/level3";
-    Uri uri = Uri.create(url);
-    assertEquals(uri.toUrl(), url, "url used to create uri and url returned from toUrl do not match");
-  }
-
-  @Test
-  public void testToUrlWithUserInfoPortPathAndQuery() {
-    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-    assertEquals(uri.toUrl(), "http://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
-  }
-
-  @Test
-  public void testQueryWithNonRootPath() {
-    Uri uri = Uri.create("http://hello.com/foo?query=value");
-    assertEquals(uri.getPath(), "/foo");
-    assertEquals(uri.getQuery(), "query=value");
-  }
-
-  @Test
-  public void testQueryWithNonRootPathAndTrailingSlash() {
-    Uri uri = Uri.create("http://hello.com/foo/?query=value");
-    assertEquals(uri.getPath(), "/foo/");
-    assertEquals(uri.getQuery(), "query=value");
-  }
-
-  @Test
-  public void testQueryWithRootPath() {
-    Uri uri = Uri.create("http://hello.com?query=value");
-    assertEquals(uri.getPath(), "");
-    assertEquals(uri.getQuery(), "query=value");
-  }
-
-  @Test
-  public void testQueryWithRootPathAndTrailingSlash() {
-    Uri uri = Uri.create("http://hello.com/?query=value");
-    assertEquals(uri.getPath(), "/");
-    assertEquals(uri.getQuery(), "query=value");
-  }
-
-  @Test
-  public void testWithNewScheme() {
-    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-    Uri newUri = uri.withNewScheme("https");
-    assertEquals(newUri.getScheme(), "https");
-    assertEquals(newUri.toUrl(), "https://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
-  }
-
-  @Test
-  public void testWithNewQuery() {
-    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-    Uri newUri = uri.withNewQuery("query2=10&query3=20");
-    assertEquals(newUri.getQuery(), "query2=10&query3=20");
-    assertEquals(newUri.toUrl(), "http://user@example.com:44/path/path2?query2=10&query3=20", "toUrl returned incorrect url");
-  }
-
-  @Test
-  public void testToRelativeUrl() {
-    Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
-    String relativeUrl = uri.toRelativeUrl();
-    assertEquals(relativeUrl, "/path/path2?query=4", "toRelativeUrl returned incorrect url");
-  }
-
-  @Test
-  public void testToRelativeUrlWithEmptyPath() {
-    Uri uri = new Uri("http", "user", "example.com", 44, null, "query=4");
-    String relativeUrl = uri.toRelativeUrl();
-    assertEquals(relativeUrl, "/?query=4", "toRelativeUrl returned incorrect url");
-  }
-
-  @Test
-  public void testGetSchemeDefaultPortHttpScheme() {
-    String url = "https://hello.com/level1/level2/level3";
-    Uri uri = Uri.create(url);
-    assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for https url");
-
-    String url2 = "http://hello.com/level1/level2/level3";
-    Uri uri2 = Uri.create(url2);
-    assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for http url");
-  }
-
-  @Test
-  public void testGetSchemeDefaultPortWebSocketScheme() {
-    String url = "wss://hello.com/level1/level2/level3";
-    Uri uri = Uri.create(url);
-    assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for wss url");
-
-    String url2 = "ws://hello.com/level1/level2/level3";
-    Uri uri2 = Uri.create(url2);
-    assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for ws url");
-  }
-
-  @Test
-  public void testGetExplicitPort() {
-    String url = "http://hello.com/level1/level2/level3";
-    Uri uri = Uri.create(url);
-    assertEquals(uri.getExplicitPort(), 80, "getExplicitPort should return port 80 for http url when port is not specified in url");
-
-    String url2 = "http://hello.com:8080/level1/level2/level3";
-    Uri uri2 = Uri.create(url2);
-    assertEquals(uri2.getExplicitPort(), 8080, "getExplicitPort should return the port given in the url");
-  }
-
-  @Test
-  public void testEquals() {
-    String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
-    Uri createdUri = Uri.create(url);
-    Uri constructedUri = new Uri("http", "user", "hello.com", 8080, "/level1/level2/level3", "q=1");
-    assertTrue(createdUri.equals(constructedUri), "The equals method returned false for two equal urls");
-  }
-
-  @Test
-  public void testIsWebsocket() {
-    String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
-    Uri uri = Uri.create(url);
-    assertFalse(uri.isWebSocket(), "isWebSocket should return false for http url");
-
-    url = "https://user@hello.com:8080/level1/level2/level3?q=1";
-    uri = Uri.create(url);
-    assertFalse(uri.isWebSocket(), "isWebSocket should return false for https url");
-
-    url = "ws://user@hello.com:8080/level1/level2/level3?q=1";
-    uri = Uri.create(url);
-    assertTrue(uri.isWebSocket(), "isWebSocket should return true for ws url");
-
-    url = "wss://user@hello.com:8080/level1/level2/level3?q=1";
-    uri = Uri.create(url);
-    assertTrue(uri.isWebSocket(), "isWebSocket should return true for wss url");
-  }
-
-  @Test
-  public void creatingUriWithDefinedSchemeAndHostWorks() {
-    Uri.create("http://localhost");
-  }
-
-  @Test(expectedExceptions = IllegalArgumentException.class)
-  public void creatingUriWithMissingSchemeThrowsIllegalArgumentException() {
-    Uri.create("localhost");
-  }
-
-  @Test(expectedExceptions = IllegalArgumentException.class)
-  public void creatingUriWithMissingHostThrowsIllegalArgumentException() {
-    Uri.create("http://");
-  }
+    private static void assertUriEquals(Uri uri, URI javaUri) {
+        assertEquals(uri.getScheme(), uri.getScheme());
+        assertEquals(uri.getUserInfo(), uri.getUserInfo());
+        assertEquals(uri.getHost(), uri.getHost());
+        assertEquals(uri.getPort(), uri.getPort());
+        assertEquals(uri.getPath(), uri.getPath());
+        assertEquals(uri.getQuery(), uri.getQuery());
+    }
+
+    private static void validateAgainstAbsoluteURI(String url) throws MalformedURLException {
+        assertUriEquals(Uri.create(url), URI.create(url));
+    }
+
+    private static void validateAgainstRelativeURI(String context, String url) throws MalformedURLException {
+        assertUriEquals(Uri.create(Uri.create(context), url), URI.create(context).resolve(URI.create(url)));
+    }
+
+    @Test
+    public void testSimpleParsing() throws MalformedURLException {
+        validateAgainstAbsoluteURI("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testRootRelativeURIWithRootContext() throws MalformedURLException {
+        validateAgainstRelativeURI("https://graph.facebook.com", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testRootRelativeURIWithNonRootContext() throws MalformedURLException {
+        validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testNonRootRelativeURIWithNonRootContext() throws MalformedURLException {
+        validateAgainstRelativeURI("https://graph.facebook.com/foo/bar", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testNonRootRelativeURIWithRootContext() throws MalformedURLException {
+        validateAgainstRelativeURI("https://graph.facebook.com", "750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testAbsoluteURIWithContext() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/foo/bar",
+                "https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
+    }
+
+    @Test
+    public void testRelativeUriWithDots() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2/", "../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithDotsAboveRoot() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1", "../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithAbsoluteDots() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/", "/../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDots() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2/", "../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsAboveRoot() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2", "../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithAbsoluteConsecutiveDots() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2/", "/../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromRoot() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/", "../../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromRootResource() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1", "../../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromSubrootResource() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2", "../../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1/level2/level3", "../../../other/content/img.png");
+    }
+
+    @Test
+    public void testRelativeUriWithNoScheme() throws MalformedURLException {
+        validateAgainstRelativeURI("https://hello.com/level1", "//world.org/content/img.png");
+    }
+
+    @Test
+    public void testCreateAndToUrl() {
+        String url = "https://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.toUrl(), url, "url used to create uri and url returned from toUrl do not match");
+    }
+
+    @Test
+    public void testToUrlWithUserInfoPortPathAndQuery() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        assertEquals(uri.toUrl(), "http://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testQueryWithNonRootPath() {
+        Uri uri = Uri.create("http://hello.com/foo?query=value");
+        assertEquals(uri.getPath(), "/foo");
+        assertEquals(uri.getQuery(), "query=value");
+    }
+
+    @Test
+    public void testQueryWithNonRootPathAndTrailingSlash() {
+        Uri uri = Uri.create("http://hello.com/foo/?query=value");
+        assertEquals(uri.getPath(), "/foo/");
+        assertEquals(uri.getQuery(), "query=value");
+    }
+
+    @Test
+    public void testQueryWithRootPath() {
+        Uri uri = Uri.create("http://hello.com?query=value");
+        assertEquals(uri.getPath(), "");
+        assertEquals(uri.getQuery(), "query=value");
+    }
+
+    @Test
+    public void testQueryWithRootPathAndTrailingSlash() {
+        Uri uri = Uri.create("http://hello.com/?query=value");
+        assertEquals(uri.getPath(), "/");
+        assertEquals(uri.getQuery(), "query=value");
+    }
+
+    @Test
+    public void testWithNewScheme() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        Uri newUri = uri.withNewScheme("https");
+        assertEquals(newUri.getScheme(), "https");
+        assertEquals(newUri.toUrl(), "https://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testWithNewQuery() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        Uri newUri = uri.withNewQuery("query2=10&query3=20");
+        assertEquals(newUri.getQuery(), "query2=10&query3=20");
+        assertEquals(newUri.toUrl(), "http://user@example.com:44/path/path2?query2=10&query3=20", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testToRelativeUrl() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        String relativeUrl = uri.toRelativeUrl();
+        assertEquals(relativeUrl, "/path/path2?query=4", "toRelativeUrl returned incorrect url");
+    }
+
+    @Test
+    public void testToRelativeUrlWithEmptyPath() {
+        Uri uri = new Uri("http", "user", "example.com", 44, null, "query=4");
+        String relativeUrl = uri.toRelativeUrl();
+        assertEquals(relativeUrl, "/?query=4", "toRelativeUrl returned incorrect url");
+    }
+
+    @Test
+    public void testGetSchemeDefaultPortHttpScheme() {
+        String url = "https://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for https url");
+
+        String url2 = "http://hello.com/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);
+        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for http url");
+    }
+
+    @Test
+    public void testGetSchemeDefaultPortWebSocketScheme() {
+        String url = "wss://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for wss url");
+
+        String url2 = "ws://hello.com/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);
+        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for ws url");
+    }
+
+    @Test
+    public void testGetExplicitPort() {
+        String url = "http://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.getExplicitPort(), 80, "getExplicitPort should return port 80 for http url when port is not specified in url");
+
+        String url2 = "http://hello.com:8080/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);
+        assertEquals(uri2.getExplicitPort(), 8080, "getExplicitPort should return the port given in the url");
+    }
+
+    @Test
+    public void testEquals() {
+        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+        Uri createdUri = Uri.create(url);
+        Uri constructedUri = new Uri("http", "user", "hello.com", 8080, "/level1/level2/level3", "q=1");
+        assertTrue(createdUri.equals(constructedUri), "The equals method returned false for two equal urls");
+    }
+
+    @Test
+    public void testIsWebsocket() {
+        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+        Uri uri = Uri.create(url);
+        assertFalse(uri.isWebSocket(), "isWebSocket should return false for http url");
+
+        url = "https://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertFalse(uri.isWebSocket(), "isWebSocket should return false for https url");
+
+        url = "ws://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertTrue(uri.isWebSocket(), "isWebSocket should return true for ws url");
+
+        url = "wss://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertTrue(uri.isWebSocket(), "isWebSocket should return true for wss url");
+    }
+
+    @Test
+    public void creatingUriWithDefinedSchemeAndHostWorks() {
+        Uri.create("http://localhost");
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void creatingUriWithMissingSchemeThrowsIllegalArgumentException() {
+        Uri.create("localhost");
+    }
+
+    @Test(expectedExceptions = IllegalArgumentException.class)
+    public void creatingUriWithMissingHostThrowsIllegalArgumentException() {
+        Uri.create("http://");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
index 77eed2dc7..1e99c3b8b 100644
--- a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
+++ b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
@@ -13,15 +13,10 @@
  */
 package org.asynchttpclient.util;
 
+import static java.nio.charset.StandardCharsets.*;
+import static org.testng.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import org.asynchttpclient.DefaultAsyncHttpClientConfig;
-import org.asynchttpclient.Dsl;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.netty.util.ByteBufUtils;
-import org.asynchttpclient.uri.Uri;
-import org.testng.annotations.Test;
 
 import java.net.URLEncoder;
 import java.nio.ByteBuffer;
@@ -30,210 +25,208 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_JSON;
-import static java.nio.charset.StandardCharsets.*;
-import static org.testng.Assert.*;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.Dsl;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.netty.util.ByteBufUtils;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
 
 public class HttpUtilsTest {
 
-  private static String toUsAsciiString(ByteBuffer buf) throws CharacterCodingException {
-    ByteBuf bb = Unpooled.wrappedBuffer(buf);
-    try {
-      return ByteBufUtils.byteBuf2String(US_ASCII, bb);
-    } finally {
-      bb.release();
-    }
-  }
-
-  @Test
-  public void testGetAuthority() {
-    Uri uri = Uri.create("http://stackoverflow.com/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    String authority = HttpUtils.getAuthority(uri);
-    assertEquals(authority, "stackoverflow.com:80", "Incorrect authority returned from getAuthority");
-  }
-
-  @Test
-  public void testGetAuthorityWithPortInUrl() {
-    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    String authority = HttpUtils.getAuthority(uri);
-    assertEquals(authority, "stackoverflow.com:8443", "Incorrect authority returned from getAuthority");
-  }
-
-  @Test
-  public void testGetBaseUrl() {
-    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    String baseUrl = HttpUtils.getBaseUrl(uri);
-    assertEquals(baseUrl, "http://stackoverflow.com:8443", "Incorrect base URL returned from getBaseURL");
-  }
-
-  @Test
-  public void testIsSameBaseUrlReturnsFalseWhenPortDifferent() {
-    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    Uri uri2 = Uri.create("http://stackoverflow.com:8442/questions/1057564/pretty-git-branch-graphs");
-    assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-  }
-
-  @Test
-  public void testIsSameBaseUrlReturnsFalseWhenSchemeDifferent() {
-    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    Uri uri2 = Uri.create("ws://stackoverflow.com:8443/questions/1057564/pretty-git-branch-graphs");
-    assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-  }
-
-  @Test
-  public void testIsSameBaseUrlReturnsFalseWhenHostDifferent() {
-    Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    Uri uri2 = Uri.create("http://example.com:8443/questions/1057564/pretty-git-branch-graphs");
-    assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
-  }
-
-  @Test
-  public void testGetPathWhenPathIsNonEmpty() {
-    Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    String path = HttpUtils.getNonEmptyPath(uri);
-    assertEquals(path, "/questions/17814461/jacoco-maven-testng-0-test-coverage", "Incorrect path returned from getNonEmptyPath");
-  }
-
-  @Test
-  public void testGetPathWhenPathIsEmpty() {
-    Uri uri = Uri.create("http://stackoverflow.com");
-    String path = HttpUtils.getNonEmptyPath(uri);
-    assertEquals(path, "/", "Incorrect path returned from getNonEmptyPath");
-  }
-
-  @Test
-  public void testIsSameBaseUrlReturnsTrueWhenOneUriHasDefaultPort() {
-    Uri uri1 = Uri.create("http://stackoverflow.com:80/questions/17814461/jacoco-maven-testng-0-test-coverage");
-    Uri uri2 = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-    assertTrue(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be same, but false was returned from isSameBase");
-  }
-
-  @Test
-  public void testExtractCharsetWithoutQuotes() {
-    Charset charset = HttpUtils.extractCharset("text/html; charset=iso-8859-1");
-    assertEquals(charset, ISO_8859_1);
-  }
-
-  @Test
-  public void testExtractCharsetWithSingleQuotes() {
-    Charset charset = HttpUtils.extractCharset("text/html; charset='iso-8859-1'");
-    assertEquals(charset, ISO_8859_1);
-  }
-
-  @Test
-  public void testExtractCharsetWithDoubleQuotes() {
-    Charset charset = HttpUtils.extractCharset("text/html; charset=\"iso-8859-1\"");
-    assertEquals(charset, ISO_8859_1);
-  }
-
-  @Test
-  public void testExtractCharsetWithDoubleQuotesAndSpaces() {
-    Charset charset = HttpUtils.extractCharset("text/html; charset= \"iso-8859-1\" ");
-    assertEquals(charset, ISO_8859_1);
-  }
-
-  @Test
-  public void testExtractCharsetFallsBackToUtf8() {
-    Charset charset = HttpUtils.extractCharset(APPLICATION_JSON.toString());
-    assertNull(charset);
-  }
-
-  @Test
-  public void testGetHostHeaderNoVirtualHost() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs").build();
-    Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-    String hostHeader = HttpUtils.hostHeader(request, uri);
-    assertEquals(hostHeader, "stackoverflow.com", "Incorrect hostHeader returned");
-  }
-
-  @Test
-  public void testGetHostHeaderHasVirtualHost() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
-    Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
-    String hostHeader = HttpUtils.hostHeader(request, uri);
-    assertEquals(hostHeader, "example.com", "Incorrect hostHeader returned");
-  }
-
-  @Test
-  public void testDefaultFollowRedirect() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
-    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
-    boolean followRedirect = HttpUtils.followRedirect(config, request);
-    assertFalse(followRedirect, "Default value of redirect should be false");
-  }
-
-  @Test
-  public void testGetFollowRedirectInRequest() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(true).build();
-    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
-    boolean followRedirect = HttpUtils.followRedirect(config, request);
-    assertTrue(followRedirect, "Follow redirect must be true as set in the request");
-  }
-
-  @Test
-  public void testGetFollowRedirectInConfig() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").build();
-    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-    boolean followRedirect = HttpUtils.followRedirect(config, request);
-    assertTrue(followRedirect, "Follow redirect should be equal to value specified in config when not specified in request");
-  }
-
-  @Test
-  public void testGetFollowRedirectPriorityGivenToRequest() {
-    Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(false).build();
-    DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-    boolean followRedirect = HttpUtils.followRedirect(config, request);
-    assertFalse(followRedirect, "Follow redirect value set in request should be given priority");
-  }
-
-  private void formUrlEncoding(Charset charset) throws Exception {
-    String key = "key";
-    String value = "中文";
-    List<Param> params = new ArrayList<>();
-    params.add(new Param(key, value));
-    ByteBuffer ahcBytes = HttpUtils.urlEncodeFormParams(params, charset);
-    String ahcString = toUsAsciiString(ahcBytes);
-    String jdkString = key + "=" + URLEncoder.encode(value, charset.name());
-    assertEquals(ahcString, jdkString);
-  }
-
-  @Test
-  public void formUrlEncodingShouldSupportUtf8Charset() throws Exception {
-    formUrlEncoding(UTF_8);
-  }
-
-  @Test
-  public void formUrlEncodingShouldSupportNonUtf8Charset() throws Exception {
-    formUrlEncoding(Charset.forName("GBK"));
-  }
-
-  @Test
-  public void computeOriginForPlainUriWithImplicitPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com/bar")), "http://foo.com");
-  }
-
-  @Test
-  public void computeOriginForPlainUriWithDefaultPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:80/bar")), "http://foo.com");
-  }
-
-  @Test
-  public void computeOriginForPlainUriWithNonDefaultPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:81/bar")), "http://foo.com:81");
-  }
-
-  @Test
-  public void computeOriginForSecuredUriWithImplicitPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com/bar")), "https://foo.com");
-  }
-
-  @Test
-  public void computeOriginForSecuredUriWithDefaultPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:443/bar")), "https://foo.com");
-  }
-
-  @Test
-  public void computeOriginForSecuredUriWithNonDefaultPort() {
-    assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:444/bar")), "https://foo.com:444");
-  }
+    @Test
+    public void testGetAuthority() {
+        Uri uri = Uri.create("http://stackoverflow.com/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String authority = HttpUtils.getAuthority(uri);
+        assertEquals(authority, "stackoverflow.com:80", "Incorrect authority returned from getAuthority");
+    }
+
+    @Test
+    public void testGetAuthorityWithPortInUrl() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String authority = HttpUtils.getAuthority(uri);
+        assertEquals(authority, "stackoverflow.com:8443", "Incorrect authority returned from getAuthority");
+    }
+
+    @Test
+    public void testGetBaseUrl() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String baseUrl = HttpUtils.getBaseUrl(uri);
+        assertEquals(baseUrl, "http://stackoverflow.com:8443", "Incorrect base URL returned from getBaseURL");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenPortDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://stackoverflow.com:8442/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenSchemeDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("ws://stackoverflow.com:8443/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenHostDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://example.com:8443/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testGetPathWhenPathIsNonEmpty() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String path = HttpUtils.getNonEmptyPath(uri);
+        assertEquals(path, "/questions/17814461/jacoco-maven-testng-0-test-coverage", "Incorrect path returned from getNonEmptyPath");
+    }
+
+    @Test
+    public void testGetPathWhenPathIsEmpty() {
+        Uri uri = Uri.create("http://stackoverflow.com");
+        String path = HttpUtils.getNonEmptyPath(uri);
+        assertEquals(path, "/", "Incorrect path returned from getNonEmptyPath");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsTrueWhenOneUriHasDefaultPort() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:80/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        assertTrue(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be same, but false was returned from isSameBase");
+    }
+
+    @Test
+    public void testParseCharsetWithoutQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=utf-8");
+        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetWithSingleQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset='utf-8'");
+        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetWithDoubleQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=\"utf-8\"");
+        assertEquals(charset, UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetReturnsNullWhenNoCharset() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json");
+        assertNull(charset, "parseCharset should return null when charset is not specified in header value");
+    }
+
+    @Test
+    public void testGetHostHeaderNoVirtualHost() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs").build();
+        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        String hostHeader = HttpUtils.hostHeader(request, uri);
+        assertEquals(hostHeader, "stackoverflow.com", "Incorrect hostHeader returned");
+    }
+
+    @Test
+    public void testGetHostHeaderHasVirtualHost() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
+        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        String hostHeader = HttpUtils.hostHeader(request, uri);
+        assertEquals(hostHeader, "example.com", "Incorrect hostHeader returned");
+    }
+
+    @Test
+    public void testDefaultFollowRedirect() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertFalse(followRedirect, "Default value of redirect should be false");
+    }
+
+    @Test
+    public void testGetFollowRedirectInRequest() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(true).build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertTrue(followRedirect, "Follow redirect must be true as set in the request");
+    }
+
+    @Test
+    public void testGetFollowRedirectInConfig() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertTrue(followRedirect, "Follow redirect should be equal to value specified in config when not specified in request");
+    }
+
+    @Test
+    public void testGetFollowRedirectPriorityGivenToRequest() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(false).build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertFalse(followRedirect, "Follow redirect value set in request should be given priority");
+    }
+
+    private void formUrlEncoding(Charset charset) throws Exception {
+        String key = "key";
+        String value = "中文";
+        List<Param> params = new ArrayList<>();
+        params.add(new Param(key, value));
+        ByteBuffer ahcBytes = HttpUtils.urlEncodeFormParams(params, charset);
+        String ahcString = toUsAsciiString(ahcBytes);
+        String jdkString = key + "=" + URLEncoder.encode(value, charset.name());
+        assertEquals(ahcString, jdkString);
+    }
+
+    @Test
+    public void formUrlEncodingShouldSupportUtf8Charset() throws Exception {
+        formUrlEncoding(UTF_8);
+    }
+
+    @Test
+    public void formUrlEncodingShouldSupportNonUtf8Charset() throws Exception {
+        formUrlEncoding(Charset.forName("GBK"));
+    }
+
+    private static String toUsAsciiString(ByteBuffer buf) throws CharacterCodingException {
+        ByteBuf bb = Unpooled.wrappedBuffer(buf);
+        try {
+            return ByteBufUtils.byteBuf2String(US_ASCII, bb);
+        } finally {
+            bb.release();
+        }
+    }
+
+    @Test
+    public void computeOriginForPlainUriWithImplicitPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com/bar")), "http://foo.com");
+    }
+
+    @Test
+    public void computeOriginForPlainUriWithDefaultPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:80/bar")), "http://foo.com");
+    }
+
+    @Test
+    public void computeOriginForPlainUriWithNonDefaultPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("ws://foo.com:81/bar")), "http://foo.com:81");
+    }
+
+    @Test
+    public void computeOriginForSecuredUriWithImplicitPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com/bar")), "https://foo.com");
+    }
+
+    @Test
+    public void computeOriginForSecuredUriWithDefaultPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:443/bar")), "https://foo.com");
+    }
+
+    @Test
+    public void computeOriginForSecuredUriWithNonDefaultPort() {
+        assertEquals(HttpUtils.computeOriginHeader(Uri.create("wss://foo.com:444/bar")), "https://foo.com:444");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java b/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
index 996d582fd..acdcf78ab 100644
--- a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
+++ b/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
@@ -15,23 +15,23 @@
  */
 package org.asynchttpclient.util;
 
-import org.testng.annotations.Test;
-
 import static org.testng.Assert.assertEquals;
 
+import org.testng.annotations.Test;
+
 public class TestUTF8UrlCodec {
-  @Test
-  public void testBasics() {
-    assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
-    assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
-    assertEquals(Utf8UrlEncoder.encodeQueryElement("a+b"), "a%2Bb");
-  }
+    @Test(groups = "standalone")
+    public void testBasics() {
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("a+b"), "a%2Bb");
+    }
 
-  @Test
-  public void testPercentageEncoding() {
-    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foobar"), "foobar");
-    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo*bar"), "foo%2Abar");
-    assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo~b_ar"), "foo~b_ar");
-  }
+    @Test(groups = "standalone")
+    public void testPercentageEncoding() {
+        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foobar"), "foobar");
+        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo*bar"), "foo%2Abar");
+        assertEquals(Utf8UrlEncoder.percentEncodeQueryElement("foo~b_ar"), "foo~b_ar");
+    }
 
 }
diff --git a/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java b/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
index adc12655e..d06090c06 100644
--- a/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
+++ b/client/src/test/java/org/asynchttpclient/webdav/WebdavTest.java
@@ -12,6 +12,18 @@
  */
 package org.asynchttpclient.webdav;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.concurrent.ExecutionException;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
 import org.apache.catalina.Context;
 import org.apache.catalina.servlets.WebdavServlet;
 import org.apache.catalina.startup.Tomcat;
@@ -24,166 +36,154 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-import java.io.File;
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.concurrent.ExecutionException;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
 public class WebdavTest {
 
-  private Tomcat tomcat;
-  private int port1;
-
-  @SuppressWarnings("serial")
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-
-    String path = new File(".").getAbsolutePath() + "/target";
-
-    tomcat = new Tomcat();
-    tomcat.setHostname("localhost");
-    tomcat.setPort(0);
-    tomcat.setBaseDir(path);
-    Context ctx = tomcat.addContext("", path);
-
-    Tomcat.addServlet(ctx, "webdav", new WebdavServlet() {
-      @Override
-      public void init(ServletConfig config) throws ServletException {
-
-        super.init(new ServletConfig() {
-
-          @Override
-          public String getServletName() {
-            return config.getServletName();
-          }
-
-          @Override
-          public ServletContext getServletContext() {
-            return config.getServletContext();
-          }
-
-          @Override
-          public Enumeration<String> getInitParameterNames() {
-            // FIXME
-            return config.getInitParameterNames();
-          }
-
-          @Override
-          public String getInitParameter(String name) {
-            switch (name) {
-              case "readonly":
-                return "false";
-              case "listings":
-                return "true";
-              default:
-                return config.getInitParameter(name);
+    private Tomcat tomcat;
+    private int port1;
+
+    @SuppressWarnings("serial")
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+
+        String path = new File(".").getAbsolutePath() + "/target";
+
+        tomcat = new Tomcat();
+        tomcat.setHostname("localhost");
+        tomcat.setPort(0);
+        tomcat.setBaseDir(path);
+        Context ctx = tomcat.addContext("", path);
+
+        Tomcat.addServlet(ctx, "webdav", new WebdavServlet() {
+            @Override
+            public void init(ServletConfig config) throws ServletException {
+
+                super.init(new ServletConfig() {
+
+                    @Override
+                    public String getServletName() {
+                        return config.getServletName();
+                    }
+
+                    @Override
+                    public ServletContext getServletContext() {
+                        return config.getServletContext();
+                    }
+
+                    @Override
+                    public Enumeration<String> getInitParameterNames() {
+                        // FIXME
+                        return config.getInitParameterNames();
+                    }
+
+                    @Override
+                    public String getInitParameter(String name) {
+                        switch (name) {
+                        case "readonly":
+                            return "false";
+                        case "listings":
+                            return "true";
+                        default:
+                            return config.getInitParameter(name);
+                        }
+                    }
+                });
             }
-          }
+
         });
-      }
-
-    });
-    ctx.addServletMappingDecoded("/*", "webdav");
-    tomcat.start();
-    port1 = tomcat.getConnector().getLocalPort();
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    tomcat.stop();
-  }
-
-  private String getTargetUrl() {
-    return String.format("http://localhost:%s/folder1", port1);
-  }
-
-  @AfterMethod(alwaysRun = true)
-  public void clean() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      c.executeRequest(delete(getTargetUrl())).get();
+        ctx.addServletMappingDecoded("/*", "webdav");
+        tomcat.start();
+        port1 = tomcat.getConnector().getLocalPort();
     }
-  }
-
-  @Test
-  public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-      Response response = c.executeRequest(mkcolRequest).get();
-      assertEquals(response.getStatusCode(), 201);
-    }
-  }
-
-  @Test
-  public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
-      Response response = c.executeRequest(mkcolRequest).get();
-      assertEquals(response.getStatusCode(), 409);
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws InterruptedException, Exception {
+        tomcat.stop();
     }
-  }
 
-  @Test
-  public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-      Response response = c.executeRequest(propFindRequest).get();
+    private String getTargetUrl() {
+        return String.format("http://localhost:%s/folder1", port1);
+    }
 
-      assertEquals(response.getStatusCode(), 404);
+    @AfterMethod(alwaysRun = true)
+    public void clean() throws InterruptedException, Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            c.executeRequest(delete(getTargetUrl())).get();
+        }
     }
-  }
 
-  @Test
-  public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-      Response response = c.executeRequest(mkcolRequest).get();
-      assertEquals(response.getStatusCode(), 201);
+    @Test(groups = "standalone")
+    public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+        }
+    }
 
-      Request putRequest = put(getTargetUrl() + "/Test.txt").setBody("this is a test").build();
-      response = c.executeRequest(putRequest).get();
-      assertEquals(response.getStatusCode(), 201);
+    @Test(groups = "standalone")
+    public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 409);
+        }
+    }
 
-      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl() + "/Test.txt").build();
-      response = c.executeRequest(propFindRequest).get();
+    @Test(groups = "standalone")
+    public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(propFindRequest).get();
 
-      assertEquals(response.getStatusCode(), 207);
-      assertTrue(response.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
-    }
-  }
-
-  @Test
-  public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-      Response response = c.executeRequest(mkcolRequest).get();
-      assertEquals(response.getStatusCode(), 201);
-
-      Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-      WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void onThrowable(Throwable t) {
-
-          t.printStackTrace();
+            assertEquals(response.getStatusCode(), 404);
         }
+    }
+
+    @Test(groups = "standalone")
+    public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
 
-        @Override
-        public WebDavResponse onCompleted(WebDavResponse response) {
-          return response;
+            Request putRequest = put(getTargetUrl() + "/Test.txt").setBody("this is a test").build();
+            response = c.executeRequest(putRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl() + "/Test.txt").build();
+            response = c.executeRequest(propFindRequest).get();
+
+            assertEquals(response.getStatusCode(), 207);
+            assertTrue(response.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
         }
-      }).get();
+    }
 
-      assertEquals(webDavResponse.getStatusCode(), 207);
-      assertTrue(webDavResponse.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
+    @Test(groups = "standalone")
+    public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
+                /**
+                 * {@inheritDoc}
+                 */
+                @Override
+                public void onThrowable(Throwable t) {
+
+                    t.printStackTrace();
+                }
+
+                @Override
+                public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
+                    return response;
+                }
+            }).get();
+
+            assertEquals(webDavResponse.getStatusCode(), 207);
+            assertTrue(webDavResponse.getResponseBody().contains("HTTP/1.1 200 OK"), "Got " + response.getResponseBody());
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
index a6c98565c..a0296bb53 100644
--- a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicWebSocketTest.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.ws;
 
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+
 import org.asynchttpclient.AbstractBasicTest;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
@@ -19,32 +21,30 @@
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.BeforeClass;
 
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-
 public abstract class AbstractBasicWebSocketTest extends AbstractBasicTest {
 
-  @BeforeClass(alwaysRun = true)
-  @Override
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(configureHandler());
-    server.start();
-    port1 = connector.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
-
-  protected String getTargetUrl() {
-    return String.format("ws://localhost:%d/", port1);
-  }
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(configureHandler());
+        server.start();
+        port1 = connector.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+    }
 
-  @Override
-  public WebSocketHandler configureHandler() {
-    return new WebSocketHandler() {
-      @Override
-      public void configure(WebSocketServletFactory factory) {
-        factory.register(EchoWebSocket.class);
-      }
-    };
-  }
+    protected String getTargetUrl() {
+        return String.format("ws://localhost:%d/", port1);
+    }
+    
+    @Override
+    public WebSocketHandler configureHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
+            }
+        };
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
index ef624af59..313113f0a 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
@@ -12,199 +12,188 @@
  */
 package org.asynchttpclient.ws;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.assertEquals;
 
 import java.nio.charset.StandardCharsets;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 public class ByteMessageTest extends AbstractBasicWebSocketTest {
-
-  private static final byte[] ECHO_BYTES = "ECHO".getBytes(StandardCharsets.UTF_8);
-
-  private void echoByte0(boolean enableCompression) throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setEnablewebSocketCompression(enableCompression))) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<byte[]> receivedBytes = new AtomicReference<>(new byte[0]);
-
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
-
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+    
+    private static final byte[] ECHO_BYTES = "ECHO".getBytes(StandardCharsets.UTF_8);
+
+    @Test(groups = "standalone")
+    public void echoByte() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<>(new byte[0]);
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+                
+                @Override
+                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+                    text.set(frame);
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendBinaryFrame(ECHO_BYTES);
+
+            latch.await();
+            assertEquals(text.get(), ECHO_BYTES);
         }
-
-        @Override
-        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-          receivedBytes.set(frame);
-          latch.countDown();
-        }
-      }).build()).get();
-
-      websocket.sendBinaryFrame(ECHO_BYTES);
-
-      latch.await();
-      assertEquals(receivedBytes.get(), ECHO_BYTES);
     }
-  }
-
-  @Test
-  public void echoByte() throws Exception {
-    echoByte0(false);
-  }
-
-  @Test
-  public void echoByteCompressed() throws Exception {
-    echoByte0(true);
-  }
-
-  @Test
-  public void echoTwoMessagesTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(2);
-      final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
+    @Test(groups = "standalone")
+    public void echoTwoMessagesTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+                    if (text.get() == null) {
+                        text.set(frame);
+                    } else {
+                        byte[] n = new byte[text.get().length + frame.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+            }).build()).get();
+
+            websocket.sendBinaryFrame(ECHO_BYTES);
+            websocket.sendBinaryFrame(ECHO_BYTES);
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
         }
-
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-
-        @Override
-        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-          if (text.get() == null) {
-            text.set(frame);
-          } else {
-            byte[] n = new byte[text.get().length + frame.length];
-            System.arraycopy(text.get(), 0, n, 0, text.get().length);
-            System.arraycopy(frame, 0, n, text.get().length, frame.length);
-            text.set(n);
-          }
-          latch.countDown();
-        }
-
-      }).build()).get();
-
-      websocket.sendBinaryFrame(ECHO_BYTES);
-      websocket.sendBinaryFrame(ECHO_BYTES);
-
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
-  }
-
-  @Test
-  public void echoOnOpenMessagesTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(2);
-      final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-          websocket.sendBinaryFrame(ECHO_BYTES);
-          websocket.sendBinaryFrame(ECHO_BYTES);
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+    @Test
+    public void echoOnOpenMessagesTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    websocket.sendBinaryFrame(ECHO_BYTES);
+                    websocket.sendBinaryFrame(ECHO_BYTES);
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+                    if (text.get() == null) {
+                        text.set(frame);
+                    } else {
+                        byte[] n = new byte[text.get().length + frame.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
         }
-
-        @Override
-        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-          if (text.get() == null) {
-            text.set(frame);
-          } else {
-            byte[] n = new byte[text.get().length + frame.length];
-            System.arraycopy(text.get(), 0, n, 0, text.get().length);
-            System.arraycopy(frame, 0, n, text.get().length, frame.length);
-            text.set(n);
-          }
-          latch.countDown();
-        }
-
-      }).build()).get();
-
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
-  }
 
-  @Test
-  public void echoFragments() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<byte[]> text = new AtomicReference<>(null);
-
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
+    public void echoFragments() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
+                    if (text.get() == null) {
+                        text.set(frame);
+                    } else {
+                        byte[] n = new byte[text.get().length + frame.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(frame, 0, n, text.get().length, frame.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+            }).build()).get();
+            websocket.sendBinaryFrame(ECHO_BYTES, false, 0);
+            websocket.sendBinaryFrame(ECHO_BYTES, true, 0);
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
         }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
-
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-
-        @Override
-        public void onBinaryFrame(byte[] frame, boolean finalFragment, int rsv) {
-          if (text.get() == null) {
-            text.set(frame);
-          } else {
-            byte[] n = new byte[text.get().length + frame.length];
-            System.arraycopy(text.get(), 0, n, 0, text.get().length);
-            System.arraycopy(frame, 0, n, text.get().length, frame.length);
-            text.set(n);
-          }
-          latch.countDown();
-        }
-
-      }).build()).get();
-      websocket.sendBinaryFrame(ECHO_BYTES, false, 0);
-      websocket.sendContinuationFrame(ECHO_BYTES, true, 0);
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO".getBytes());
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 52aaefc3a..3a602783f 100644
--- a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -12,54 +12,56 @@
  */
 package org.asynchttpclient.ws;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 public class CloseCodeReasonMessageTest extends AbstractBasicWebSocketTest {
 
-  @Test(timeOut = 60000)
-  public void onCloseWithCode() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onCloseWithCode() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
-      websocket.sendCloseFrame();
+            websocket.sendCloseFrame();
 
-      latch.await();
-      assertTrue(text.get().startsWith("1000"), "Expected a 1000 code but got " + text.get());
+            latch.await();
+            assertTrue(text.get().startsWith("1000"), "Expected a 1000 code but got " + text.get());
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void onCloseWithCodeServerClose() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onCloseWithCodeServerClose() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
-      latch.await();
-      assertEquals(text.get(), "1001-Idle Timeout");
+            latch.await();
+            assertEquals(text.get(), "1001-Idle Timeout");
+        }
     }
-  }
 
-  @Test(groups = "online", timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void getWebSocketThrowsException() throws Throwable {
-    final CountDownLatch latch = new CountDownLatch(1);
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+    public final static class Listener implements WebSocketListener {
+
+        final CountDownLatch latch;
+        final AtomicReference<String> text;
+
+        public Listener(CountDownLatch latch, AtomicReference<String> text) {
+            this.latch = latch;
+            this.text = text;
+        }
 
         @Override
         public void onOpen(WebSocket websocket) {
@@ -67,100 +69,96 @@ public void onOpen(WebSocket websocket) {
 
         @Override
         public void onClose(WebSocket websocket, int code, String reason) {
+            text.set(code + "-" + reason);
+            latch.countDown();
         }
 
         @Override
         public void onError(Throwable t) {
-          latch.countDown();
+            t.printStackTrace();
+            latch.countDown();
         }
-      }).build()).get();
     }
 
-    latch.await();
-  }
-
-  @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalArgumentException.class)
-  public void wrongStatusCode() throws Throwable {
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<Throwable> throwable = new AtomicReference<>();
-
-      client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(org.asynchttpclient.ws.WebSocket websocket) {
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void getWebSocketThrowsException() throws Throwable {
+        final CountDownLatch latch = new CountDownLatch(1);
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+                
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    latch.countDown();
+                }
+            }).build()).get();
         }
 
-        @Override
-        public void onError(Throwable t) {
-          throwable.set(t);
-          latch.countDown();
-        }
-      }).build());
-
-      latch.await();
-      assertNotNull(throwable.get());
-      throw throwable.get();
+        latch.await();
     }
-  }
 
-  @Test(groups = "online", timeOut = 60000, expectedExceptions = IOException.class)
-  public void wrongProtocolCode() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<Throwable> throwable = new AtomicReference<>();
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalArgumentException.class)
+    public void wrongStatusCode() throws Throwable {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
 
-      c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onOpen(org.asynchttpclient.ws.WebSocket websocket) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                }
 
-        @Override
-        public void onError(Throwable t) {
-          throwable.set(t);
-          latch.countDown();
-        }
-      }).build());
+                @Override
+                public void onError(Throwable t) {
+                    throwable.set(t);
+                    latch.countDown();
+                }
+            }).build());
 
-      latch.await();
-      assertNotNull(throwable.get());
-      throw throwable.get();
+            latch.await();
+            assertNotNull(throwable.get());
+            throw throwable.get();
+        }
     }
-  }
 
-  public final static class Listener implements WebSocketListener {
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = IOException.class)
+    public void wrongProtocolCode() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
 
-    final CountDownLatch latch;
-    final AtomicReference<String> text;
+            c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-    Listener(CountDownLatch latch, AtomicReference<String> text) {
-      this.latch = latch;
-      this.text = text;
-    }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-    @Override
-    public void onOpen(WebSocket websocket) {
-    }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                }
 
-    @Override
-    public void onClose(WebSocket websocket, int code, String reason) {
-      text.set(code + "-" + reason);
-      latch.countDown();
-    }
+                @Override
+                public void onError(Throwable t) {
+                    throwable.set(t);
+                    latch.countDown();
+                }
+            }).build());
 
-    @Override
-    public void onError(Throwable t) {
-      t.printStackTrace();
-      latch.countDown();
+            latch.await();
+            assertNotNull(throwable.get());
+            throw throwable.get();
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java b/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
new file mode 100644
index 000000000..e239e2a64
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/ws/EchoSocket.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.ws;
+
+import org.eclipse.jetty.websocket.api.Session;
+import org.eclipse.jetty.websocket.api.WebSocketAdapter;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+public class EchoSocket extends WebSocketAdapter {
+
+    @Override
+    public void onWebSocketConnect(Session sess) {
+        super.onWebSocketConnect(sess);
+        sess.setIdleTimeout(10000);
+    }
+
+    @Override
+    public void onWebSocketClose(int statusCode, String reason) {
+        getSession().close();
+        super.onWebSocketClose(statusCode, reason);
+    }
+
+    @Override
+    public void onWebSocketBinary(byte[] payload, int offset, int len) {
+        if (isNotConnected()) {
+            return;
+        }
+        try {
+            getRemote().sendBytes(ByteBuffer.wrap(payload, offset, len));
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void onWebSocketText(String message) {
+        if (isNotConnected()) {
+            return;
+        }
+        try {
+            if (message.equals("CLOSE"))
+                getSession().close();
+            else
+                getRemote().sendString(message);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java b/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java
deleted file mode 100644
index 2ffeaa4ab..000000000
--- a/client/src/test/java/org/asynchttpclient/ws/EchoWebSocket.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.ws;
-
-import org.eclipse.jetty.websocket.api.Session;
-import org.eclipse.jetty.websocket.api.WebSocketAdapter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-public class EchoWebSocket extends WebSocketAdapter {
-
-  private static final Logger LOGGER = LoggerFactory.getLogger(EchoWebSocket.class);
-
-  @Override
-  public void onWebSocketConnect(Session sess) {
-    super.onWebSocketConnect(sess);
-    sess.setIdleTimeout(10000);
-  }
-
-  @Override
-  public void onWebSocketClose(int statusCode, String reason) {
-    getSession().close();
-    super.onWebSocketClose(statusCode, reason);
-  }
-
-  @Override
-  public void onWebSocketBinary(byte[] payload, int offset, int len) {
-    if (isNotConnected()) {
-      return;
-    }
-    try {
-      LOGGER.debug("Received binary frame of size {}: {}", len, new String(payload, offset, len, UTF_8));
-      getRemote().sendBytes(ByteBuffer.wrap(payload, offset, len));
-    } catch (IOException e) {
-      e.printStackTrace();
-    }
-  }
-
-  @Override
-  public void onWebSocketText(String message) {
-    if (isNotConnected()) {
-      return;
-    }
-
-    if (message.equals("CLOSE")) {
-      getSession().close();
-      return;
-    }
-
-    try {
-      LOGGER.debug("Received text frame of size: {}", message);
-      getRemote().sendString(message);
-    } catch (IOException e) {
-      e.printStackTrace();
-    }
-  }
-}
diff --git a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index 55b058a93..ba2d7f01d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -12,6 +12,13 @@
  */
 package org.asynchttpclient.ws;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.eclipse.jetty.proxy.ConnectHandler;
@@ -20,94 +27,86 @@
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
-import static org.testng.Assert.assertEquals;
-
 /**
  * Proxy usage tests.
  */
 public class ProxyTunnellingTest extends AbstractBasicWebSocketTest {
 
-  private Server server2;
+    private Server server2;
 
-  private void setUpServers(boolean targetHttps) throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(new ConnectHandler());
-    server.start();
-    port1 = connector.getLocalPort();
+    public void setUpServers(boolean targetHttps) throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(new ConnectHandler());
+        server.start();
+        port1 = connector.getLocalPort();
 
-    server2 = new Server();
-    @SuppressWarnings("resource")
-    ServerConnector connector2 = targetHttps ? addHttpsConnector(server2) : addHttpConnector(server2);
-    server2.setHandler(configureHandler());
-    server2.start();
-    port2 = connector2.getLocalPort();
+        server2 = new Server();
+        @SuppressWarnings("resource")
+        ServerConnector connector2 = targetHttps ? addHttpsConnector(server2) : addHttpConnector(server2);
+        server2.setHandler(configureHandler());
+        server2.start();
+        port2 = connector2.getLocalPort();
 
-    logger.info("Local HTTP server started successfully");
-  }
+        logger.info("Local HTTP server started successfully");
+    }
 
-  @AfterMethod(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    server.stop();
-    server2.stop();
-  }
+    @AfterMethod(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        server.stop();
+        server2.stop();
+    }
 
-  @Test(timeOut = 60000)
-  public void echoWSText() throws Exception {
-    runTest(false);
-  }
+    @Test(groups = "standalone", timeOut = 60000)
+    public void echoWSText() throws Exception {
+        runTest(false);
+    }
 
-  @Test(timeOut = 60000)
-  public void echoWSSText() throws Exception {
-    runTest(true);
-  }
+    @Test(groups = "standalone", timeOut = 60000)
+    public void echoWSSText() throws Exception {
+        runTest(true);
+    }
 
-  private void runTest(boolean secure) throws Exception {
+    private void runTest(boolean secure) throws Exception {
 
-    setUpServers(secure);
+        setUpServers(secure);
 
-    String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
+        String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
 
-    // CONNECT happens over HTTP, not HTTPS
-    ProxyServer ps = proxyServer("localhost", port1).build();
-    try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setUseInsecureTrustManager(true))) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+        // CONNECT happens over HTTP, not HTTPS
+        ProxyServer ps = proxyServer("localhost", port1).build();
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setUseInsecureTrustManager(true))) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(payload);
-          latch.countDown();
-        }
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(payload);
+                    latch.countDown();
+                }
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-      }).build()).get();
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-      websocket.sendTextFrame("ECHO");
+            websocket.sendTextFrame("ECHO");
 
-      latch.await();
-      assertEquals(text.get(), "ECHO");
+            latch.await();
+            assertEquals(text.get(), "ECHO");
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index fd949fa25..763848cc1 100644
--- a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -13,6 +13,18 @@
 
 package org.asynchttpclient.ws;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -22,77 +34,66 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.asynchttpclient.Dsl.config;
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.testng.Assert.assertEquals;
-
 public class RedirectTest extends AbstractBasicWebSocketTest {
 
-  @BeforeClass
-  @Override
-  public void setUpGlobal() throws Exception {
-
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    ServerConnector connector2 = addHttpConnector(server);
-
-    HandlerList list = new HandlerList();
-    list.addHandler(new AbstractHandler() {
-      @Override
-      public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException {
-        if (request.getLocalPort() == port2) {
-          httpServletResponse.sendRedirect(getTargetUrl());
-        }
-      }
-    });
-    list.addHandler(configureHandler());
-    server.setHandler(list);
-
-    server.start();
-    port1 = connector1.getLocalPort();
-    port2 = connector2.getLocalPort();
-    logger.info("Local HTTP server started successfully");
-  }
-
-  @Test(timeOut = 60000)
-  public void testRedirectToWSResource() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
-
-      WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-          text.set("OnOpen");
-          latch.countDown();
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-        }
+    @BeforeClass
+    @Override
+    public void setUpGlobal() throws Exception {
+
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        ServerConnector connector2 = addHttpConnector(server);
+
+        HandlerList list = new HandlerList();
+        list.addHandler(new AbstractHandler() {
+            @Override
+            public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
+                if (request.getLocalPort() == port2) {
+                    httpServletResponse.sendRedirect(getTargetUrl());
+                }
+            }
+        });
+        list.addHandler(configureHandler());
+        server.setHandler(list);
+
+        server.start();
+        port1 = connector1.getLocalPort();
+        port2 = connector2.getLocalPort();
+        logger.info("Local HTTP server started successfully");
+    }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+    @Test(groups = "standalone", timeOut = 60000)
+    public void testRedirectToWSResource() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
+
+            WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
+            websocket.sendCloseFrame();
         }
-      }).build()).get();
-
-      latch.await();
-      assertEquals(text.get(), "OnOpen");
-      websocket.sendCloseFrame();
     }
-  }
 
-  private String getRedirectURL() {
-    return String.format("ws://localhost:%d/", port2);
-  }
+    private String getRedirectURL() {
+        return String.format("ws://localhost:%d/", port2);
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
index d3249944d..2da22ec79 100644
--- a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
@@ -12,344 +12,341 @@
  */
 package org.asynchttpclient.ws;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
+import static org.testng.Assert.*;
 
 import java.net.UnknownHostException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
+import org.asynchttpclient.AsyncHttpClient;
+import org.testng.annotations.Test;
 
 public class TextMessageTest extends AbstractBasicWebSocketTest {
 
-  @Test(timeOut = 60000)
-  public void onOpen() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
-
-      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-          text.set("OnOpen");
-          latch.countDown();
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-        }
-
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-      }).build()).get();
-
-      latch.await();
-      assertEquals(text.get(), "OnOpen");
-    }
-  }
-
-  @Test(timeOut = 60000)
-  public void onEmptyListenerTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      WebSocket websocket = null;
-      try {
-        websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
-      } catch (Throwable t) {
-        fail();
-      }
-      assertTrue(websocket != null);
-    }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = UnknownHostException.class)
-  public void onFailureTest() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
-    } catch (ExecutionException e) {
-      throw e.getCause();
-    }
-  }
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onOpen() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-  @Test(timeOut = 60000)
-  public void onTimeoutCloseTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          text.set("OnClose");
-          latch.countDown();
-        }
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
         }
-      }).build()).get();
-
-      latch.await();
-      assertEquals(text.get(), "OnClose");
     }
-  }
-
-  @Test(timeOut = 60000)
-  public void onClose() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
-
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          text.set("OnClose");
-          latch.countDown();
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onEmptyListenerTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            WebSocket websocket = null;
+            try {
+                websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+            } catch (Throwable t) {
+                fail();
+            }
+            assertTrue(websocket != null);
         }
+    }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = UnknownHostException.class)
+    public void onFailureTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
+        } catch (ExecutionException e) {
+            throw e.getCause();
         }
-      }).build()).get();
-
-      websocket.sendCloseFrame();
-
-      latch.await();
-      assertEquals(text.get(), "OnClose");
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void echoText() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onTimeoutCloseTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(payload);
-          latch.countDown();
-        }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+            latch.await();
+            assertEquals(text.get(), "OnClose");
         }
-      }).build()).get();
-
-      websocket.sendTextFrame("ECHO");
-
-      latch.await();
-      assertEquals(text.get(), "ECHO");
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void echoDoubleListenerText() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(2);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    @Test(groups = "standalone", timeOut = 60000)
+    public void onClose() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(payload);
-          latch.countDown();
-        }
-
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-      }).addWebSocketListener(new WebSocketListener() {
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(text.get() + payload);
-          latch.countDown();
-        }
+            websocket.sendCloseFrame();
 
-        @Override
-        public void onOpen(WebSocket websocket) {
+            latch.await();
+            assertEquals(text.get(), "OnClose");
         }
+    }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
+    @Test(groups = "standalone", timeOut = 60000)
+    public void echoText() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-      }).build()).get();
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-      websocket.sendTextFrame("ECHO");
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(payload);
+                    latch.countDown();
+                }
 
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO");
-    }
-  }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-  @Test
-  public void echoTwoMessagesTest() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(2);
-      final AtomicReference<String> text = new AtomicReference<>("");
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
 
-      c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(text.get() + payload);
-          latch.countDown();
-        }
+            websocket.sendTextFrame("ECHO");
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-          websocket.sendTextFrame("ECHO");
-          websocket.sendTextFrame("ECHO");
+            latch.await();
+            assertEquals(text.get(), "ECHO");
         }
+    }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
+    @Test(groups = "standalone", timeOut = 60000)
+    public void echoDoubleListenerText() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(payload);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(text.get() + payload);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendTextFrame("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
         }
+    }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
+    @Test(groups = "standalone")
+    public void echoTwoMessagesTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<>("");
+
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(text.get() + payload);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    websocket.sendTextFrame("ECHO");
+                    websocket.sendTextFrame("ECHO");
+                }
+
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
         }
-      }).build()).get();
-
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO");
     }
-  }
 
-  @Test
-  public void echoFragments() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch latch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    public void echoFragments() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(payload);
-          latch.countDown();
-        }
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(payload);
+                    latch.countDown();
+                }
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          latch.countDown();
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    latch.countDown();
+                }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          latch.countDown();
-        }
-      }).build()).get();
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-      websocket.sendTextFrame("ECHO", false, 0);
-      websocket.sendContinuationFrame("ECHO", true, 0);
+            websocket.sendTextFrame("ECHO", false, 0);
+            websocket.sendTextFrame("ECHO", true, 0);
 
-      latch.await();
-      assertEquals(text.get(), "ECHOECHO");
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void echoTextAndThenClose() throws Throwable {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      final CountDownLatch textLatch = new CountDownLatch(1);
-      final CountDownLatch closeLatch = new CountDownLatch(1);
-      final AtomicReference<String> text = new AtomicReference<>("");
+    @Test(groups = "standalone", timeOut = 60000)
+    public void echoTextAndThenClose() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            final CountDownLatch textLatch = new CountDownLatch(1);
+            final CountDownLatch closeLatch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<>("");
 
-      final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-        @Override
-        public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          text.set(text.get() + payload);
-          textLatch.countDown();
-        }
+                @Override
+                public void onTextFrame(String payload, boolean finalFragment, int rsv) {
+                    text.set(text.get() + payload);
+                    textLatch.countDown();
+                }
 
-        @Override
-        public void onOpen(WebSocket websocket) {
-        }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-        @Override
-        public void onClose(WebSocket websocket, int code, String reason) {
-          closeLatch.countDown();
-        }
+                @Override
+                public void onClose(WebSocket websocket, int code, String reason) {
+                    closeLatch.countDown();
+                }
 
-        @Override
-        public void onError(Throwable t) {
-          t.printStackTrace();
-          closeLatch.countDown();
-        }
-      }).build()).get();
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    closeLatch.countDown();
+                }
+            }).build()).get();
 
-      websocket.sendTextFrame("ECHO");
-      textLatch.await();
+            websocket.sendTextFrame("ECHO");
+            textLatch.await();
 
-      websocket.sendTextFrame("CLOSE");
-      closeLatch.await();
+            websocket.sendTextFrame("CLOSE");
+            closeLatch.await();
 
-      assertEquals(text.get(), "ECHO");
+            assertEquals(text.get(), "ECHO");
+        }
     }
-  }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java b/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
index a3b0ac53a..90253fbd8 100644
--- a/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/WebSocketWriteFutureTest.java
@@ -13,156 +13,156 @@
  */
 package org.asynchttpclient.ws;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.eclipse.jetty.websocket.server.WebSocketHandler;
-import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
-import org.testng.annotations.Test;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient;
+import org.eclipse.jetty.websocket.server.WebSocketHandler;
+import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
+import org.testng.annotations.Test;
 
 public class WebSocketWriteFutureTest extends AbstractBasicWebSocketTest {
 
-  @Override
-  public WebSocketHandler configureHandler() {
-    return new WebSocketHandler() {
-      @Override
-      public void configure(WebSocketServletFactory factory) {
-        factory.register(EchoWebSocket.class);
-      }
-    };
-  }
-
-  @Test(timeOut = 60000)
-  public void sendTextMessage() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
+    @Override
+    public WebSocketHandler configureHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public void configure(WebSocketServletFactory factory) {
+                factory.register(EchoSocket.class);
+            }
+        };
     }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void sendTextMessageExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", timeOut = 60000)
+    public void sendTextMessage() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void sendByteMessage() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void sendTextMessageExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendTextFrame("TEXT").get(10, TimeUnit.SECONDS);
+        }
     }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void sendByteMessageExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", timeOut = 60000)
+    public void sendByteMessage() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void sendPingMessage() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void sendByteMessageExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendBinaryFrame("BYTES".getBytes()).get(10, TimeUnit.SECONDS);
+        }
     }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void sendPingMessageExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", timeOut = 60000)
+    public void sendPingMessage() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
+        }
+    }
+
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void sendPingMessageExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendPingFrame("PING".getBytes()).get(10, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void sendPongMessage() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendPongFrame("PONG".getBytes()).get(10, TimeUnit.SECONDS);
+    @Test(groups = "standalone", timeOut = 60000)
+    public void sendPongMessage() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendPongFrame("PONG".getBytes()).get(10, TimeUnit.SECONDS);
+        }
     }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void sendPongMessageExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendPongFrame("PONG".getBytes()).get(1, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void sendPongMessageExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendPongFrame("PONG".getBytes()).get(1, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  @Test(timeOut = 60000)
-  public void streamBytes() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
+    @Test(groups = "standalone", timeOut = 60000)
+    public void streamBytes() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
+        }
     }
-  }
-
-  @Test(timeOut = 60000, expectedExceptions = ExecutionException.class)
-  public void streamBytesExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = ExecutionException.class)
+    public void streamBytesExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendBinaryFrame("STREAM".getBytes(), true, 0).get(1, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  @Test
-  public void streamText() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      getWebSocket(c).sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
+    @Test(groups = "standalone")
+    public void streamText() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            getWebSocket(c).sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
+        }
     }
-  }
-
-  @Test(expectedExceptions = ExecutionException.class)
-  public void streamTextExpectFailure() throws Exception {
-    try (AsyncHttpClient c = asyncHttpClient()) {
-      CountDownLatch closeLatch = new CountDownLatch(1);
-      WebSocket websocket = getWebSocket(c, closeLatch);
-      websocket.sendCloseFrame();
-      closeLatch.await(1, TimeUnit.SECONDS);
-      websocket.sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
+
+    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
+    public void streamTextExpectFailure() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            CountDownLatch closeLatch = new CountDownLatch(1);
+            WebSocket websocket = getWebSocket(c, closeLatch);
+            websocket.sendCloseFrame();
+            closeLatch.await(1, TimeUnit.SECONDS);
+            websocket.sendTextFrame("STREAM", true, 0).get(1, TimeUnit.SECONDS);
+        }
     }
-  }
 
-  private WebSocket getWebSocket(final AsyncHttpClient c) throws Exception {
-    return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
-  }
+    private WebSocket getWebSocket(final AsyncHttpClient c) throws Exception {
+        return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+    }
 
-  private WebSocket getWebSocket(final AsyncHttpClient c, CountDownLatch closeLatch) throws Exception {
-    return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+    private WebSocket getWebSocket(final AsyncHttpClient c, CountDownLatch closeLatch) throws Exception {
+        return c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-      @Override
-      public void onOpen(WebSocket websocket) {
-      }
+            @Override
+            public void onOpen(WebSocket websocket) {
+            }
 
-      @Override
-      public void onError(Throwable t) {
-      }
+            @Override
+            public void onError(Throwable t) {
+            }
 
-      @Override
-      public void onClose(WebSocket websocket, int code, String reason) {
-        closeLatch.countDown();
-      }
-    }).build()).get();
-  }
+            @Override
+            public void onClose(WebSocket websocket, int code, String reason) {
+                closeLatch.countDown();
+            }
+        }).build()).get();
+    }
 }
diff --git a/client/src/test/resources/empty.txt b/client/src/test/resources/empty.txt
deleted file mode 100644
index e69de29bb..000000000
diff --git a/client/src/test/resources/logback-test.xml b/client/src/test/resources/logback-test.xml
index 8a4aafcd9..0126d3538 100644
--- a/client/src/test/resources/logback-test.xml
+++ b/client/src/test/resources/logback-test.xml
@@ -1,14 +1,14 @@
 <configuration>
-  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
-    <layout class="ch.qos.logback.classic.PatternLayout">
-      <Pattern>%d [%thread] %level %logger - %m%n</Pattern>
-    </layout>
-  </appender>
+	<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
+		<layout class="ch.qos.logback.classic.PatternLayout">
+			<Pattern>%d [%thread] %level %logger - %m%n</Pattern>
+		</layout>
+	</appender>
 
-  <logger name="org.eclipse" level="INFO"/>
-  <logger name="org.apache" level="INFO"/>
+	<logger name="org.eclipse" level="INFO" />
+	<logger name="org.apache" level="INFO" />
 
-  <root level="DEBUG">
-    <appender-ref ref="CONSOLE"/>
-  </root>
+	<root level="DEBUG">
+		<appender-ref ref="CONSOLE" />
+	</root>
 </configuration>
diff --git a/example/pom.xml b/example/pom.xml
index f7d3ce244..1e1eacaee 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -1,21 +1,21 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-project</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client-example</artifactId>
-  <name>Asynchronous Http Client Example</name>
-  <packaging>jar</packaging>
-  <description>
-    The Async Http Client example.
-  </description>
-  <dependencies>
-    <dependency>
-      <groupId>org.asynchttpclient</groupId>
-      <artifactId>async-http-client</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-project</artifactId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-example</artifactId>
+    <name>Asynchronous Http Client Example</name>
+    <packaging>jar</packaging>
+    <description>
+        The Async Http Client example.
+    </description>
+    <dependencies>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
index f8a5eb1c0..172876113 100644
--- a/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
+++ b/example/src/main/java/org/asynchttpclient/example/completable/CompletableFutures.java
@@ -24,15 +24,15 @@
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 
 public class CompletableFutures {
-  public static void main(String[] args) throws IOException {
-    try (AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
-      asyncHttpClient
-              .prepareGet("http://www.example.com/")
-              .execute()
-              .toCompletableFuture()
-              .thenApply(Response::getResponseBody)
-              .thenAccept(System.out::println)
-              .join();
+    public static void main(String[] args) throws IOException {
+        try(AsyncHttpClient asyncHttpClient = asyncHttpClient()) {
+            asyncHttpClient
+                    .prepareGet("http://www.example.com/")
+                    .execute()
+                    .toCompletableFuture()
+                    .thenApply(Response::getResponseBody)
+                    .thenAccept(System.out::println)
+                    .join();
+        }
     }
-  }
 }
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 82751b3dd..76c56ec76 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -1,21 +1,21 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client-extras-guava</artifactId>
-  <name>Asynchronous Http Client Guava Extras</name>
-  <description>
-    The Async Http Client Guava Extras.
-  </description>
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-extras-guava</artifactId>
+    <name>Asynchronous Http Client Guava Extras</name>
+    <description>
+        The Async Http Client Guava Extras.
+    </description>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>14.0.1</version>
-    </dependency>
-  </dependencies>
+    <dependencies>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>14.0.1</version>
+        </dependency>
+    </dependencies>
 </project>
\ No newline at end of file
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
index 5138a224e..50807a4f4 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/ListenableFutureAdapter.java
@@ -21,38 +21,38 @@
 
 public final class ListenableFutureAdapter {
 
-  /**
-   * @param future an AHC ListenableFuture
-   * @param <V>    the Future's value type
-   * @return a Guava ListenableFuture
-   */
-  public static <V> com.google.common.util.concurrent.ListenableFuture<V> asGuavaFuture(final ListenableFuture<V> future) {
-
-    return new com.google.common.util.concurrent.ListenableFuture<V>() {
-
-      public boolean cancel(boolean mayInterruptIfRunning) {
-        return future.cancel(mayInterruptIfRunning);
-      }
-
-      public V get() throws InterruptedException, ExecutionException {
-        return future.get();
-      }
-
-      public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        return future.get(timeout, unit);
-      }
-
-      public boolean isCancelled() {
-        return future.isCancelled();
-      }
-
-      public boolean isDone() {
-        return future.isDone();
-      }
-
-      public void addListener(final Runnable runnable, final Executor executor) {
-        future.addListener(runnable, executor);
-      }
-    };
-  }
+    /**
+     * @param future an AHC ListenableFuture
+     * @param <V> the Future's value type
+     * @return a Guava ListenableFuture
+     */
+    public static <V> com.google.common.util.concurrent.ListenableFuture<V> asGuavaFuture(final ListenableFuture<V> future) {
+
+        return new com.google.common.util.concurrent.ListenableFuture<V>() {
+
+            public boolean cancel(boolean mayInterruptIfRunning) {
+                return future.cancel(mayInterruptIfRunning);
+            }
+
+            public V get() throws InterruptedException, ExecutionException {
+                return future.get();
+            }
+
+            public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+                return future.get(timeout, unit);
+            }
+
+            public boolean isCancelled() {
+                return future.isCancelled();
+            }
+
+            public boolean isDone() {
+                return future.isDone();
+            }
+
+            public void addListener(final Runnable runnable, final Executor executor) {
+                future.addListener(runnable, executor);
+            }
+        };
+    }
 }
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
index 102b03df8..3da30e110 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -1,10 +1,15 @@
 package org.asynchttpclient.extras.guava;
 
-import com.google.common.util.concurrent.RateLimiter;
-import org.asynchttpclient.filter.*;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ReleasePermitOnComplete;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.filter.ThrottleRequestFilter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.util.concurrent.RateLimiter;
+
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
@@ -12,79 +17,79 @@
  * A {@link org.asynchttpclient.filter.RequestFilter} that extends the capability of
  * {@link ThrottleRequestFilter} by allowing rate limiting per second in addition to the
  * number of concurrent connections.
- * <p>
- * The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For
- * example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
- * it will only spend another 500 ms waiting for the rate limiter.
+ * 
+ *  The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For 
+ *  example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
+ *  it will only spend another 500 ms waiting for the rate limiter.
  */
 public class RateLimitedThrottleRequestFilter implements RequestFilter {
-  private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
-  private final Semaphore available;
-  private final int maxWaitMs;
-  private final RateLimiter rateLimiter;
-
-  public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
-    this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
-  }
-
-  public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
-    this.maxWaitMs = maxWaitMs;
-    this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
-    available = new Semaphore(maxConnections, true);
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-    try {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Current Throttling Status {}", available.availablePermits());
-      }
-
-      long startOfWait = System.currentTimeMillis();
-      attemptConcurrencyPermitAcquistion(ctx);
-
-      attemptRateLimitedPermitAcquistion(ctx, startOfWait);
-    } catch (InterruptedException e) {
-      throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
+    private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
+    private final Semaphore available;
+    private final int maxWaitMs;
+    private final RateLimiter rateLimiter;
+
+    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
+        this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
+    }
+
+    public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
+        this.maxWaitMs = maxWaitMs;
+        this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
+        available = new Semaphore(maxConnections, true);
     }
 
-    return new FilterContext.FilterContextBuilder<>(ctx)
-            .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
-            .build();
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Current Throttling Status {}", available.availablePermits());
+            }
 
-  private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
-    long wait = getMillisRemainingInMaxWait(startOfWait);
+            long startOfWait = System.currentTimeMillis();
+            attemptConcurrencyPermitAcquistion(ctx);
 
-    if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
-      throw new FilterException(String.format("Wait for rate limit exceeded during processing Request %s with AsyncHandler %s",
-              ctx.getRequest(), ctx.getAsyncHandler()));
+            attemptRateLimitedPermitAcquistion(ctx, startOfWait);
+        } catch (InterruptedException e) {
+            throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
+        }
+
+        return new FilterContext.FilterContextBuilder<>(ctx)
+              .asyncHandler(ReleasePermitOnComplete.wrap(ctx.getAsyncHandler(), available))
+              .build();
     }
-  }
 
-  private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException, FilterException {
-    if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
-      throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
-              ctx.getAsyncHandler()));
+    private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
+        long wait = getMillisRemainingInMaxWait(startOfWait);
+
+        if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
+            throw new FilterException(String.format("Wait for rate limit exceeded during processing Request %s with AsyncHandler %s",
+                    ctx.getRequest(), ctx.getAsyncHandler()));
+        }
     }
-  }
-
-  private long getMillisRemainingInMaxWait(long startOfWait) {
-    int MINUTE_IN_MILLIS = 60000;
-    long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
-    long nonNegativeDuration = Math.max(durationLeft, 0);
-
-    // have to reduce the duration because there is a boundary case inside the Guava
-    // rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
-    // limiter's internal calculations can exceed Long.MAX_VALUE resulting in a
-    // negative number which causes the tryAcquire() method to fail unexpectedly
-    if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
-      return nonNegativeDuration - MINUTE_IN_MILLIS;
+
+    private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException, FilterException {
+        if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
+            throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
+                    ctx.getAsyncHandler()));
+        }
     }
 
-    return nonNegativeDuration;
-  }
+    private long getMillisRemainingInMaxWait(long startOfWait) {
+        int MINUTE_IN_MILLIS = 60000;
+        long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
+        long nonNegativeDuration = Math.max(durationLeft, 0);
+
+        // have to reduce the duration because there is a boundary case inside the Guava
+        // rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
+        // limiter's internal calculations can exceed Long.MAX_VALUE resulting in a 
+        // negative number which causes the tryAcquire() method to fail unexpectedly
+        if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
+            return nonNegativeDuration - MINUTE_IN_MILLIS;
+        }
+
+        return nonNegativeDuration;
+    }
 }
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 7641f02a6..1734d2b3d 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,16 +18,16 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
+    <version>2.1.0-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
   <description>The Async Http Client jDeffered Extras.</description>
   <dependencies>
-    <dependency>
-      <groupId>org.jdeferred</groupId>
-      <artifactId>jdeferred-core</artifactId>
-      <version>1.2.6</version>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>org.jdeferred</groupId>
+            <artifactId>jdeferred-core</artifactId>
+            <version>1.2.4</version>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
index 968a5bd01..ce4500799 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,41 +15,45 @@
  */
 package org.asynchttpclient.extras.jdeferred;
 
-import org.asynchttpclient.*;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Response;
 import org.jdeferred.Promise;
 import org.jdeferred.impl.DeferredObject;
 
 import java.io.IOException;
 
 public class AsyncHttpDeferredObject extends DeferredObject<Response, Throwable, HttpProgress> {
-  public AsyncHttpDeferredObject(BoundRequestBuilder builder) {
-    builder.execute(new AsyncCompletionHandler<Void>() {
-      @Override
-      public Void onCompleted(Response response) {
-        AsyncHttpDeferredObject.this.resolve(response);
-        return null;
-      }
+    public AsyncHttpDeferredObject(BoundRequestBuilder builder) throws IOException {
+        builder.execute(new AsyncCompletionHandler<Void>() {
+            @Override
+            public Void onCompleted(Response response) throws Exception {
+                AsyncHttpDeferredObject.this.resolve(response);
+                return null;
+            }
 
-      @Override
-      public void onThrowable(Throwable t) {
-        AsyncHttpDeferredObject.this.reject(t);
-      }
+            @Override
+            public void onThrowable(Throwable t) {
+                AsyncHttpDeferredObject.this.reject(t);
+            }
 
-      @Override
-      public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
-        AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
-        return super.onContentWriteProgress(amount, current, total);
-      }
+            @Override
+            public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
+                AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
+                return super.onContentWriteProgress(amount, current, total);
+            }
 
-      @Override
-      public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-        AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
-        return super.onBodyPartReceived(content);
-      }
-    });
-  }
+            @Override
+            public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
+                return super.onBodyPartReceived(content);
+            }
+        });
+    }
 
-  public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) {
-    return new AsyncHttpDeferredObject(builder).promise();
-  }
+    public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) throws IOException {
+        return new AsyncHttpDeferredObject(builder).promise();
+    }
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
index 13fd1d3c7..b07a76d3f 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/ContentWriteProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,30 +16,30 @@
 package org.asynchttpclient.extras.jdeferred;
 
 public class ContentWriteProgress implements HttpProgress {
-  private final long amount;
-  private final long current;
-  private final long total;
+    private final long amount;
+    private final long current;
+    private final long total;
 
-  public ContentWriteProgress(long amount, long current, long total) {
-    this.amount = amount;
-    this.current = current;
-    this.total = total;
-  }
+    public ContentWriteProgress(long amount, long current, long total) {
+        this.amount = amount;
+        this.current = current;
+        this.total = total;
+    }
 
-  public long getAmount() {
-    return amount;
-  }
+    public long getAmount() {
+        return amount;
+    }
 
-  public long getCurrent() {
-    return current;
-  }
+    public long getCurrent() {
+        return current;
+    }
 
-  public long getTotal() {
-    return total;
-  }
+    public long getTotal() {
+        return total;
+    }
 
-  @Override
-  public String toString() {
-    return "ContentWriteProgress [amount=" + amount + ", current=" + current + ", total=" + total + "]";
-  }
+    @Override
+    public String toString() {
+        return "ContentWriteProgress [amount=" + amount + ", current=" + current + ", total=" + total + "]";
+    }
 }
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
index d757d6422..8ff478856 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
index 6263812d5..7137c5469 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/HttpResponseBodyPartProgress.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,18 +18,18 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 
 public class HttpResponseBodyPartProgress implements HttpProgress {
-  private final HttpResponseBodyPart part;
+    private final HttpResponseBodyPart part;
 
-  public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
-    this.part = part;
-  }
+    public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
+        this.part = part;
+    }
 
-  public HttpResponseBodyPart getPart() {
-    return part;
-  }
+    public HttpResponseBodyPart getPart() {
+        return part;
+    }
 
-  @Override
-  public String toString() {
-    return "HttpResponseBodyPartProgress [part=" + part + "]";
-  }
+    @Override
+    public String toString() {
+        return "HttpResponseBodyPartProgress [part=" + part + "]";
+    }
 }
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
index c9fd72521..f684b7666 100644
--- a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
+++ b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2013 Ray Tsang
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -15,6 +15,13 @@
  */
 package org.asynchttpclient.extra;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.extras.jdeferred.AsyncHttpDeferredObject;
@@ -25,76 +32,68 @@
 import org.jdeferred.impl.DefaultDeferredManager;
 import org.jdeferred.multiple.MultipleResults;
 
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
 public class AsyncHttpTest {
-  protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
+    protected DefaultDeferredManager deferredManager = new DefaultDeferredManager();
 
-  public void testPromiseAdapter() throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicInteger successCount = new AtomicInteger();
-    final AtomicInteger progressCount = new AtomicInteger();
+    public void testPromiseAdapter() throws IOException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicInteger successCount = new AtomicInteger();
+        final AtomicInteger progressCount = new AtomicInteger();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-      p1.done(new DoneCallback<Response>() {
-        @Override
-        public void onDone(Response response) {
-          try {
-            assertEquals(response.getStatusCode(), 200);
-            successCount.incrementAndGet();
-          } finally {
-            latch.countDown();
-          }
-        }
-      }).progress(new ProgressCallback<HttpProgress>() {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
+            p1.done(new DoneCallback<Response>() {
+                @Override
+                public void onDone(Response response) {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        successCount.incrementAndGet();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            }).progress(new ProgressCallback<HttpProgress>() {
 
-        @Override
-        public void onProgress(HttpProgress progress) {
-          progressCount.incrementAndGet();
-        }
-      });
+                @Override
+                public void onProgress(HttpProgress progress) {
+                    progressCount.incrementAndGet();
+                }
+            });
 
-      latch.await();
-      assertTrue(progressCount.get() > 0);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+            latch.await();
+            assertTrue(progressCount.get() > 0);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 
-  public void testMultiplePromiseAdapter() throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicInteger successCount = new AtomicInteger();
+    public void testMultiplePromiseAdapter() throws IOException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicInteger successCount = new AtomicInteger();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
-      Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
-      AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://gatling.io"));
+            Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
+            AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
 
-      deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
-        @Override
-        public void onDone(MultipleResults result) {
-          try {
-            assertEquals(result.size(), 3);
-            assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
-            assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
-            assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
-            successCount.incrementAndGet();
-          } finally {
-            latch.countDown();
-          }
-        }
-      });
-      latch.await();
+            deferredManager.when(p1, p2, deferredRequest).then(new DoneCallback<MultipleResults>() {
+                @Override
+                public void onDone(MultipleResults result) {
+                    try {
+                        assertEquals(result.size(), 3);
+                        assertEquals(Response.class.cast(result.get(0).getResult()).getStatusCode(), 200);
+                        assertEquals(Response.class.cast(result.get(1).getResult()).getStatusCode(), 200);
+                        assertEquals(Response.class.cast(result.get(2).getResult()).getStatusCode(), 200);
+                        successCount.incrementAndGet();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            });
+            latch.await();
 
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 }
diff --git a/extras/pom.xml b/extras/pom.xml
index 7efbc75e4..63af14a83 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -1,40 +1,39 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-project</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client-extras-parent</artifactId>
-  <name>Asynchronous Http Client Extras Parent</name>
-  <packaging>pom</packaging>
-  <description>
-    The Async Http Client extras library parent.
-  </description>
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-project</artifactId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <name>Asynchronous Http Client Extras Parent</name>
+    <packaging>pom</packaging>
+    <description>
+        The Async Http Client extras library parent.
+    </description>
 
-  <modules>
-    <module>guava</module>
-    <module>jdeferred</module>
-    <module>registry</module>
-    <module>rxjava</module>
-    <module>rxjava2</module>
-    <module>simple</module>
-    <module>retrofit2</module>
-    <module>typesafeconfig</module>
-  </modules>
+    <modules>
+        <module>guava</module>
+        <module>jdeferred</module>
+        <module>registry</module>
+        <module>rxjava</module>
+        <module>rxjava2</module>
+        <module>simple</module>
+        <module>retrofit2</module>
+    </modules>
 
-  <dependencies>
-    <dependency>
-      <groupId>org.asynchttpclient</groupId>
-      <artifactId>async-http-client</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.asynchttpclient</groupId>
-      <artifactId>async-http-client</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-      <classifier>tests</classifier>
-    </dependency>
-  </dependencies>
+    <dependencies>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+            <classifier>tests</classifier>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index e5044af65..49d0318db 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -1,13 +1,13 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client-extras-registry</artifactId>
-  <name>Asynchronous Http Client Registry Extras</name>
-  <description>
-    The Async Http Client Registry Extras.
-  </description>
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-extras-parent</artifactId>
+		<version>2.1.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-extras-registry</artifactId>
+	<name>Asynchronous Http Client Registry Extras</name>
+	<description>
+        The Async Http Client Registry Extras.
+    </description>
 </project>
\ No newline at end of file
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 1d56b3b96..941208730 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,17 +12,18 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 
 import java.lang.reflect.Constructor;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
-import static org.asynchttpclient.Dsl.asyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * The AsyncHttpClientFactory returns back an instance of AsyncHttpClient. The
@@ -39,51 +40,51 @@
  */
 public class AsyncHttpClientFactory {
 
-  public static final Logger logger = LoggerFactory.getLogger(AsyncHttpClientFactory.class);
-  private static Class<AsyncHttpClient> asyncHttpClientImplClass = null;
-  private static volatile boolean instantiated = false;
-  private static Lock lock = new ReentrantLock();
+    private static Class<AsyncHttpClient> asyncHttpClientImplClass = null;
+    private static volatile boolean instantiated = false;
+    public static final Logger logger = LoggerFactory.getLogger(AsyncHttpClientFactory.class);
+    private static Lock lock = new ReentrantLock();
 
-  public static AsyncHttpClient getAsyncHttpClient() {
+    public static AsyncHttpClient getAsyncHttpClient() {
 
-    try {
-      if (attemptInstantiation())
-        return asyncHttpClientImplClass.newInstance();
-    } catch (InstantiationException e) {
-      throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
-              + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
-    } catch (IllegalAccessException e) {
-      throw new AsyncHttpClientImplException("Unable to find the class specified by system property : "
-              + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+        try {
+            if (attemptInstantiation())
+                return asyncHttpClientImplClass.newInstance();
+        } catch (InstantiationException e) {
+            throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
+                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+        } catch (IllegalAccessException e) {
+            throw new AsyncHttpClientImplException("Unable to find the class specified by system property : "
+                    + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
+        }
+        return asyncHttpClient();
     }
-    return asyncHttpClient();
-  }
 
-  public static AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-    if (attemptInstantiation()) {
-      try {
-        Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpClientConfig.class);
-        return constructor.newInstance(config);
-      } catch (Exception e) {
-        throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
-                + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
-      }
+    public static AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        if (attemptInstantiation()) {
+            try {
+                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(AsyncHttpClientConfig.class);
+                return constructor.newInstance(config);
+            } catch (Exception e) {
+                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
+                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
+            }
+        }
+        return asyncHttpClient(config);
     }
-    return asyncHttpClient(config);
-  }
 
-  private static boolean attemptInstantiation() {
-    if (!instantiated) {
-      lock.lock();
-      try {
+    private static boolean attemptInstantiation() {
         if (!instantiated) {
-          asyncHttpClientImplClass = AsyncImplHelper.getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-          instantiated = true;
+            lock.lock();
+            try {
+                if (!instantiated) {
+                    asyncHttpClientImplClass = AsyncImplHelper.getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+                    instantiated = true;
+                }
+            } finally {
+                lock.unlock();
+            }
         }
-      } finally {
-        lock.unlock();
-      }
+        return asyncHttpClientImplClass != null;
     }
-    return asyncHttpClientImplClass != null;
-  }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
index 1f57f95c6..f59bf0698 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -15,11 +15,11 @@
 @SuppressWarnings("serial")
 public class AsyncHttpClientImplException extends RuntimeException {
 
-  public AsyncHttpClientImplException(String msg) {
-    super(msg);
-  }
+    public AsyncHttpClientImplException(String msg) {
+        super(msg);
+    }
 
-  public AsyncHttpClientImplException(String msg, Exception e) {
-    super(msg, e);
-  }
+    public AsyncHttpClientImplException(String msg, Exception e) {
+        super(msg, e);
+    }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
index 99279b52e..60fa3170d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -18,64 +18,64 @@
 
 public interface AsyncHttpClientRegistry {
 
-  /**
-   * Returns back the AsyncHttpClient associated with this name
-   *
-   * @param name the name of the client instance in the registry
-   * @return the client
-   */
-  AsyncHttpClient get(String name);
+    /**
+     * Returns back the AsyncHttpClient associated with this name
+     * 
+     * @param name the name of the client instance in the registry
+     * @return the client
+     */
+    AsyncHttpClient get(String name);
 
-  /**
-   * Registers this instance of AsyncHttpClient with this name and returns
-   * back a null if an instance with the same name never existed but will return back the
-   * previous instance if there was another instance registered with the same
-   * name and has been replaced by this one.
-   *
-   * @param name   the name of the client instance in the registry
-   * @param client the client instance
-   * @return the previous instance
-   */
-  AsyncHttpClient addOrReplace(String name, AsyncHttpClient client);
+    /**
+     * Registers this instance of AsyncHttpClient with this name and returns
+     * back a null if an instance with the same name never existed but will return back the
+     * previous instance if there was another instance registered with the same
+     * name and has been replaced by this one.
+     * 
+     * @param name the name of the client instance in the registry
+     * @param client the client instance
+     * @return the previous instance
+     */
+    AsyncHttpClient addOrReplace(String name, AsyncHttpClient client);
 
-  /**
-   * Will register only if an instance with this name doesn't exist and if it
-   * does exist will not replace this instance and will return false. Use it in the
-   * following way:
-   * <blockquote><pre>
-   *      AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
-   *      if(!AsyncHttpClientRegistryImpl.getInstance().registerIfNew(“MyAHC”,ahc)){
-   *          //An instance with this name is already registered so close ahc
-   *          ahc.close();
-   *          //and do necessary cleanup
-   *      }
-   * </pre></blockquote>
-   *
-   * @param name   the name of the client instance in the registry
-   * @param client the client instance
-   * @return true is the client was indeed registered
-   */
+    /**
+     * Will register only if an instance with this name doesn't exist and if it
+     * does exist will not replace this instance and will return false. Use it in the 
+     * following way:
+     * <blockquote><pre>
+     *      AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();      
+     *      if(!AsyncHttpClientRegistryImpl.getInstance().registerIfNew(“MyAHC”,ahc)){
+     *          //An instance with this name is already registered so close ahc 
+     *          ahc.close(); 
+     *          //and do necessary cleanup
+     *      }
+     * </pre></blockquote>
+     * 
+     * @param name the name of the client instance in the registry
+     * @param client the client instance
+     * @return true is the client was indeed registered
+     */
 
-  boolean registerIfNew(String name, AsyncHttpClient client);
+    boolean registerIfNew(String name, AsyncHttpClient client);
 
-  /**
-   * Remove the instance associate with this name
-   *
-   * @param name the name of the client instance in the registry
-   * @return true is the client was indeed unregistered
-   */
+    /**
+     * Remove the instance associate with this name
+     * 
+     * @param name the name of the client instance in the registry
+     * @return true is the client was indeed unregistered
+     */
 
-  boolean unregister(String name);
+    boolean unregister(String name);
 
-  /**
-   * @return all registered names
-   */
+    /**
+     * @return all registered names
+     */
 
-  Set<String> getAllRegisteredNames();
+    Set<String> getAllRegisteredNames();
 
-  /**
-   * Removes all instances from this registry.
-   */
+    /**
+     * Removes all instances from this registry.
+     */
 
-  void clearAllInstances();
+    void clearAllInstances();
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 48f72f881..f252a8e8d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -22,98 +22,97 @@
 
 public class AsyncHttpClientRegistryImpl implements AsyncHttpClientRegistry {
 
-  private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<>();
-  private static volatile AsyncHttpClientRegistry _instance;
-  private static Lock lock = new ReentrantLock();
+    private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<>();
+    private static volatile AsyncHttpClientRegistry _instance;
+    private static Lock lock = new ReentrantLock();
 
-  /**
-   * Returns a singleton instance of AsyncHttpClientRegistry
-   *
-   * @return the current instance
-   */
-  public static AsyncHttpClientRegistry getInstance() {
-    if (_instance == null) {
-      lock.lock();
-      try {
+    /**
+     * Returns a singleton instance of AsyncHttpClientRegistry
+     * @return the current instance
+     */
+    public static AsyncHttpClientRegistry getInstance() {
         if (_instance == null) {
-          Class<?> asyncHttpClientRegistryImplClass = AsyncImplHelper
-                  .getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-          if (asyncHttpClientRegistryImplClass != null)
-            _instance = (AsyncHttpClientRegistry) asyncHttpClientRegistryImplClass.newInstance();
-          else
-            _instance = new AsyncHttpClientRegistryImpl();
+            lock.lock();
+            try {
+                if (_instance == null) {
+                    Class<?> asyncHttpClientRegistryImplClass = AsyncImplHelper
+                            .getAsyncImplClass(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+                    if (asyncHttpClientRegistryImplClass != null)
+                        _instance = (AsyncHttpClientRegistry) asyncHttpClientRegistryImplClass.newInstance();
+                    else
+                        _instance = new AsyncHttpClientRegistryImpl();
+                }
+            } catch (InstantiationException | IllegalAccessException e) {
+                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
+            } finally {
+                lock.unlock();
+            }
         }
-      } catch (InstantiationException | IllegalAccessException e) {
-        throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
-      } finally {
-        lock.unlock();
-      }
+        return _instance;
     }
-    return _instance;
-  }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.asynchttpclient.IAsyncHttpClientRegistry#get(java.lang.String)
-   */
-  @Override
-  public AsyncHttpClient get(String clientName) {
-    return asyncHttpClientMap.get(clientName);
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#get(java.lang.String)
+     */
+    @Override
+    public AsyncHttpClient get(String clientName) {
+        return asyncHttpClientMap.get(clientName);
+    }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see
-   * org.asynchttpclient.IAsyncHttpClientRegistry#register(java.lang.String,
-   * org.asynchttpclient.AsyncHttpClient)
-   */
-  @Override
-  public AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc) {
-    return asyncHttpClientMap.put(name, ahc);
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#register(java.lang.String,
+     * org.asynchttpclient.AsyncHttpClient)
+     */
+    @Override
+    public AsyncHttpClient addOrReplace(String name, AsyncHttpClient ahc) {
+        return asyncHttpClientMap.put(name, ahc);
+    }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see
-   * org.asynchttpclient.IAsyncHttpClientRegistry#registerIfNew(java.lang.
-   * String, org.asynchttpclient.AsyncHttpClient)
-   */
-  @Override
-  public boolean registerIfNew(String name, AsyncHttpClient ahc) {
-    return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#registerIfNew(java.lang.
+     * String, org.asynchttpclient.AsyncHttpClient)
+     */
+    @Override
+    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
+        return asyncHttpClientMap.putIfAbsent(name, ahc) == null;
+    }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see
-   * org.asynchttpclient.IAsyncHttpClientRegistry#unRegister(java.lang.String)
-   */
-  @Override
-  public boolean unregister(String name) {
-    return asyncHttpClientMap.remove(name) != null;
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.asynchttpclient.IAsyncHttpClientRegistry#unRegister(java.lang.String)
+     */
+    @Override
+    public boolean unregister(String name) {
+        return asyncHttpClientMap.remove(name) != null;
+    }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.asynchttpclient.IAsyncHttpClientRegistry#getAllRegisteredNames()
-   */
-  @Override
-  public Set<String> getAllRegisteredNames() {
-    return asyncHttpClientMap.keySet();
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#getAllRegisteredNames()
+     */
+    @Override
+    public Set<String> getAllRegisteredNames() {
+        return asyncHttpClientMap.keySet();
+    }
 
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.asynchttpclient.IAsyncHttpClientRegistry#clearAllInstances()
-   */
-  @Override
-  public void clearAllInstances() {
-    asyncHttpClientMap.clear();
-  }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.asynchttpclient.IAsyncHttpClientRegistry#clearAllInstances()
+     */
+    @Override
+    public void clearAllInstances() {
+        asyncHttpClientMap.clear();
+    }
 }
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
index 1099da6bf..a918bffdc 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,43 +21,44 @@
 
 public class AsyncImplHelper {
 
-  public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
-  public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
+    public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
+    public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
 
-  /*
-   * Returns the class specified by either a system property or a properties
-   * file as the class to instantiated for the AsyncHttpClient. Returns null
-   * if property is not found and throws an AsyncHttpClientImplException if
-   * the specified class couldn't be created.
-   */
-  public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
-    String asyncHttpClientImplClassName = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(propertyName);
-    if (asyncHttpClientImplClassName != null) {
-      return AsyncImplHelper.getClass(asyncHttpClientImplClassName);
+    /*
+     * Returns the class specified by either a system property or a properties
+     * file as the class to instantiated for the AsyncHttpClient. Returns null
+     * if property is not found and throws an AsyncHttpClientImplException if
+     * the specified class couldn't be created.
+     */
+    public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
+        String asyncHttpClientImplClassName = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(propertyName);
+        if (asyncHttpClientImplClassName != null) {
+            Class<AsyncHttpClient> asyncHttpClientImplClass = AsyncImplHelper.getClass(asyncHttpClientImplClassName);
+            return asyncHttpClientImplClass;
+        }
+        return null;
     }
-    return null;
-  }
 
-  private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
-    try {
-      return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<AsyncHttpClient>>() {
-        @SuppressWarnings("unchecked")
-        public Class<AsyncHttpClient> run() throws ClassNotFoundException {
-          ClassLoader cl = Thread.currentThread().getContextClassLoader();
-          if (cl != null)
-            try {
-              return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
-            } catch (ClassNotFoundException e) {
-              AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName + " in thread context classpath " + "checking system class path next",
-                      e);
-            }
+    private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
+        try {
+            return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<AsyncHttpClient>>() {
+                @SuppressWarnings("unchecked")
+                public Class<AsyncHttpClient> run() throws ClassNotFoundException {
+                    ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                    if (cl != null)
+                        try {
+                            return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+                        } catch (ClassNotFoundException e) {
+                            AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName + " in thread context classpath " + "checking system class path next",
+                                    e);
+                        }
 
-          cl = ClassLoader.getSystemClassLoader();
-          return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+                    cl = ClassLoader.getSystemClassLoader();
+                    return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
+                }
+            });
+        } catch (PrivilegedActionException e) {
+            throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : " + e.getMessage(), e);
         }
-      });
-    } catch (PrivilegedActionException e) {
-      throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : " + e.getMessage(), e);
     }
-  }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
index e9b3320a9..bf2b166d0 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,12 +12,17 @@
  */
 package org.asynchttpclient.extras.registry;
 
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+
 import junit.extensions.PA;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.DefaultAsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.asynchttpclient.test.EchoHandler;
+import static org.asynchttpclient.test.TestUtils.*;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.testng.Assert;
@@ -26,190 +31,185 @@
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
+public abstract class AbstractAsyncHttpClientFactoryTest {
 
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+    public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
+    public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
+    public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
 
-public abstract class AbstractAsyncHttpClientFactoryTest {
+    private Server server;
+    private int port;
+
+    @BeforeMethod
+    public void setUp() {
+        PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
+        PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+        AsyncHttpClientConfigHelper.reloadProperties();
+    }
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpBeforeTest() throws Exception {
+        server = new Server();
+        ServerConnector connector = addHttpConnector(server);
+        server.setHandler(new EchoHandler());
+        server.start();
+        port = connector.getLocalPort();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDown() throws Exception {
+        setUp();
+        if (server != null)
+            server.stop();
+    }
+
+    /**
+     * If the property is not found via the system property or properties file the default instance of AsyncHttpClient should be returned.
+     */
+    // ================================================================================================================
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClient() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientConfig() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientProvider() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
+    }
 
-  public static final String TEST_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.TestAsyncHttpClient";
-  public static final String BAD_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.BadAsyncHttpClient";
-  public static final String NON_EXISTENT_CLIENT_CLASS_NAME = "org.asynchttpclient.extras.registry.NonExistentAsyncHttpClient";
-
-  private Server server;
-  private int port;
-
-  @BeforeMethod
-  public void setUp() {
-    PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
-    PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
-    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-    AsyncHttpClientConfigHelper.reloadProperties();
-  }
-
-  @BeforeClass(alwaysRun = true)
-  public void setUpBeforeTest() throws Exception {
-    server = new Server();
-    ServerConnector connector = addHttpConnector(server);
-    server.setHandler(new EchoHandler());
-    server.start();
-    port = connector.getLocalPort();
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDown() throws Exception {
-    setUp();
-    if (server != null)
-      server.stop();
-  }
-
-  /**
-   * If the property is not found via the system property or properties file the default instance of AsyncHttpClient should be returned.
-   */
-  // ================================================================================================================
-  @Test
-  public void testGetAsyncHttpClient() throws Exception {
-    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-      assertClientWorks(asyncHttpClient);
-    }
-  }
-
-  @Test
-  public void testGetAsyncHttpClientConfig() throws Exception {
-    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-      assertClientWorks(asyncHttpClient);
-    }
-  }
-
-  @Test
-  public void testGetAsyncHttpClientProvider() throws Exception {
-    try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-      assertClientWorks(asyncHttpClient);
-    }
-  }
-
-  // ==================================================================================================================================
-
-  /**
-   * If the class is specified via a system property then that class should be returned
-   */
-  // ===================================================================================================================================
-  @Test
-  public void testFactoryWithSystemProperty() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-    }
-  }
-
-  @Test
-  public void testGetAsyncHttpClientConfigWithSystemProperty() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-    }
-  }
-
-  @Test
-  public void testGetAsyncHttpClientProviderWithSystemProperty() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
-    }
-  }
-
-  // ===================================================================================================================================
-
-  /**
-   * If any of the constructors of the class fail then a AsyncHttpClientException is thrown.
-   */
-  // ===================================================================================================================================
-  @Test(expectedExceptions = BadAsyncHttpClientException.class)
-  public void testFactoryWithBadAsyncHttpClient() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
-    }
-  }
-
-  @Test
-  public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      //
-    } catch (AsyncHttpClientImplException e) {
-      assertException(e);
-    }
-    // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-  }
-
-  @Test
-  public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      //
-    } catch (AsyncHttpClientImplException e) {
-      assertException(e);
-    }
-    // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-  }
-
-  // ===================================================================================================================================
-
-  /*
-   * If the system property exists instantiate the class else if the class is not found throw an AsyncHttpClientException.
-   */
-  @Test(expectedExceptions = AsyncHttpClientImplException.class)
-  public void testFactoryWithNonExistentAsyncHttpClient() throws IOException {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      //
-    }
-    Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-  }
-
-  /**
-   * If property is specified but the class can’t be created or found for any reason subsequent calls should throw an AsyncClientException.
-   */
-  @Test(expectedExceptions = AsyncHttpClientImplException.class)
-  public void testRepeatedCallsToBadAsyncHttpClient() throws IOException {
-    boolean exceptionCaught = false;
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      //
-    } catch (AsyncHttpClientImplException e) {
-      exceptionCaught = true;
-    }
-    Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
-    exceptionCaught = false;
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      //
-    } catch (AsyncHttpClientImplException e) {
-      exceptionCaught = true;
-    }
-    Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
-  }
-
-  private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
-    Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
-    Assert.assertEquals(200, response.getStatusCode());
-  }
-
-  private void assertException(AsyncHttpClientImplException e) {
-    InvocationTargetException t = (InvocationTargetException) e.getCause();
-    Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
-  }
+    // ==================================================================================================================================
+
+    /**
+     * If the class is specified via a system property then that class should be returned
+     */
+    // ===================================================================================================================================
+    @Test(groups = "standalone")
+    public void testFactoryWithSystemProperty() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientConfigWithSystemProperty() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientProviderWithSystemProperty() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(ahc.getClass().equals(TestAsyncHttpClient.class));
+        }
+    }
+
+    // ===================================================================================================================================
+
+    /**
+     * If any of the constructors of the class fail then a AsyncHttpClientException is thrown.
+     */
+    // ===================================================================================================================================
+    @Test(groups = "standalone", expectedExceptions = BadAsyncHttpClientException.class)
+    public void testFactoryWithBadAsyncHttpClient() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            //
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            //
+        } catch (AsyncHttpClientImplException e) {
+            assertException(e);
+        }
+        // Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    // ===================================================================================================================================
+
+    /*
+     * If the system property exists instantiate the class else if the class is not found throw an AsyncHttpClientException.
+     */
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testFactoryWithNonExistentAsyncHttpClient() throws IOException {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            //
+        }
+        Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
+    }
+
+    /**
+     * If property is specified but the class can’t be created or found for any reason subsequent calls should throw an AsyncClientException.
+     */
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testRepeatedCallsToBadAsyncHttpClient() throws IOException {
+        boolean exceptionCaught = false;
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            //
+        } catch (AsyncHttpClientImplException e) {
+            exceptionCaught = true;
+        }
+        Assert.assertTrue(exceptionCaught, "Didn't catch exception the first time");
+        exceptionCaught = false;
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            //
+        } catch (AsyncHttpClientImplException e) {
+            exceptionCaught = true;
+        }
+        Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
+    }
+
+    private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
+        Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
+        Assert.assertEquals(200, response.getStatusCode());
+    }
+
+    private void assertException(AsyncHttpClientImplException e) {
+        InvocationTargetException t = (InvocationTargetException) e.getCause();
+        Assert.assertTrue(t.getCause() instanceof BadAsyncHttpClientException);
+    }
 
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
index eeebabc7b..e546c6899 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,113 +12,118 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import junit.extensions.PA;
+import java.io.IOException;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
+import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
+import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+import org.asynchttpclient.extras.registry.AsyncImplHelper;
 import org.testng.Assert;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
+import junit.extensions.PA;
 
 public class AsyncHttpClientRegistryTest {
 
-  private static final String TEST_AHC = "testAhc";
-
-  @BeforeMethod
-  public void setUp() {
-    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-    PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
-  }
-
-  @BeforeClass
-  public void setUpBeforeTest() {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
-  }
-
-  @AfterClass
-  public void tearDown() {
-    System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-  }
-
-  @Test
-  public void testGetAndRegister() throws IOException {
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-      Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+    private static final String TEST_AHC = "testAhc";
+
+    @BeforeMethod
+    public void setUp() {
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+        PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
+    }
+
+    @BeforeClass
+    public void setUpBeforeTest() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.TEST_CLIENT_CLASS_NAME);
+    }
+
+    @AfterClass
+    public void tearDown() {
+        System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
+    }
+
+    @Test(groups = "standalone")
+    public void testGetAndRegister() throws IOException {
+        try(AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+            Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+        }
     }
-  }
-
-  @Test
-  public void testDeRegister() throws IOException {
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-      Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
-      Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+
+    @Test(groups = "standalone")
+    public void testDeRegister() throws IOException {
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
+            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+            Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
+            Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+        }
     }
-  }
-
-  @Test
-  public void testRegisterIfNew() throws IOException {
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-        Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-        Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
-        Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
-        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
-      }
+
+    @Test(groups = "standalone")
+    public void testRegisterIfNew() throws IOException {
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+                Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+                Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC, ahc2));
+                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc);
+                Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc2));
+                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC) == ahc2);
+                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().registerIfNew(TEST_AHC + 1, ahc));
+                Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
+            }
+        }
     }
-  }
-
-  @Test
-  public void testClearAllInstances() throws IOException {
-    try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
-      try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-        try (AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient()) {
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
-          Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-          AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
-          Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
-          Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
+
+    @Test(groups = "standalone")
+    public void testClearAllInstances() throws IOException {
+        try (AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            try (AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+                try (AsyncHttpClient ahc3 = AsyncHttpClientFactory.getAsyncHttpClient()) {
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC, ahc));
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 2, ahc2));
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().addOrReplace(TEST_AHC + 3, ahc3));
+                    Assert.assertEquals(3, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+                    AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
+                    Assert.assertEquals(0, AsyncHttpClientRegistryImpl.getInstance().getAllRegisteredNames().size());
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 2));
+                    Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
+                }
+            }
         }
-      }
     }
-  }
-
-  @Test
-  public void testCustomAsyncHttpClientRegistry() {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
-    AsyncHttpClientConfigHelper.reloadProperties();
-    Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
-  }
-
-  @Test(expectedExceptions = AsyncHttpClientImplException.class)
-  public void testNonExistentAsyncHttpClientRegistry() {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    AsyncHttpClientRegistryImpl.getInstance();
-    Assert.fail("Should never have reached here");
-  }
-
-  @Test(expectedExceptions = AsyncHttpClientImplException.class)
-  public void testBadAsyncHttpClientRegistry() {
-    System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
-    AsyncHttpClientConfigHelper.reloadProperties();
-    AsyncHttpClientRegistryImpl.getInstance();
-    Assert.fail("Should never have reached here");
-  }
+
+    @Test(groups = "standalone")
+    public void testCustomAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
+        AsyncHttpClientConfigHelper.reloadProperties();
+        Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
+    }
+
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testNonExistentAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance();
+        Assert.fail("Should never have reached here");
+    }
+
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
+    public void testBadAsyncHttpClientRegistry() {
+        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
+        AsyncHttpClientConfigHelper.reloadProperties();
+        AsyncHttpClientRegistryImpl.getInstance();
+        Assert.fail("Should never have reached here");
+    }
 
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
index 138713b31..713887c98 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,126 +12,135 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.*;
-
 import java.util.function.Predicate;
 
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.ClientStats;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SignatureCalculator;
+
 public class BadAsyncHttpClient implements AsyncHttpClient {
 
-  public BadAsyncHttpClient() {
-    throw new BadAsyncHttpClientException("Because I am bad!!");
-  }
-
-  public BadAsyncHttpClient(AsyncHttpClientConfig config) {
-    throw new BadAsyncHttpClientException("Because I am bad!!");
-  }
-
-  public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-    throw new BadAsyncHttpClientException("Because I am bad!!");
-  }
-
-  @Override
-  public void close() {
-
-  }
-
-  @Override
-  public boolean isClosed() {
-    return false;
-  }
-
-  @Override
-  public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareGet(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareConnect(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareOptions(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareHead(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePost(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePut(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareDelete(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePatch(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareTrace(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(Request request) {
-    return null;
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-    return null;
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(Request request) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-    return null;
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-    return null;
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-    return null;
-  }
-
-  @Override
-  public ClientStats getClientStats() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public AsyncHttpClientConfig getConfig() {
-    return null;
-  }
+    public BadAsyncHttpClient() {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(AsyncHttpClientConfig config) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    public BadAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+        throw new BadAsyncHttpClientException("Because I am bad!!");
+    }
+
+    @Override
+    public void close() {
+
+    }
+
+    @Override
+    public boolean isClosed() {
+        return false;
+    }
+
+    @Override
+    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public ClientStats getClientStats() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return null;
+    }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
index cf5009c40..1aca098e8 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,10 +12,12 @@
  */
 package org.asynchttpclient.extras.registry;
 
+import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
+
 @SuppressWarnings("serial")
 public class BadAsyncHttpClientException extends AsyncHttpClientImplException {
 
-  public BadAsyncHttpClientException(String msg) {
-    super(msg);
-  }
+    public BadAsyncHttpClientException(String msg) {
+        super(msg);
+    }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
index 4a32bf217..b3d853de3 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,9 +12,11 @@
  */
 package org.asynchttpclient.extras.registry;
 
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+
 public class BadAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
 
-  private BadAsyncHttpClientRegistry() {
-    throw new RuntimeException("I am bad");
-  }
+    private BadAsyncHttpClientRegistry() {
+        throw new RuntimeException("I am bad");
+    }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
index be9ac5a5f..0e61c109f 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,122 +12,131 @@
  */
 package org.asynchttpclient.extras.registry;
 
-import org.asynchttpclient.*;
-
 import java.util.function.Predicate;
 
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.ClientStats;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SignatureCalculator;
+
 public class TestAsyncHttpClient implements AsyncHttpClient {
 
-  public TestAsyncHttpClient() {
-  }
-
-  public TestAsyncHttpClient(AsyncHttpClientConfig config) {
-  }
-
-  public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-  }
-
-  @Override
-  public void close() {
-  }
-
-  @Override
-  public boolean isClosed() {
-    return false;
-  }
-
-  @Override
-  public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareGet(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareConnect(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareOptions(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareHead(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePost(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePut(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareDelete(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder preparePatch(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareTrace(String url) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(Request request) {
-    return null;
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-    return null;
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(Request request) {
-    return null;
-  }
-
-  @Override
-  public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
-    return null;
-  }
-
-  @Override
-  public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
-    return null;
-  }
-
-  @Override
-  public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
-    return null;
-  }
-
-  @Override
-  public ClientStats getClientStats() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void flushChannelPoolPartitions(Predicate<Object> predicate) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public AsyncHttpClientConfig getConfig() {
-    return null;
-  }
+    public TestAsyncHttpClient() {
+    }
+
+    public TestAsyncHttpClient(AsyncHttpClientConfig config) {
+    }
+
+    public TestAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
+    }
+
+    @Override
+    public void close() {
+    }
+
+    @Override
+    public boolean isClosed() {
+        return false;
+    }
+
+    @Override
+    public AsyncHttpClient setSignatureCalculator(SignatureCalculator signatureCalculator) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareGet(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareConnect(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareOptions(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareHead(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePost(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePut(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareDelete(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder preparePatch(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareTrace(String url) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(Request request) {
+        return null;
+    }
+
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public ClientStats getClientStats() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void flushChannelPoolPartitions(Predicate<Object> predicate) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public AsyncHttpClientConfig getConfig() {
+        return null;
+    }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
index c17734d97..b9410737d 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.extras.registry;
 
+import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
+
 public class TestAsyncHttpClientRegistry extends AsyncHttpClientRegistryImpl {
 
 }
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index a1bd711e4..edba32b80 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -1,62 +1,62 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>async-http-client-extras-retrofit2</artifactId>
-  <name>Asynchronous Http Client Retrofit2 Extras</name>
-  <description>The Async Http Client Retrofit2 Extras.</description>
-
-  <properties>
-    <retrofit2.version>2.3.0</retrofit2.version>
-    <lombok.version>1.16.18</lombok.version>
-  </properties>
-
-  <dependencies>
-    <dependency>
-      <groupId>org.projectlombok</groupId>
-      <artifactId>lombok</artifactId>
-      <version>${lombok.version}</version>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.retrofit2</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${retrofit2.version}</version>
-    </dependency>
-
-    <!-- for tests -->
-    <dependency>
-      <groupId>com.squareup.retrofit2</groupId>
-      <artifactId>converter-scalars</artifactId>
-      <version>${retrofit2.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.retrofit2</groupId>
-      <artifactId>converter-jackson</artifactId>
-      <version>${retrofit2.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.retrofit2</groupId>
-      <artifactId>adapter-rxjava</artifactId>
-      <version>${retrofit2.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.retrofit2</groupId>
-      <artifactId>adapter-rxjava2</artifactId>
-      <version>${retrofit2.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <groupId>org.asynchttpclient</groupId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>async-http-client-extras-retrofit2</artifactId>
+    <name>Asynchronous Http Client Retrofit2 Extras</name>
+    <description>The Async Http Client Retrofit2 Extras.</description>
+
+    <properties>
+      <retrofit2.version>2.3.0</retrofit2.version>
+      <lombok.version>1.16.16</lombok.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.projectlombok</groupId>
+            <artifactId>lombok</artifactId>
+            <version>${lombok.version}</version>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.retrofit2</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${retrofit2.version}</version>
+        </dependency>
+
+        <!-- for tests -->
+        <dependency>
+            <groupId>com.squareup.retrofit2</groupId>
+            <artifactId>converter-scalars</artifactId>
+            <version>${retrofit2.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.retrofit2</groupId>
+            <artifactId>converter-jackson</artifactId>
+            <version>${retrofit2.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.retrofit2</groupId>
+            <artifactId>adapter-rxjava</artifactId>
+            <version>${retrofit2.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.retrofit2</groupId>
+            <artifactId>adapter-rxjava2</artifactId>
+            <version>${retrofit2.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
index 6ffd3f1a8..2dde47813 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
@@ -12,9 +12,22 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
-import lombok.*;
+import lombok.AccessLevel;
+import lombok.Builder;
+import lombok.Getter;
+import lombok.NonNull;
+import lombok.Singular;
+import lombok.SneakyThrows;
+import lombok.Value;
 import lombok.extern.slf4j.Slf4j;
-import okhttp3.*;
+import lombok.val;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
@@ -37,269 +50,277 @@
 @Builder(toBuilder = true)
 @Slf4j
 class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
-  /**
-   * Default {@link #execute()} timeout in milliseconds (value: <b>{@value}</b>)
-   *
-   * @see #execute()
-   * @see #executeTimeoutMillis
-   */
-  public static final long DEFAULT_EXECUTE_TIMEOUT_MILLIS = 30_000;
-  /**
-   * Tells whether call has been executed.
-   *
-   * @see #isExecuted()
-   * @see #isCanceled()
-   */
-  private final AtomicReference<CompletableFuture<Response>> futureRef = new AtomicReference<>();
-  /**
-   * HttpClient instance.
-   */
-  @NonNull
-  AsyncHttpClient httpClient;
-  /**
-   * {@link #execute()} response timeout in milliseconds.
-   */
-  @Builder.Default
-  long executeTimeoutMillis = DEFAULT_EXECUTE_TIMEOUT_MILLIS;
-  /**
-   * Retrofit request.
-   */
-  @NonNull
-  @Getter(AccessLevel.NONE)
-  Request request;
-  /**
-   * List of consumers that get called just before actual async-http-client request is being built.
-   */
-  @Singular("requestCustomizer")
-  List<Consumer<RequestBuilder>> requestCustomizers;
-  /**
-   * List of consumers that get called just before actual HTTP request is being fired.
-   */
-  @Singular("onRequestStart")
-  List<Consumer<Request>> onRequestStart;
-  /**
-   * List of consumers that get called when HTTP request finishes with an exception.
-   */
-  @Singular("onRequestFailure")
-  List<Consumer<Throwable>> onRequestFailure;
-  /**
-   * List of consumers that get called when HTTP request finishes successfully.
-   */
-  @Singular("onRequestSuccess")
-  List<Consumer<Response>> onRequestSuccess;
-
-  /**
-   * Safely runs specified consumer.
-   *
-   * @param consumer consumer (may be null)
-   * @param argument consumer argument
-   * @param <T>      consumer type.
-   */
-  protected static <T> void runConsumer(Consumer<T> consumer, T argument) {
-    try {
-      if (consumer != null) {
-        consumer.accept(argument);
-      }
-    } catch (Exception e) {
-      log.error("Exception while running consumer {}: {}", consumer, e.getMessage(), e);
+    /**
+     * Default {@link #execute()} timeout in milliseconds (value: <b>{@value}</b>)
+     *
+     * @see #execute()
+     * @see #executeTimeoutMillis
+     */
+    public static final long DEFAULT_EXECUTE_TIMEOUT_MILLIS = 30_000;
+
+    /**
+     * HttpClient instance.
+     */
+    @NonNull
+    AsyncHttpClient httpClient;
+
+    /**
+     * {@link #execute()} response timeout in milliseconds.
+     */
+    @Builder.Default
+    long executeTimeoutMillis = DEFAULT_EXECUTE_TIMEOUT_MILLIS;
+
+    /**
+     * Retrofit request.
+     */
+    @NonNull
+    @Getter(AccessLevel.NONE)
+    Request request;
+
+    /**
+     * List of consumers that get called just before actual async-http-client request is being built.
+     */
+    @Singular("requestCustomizer")
+    List<Consumer<RequestBuilder>> requestCustomizers;
+
+    /**
+     * List of consumers that get called just before actual HTTP request is being fired.
+     */
+    @Singular("onRequestStart")
+    List<Consumer<Request>> onRequestStart;
+
+    /**
+     * List of consumers that get called when HTTP request finishes with an exception.
+     */
+    @Singular("onRequestFailure")
+    List<Consumer<Throwable>> onRequestFailure;
+
+    /**
+     * List of consumers that get called when HTTP request finishes successfully.
+     */
+    @Singular("onRequestSuccess")
+    List<Consumer<Response>> onRequestSuccess;
+
+    /**
+     * Tells whether call has been executed.
+     *
+     * @see #isExecuted()
+     * @see #isCanceled()
+     */
+    private final AtomicReference<CompletableFuture<Response>> futureRef = new AtomicReference<>();
+
+    @Override
+    public Request request() {
+        return request;
     }
-  }
-
-  /**
-   * Safely runs multiple consumers.
-   *
-   * @param consumers collection of consumers (may be null)
-   * @param argument  consumer argument
-   * @param <T>       consumer type.
-   */
-  protected static <T> void runConsumers(Collection<Consumer<T>> consumers, T argument) {
-    if (consumers == null || consumers.isEmpty()) {
-      return;
+
+    @Override
+    public Response execute() throws IOException {
+        try {
+            return executeHttpRequest().get(getExecuteTimeoutMillis(), TimeUnit.MILLISECONDS);
+        } catch (ExecutionException e) {
+            throw toIOException(e.getCause());
+        } catch (Exception e) {
+            throw toIOException(e);
+        }
     }
-    consumers.forEach(consumer -> runConsumer(consumer, argument));
-  }
-
-  @Override
-  public Request request() {
-    return request;
-  }
-
-  @Override
-  public Response execute() throws IOException {
-    try {
-      return executeHttpRequest().get(getExecuteTimeoutMillis(), TimeUnit.MILLISECONDS);
-    } catch (ExecutionException e) {
-      throw toIOException(e.getCause());
-    } catch (Exception e) {
-      throw toIOException(e);
+
+    @Override
+    public void enqueue(Callback responseCallback) {
+        executeHttpRequest()
+                .thenApply(response -> handleResponse(response, responseCallback))
+                .exceptionally(throwable -> handleException(throwable, responseCallback));
     }
-  }
-
-  @Override
-  public void enqueue(Callback responseCallback) {
-    executeHttpRequest()
-            .thenApply(response -> handleResponse(response, responseCallback))
-            .exceptionally(throwable -> handleException(throwable, responseCallback));
-  }
-
-  @Override
-  public void cancel() {
-    val future = futureRef.get();
-    if (future != null) {
-      if (!future.cancel(true)) {
-        log.warn("Cannot cancel future: {}", future);
-      }
+
+    @Override
+    public void cancel() {
+        val future = futureRef.get();
+        if (future != null) {
+            if (!future.cancel(true)) {
+                log.warn("Cannot cancel future: {}", future);
+            }
+        }
     }
-  }
-
-  @Override
-  public boolean isExecuted() {
-    val future = futureRef.get();
-    return future != null && future.isDone();
-  }
-
-  @Override
-  public boolean isCanceled() {
-    val future = futureRef.get();
-    return future != null && future.isCancelled();
-  }
-
-  @Override
-  public Call clone() {
-    return toBuilder().build();
-  }
-
-  protected <T> T handleException(Throwable throwable, Callback responseCallback) {
-    try {
-      if (responseCallback != null) {
-        responseCallback.onFailure(this, toIOException(throwable));
-      }
-    } catch (Exception e) {
-      log.error("Exception while executing onFailure() on {}: {}", responseCallback, e.getMessage(), e);
+
+    @Override
+    public boolean isExecuted() {
+        val future = futureRef.get();
+        return future != null && future.isDone();
     }
-    return null;
-  }
-
-  protected Response handleResponse(Response response, Callback responseCallback) {
-    try {
-      if (responseCallback != null) {
-        responseCallback.onResponse(this, response);
-      }
-    } catch (Exception e) {
-      log.error("Exception while executing onResponse() on {}: {}", responseCallback, e.getMessage(), e);
+
+    @Override
+    public boolean isCanceled() {
+        val future = futureRef.get();
+        return future != null && future.isCancelled();
     }
-    return response;
-  }
 
-  protected CompletableFuture<Response> executeHttpRequest() {
-    if (futureRef.get() != null) {
-      throwAlreadyExecuted();
+    @Override
+    public Call clone() {
+        return toBuilder().build();
     }
 
-    // create future and try to store it into atomic reference
-    val future = new CompletableFuture<Response>();
-    if (!futureRef.compareAndSet(null, future)) {
-      throwAlreadyExecuted();
+    protected <T> T handleException(Throwable throwable, Callback responseCallback) {
+        try {
+            if (responseCallback != null) {
+                responseCallback.onFailure(this, toIOException(throwable));
+            }
+        } catch (Exception e) {
+            log.error("Exception while executing onFailure() on {}: {}", responseCallback, e.getMessage(), e);
+        }
+        return null;
     }
 
-    // create request
-    val asyncHttpClientRequest = createRequest(request());
-
-    // execute the request.
-    val me = this;
-    runConsumers(this.onRequestStart, this.request);
-    getHttpClient().executeRequest(asyncHttpClientRequest, new AsyncCompletionHandler<Response>() {
-      @Override
-      public void onThrowable(Throwable t) {
-        runConsumers(me.onRequestFailure, t);
-        future.completeExceptionally(t);
-      }
-
-      @Override
-      public Response onCompleted(org.asynchttpclient.Response response) {
-        val okHttpResponse = toOkhttpResponse(response);
-        runConsumers(me.onRequestSuccess, okHttpResponse);
-        future.complete(okHttpResponse);
-        return okHttpResponse;
-      }
-    });
-
-    return future;
-  }
-
-  /**
-   * Converts async-http-client response to okhttp response.
-   *
-   * @param asyncHttpClientResponse async-http-client response
-   * @return okhttp response.
-   * @throws NullPointerException in case of null arguments
-   */
-  private Response toOkhttpResponse(org.asynchttpclient.Response asyncHttpClientResponse) {
-    // status code
-    val rspBuilder = new Response.Builder()
-            .request(request())
-            .protocol(Protocol.HTTP_1_1)
-            .code(asyncHttpClientResponse.getStatusCode())
-            .message(asyncHttpClientResponse.getStatusText());
-
-    // headers
-    if (asyncHttpClientResponse.hasResponseHeaders()) {
-      asyncHttpClientResponse.getHeaders().forEach(e -> rspBuilder.header(e.getKey(), e.getValue()));
+    protected Response handleResponse(Response response, Callback responseCallback) {
+        try {
+            if (responseCallback != null) {
+                responseCallback.onResponse(this, response);
+            }
+        } catch (Exception e) {
+            log.error("Exception while executing onResponse() on {}: {}", responseCallback, e.getMessage(), e);
+        }
+        return response;
     }
 
-    // body
-    if (asyncHttpClientResponse.hasResponseBody()) {
-      val contentType = MediaType.parse(asyncHttpClientResponse.getContentType());
-      val okHttpBody = ResponseBody.create(contentType, asyncHttpClientResponse.getResponseBodyAsBytes());
-      rspBuilder.body(okHttpBody);
+    protected CompletableFuture<Response> executeHttpRequest() {
+        if (futureRef.get() != null) {
+            throwAlreadyExecuted();
+        }
+
+        // create future and try to store it into atomic reference
+        val future = new CompletableFuture<Response>();
+        if (!futureRef.compareAndSet(null, future)) {
+            throwAlreadyExecuted();
+        }
+
+        // create request
+        val asyncHttpClientRequest = createRequest(request());
+
+        // execute the request.
+        val me = this;
+        runConsumers(this.onRequestStart, this.request);
+        getHttpClient().executeRequest(asyncHttpClientRequest, new AsyncCompletionHandler<Response>() {
+            @Override
+            public void onThrowable(Throwable t) {
+                runConsumers(me.onRequestFailure, t);
+                future.completeExceptionally(t);
+            }
+
+            @Override
+            public Response onCompleted(org.asynchttpclient.Response response) throws Exception {
+                val okHttpResponse = toOkhttpResponse(response);
+                runConsumers(me.onRequestSuccess, okHttpResponse);
+                future.complete(okHttpResponse);
+                return okHttpResponse;
+            }
+        });
+
+        return future;
     }
 
-    return rspBuilder.build();
-  }
+    /**
+     * Converts async-http-client response to okhttp response.
+     *
+     * @param asyncHttpClientResponse async-http-client response
+     * @return okhttp response.
+     * @throws NullPointerException in case of null arguments
+     */
+    private Response toOkhttpResponse(org.asynchttpclient.Response asyncHttpClientResponse) {
+        // status code
+        val rspBuilder = new Response.Builder()
+                .request(request())
+                .protocol(Protocol.HTTP_1_1)
+                .code(asyncHttpClientResponse.getStatusCode())
+                .message(asyncHttpClientResponse.getStatusText());
+
+        // headers
+        if (asyncHttpClientResponse.hasResponseHeaders()) {
+            asyncHttpClientResponse.getHeaders().forEach(e -> rspBuilder.header(e.getKey(), e.getValue()));
+        }
+
+        // body
+        if (asyncHttpClientResponse.hasResponseBody()) {
+            val contentType = MediaType.parse(asyncHttpClientResponse.getContentType());
+            val okHttpBody = ResponseBody.create(contentType, asyncHttpClientResponse.getResponseBodyAsBytes());
+            rspBuilder.body(okHttpBody);
+        }
+
+        return rspBuilder.build();
+    }
 
-  protected IOException toIOException(@NonNull Throwable exception) {
-    if (exception instanceof IOException) {
-      return (IOException) exception;
-    } else {
-      val message = (exception.getMessage() == null) ? exception.toString() : exception.getMessage();
-      return new IOException(message, exception);
+    protected IOException toIOException(@NonNull Throwable exception) {
+        if (exception instanceof IOException) {
+            return (IOException) exception;
+        } else {
+            val message = (exception.getMessage() == null) ? exception.toString() : exception.getMessage();
+            return new IOException(message, exception);
+        }
     }
-  }
-
-  /**
-   * Converts retrofit request to async-http-client request.
-   *
-   * @param request retrofit request
-   * @return async-http-client request.
-   */
-  @SneakyThrows
-  protected org.asynchttpclient.Request createRequest(@NonNull Request request) {
-    // create async-http-client request builder
-    val requestBuilder = new RequestBuilder(request.method());
-
-    // request uri
-    requestBuilder.setUrl(request.url().toString());
-
-    // set headers
-    val headers = request.headers();
-    headers.names().forEach(name -> requestBuilder.setHeader(name, headers.values(name)));
-
-    // set request body
-    val body = request.body();
-    if (body != null && body.contentLength() > 0) {
-      // write body to buffer
-      val okioBuffer = new Buffer();
-      body.writeTo(okioBuffer);
-      requestBuilder.setBody(okioBuffer.readByteArray());
+
+    /**
+     * Converts retrofit request to async-http-client request.
+     *
+     * @param request retrofit request
+     * @return async-http-client request.
+     */
+    @SneakyThrows
+    protected org.asynchttpclient.Request createRequest(@NonNull Request request) {
+        // create async-http-client request builder
+        val requestBuilder = new RequestBuilder(request.method());
+
+        // request uri
+        requestBuilder.setUrl(request.url().toString());
+
+        // set headers
+        val headers = request.headers();
+        headers.names().forEach(name -> requestBuilder.setHeader(name, headers.values(name)));
+
+        // set request body
+        val body = request.body();
+        if (body != null && body.contentLength() > 0) {
+            // write body to buffer
+            val okioBuffer = new Buffer();
+            body.writeTo(okioBuffer);
+            requestBuilder.setBody(okioBuffer.readByteArray());
+        }
+
+        // customize the request builder (external customizer can change the request url for example)
+        runConsumers(this.requestCustomizers, requestBuilder);
+
+        return requestBuilder.build();
     }
 
-    // customize the request builder (external customizer can change the request url for example)
-    runConsumers(this.requestCustomizers, requestBuilder);
+    /**
+     * Safely runs specified consumer.
+     *
+     * @param consumer consumer (may be null)
+     * @param argument consumer argument
+     * @param <T>      consumer type.
+     */
+    protected static <T> void runConsumer(Consumer<T> consumer, T argument) {
+        try {
+            if (consumer != null) {
+                consumer.accept(argument);
+            }
+        } catch (Exception e) {
+            log.error("Exception while running consumer {}: {}", consumer, e.getMessage(), e);
+        }
+    }
 
-    return requestBuilder.build();
-  }
+    /**
+     * Safely runs multiple consumers.
+     *
+     * @param consumers collection of consumers (may be null)
+     * @param argument  consumer argument
+     * @param <T>       consumer type.
+     */
+    protected static <T> void runConsumers(Collection<Consumer<T>> consumers, T argument) {
+        if (consumers == null || consumers.isEmpty()) {
+            return;
+        }
+        consumers.forEach(consumer -> runConsumer(consumer, argument));
+    }
 
-  private void throwAlreadyExecuted() {
-    throw new IllegalStateException("This call has already been executed.");
-  }
+    private void throwAlreadyExecuted() {
+        throw new IllegalStateException("This call has already been executed.");
+    }
 }
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
index b7c087fd3..0376628b7 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactory.java
@@ -12,7 +12,11 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
-import lombok.*;
+import lombok.Builder;
+import lombok.NonNull;
+import lombok.Singular;
+import lombok.Value;
+import lombok.val;
 import okhttp3.Call;
 import okhttp3.Request;
 import org.asynchttpclient.AsyncHttpClient;
@@ -28,28 +32,28 @@
 @Value
 @Builder(toBuilder = true)
 public class AsyncHttpClientCallFactory implements Call.Factory {
-  /**
-   * {@link AsyncHttpClient} in use.
-   */
-  @NonNull
-  AsyncHttpClient httpClient;
-
-  /**
-   * List of {@link Call} builder customizers that are invoked just before creating it.
-   */
-  @Singular("callCustomizer")
-  List<Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder>> callCustomizers;
-
-  @Override
-  public Call newCall(Request request) {
-    val callBuilder = AsyncHttpClientCall.builder()
-            .httpClient(httpClient)
-            .request(request);
-
-    // customize builder before creating a call
-    runConsumers(this.callCustomizers, callBuilder);
-
-    // create a call
-    return callBuilder.build();
-  }
+    /**
+     * {@link AsyncHttpClient} in use.
+     */
+    @NonNull
+    AsyncHttpClient httpClient;
+
+    /**
+     * List of {@link Call} builder customizers that are invoked just before creating it.
+     */
+    @Singular("callCustomizer")
+    List<Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder>> callCustomizers;
+
+    @Override
+    public Call newCall(Request request) {
+        val callBuilder = AsyncHttpClientCall.builder()
+                .httpClient(httpClient)
+                .request(request);
+
+        // customize builder before creating a call
+        runConsumers(this.callCustomizers, callBuilder);
+
+        // create a call
+        return callBuilder.build();
+    }
 }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
index 730ab5d00..58eef1c91 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallFactoryTest.java
@@ -20,6 +20,7 @@
 import org.asynchttpclient.RequestBuilder;
 import org.testng.annotations.Test;
 
+import java.io.IOException;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
@@ -31,124 +32,125 @@
 
 @Slf4j
 public class AsyncHttpClientCallFactoryTest {
-  @Test
-  void newCallShouldProduceExpectedResult() {
-    // given
-    val request = new Request.Builder().url("http://www.google.com/").build();
-    val httpClient = mock(AsyncHttpClient.class);
-
-    Consumer<Request> onRequestStart = createConsumer(new AtomicInteger());
-    Consumer<Throwable> onRequestFailure = createConsumer(new AtomicInteger());
-    Consumer<Response> onRequestSuccess = createConsumer(new AtomicInteger());
-    Consumer<RequestBuilder> requestCustomizer = createConsumer(new AtomicInteger());
-
-    // first call customizer
-    val customizer1Called = new AtomicInteger();
-    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer1 = builder -> {
-      builder.onRequestStart(onRequestStart)
-              .onRequestFailure(onRequestFailure)
-              .onRequestSuccess(onRequestSuccess);
-      customizer1Called.incrementAndGet();
-    };
-
-    // first call customizer
-    val customizer2Called = new AtomicInteger();
-    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer2 = builder -> {
-      builder.requestCustomizer(requestCustomizer);
-      customizer2Called.incrementAndGet();
-    };
-
-    // when: create call factory
-    val factory = AsyncHttpClientCallFactory.builder()
-            .httpClient(httpClient)
-            .callCustomizer(callBuilderConsumer1)
-            .callCustomizer(callBuilderConsumer2)
-            .build();
-
-    // then
-    assertTrue(factory.getHttpClient() == httpClient);
-    assertTrue(factory.getCallCustomizers().size() == 2);
-    assertTrue(customizer1Called.get() == 0);
-    assertTrue(customizer2Called.get() == 0);
-
-    // when
-    val call = (AsyncHttpClientCall) factory.newCall(request);
-
-    // then
-    assertNotNull(call);
-    assertTrue(customizer1Called.get() == 1);
-    assertTrue(customizer2Called.get() == 1);
-
-    assertTrue(call.request() == request);
-    assertTrue(call.getHttpClient() == httpClient);
-
-    assertEquals(call.getOnRequestStart().get(0), onRequestStart);
-    assertEquals(call.getOnRequestFailure().get(0), onRequestFailure);
-    assertEquals(call.getOnRequestSuccess().get(0), onRequestSuccess);
-    assertEquals(call.getRequestCustomizers().get(0), requestCustomizer);
-  }
-
-  @Test
-  void shouldApplyAllConsumersToCallBeingConstructed() {
-    // given
-    val httpClient = mock(AsyncHttpClient.class);
-
-    val rewriteUrl = "http://foo.bar.com/";
-    val headerName = "X-Header";
-    val headerValue = UUID.randomUUID().toString();
-
-    val numCustomized = new AtomicInteger();
-    val numRequestStart = new AtomicInteger();
-    val numRequestSuccess = new AtomicInteger();
-    val numRequestFailure = new AtomicInteger();
-
-    Consumer<RequestBuilder> requestCustomizer = requestBuilder -> {
-      requestBuilder.setUrl(rewriteUrl)
-              .setHeader(headerName, headerValue);
-      numCustomized.incrementAndGet();
-    };
-
-    Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callCustomizer = callBuilder ->
-      callBuilder
-              .requestCustomizer(requestCustomizer)
-              .requestCustomizer(rb -> log.warn("I'm customizing: {}", rb))
-              .onRequestSuccess(createConsumer(numRequestSuccess))
-              .onRequestFailure(createConsumer(numRequestFailure))
-              .onRequestStart(createConsumer(numRequestStart));
-
-    // create factory
-    val factory = AsyncHttpClientCallFactory.builder()
-            .callCustomizer(callCustomizer)
-            .httpClient(httpClient)
-            .build();
-
-    // when
-    val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
-    val callRequest = call.createRequest(call.request());
-
-    // then
-    assertTrue(numCustomized.get() == 1);
-    assertTrue(numRequestStart.get() == 0);
-    assertTrue(numRequestSuccess.get() == 0);
-    assertTrue(numRequestFailure.get() == 0);
-
-    // let's see whether request customizers did their job
-    // final async-http-client request should have modified URL and one
-    // additional header value.
-    assertEquals(callRequest.getUrl(), rewriteUrl);
-    assertEquals(callRequest.getHeaders().get(headerName), headerValue);
-
-    // final call should have additional consumers set
-    assertNotNull(call.getOnRequestStart());
-    assertTrue(call.getOnRequestStart().size() == 1);
-
-    assertNotNull(call.getOnRequestSuccess());
-    assertTrue(call.getOnRequestSuccess().size() == 1);
-
-    assertNotNull(call.getOnRequestFailure());
-    assertTrue(call.getOnRequestFailure().size() == 1);
-
-    assertNotNull(call.getRequestCustomizers());
-    assertTrue(call.getRequestCustomizers().size() == 2);
-  }
+    @Test
+    void newCallShouldProduceExpectedResult() {
+        // given
+        val request = new Request.Builder().url("http://www.google.com/").build();
+        val httpClient = mock(AsyncHttpClient.class);
+
+        Consumer<Request> onRequestStart = createConsumer(new AtomicInteger());
+        Consumer<Throwable> onRequestFailure = createConsumer(new AtomicInteger());
+        Consumer<Response> onRequestSuccess = createConsumer(new AtomicInteger());
+        Consumer<RequestBuilder> requestCustomizer = createConsumer(new AtomicInteger());
+
+        // first call customizer
+        val customizer1Called = new AtomicInteger();
+        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer1 = builder -> {
+            builder.onRequestStart(onRequestStart)
+                    .onRequestFailure(onRequestFailure)
+                    .onRequestSuccess(onRequestSuccess);
+            customizer1Called.incrementAndGet();
+        };
+
+        // first call customizer
+        val customizer2Called = new AtomicInteger();
+        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callBuilderConsumer2 = builder -> {
+            builder.requestCustomizer(requestCustomizer);
+            customizer2Called.incrementAndGet();
+        };
+
+        // when: create call factory
+        val factory = AsyncHttpClientCallFactory.builder()
+                .httpClient(httpClient)
+                .callCustomizer(callBuilderConsumer1)
+                .callCustomizer(callBuilderConsumer2)
+                .build();
+
+        // then
+        assertTrue(factory.getHttpClient() == httpClient);
+        assertTrue(factory.getCallCustomizers().size() == 2);
+        assertTrue(customizer1Called.get() == 0);
+        assertTrue(customizer2Called.get() == 0);
+
+        // when
+        val call = (AsyncHttpClientCall) factory.newCall(request);
+
+        // then
+        assertNotNull(call);
+        assertTrue(customizer1Called.get() == 1);
+        assertTrue(customizer2Called.get() == 1);
+
+        assertTrue(call.request() == request);
+        assertTrue(call.getHttpClient() == httpClient);
+
+        assertEquals(call.getOnRequestStart().get(0), onRequestStart);
+        assertEquals(call.getOnRequestFailure().get(0), onRequestFailure);
+        assertEquals(call.getOnRequestSuccess().get(0), onRequestSuccess);
+        assertEquals(call.getRequestCustomizers().get(0), requestCustomizer);
+    }
+
+    @Test
+    void shouldApplyAllConsumersToCallBeingConstructed() throws IOException {
+        // given
+        val httpClient = mock(AsyncHttpClient.class);
+
+        val rewriteUrl = "http://foo.bar.com/";
+        val headerName = "X-Header";
+        val headerValue = UUID.randomUUID().toString();
+
+        val numCustomized = new AtomicInteger();
+        val numRequestStart = new AtomicInteger();
+        val numRequestSuccess = new AtomicInteger();
+        val numRequestFailure = new AtomicInteger();
+
+        Consumer<RequestBuilder> requestCustomizer = requestBuilder -> {
+            requestBuilder.setUrl(rewriteUrl)
+                    .setHeader(headerName, headerValue);
+            numCustomized.incrementAndGet();
+        };
+
+        Consumer<AsyncHttpClientCall.AsyncHttpClientCallBuilder> callCustomizer = callBuilder -> {
+            callBuilder
+                    .requestCustomizer(requestCustomizer)
+                    .requestCustomizer(rb -> log.warn("I'm customizing: {}", rb))
+                    .onRequestSuccess(createConsumer(numRequestSuccess))
+                    .onRequestFailure(createConsumer(numRequestFailure))
+                    .onRequestStart(createConsumer(numRequestStart));
+        };
+
+        // create factory
+        val factory = AsyncHttpClientCallFactory.builder()
+                .callCustomizer(callCustomizer)
+                .httpClient(httpClient)
+                .build();
+
+        // when
+        val call = (AsyncHttpClientCall) factory.newCall(REQUEST);
+        val callRequest = call.createRequest(call.request());
+
+        // then
+        assertTrue(numCustomized.get() == 1);
+        assertTrue(numRequestStart.get() == 0);
+        assertTrue(numRequestSuccess.get() == 0);
+        assertTrue(numRequestFailure.get() == 0);
+
+        // let's see whether request customizers did their job
+        // final async-http-client request should have modified URL and one
+        // additional header value.
+        assertEquals(callRequest.getUrl(), rewriteUrl);
+        assertEquals(callRequest.getHeaders().get(headerName), headerValue);
+
+        // final call should have additional consumers set
+        assertNotNull(call.getOnRequestStart());
+        assertTrue(call.getOnRequestStart().size() == 1);
+
+        assertNotNull(call.getOnRequestSuccess());
+        assertTrue(call.getOnRequestSuccess().size() == 1);
+
+        assertNotNull(call.getOnRequestFailure());
+        assertTrue(call.getOnRequestFailure().size() == 1);
+
+        assertNotNull(call.getRequestCustomizers());
+        assertTrue(call.getRequestCustomizers().size() == 2);
+    }
 }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
index 71f07ce2b..1bfd81151 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCallTest.java
@@ -12,16 +12,11 @@
  */
 package org.asynchttpclient.extras.retrofit;
 
+import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+import static org.testng.Assert.assertTrue;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
-import lombok.val;
-import okhttp3.Request;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
-import org.testng.Assert;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -31,12 +26,16 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.runConsumer;
-import static org.asynchttpclient.extras.retrofit.AsyncHttpClientCall.runConsumers;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.testng.Assert.assertTrue;
+import lombok.val;
+import okhttp3.Request;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.Response;
+import org.testng.Assert;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 
 public class AsyncHttpClientCallTest {
     static final Request REQUEST = new Request.Builder().url("http://www.google.com/").build();
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
index 151c54c6c..d370e38c9 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/AsyncHttpRetrofitIntegrationTest.java
@@ -20,7 +20,11 @@
 import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.asynchttpclient.testserver.HttpServer;
 import org.asynchttpclient.testserver.HttpTest;
-import org.testng.annotations.*;
+import org.testng.annotations.AfterSuite;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
 import retrofit2.HttpException;
 import retrofit2.Retrofit;
 import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
@@ -39,6 +43,7 @@
 
 import static org.asynchttpclient.extras.retrofit.TestServices.Contributor;
 import static org.testng.Assert.*;
+import static org.testng.AssertJUnit.assertEquals;
 
 /**
  * All tests in this test suite are disabled, because they call functionality of github service that is
@@ -46,390 +51,393 @@
  */
 @Slf4j
 public class AsyncHttpRetrofitIntegrationTest extends HttpTest {
-  private static final ObjectMapper objectMapper = new ObjectMapper();
-  private static final String OWNER = "AsyncHttpClient";
-  private static final String REPO = "async-http-client";
-
-  private static final AsyncHttpClient httpClient = createHttpClient();
-  private static HttpServer server;
-
-  private List<Contributor> expectedContributors;
-
-  private static AsyncHttpClient createHttpClient() {
-    val config = new DefaultAsyncHttpClientConfig.Builder()
-            .setCompressionEnforced(true)
-            .setTcpNoDelay(true)
-            .setKeepAlive(true)
-            .setPooledConnectionIdleTimeout(120_000)
-            .setFollowRedirect(true)
-            .setMaxRedirects(5)
-            .build();
-
-    return new DefaultAsyncHttpClient(config);
-  }
-
-  @BeforeClass
-  public static void start() throws Throwable {
-    server = new HttpServer();
-    server.start();
-  }
-
-  @BeforeTest
-  void before() {
-    this.expectedContributors = generateContributors();
-  }
-
-  @AfterSuite
-  void cleanup() throws IOException {
-    httpClient.close();
-  }
-
-  // begin: synchronous execution
-  @Test
-  public void testSynchronousService_OK() throws Throwable {
-    // given
-    val service = synchronousSetup();
-
-    // when:
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-      val contributors = service.contributors(OWNER, REPO).execute().body();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributors(expectedContributors, resultRef.get());
-  }
-
-  @Test
-  public void testSynchronousService_OK_WithBadEncoding() throws Throwable {
-    // given
-    val service = synchronousSetup();
-
-    // when:
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-      val contributors = service.contributors(OWNER, REPO).execute().body();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-  }
-
-  @Test
-  public void testSynchronousService_FAIL() throws Throwable {
-    // given
-    val service = synchronousSetup();
-
-    // when:
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-      val contributors = service.contributors(OWNER, REPO).execute().body();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then:
-    assertNull(resultRef.get());
-  }
-
-  @Test
-  public void testSynchronousService_NOT_FOUND() throws Throwable {
-    // given
-    val service = synchronousSetup();
-
-    // when:
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-      val contributors = service.contributors(OWNER, REPO).execute().body();
-      log.info("contributors: {}", contributors);
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then:
-    assertNull(resultRef.get());
-  }
-
-  private TestServices.GithubSync synchronousSetup() {
-    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-    val retrofit = createRetrofitBuilder()
-            .callFactory(callFactory)
-            .build();
-    return retrofit.create(TestServices.GithubSync.class);
-  }
-  // end: synchronous execution
-
-  // begin: rxjava 1.x
-  @Test(dataProvider = "testRxJava1Service")
-  public void testRxJava1Service_OK(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava1Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributors(expectedContributors, resultRef.get());
-  }
-
-  @Test(dataProvider = "testRxJava1Service")
-  public void testRxJava1Service_OK_WithBadEncoding(RxJavaCallAdapterFactory rxJavaCallAdapterFactory)
-          throws Throwable {
-    // given
-    val service = rxjava1Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-  }
-
-  @Test(dataProvider = "testRxJava1Service", expectedExceptions = HttpException.class,
-          expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-  public void testRxJava1Service_HTTP_500(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava1Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-      resultRef.compareAndSet(null, contributors);
-    });
-  }
-
-  @Test(dataProvider = "testRxJava1Service",
-          expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-  public void testRxJava1Service_NOT_FOUND(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava1Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).toBlocking().first();
-      resultRef.compareAndSet(null, contributors);
-    });
-  }
-
-  private TestServices.GithubRxJava1 rxjava1Setup(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) {
-    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-    val retrofit = createRetrofitBuilder()
-            .addCallAdapterFactory(rxJavaCallAdapterFactory)
-            .callFactory(callFactory)
-            .build();
-    return retrofit.create(TestServices.GithubRxJava1.class);
-  }
-
-  @DataProvider(name = "testRxJava1Service")
-  Object[][] testRxJava1Service_DataProvider() {
-    return new Object[][]{
-            {RxJavaCallAdapterFactory.create()},
-            {RxJavaCallAdapterFactory.createAsync()},
-            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io())},
-            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.computation())},
-            {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.trampoline())},
-    };
-  }
-  // end: rxjava 1.x
-
-  // begin: rxjava 2.x
-  @Test(dataProvider = "testRxJava2Service")
-  public void testRxJava2Service_OK(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava2Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).blockingGet();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributors(expectedContributors, resultRef.get());
-  }
-
-  @Test(dataProvider = "testRxJava2Service")
-  public void testRxJava2Service_OK_WithBadEncoding(RxJava2CallAdapterFactory rxJavaCallAdapterFactory)
-          throws Throwable {
-    // given
-    val service = rxjava2Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 200, expectedContributors, "us-ascii");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).blockingGet();
-      resultRef.compareAndSet(null, contributors);
-    });
-
-    // then
-    assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
-  }
-
-  @Test(dataProvider = "testRxJava2Service", expectedExceptions = HttpException.class,
-          expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
-  public void testRxJava2Service_HTTP_500(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava2Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 500, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).blockingGet();
-      resultRef.compareAndSet(null, contributors);
-    });
-  }
-
-  @Test(dataProvider = "testRxJava2Service",
-          expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
-  public void testRxJava2Service_NOT_FOUND(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
-    // given
-    val service = rxjava2Setup(rxJavaCallAdapterFactory);
-    val expectedContributors = generateContributors();
-
-    // when
-    val resultRef = new AtomicReference<List<Contributor>>();
-    withServer(server).run(srv -> {
-      configureTestServer(srv, 404, expectedContributors, "utf-8");
-
-      // execute retrofit request
-      val contributors = service.contributors(OWNER, REPO).blockingGet();
-      resultRef.compareAndSet(null, contributors);
-    });
-  }
-
-  private TestServices.GithubRxJava2 rxjava2Setup(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) {
-    val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
-    val retrofit = createRetrofitBuilder()
-            .addCallAdapterFactory(rxJavaCallAdapterFactory)
-            .callFactory(callFactory)
-            .build();
-    return retrofit.create(TestServices.GithubRxJava2.class);
-  }
-
-  @DataProvider(name = "testRxJava2Service")
-  Object[][] testRxJava2Service_DataProvider() {
-    return new Object[][]{
-            {RxJava2CallAdapterFactory.create()},
-            {RxJava2CallAdapterFactory.createAsync()},
-            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.io())},
-            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.computation())},
-            {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.trampoline())},
-    };
-  }
-  // end: rxjava 2.x
-
-  private Retrofit.Builder createRetrofitBuilder() {
-    return new Retrofit.Builder()
-            .addConverterFactory(ScalarsConverterFactory.create())
-            .addConverterFactory(JacksonConverterFactory.create(objectMapper))
-            .validateEagerly(true)
-            .baseUrl(server.getHttpUrl());
-  }
-
-  /**
-   * Asserts contributors.
-   *
-   * @param expected expected list of contributors
-   * @param actual   actual retrieved list of contributors.
-   */
-  private void assertContributors(Collection<Contributor> expected, Collection<Contributor> actual) {
-    assertNotNull(actual, "Retrieved contributors should not be null.");
-    log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-    assertTrue(expected.size() == actual.size());
-    assertEquals(expected, actual);
-  }
-
-  private void assertContributorsWithWrongCharset(List<Contributor> expected, List<Contributor> actual) {
-    assertNotNull(actual, "Retrieved contributors should not be null.");
-    log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
-    assertTrue(expected.size() == actual.size());
-
-    // first and second element should have different logins due to problems with decoding utf8 to us-ascii
-    assertNotEquals(expected.get(0).getLogin(), actual.get(0).getLogin());
-    assertEquals(expected.get(0).getContributions(), actual.get(0).getContributions());
-
-    assertNotEquals(expected.get(1).getLogin(), actual.get(1).getLogin());
-    assertEquals(expected.get(1).getContributions(), actual.get(1).getContributions());
-
-    // other elements should be equal
-    for (int i = 2; i < expected.size(); i++) {
-      assertEquals(expected.get(i), actual.get(i));
+    private static final ObjectMapper objectMapper = new ObjectMapper();
+    private static final String OWNER = "AsyncHttpClient";
+    private static final String REPO = "async-http-client";
+
+    private static final AsyncHttpClient httpClient = createHttpClient();
+    private static HttpServer server;
+
+    private List<Contributor> expectedContributors;
+
+    private static AsyncHttpClient createHttpClient() {
+        val config = new DefaultAsyncHttpClientConfig.Builder()
+                .setCompressionEnforced(true)
+                .setTcpNoDelay(true)
+                .setKeepAlive(true)
+                .setPooledConnectionIdleTimeout(120_000)
+                .setFollowRedirect(true)
+                .setMaxRedirects(5)
+                .build();
+
+        return new DefaultAsyncHttpClient(config);
+    }
+
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
+    }
+
+    @BeforeTest
+    void before() {
+        this.expectedContributors = generateContributors();
+    }
+
+    @AfterSuite
+    void cleanup() throws IOException {
+        httpClient.close();
+    }
+
+    // begin: synchronous execution
+    @Test
+    public void testSynchronousService_OK() throws Throwable {
+        // given
+        val service = synchronousSetup();
+
+        // when:
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+            val contributors = service.contributors(OWNER, REPO).execute().body();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributors(expectedContributors, resultRef.get());
+    }
+
+    @Test
+    public void testSynchronousService_OK_WithBadEncoding() throws Throwable {
+        // given
+        val service = synchronousSetup();
+
+        // when:
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+            val contributors = service.contributors(OWNER, REPO).execute().body();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+    }
+
+    @Test
+    public void testSynchronousService_FAIL() throws Throwable {
+        // given
+        val service = synchronousSetup();
+
+        // when:
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+            val contributors = service.contributors(OWNER, REPO).execute().body();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then:
+        assertNull(resultRef.get());
+    }
+
+    @Test
+    public void testSynchronousService_NOT_FOUND() throws Throwable {
+        // given
+        val service = synchronousSetup();
+
+        // when:
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+            val contributors = service.contributors(OWNER, REPO).execute().body();
+            log.info("contributors: {}", contributors);
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then:
+        assertNull(resultRef.get());
+    }
+
+    private TestServices.GithubSync synchronousSetup() {
+        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+        val retrofit = createRetrofitBuilder()
+                .callFactory(callFactory)
+                .build();
+        val service = retrofit.create(TestServices.GithubSync.class);
+        return service;
+    }
+    // end: synchronous execution
+
+    // begin: rxjava 1.x
+    @Test(dataProvider = "testRxJava1Service")
+    public void testRxJava1Service_OK(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava1Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributors(expectedContributors, resultRef.get());
+    }
+
+    @Test(dataProvider = "testRxJava1Service")
+    public void testRxJava1Service_OK_WithBadEncoding(RxJavaCallAdapterFactory rxJavaCallAdapterFactory)
+            throws Throwable {
+        // given
+        val service = rxjava1Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+    }
+
+    @Test(dataProvider = "testRxJava1Service", expectedExceptions = HttpException.class,
+            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
+    public void testRxJava1Service_HTTP_500(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava1Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+            resultRef.compareAndSet(null, contributors);
+        });
+    }
+
+    @Test(dataProvider = "testRxJava1Service",
+            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
+    public void testRxJava1Service_NOT_FOUND(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava1Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).toBlocking().first();
+            resultRef.compareAndSet(null, contributors);
+        });
+    }
+
+    private TestServices.GithubRxJava1 rxjava1Setup(RxJavaCallAdapterFactory rxJavaCallAdapterFactory) {
+        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+        val retrofit = createRetrofitBuilder()
+                .addCallAdapterFactory(rxJavaCallAdapterFactory)
+                .callFactory(callFactory)
+                .build();
+        return retrofit.create(TestServices.GithubRxJava1.class);
+    }
+
+    @DataProvider(name = "testRxJava1Service")
+    Object[][] testRxJava1Service_DataProvider() {
+        return new Object[][]{
+                {RxJavaCallAdapterFactory.create()},
+                {RxJavaCallAdapterFactory.createAsync()},
+                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io())},
+                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.computation())},
+                {RxJavaCallAdapterFactory.createWithScheduler(Schedulers.trampoline())},
+        };
+    }
+    // end: rxjava 1.x
+
+    // begin: rxjava 2.x
+    @Test(dataProvider = "testRxJava2Service")
+    public void testRxJava2Service_OK(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava2Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).blockingGet();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributors(expectedContributors, resultRef.get());
+    }
+
+    @Test(dataProvider = "testRxJava2Service")
+    public void testRxJava2Service_OK_WithBadEncoding(RxJava2CallAdapterFactory rxJavaCallAdapterFactory)
+            throws Throwable {
+        // given
+        val service = rxjava2Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 200, expectedContributors, "us-ascii");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).blockingGet();
+            resultRef.compareAndSet(null, contributors);
+        });
+
+        // then
+        assertContributorsWithWrongCharset(expectedContributors, resultRef.get());
+    }
+
+    @Test(dataProvider = "testRxJava2Service", expectedExceptions = HttpException.class,
+            expectedExceptionsMessageRegExp = ".*HTTP 500 Server Error.*")
+    public void testRxJava2Service_HTTP_500(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava2Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 500, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).blockingGet();
+            resultRef.compareAndSet(null, contributors);
+        });
+    }
+
+    @Test(dataProvider = "testRxJava2Service",
+            expectedExceptions = HttpException.class, expectedExceptionsMessageRegExp = "HTTP 404 Not Found")
+    public void testRxJava2Service_NOT_FOUND(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) throws Throwable {
+        // given
+        val service = rxjava2Setup(rxJavaCallAdapterFactory);
+        val expectedContributors = generateContributors();
+
+        // when
+        val resultRef = new AtomicReference<List<Contributor>>();
+        withServer(server).run(srv -> {
+            configureTestServer(srv, 404, expectedContributors, "utf-8");
+
+            // execute retrofit request
+            val contributors = service.contributors(OWNER, REPO).blockingGet();
+            resultRef.compareAndSet(null, contributors);
+        });
+    }
+
+    private TestServices.GithubRxJava2 rxjava2Setup(RxJava2CallAdapterFactory rxJavaCallAdapterFactory) {
+        val callFactory = AsyncHttpClientCallFactory.builder().httpClient(httpClient).build();
+        val retrofit = createRetrofitBuilder()
+                .addCallAdapterFactory(rxJavaCallAdapterFactory)
+                .callFactory(callFactory)
+                .build();
+        return retrofit.create(TestServices.GithubRxJava2.class);
+    }
+
+    @DataProvider(name = "testRxJava2Service")
+    Object[][] testRxJava2Service_DataProvider() {
+        return new Object[][]{
+                {RxJava2CallAdapterFactory.create()},
+                {RxJava2CallAdapterFactory.createAsync()},
+                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.io())},
+                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.computation())},
+                {RxJava2CallAdapterFactory.createWithScheduler(io.reactivex.schedulers.Schedulers.trampoline())},
+        };
+    }
+    // end: rxjava 2.x
+
+    private Retrofit.Builder createRetrofitBuilder() {
+        return new Retrofit.Builder()
+                .addConverterFactory(ScalarsConverterFactory.create())
+                .addConverterFactory(JacksonConverterFactory.create(objectMapper))
+                .validateEagerly(true)
+                .baseUrl(server.getHttpUrl());
+    }
+
+    /**
+     * Asserts contributors.
+     *
+     * @param expected expected list of contributors
+     * @param actual   actual retrieved list of contributors.
+     */
+    private void assertContributors(Collection<Contributor> expected, Collection<Contributor> actual) {
+        assertNotNull(actual, "Retrieved contributors should not be null.");
+        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
+        assertTrue(expected.size() == actual.size());
+        assertEquals(expected, actual);
+    }
+
+    private void assertContributorsWithWrongCharset(List<Contributor> expected, List<Contributor> actual) {
+        assertNotNull(actual, "Retrieved contributors should not be null.");
+        log.debug("Contributors: {} ->\n  {}", actual.size(), actual);
+        assertTrue(expected.size() == actual.size());
+
+        // first and second element should have different logins due to problems with decoding utf8 to us-ascii
+        assertNotEquals(expected.get(0).getLogin(), actual.get(0).getLogin());
+        assertEquals(expected.get(0).getContributions(), actual.get(0).getContributions());
+
+        assertNotEquals(expected.get(1).getLogin(), actual.get(1).getLogin());
+        assertEquals(expected.get(1).getContributions(), actual.get(1).getContributions());
+
+        // other elements should be equal
+        for (int i = 2; i < expected.size(); i++) {
+            assertEquals(expected.get(i), actual.get(i));
+        }
+    }
+
+    private List<Contributor> generateContributors() {
+        val list = new ArrayList<Contributor>();
+
+        list.add(new Contributor(UUID.randomUUID() + ": čćžšđ", 100));
+        list.add(new Contributor(UUID.randomUUID() + ": ČĆŽŠĐ", 200));
+
+        IntStream.range(0, (int) (Math.random() * 100)).forEach(i -> {
+            list.add(new Contributor(UUID.randomUUID().toString(), (int) (Math.random() * 500)));
+        });
+
+        return list;
+    }
+
+    private HttpServer configureTestServer(HttpServer server, int status,
+                                           Collection<Contributor> contributors,
+                                           String charset) {
+        server.enqueueResponse(response -> {
+            response.setStatus(status);
+            if (status == 200) {
+                response.setHeader("Content-Type", "application/json; charset=" + charset);
+                response.getOutputStream().write(objectMapper.writeValueAsBytes(contributors));
+            } else {
+                response.setHeader("Content-Type", "text/plain");
+                val errorMsg = "This is an " + status + " error";
+                response.getOutputStream().write(errorMsg.getBytes());
+            }
+        });
+
+        return server;
     }
-  }
-
-  private List<Contributor> generateContributors() {
-    val list = new ArrayList<Contributor>();
-
-    list.add(new Contributor(UUID.randomUUID() + ": čćžšđ", 100));
-    list.add(new Contributor(UUID.randomUUID() + ": ČĆŽŠĐ", 200));
-
-    IntStream
-            .range(0, (int) (Math.random() * 100))
-            .forEach(i -> list.add(new Contributor(UUID.randomUUID().toString(), (int) (Math.random() * 500))));
-
-    return list;
-  }
-
-  private void configureTestServer(HttpServer server, int status,
-                                         Collection<Contributor> contributors,
-                                         String charset) {
-    server.enqueueResponse(response -> {
-      response.setStatus(status);
-      if (status == 200) {
-        response.setHeader("Content-Type", "application/json; charset=" + charset);
-        response.getOutputStream().write(objectMapper.writeValueAsBytes(contributors));
-      } else {
-        response.setHeader("Content-Type", "text/plain");
-        val errorMsg = "This is an " + status + " error";
-        response.getOutputStream().write(errorMsg.getBytes());
-      }
-    });
-  }
 }
diff --git a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
index 5688488a1..6e0939dba 100644
--- a/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
+++ b/extras/retrofit2/src/test/java/org/asynchttpclient/extras/retrofit/TestServices.java
@@ -26,39 +26,39 @@
 /**
  * Github DTOs and services.
  */
-class TestServices {
-  /**
-   * Synchronous interface
-   */
-  public interface GithubSync {
-    @GET("/repos/{owner}/{repo}/contributors")
-    Call<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
+public class TestServices {
+    @Value
+    @JsonIgnoreProperties(ignoreUnknown = true)
+    public static class Contributor implements Serializable {
+        private static final long serialVersionUID = 1;
 
-  /**
-   * RxJava 1.x reactive interface
-   */
-  public interface GithubRxJava1 {
-    @GET("/repos/{owner}/{repo}/contributors")
-    Observable<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
+        @NonNull
+        String login;
 
-  /**
-   * RxJava 2.x reactive interface
-   */
-  public interface GithubRxJava2 {
-    @GET("/repos/{owner}/{repo}/contributors")
-    io.reactivex.Single<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
+        int contributions;
+    }
 
-  @Value
-  @JsonIgnoreProperties(ignoreUnknown = true)
-  static class Contributor implements Serializable {
-    private static final long serialVersionUID = 1;
+    /**
+     * Synchronous interface
+     */
+    public interface GithubSync {
+        @GET("/repos/{owner}/{repo}/contributors")
+        Call<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+    }
 
-    @NonNull
-    String login;
+    /**
+     * RxJava 1.x reactive interface
+     */
+    public interface GithubRxJava1 {
+        @GET("/repos/{owner}/{repo}/contributors")
+        Observable<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+    }
 
-    int contributions;
-  }
+    /**
+     * RxJava 2.x reactive interface
+     */
+    public interface GithubRxJava2 {
+        @GET("/repos/{owner}/{repo}/contributors")
+        io.reactivex.Single<List<Contributor>> contributors(@Path("owner") String owner, @Path("repo") String repo);
+    }
 }
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index dcb081e5f..7c77178cc 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <artifactId>async-http-client-extras-rxjava</artifactId>
-  <name>Asynchronous Http Client RxJava Extras</name>
-  <description>The Async Http Client RxJava Extras.</description>
-  <dependencies>
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-    </dependency>
-  </dependencies>
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <groupId>org.asynchttpclient</groupId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <artifactId>async-http-client-extras-rxjava</artifactId>
+    <name>Asynchronous Http Client RxJava Extras</name>
+    <description>The Async Http Client RxJava Extras.</description>
+    <dependencies>
+        <dependency>
+            <groupId>io.reactivex</groupId>
+            <artifactId>rxjava</artifactId>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
index 6fb1713f7..91865432e 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
@@ -22,63 +22,63 @@
 
 /**
  * Provide RxJava support for executing requests. Request can be subscribed to and manipulated as needed.
- *
+ * 
  * @see <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>
  */
 public class AsyncHttpObservable {
 
-  /**
-   * Observe a request execution and emit the response to the observer.
-   *
-   * @param supplier the supplier
-   * @return The cold observable (must be subscribed to in order to execute).
-   */
-  public static Observable<Response> toObservable(final Func0<BoundRequestBuilder> supplier) {
-
-    //Get the builder from the function
-    final BoundRequestBuilder builder = supplier.call();
+    /**
+     * Observe a request execution and emit the response to the observer.
+     *
+     * @param supplier the supplier
+     * @return The cold observable (must be subscribed to in order to execute).
+     */
+    public static Observable<Response> toObservable(final Func0<BoundRequestBuilder> supplier) {
 
-    //create the observable from scratch
-    return Observable.unsafeCreate(new Observable.OnSubscribe<Response>() {
+        //Get the builder from the function
+        final BoundRequestBuilder builder = supplier.call();
 
-      @Override
-      public void call(final Subscriber<? super Response> subscriber) {
-        try {
-          AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {
+        //create the observable from scratch
+        return Observable.unsafeCreate(new Observable.OnSubscribe<Response>() {
 
             @Override
-            public Void onCompleted(Response response) throws Exception {
-              subscriber.onNext(response);
-              subscriber.onCompleted();
-              return null;
-            }
+            public void call(final Subscriber<? super Response> subscriber) {
+                try {
+                    AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {
 
-            @Override
-            public void onThrowable(Throwable t) {
-              subscriber.onError(t);
+                        @Override
+                        public Void onCompleted(Response response) throws Exception {
+                            subscriber.onNext(response);
+                            subscriber.onCompleted();
+                            return null;
+                        }
+
+                        @Override
+                        public void onThrowable(Throwable t) {
+                            subscriber.onError(t);
+                        }
+                    };
+                    //execute the request
+                    builder.execute(handler);
+                } catch (Throwable t) {
+                    subscriber.onError(t);
+                }
             }
-          };
-          //execute the request
-          builder.execute(handler);
-        } catch (Throwable t) {
-          subscriber.onError(t);
-        }
-      }
-    });
-  }
+        });
+    }
 
-  /**
-   * Observe a request execution and emit the response to the observer.
-   *
-   * @param supplier teh supplier
-   * @return The hot observable (eagerly executes).
-   */
-  public static Observable<Response> observe(final Func0<BoundRequestBuilder> supplier) {
-    //use a ReplaySubject to buffer the eagerly subscribed-to Observable
-    ReplaySubject<Response> subject = ReplaySubject.create();
-    //eagerly kick off subscription
-    toObservable(supplier).subscribe(subject);
-    //return the subject that can be subscribed to later while the execution has already started
-    return subject;
-  }
+    /**
+     * Observe a request execution and emit the response to the observer.
+     *
+     * @param supplier teh supplier
+     * @return The hot observable (eagerly executes).
+     */
+    public static Observable<Response> observe(final Func0<BoundRequestBuilder> supplier) {
+        //use a ReplaySubject to buffer the eagerly subscribed-to Observable
+        ReplaySubject<Response> subject = ReplaySubject.create();
+        //eagerly kick off subscription
+        toObservable(supplier).subscribe(subject);
+        //return the subject that can be subscribed to later while the execution has already started
+        return subject;
+    }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
index eeae82f28..c1a7099db 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/UnsubscribedException.java
@@ -20,10 +20,10 @@
 @SuppressWarnings("serial")
 public class UnsubscribedException extends CancellationException {
 
-  public UnsubscribedException() {
-  }
+    public UnsubscribedException() {
+    }
 
-  public UnsubscribedException(final Throwable cause) {
-    initCause(cause);
-  }
+    public UnsubscribedException(final Throwable cause) {
+        initCause(cause);
+    }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
index bea48961e..dfdd87a09 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractProgressSingleSubscriberBridge.java
@@ -13,30 +13,31 @@
 package org.asynchttpclient.extras.rxjava.single;
 
 import org.asynchttpclient.handler.ProgressAsyncHandler;
+
 import rx.SingleSubscriber;
 
 abstract class AbstractProgressSingleSubscriberBridge<T> extends AbstractSingleSubscriberBridge<T> implements ProgressAsyncHandler<Void> {
 
-  protected AbstractProgressSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
-    super(subscriber);
-  }
+    protected AbstractProgressSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
+        super(subscriber);
+    }
 
-  @Override
-  public State onHeadersWritten() {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersWritten();
-  }
+    @Override
+    public State onHeadersWritten() {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersWritten();
+    }
 
-  @Override
-  public State onContentWritten() {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onContentWritten();
-  }
+    @Override
+    public State onContentWritten() {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onContentWritten();
+    }
 
-  @Override
-  public State onContentWriteProgress(long amount, long current, long total) {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onContentWriteProgress(amount, current, total);
-  }
+    @Override
+    public State onContentWriteProgress(long amount, long current, long total) {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onContentWriteProgress(amount, current, total);
+    }
 
-  @Override
-  protected abstract ProgressAsyncHandler<? extends T> delegate();
+    @Override
+    protected abstract ProgressAsyncHandler<? extends T> delegate();
 
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
index bb6749fee..c64c3ceb4 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AbstractSingleSubscriberBridge.java
@@ -12,109 +12,110 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
+import static java.util.Objects.requireNonNull;
 import io.netty.handler.codec.http.HttpHeaders;
+
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava.UnsubscribedException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+
 import rx.SingleSubscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
 
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static java.util.Objects.requireNonNull;
-
 abstract class AbstractSingleSubscriberBridge<T> implements AsyncHandler<Void> {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractSingleSubscriberBridge.class);
-
-  protected final SingleSubscriber<T> subscriber;
+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractSingleSubscriberBridge.class);
 
-  private final AtomicBoolean delegateTerminated = new AtomicBoolean();
+    protected final SingleSubscriber<T> subscriber;
 
-  protected AbstractSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
-    this.subscriber = requireNonNull(subscriber);
-  }
+    private final AtomicBoolean delegateTerminated = new AtomicBoolean();
 
-  @Override
-  public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onBodyPartReceived(content);
-  }
-
-  @Override
-  public State onStatusReceived(HttpResponseStatus status) throws Exception {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onStatusReceived(status);
-  }
+    protected AbstractSingleSubscriberBridge(SingleSubscriber<T> subscriber) {
+        this.subscriber = requireNonNull(subscriber);
+    }
 
-  @Override
-  public State onHeadersReceived(HttpHeaders headers) throws Exception {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersReceived(headers);
-  }
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onBodyPartReceived(content);
+    }
 
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-    return subscriber.isUnsubscribed() ? abort() : delegate().onTrailingHeadersReceived(headers);
-  }
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onStatusReceived(status);
+    }
 
-  @Override
-  public Void onCompleted() {
-    if (delegateTerminated.getAndSet(true)) {
-      return null;
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onHeadersReceived(headers);
     }
 
-    final T result;
-    try {
-      result = delegate().onCompleted();
-    } catch (final Throwable t) {
-      emitOnError(t);
-      return null;
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        return subscriber.isUnsubscribed() ? abort() : delegate().onTrailingHeadersReceived(headers);
     }
 
-    if (!subscriber.isUnsubscribed()) {
-      subscriber.onSuccess(result);
+    @Override
+    public Void onCompleted() {
+        if (delegateTerminated.getAndSet(true)) {
+            return null;
+        }
+
+        final T result;
+        try {
+            result = delegate().onCompleted();
+        } catch (final Throwable t) {
+            emitOnError(t);
+            return null;
+        }
+
+        if (!subscriber.isUnsubscribed()) {
+            subscriber.onSuccess(result);
+        }
+
+        return null;
     }
 
-    return null;
-  }
+    @Override
+    public void onThrowable(Throwable t) {
+        if (delegateTerminated.getAndSet(true)) {
+            return;
+        }
 
-  @Override
-  public void onThrowable(Throwable t) {
-    if (delegateTerminated.getAndSet(true)) {
-      return;
-    }
+        Throwable error = t;
+        try {
+            delegate().onThrowable(t);
+        } catch (final Throwable x) {
+            error = new CompositeException(Arrays.asList(t, x));
+        }
 
-    Throwable error = t;
-    try {
-      delegate().onThrowable(t);
-    } catch (final Throwable x) {
-      error = new CompositeException(Arrays.asList(t, x));
+        emitOnError(error);
     }
 
-    emitOnError(error);
-  }
+    protected AsyncHandler.State abort() {
+        if (!delegateTerminated.getAndSet(true)) {
+            // send a terminal event to the delegate
+            // e.g. to trigger cleanup logic
+            delegate().onThrowable(new UnsubscribedException());
+        }
 
-  protected AsyncHandler.State abort() {
-    if (!delegateTerminated.getAndSet(true)) {
-      // send a terminal event to the delegate
-      // e.g. to trigger cleanup logic
-      delegate().onThrowable(new UnsubscribedException());
+        return State.ABORT;
     }
 
-    return State.ABORT;
-  }
-
-  protected abstract AsyncHandler<? extends T> delegate();
+    protected abstract AsyncHandler<? extends T> delegate();
 
-  private void emitOnError(Throwable error) {
-    Exceptions.throwIfFatal(error);
-    if (!subscriber.isUnsubscribed()) {
-      subscriber.onError(error);
-    } else {
-      LOGGER.debug("Not propagating onError after unsubscription: {}", error.getMessage(), error);
+    private void emitOnError(Throwable error) {
+        Exceptions.throwIfFatal(error);
+        if (!subscriber.isUnsubscribed()) {
+            subscriber.onError(error);
+        } else {
+            LOGGER.debug("Not propagating onError after unsubscription: {}", error.getMessage(), error);
+        }
     }
-  }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
index e52fbcf89..4e95aab84 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingle.java
@@ -12,122 +12,130 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
+import static java.util.Objects.requireNonNull;
+
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
+
+import java.util.concurrent.Future;
+
 import rx.Single;
 import rx.SingleSubscriber;
 import rx.functions.Func0;
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
 
-import java.util.concurrent.Future;
-
-import static java.util.Objects.requireNonNull;
-
 /**
  * Wraps HTTP requests into RxJava {@code Single} instances.
  *
  * @see <a href="https://github.com/ReactiveX/RxJava">https://github.com/
- * ReactiveX/RxJava</a>
+ *      ReactiveX/RxJava</a>
  */
 public final class AsyncHttpSingle {
 
-  private AsyncHttpSingle() {
-    throw new AssertionError("No instances for you!");
-  }
+    /**
+     * Emits the responses to HTTP requests obtained from {@code builder}.
+     *
+     * @param builder used to build the HTTP request that is to be executed
+     * @return a {@code Single} that executes new requests on subscription
+     *         obtained from {@code builder} on subscription and that emits the
+     *         response
+     *
+     * @throws NullPointerException if {@code builder} is {@code null}
+     */
+    public static Single<Response> create(BoundRequestBuilder builder) {
+        requireNonNull(builder);
+        return create(builder::execute, AsyncCompletionHandlerBase::new);
+    }
 
-  /**
-   * Emits the responses to HTTP requests obtained from {@code builder}.
-   *
-   * @param builder used to build the HTTP request that is to be executed
-   * @return a {@code Single} that executes new requests on subscription
-   * obtained from {@code builder} on subscription and that emits the
-   * response
-   * @throws NullPointerException if {@code builder} is {@code null}
-   */
-  public static Single<Response> create(BoundRequestBuilder builder) {
-    requireNonNull(builder);
-    return create(builder::execute, AsyncCompletionHandlerBase::new);
-  }
+    /**
+     * Emits the responses to HTTP requests obtained by calling
+     * {@code requestTemplate}.
+     *
+     * @param requestTemplate called to start the HTTP request with an
+     *            {@code AysncHandler} that builds the HTTP response and
+     *            propagates results to the returned {@code Single}. The
+     *            {@code Future} that is returned by {@code requestTemplate}
+     *            will be used to cancel the request when the {@code Single} is
+     *            unsubscribed.
+     *
+     * @return a {@code Single} that executes new requests on subscription by
+     *         calling {@code requestTemplate} and that emits the response
+     *
+     * @throws NullPointerException if {@code requestTemplate} is {@code null}
+     */
+    public static Single<Response> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate) {
+        return create(requestTemplate, AsyncCompletionHandlerBase::new);
+    }
 
-  /**
-   * Emits the responses to HTTP requests obtained by calling
-   * {@code requestTemplate}.
-   *
-   * @param requestTemplate called to start the HTTP request with an
-   *                        {@code AysncHandler} that builds the HTTP response and
-   *                        propagates results to the returned {@code Single}. The
-   *                        {@code Future} that is returned by {@code requestTemplate}
-   *                        will be used to cancel the request when the {@code Single} is
-   *                        unsubscribed.
-   * @return a {@code Single} that executes new requests on subscription by
-   * calling {@code requestTemplate} and that emits the response
-   * @throws NullPointerException if {@code requestTemplate} is {@code null}
-   */
-  public static Single<Response> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate) {
-    return create(requestTemplate, AsyncCompletionHandlerBase::new);
-  }
+    /**
+     * Emits the results of {@code AsyncHandlers} obtained from
+     * {@code handlerSupplier} for HTTP requests obtained from {@code builder}.
+     *
+     * @param builder used to build the HTTP request that is to be executed
+     * @param handlerSupplier supplies the desired {@code AsyncHandler}
+     *            instances that are used to produce results
+     *
+     * @return a {@code Single} that executes new requests on subscription
+     *         obtained from {@code builder} and that emits the result of the
+     *         {@code AsyncHandler} obtained from {@code handlerSupplier}
+     *
+     * @throws NullPointerException if at least one of the parameters is
+     *             {@code null}
+     */
+    public static <T> Single<T> create(BoundRequestBuilder builder, Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
+        requireNonNull(builder);
+        return create(builder::execute, handlerSupplier);
+    }
 
-  /**
-   * Emits the results of {@code AsyncHandlers} obtained from
-   * {@code handlerSupplier} for HTTP requests obtained from {@code builder}.
-   *
-   * @param builder         used to build the HTTP request that is to be executed
-   * @param handlerSupplier supplies the desired {@code AsyncHandler}
-   *                        instances that are used to produce results
-   * @return a {@code Single} that executes new requests on subscription
-   * obtained from {@code builder} and that emits the result of the
-   * {@code AsyncHandler} obtained from {@code handlerSupplier}
-   * @throws NullPointerException if at least one of the parameters is
-   *                              {@code null}
-   */
-  public static <T> Single<T> create(BoundRequestBuilder builder, Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
-    requireNonNull(builder);
-    return create(builder::execute, handlerSupplier);
-  }
+    /**
+     * Emits the results of {@code AsyncHandlers} obtained from
+     * {@code handlerSupplier} for HTTP requests obtained obtained by calling
+     * {@code requestTemplate}.
+     *
+     * @param requestTemplate called to start the HTTP request with an
+     *            {@code AysncHandler} that builds the HTTP response and
+     *            propagates results to the returned {@code Single}.  The
+     *            {@code Future} that is returned by {@code requestTemplate}
+     *            will be used to cancel the request when the {@code Single} is
+     *            unsubscribed.
+     * @param handlerSupplier supplies the desired {@code AsyncHandler}
+     *            instances that are used to produce results
+     *
+     * @return a {@code Single} that executes new requests on subscription by
+     *         calling {@code requestTemplate} and that emits the results
+     *         produced by the {@code AsyncHandlers} supplied by
+     *         {@code handlerSupplier}
+     *
+     * @throws NullPointerException if at least one of the parameters is
+     *             {@code null}
+     */
+    public static <T> Single<T> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate,
+            Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
 
-  /**
-   * Emits the results of {@code AsyncHandlers} obtained from
-   * {@code handlerSupplier} for HTTP requests obtained obtained by calling
-   * {@code requestTemplate}.
-   *
-   * @param requestTemplate called to start the HTTP request with an
-   *                        {@code AysncHandler} that builds the HTTP response and
-   *                        propagates results to the returned {@code Single}.  The
-   *                        {@code Future} that is returned by {@code requestTemplate}
-   *                        will be used to cancel the request when the {@code Single} is
-   *                        unsubscribed.
-   * @param handlerSupplier supplies the desired {@code AsyncHandler}
-   *                        instances that are used to produce results
-   * @return a {@code Single} that executes new requests on subscription by
-   * calling {@code requestTemplate} and that emits the results
-   * produced by the {@code AsyncHandlers} supplied by
-   * {@code handlerSupplier}
-   * @throws NullPointerException if at least one of the parameters is
-   *                              {@code null}
-   */
-  public static <T> Single<T> create(Func1<? super AsyncHandler<?>, ? extends Future<?>> requestTemplate,
-                                     Func0<? extends AsyncHandler<? extends T>> handlerSupplier) {
+        requireNonNull(requestTemplate);
+        requireNonNull(handlerSupplier);
 
-    requireNonNull(requestTemplate);
-    requireNonNull(handlerSupplier);
+        return Single.create(subscriber -> {
+            final AsyncHandler<?> bridge = createBridge(subscriber, handlerSupplier.call());
+            final Future<?> responseFuture = requestTemplate.call(bridge);
+            subscriber.add(Subscriptions.from(responseFuture));
+        });
+    }
 
-    return Single.create(subscriber -> {
-      final AsyncHandler<?> bridge = createBridge(subscriber, handlerSupplier.call());
-      final Future<?> responseFuture = requestTemplate.call(bridge);
-      subscriber.add(Subscriptions.from(responseFuture));
-    });
-  }
+    static <T> AsyncHandler<?> createBridge(SingleSubscriber<? super T> subscriber, AsyncHandler<? extends T> handler) {
 
-  static <T> AsyncHandler<?> createBridge(SingleSubscriber<? super T> subscriber, AsyncHandler<? extends T> handler) {
+        if (handler instanceof ProgressAsyncHandler) {
+            return new ProgressAsyncSingleSubscriberBridge<>(subscriber, (ProgressAsyncHandler<? extends T>) handler);
+        }
 
-    if (handler instanceof ProgressAsyncHandler) {
-      return new ProgressAsyncSingleSubscriberBridge<>(subscriber, (ProgressAsyncHandler<? extends T>) handler);
+        return new AsyncSingleSubscriberBridge<>(subscriber, handler);
     }
 
-    return new AsyncSingleSubscriberBridge<>(subscriber, handler);
-  }
+    private AsyncHttpSingle() {
+        throw new AssertionError("No instances for you!");
+    }
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
index ccef13e9d..4d3889710 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/AsyncSingleSubscriberBridge.java
@@ -12,23 +12,24 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
+import static java.util.Objects.requireNonNull;
+
 import org.asynchttpclient.AsyncHandler;
-import rx.SingleSubscriber;
 
-import static java.util.Objects.requireNonNull;
+import rx.SingleSubscriber;
 
 final class AsyncSingleSubscriberBridge<T> extends AbstractSingleSubscriberBridge<T> {
 
-  private final AsyncHandler<? extends T> delegate;
+    private final AsyncHandler<? extends T> delegate;
 
-  public AsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, AsyncHandler<? extends T> delegate) {
-    super(subscriber);
-    this.delegate = requireNonNull(delegate);
-  }
+    public AsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, AsyncHandler<? extends T> delegate) {
+        super(subscriber);
+        this.delegate = requireNonNull(delegate);
+    }
 
-  @Override
-  protected AsyncHandler<? extends T> delegate() {
-    return delegate;
-  }
+    @Override
+    protected AsyncHandler<? extends T> delegate() {
+        return delegate;
+    }
 
 }
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
index 3a1ffda2c..78d0948df 100644
--- a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/single/ProgressAsyncSingleSubscriberBridge.java
@@ -12,23 +12,24 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
+import static java.util.Objects.requireNonNull;
+
 import org.asynchttpclient.handler.ProgressAsyncHandler;
-import rx.SingleSubscriber;
 
-import static java.util.Objects.requireNonNull;
+import rx.SingleSubscriber;
 
 final class ProgressAsyncSingleSubscriberBridge<T> extends AbstractProgressSingleSubscriberBridge<T> {
 
-  private final ProgressAsyncHandler<? extends T> delegate;
+    private final ProgressAsyncHandler<? extends T> delegate;
 
-  public ProgressAsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, ProgressAsyncHandler<? extends T> delegate) {
-    super(subscriber);
-    this.delegate = requireNonNull(delegate);
-  }
+    public ProgressAsyncSingleSubscriberBridge(SingleSubscriber<T> subscriber, ProgressAsyncHandler<? extends T> delegate) {
+        super(subscriber);
+        this.delegate = requireNonNull(delegate);
+    }
 
-  @Override
-  protected ProgressAsyncHandler<? extends T> delegate() {
-    return delegate;
-  }
+    @Override
+    protected ProgressAsyncHandler<? extends T> delegate() {
+        return delegate;
+    }
 
 }
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
index 8adbecd3a..9497d0f81 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -12,122 +12,122 @@
  */
 package org.asynchttpclient.extras.rxjava;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
+import java.util.List;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
+
 import rx.Observable;
 import rx.observers.TestSubscriber;
 
-import java.util.List;
-
-import static org.asynchttpclient.Dsl.asyncHttpClient;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
 public class AsyncHttpObservableTest {
 
-  @Test
-  public void testToObservableNoError() {
-    final TestSubscriber<Response> tester = new TestSubscriber<>();
+    @Test(groups = "standalone")
+    public void testToObservableNoError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io"));
-      o1.subscribe(tester);
-      tester.awaitTerminalEvent();
-      tester.assertTerminalEvent();
-      tester.assertNoErrors();
-      tester.assertCompleted();
-      List<Response> responses = tester.getOnNextEvents();
-      assertNotNull(responses);
-      assertEquals(responses.size(), 1);
-      assertEquals(responses.get(0).getStatusCode(), 200);
-    } catch (Exception e) {
-      Thread.currentThread().interrupt();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io"));
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertNoErrors();
+            tester.assertCompleted();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 200);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 
-  @Test
-  public void testToObservableError() {
-    final TestSubscriber<Response> tester = new TestSubscriber<>();
+    @Test(groups = "standalone")
+    public void testToObservableError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io/ttfn"));
-      o1.subscribe(tester);
-      tester.awaitTerminalEvent();
-      tester.assertTerminalEvent();
-      tester.assertNoErrors();
-      tester.assertCompleted();
-      List<Response> responses = tester.getOnNextEvents();
-      assertNotNull(responses);
-      assertEquals(responses.size(), 1);
-      assertEquals(responses.get(0).getStatusCode(), 404);
-    } catch (Exception e) {
-      Thread.currentThread().interrupt();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io/ttfn"));
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertNoErrors();
+            tester.assertCompleted();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 404);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 
-  @Test
-  public void testObserveNoError() {
-    final TestSubscriber<Response> tester = new TestSubscriber<>();
+    @Test(groups = "standalone")
+    public void testObserveNoError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
-      o1.subscribe(tester);
-      tester.awaitTerminalEvent();
-      tester.assertTerminalEvent();
-      tester.assertNoErrors();
-      tester.assertCompleted();
-      List<Response> responses = tester.getOnNextEvents();
-      assertNotNull(responses);
-      assertEquals(responses.size(), 1);
-      assertEquals(responses.get(0).getStatusCode(), 200);
-    } catch (Exception e) {
-      Thread.currentThread().interrupt();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertNoErrors();
+            tester.assertCompleted();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 200);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 
-  @Test
-  public void testObserveError() {
-    final TestSubscriber<Response> tester = new TestSubscriber<>();
+    @Test(groups = "standalone")
+    public void testObserveError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io/ttfn"));
-      o1.subscribe(tester);
-      tester.awaitTerminalEvent();
-      tester.assertTerminalEvent();
-      tester.assertNoErrors();
-      tester.assertCompleted();
-      List<Response> responses = tester.getOnNextEvents();
-      assertNotNull(responses);
-      assertEquals(responses.size(), 1);
-      assertEquals(responses.get(0).getStatusCode(), 404);
-    } catch (Exception e) {
-      Thread.currentThread().interrupt();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io/ttfn"));
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertNoErrors();
+            tester.assertCompleted();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 404);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 
-  @Test
-  public void testObserveMultiple() {
-    final TestSubscriber<Response> tester = new TestSubscriber<>();
+    @Test(groups = "standalone")
+    public void testObserveMultiple() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
 
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
-      Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
-      Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
-      Observable<Response> all = Observable.merge(o1, o2, o3);
-      all.subscribe(tester);
-      tester.awaitTerminalEvent();
-      tester.assertTerminalEvent();
-      tester.assertNoErrors();
-      tester.assertCompleted();
-      List<Response> responses = tester.getOnNextEvents();
-      assertNotNull(responses);
-      assertEquals(responses.size(), 3);
-      for (Response response : responses) {
-        assertEquals(response.getStatusCode(), 200);
-      }
-    } catch (Exception e) {
-      Thread.currentThread().interrupt();
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
+            Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
+            Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
+            Observable<Response> all = Observable.merge(o1, o2, o3);
+            all.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertNoErrors();
+            tester.assertCompleted();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 3);
+            for (Response response : responses) {
+                assertEquals(response.getStatusCode(), 200);
+            }
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
     }
-  }
 }
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
index 90b2446b7..f7f5f9b62 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/single/AsyncHttpSingleTest.java
@@ -12,20 +12,6 @@
  */
 package org.asynchttpclient.extras.rxjava.single;
 
-import org.asynchttpclient.*;
-import org.asynchttpclient.extras.rxjava.UnsubscribedException;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.InOrder;
-import org.testng.annotations.Test;
-import rx.Single;
-import rx.exceptions.CompositeException;
-import rx.observers.TestSubscriber;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicReference;
-
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
@@ -44,273 +30,299 @@
 import static org.mockito.Mockito.when;
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.extras.rxjava.UnsubscribedException;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.mockito.InOrder;
+import org.testng.annotations.Test;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+
+import rx.Single;
+import rx.exceptions.CompositeException;
+import rx.observers.TestSubscriber;
+
 public class AsyncHttpSingleTest {
 
-  @Test(expectedExceptions = {NullPointerException.class})
-  public void testFailsOnNullRequest() {
-    AsyncHttpSingle.create((BoundRequestBuilder) null);
-  }
+    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
+    public void testFailsOnNullRequest() {
+        AsyncHttpSingle.create((BoundRequestBuilder) null);
+    }
+
+    @Test(groups = "standalone", expectedExceptions = { NullPointerException.class })
+    public void testFailsOnNullHandlerSupplier() {
+        AsyncHttpSingle.create(mock(BoundRequestBuilder.class), null);
+    }
 
-  @Test(expectedExceptions = {NullPointerException.class})
-  public void testFailsOnNullHandlerSupplier() {
-    AsyncHttpSingle.create(mock(BoundRequestBuilder.class), null);
-  }
+    @Test(groups = "standalone")
+    public void testSuccessfulCompletion() throws Exception {
 
-  @Test
-  public void testSuccessfulCompletion() throws Exception {
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        when(handler.onCompleted()).thenReturn(handler);
 
-    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-    when(handler.onCompleted()).thenReturn(handler);
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            try {
+                assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
 
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      try {
-        assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
+                bridge.onStatusReceived(null);
+                verify(handler).onStatusReceived(null);
 
-        bridge.onStatusReceived(null);
-        verify(handler).onStatusReceived(null);
+                bridge.onHeadersReceived(null);
+                verify(handler).onHeadersReceived(null);
 
-        bridge.onHeadersReceived(null);
-        verify(handler).onHeadersReceived(null);
+                bridge.onBodyPartReceived(null);
+                verify(handler).onBodyPartReceived(null);
 
-        bridge.onBodyPartReceived(null);
-        verify(handler).onBodyPartReceived(null);
+                bridge.onTrailingHeadersReceived(null);
+                verify(handler).onTrailingHeadersReceived(null);
 
-        bridge.onTrailingHeadersReceived(null);
-        verify(handler).onTrailingHeadersReceived(null);
+                bridge.onCompleted();
+                verify(handler).onCompleted();
+            } catch (final Throwable t) {
+                bridge.onThrowable(t);
+            }
 
-        bridge.onCompleted();
-        verify(handler).onCompleted();
-      } catch (final Throwable t) {
-        bridge.onThrowable(t);
-      }
+            return mock(Future.class);
+        } , () -> handler);
+
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        underTest.subscribe(subscriber);
+
+        verifyNoMoreInteractions(handler);
+
+        subscriber.awaitTerminalEvent();
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoErrors();
+        subscriber.assertCompleted();
+        subscriber.assertValue(handler);
+    }
+
+    @Test(groups = "standalone")
+    public void testSuccessfulCompletionWithProgress() throws Exception {
+
+        @SuppressWarnings("unchecked")
+        final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
+        when(handler.onCompleted()).thenReturn(handler);
+        final InOrder inOrder = inOrder(handler);
+
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            try {
+                assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
+
+                final ProgressAsyncHandler<?> progressBridge = (ProgressAsyncHandler<?>) bridge;
+
+                progressBridge.onHeadersWritten();
+                inOrder.verify(handler).onHeadersWritten();
 
-      return mock(Future.class);
-    }, () -> handler);
+                progressBridge.onContentWriteProgress(60, 40, 100);
+                inOrder.verify(handler).onContentWriteProgress(60, 40, 100);
 
-    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-    underTest.subscribe(subscriber);
+                progressBridge.onContentWritten();
+                inOrder.verify(handler).onContentWritten();
 
-    verifyNoMoreInteractions(handler);
+                progressBridge.onStatusReceived(null);
+                inOrder.verify(handler).onStatusReceived(null);
 
-    subscriber.awaitTerminalEvent();
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoErrors();
-    subscriber.assertCompleted();
-    subscriber.assertValue(handler);
-  }
+                progressBridge.onHeadersReceived(null);
+                inOrder.verify(handler).onHeadersReceived(null);
 
-  @Test
-  public void testSuccessfulCompletionWithProgress() throws Exception {
+                progressBridge.onBodyPartReceived(null);
+                inOrder.verify(handler).onBodyPartReceived(null);
 
-    @SuppressWarnings("unchecked") final ProgressAsyncHandler<Object> handler = mock(ProgressAsyncHandler.class);
-    when(handler.onCompleted()).thenReturn(handler);
-    final InOrder inOrder = inOrder(handler);
+                bridge.onTrailingHeadersReceived(null);
+                verify(handler).onTrailingHeadersReceived(null);
 
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      try {
-        assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
+                progressBridge.onCompleted();
+                inOrder.verify(handler).onCompleted();
+            } catch (final Throwable t) {
+                bridge.onThrowable(t);
+            }
 
-        final ProgressAsyncHandler<?> progressBridge = (ProgressAsyncHandler<?>) bridge;
+            return mock(Future.class);
+        } , () -> handler);
 
-        progressBridge.onHeadersWritten();
-        inOrder.verify(handler).onHeadersWritten();
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        underTest.subscribe(subscriber);
 
-        progressBridge.onContentWriteProgress(60, 40, 100);
-        inOrder.verify(handler).onContentWriteProgress(60, 40, 100);
+        inOrder.verifyNoMoreInteractions();
 
-        progressBridge.onContentWritten();
-        inOrder.verify(handler).onContentWritten();
+        subscriber.awaitTerminalEvent();
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoErrors();
+        subscriber.assertCompleted();
+        subscriber.assertValue(handler);
+    }
+
+    @Test(groups = "standalone")
+    public void testNewRequestForEachSubscription() throws Exception {
+        final BoundRequestBuilder builder = mock(BoundRequestBuilder.class);
 
-        progressBridge.onStatusReceived(null);
-        inOrder.verify(handler).onStatusReceived(null);
+        final Single<?> underTest = AsyncHttpSingle.create(builder);
+        underTest.subscribe(new TestSubscriber<>());
+        underTest.subscribe(new TestSubscriber<>());
 
-        progressBridge.onHeadersReceived(null);
-        inOrder.verify(handler).onHeadersReceived(null);
+        verify(builder, times(2)).execute(any());
+        verifyNoMoreInteractions(builder);
+    }
 
-        progressBridge.onBodyPartReceived(null);
-        inOrder.verify(handler).onBodyPartReceived(null);
+    @Test(groups = "standalone")
+    public void testErrorPropagation() throws Exception {
 
-        bridge.onTrailingHeadersReceived(null);
-        verify(handler).onTrailingHeadersReceived(null);
+        final RuntimeException expectedException = new RuntimeException("expected");
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        when(handler.onCompleted()).thenReturn(handler);
+        final InOrder inOrder = inOrder(handler);
 
-        progressBridge.onCompleted();
-        inOrder.verify(handler).onCompleted();
-      } catch (final Throwable t) {
-        bridge.onThrowable(t);
-      }
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            try {
+                bridge.onStatusReceived(null);
+                inOrder.verify(handler).onStatusReceived(null);
 
-      return mock(Future.class);
-    }, () -> handler);
+                bridge.onHeadersReceived(null);
+                inOrder.verify(handler).onHeadersReceived(null);
 
-    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-    underTest.subscribe(subscriber);
+                bridge.onBodyPartReceived(null);
+                inOrder.verify(handler).onBodyPartReceived(null);
 
-    inOrder.verifyNoMoreInteractions();
+                bridge.onThrowable(expectedException);
+                inOrder.verify(handler).onThrowable(expectedException);
 
-    subscriber.awaitTerminalEvent();
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoErrors();
-    subscriber.assertCompleted();
-    subscriber.assertValue(handler);
-  }
+                // test that no further events are invoked after terminal events
+                bridge.onCompleted();
+                inOrder.verify(handler, never()).onCompleted();
+            } catch (final Throwable t) {
+                bridge.onThrowable(t);
+            }
 
-  @Test
-  public void testNewRequestForEachSubscription() {
-    final BoundRequestBuilder builder = mock(BoundRequestBuilder.class);
+            return mock(Future.class);
+        } , () -> handler);
 
-    final Single<?> underTest = AsyncHttpSingle.create(builder);
-    underTest.subscribe(new TestSubscriber<>());
-    underTest.subscribe(new TestSubscriber<>());
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        underTest.subscribe(subscriber);
 
-    verify(builder, times(2)).execute(any());
-    verifyNoMoreInteractions(builder);
-  }
+        inOrder.verifyNoMoreInteractions();
 
-  @Test
-  public void testErrorPropagation() throws Exception {
+        subscriber.awaitTerminalEvent();
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoValues();
+        subscriber.assertError(expectedException);
+    }
 
-    final RuntimeException expectedException = new RuntimeException("expected");
-    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-    when(handler.onCompleted()).thenReturn(handler);
-    final InOrder inOrder = inOrder(handler);
+    @Test(groups = "standalone")
+    public void testErrorInOnCompletedPropagation() throws Exception {
 
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      try {
-        bridge.onStatusReceived(null);
-        inOrder.verify(handler).onStatusReceived(null);
+        final RuntimeException expectedException = new RuntimeException("expected");
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        when(handler.onCompleted()).thenThrow(expectedException);
 
-        bridge.onHeadersReceived(null);
-        inOrder.verify(handler).onHeadersReceived(null);
-
-        bridge.onBodyPartReceived(null);
-        inOrder.verify(handler).onBodyPartReceived(null);
-
-        bridge.onThrowable(expectedException);
-        inOrder.verify(handler).onThrowable(expectedException);
-
-        // test that no further events are invoked after terminal events
-        bridge.onCompleted();
-        inOrder.verify(handler, never()).onCompleted();
-      } catch (final Throwable t) {
-        bridge.onThrowable(t);
-      }
-
-      return mock(Future.class);
-    }, () -> handler);
-
-    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-    underTest.subscribe(subscriber);
-
-    inOrder.verifyNoMoreInteractions();
-
-    subscriber.awaitTerminalEvent();
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoValues();
-    subscriber.assertError(expectedException);
-  }
-
-  @Test
-  public void testErrorInOnCompletedPropagation() throws Exception {
-
-    final RuntimeException expectedException = new RuntimeException("expected");
-    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-    when(handler.onCompleted()).thenThrow(expectedException);
-
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      try {
-        bridge.onCompleted();
-        return mock(Future.class);
-      } catch (final Throwable t) {
-        throw new AssertionError(t);
-      }
-    }, () -> handler);
-
-    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-    underTest.subscribe(subscriber);
-
-    verify(handler).onCompleted();
-    verifyNoMoreInteractions(handler);
-
-    subscriber.awaitTerminalEvent();
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoValues();
-    subscriber.assertError(expectedException);
-  }
-
-  @Test
-  public void testErrorInOnThrowablePropagation() {
-
-    final RuntimeException processingException = new RuntimeException("processing");
-    final RuntimeException thrownException = new RuntimeException("thrown");
-    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-    doThrow(thrownException).when(handler).onThrowable(processingException);
-
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      try {
-        bridge.onThrowable(processingException);
-        return mock(Future.class);
-      } catch (final Throwable t) {
-        throw new AssertionError(t);
-      }
-    }, () -> handler);
-
-    final TestSubscriber<Object> subscriber = new TestSubscriber<>();
-    underTest.subscribe(subscriber);
-
-    verify(handler).onThrowable(processingException);
-    verifyNoMoreInteractions(handler);
-
-    subscriber.awaitTerminalEvent();
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoValues();
-
-    final List<Throwable> errorEvents = subscriber.getOnErrorEvents();
-    assertEquals(errorEvents.size(), 1);
-    assertThat(errorEvents.get(0), is(instanceOf(CompositeException.class)));
-    final CompositeException error = (CompositeException) errorEvents.get(0);
-    assertEquals(error.getExceptions(), Arrays.asList(processingException, thrownException));
-  }
-
-  @Test
-  public void testAbort() throws Exception {
-    final TestSubscriber<Response> subscriber = new TestSubscriber<>();
-
-    try (AsyncHttpClient client = asyncHttpClient()) {
-      final Single<Response> underTest = AsyncHttpSingle.create(client.prepareGet("http://gatling.io"),
-              () -> new AsyncCompletionHandlerBase() {
-                @Override
-                public State onStatusReceived(HttpResponseStatus status) {
-                  return State.ABORT;
-                }
-              });
-
-      underTest.subscribe(subscriber);
-      subscriber.awaitTerminalEvent();
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            try {
+                bridge.onCompleted();
+                return mock(Future.class);
+            } catch (final Throwable t) {
+                throw new AssertionError(t);
+            }
+        } , () -> handler);
+
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        underTest.subscribe(subscriber);
+
+        verify(handler).onCompleted();
+        verifyNoMoreInteractions(handler);
+
+        subscriber.awaitTerminalEvent();
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoValues();
+        subscriber.assertError(expectedException);
+    }
+
+    @Test(groups = "standalone")
+    public void testErrorInOnThrowablePropagation() throws Exception {
+
+        final RuntimeException processingException = new RuntimeException("processing");
+        final RuntimeException thrownException = new RuntimeException("thrown");
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        doThrow(thrownException).when(handler).onThrowable(processingException);
+
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            try {
+                bridge.onThrowable(processingException);
+                return mock(Future.class);
+            } catch (final Throwable t) {
+                throw new AssertionError(t);
+            }
+        } , () -> handler);
+
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        underTest.subscribe(subscriber);
+
+        verify(handler).onThrowable(processingException);
+        verifyNoMoreInteractions(handler);
+
+        subscriber.awaitTerminalEvent();
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoValues();
+
+        final List<Throwable> errorEvents = subscriber.getOnErrorEvents();
+        assertEquals(errorEvents.size(), 1);
+        assertThat(errorEvents.get(0), is(instanceOf(CompositeException.class)));
+        final CompositeException error = (CompositeException) errorEvents.get(0);
+        assertEquals(error.getExceptions(), Arrays.asList(processingException, thrownException));
     }
 
-    subscriber.assertTerminalEvent();
-    subscriber.assertNoErrors();
-    subscriber.assertCompleted();
-    subscriber.assertValue(null);
-  }
-
-  @Test
-  public void testUnsubscribe() throws Exception {
-    @SuppressWarnings("unchecked") final AsyncHandler<Object> handler = mock(AsyncHandler.class);
-    final Future<?> future = mock(Future.class);
-    final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
-
-    final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
-      bridgeRef.set(bridge);
-      return future;
-    }, () -> handler);
-
-    underTest.subscribe().unsubscribe();
-    verify(future).cancel(true);
-    verifyZeroInteractions(handler);
-
-    assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
-    verify(handler).onThrowable(isA(UnsubscribedException.class));
-    verifyNoMoreInteractions(handler);
-  }
+    @Test(groups = "standalone")
+    public void testAbort() throws Exception {
+        final TestSubscriber<Response> subscriber = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            final Single<Response> underTest = AsyncHttpSingle.create(client.prepareGet("http://gatling.io"),
+                    () -> new AsyncCompletionHandlerBase() {
+                        @Override
+                        public State onStatusReceived(HttpResponseStatus status) {
+                            return State.ABORT;
+                        }
+                    });
+
+            underTest.subscribe(subscriber);
+            subscriber.awaitTerminalEvent();
+        }
+
+        subscriber.assertTerminalEvent();
+        subscriber.assertNoErrors();
+        subscriber.assertCompleted();
+        subscriber.assertValue(null);
+    }
+
+    @Test(groups = "standalone")
+    public void testUnsubscribe() throws Exception {
+        @SuppressWarnings("unchecked")
+        final AsyncHandler<Object> handler = mock(AsyncHandler.class);
+        final Future<?> future = mock(Future.class);
+        final AtomicReference<AsyncHandler<?>> bridgeRef = new AtomicReference<>();
+
+        final Single<?> underTest = AsyncHttpSingle.create(bridge -> {
+            bridgeRef.set(bridge);
+            return future;
+        } , () -> handler);
+
+        underTest.subscribe().unsubscribe();
+        verify(future).cancel(true);
+        verifyZeroInteractions(handler);
+
+        assertThat(bridgeRef.get().onStatusReceived(null), is(AsyncHandler.State.ABORT));
+        verify(handler).onThrowable(isA(UnsubscribedException.class));
+        verifyNoMoreInteractions(handler);
+    }
 }
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 1342240e8..434e67a95 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <artifactId>async-http-client-extras-rxjava2</artifactId>
-  <name>Asynchronous Http Client RxJava2 Extras</name>
-  <description>The Async Http Client RxJava2 Extras.</description>
-  <dependencies>
-    <dependency>
-      <groupId>io.reactivex.rxjava2</groupId>
-      <artifactId>rxjava</artifactId>
-    </dependency>
-  </dependencies>
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <groupId>org.asynchttpclient</groupId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <artifactId>async-http-client-extras-rxjava2</artifactId>
+    <name>Asynchronous Http Client RxJava2 Extras</name>
+    <description>The Async Http Client RxJava2 Extras.</description>
+    <dependencies>
+        <dependency>
+            <groupId>io.reactivex.rxjava2</groupId>
+            <artifactId>rxjava</artifactId>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
index d582e3f9b..9f154bf6c 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClient.java
@@ -13,9 +13,11 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
-import io.reactivex.Maybe;
-import io.reactivex.MaybeEmitter;
-import io.reactivex.disposables.Disposables;
+import static java.util.Objects.requireNonNull;
+
+import java.util.concurrent.Future;
+import java.util.function.Supplier;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
@@ -23,56 +25,63 @@
 import org.asynchttpclient.extras.rxjava2.maybe.ProgressAsyncMaybeEmitterBridge;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
-import java.util.concurrent.Future;
-import java.util.function.Supplier;
-
-import static java.util.Objects.requireNonNull;
+import io.reactivex.Maybe;
+import io.reactivex.MaybeEmitter;
+import io.reactivex.disposables.Disposables;
 
 /**
  * Straight forward default implementation of the {@code RxHttpClient} interface.
  */
 public class DefaultRxHttpClient implements RxHttpClient {
 
-  private final AsyncHttpClient asyncHttpClient;
+    private final AsyncHttpClient asyncHttpClient;
 
-  /**
-   * Returns a new {@code DefaultRxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
-   *
-   * @param asyncHttpClient the Async HTTP Client instance to be used
-   * @throws NullPointerException if {@code asyncHttpClient} is {@code null}
-   */
-  public DefaultRxHttpClient(AsyncHttpClient asyncHttpClient) {
-    this.asyncHttpClient = requireNonNull(asyncHttpClient);
-  }
-
-  @Override
-  public <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier) {
-    requireNonNull(request);
-    requireNonNull(handlerSupplier);
+    /**
+     * Returns a new {@code DefaultRxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
+     *
+     * @param asyncHttpClient
+     *            the Async HTTP Client instance to be used
+     *
+     * @throws NullPointerException
+     *             if {@code asyncHttpClient} is {@code null}
+     */
+    public DefaultRxHttpClient(AsyncHttpClient asyncHttpClient) {
+        this.asyncHttpClient = requireNonNull(asyncHttpClient);
+    }
 
-    return Maybe.create(emitter -> {
-      final AsyncHandler<?> bridge = createBridge(emitter, handlerSupplier.get());
-      final Future<?> responseFuture = asyncHttpClient.executeRequest(request, bridge);
-      emitter.setDisposable(Disposables.fromFuture(responseFuture));
-    });
-  }
+    @Override
+    public <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier) {
+        requireNonNull(request);
+        requireNonNull(handlerSupplier);
 
-  /**
-   * Creates an {@code AsyncHandler} that bridges events from the given {@code handler} to the given {@code emitter}
-   * and cancellation/disposal in the other direction.
-   *
-   * @param <T>     the result type produced by {@code handler} and emitted by {@code emitter}
-   * @param emitter the RxJava emitter instance that receives results upon completion and will be queried for disposal
-   *                during event processing
-   * @param handler the {@code AsyncHandler} instance that receives downstream events and produces the result that will be
-   *                emitted upon request completion
-   * @return the bridge handler
-   */
-  protected <T> AsyncHandler<?> createBridge(MaybeEmitter<T> emitter, AsyncHandler<T> handler) {
-    if (handler instanceof ProgressAsyncHandler) {
-      return new ProgressAsyncMaybeEmitterBridge<>(emitter, (ProgressAsyncHandler<? extends T>) handler);
+        return Maybe.create(emitter -> {
+            final AsyncHandler<?> bridge = createBridge(emitter, handlerSupplier.get());
+            final Future<?> responseFuture = asyncHttpClient.executeRequest(request, bridge);
+            emitter.setDisposable(Disposables.fromFuture(responseFuture));
+        });
     }
 
-    return new MaybeAsyncHandlerBridge<>(emitter, handler);
-  }
+    /**
+     * Creates an {@code AsyncHandler} that bridges events from the given {@code handler} to the given {@code emitter}
+     * and cancellation/disposal in the other direction.
+     *
+     * @param <T>
+     *            the result type produced by {@code handler} and emitted by {@code emitter}
+     *
+     * @param emitter
+     *            the RxJava emitter instance that receives results upon completion and will be queried for disposal
+     *            during event processing
+     * @param handler
+     *            the {@code AsyncHandler} instance that receives downstream events and produces the result that will be
+     *            emitted upon request completion
+     *
+     * @return the bridge handler
+     */
+    protected <T> AsyncHandler<?> createBridge(MaybeEmitter<T> emitter, AsyncHandler<T> handler) {
+        if (handler instanceof ProgressAsyncHandler) {
+            return new ProgressAsyncMaybeEmitterBridge<>(emitter, (ProgressAsyncHandler<? extends T>) handler);
+        }
+
+        return new MaybeAsyncHandlerBridge<>(emitter, handler);
+    }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
index dfaaf2cf8..8113d12e8 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/DisposedException.java
@@ -19,9 +19,9 @@
  * Indicates that the HTTP request has been disposed asynchronously via RxJava.
  */
 public class DisposedException extends CancellationException {
-  private static final long serialVersionUID = -5885577182105850384L;
+    private static final long serialVersionUID = -5885577182105850384L;
 
-  public DisposedException(String message) {
-    super(message);
-  }
+    public DisposedException(String message) {
+        super(message);
+    }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
index bf2fa3916..766de8a76 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/RxHttpClient.java
@@ -13,11 +13,16 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
-import io.reactivex.Maybe;
-import org.asynchttpclient.*;
-
 import java.util.function.Supplier;
 
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+
+import io.reactivex.Maybe;
+
 /**
  * Prepares HTTP requests by wrapping them into RxJava 2 {@code Maybe} instances.
  *
@@ -25,40 +30,55 @@
  */
 public interface RxHttpClient {
 
-  /**
-   * Returns a new {@code RxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
-   *
-   * @param asyncHttpClient the Async HTTP Client instance to be used
-   * @return a new {@code RxHttpClient} instance
-   * @throws NullPointerException if {@code asyncHttpClient} is {@code null}
-   */
-  static RxHttpClient create(AsyncHttpClient asyncHttpClient) {
-    return new DefaultRxHttpClient(asyncHttpClient);
-  }
+    /**
+     * Returns a new {@code RxHttpClient} instance that uses the given {@code asyncHttpClient} under the hoods.
+     *
+     * @param asyncHttpClient
+     *            the Async HTTP Client instance to be used
+     *
+     * @return a new {@code RxHttpClient} instance
+     *
+     * @throws NullPointerException
+     *             if {@code asyncHttpClient} is {@code null}
+     */
+    static RxHttpClient create(AsyncHttpClient asyncHttpClient) {
+        return new DefaultRxHttpClient(asyncHttpClient);
+    }
 
-  /**
-   * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
-   * be executed and its response will be emitted.
-   *
-   * @param request the request that is to be executed
-   * @return a {@code Maybe} that executes {@code request} upon subscription and emits the response
-   * @throws NullPointerException if {@code request} is {@code null}
-   */
-  default Maybe<Response> prepare(Request request) {
-    return prepare(request, AsyncCompletionHandlerBase::new);
-  }
+    /**
+     * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
+     * be executed and its response will be emitted.
+     *
+     * @param request
+     *            the request that is to be executed
+     *
+     * @return a {@code Maybe} that executes {@code request} upon subscription and emits the response
+     *
+     * @throws NullPointerException
+     *             if {@code request} is {@code null}
+     */
+    default Maybe<Response> prepare(Request request) {
+        return prepare(request, AsyncCompletionHandlerBase::new);
+    }
 
-  /**
-   * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
-   * be executed and the results of {@code AsyncHandlers} obtained from {@code handlerSupplier} will be emitted.
-   *
-   * @param <T>             the result type produced by handlers produced by {@code handlerSupplier} and emitted by the returned
-   *                        {@code Maybe} instance
-   * @param request         the request that is to be executed
-   * @param handlerSupplier supplies the desired {@code AsyncHandler} instances that are used to produce results
-   * @return a {@code Maybe} that executes {@code request} upon subscription and that emits the results produced by
-   * the supplied handers
-   * @throws NullPointerException if at least one of the parameters is {@code null}
-   */
-  <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier);
+    /**
+     * Prepares the given {@code request}. For each subscription to the returned {@code Maybe}, a new HTTP request will
+     * be executed and the results of {@code AsyncHandlers} obtained from {@code handlerSupplier} will be emitted.
+     *
+     * @param <T>
+     *            the result type produced by handlers produced by {@code handlerSupplier} and emitted by the returned
+     *            {@code Maybe} instance
+     *
+     * @param request
+     *            the request that is to be executed
+     * @param handlerSupplier
+     *            supplies the desired {@code AsyncHandler} instances that are used to produce results
+     *
+     * @return a {@code Maybe} that executes {@code request} upon subscription and that emits the results produced by
+     *         the supplied handers
+     *
+     * @throws NullPointerException
+     *             if at least one of the parameters is {@code null}
+     */
+    <T> Maybe<T> prepare(Request request, Supplier<? extends AsyncHandler<T>> handlerSupplier);
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
index bf366f820..6386442aa 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
@@ -13,10 +13,15 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import static java.util.Objects.requireNonNull;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.exceptions.Exceptions;
+
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
@@ -24,164 +29,160 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static java.util.Objects.requireNonNull;
-
 /**
  * Abstract base class that bridges events between the {@code Maybe} reactive base type and {@code AsyncHandlers}.
- * <p>
+ *
  * When an event is received, it's first checked if the Rx stream has been disposed asynchronously. If so, request
  * processing is {@linkplain #disposed() aborted}, otherwise, the event is forwarded to the {@linkplain #delegate()
  * wrapped handler}.
- * <p>
+ *
  * When the request is {@link AsyncHandler#onCompleted() completed}, the result produced by the wrapped instance is
  * forwarded to the {@code Maybe}: If the result is {@code null}, {@link MaybeEmitter#onComplete()} is invoked,
  * {@link MaybeEmitter#onSuccess(Object)} otherwise.
- * <p>
+ *
  * Any errors during request processing are forwarded via {@link MaybeEmitter#onError(Throwable)}.
  *
- * @param <T> the result type produced by the wrapped {@code AsyncHandler} and emitted via RxJava
+ * @param <T>
+ *            the result type produced by the wrapped {@code AsyncHandler} and emitted via RxJava
  */
 public abstract class AbstractMaybeAsyncHandlerBridge<T> implements AsyncHandler<Void> {
 
-  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMaybeAsyncHandlerBridge.class);
-
-  private static volatile DisposedException sharedDisposed;
-
-  /**
-   * The Rx callback object that receives downstream events and will be queried for its
-   * {@link MaybeEmitter#isDisposed() disposed state} when Async HTTP Client callbacks are invoked.
-   */
-  protected final MaybeEmitter<T> emitter;
-
-  /**
-   * Indicates if the delegate has already received a terminal event.
-   */
-  private final AtomicBoolean delegateTerminated = new AtomicBoolean();
-
-  protected AbstractMaybeAsyncHandlerBridge(MaybeEmitter<T> emitter) {
-    this.emitter = requireNonNull(emitter);
-  }
-
-  @Override
-  public final State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-    return emitter.isDisposed() ? disposed() : delegate().onBodyPartReceived(content);
-  }
-
-  @Override
-  public final State onStatusReceived(HttpResponseStatus status) throws Exception {
-    return emitter.isDisposed() ? disposed() : delegate().onStatusReceived(status);
-  }
-
-  @Override
-  public final State onHeadersReceived(HttpHeaders headers) throws Exception {
-    return emitter.isDisposed() ? disposed() : delegate().onHeadersReceived(headers);
-  }
-
-  @Override
-  public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-    return emitter.isDisposed() ? disposed() : delegate().onTrailingHeadersReceived(headers);
-  }
-
-  /**
-   * {@inheritDoc}
-   * <p>
-   * <p>
-   * The value returned by the wrapped {@code AsyncHandler} won't be returned by this method, but emtited via RxJava.
-   * </p>
-   *
-   * @return always {@code null}
-   */
-  @Override
-  public final Void onCompleted() {
-    if (delegateTerminated.getAndSet(true)) {
-      return null;
+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractMaybeAsyncHandlerBridge.class);
+
+    private static volatile DisposedException sharedDisposed;
+
+    /**
+     * The Rx callback object that receives downstream events and will be queried for its
+     * {@link MaybeEmitter#isDisposed() disposed state} when Async HTTP Client callbacks are invoked.
+     */
+    protected final MaybeEmitter<T> emitter;
+
+    /**
+     * Indicates if the delegate has already received a terminal event.
+     */
+    private final AtomicBoolean delegateTerminated = new AtomicBoolean();
+
+    protected AbstractMaybeAsyncHandlerBridge(MaybeEmitter<T> emitter) {
+        this.emitter = requireNonNull(emitter);
+    }
+
+    @Override
+    public final State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+        return emitter.isDisposed() ? disposed() : delegate().onBodyPartReceived(content);
     }
 
-    final T result;
-    try {
-      result = delegate().onCompleted();
-    } catch (final Throwable t) {
-      emitOnError(t);
-      return null;
+    @Override
+    public final State onStatusReceived(HttpResponseStatus status) throws Exception {
+        return emitter.isDisposed() ? disposed() : delegate().onStatusReceived(status);
     }
 
-    if (!emitter.isDisposed()) {
-      if (result == null) {
-        emitter.onComplete();
-      } else {
-        emitter.onSuccess(result);
-      }
+    @Override
+    public final State onHeadersReceived(HttpHeaders headers) throws Exception {
+        return emitter.isDisposed() ? disposed() : delegate().onHeadersReceived(headers);
     }
 
-    return null;
-  }
-
-  /**
-   * {@inheritDoc}
-   * <p>
-   * <p>
-   * The exception will first be propagated to the wrapped {@code AsyncHandler}, then emitted via RxJava. If the
-   * invocation of the delegate itself throws an exception, both the original exception and the follow-up exception
-   * will be wrapped into RxJava's {@code CompositeException} and then be emitted.
-   * </p>
-   */
-  @Override
-  public final void onThrowable(Throwable t) {
-    if (delegateTerminated.getAndSet(true)) {
-      return;
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        return emitter.isDisposed() ? disposed() : delegate().onTrailingHeadersReceived(headers);
     }
 
-    Throwable error = t;
-    try {
-      delegate().onThrowable(t);
-    } catch (final Throwable x) {
-      error = new CompositeException(Arrays.asList(t, x));
+    /**
+     * {@inheritDoc}
+     *
+     * <p>
+     * The value returned by the wrapped {@code AsyncHandler} won't be returned by this method, but emtited via RxJava.
+     * </p>
+     *
+     * @return always {@code null}
+     */
+    @Override
+    public final Void onCompleted() {
+        if (delegateTerminated.getAndSet(true)) {
+            return null;
+        }
+
+        final T result;
+        try {
+            result = delegate().onCompleted();
+        } catch (final Throwable t) {
+            emitOnError(t);
+            return null;
+        }
+
+        if (!emitter.isDisposed()) {
+            if (result == null) {
+                emitter.onComplete();
+            } else {
+                emitter.onSuccess(result);
+            }
+        }
+
+        return null;
     }
 
-    emitOnError(error);
-  }
-
-  /**
-   * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
-   * the {@link #delegate() delegate} didn't already receive a terminal event,
-   * {@code AsyncHandler#onThrowable(Throwable) onThrowable} will be called with a {@link DisposedException}.
-   *
-   * @return always {@link State#ABORT}
-   */
-  protected final AsyncHandler.State disposed() {
-    if (!delegateTerminated.getAndSet(true)) {
-
-      DisposedException disposed = sharedDisposed;
-      if (disposed == null) {
-        disposed = new DisposedException("Subscription has been disposed.");
-        final StackTraceElement[] stackTrace = disposed.getStackTrace();
-        if (stackTrace.length > 0) {
-          disposed.setStackTrace(new StackTraceElement[]{stackTrace[0]});
+    /**
+     * {@inheritDoc}
+     *
+     * <p>
+     * The exception will first be propagated to the wrapped {@code AsyncHandler}, then emitted via RxJava. If the
+     * invocation of the delegate itself throws an exception, both the original exception and the follow-up exception
+     * will be wrapped into RxJava's {@code CompositeException} and then be emitted.
+     * </p>
+     */
+    @Override
+    public final void onThrowable(Throwable t) {
+        if (delegateTerminated.getAndSet(true)) {
+            return;
         }
 
-        sharedDisposed = disposed;
-      }
+        Throwable error = t;
+        try {
+            delegate().onThrowable(t);
+        } catch (final Throwable x) {
+            error = new CompositeException(Arrays.asList(t, x));
+        }
 
-      delegate().onThrowable(disposed);
+        emitOnError(error);
     }
 
-    return State.ABORT;
-  }
+    /**
+     * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
+     * the {@link #delegate() delegate} didn't already receive a terminal event,
+     * {@code AsyncHandler#onThrowable(Throwable) onThrowable} will be called with a {@link DisposedException}.
+     *
+     * @return always {@link State#ABORT}
+     */
+    protected final AsyncHandler.State disposed() {
+        if (!delegateTerminated.getAndSet(true)) {
+
+            DisposedException disposed = sharedDisposed;
+            if (disposed == null) {
+                disposed = new DisposedException("Subscription has been disposed.");
+                final StackTraceElement[] stackTrace = disposed.getStackTrace();
+                if (stackTrace.length > 0) {
+                    disposed.setStackTrace(new StackTraceElement[] { stackTrace[0] });
+                }
+
+                sharedDisposed = disposed;
+            }
+
+            delegate().onThrowable(disposed);
+        }
 
-  /**
-   * @return the wrapped {@code AsyncHandler} instance to which calls are delegated
-   */
-  protected abstract AsyncHandler<? extends T> delegate();
+        return State.ABORT;
+    }
 
-  private void emitOnError(Throwable error) {
-    Exceptions.throwIfFatal(error);
-    if (!emitter.isDisposed()) {
-      emitter.onError(error);
-    } else {
-      LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
+    /**
+     * @return the wrapped {@code AsyncHandler} instance to which calls are delegated
+     */
+    protected abstract AsyncHandler<? extends T> delegate();
+
+    private void emitOnError(Throwable error) {
+        Exceptions.throwIfFatal(error);
+        if (!emitter.isDisposed()) {
+            emitter.onError(error);
+        } else {
+            LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
+        }
     }
-  }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
index db41d1b8b..c68a10c38 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridge.java
@@ -13,37 +13,39 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import io.reactivex.MaybeEmitter;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
+import io.reactivex.MaybeEmitter;
+
 /**
  * An extension to {@code AbstractMaybeAsyncHandlerBridge} for {@code ProgressAsyncHandlers}.
  *
- * @param <T> the result type produced by the wrapped {@code ProgressAsyncHandler} and emitted via RxJava
+ * @param <T>
+ *            the result type produced by the wrapped {@code ProgressAsyncHandler} and emitted via RxJava
  */
 public abstract class AbstractMaybeProgressAsyncHandlerBridge<T> extends AbstractMaybeAsyncHandlerBridge<T>
         implements ProgressAsyncHandler<Void> {
 
-  protected AbstractMaybeProgressAsyncHandlerBridge(MaybeEmitter<T> emitter) {
-    super(emitter);
-  }
+    protected AbstractMaybeProgressAsyncHandlerBridge(MaybeEmitter<T> emitter) {
+        super(emitter);
+    }
 
-  @Override
-  public final State onHeadersWritten() {
-    return emitter.isDisposed() ? disposed() : delegate().onHeadersWritten();
-  }
+    @Override
+    public final State onHeadersWritten() {
+        return emitter.isDisposed() ? disposed() : delegate().onHeadersWritten();
+    }
 
-  @Override
-  public final State onContentWritten() {
-    return emitter.isDisposed() ? disposed() : delegate().onContentWritten();
-  }
+    @Override
+    public final State onContentWritten() {
+        return emitter.isDisposed() ? disposed() : delegate().onContentWritten();
+    }
 
-  @Override
-  public final State onContentWriteProgress(long amount, long current, long total) {
-    return emitter.isDisposed() ? disposed() : delegate().onContentWriteProgress(amount, current, total);
-  }
+    @Override
+    public final State onContentWriteProgress(long amount, long current, long total) {
+        return emitter.isDisposed() ? disposed() : delegate().onContentWriteProgress(amount, current, total);
+    }
 
-  @Override
-  protected abstract ProgressAsyncHandler<? extends T> delegate();
+    @Override
+    protected abstract ProgressAsyncHandler<? extends T> delegate();
 
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
index d8b7e3efe..b4af729aa 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/MaybeAsyncHandlerBridge.java
@@ -13,22 +13,23 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import io.reactivex.MaybeEmitter;
+import static java.util.Objects.requireNonNull;
+
 import org.asynchttpclient.AsyncHandler;
 
-import static java.util.Objects.requireNonNull;
+import io.reactivex.MaybeEmitter;
 
 public final class MaybeAsyncHandlerBridge<T> extends AbstractMaybeAsyncHandlerBridge<T> {
 
-  private final AsyncHandler<? extends T> delegate;
+    private final AsyncHandler<? extends T> delegate;
 
-  public MaybeAsyncHandlerBridge(MaybeEmitter<T> emitter, AsyncHandler<? extends T> delegate) {
-    super(emitter);
-    this.delegate = requireNonNull(delegate);
-  }
+    public MaybeAsyncHandlerBridge(MaybeEmitter<T> emitter, AsyncHandler<? extends T> delegate) {
+        super(emitter);
+        this.delegate = requireNonNull(delegate);
+    }
 
-  @Override
-  protected AsyncHandler<? extends T> delegate() {
-    return delegate;
-  }
+    @Override
+    protected AsyncHandler<? extends T> delegate() {
+        return delegate;
+    }
 }
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
index 0b0881d5a..4e54a823d 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/ProgressAsyncMaybeEmitterBridge.java
@@ -13,22 +13,23 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import io.reactivex.MaybeEmitter;
+import static java.util.Objects.requireNonNull;
+
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 
-import static java.util.Objects.requireNonNull;
+import io.reactivex.MaybeEmitter;
 
 public final class ProgressAsyncMaybeEmitterBridge<T> extends AbstractMaybeProgressAsyncHandlerBridge<T> {
 
-  private final ProgressAsyncHandler<? extends T> delegate;
+    private final ProgressAsyncHandler<? extends T> delegate;
 
-  public ProgressAsyncMaybeEmitterBridge(MaybeEmitter<T> emitter, ProgressAsyncHandler<? extends T> delegate) {
-    super(emitter);
-    this.delegate = requireNonNull(delegate);
-  }
+    public ProgressAsyncMaybeEmitterBridge(MaybeEmitter<T> emitter, ProgressAsyncHandler<? extends T> delegate) {
+        super(emitter);
+        this.delegate = requireNonNull(delegate);
+    }
 
-  @Override
-  protected ProgressAsyncHandler<? extends T> delegate() {
-    return delegate;
-  }
+    @Override
+    protected ProgressAsyncHandler<? extends T> delegate() {
+        return delegate;
+    }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
index 198f4749f..77f055373 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/DefaultRxHttpClientTest.java
@@ -13,19 +13,6 @@
  */
 package org.asynchttpclient.extras.rxjava2;
 
-import io.reactivex.Maybe;
-import io.reactivex.observers.TestObserver;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.mockito.*;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-import java.util.function.Supplier;
-
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
@@ -39,127 +26,143 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
+import java.util.function.Supplier;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import io.reactivex.Maybe;
+import io.reactivex.observers.TestObserver;
 
 public class DefaultRxHttpClientTest {
 
-  @Mock
-  private AsyncHttpClient asyncHttpClient;
-
-  @Mock
-  private Request request;
-
-  @Mock
-  private Supplier<AsyncHandler<Object>> handlerSupplier;
-
-  @Mock
-  private AsyncHandler<Object> handler;
-
-  @Mock
-  private ProgressAsyncHandler<Object> progressHandler;
-
-  @Captor
-  private ArgumentCaptor<AsyncHandler<Object>> handlerCaptor;
-
-  @Mock
-  private ListenableFuture<Object> resposeFuture;
-
-  @InjectMocks
-  private DefaultRxHttpClient underTest;
-
-  @BeforeMethod
-  public void initializeTest() {
-    underTest = null; // we want a fresh instance for each test
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test(expectedExceptions = NullPointerException.class)
-  public void rejectsNullClient() {
-    new DefaultRxHttpClient(null);
-  }
-
-  @Test(expectedExceptions = NullPointerException.class)
-  public void rejectsNullRequest() {
-    underTest.prepare(null, handlerSupplier);
-  }
-
-  @Test(expectedExceptions = NullPointerException.class)
-  public void rejectsNullHandlerSupplier() {
-    underTest.prepare(request, null);
-  }
-
-  @Test
-  public void emitsNullPointerExceptionWhenNullHandlerIsSupplied() {
-    // given
-    given(handlerSupplier.get()).willReturn(null);
-    final TestObserver<Object> subscriber = new TestObserver<>();
-
-    // when
-    underTest.prepare(request, handlerSupplier).subscribe(subscriber);
-
-    // then
-    subscriber.assertTerminated();
-    subscriber.assertNoValues();
-    subscriber.assertError(NullPointerException.class);
-    then(handlerSupplier).should().get();
-    verifyNoMoreInteractions(handlerSupplier);
-  }
-
-  @Test
-  public void usesVanillaAsyncHandler() {
-    // given
-    given(handlerSupplier.get()).willReturn(handler);
-
-    // when
-    underTest.prepare(request, handlerSupplier).subscribe();
-
-    // then
-    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-    assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
-  }
-
-  @Test
-  public void usesProgressAsyncHandler() {
-    given(handlerSupplier.get()).willReturn(progressHandler);
-
-    // when
-    underTest.prepare(request, handlerSupplier).subscribe();
-
-    // then
-    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-    assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
-  }
-
-  @Test
-  public void callsSupplierForEachSubscription() {
-    // given
-    given(handlerSupplier.get()).willReturn(handler);
-    final Maybe<Object> prepared = underTest.prepare(request, handlerSupplier);
-
-    // when
-    prepared.subscribe();
-    prepared.subscribe();
-
-    // then
-    then(handlerSupplier).should(times(2)).get();
-  }
-
-  @Test
-  public void cancelsResponseFutureOnDispose() throws Exception {
-    given(handlerSupplier.get()).willReturn(handler);
-    given(asyncHttpClient.executeRequest(eq(request), any())).willReturn(resposeFuture);
-
-    /* when */
-    underTest.prepare(request, handlerSupplier).subscribe().dispose();
-
-    // then
-    then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
-    final AsyncHandler<Object> bridge = handlerCaptor.getValue();
-    then(resposeFuture).should().cancel(true);
-    verifyZeroInteractions(handler);
-    assertThat(bridge.onStatusReceived(null), is(AsyncHandler.State.ABORT));
-    verify(handler).onThrowable(isA(DisposedException.class));
-    verifyNoMoreInteractions(handler);
-  }
+    @Mock
+    private AsyncHttpClient asyncHttpClient;
+
+    @Mock
+    private Request request;
+
+    @Mock
+    private Supplier<AsyncHandler<Object>> handlerSupplier;
+
+    @Mock
+    private AsyncHandler<Object> handler;
+
+    @Mock
+    private ProgressAsyncHandler<Object> progressHandler;
+
+    @Captor
+    private ArgumentCaptor<AsyncHandler<Object>> handlerCaptor;
+
+    @Mock
+    private ListenableFuture<Object> resposeFuture;
+
+    @InjectMocks
+    private DefaultRxHttpClient underTest;
+
+    @BeforeMethod(groups = "standalone")
+    public void initializeTest() {
+        underTest = null; // we want a fresh instance for each test
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
+    public void rejectsNullClient() {
+        new DefaultRxHttpClient(null);
+    }
+
+    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
+    public void rejectsNullRequest() {
+        underTest.prepare(null, handlerSupplier);
+    }
+
+    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
+    public void rejectsNullHandlerSupplier() {
+        underTest.prepare(request, null);
+    }
+
+    @Test(groups = "standalone")
+    public void emitsNullPointerExceptionWhenNullHandlerIsSupplied() {
+        // given
+        given(handlerSupplier.get()).willReturn(null);
+        final TestObserver<Object> subscriber = new TestObserver<>();
+
+        // when
+        underTest.prepare(request, handlerSupplier).subscribe(subscriber);
+
+        // then
+        subscriber.assertTerminated();
+        subscriber.assertNoValues();
+        subscriber.assertError(NullPointerException.class);
+        then(handlerSupplier).should().get();
+        verifyNoMoreInteractions(handlerSupplier);
+    }
+
+    @Test(groups = "standalone")
+    public void usesVanillaAsyncHandler() throws Exception {
+        // given
+        given(handlerSupplier.get()).willReturn(handler);
+
+        // when
+        underTest.prepare(request, handlerSupplier).subscribe();
+
+        // then
+        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+        assertThat(bridge, is(not(instanceOf(ProgressAsyncHandler.class))));
+    }
+
+    @Test(groups = "standalone")
+    public void usesProgressAsyncHandler() throws Exception {
+        given(handlerSupplier.get()).willReturn(progressHandler);
+
+        // when
+        underTest.prepare(request, handlerSupplier).subscribe();
+
+        // then
+        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+        assertThat(bridge, is(instanceOf(ProgressAsyncHandler.class)));
+    }
+
+    @Test(groups = "standalone")
+    public void callsSupplierForEachSubscription() throws Exception {
+        // given
+        given(handlerSupplier.get()).willReturn(handler);
+        final Maybe<Object> prepared = underTest.prepare(request, handlerSupplier);
+
+        // when
+        prepared.subscribe();
+        prepared.subscribe();
+
+        // then
+        then(handlerSupplier).should(times(2)).get();
+    }
+
+    @Test(groups = "standalone")
+    public void cancelsResponseFutureOnDispose() throws Exception {
+        given(handlerSupplier.get()).willReturn(handler);
+        given(asyncHttpClient.executeRequest(eq(request), any())).willReturn(resposeFuture);
+
+        /* when */ underTest.prepare(request, handlerSupplier).subscribe().dispose();
+
+        // then
+        then(asyncHttpClient).should().executeRequest(eq(request), handlerCaptor.capture());
+        final AsyncHandler<Object> bridge = handlerCaptor.getValue();
+        then(resposeFuture).should().cancel(true);
+        verifyZeroInteractions(handler);
+        assertThat(bridge.onStatusReceived(null), is(AsyncHandler.State.ABORT));
+        verify(handler).onThrowable(isA(DisposedException.class));
+        verifyNoMoreInteractions(handler);
+    }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
index b8a9b3b4e..5c67bc1ce 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
@@ -13,255 +13,234 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.sameInstance;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.then;
+import static org.mockito.BDDMockito.willThrow;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Callable;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
-import org.mockito.*;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Callable;
+public class AbstractMaybeAsyncHandlerBridgeTest {
 
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.*;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
+    @Mock
+    MaybeEmitter<Object> emitter;
 
-public class AbstractMaybeAsyncHandlerBridgeTest {
+    @Mock
+    AsyncHandler<Object> delegate;
+
+    @Mock
+    private HttpResponseStatus status;
+
+    @Mock
+    private HttpHeaders headers;
+
+    @Mock
+    private HttpResponseBodyPart bodyPart;
+
+    @Captor
+    private ArgumentCaptor<Throwable> throwable;
+
+    private AbstractMaybeAsyncHandlerBridge<Object> underTest;
+
+    @BeforeMethod
+    public void initializeTest() {
+        MockitoAnnotations.initMocks(this);
+        underTest = new UnderTest();
+    }
+
+    @Test
+    public void forwardsEvents() throws Exception {
+        given(delegate.onCompleted()).willReturn(this);
+
+        /* when */ underTest.onStatusReceived(status);
+        then(delegate).should().onStatusReceived(status);
+
+        /* when */ underTest.onHeadersReceived(headers);
+        then(delegate).should().onHeadersReceived(headers);
+
+        /* when */ underTest.onBodyPartReceived(bodyPart);
+        /* when */ underTest.onBodyPartReceived(bodyPart);
+        then(delegate).should(times(2)).onBodyPartReceived(bodyPart);
+
+        /* when */ underTest.onTrailingHeadersReceived(headers);
+        then(delegate).should().onTrailingHeadersReceived(headers);
+
+        /* when */ underTest.onCompleted();
+        then(delegate).should().onCompleted();
+        then(emitter).should().onSuccess(this);
+        /* then */ verifyNoMoreInteractions(delegate);
+    }
+
+    @Test
+    public void wontCallOnCompleteTwice() throws Exception {
+        InOrder inOrder = Mockito.inOrder(emitter);
+
+        /* when */ underTest.onCompleted();
+        /* then */ inOrder.verify(emitter).onComplete();
+
+        /* when */ underTest.onCompleted();
+        /* then */ inOrder.verify(emitter, never()).onComplete();
+    }
+
+    @Test
+    public void wontCallOnErrorTwice() throws Exception {
+        InOrder inOrder = Mockito.inOrder(emitter);
+
+        /* when */ underTest.onThrowable(null);
+        /* then */ inOrder.verify(emitter).onError(null);
+
+        /* when */ underTest.onThrowable(new RuntimeException("unwanted"));
+        /* then */ inOrder.verify(emitter, never()).onError(any());
+    }
+
+    @Test
+    public void wontCallOnErrorAfterOnComplete() throws Exception {
+        /* when */ underTest.onCompleted();
+        then(emitter).should().onComplete();
+
+        /* when */ underTest.onThrowable(null);
+        then(emitter).should(never()).onError(any());
+    }
+
+    @Test
+    public void wontCallOnCompleteAfterOnError() throws Exception {
+        /* when */ underTest.onThrowable(null);
+        then(emitter).should().onError(null);
+
+        /* when */ underTest.onCompleted();
+        then(emitter).should(never()).onComplete();
+    }
+
+    @Test
+    public void wontCallOnCompleteAfterDisposal() throws Exception {
+        given(emitter.isDisposed()).willReturn(true);
+        /* when */ underTest.onCompleted();
+        /* then */ verify(emitter, never()).onComplete();
+    }
+
+    @Test
+    public void wontCallOnErrorAfterDisposal() throws Exception {
+        given(emitter.isDisposed()).willReturn(true);
+        /* when */ underTest.onThrowable(new RuntimeException("ignored"));
+        /* then */ verify(emitter, never()).onError(any());
+    }
+
+    @Test
+    public void handlesExceptionsWhileCompleting() throws Exception {
+        /* given */ final Throwable x = new RuntimeException("mocked error in delegate onCompleted()");
+        given(delegate.onCompleted()).willThrow(x);
+        /* when */ underTest.onCompleted();
+        then(emitter).should().onError(x);
+    }
+
+    @Test
+    public void handlesExceptionsWhileFailing() throws Exception {
+        // given
+        final Throwable initial = new RuntimeException("mocked error for onThrowable()");
+        final Throwable followup = new RuntimeException("mocked error in delegate onThrowable()");
+        willThrow(followup).given(delegate).onThrowable(initial);
+
+        /* when */ underTest.onThrowable(initial);
+
+        // then
+        then(emitter).should().onError(throwable.capture());
+        final Throwable thrown = throwable.getValue();
+        assertThat(thrown, is(instanceOf(CompositeException.class)));
+        assertThat(((CompositeException) thrown).getExceptions(), is(Arrays.asList(initial, followup)));
+    }
+
+    @Test
+    public void cachesDisposedException() throws Exception {
+        // when
+        new UnderTest().disposed();
+        new UnderTest().disposed();
+
+        // then
+        then(delegate).should(times(2)).onThrowable(throwable.capture());
+        final List<Throwable> errors = throwable.getAllValues();
+        final Throwable firstError = errors.get(0), secondError = errors.get(1);
+        assertThat(secondError, is(sameInstance(firstError)));
+        final StackTraceElement[] stackTrace = firstError.getStackTrace();
+        assertThat(stackTrace.length, is(1));
+        assertThat(stackTrace[0].getClassName(), is(AbstractMaybeAsyncHandlerBridge.class.getName()));
+        assertThat(stackTrace[0].getMethodName(), is("disposed"));
+    }
+
+    @DataProvider
+    public Object[][] httpEvents() {
+        return new Object[][] { //
+                { named("onStatusReceived", () -> underTest.onStatusReceived(status)) }, //
+                { named("onHeadersReceived", () -> underTest.onHeadersReceived(headers)) }, //
+                { named("onBodyPartReceived", () -> underTest.onBodyPartReceived(bodyPart)) }, //
+                { named("onTrailingHeadersReceived", () -> underTest.onTrailingHeadersReceived(headers)) }, //
+        };
+    }
+
+    @Test(dataProvider = "httpEvents")
+    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
+        given(emitter.isDisposed()).willReturn(true);
+
+        /* when */ final AsyncHandler.State firstState = httpEvent.call();
+        /* then */ assertThat(firstState, is(State.ABORT));
+        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+        /* when */ final AsyncHandler.State secondState = httpEvent.call();
+        /* then */ assertThat(secondState, is(State.ABORT));
+        /* then */ verifyNoMoreInteractions(delegate);
+    }
+
+    private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
+        UnderTest() {
+            super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
+        }
 
-  @Mock
-  MaybeEmitter<Object> emitter;
-
-  @Mock
-  AsyncHandler<Object> delegate;
-
-  @Mock
-  private HttpResponseStatus status;
-
-  @Mock
-  private HttpHeaders headers;
-
-  @Mock
-  private HttpResponseBodyPart bodyPart;
-
-  @Captor
-  private ArgumentCaptor<Throwable> throwable;
-
-  private AbstractMaybeAsyncHandlerBridge<Object> underTest;
-
-  private static <T> Callable<T> named(String name, Callable<T> callable) {
-    return new Callable<T>() {
-      @Override
-      public String toString() {
-        return name;
-      }
-
-      @Override
-      public T call() throws Exception {
-        return callable.call();
-      }
-    };
-  }
-
-  @BeforeMethod
-  public void initializeTest() {
-    MockitoAnnotations.initMocks(this);
-    underTest = new UnderTest();
-  }
-
-  @Test
-  public void forwardsEvents() throws Exception {
-    given(delegate.onCompleted()).willReturn(this);
-
-    /* when */
-    underTest.onStatusReceived(status);
-    then(delegate).should().onStatusReceived(status);
-
-    /* when */
-    underTest.onHeadersReceived(headers);
-    then(delegate).should().onHeadersReceived(headers);
-
-    /* when */
-    underTest.onBodyPartReceived(bodyPart);
-    /* when */
-    underTest.onBodyPartReceived(bodyPart);
-    then(delegate).should(times(2)).onBodyPartReceived(bodyPart);
-
-    /* when */
-    underTest.onTrailingHeadersReceived(headers);
-    then(delegate).should().onTrailingHeadersReceived(headers);
-
-    /* when */
-    underTest.onCompleted();
-    then(delegate).should().onCompleted();
-    then(emitter).should().onSuccess(this);
-    /* then */
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test
-  public void wontCallOnCompleteTwice() {
-    InOrder inOrder = Mockito.inOrder(emitter);
-
-    /* when */
-    underTest.onCompleted();
-    /* then */
-    inOrder.verify(emitter).onComplete();
-
-    /* when */
-    underTest.onCompleted();
-    /* then */
-    inOrder.verify(emitter, never()).onComplete();
-  }
-
-  @Test
-  public void wontCallOnErrorTwice() {
-    InOrder inOrder = Mockito.inOrder(emitter);
-
-    /* when */
-    underTest.onThrowable(null);
-    /* then */
-    inOrder.verify(emitter).onError(null);
-
-    /* when */
-    underTest.onThrowable(new RuntimeException("unwanted"));
-    /* then */
-    inOrder.verify(emitter, never()).onError(any());
-  }
-
-  @Test
-  public void wontCallOnErrorAfterOnComplete() {
-    /* when */
-    underTest.onCompleted();
-    then(emitter).should().onComplete();
-
-    /* when */
-    underTest.onThrowable(null);
-    then(emitter).should(never()).onError(any());
-  }
-
-  @Test
-  public void wontCallOnCompleteAfterOnError() {
-    /* when */
-    underTest.onThrowable(null);
-    then(emitter).should().onError(null);
-
-    /* when */
-    underTest.onCompleted();
-    then(emitter).should(never()).onComplete();
-  }
-
-  @Test
-  public void wontCallOnCompleteAfterDisposal() {
-    given(emitter.isDisposed()).willReturn(true);
-    /* when */
-    underTest.onCompleted();
-    /* then */
-    verify(emitter, never()).onComplete();
-  }
-
-  @Test
-  public void wontCallOnErrorAfterDisposal() {
-    given(emitter.isDisposed()).willReturn(true);
-    /* when */
-    underTest.onThrowable(new RuntimeException("ignored"));
-    /* then */
-    verify(emitter, never()).onError(any());
-  }
-
-  @Test
-  public void handlesExceptionsWhileCompleting() throws Exception {
-    /* given */
-    final Throwable x = new RuntimeException("mocked error in delegate onCompleted()");
-    given(delegate.onCompleted()).willThrow(x);
-    /* when */
-    underTest.onCompleted();
-    then(emitter).should().onError(x);
-  }
-
-  @Test
-  public void handlesExceptionsWhileFailing() {
-    // given
-    final Throwable initial = new RuntimeException("mocked error for onThrowable()");
-    final Throwable followup = new RuntimeException("mocked error in delegate onThrowable()");
-    willThrow(followup).given(delegate).onThrowable(initial);
-
-    /* when */
-    underTest.onThrowable(initial);
-
-    // then
-    then(emitter).should().onError(throwable.capture());
-    final Throwable thrown = throwable.getValue();
-    assertThat(thrown, is(instanceOf(CompositeException.class)));
-    assertThat(((CompositeException) thrown).getExceptions(), is(Arrays.asList(initial, followup)));
-  }
-
-  @Test
-  public void cachesDisposedException() {
-    // when
-    new UnderTest().disposed();
-    new UnderTest().disposed();
-
-    // then
-    then(delegate).should(times(2)).onThrowable(throwable.capture());
-    final List<Throwable> errors = throwable.getAllValues();
-    final Throwable firstError = errors.get(0), secondError = errors.get(1);
-    assertThat(secondError, is(sameInstance(firstError)));
-    final StackTraceElement[] stackTrace = firstError.getStackTrace();
-    assertThat(stackTrace.length, is(1));
-    assertThat(stackTrace[0].getClassName(), is(AbstractMaybeAsyncHandlerBridge.class.getName()));
-    assertThat(stackTrace[0].getMethodName(), is("disposed"));
-  }
-
-  @DataProvider
-  public Object[][] httpEvents() {
-    return new Object[][]{
-            {named("onStatusReceived", () -> underTest.onStatusReceived(status))},
-            {named("onHeadersReceived", () -> underTest.onHeadersReceived(headers))},
-            {named("onBodyPartReceived", () -> underTest.onBodyPartReceived(bodyPart))},
-            {named("onTrailingHeadersReceived", () -> underTest.onTrailingHeadersReceived(headers))},
-    };
-  }
-
-  @Test(dataProvider = "httpEvents")
-  public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-    given(emitter.isDisposed()).willReturn(true);
-
-    /* when */
-    final AsyncHandler.State firstState = httpEvent.call();
-    /* then */
-    assertThat(firstState, is(State.ABORT));
-    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
-
-    /* when */
-    final AsyncHandler.State secondState = httpEvent.call();
-    /* then */
-    assertThat(secondState, is(State.ABORT));
-    /* then */
-    verifyNoMoreInteractions(delegate);
-  }
-
-  private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
-    UnderTest() {
-      super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
+        @Override
+        protected AsyncHandler<? extends Object> delegate() {
+            return delegate;
+        }
     }
 
-    @Override
-    protected AsyncHandler<?> delegate() {
-      return delegate;
+    private static <T> Callable<T> named(String name, Callable<T> callable) {
+        return new Callable<T>() {
+            @Override
+            public String toString() {
+                return name;
+            }
+
+            @Override
+            public T call() throws Exception {
+                return callable.call();
+            }
+        };
     }
-  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
index 53cc4940c..5f33906e5 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeProgressAsyncHandlerBridgeTest.java
@@ -13,7 +13,16 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
-import io.reactivex.MaybeEmitter;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.then;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+import java.util.concurrent.Callable;
+
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
@@ -24,96 +33,81 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import java.util.concurrent.Callable;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.then;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
+import io.reactivex.MaybeEmitter;
 
 public class AbstractMaybeProgressAsyncHandlerBridgeTest {
 
-  @Mock
-  MaybeEmitter<Object> emitter;
-
-  @Mock
-  ProgressAsyncHandler<? extends Object> delegate;
-
-  private AbstractMaybeProgressAsyncHandlerBridge<Object> underTest;
-
-  private static <T> Callable<T> named(String name, Callable<T> callable) {
-    return new Callable<T>() {
-      @Override
-      public String toString() {
-        return name;
-      }
-
-      @Override
-      public T call() throws Exception {
-        return callable.call();
-      }
-    };
-  }
-
-  @BeforeMethod
-  public void initializeTest() {
-    MockitoAnnotations.initMocks(this);
-    underTest = new UnderTest();
-  }
-
-  @Test
-  public void forwardsEvents() {
-    /* when */
-    underTest.onHeadersWritten();
-    then(delegate).should().onHeadersWritten();
-
-    /* when */
-    underTest.onContentWriteProgress(40, 60, 100);
-    then(delegate).should().onContentWriteProgress(40, 60, 100);
-
-    /* when */
-    underTest.onContentWritten();
-    then(delegate).should().onContentWritten();
-  }
-
-  @DataProvider
-  public Object[][] httpEvents() {
-    return new Object[][]{
-            {named("onHeadersWritten", () -> underTest.onHeadersWritten())},
-            {named("onContentWriteProgress", () -> underTest.onContentWriteProgress(40, 60, 100))},
-            {named("onContentWritten", () -> underTest.onContentWritten())},
-    };
-  }
-
-  @Test(dataProvider = "httpEvents")
-  public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
-    given(emitter.isDisposed()).willReturn(true);
-
-    /* when */
-    final AsyncHandler.State firstState = httpEvent.call();
-    /* then */
-    assertThat(firstState, is(State.ABORT));
-    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
-
-    /* when */
-    final AsyncHandler.State secondState = httpEvent.call();
-    /* then */
-    assertThat(secondState, is(State.ABORT));
-    /* then */
-    verifyNoMoreInteractions(delegate);
-  }
-
-  private final class UnderTest extends AbstractMaybeProgressAsyncHandlerBridge<Object> {
-    UnderTest() {
-      super(AbstractMaybeProgressAsyncHandlerBridgeTest.this.emitter);
+    @Mock
+    MaybeEmitter<Object> emitter;
+
+    @Mock
+    ProgressAsyncHandler<? extends Object> delegate;
+
+    private AbstractMaybeProgressAsyncHandlerBridge<Object> underTest;
+
+    @BeforeMethod
+    public void initializeTest() {
+        MockitoAnnotations.initMocks(this);
+        underTest = new UnderTest();
+    }
+
+    @Test
+    public void forwardsEvents() throws Exception {
+        /* when */ underTest.onHeadersWritten();
+        then(delegate).should().onHeadersWritten();
+
+        /* when */ underTest.onContentWriteProgress(40, 60, 100);
+        then(delegate).should().onContentWriteProgress(40, 60, 100);
+
+        /* when */ underTest.onContentWritten();
+        then(delegate).should().onContentWritten();
+    }
+
+    @DataProvider
+    public Object[][] httpEvents() {
+        return new Object[][] { //
+                { named("onHeadersWritten", () -> underTest.onHeadersWritten()) }, //
+                { named("onContentWriteProgress", () -> underTest.onContentWriteProgress(40, 60, 100)) }, //
+                { named("onContentWritten", () -> underTest.onContentWritten()) }, //
+        };
+    }
+
+    @Test(dataProvider = "httpEvents")
+    public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEvent) throws Exception {
+        given(emitter.isDisposed()).willReturn(true);
+
+        /* when */ final AsyncHandler.State firstState = httpEvent.call();
+        /* then */ assertThat(firstState, is(State.ABORT));
+        then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+        /* when */ final AsyncHandler.State secondState = httpEvent.call();
+        /* then */ assertThat(secondState, is(State.ABORT));
+        /* then */ verifyNoMoreInteractions(delegate);
+    }
+
+    private final class UnderTest extends AbstractMaybeProgressAsyncHandlerBridge<Object> {
+        UnderTest() {
+            super(AbstractMaybeProgressAsyncHandlerBridgeTest.this.emitter);
+        }
+
+        @Override
+        protected ProgressAsyncHandler<? extends Object> delegate() {
+            return delegate;
+        }
+
     }
 
-    @Override
-    protected ProgressAsyncHandler<?> delegate() {
-      return delegate;
+    private static <T> Callable<T> named(String name, Callable<T> callable) {
+        return new Callable<T>() {
+            @Override
+            public String toString() {
+                return name;
+            }
+
+            @Override
+            public T call() throws Exception {
+                return callable.call();
+            }
+        };
     }
-  }
 }
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 0dee4f389..5d4306d00 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -1,11 +1,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <artifactId>async-http-client-extras-simple</artifactId>
-  <name>Asynchronous Http Simple Client</name>
-  <description>The Async Http Simple Client.</description>
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <groupId>org.asynchttpclient</groupId>
+        <version>2.1.0-SNAPSHOT</version>
+    </parent>
+    <artifactId>async-http-client-extras-simple</artifactId>
+    <name>Asynchronous Http Simple Client</name>
+    <description>The Async Http Simple Client.</description>
 </project>
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
index 8ca877d33..81cfd7745 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/AppendableBodyConsumer.java
@@ -12,41 +12,41 @@
  */
 package org.asynchttpclient.extras.simple;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 /**
  * An {@link Appendable} customer for {@link ByteBuffer}
  */
 public class AppendableBodyConsumer implements BodyConsumer {
 
-  private final Appendable appendable;
-  private final Charset charset;
-
-  public AppendableBodyConsumer(Appendable appendable, Charset charset) {
-    this.appendable = appendable;
-    this.charset = charset;
-  }
-
-  public AppendableBodyConsumer(Appendable appendable) {
-    this.appendable = appendable;
-    this.charset = UTF_8;
-  }
-
-  @Override
-  public void consume(ByteBuffer byteBuffer) throws IOException {
-    appendable
-            .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), charset));
-  }
-
-  @Override
-  public void close() throws IOException {
-    if (appendable instanceof Closeable) {
-      Closeable.class.cast(appendable).close();
+    private final Appendable appendable;
+    private final Charset charset;
+
+    public AppendableBodyConsumer(Appendable appendable, Charset charset) {
+        this.appendable = appendable;
+        this.charset = charset;
+    }
+
+    public AppendableBodyConsumer(Appendable appendable) {
+        this.appendable = appendable;
+        this.charset = UTF_8;
+    }
+
+    @Override
+    public void consume(ByteBuffer byteBuffer) throws IOException {
+        appendable
+                .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), charset));
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (appendable instanceof Closeable) {
+            Closeable.class.cast(appendable).close();
+        }
     }
-  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
index f900b4e57..3b12e5a0e 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/BodyConsumer.java
@@ -22,11 +22,11 @@
  */
 public interface BodyConsumer extends Closeable {
 
-  /**
-   * Consume the received bytes.
-   *
-   * @param byteBuffer a {@link ByteBuffer} representation of the response's chunk.
-   * @throws IOException IO exception
-   */
-  void consume(ByteBuffer byteBuffer) throws IOException;
+    /**
+     * Consume the received bytes.
+     *
+     * @param byteBuffer a {@link ByteBuffer} representation of the response's chunk.
+     * @throws IOException IO exception
+     */
+    void consume(ByteBuffer byteBuffer) throws IOException;
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
index 1dfdd38a9..427ff8b01 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ByteBufferBodyConsumer.java
@@ -20,25 +20,25 @@
  */
 public class ByteBufferBodyConsumer implements BodyConsumer {
 
-  private final ByteBuffer byteBuffer;
+    private final ByteBuffer byteBuffer;
 
-  public ByteBufferBodyConsumer(ByteBuffer byteBuffer) {
-    this.byteBuffer = byteBuffer;
-  }
+    public ByteBufferBodyConsumer(ByteBuffer byteBuffer) {
+        this.byteBuffer = byteBuffer;
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void consume(ByteBuffer byteBuffer) throws IOException {
-    byteBuffer.put(byteBuffer);
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void consume(ByteBuffer byteBuffer) throws IOException {
+        byteBuffer.put(byteBuffer);
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void close() throws IOException {
-    byteBuffer.flip();
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void close() throws IOException {
+        byteBuffer.flip();
+    }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
index 14fe594a2..5a51e5e99 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/FileBodyConsumer.java
@@ -21,42 +21,42 @@
  */
 public class FileBodyConsumer implements ResumableBodyConsumer {
 
-  private final RandomAccessFile file;
-
-  public FileBodyConsumer(RandomAccessFile file) {
-    this.file = file;
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void consume(ByteBuffer byteBuffer) throws IOException {
-    // TODO: Channel.transferFrom may be a good idea to investigate.
-    file.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void close() throws IOException {
-    file.close();
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public long getTransferredBytes() throws IOException {
-    return file.length();
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void resume() throws IOException {
-    file.seek(getTransferredBytes());
-  }
+    private final RandomAccessFile file;
+
+    public FileBodyConsumer(RandomAccessFile file) {
+        this.file = file;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void consume(ByteBuffer byteBuffer) throws IOException {
+        // TODO: Channel.transferFrom may be a good idea to investigate.
+        file.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void close() throws IOException {
+        file.close();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public long getTransferredBytes() throws IOException {
+        return file.length();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void resume() throws IOException {
+        file.seek(getTransferredBytes());
+    }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
index dc871d376..297a68714 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/OutputStreamBodyConsumer.java
@@ -21,25 +21,25 @@
  */
 public class OutputStreamBodyConsumer implements BodyConsumer {
 
-  private final OutputStream outputStream;
+    private final OutputStream outputStream;
 
-  public OutputStreamBodyConsumer(OutputStream outputStream) {
-    this.outputStream = outputStream;
-  }
+    public OutputStreamBodyConsumer(OutputStream outputStream) {
+        this.outputStream = outputStream;
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void consume(ByteBuffer byteBuffer) throws IOException {
-    outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void consume(ByteBuffer byteBuffer) throws IOException {
+        outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());
+    }
 
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public void close() throws IOException {
-    outputStream.close();
-  }
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void close() throws IOException {
+        outputStream.close();
+    }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
index 46048fca9..459e73641 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ResumableBodyConsumer.java
@@ -1,15 +1,15 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
+* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+*
+* This program is licensed to you under the Apache License Version 2.0,
+* and you may not use this file except in compliance with the Apache License Version 2.0.
+* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the Apache License Version 2.0 is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+*/
 
 package org.asynchttpclient.extras.simple;
 
@@ -20,18 +20,18 @@
  */
 public interface ResumableBodyConsumer extends BodyConsumer {
 
-  /**
-   * Prepare this consumer to resume a download, for example by seeking to the end of the underlying file.
-   *
-   * @throws IOException IO exception
-   */
-  void resume() throws IOException;
+    /**
+     * Prepare this consumer to resume a download, for example by seeking to the end of the underlying file.
+     *
+     * @throws IOException IO exception
+     */
+    void resume() throws IOException;
 
-  /**
-   * Get the previously transferred bytes, for example the current file size.
-   *
-   * @return the number of tranferred bytes
-   * @throws IOException IO exception
-   */
-  long getTransferredBytes() throws IOException;
+    /**
+     * Get the previously transferred bytes, for example the current file size.
+     *
+     *@return the number of tranferred bytes
+     * @throws IOException IO exception
+     */
+    long getTransferredBytes() throws IOException;
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
index 774becc15..8b5e0f106 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAHCTransferListener.java
@@ -3,17 +3,18 @@
 /*
  * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
  *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * This program is licensed to you under the Apache License Version 2.0, 
+ * and you may not use this file except in compliance with the Apache License Version 2.0. 
  * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * Unless required by applicable law or agreed to in writing, 
+ * software distributed under the Apache License Version 2.0 is distributed on an 
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
 import io.netty.handler.codec.http.HttpHeaders;
+
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -27,54 +28,54 @@
  */
 public interface SimpleAHCTransferListener {
 
-  /**
-   * This method is called after the connection status is received.
-   *
-   * @param uri        the uri
-   * @param statusCode the received status code.
-   * @param statusText the received status text.
-   */
-  void onStatus(Uri uri, int statusCode, String statusText);
+    /**
+     * This method is called after the connection status is received.
+     *
+     * @param uri        the uri
+     * @param statusCode the received status code.
+     * @param statusText the received status text.
+     */
+    void onStatus(Uri uri, int statusCode, String statusText);
 
-  /**
-   * This method is called after the response headers are received.
-   *
-   * @param uri     the uri
-   * @param headers the received headers, never {@code null}.
-   */
-  void onHeaders(Uri uri, HttpHeaders headers);
+    /**
+     * This method is called after the response headers are received.
+     *
+     * @param uri     the uri
+     * @param headers the received headers, never {@code null}.
+     */
+    void onHeaders(Uri uri, HttpHeaders headers);
 
-  /**
-   * This method is called when bytes of the responses body are received.
-   *
-   * @param uri     the uri
-   * @param amount  the number of transferred bytes so far.
-   * @param current the number of transferred bytes since the last call to this
-   *                method.
-   * @param total   the total number of bytes to be transferred. This is taken
-   *                from the Content-Length-header and may be unspecified (-1).
-   */
-  void onBytesReceived(Uri uri, long amount, long current, long total);
+    /**
+     * This method is called when bytes of the responses body are received.
+     *
+     * @param uri     the uri
+     * @param amount  the number of transferred bytes so far.
+     * @param current the number of transferred bytes since the last call to this
+     *                method.
+     * @param total   the total number of bytes to be transferred. This is taken
+     *                from the Content-Length-header and may be unspecified (-1).
+     */
+    void onBytesReceived(Uri uri, long amount, long current, long total);
 
-  /**
-   * This method is called when bytes are sent.
-   *
-   * @param uri     the uri
-   * @param amount  the number of transferred bytes so far.
-   * @param current the number of transferred bytes since the last call to this
-   *                method.
-   * @param total   the total number of bytes to be transferred. This is taken
-   *                from the Content-Length-header and may be unspecified (-1).
-   */
-  void onBytesSent(Uri uri, long amount, long current, long total);
+    /**
+     * This method is called when bytes are sent.
+     *
+     * @param uri     the uri
+     * @param amount  the number of transferred bytes so far.
+     * @param current the number of transferred bytes since the last call to this
+     *                method.
+     * @param total   the total number of bytes to be transferred. This is taken
+     *                from the Content-Length-header and may be unspecified (-1).
+     */
+    void onBytesSent(Uri uri, long amount, long current, long total);
 
-  /**
-   * This method is called when the request is completed.
-   *
-   * @param uri        the uri
-   * @param statusCode the received status code.
-   * @param statusText the received status text.
-   */
-  void onCompleted(Uri uri, int statusCode, String statusText);
+    /**
+     * This method is called when the request is completed.
+     *
+     * @param uri        the uri
+     * @param statusCode the received status code.
+     * @param statusText the received status text.
+     */
+    void onCompleted(Uri uri, int statusCode, String statusText);
 }
 
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index b58658fb5..60c1e62eb 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -12,18 +12,12 @@
  */
 package org.asynchttpclient.extras.simple;
 
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.util.MiscUtils.*;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.cookie.Cookie;
 import io.netty.handler.ssl.SslContext;
-import org.asynchttpclient.*;
-import org.asynchttpclient.Realm.AuthScheme;
-import org.asynchttpclient.handler.ProgressAsyncHandler;
-import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
-import org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.multipart.Part;
-import org.asynchttpclient.uri.Uri;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -33,10 +27,27 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
-import static org.asynchttpclient.util.MiscUtils.withDefault;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SslEngineFactory;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * Simple implementation of {@link AsyncHttpClient} and it's related builders ({@link AsyncHttpClientConfig},
@@ -52,788 +63,788 @@
  * .setRequestTimeout(5 * 60 * 1000)
  * .setUrl(getTargetUrl())
  * .setHeader("Content-Type", "text/html").build();
- *
+ * 
  * StringBuilder s = new StringBuilder();
  * Future&lt;Response&gt; future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
  * </pre></blockquote>
  * or
  * <blockquote><pre>
  * public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
- *
+ * 
  * SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
  * .setUrl(getTargetUrl())
  * .build();
- *
+ * 
  * ByteArrayOutputStream o = new ByteArrayOutputStream(10);
  * Future&lt;Response&gt; future = client.post(new FileBodyGenerator(myFile), new OutputStreamBodyConsumer(o));
  * </pre></blockquote>
  */
 public class SimpleAsyncHttpClient implements Closeable {
 
-  private final AsyncHttpClientConfig config;
-  private final RequestBuilder requestBuilder;
-  private final ThrowableHandler defaultThrowableHandler;
-  private final boolean resumeEnabled;
-  private final ErrorDocumentBehaviour errorDocumentBehaviour;
-  private final SimpleAHCTransferListener listener;
-  private final boolean derived;
-  private AsyncHttpClient asyncHttpClient;
-
-  private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
-                                ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
-    this.config = config;
-    this.requestBuilder = requestBuilder;
-    this.defaultThrowableHandler = defaultThrowableHandler;
-    this.resumeEnabled = resumeEnabled;
-    this.errorDocumentBehaviour = errorDocumentBehaviour;
-    this.asyncHttpClient = ahc;
-    this.listener = listener;
-
-    this.derived = ahc != null;
-  }
-
-  public Future<Response> post(Part... parts) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-
-    for (Part part : parts) {
-      r.addBodyPart(part);
-    }
-
-    return execute(r, null, null);
-  }
-
-  public Future<Response> post(BodyConsumer consumer, Part... parts) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-
-    for (Part part : parts) {
-      r.addBodyPart(part);
-    }
-
-    return execute(r, consumer, null);
-  }
-
-  public Future<Response> post(BodyGenerator bodyGenerator) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-    r.setBody(bodyGenerator);
-    return execute(r, null, null);
-  }
-
-  public Future<Response> post(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-    r.setBody(bodyGenerator);
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-    r.setBody(bodyGenerator);
-    return execute(r, bodyConsumer, null);
-  }
-
-  public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
-          throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-    r.setBody(bodyGenerator);
-    return execute(r, bodyConsumer, throwableHandler);
-  }
-
-  public Future<Response> put(Part... parts) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-
-    for (Part part : parts) {
-      r.addBodyPart(part);
-    }
-
-    return execute(r, null, null);
-  }
-
-  public Future<Response> put(BodyConsumer consumer, Part... parts) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("POST");
-
-    for (Part part : parts) {
-      r.addBodyPart(part);
-    }
-
-    return execute(r, consumer, null);
-  }
-
-  public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("PUT");
-    r.setBody(bodyGenerator);
-    return execute(r, bodyConsumer, null);
-  }
-
-  public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
-          throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("PUT");
-    r.setBody(bodyGenerator);
-    return execute(r, bodyConsumer, throwableHandler);
-  }
-
-  public Future<Response> put(BodyGenerator bodyGenerator) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("PUT");
-    r.setBody(bodyGenerator);
-    return execute(r, null, null);
-  }
-
-  public Future<Response> put(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("PUT");
-    r.setBody(bodyGenerator);
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> get() throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    return execute(r, null, null);
-  }
-
-  public Future<Response> get(ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> get(BodyConsumer bodyConsumer) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    return execute(r, bodyConsumer, null);
-  }
-
-  public Future<Response> get(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    return execute(r, bodyConsumer, throwableHandler);
-  }
-
-  public Future<Response> delete() throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("DELETE");
-    return execute(r, null, null);
-  }
-
-  public Future<Response> delete(ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("DELETE");
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> delete(BodyConsumer bodyConsumer) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("DELETE");
-    return execute(r, bodyConsumer, null);
-  }
-
-  public Future<Response> delete(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("DELETE");
-    return execute(r, bodyConsumer, throwableHandler);
-  }
-
-  public Future<Response> head() throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("HEAD");
-    return execute(r, null, null);
-  }
-
-  public Future<Response> head(ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("HEAD");
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> options() throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("OPTIONS");
-    return execute(r, null, null);
-  }
-
-  public Future<Response> options(ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("OPTIONS");
-    return execute(r, null, throwableHandler);
-  }
-
-  public Future<Response> options(BodyConsumer bodyConsumer) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("OPTIONS");
-    return execute(r, bodyConsumer, null);
-  }
-
-  public Future<Response> options(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-    RequestBuilder r = rebuildRequest(requestBuilder.build());
-    r.setMethod("OPTIONS");
-    return execute(r, bodyConsumer, throwableHandler);
-  }
-
-  private RequestBuilder rebuildRequest(Request rb) {
-    return new RequestBuilder(rb);
-  }
-
-  private Future<Response> execute(RequestBuilder rb, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
-    if (throwableHandler == null) {
-      throwableHandler = defaultThrowableHandler;
-    }
-
-    Request request = rb.build();
-    ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour,
-            request.getUri(), listener);
-
-    if (resumeEnabled && request.getMethod().equals("GET") && bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
-      ResumableBodyConsumer fileBodyConsumer = (ResumableBodyConsumer) bodyConsumer;
-      long length = fileBodyConsumer.getTransferredBytes();
-      fileBodyConsumer.resume();
-      handler = new ResumableBodyConsumerAsyncHandler(length, handler);
-    }
-
-    return getAsyncHttpClient().executeRequest(request, handler);
-  }
-
-  private AsyncHttpClient getAsyncHttpClient() {
-    synchronized (config) {
-      if (asyncHttpClient == null) {
-        asyncHttpClient = asyncHttpClient(config);
-      }
-    }
-    return asyncHttpClient;
-  }
-
-  /**
-   * Close the underlying AsyncHttpClient for this instance.
-   * <br>
-   * If this instance is derived from another instance, this method does
-   * nothing as the client instance is managed by the original
-   * SimpleAsyncHttpClient.
-   *
-   * @see #derive()
-   * @see AsyncHttpClient#close()
-   */
-  public void close() throws IOException {
-    if (!derived && asyncHttpClient != null) {
-      asyncHttpClient.close();
-    }
-  }
-
-  /**
-   * Returns a Builder for a derived SimpleAsyncHttpClient that uses the same
-   * instance of {@link AsyncHttpClient} to execute requests.
-   * <br>
-   * The original SimpleAsyncHttpClient is responsible for managing the
-   * underlying AsyncHttpClient. For the derived instance, {@link #close()} is
-   * a NOOP. If the original SimpleAsyncHttpClient is closed, all derived
-   * instances become invalid.
-   *
-   * @return a Builder for a derived SimpleAsyncHttpClient that uses the same
-   * instance of {@link AsyncHttpClient} to execute requests, never
-   * {@code null}.
-   */
-  public DerivedBuilder derive() {
-    return new Builder(this);
-  }
-
-  public enum ErrorDocumentBehaviour {
-    /**
-     * Write error documents as usual via
-     * {@link BodyConsumer#consume(java.nio.ByteBuffer)}.
-     */
-    WRITE,
-
-    /**
-     * Accumulate error documents in memory but do not consume.
-     */
-    ACCUMULATE,
-
-    /**
-     * Omit error documents. An error document will neither be available in
-     * the response nor written via a {@link BodyConsumer}.
-     */
-    OMIT
-  }
-
-  /**
-   * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
-   *
-   * @see SimpleAsyncHttpClient#derive()
-   */
-  /**
-   * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
-   *
-   * @see SimpleAsyncHttpClient#derive()
-   */
-  public interface DerivedBuilder {
-
-    DerivedBuilder setFollowRedirect(boolean followRedirect);
-
-    DerivedBuilder setVirtualHost(String virtualHost);
-
-    DerivedBuilder setUrl(String url);
-
-    DerivedBuilder setFormParams(List<Param> params);
-
-    DerivedBuilder setFormParams(Map<String, List<String>> params);
-
-    DerivedBuilder setHeaders(Map<CharSequence, Collection<?>> headers);
-
-    DerivedBuilder setHeaders(HttpHeaders headers);
-
-    DerivedBuilder setHeader(CharSequence name, Object value);
-
-    DerivedBuilder addQueryParam(String name, String value);
-
-    DerivedBuilder addFormParam(String key, String value);
+    private final AsyncHttpClientConfig config;
+    private final RequestBuilder requestBuilder;
+    private AsyncHttpClient asyncHttpClient;
+    private final ThrowableHandler defaultThrowableHandler;
+    private final boolean resumeEnabled;
+    private final ErrorDocumentBehaviour errorDocumentBehaviour;
+    private final SimpleAHCTransferListener listener;
+    private final boolean derived;
 
-    DerivedBuilder addHeader(CharSequence name, Object value);
+    private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
+            ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
+        this.config = config;
+        this.requestBuilder = requestBuilder;
+        this.defaultThrowableHandler = defaultThrowableHandler;
+        this.resumeEnabled = resumeEnabled;
+        this.errorDocumentBehaviour = errorDocumentBehaviour;
+        this.asyncHttpClient = ahc;
+        this.listener = listener;
 
-    DerivedBuilder addCookie(Cookie cookie);
+        this.derived = ahc != null;
+    }
 
-    DerivedBuilder addBodyPart(Part part);
+    public Future<Response> post(Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
 
-    DerivedBuilder setResumableDownload(boolean resume);
+        for (Part part : parts) {
+            r.addBodyPart(part);
+        }
 
-    SimpleAsyncHttpClient build();
-  }
+        return execute(r, null, null);
+    }
 
-  public final static class Builder implements DerivedBuilder {
+    public Future<Response> post(BodyConsumer consumer, Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
 
-    private final RequestBuilder requestBuilder;
-    private final DefaultAsyncHttpClientConfig.Builder configBuilder = config();
-    private Realm.Builder realmBuilder = null;
-    private Realm.AuthScheme proxyAuthScheme;
-    private String proxyHost = null;
-    private String proxyPrincipal = null;
-    private String proxyPassword = null;
-    private int proxyPort = 80;
-    private ThrowableHandler defaultThrowableHandler = null;
-    private boolean enableResumableDownload = false;
-    private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
-    private AsyncHttpClient ahc = null;
-    private SimpleAHCTransferListener listener = null;
+        for (Part part : parts) {
+            r.addBodyPart(part);
+        }
 
-    public Builder() {
-      requestBuilder = new RequestBuilder("GET", false);
+        return execute(r, consumer, null);
     }
 
-    private Builder(SimpleAsyncHttpClient client) {
-      this.requestBuilder = new RequestBuilder(client.requestBuilder.build());
-      this.defaultThrowableHandler = client.defaultThrowableHandler;
-      this.errorDocumentBehaviour = client.errorDocumentBehaviour;
-      this.enableResumableDownload = client.resumeEnabled;
-      this.ahc = client.getAsyncHttpClient();
-      this.listener = client.listener;
+    public Future<Response> post(BodyGenerator bodyGenerator) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        r.setBody(bodyGenerator);
+        return execute(r, null, null);
     }
 
-    public Builder addBodyPart(Part part) {
-      requestBuilder.addBodyPart(part);
-      return this;
+    public Future<Response> post(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        r.setBody(bodyGenerator);
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder addCookie(Cookie cookie) {
-      requestBuilder.addCookie(cookie);
-      return this;
+    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        r.setBody(bodyGenerator);
+        return execute(r, bodyConsumer, null);
     }
 
-    public Builder addHeader(CharSequence name, Object value) {
-      requestBuilder.addHeader(name, value);
-      return this;
+    public Future<Response> post(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+            throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        r.setBody(bodyGenerator);
+        return execute(r, bodyConsumer, throwableHandler);
     }
 
-    public Builder addFormParam(String key, String value) {
-      requestBuilder.addFormParam(key, value);
-      return this;
-    }
+    public Future<Response> put(Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
 
-    public Builder addQueryParam(String name, String value) {
-      requestBuilder.addQueryParam(name, value);
-      return this;
-    }
+        for (Part part : parts) {
+            r.addBodyPart(part);
+        }
 
-    public Builder setHeader(CharSequence name, Object value) {
-      requestBuilder.setHeader(name, value);
-      return this;
+        return execute(r, null, null);
     }
 
-    public Builder setHeaders(HttpHeaders headers) {
-      requestBuilder.setHeaders(headers);
-      return this;
-    }
+    public Future<Response> put(BodyConsumer consumer, Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
 
-    public Builder setHeaders(Map<CharSequence, Collection<?>> headers) {
-      requestBuilder.setHeaders(headers);
-      return this;
-    }
+        for (Part part : parts) {
+            r.addBodyPart(part);
+        }
 
-    public Builder setFormParams(Map<String, List<String>> parameters) {
-      requestBuilder.setFormParams(parameters);
-      return this;
+        return execute(r, consumer, null);
     }
 
-    public Builder setFormParams(List<Param> params) {
-      requestBuilder.setFormParams(params);
-      return this;
+    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("PUT");
+        r.setBody(bodyGenerator);
+        return execute(r, bodyConsumer, null);
     }
 
-    public Builder setUrl(String url) {
-      requestBuilder.setUrl(url);
-      return this;
+    public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler)
+            throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("PUT");
+        r.setBody(bodyGenerator);
+        return execute(r, bodyConsumer, throwableHandler);
     }
 
-    public Builder setVirtualHost(String virtualHost) {
-      requestBuilder.setVirtualHost(virtualHost);
-      return this;
+    public Future<Response> put(BodyGenerator bodyGenerator) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("PUT");
+        r.setBody(bodyGenerator);
+        return execute(r, null, null);
     }
 
-    public Builder setFollowRedirect(boolean followRedirect) {
-      requestBuilder.setFollowRedirect(followRedirect);
-      return this;
+    public Future<Response> put(BodyGenerator bodyGenerator, ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("PUT");
+        r.setBody(bodyGenerator);
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder setMaxConnections(int defaultMaxConnections) {
-      configBuilder.setMaxConnections(defaultMaxConnections);
-      return this;
+    public Future<Response> get() throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        return execute(r, null, null);
     }
 
-    public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
-      configBuilder.setMaxConnectionsPerHost(defaultMaxConnectionsPerHost);
-      return this;
+    public Future<Response> get(ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder setConnectTimeout(int connectTimeuot) {
-      configBuilder.setConnectTimeout(connectTimeuot);
-      return this;
+    public Future<Response> get(BodyConsumer bodyConsumer) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        return execute(r, bodyConsumer, null);
     }
 
-    public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
-      configBuilder.setPooledConnectionIdleTimeout(pooledConnectionIdleTimeout);
-      return this;
+    public Future<Response> get(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        return execute(r, bodyConsumer, throwableHandler);
     }
 
-    public Builder setRequestTimeout(int defaultRequestTimeout) {
-      configBuilder.setRequestTimeout(defaultRequestTimeout);
-      return this;
+    public Future<Response> delete() throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("DELETE");
+        return execute(r, null, null);
     }
 
-    public Builder setMaxRedirects(int maxRedirects) {
-      configBuilder.setMaxRedirects(maxRedirects);
-      return this;
+    public Future<Response> delete(ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("DELETE");
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder setCompressionEnforced(boolean compressionEnforced) {
-      configBuilder.setCompressionEnforced(compressionEnforced);
-      return this;
+    public Future<Response> delete(BodyConsumer bodyConsumer) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("DELETE");
+        return execute(r, bodyConsumer, null);
     }
 
-    public Builder setUserAgent(String userAgent) {
-      configBuilder.setUserAgent(userAgent);
-      return this;
+    public Future<Response> delete(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("DELETE");
+        return execute(r, bodyConsumer, throwableHandler);
     }
 
-    public Builder setKeepAlive(boolean allowPoolingConnections) {
-      configBuilder.setKeepAlive(allowPoolingConnections);
-      return this;
+    public Future<Response> head() throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("HEAD");
+        return execute(r, null, null);
     }
 
-    public Builder setThreadFactory(ThreadFactory threadFactory) {
-      configBuilder.setThreadFactory(threadFactory);
-      return this;
+    public Future<Response> head(ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("HEAD");
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder setSslContext(SslContext sslContext) {
-      configBuilder.setSslContext(sslContext);
-      return this;
+    public Future<Response> options() throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("OPTIONS");
+        return execute(r, null, null);
     }
 
-    public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
-      configBuilder.setSslEngineFactory(sslEngineFactory);
-      return this;
+    public Future<Response> options(ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("OPTIONS");
+        return execute(r, null, throwableHandler);
     }
 
-    public Builder setRealm(Realm realm) {
-      configBuilder.setRealm(realm);
-      return this;
+    public Future<Response> options(BodyConsumer bodyConsumer) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("OPTIONS");
+        return execute(r, bodyConsumer, null);
     }
 
-    public Builder setProxyAuthScheme(Realm.AuthScheme proxyAuthScheme) {
-      this.proxyAuthScheme = proxyAuthScheme;
-      return this;
+    public Future<Response> options(BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("OPTIONS");
+        return execute(r, bodyConsumer, throwableHandler);
     }
 
-    public Builder setProxyHost(String host) {
-      this.proxyHost = host;
-      return this;
+    private RequestBuilder rebuildRequest(Request rb) {
+        return new RequestBuilder(rb);
     }
 
-    public Builder setProxyPrincipal(String principal) {
-      this.proxyPrincipal = principal;
-      return this;
-    }
+    private Future<Response> execute(RequestBuilder rb, BodyConsumer bodyConsumer, ThrowableHandler throwableHandler) throws IOException {
+        if (throwableHandler == null) {
+            throwableHandler = defaultThrowableHandler;
+        }
 
-    public Builder setProxyPassword(String password) {
-      this.proxyPassword = password;
-      return this;
-    }
+        Request request = rb.build();
+        ProgressAsyncHandler<Response> handler = new BodyConsumerAsyncHandler(bodyConsumer, throwableHandler, errorDocumentBehaviour,
+                request.getUri(), listener);
+
+        if (resumeEnabled && request.getMethod().equals("GET") && bodyConsumer != null && bodyConsumer instanceof ResumableBodyConsumer) {
+            ResumableBodyConsumer fileBodyConsumer = (ResumableBodyConsumer) bodyConsumer;
+            long length = fileBodyConsumer.getTransferredBytes();
+            fileBodyConsumer.resume();
+            handler = new ResumableBodyConsumerAsyncHandler(length, handler);
+        }
 
-    public Builder setProxyPort(int port) {
-      this.proxyPort = port;
-      return this;
+        return getAsyncHttpClient().executeRequest(request, handler);
     }
 
-    public Builder setDefaultThrowableHandler(ThrowableHandler throwableHandler) {
-      this.defaultThrowableHandler = throwableHandler;
-      return this;
+    private AsyncHttpClient getAsyncHttpClient() {
+        synchronized (config) {
+            if (asyncHttpClient == null) {
+                asyncHttpClient = asyncHttpClient(config);
+            }
+        }
+        return asyncHttpClient;
     }
 
     /**
-     * This setting controls whether an error document should be written via
-     * the {@link BodyConsumer} after an error status code was received (e.g.
-     * 404). Default is {@link ErrorDocumentBehaviour#WRITE}.
+     * Close the underlying AsyncHttpClient for this instance.
+     * <br>
+     * If this instance is derived from another instance, this method does
+     * nothing as the client instance is managed by the original
+     * SimpleAsyncHttpClient.
      *
-     * @param behaviour the behaviour
-     * @return this
+     * @see #derive()
+     * @see AsyncHttpClient#close()
      */
-    public Builder setErrorDocumentBehaviour(ErrorDocumentBehaviour behaviour) {
-      this.errorDocumentBehaviour = behaviour;
-      return this;
+    public void close() throws IOException {
+        if (!derived && asyncHttpClient != null) {
+            asyncHttpClient.close();
+        }
     }
 
     /**
-     * Enable resumable downloads for the SimpleAHC. Resuming downloads will only work for GET requests
-     * with an instance of {@link ResumableBodyConsumer}.
+     * Returns a Builder for a derived SimpleAsyncHttpClient that uses the same
+     * instance of {@link AsyncHttpClient} to execute requests.
+     * <br>
+     * The original SimpleAsyncHttpClient is responsible for managing the
+     * underlying AsyncHttpClient. For the derived instance, {@link #close()} is
+     * a NOOP. If the original SimpleAsyncHttpClient is closed, all derived
+     * instances become invalid.
+     *
+     * @return a Builder for a derived SimpleAsyncHttpClient that uses the same
+     *         instance of {@link AsyncHttpClient} to execute requests, never
+     *         {@code null}.
      */
-    @Override
-    public Builder setResumableDownload(boolean enableResumableDownload) {
-      this.enableResumableDownload = enableResumableDownload;
-      return this;
+    public DerivedBuilder derive() {
+        return new Builder(this);
+    }
+
+    public enum ErrorDocumentBehaviour {
+        /**
+         * Write error documents as usual via
+         * {@link BodyConsumer#consume(java.nio.ByteBuffer)}.
+         */
+        WRITE,
+
+        /**
+         * Accumulate error documents in memory but do not consume.
+         */
+        ACCUMULATE,
+
+        /**
+         * Omit error documents. An error document will neither be available in
+         * the response nor written via a {@link BodyConsumer}.
+         */
+        OMIT
     }
 
     /**
-     * Set the listener to notify about connection progress.
+     * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
      *
-     * @param listener a listener
-     * @return this
+     * @see SimpleAsyncHttpClient#derive()
      */
-    public Builder setListener(SimpleAHCTransferListener listener) {
-      this.listener = listener;
-      return this;
-    }
-
     /**
-     * Set the number of time a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
+     * This interface contains possible configuration changes for a derived SimpleAsyncHttpClient.
      *
-     * @param maxRequestRetry the number of time a request will be retried
-     * @return this
+     * @see SimpleAsyncHttpClient#derive()
      */
-    public Builder setMaxRequestRetry(int maxRequestRetry) {
-      configBuilder.setMaxRequestRetry(maxRequestRetry);
-      return this;
-    }
+    public interface DerivedBuilder {
+
+        DerivedBuilder setFollowRedirect(boolean followRedirect);
+
+        DerivedBuilder setVirtualHost(String virtualHost);
+
+        DerivedBuilder setUrl(String url);
+
+        DerivedBuilder setFormParams(List<Param> params);
+
+        DerivedBuilder setFormParams(Map<String, List<String>> params);
 
-    public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
-      configBuilder.setUseInsecureTrustManager(acceptAnyCertificate);
-      return this;
+        DerivedBuilder setHeaders(Map<CharSequence, Collection<?>> headers);
+
+        DerivedBuilder setHeaders(HttpHeaders headers);
+
+        DerivedBuilder setHeader(CharSequence name, Object value);
+
+        DerivedBuilder addQueryParam(String name, String value);
+
+        DerivedBuilder addFormParam(String key, String value);
+
+        DerivedBuilder addHeader(CharSequence name, Object value);
+
+        DerivedBuilder addCookie(Cookie cookie);
+
+        DerivedBuilder addBodyPart(Part part);
+
+        DerivedBuilder setResumableDownload(boolean resume);
+
+        SimpleAsyncHttpClient build();
     }
 
-    public SimpleAsyncHttpClient build() {
+    public final static class Builder implements DerivedBuilder {
 
-      if (realmBuilder != null) {
-        configBuilder.setRealm(realmBuilder.build());
-      }
+        private final RequestBuilder requestBuilder;
+        private final DefaultAsyncHttpClientConfig.Builder configBuilder = config();
+        private Realm.Builder realmBuilder = null;
+        private Realm.AuthScheme proxyAuthScheme;
+        private String proxyHost = null;
+        private String proxyPrincipal = null;
+        private String proxyPassword = null;
+        private int proxyPort = 80;
+        private ThrowableHandler defaultThrowableHandler = null;
+        private boolean enableResumableDownload = false;
+        private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
+        private AsyncHttpClient ahc = null;
+        private SimpleAHCTransferListener listener = null;
 
-      if (proxyHost != null) {
-        Realm realm = null;
-        if (proxyPrincipal != null) {
-          AuthScheme proxyAuthScheme = withDefault(this.proxyAuthScheme, AuthScheme.BASIC);
-          realm = realm(proxyAuthScheme, proxyPrincipal, proxyPassword).build();
+        public Builder() {
+            requestBuilder = new RequestBuilder("GET", false);
         }
 
-        configBuilder.setProxyServer(proxyServer(proxyHost, proxyPort).setRealm(realm).build());
-      }
+        private Builder(SimpleAsyncHttpClient client) {
+            this.requestBuilder = new RequestBuilder(client.requestBuilder.build());
+            this.defaultThrowableHandler = client.defaultThrowableHandler;
+            this.errorDocumentBehaviour = client.errorDocumentBehaviour;
+            this.enableResumableDownload = client.resumeEnabled;
+            this.ahc = client.getAsyncHttpClient();
+            this.listener = client.listener;
+        }
 
-      configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
+        public Builder addBodyPart(Part part) {
+            requestBuilder.addBodyPart(part);
+            return this;
+        }
 
-      SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
-              errorDocumentBehaviour, enableResumableDownload, ahc, listener);
+        public Builder addCookie(Cookie cookie) {
+            requestBuilder.addCookie(cookie);
+            return this;
+        }
 
-      return sc;
-    }
-  }
+        public Builder addHeader(CharSequence name, Object value) {
+            requestBuilder.addHeader(name, value);
+            return this;
+        }
 
-  private final static class ResumableBodyConsumerAsyncHandler extends ResumableAsyncHandler implements ProgressAsyncHandler<Response> {
+        public Builder addFormParam(String key, String value) {
+            requestBuilder.addFormParam(key, value);
+            return this;
+        }
 
-    private final ProgressAsyncHandler<Response> delegate;
+        public Builder addQueryParam(String name, String value) {
+            requestBuilder.addQueryParam(name, value);
+            return this;
+        }
 
-    public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHandler<Response> delegate) {
-      super(byteTransferred, delegate);
-      this.delegate = delegate;
-    }
+        public Builder setHeader(CharSequence name, Object value) {
+            requestBuilder.setHeader(name, value);
+            return this;
+        }
 
-    public AsyncHandler.State onHeadersWritten() {
-      return delegate.onHeadersWritten();
-    }
+        public Builder setHeaders(HttpHeaders headers) {
+            requestBuilder.setHeaders(headers);
+            return this;
+        }
 
-    public AsyncHandler.State onContentWritten() {
-      return delegate.onContentWritten();
-    }
+        public Builder setHeaders(Map<CharSequence, Collection<?>> headers) {
+            requestBuilder.setHeaders(headers);
+            return this;
+        }
 
-    public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
-      return delegate.onContentWriteProgress(amount, current, total);
-    }
-  }
+        public Builder setFormParams(Map<String, List<String>> parameters) {
+            requestBuilder.setFormParams(parameters);
+            return this;
+        }
+
+        public Builder setFormParams(List<Param> params) {
+            requestBuilder.setFormParams(params);
+            return this;
+        }
 
-  private final static class BodyConsumerAsyncHandler extends AsyncCompletionHandlerBase {
+        public Builder setUrl(String url) {
+            requestBuilder.setUrl(url);
+            return this;
+        }
 
-    private final BodyConsumer bodyConsumer;
-    private final ThrowableHandler exceptionHandler;
-    private final ErrorDocumentBehaviour errorDocumentBehaviour;
-    private final Uri uri;
-    private final SimpleAHCTransferListener listener;
+        public Builder setVirtualHost(String virtualHost) {
+            requestBuilder.setVirtualHost(virtualHost);
+            return this;
+        }
 
-    private boolean accumulateBody = false;
-    private boolean omitBody = false;
-    private int amount = 0;
-    private long total = -1;
+        public Builder setFollowRedirect(boolean followRedirect) {
+            requestBuilder.setFollowRedirect(followRedirect);
+            return this;
+        }
 
-    public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler,
-                                    ErrorDocumentBehaviour errorDocumentBehaviour, Uri uri, SimpleAHCTransferListener listener) {
-      this.bodyConsumer = bodyConsumer;
-      this.exceptionHandler = exceptionHandler;
-      this.errorDocumentBehaviour = errorDocumentBehaviour;
-      this.uri = uri;
-      this.listener = listener;
-    }
+        public Builder setMaxConnections(int defaultMaxConnections) {
+            configBuilder.setMaxConnections(defaultMaxConnections);
+            return this;
+        }
 
-    @Override
-    public void onThrowable(Throwable t) {
-      try {
-        if (exceptionHandler != null) {
-          exceptionHandler.onThrowable(t);
-        } else {
-          super.onThrowable(t);
+        public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
+            configBuilder.setMaxConnectionsPerHost(defaultMaxConnectionsPerHost);
+            return this;
         }
-      } finally {
-        closeConsumer();
-      }
-    }
 
-    /**
-     * {@inheritDoc}
-     */
-    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-      fireReceived(content);
-      if (omitBody) {
-        return State.CONTINUE;
-      }
+        public Builder setConnectTimeout(int connectTimeuot) {
+            configBuilder.setConnectTimeout(connectTimeuot);
+            return this;
+        }
 
-      if (!accumulateBody && bodyConsumer != null) {
-        bodyConsumer.consume(content.getBodyByteBuffer());
-      } else {
-        return super.onBodyPartReceived(content);
-      }
-      return State.CONTINUE;
-    }
+        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+            configBuilder.setPooledConnectionIdleTimeout(pooledConnectionIdleTimeout);
+            return this;
+        }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-      fireCompleted(response);
-      closeConsumer();
-      return super.onCompleted(response);
-    }
+        public Builder setRequestTimeout(int defaultRequestTimeout) {
+            configBuilder.setRequestTimeout(defaultRequestTimeout);
+            return this;
+        }
 
-    private void closeConsumer() {
-      if (bodyConsumer != null)
-        closeSilently(bodyConsumer);
-    }
+        public Builder setMaxRedirects(int maxRedirects) {
+            configBuilder.setMaxRedirects(maxRedirects);
+            return this;
+        }
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus status) throws Exception {
-      fireStatus(status);
+        public Builder setCompressionEnforced(boolean compressionEnforced) {
+            configBuilder.setCompressionEnforced(compressionEnforced);
+            return this;
+        }
 
-      if (isErrorStatus(status)) {
-        switch (errorDocumentBehaviour) {
-          case ACCUMULATE:
-            accumulateBody = true;
-            break;
-          case OMIT:
-            omitBody = true;
-            break;
-          default:
-            break;
+        public Builder setUserAgent(String userAgent) {
+            configBuilder.setUserAgent(userAgent);
+            return this;
         }
-      }
-      return super.onStatusReceived(status);
-    }
 
-    private boolean isErrorStatus(HttpResponseStatus status) {
-      return status.getStatusCode() >= 400;
-    }
+        public Builder setKeepAlive(boolean allowPoolingConnections) {
+            configBuilder.setKeepAlive(allowPoolingConnections);
+            return this;
+        }
 
-    @Override
-    public State onHeadersReceived(HttpHeaders headers) throws Exception {
-      calculateTotal(headers);
+        public Builder setThreadFactory(ThreadFactory threadFactory) {
+            configBuilder.setThreadFactory(threadFactory);
+            return this;
+        }
 
-      fireHeaders(headers);
+        public Builder setSslContext(SslContext sslContext) {
+            configBuilder.setSslContext(sslContext);
+            return this;
+        }
+        
+        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+            configBuilder.setSslEngineFactory(sslEngineFactory);
+            return this;
+        }
 
-      return super.onHeadersReceived(headers);
-    }
+        public Builder setRealm(Realm realm) {
+            configBuilder.setRealm(realm);
+            return this;
+        }
 
-    private void calculateTotal(HttpHeaders headers) {
-      String length = headers.get(CONTENT_LENGTH);
+        public Builder setProxyAuthScheme(Realm.AuthScheme proxyAuthScheme) {
+            this.proxyAuthScheme = proxyAuthScheme;
+            return this;
+        }
 
-      try {
-        total = Integer.valueOf(length);
-      } catch (Exception e) {
-        total = -1;
-      }
-    }
+        public Builder setProxyHost(String host) {
+            this.proxyHost = host;
+            return this;
+        }
 
-    @Override
-    public State onContentWriteProgress(long amount, long current, long total) {
-      fireSent(uri, amount, current, total);
-      return super.onContentWriteProgress(amount, current, total);
-    }
+        public Builder setProxyPrincipal(String principal) {
+            this.proxyPrincipal = principal;
+            return this;
+        }
 
-    private void fireStatus(HttpResponseStatus status) {
-      if (listener != null) {
-        listener.onStatus(uri, status.getStatusCode(), status.getStatusText());
-      }
-    }
+        public Builder setProxyPassword(String password) {
+            this.proxyPassword = password;
+            return this;
+        }
 
-    private void fireReceived(HttpResponseBodyPart content) {
-      int remaining = content.getBodyByteBuffer().remaining();
+        public Builder setProxyPort(int port) {
+            this.proxyPort = port;
+            return this;
+        }
 
-      amount += remaining;
+        public Builder setDefaultThrowableHandler(ThrowableHandler throwableHandler) {
+            this.defaultThrowableHandler = throwableHandler;
+            return this;
+        }
 
-      if (listener != null) {
-        listener.onBytesReceived(uri, amount, remaining, total);
-      }
-    }
+        /**
+         * This setting controls whether an error document should be written via
+         * the {@link BodyConsumer} after an error status code was received (e.g.
+         * 404). Default is {@link ErrorDocumentBehaviour#WRITE}.
+         * 
+         * @param behaviour the behaviour
+         * @return this
+         */
+        public Builder setErrorDocumentBehaviour(ErrorDocumentBehaviour behaviour) {
+            this.errorDocumentBehaviour = behaviour;
+            return this;
+        }
+
+        /**
+         * Enable resumable downloads for the SimpleAHC. Resuming downloads will only work for GET requests
+         * with an instance of {@link ResumableBodyConsumer}.
+         */
+        @Override
+        public Builder setResumableDownload(boolean enableResumableDownload) {
+            this.enableResumableDownload = enableResumableDownload;
+            return this;
+        }
+
+        /**
+         * Set the listener to notify about connection progress.
+         * 
+         * @param listener a listener
+         * @return this
+         */
+        public Builder setListener(SimpleAHCTransferListener listener) {
+            this.listener = listener;
+            return this;
+        }
+
+        /**
+         * Set the number of time a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
+         *
+         * @param maxRequestRetry the number of time a request will be retried
+         * @return this
+         */
+        public Builder setMaxRequestRetry(int maxRequestRetry) {
+            configBuilder.setMaxRequestRetry(maxRequestRetry);
+            return this;
+        }
+
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            configBuilder.setUseInsecureTrustManager(acceptAnyCertificate);
+            return this;
+        }
+
+        public SimpleAsyncHttpClient build() {
+
+            if (realmBuilder != null) {
+                configBuilder.setRealm(realmBuilder.build());
+            }
+
+            if (proxyHost != null) {
+                Realm realm = null;
+                if (proxyPrincipal != null) {
+                    AuthScheme proxyAuthScheme = withDefault(this.proxyAuthScheme, AuthScheme.BASIC);
+                    realm = realm(proxyAuthScheme, proxyPrincipal, proxyPassword).build();
+                }
 
-    private void fireHeaders(HttpHeaders headers) {
-      if (listener != null) {
-        listener.onHeaders(uri, headers);
-      }
+                configBuilder.setProxyServer(proxyServer(proxyHost, proxyPort).setRealm(realm).build());
+            }
+
+            configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
+
+            SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
+                    errorDocumentBehaviour, enableResumableDownload, ahc, listener);
+
+            return sc;
+        }
     }
 
-    private void fireSent(Uri uri, long amount, long current, long total) {
-      if (listener != null) {
-        listener.onBytesSent(uri, amount, current, total);
-      }
+    private final static class ResumableBodyConsumerAsyncHandler extends ResumableAsyncHandler implements ProgressAsyncHandler<Response> {
+
+        private final ProgressAsyncHandler<Response> delegate;
+
+        public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHandler<Response> delegate) {
+            super(byteTransferred, delegate);
+            this.delegate = delegate;
+        }
+
+        public AsyncHandler.State onHeadersWritten() {
+            return delegate.onHeadersWritten();
+        }
+
+        public AsyncHandler.State onContentWritten() {
+            return delegate.onContentWritten();
+        }
+
+        public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
+            return delegate.onContentWriteProgress(amount, current, total);
+        }
     }
 
-    private void fireCompleted(Response response) {
-      if (listener != null) {
-        listener.onCompleted(uri, response.getStatusCode(), response.getStatusText());
-      }
+    private final static class BodyConsumerAsyncHandler extends AsyncCompletionHandlerBase {
+
+        private final BodyConsumer bodyConsumer;
+        private final ThrowableHandler exceptionHandler;
+        private final ErrorDocumentBehaviour errorDocumentBehaviour;
+        private final Uri uri;
+        private final SimpleAHCTransferListener listener;
+
+        private boolean accumulateBody = false;
+        private boolean omitBody = false;
+        private int amount = 0;
+        private long total = -1;
+
+        public BodyConsumerAsyncHandler(BodyConsumer bodyConsumer, ThrowableHandler exceptionHandler,
+                ErrorDocumentBehaviour errorDocumentBehaviour, Uri uri, SimpleAHCTransferListener listener) {
+            this.bodyConsumer = bodyConsumer;
+            this.exceptionHandler = exceptionHandler;
+            this.errorDocumentBehaviour = errorDocumentBehaviour;
+            this.uri = uri;
+            this.listener = listener;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            try {
+                if (exceptionHandler != null) {
+                    exceptionHandler.onThrowable(t);
+                } else {
+                    super.onThrowable(t);
+                }
+            } finally {
+                closeConsumer();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+            fireReceived(content);
+            if (omitBody) {
+                return State.CONTINUE;
+            }
+
+            if (!accumulateBody && bodyConsumer != null) {
+                bodyConsumer.consume(content.getBodyByteBuffer());
+            } else {
+                return super.onBodyPartReceived(content);
+            }
+            return State.CONTINUE;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+            fireCompleted(response);
+            closeConsumer();
+            return super.onCompleted(response);
+        }
+
+        private void closeConsumer() {
+            if (bodyConsumer != null)
+                closeSilently(bodyConsumer);
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus status) throws Exception {
+            fireStatus(status);
+
+            if (isErrorStatus(status)) {
+                switch (errorDocumentBehaviour) {
+                case ACCUMULATE:
+                    accumulateBody = true;
+                    break;
+                case OMIT:
+                    omitBody = true;
+                    break;
+                default:
+                    break;
+                }
+            }
+            return super.onStatusReceived(status);
+        }
+
+        private boolean isErrorStatus(HttpResponseStatus status) {
+            return status.getStatusCode() >= 400;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            calculateTotal(headers);
+
+            fireHeaders(headers);
+
+            return super.onHeadersReceived(headers);
+        }
+
+        private void calculateTotal(HttpHeaders headers) {
+            String length = headers.get(CONTENT_LENGTH);
+
+            try {
+                total = Integer.valueOf(length);
+            } catch (Exception e) {
+                total = -1;
+            }
+        }
+
+        @Override
+        public State onContentWriteProgress(long amount, long current, long total) {
+            fireSent(uri, amount, current, total);
+            return super.onContentWriteProgress(amount, current, total);
+        }
+
+        private void fireStatus(HttpResponseStatus status) {
+            if (listener != null) {
+                listener.onStatus(uri, status.getStatusCode(), status.getStatusText());
+            }
+        }
+
+        private void fireReceived(HttpResponseBodyPart content) {
+            int remaining = content.getBodyByteBuffer().remaining();
+
+            amount += remaining;
+
+            if (listener != null) {
+                listener.onBytesReceived(uri, amount, remaining, total);
+            }
+        }
+
+        private void fireHeaders(HttpHeaders headers) {
+            if (listener != null) {
+                listener.onHeaders(uri, headers);
+            }
+        }
+
+        private void fireSent(Uri uri, long amount, long current, long total) {
+            if (listener != null) {
+                listener.onBytesSent(uri, amount, current, total);
+            }
+        }
+
+        private void fireCompleted(Response response) {
+            if (listener != null) {
+                listener.onCompleted(uri, response.getStatusCode(), response.getStatusText());
+            }
+        }
     }
-  }
 }
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
index c0956e93c..50d7671c0 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/ThrowableHandler.java
@@ -1,15 +1,15 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
+* Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+*
+* This program is licensed to you under the Apache License Version 2.0,
+* and you may not use this file except in compliance with the Apache License Version 2.0.
+* You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the Apache License Version 2.0 is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+*/
 
 package org.asynchttpclient.extras.simple;
 
@@ -19,5 +19,5 @@
  */
 public interface ThrowableHandler {
 
-  void onThrowable(Throwable t);
+    void onThrowable(Throwable t);
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
index 4567b38c3..80cd0e97c 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
@@ -1,5 +1,12 @@
 package org.asynchttpclient.extras.simple;
 
+import static org.asynchttpclient.test.TestUtils.*;
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.test.EchoHandler;
@@ -11,59 +18,51 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-
-import static org.asynchttpclient.test.TestUtils.addHttpConnector;
-import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
-import static org.testng.Assert.assertEquals;
-
 public class HttpsProxyTest extends AbstractBasicTest {
 
-  private Server server2;
+    private Server server2;
 
-  public AbstractHandler configureHandler() {
-    return new ConnectHandler();
-  }
+    public AbstractHandler configureHandler() throws Exception {
+        return new ConnectHandler();
+    }
 
-  @BeforeClass(alwaysRun = true)
-  public void setUpGlobal() throws Exception {
-    server = new Server();
-    ServerConnector connector1 = addHttpConnector(server);
-    server.setHandler(configureHandler());
-    server.start();
-    port1 = connector1.getLocalPort();
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        server = new Server();
+        ServerConnector connector1 = addHttpConnector(server);
+        server.setHandler(configureHandler());
+        server.start();
+        port1 = connector1.getLocalPort();
 
-    server2 = new Server();
-    ServerConnector connector2 = addHttpsConnector(server2);
-    server2.setHandler(new EchoHandler());
-    server2.start();
-    port2 = connector2.getLocalPort();
+        server2 = new Server();
+        ServerConnector connector2 = addHttpsConnector(server2);
+        server2.setHandler(new EchoHandler());
+        server2.start();
+        port2 = connector2.getLocalPort();
 
-    logger.info("Local HTTP server started successfully");
-  }
+        logger.info("Local HTTP server started successfully");
+    }
 
-  @AfterClass(alwaysRun = true)
-  public void tearDownGlobal() throws Exception {
-    server.stop();
-    server2.stop();
-  }
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        server.stop();
+        server2.stop();
+    }
 
-  @Test
-  public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException {
+    @Test(groups = "online")
+    public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setProxyHost("localhost")
-            .setProxyPort(port1)
-            .setFollowRedirect(true)
-            .setUrl(getTargetUrl2())
-            .setAcceptAnyCertificate(true)
-            .setHeader("Content-Type", "text/html")
-            .build()) {
-      Response r = client.get().get();
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setProxyHost("localhost")//
+                .setProxyPort(port1)//
+                .setFollowRedirect(true)//
+                .setUrl(getTargetUrl2())//
+                .setAcceptAnyCertificate(true)//
+                .setHeader("Content-Type", "text/html")//
+                .build()) {
+            Response r = client.get().get();
 
-      assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getStatusCode(), 200);
+        }
     }
-  }
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
index a9c628389..f2ca7f76c 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
@@ -12,68 +12,69 @@
  */
 package org.asynchttpclient.extras.simple;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.extras.simple.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.concurrent.Future;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.extras.simple.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
 
 /**
  * @author Benjamin Hanzelmann
+ * 
  */
 public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
+    
+    @Test(groups = "standalone")
+    public void testAccumulateErrorBody() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setUrl(getTargetUrl() + "/nonexistent")//
+                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
-  @Test
-  public void testAccumulateErrorBody() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setUrl(getTargetUrl() + "/nonexistent")
-            .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-      Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-
-      System.out.println("waiting for response");
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 404);
-      assertEquals(o.toString(), "");
-      assertTrue(response.getResponseBody().startsWith("<html>"));
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertTrue(response.getResponseBody().startsWith("<html>"));
+        }
     }
-  }
 
-  @Test
-  public void testOmitErrorBody() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setUrl(getTargetUrl() + "/nonexistent")
-            .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-      Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+    @Test(groups = "standalone")
+    public void testOmitErrorBody() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setUrl(getTargetUrl() + "/nonexistent")//
+                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
-      System.out.println("waiting for response");
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 404);
-      assertEquals(o.toString(), "");
-      assertEquals(response.getResponseBody(), "");
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertEquals(response.getResponseBody(), "");
+        }
     }
-  }
 
-  @Override
-  public AbstractHandler configureHandler() {
-    return new AbstractHandler() {
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
 
-      public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {
-        response.sendError(404);
-        baseRequest.setHandled(true);
-      }
-    };
-  }
+            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                response.sendError(404);
+                baseRequest.setHandled(true);
+            }
+        };
+    }
 
 }
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
index 42ca1d7a7..b02b8c2f1 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
@@ -12,14 +12,9 @@
  */
 package org.asynchttpclient.extras.simple;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.request.body.generator.FileBodyGenerator;
-import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.multipart.ByteArrayPart;
-import org.asynchttpclient.uri.Uri;
-import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -30,292 +25,297 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
 
 public class SimpleAsyncHttpClientTest extends AbstractBasicTest {
 
-  private final static String MY_MESSAGE = "my message";
+    private final static String MY_MESSAGE = "my message";
 
-  @Test
-  public void inputStreamBodyConsumerTest() throws Exception {
+    @Test(groups = "standalone")
+    public void inputStreamBodyConsumerTest() throws Exception {
 
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setPooledConnectionIdleTimeout(100)
-            .setMaxConnections(50)
-            .setRequestTimeout(5 * 60 * 1000)
-            .setUrl(getTargetUrl())
-            .setHeader("Content-Type", "text/html").build()) {
-      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(response.getResponseBody(), MY_MESSAGE);
-    }
-  }
-
-  @Test
-  public void stringBuilderBodyConsumerTest() throws Exception {
-
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setPooledConnectionIdleTimeout(100)
-            .setMaxConnections(50)
-            .setRequestTimeout(5 * 60 * 1000)
-            .setUrl(getTargetUrl())
-            .setHeader("Content-Type", "text/html").build()) {
-      StringBuilder s = new StringBuilder();
-      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
-
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(s.toString(), MY_MESSAGE);
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        }
     }
-  }
-
-  @Test
-  public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
-
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setPooledConnectionIdleTimeout(100).setMaxConnections(50)
-            .setRequestTimeout(5 * 60 * 1000)
-            .setUrl(getTargetUrl())
-            .setHeader("Content-Type", "text/html").build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(o.toString(), MY_MESSAGE);
+
+    @Test(groups = "standalone")
+    public void stringBuilderBodyConsumerTest() throws Exception {
+
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
+            StringBuilder s = new StringBuilder();
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(s.toString(), MY_MESSAGE);
+        }
     }
-  }
 
-  @Test
-  public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
+    @Test(groups = "standalone")
+    public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-      Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100).setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
-      Response response = future.get();
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(o.toString(), MY_MESSAGE);
-    }
-  }
-
-  /**
-   * See https://issues.sonatype.org/browse/AHC-5
-   */
-  @Test
-  public void testPutZeroBytesFileTest() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setPooledConnectionIdleTimeout(100)
-            .setMaxConnections(50)
-            .setRequestTimeout(5 * 1000)
-            .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")
-            .setHeader("Content-Type", "text/plain").build()) {
-      File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
-      tmpfile.deleteOnExit();
-
-      Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
-
-      System.out.println("waiting for response");
-      Response response = future.get();
-
-      tmpfile.delete();
-
-      assertEquals(response.getStatusCode(), 200);
-    }
-  }
-
-  @Test
-  public void testDerive() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-      try (SimpleAsyncHttpClient derived = client.derive().build()) {
-        assertNotSame(derived, client);
-      }
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        }
     }
-  }
-
-  @Test
-  public void testDeriveOverrideURL() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-      InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-      OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+    @Test(groups = "standalone")
+    public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-      try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
-        Future<Response> future = derived.post(generator, consumer);
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-      }
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        }
     }
-  }
 
-  @Test
-  public void testSimpleTransferListener() throws Exception {
+    /**
+     * See https://issues.sonatype.org/browse/AHC-5
+     */
+    @Test(groups = "standalone", enabled = true)
+    public void testPutZeroBytesFileTest() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 1000)//
+                .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")//
+                .setHeader("Content-Type", "text/plain").build()) {
+            File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
+            tmpfile.deleteOnExit();
 
-    final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
+            Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
 
-    SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
+            System.out.println("waiting for response");
+            Response response = future.get();
 
-      public void onStatus(Uri uri, int statusCode, String statusText) {
-        try {
-          assertEquals(statusCode, 200);
-          assertEquals(uri.toUrl(), getTargetUrl());
-        } catch (Error e) {
-          errors.add(e);
-          throw e;
-        }
-      }
-
-      public void onHeaders(Uri uri, HttpHeaders headers) {
-        try {
-          assertEquals(uri.toUrl(), getTargetUrl());
-          assertNotNull(headers);
-          assertTrue(!headers.isEmpty());
-          assertEquals(headers.get("X-Custom"), "custom");
-        } catch (Error e) {
-          errors.add(e);
-          throw e;
-        }
-      }
-
-      public void onCompleted(Uri uri, int statusCode, String statusText) {
-        try {
-          assertEquals(statusCode, 200);
-          assertEquals(uri.toUrl(), getTargetUrl());
-        } catch (Error e) {
-          errors.add(e);
-          throw e;
-        }
-      }
-
-      public void onBytesSent(Uri uri, long amount, long current, long total) {
-        try {
-          assertEquals(uri.toUrl(), getTargetUrl());
-          // FIXME Netty bug, see
-          // https://github.com/netty/netty/issues/1855
-          // assertEquals(total, MY_MESSAGE.getBytes().length);
-        } catch (Error e) {
-          errors.add(e);
-          throw e;
-        }
-      }
-
-      public void onBytesReceived(Uri uri, long amount, long current, long total) {
-        try {
-          assertEquals(uri.toUrl(), getTargetUrl());
-          assertEquals(total, -1);
-        } catch (Error e) {
-          errors.add(e);
-          throw e;
+            tmpfile.delete();
+
+            assertEquals(response.getStatusCode(), 200);
         }
-      }
-    };
+    }
 
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-            .setUrl(getTargetUrl())
-            .setHeader("Custom", "custom")
-            .setListener(listener).build()) {
-      ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+    @Test(groups = "standalone")
+    public void testDerive() throws Exception {
+        try(SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
+            try(SimpleAsyncHttpClient derived = client.derive().build()) {
+                assertNotSame(derived, client);
+            }
+        }
+    }
 
-      InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-      OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+    @Test(groups = "standalone")
+    public void testDeriveOverrideURL() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-      Future<Response> future = client.post(generator, consumer);
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-      Response response = future.get();
+            try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
+                Future<Response> future = derived.post(generator, consumer);
 
-      if (!errors.isEmpty()) {
-        for (Error e : errors) {
-          e.printStackTrace();
+                Response response = future.get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(o.toString(), MY_MESSAGE);
+            }
         }
-        throw errors.get(0);
-      }
+    }
 
-      assertEquals(response.getStatusCode(), 200);
-      assertEquals(o.toString(), MY_MESSAGE);
+    @Test(groups = "standalone")
+    public void testSimpleTransferListener() throws Exception {
+
+        final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
+
+        SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
+
+            public void onStatus(Uri uri, int statusCode, String statusText) {
+                try {
+                    assertEquals(statusCode, 200);
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
+            }
+
+            public void onHeaders(Uri uri, HttpHeaders headers) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    assertNotNull(headers);
+                    assertTrue(!headers.isEmpty());
+                    assertEquals(headers.get("X-Custom"), "custom");
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
+            }
+
+            public void onCompleted(Uri uri, int statusCode, String statusText) {
+                try {
+                    assertEquals(statusCode, 200);
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
+            }
+
+            public void onBytesSent(Uri uri, long amount, long current, long total) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    // FIXME Netty bug, see
+                    // https://github.com/netty/netty/issues/1855
+                    // assertEquals(total, MY_MESSAGE.getBytes().length);
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
+            }
+
+            public void onBytesReceived(Uri uri, long amount, long current, long total) {
+                try {
+                    assertEquals(uri.toUrl(), getTargetUrl());
+                    assertEquals(total, -1);
+                } catch (Error e) {
+                    errors.add(e);
+                    throw e;
+                }
+            }
+        };
+
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setUrl(getTargetUrl())//
+                .setHeader("Custom", "custom")//
+                .setListener(listener).build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+
+            Future<Response> future = client.post(generator, consumer);
+
+            Response response = future.get();
+
+            if (!errors.isEmpty()) {
+                for (Error e : errors) {
+                    e.printStackTrace();
+                }
+                throw errors.get(0);
+            }
+
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        }
     }
-  }
 
-  @Test
-  public void testNullUrl() throws Exception {
+    @Test(groups = "standalone")
+    public void testNullUrl() throws Exception {
 
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
-      assertTrue(true);
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
+            assertTrue(true);
+        }
     }
-  }
 
-  @Test
-  public void testCloseDerivedValidMaster() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
-      try (SimpleAsyncHttpClient derived = client.derive().build()) {
-        derived.get().get();
-      }
+    @Test(groups = "standalone")
+    public void testCloseDerivedValidMaster() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
+            try (SimpleAsyncHttpClient derived = client.derive().build()) {
+                derived.get().get();
+            }
 
-      Response response = client.get().get();
-      assertEquals(response.getStatusCode(), 200);
-    }
-  }
-
-  @Test(expectedExceptions = IllegalStateException.class)
-  public void testCloseMasterInvalidDerived() throws Throwable {
-    SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-    try (SimpleAsyncHttpClient derived = client.derive().build()) {
-      client.close();
-
-      try {
-        derived.get().get();
-        fail("Expected closed AHC");
-      } catch (ExecutionException e) {
-        throw e.getCause();
-      }
+            Response response = client.get().get();
+            assertEquals(response.getStatusCode(), 200);
+        }
     }
 
-  }
+    @Test(groups = "standalone", expectedExceptions = IllegalStateException.class)
+    public void testCloseMasterInvalidDerived() throws Throwable {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
+        try (SimpleAsyncHttpClient derived = client.derive().build()) {
+            client.close();
+            
+            try {
+                derived.get().get();
+                fail("Expected closed AHC");
+            } catch (ExecutionException e) {
+                throw e.getCause();
+            }
+        }
+
+    }
 
-  @Test
-  public void testMultiPartPut() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-      Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
+    @Test(groups = "standalone")
+    public void testMultiPartPut() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
-      String body = response.getResponseBody();
-      String contentType = response.getHeader("X-Content-Type");
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
 
-      assertTrue(contentType.contains("multipart/form-data"));
+            assertTrue(contentType.contains("multipart/form-data"));
 
-      String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
 
-      assertTrue(body.startsWith("--" + boundary));
-      assertTrue(body.trim().endsWith("--" + boundary + "--"));
-      assertTrue(body.contains("Content-Disposition:"));
-      assertTrue(body.contains("Content-Type: application/test"));
-      assertTrue(body.contains("name=\"baPart"));
-      assertTrue(body.contains("filename=\"fileName"));
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        }
     }
-  }
 
-  @Test
-  public void testMultiPartPost() throws Exception {
-    try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
-      Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
+    @Test(groups = "standalone")
+    public void testMultiPartPost() throws Exception {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
-      String body = response.getResponseBody();
-      String contentType = response.getHeader("X-Content-Type");
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
 
-      assertTrue(contentType.contains("multipart/form-data"));
+            assertTrue(contentType.contains("multipart/form-data"));
 
-      String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
 
-      assertTrue(body.startsWith("--" + boundary));
-      assertTrue(body.trim().endsWith("--" + boundary + "--"));
-      assertTrue(body.contains("Content-Disposition:"));
-      assertTrue(body.contains("Content-Type: application/test"));
-      assertTrue(body.contains("name=\"baPart"));
-      assertTrue(body.contains("filename=\"fileName"));
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        }
     }
-  }
 }
diff --git a/extras/typesafeconfig/README.md b/extras/typesafeconfig/README.md
deleted file mode 100644
index 3078cac2d..000000000
--- a/extras/typesafeconfig/README.md
+++ /dev/null
@@ -1,34 +0,0 @@
-# Async-http-client and Typesafe Config integration
-
-An `AsyncHttpClientConfig` implementation integrating [Typesafe Config][1] with Async Http Client.
-## Download
-
-Download [the latest JAR][2] or grab via [Maven][3]:
-
-```xml
-<dependency>
-  <groupId>org.asynchttpclient</groupId>
-  <artifactId>async-http-client-extras-typesafeconfig</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-
-or [Gradle][3]:
-
-```groovy
-compile "org.asynchttpclient:async-http-client-extras-typesafeconfig:latest.version"
-```
-
- [1]: https://github.com/lightbend/config
- [2]: https://search.maven.org/remote_content?g=org.asynchttpclient&a=async-http-client-extras-typesafeconfig&v=LATEST
- [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.asynchttpclient%22%20a%3A%22async-http-client-extras-typesafeconfig%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
-
-## Example usage
-
-```java
-// creating async-http-client with Typesafe config
-com.typesafe.config.Config config = ...
-AsyncHttpClientTypesafeConfig ahcConfig = new AsyncHttpClientTypesafeConfig(config);
-AsyncHttpClient client = new DefaultAsyncHttpClient(ahcConfig);
-```
\ No newline at end of file
diff --git a/extras/typesafeconfig/pom.xml b/extras/typesafeconfig/pom.xml
deleted file mode 100644
index 127162b3b..000000000
--- a/extras/typesafeconfig/pom.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <artifactId>async-http-client-extras-parent</artifactId>
-    <groupId>org.asynchttpclient</groupId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>async-http-client-extras-typesafe-config</artifactId>
-  <name>Asynchronous Http Client Typesafe Config Extras</name>
-  <description>The Async Http Client Typesafe Config Extras.</description>
-
-  <properties>
-    <typesafeconfig.version>1.3.2</typesafeconfig.version>
-  </properties>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.typesafe</groupId>
-      <artifactId>config</artifactId>
-      <version>${typesafeconfig.version}</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java b/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java
deleted file mode 100644
index 05a985602..000000000
--- a/extras/typesafeconfig/src/main/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfig.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.typesafeconfig;
-
-import com.typesafe.config.Config;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.handler.ssl.SslContext;
-import io.netty.util.Timer;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.SslEngineFactory;
-import org.asynchttpclient.channel.ChannelPool;
-import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
-import org.asynchttpclient.channel.KeepAliveStrategy;
-import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
-import org.asynchttpclient.cookie.CookieStore;
-import org.asynchttpclient.cookie.ThreadSafeCookieStore;
-import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.filter.RequestFilter;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.proxy.ProxyServerSelector;
-
-import java.util.*;
-import java.util.concurrent.ThreadFactory;
-import java.util.function.Consumer;
-import java.util.function.Function;
-
-import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
-
-public class AsyncHttpClientTypesafeConfig implements AsyncHttpClientConfig {
-
-  private final Config config;
-
-  public AsyncHttpClientTypesafeConfig(Config config) {
-    this.config = config;
-  }
-
-  @Override
-  public String getAhcVersion() {
-    return AsyncHttpClientConfigDefaults.AHC_VERSION;
-  }
-
-  @Override
-  public String getThreadPoolName() {
-    return getStringOpt(THREAD_POOL_NAME_CONFIG).orElse(defaultThreadPoolName());
-  }
-
-  @Override
-  public int getMaxConnections() {
-    return getIntegerOpt(MAX_CONNECTIONS_CONFIG).orElse(defaultMaxConnections());
-  }
-
-  @Override
-  public int getMaxConnectionsPerHost() {
-    return getIntegerOpt(MAX_CONNECTIONS_PER_HOST_CONFIG).orElse(defaultMaxConnectionsPerHost());
-  }
-
-  @Override
-  public int getConnectTimeout() {
-    return getIntegerOpt(CONNECTION_TIMEOUT_CONFIG).orElse(defaultConnectTimeout());
-  }
-
-  @Override
-  public int getReadTimeout() {
-    return getIntegerOpt(READ_TIMEOUT_CONFIG).orElse(defaultReadTimeout());
-  }
-
-  @Override
-  public int getPooledConnectionIdleTimeout() {
-    return getIntegerOpt(POOLED_CONNECTION_IDLE_TIMEOUT_CONFIG).orElse(defaultPooledConnectionIdleTimeout());
-  }
-
-  @Override
-  public int getConnectionPoolCleanerPeriod() {
-    return getIntegerOpt(CONNECTION_POOL_CLEANER_PERIOD_CONFIG).orElse(defaultConnectionPoolCleanerPeriod());
-  }
-
-  @Override
-  public int getRequestTimeout() {
-    return getIntegerOpt(REQUEST_TIMEOUT_CONFIG).orElse(defaultRequestTimeout());
-  }
-
-  @Override
-  public boolean isFollowRedirect() {
-    return getBooleanOpt(FOLLOW_REDIRECT_CONFIG).orElse(defaultFollowRedirect());
-  }
-
-  @Override
-  public int getMaxRedirects() {
-    return getIntegerOpt(MAX_REDIRECTS_CONFIG).orElse(defaultMaxRedirects());
-  }
-
-  @Override
-  public boolean isKeepAlive() {
-    return getBooleanOpt(KEEP_ALIVE_CONFIG).orElse(defaultKeepAlive());
-  }
-
-  @Override
-  public String getUserAgent() {
-    return getStringOpt(USER_AGENT_CONFIG).orElse(defaultUserAgent());
-  }
-
-  @Override
-  public boolean isCompressionEnforced() {
-    return getBooleanOpt(COMPRESSION_ENFORCED_CONFIG).orElse(defaultCompressionEnforced());
-  }
-
-  @Override
-  public ThreadFactory getThreadFactory() {
-    return null;
-  }
-
-  @Override
-  public ProxyServerSelector getProxyServerSelector() {
-    return ProxyServerSelector.NO_PROXY_SELECTOR;
-  }
-
-  @Override
-  public SslContext getSslContext() {
-    return null;
-  }
-
-  @Override
-  public Realm getRealm() {
-    return null;
-  }
-
-  @Override
-  public List<RequestFilter> getRequestFilters() {
-    return new LinkedList<>();
-  }
-
-  @Override
-  public List<ResponseFilter> getResponseFilters() {
-    return new LinkedList<>();
-  }
-
-  @Override
-  public List<IOExceptionFilter> getIoExceptionFilters() {
-    return new LinkedList<>();
-  }
-
-  @Override
-  public CookieStore getCookieStore() {
-    return new ThreadSafeCookieStore();
-  }
-
-  @Override
-  public int getMaxRequestRetry() {
-    return getIntegerOpt(MAX_REQUEST_RETRY_CONFIG).orElse(defaultMaxRequestRetry());
-  }
-
-  @Override
-  public boolean isDisableUrlEncodingForBoundRequests() {
-    return getBooleanOpt(DISABLE_URL_ENCODING_FOR_BOUND_REQUESTS_CONFIG).orElse(defaultDisableUrlEncodingForBoundRequests());
-  }
-
-  @Override
-  public boolean isUseLaxCookieEncoder() {
-    return getBooleanOpt(USE_LAX_COOKIE_ENCODER_CONFIG).orElse(defaultUseLaxCookieEncoder());
-  }
-
-  @Override
-  public boolean isStrict302Handling() {
-    return getBooleanOpt(STRICT_302_HANDLING_CONFIG).orElse(defaultStrict302Handling());
-  }
-
-  @Override
-  public int getConnectionTtl() {
-    return getIntegerOpt(CONNECTION_TTL_CONFIG).orElse(defaultConnectionTtl());
-  }
-
-  @Override
-  public boolean isUseOpenSsl() {
-    return getBooleanOpt(USE_OPEN_SSL_CONFIG).orElse(defaultUseOpenSsl());
-  }
-
-  @Override
-  public boolean isUseInsecureTrustManager() {
-    return getBooleanOpt(USE_INSECURE_TRUST_MANAGER_CONFIG).orElse(defaultUseInsecureTrustManager());
-  }
-
-  @Override
-  public boolean isDisableHttpsEndpointIdentificationAlgorithm() {
-    return getBooleanOpt(DISABLE_HTTPS_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG).orElse(defaultDisableHttpsEndpointIdentificationAlgorithm());
-  }
-
-  @Override
-  public String[] getEnabledProtocols() {
-    return getListOpt(ENABLED_PROTOCOLS_CONFIG).map(list -> list.toArray(new String[0])).orElse(defaultEnabledProtocols());
-  }
-
-  @Override
-  public String[] getEnabledCipherSuites() {
-    return getListOpt(ENABLED_CIPHER_SUITES_CONFIG).map(list -> list.toArray(new String[0])).orElse(defaultEnabledCipherSuites());
-  }
-
-  @Override
-  public int getSslSessionCacheSize() {
-    return getIntegerOpt(SSL_SESSION_CACHE_SIZE_CONFIG).orElse(defaultSslSessionCacheSize());
-  }
-
-  @Override
-  public int getSslSessionTimeout() {
-    return getIntegerOpt(SSL_SESSION_TIMEOUT_CONFIG).orElse(defaultSslSessionTimeout());
-  }
-
-  @Override
-  public int getHttpClientCodecMaxInitialLineLength() {
-    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH_CONFIG).orElse(defaultHttpClientCodecMaxInitialLineLength());
-  }
-
-  @Override
-  public int getHttpClientCodecMaxHeaderSize() {
-    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_HEADER_SIZE_CONFIG).orElse(defaultHttpClientCodecMaxHeaderSize());
-  }
-
-  @Override
-  public int getHttpClientCodecMaxChunkSize() {
-    return getIntegerOpt(HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE_CONFIG).orElse(defaultHttpClientCodecMaxChunkSize());
-  }
-
-  @Override
-  public int getHttpClientCodecInitialBufferSize() {
-    return getIntegerOpt(HTTP_CLIENT_CODEC_INITIAL_BUFFER_SIZE_CONFIG).orElse(defaultHttpClientCodecInitialBufferSize());
-  }
-
-  @Override
-  public boolean isDisableZeroCopy() {
-    return getBooleanOpt(DISABLE_ZERO_COPY_CONFIG).orElse(defaultDisableZeroCopy());
-  }
-
-  @Override
-  public int getHandshakeTimeout() {
-    return getIntegerOpt(HANDSHAKE_TIMEOUT_CONFIG).orElse(defaultHandshakeTimeout());
-  }
-
-  @Override
-  public SslEngineFactory getSslEngineFactory() {
-    return null;
-  }
-
-  @Override
-  public int getChunkedFileChunkSize() {
-    return getIntegerOpt(CHUNKED_FILE_CHUNK_SIZE_CONFIG).orElse(defaultChunkedFileChunkSize());
-  }
-
-  @Override
-  public int getWebSocketMaxBufferSize() {
-    return getIntegerOpt(WEBSOCKET_MAX_BUFFER_SIZE_CONFIG).orElse(defaultWebSocketMaxBufferSize());
-  }
-
-  @Override
-  public int getWebSocketMaxFrameSize() {
-    return getIntegerOpt(WEBSOCKET_MAX_FRAME_SIZE_CONFIG).orElse(defaultWebSocketMaxFrameSize());
-  }
-
-  @Override
-  public boolean isKeepEncodingHeader() {
-    return getBooleanOpt(KEEP_ENCODING_HEADER_CONFIG).orElse(defaultKeepEncodingHeader());
-  }
-
-  @Override
-  public int getShutdownQuietPeriod() {
-    return getIntegerOpt(SHUTDOWN_QUIET_PERIOD_CONFIG).orElse(defaultShutdownQuietPeriod());
-  }
-
-  @Override
-  public int getShutdownTimeout() {
-    return getIntegerOpt(SHUTDOWN_TIMEOUT_CONFIG).orElse(defaultShutdownTimeout());
-  }
-
-  @Override
-  public Map<ChannelOption<Object>, Object> getChannelOptions() {
-    return Collections.emptyMap();
-  }
-
-  @Override
-  public EventLoopGroup getEventLoopGroup() {
-    return null;
-  }
-
-  @Override
-  public boolean isUseNativeTransport() {
-    return getBooleanOpt(USE_NATIVE_TRANSPORT_CONFIG).orElse(defaultUseNativeTransport());
-  }
-
-  @Override
-  public Consumer<Channel> getHttpAdditionalChannelInitializer() {
-    return null;
-  }
-
-  @Override
-  public Consumer<Channel> getWsAdditionalChannelInitializer() {
-    return null;
-  }
-
-  @Override
-  public ResponseBodyPartFactory getResponseBodyPartFactory() {
-    return ResponseBodyPartFactory.EAGER;
-  }
-
-  @Override
-  public ChannelPool getChannelPool() {
-    return null;
-  }
-
-  @Override
-  public Timer getNettyTimer() {
-    return null;
-  }
-
-  @Override
-  public KeepAliveStrategy getKeepAliveStrategy() {
-    return new DefaultKeepAliveStrategy();
-  }
-
-  @Override
-  public boolean isValidateResponseHeaders() {
-    return getBooleanOpt(VALIDATE_RESPONSE_HEADERS_CONFIG).orElse(defaultValidateResponseHeaders());
-  }
-
-  @Override
-  public boolean isAggregateWebSocketFrameFragments() {
-    return getBooleanOpt(AGGREGATE_WEBSOCKET_FRAME_FRAGMENTS_CONFIG).orElse(defaultAggregateWebSocketFrameFragments());
-  }
-
-  @Override
-  public boolean isEnableWebSocketCompression() {
-    return getBooleanOpt(ENABLE_WEBSOCKET_COMPRESSION_CONFIG).orElse(defaultEnableWebSocketCompression());
-  }
-
-  @Override
-  public boolean isTcpNoDelay() {
-    return getBooleanOpt(TCP_NO_DELAY_CONFIG).orElse(defaultTcpNoDelay());
-  }
-
-  @Override
-  public boolean isSoReuseAddress() {
-    return getBooleanOpt(SO_REUSE_ADDRESS_CONFIG).orElse(defaultSoReuseAddress());
-  }
-
-  @Override
-  public int getSoLinger() {
-    return getIntegerOpt(SO_LINGER_CONFIG).orElse(defaultSoLinger());
-  }
-
-  @Override
-  public int getSoSndBuf() {
-    return getIntegerOpt(SO_SND_BUF_CONFIG).orElse(defaultSoSndBuf());
-  }
-
-  @Override
-  public int getSoRcvBuf() {
-    return getIntegerOpt(SO_RCV_BUF_CONFIG).orElse(defaultSoRcvBuf());
-  }
-
-  @Override
-  public ByteBufAllocator getAllocator() {
-    return null;
-  }
-
-  @Override
-  public int getIoThreadsCount() {
-    return getIntegerOpt(IO_THREADS_COUNT_CONFIG).orElse(defaultIoThreadsCount());
-  }
-
-  private Optional<String> getStringOpt(String key) {
-    return getOpt(config::getString, key);
-  }
-
-  private Optional<Boolean> getBooleanOpt(String key) {
-    return getOpt(config::getBoolean, key);
-  }
-
-  private Optional<Integer> getIntegerOpt(String key) {
-    return getOpt(config::getInt, key);
-  }
-
-  private Optional<List<String>> getListOpt(String key) {
-    return getOpt(config::getStringList, key);
-  }
-
-  private <T> Optional<T> getOpt(Function<String, T> func, String key) {
-    return config.hasPath(key)
-        ? Optional.ofNullable(func.apply(key))
-        : Optional.empty();
-  }
-}
diff --git a/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java b/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java
deleted file mode 100644
index 1decc7749..000000000
--- a/extras/typesafeconfig/src/test/java/org/asynchttpclient/extras/typesafeconfig/AsyncHttpClientTypesafeConfigTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2018 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.typesafeconfig;
-
-import com.typesafe.config.ConfigFactory;
-import com.typesafe.config.ConfigValue;
-import com.typesafe.config.ConfigValueFactory;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.util.Arrays;
-import java.util.Optional;
-import java.util.function.Function;
-
-@Test
-public class AsyncHttpClientTypesafeConfigTest {
-
-  public void testThreadPoolName() {
-    test(AsyncHttpClientTypesafeConfig::getThreadPoolName, "threadPoolName", "MyHttpClient", "AsyncHttpClient");
-  }
-
-  public void testMaxTotalConnections() {
-    test(AsyncHttpClientTypesafeConfig::getMaxConnections, "maxConnections", 100, -1);
-  }
-
-  public void testMaxConnectionPerHost() {
-    test(AsyncHttpClientTypesafeConfig::getMaxConnectionsPerHost, "maxConnectionsPerHost", 100, -1);
-  }
-
-  public void testConnectTimeOut() {
-    test(AsyncHttpClientTypesafeConfig::getConnectTimeout, "connectTimeout", 100, 5 * 1000);
-  }
-
-  public void testPooledConnectionIdleTimeout() {
-    test(AsyncHttpClientTypesafeConfig::getPooledConnectionIdleTimeout, "pooledConnectionIdleTimeout", 200, 6 * 10000);
-  }
-
-  public void testReadTimeout() {
-    test(AsyncHttpClientTypesafeConfig::getReadTimeout, "readTimeout", 100, 60 * 1000);
-  }
-
-  public void testRequestTimeout() {
-    test(AsyncHttpClientTypesafeConfig::getRequestTimeout, "requestTimeout", 200, 6 * 10000);
-  }
-
-  public void testConnectionTtl() {
-    test(AsyncHttpClientTypesafeConfig::getConnectionTtl, "connectionTtl", 100, -1);
-  }
-
-  public void testFollowRedirect() {
-    test(AsyncHttpClientTypesafeConfig::isFollowRedirect, "followRedirect", true, false);
-  }
-
-  public void testMaxRedirects() {
-    test(AsyncHttpClientTypesafeConfig::getMaxRedirects, "maxRedirects", 100, 5);
-  }
-
-  public void testCompressionEnforced() {
-    test(AsyncHttpClientTypesafeConfig::isCompressionEnforced, "compressionEnforced", true, false);
-  }
-
-  public void testStrict302Handling() {
-    test(AsyncHttpClientTypesafeConfig::isStrict302Handling, "strict302Handling", true, false);
-  }
-
-  public void testAllowPoolingConnection() {
-    test(AsyncHttpClientTypesafeConfig::isKeepAlive, "keepAlive", false, true);
-  }
-
-  public void testMaxRequestRetry() {
-    test(AsyncHttpClientTypesafeConfig::getMaxRequestRetry, "maxRequestRetry", 100, 5);
-  }
-
-  public void testDisableUrlEncodingForBoundRequests() {
-    test(AsyncHttpClientTypesafeConfig::isDisableUrlEncodingForBoundRequests, "disableUrlEncodingForBoundRequests", true, false);
-  }
-
-  public void testUseInsecureTrustManager() {
-    test(AsyncHttpClientTypesafeConfig::isUseInsecureTrustManager, "useInsecureTrustManager", true, false);
-  }
-
-  public void testEnabledProtocols() {
-    test(AsyncHttpClientTypesafeConfig::getEnabledProtocols,
-        "enabledProtocols",
-        new String[]{"TLSv1.2", "TLSv1.1"},
-        new String[]{"TLSv1.2", "TLSv1.1", "TLSv1"},
-        Optional.of(obj -> ConfigValueFactory.fromIterable(Arrays.asList(obj)))
-    );
-  }
-
-  private <T> void test(Function<AsyncHttpClientTypesafeConfig, T> func,
-                        String configKey,
-                        T value,
-                        T defaultValue) {
-    test(func, configKey, value, defaultValue, Optional.empty());
-  }
-
-  private <T> void test(Function<AsyncHttpClientTypesafeConfig, T> func,
-                        String configKey,
-                        T value,
-                        T defaultValue,
-                        Optional<Function<T, ConfigValue>> toConfigValue) {
-    AsyncHttpClientTypesafeConfig defaultConfig = new AsyncHttpClientTypesafeConfig(ConfigFactory.empty());
-    Assert.assertEquals(func.apply(defaultConfig), defaultValue);
-
-    AsyncHttpClientTypesafeConfig config = new AsyncHttpClientTypesafeConfig(
-        ConfigFactory.empty().withValue(configKey, toConfigValue.orElse(ConfigValueFactory::fromAnyRef).apply(value))
-    );
-    Assert.assertEquals(func.apply(config), value);
-  }
-}
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
index ffa6f40ee..29815a010 100644
--- a/netty-utils/pom.xml
+++ b/netty-utils/pom.xml
@@ -1,17 +1,17 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-project</artifactId>
-    <version>2.2.1-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>async-http-client-netty-utils</artifactId>
-  <name>Asynchronous Http Client Netty Utils</name>
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.1.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-netty-utils</artifactId>
+	<name>Asynchronous Http Client Netty Utils</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-buffer</artifactId>
-    </dependency>
-  </dependencies>
+	<dependencies>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-buffer</artifactId>
+		</dependency>
+	</dependencies>
 </project>
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
index b95829ebf..f64f62e99 100755
--- a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
@@ -13,148 +13,60 @@
  */
 package org.asynchttpclient.netty.util;
 
+import static java.nio.charset.StandardCharsets.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.util.CharsetUtil;
 
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CoderResult;
-
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.netty.util.Utf8ByteBufCharsetDecoder.*;
 
 public final class ByteBufUtils {
 
-  private static final char[] EMPTY_CHARS = new char[0];
-  private static final ThreadLocal<CharBuffer> CHAR_BUFFERS = ThreadLocal.withInitial(() -> CharBuffer.allocate(1024));
-
-  private ByteBufUtils() {
-  }
-
-  public static byte[] byteBuf2Bytes(ByteBuf buf) {
-    int readable = buf.readableBytes();
-    int readerIndex = buf.readerIndex();
-    if (buf.hasArray()) {
-      byte[] array = buf.array();
-      if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-        return array;
-      }
+    private ByteBufUtils() {
     }
-    byte[] array = new byte[readable];
-    buf.getBytes(readerIndex, array);
-    return array;
-  }
 
-  public static String byteBuf2String(Charset charset, ByteBuf buf) {
-    return isUtf8OrUsAscii(charset) ? decodeUtf8(buf) : buf.toString(charset);
-  }
-
-  public static String byteBuf2String(Charset charset, ByteBuf... bufs) {
-    return isUtf8OrUsAscii(charset) ? decodeUtf8(bufs) : byteBuf2String0(charset, bufs);
-  }
-
-  public static char[] byteBuf2Chars(Charset charset, ByteBuf buf) {
-    return isUtf8OrUsAscii(charset) ? decodeUtf8Chars(buf) : decodeChars(buf, charset);
-  }
+    public static boolean isUtf8OrUsAscii(Charset charset) {
+        return charset.equals(UTF_8) || charset.equals(US_ASCII);
+    }
 
-  public static char[] byteBuf2Chars(Charset charset, ByteBuf... bufs) {
-    return isUtf8OrUsAscii(charset) ? decodeUtf8Chars(bufs) : byteBuf2Chars0(charset, bufs);
-  }
+    public static String byteBuf2StringDefault(Charset charset, ByteBuf... bufs) {
 
-  private static boolean isUtf8OrUsAscii(Charset charset) {
-    return charset.equals(UTF_8) || charset.equals(US_ASCII);
-  }
+        if (bufs.length == 1) {
+            return bufs[0].toString(charset);
+        }
 
-  private static char[] decodeChars(ByteBuf src, Charset charset) {
-    int readerIndex = src.readerIndex();
-    int len = src.readableBytes();
+        for (ByteBuf buf : bufs) {
+            buf.retain();
+        }
 
-    if (len == 0) {
-      return EMPTY_CHARS;
-    }
-    final CharsetDecoder decoder = CharsetUtil.decoder(charset);
-    final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());
-    CharBuffer dst = CHAR_BUFFERS.get();
-    if (dst.length() < maxLength) {
-      dst = CharBuffer.allocate(maxLength);
-      CHAR_BUFFERS.set(dst);
-    } else {
-      dst.clear();
-    }
-    if (src.nioBufferCount() == 1) {
-      // Use internalNioBuffer(...) to reduce object creation.
-      decode(decoder, src.internalNioBuffer(readerIndex, len), dst);
-    } else {
-      // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers
-      // are both backed by a byte array.
-      ByteBuf buffer = src.alloc().heapBuffer(len);
-      try {
-        buffer.writeBytes(src, readerIndex, len);
-        // Use internalNioBuffer(...) to reduce object creation.
-        decode(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);
-      } finally {
-        // Release the temporary buffer again.
-        buffer.release();
-      }
-    }
-    dst.flip();
-    return toCharArray(dst);
-  }
+        ByteBuf composite = Unpooled.wrappedBuffer(bufs);
 
-  static String byteBuf2String0(Charset charset, ByteBuf... bufs) {
-    if (bufs.length == 1) {
-      return bufs[0].toString(charset);
-    }
-    ByteBuf composite = composite(bufs);
-    try {
-      return composite.toString(charset);
-    } finally {
-      composite.release();
+        try {
+            return composite.toString(charset);
+        } finally {
+            composite.release();
+        }
     }
-  }
 
-  static char[] byteBuf2Chars0(Charset charset, ByteBuf... bufs) {
-    if (bufs.length == 1) {
-      return decodeChars(bufs[0], charset);
+    public static String byteBuf2String(Charset charset, ByteBuf buf) throws CharacterCodingException {
+        return isUtf8OrUsAscii(charset) ? Utf8ByteBufCharsetDecoder.decodeUtf8(buf) : buf.toString(charset);
     }
-    ByteBuf composite = composite(bufs);
-    try {
-      return decodeChars(composite, charset);
-    } finally {
-      composite.release();
-    }
-  }
 
-  private static ByteBuf composite(ByteBuf[] bufs) {
-    for (ByteBuf buf : bufs) {
-      buf.retain();
+    public static String byteBuf2String(Charset charset, ByteBuf... bufs) throws CharacterCodingException {
+        return isUtf8OrUsAscii(charset) ? Utf8ByteBufCharsetDecoder.decodeUtf8(bufs) : byteBuf2StringDefault(charset, bufs);
     }
-    return Unpooled.wrappedBuffer(bufs);
-  }
 
-  private static void decode(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {
-    try {
-      CoderResult cr = decoder.decode(src, dst, true);
-      if (!cr.isUnderflow()) {
-        cr.throwException();
-      }
-      cr = decoder.flush(dst);
-      if (!cr.isUnderflow()) {
-        cr.throwException();
-      }
-    } catch (CharacterCodingException x) {
-      throw new IllegalStateException(x);
+    public static byte[] byteBuf2Bytes(ByteBuf buf) {
+        int readable = buf.readableBytes();
+        int readerIndex = buf.readerIndex();
+        if (buf.hasArray()) {
+            byte[] array = buf.array();
+            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        buf.getBytes(readerIndex, array);
+        return array;
     }
-  }
-
-  static char[] toCharArray(CharBuffer charBuffer) {
-    char[] chars = new char[charBuffer.remaining()];
-    charBuffer.get(chars);
-    return chars;
-  }
 }
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
index ab3fcfca0..ae0331fd2 100644
--- a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.netty.util;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
@@ -21,22 +22,17 @@
 import java.nio.charset.CoderResult;
 import java.nio.charset.CodingErrorAction;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.netty.util.ByteBufUtils.*;
-
 public class Utf8ByteBufCharsetDecoder {
 
   private static final int INITIAL_CHAR_BUFFER_SIZE = 1024;
   private static final int UTF_8_MAX_BYTES_PER_CHAR = 4;
   private static final char INVALID_CHAR_REPLACEMENT = '�';
 
-  private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = ThreadLocal.withInitial(Utf8ByteBufCharsetDecoder::new);
-  private final CharsetDecoder decoder = configureReplaceCodingErrorActions(UTF_8.newDecoder());
-  protected CharBuffer charBuffer = allocateCharBuffer(INITIAL_CHAR_BUFFER_SIZE);
-  private ByteBuffer splitCharBuffer = ByteBuffer.allocate(UTF_8_MAX_BYTES_PER_CHAR);
-  private int totalSize = 0;
-  private int totalNioBuffers = 0;
-  private boolean withoutArray = false;
+  private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = new ThreadLocal<Utf8ByteBufCharsetDecoder>() {
+    protected Utf8ByteBufCharsetDecoder initialValue() {
+      return new Utf8ByteBufCharsetDecoder();
+    }
+  };
 
   private static Utf8ByteBufCharsetDecoder pooledDecoder() {
     Utf8ByteBufCharsetDecoder decoder = POOL.get();
@@ -52,16 +48,35 @@ public static String decodeUtf8(ByteBuf... bufs) {
     return pooledDecoder().decode(bufs);
   }
 
-  public static char[] decodeUtf8Chars(ByteBuf buf) {
-    return pooledDecoder().decodeChars(buf);
+  private static CharsetDecoder configureReplaceCodingErrorActions(CharsetDecoder decoder) {
+    return decoder.onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
   }
 
-  public static char[] decodeUtf8Chars(ByteBuf... bufs) {
-    return pooledDecoder().decodeChars(bufs);
+  private final CharsetDecoder decoder = configureReplaceCodingErrorActions(UTF_8.newDecoder());
+  protected CharBuffer charBuffer = allocateCharBuffer(INITIAL_CHAR_BUFFER_SIZE);
+  private ByteBuffer splitCharBuffer = ByteBuffer.allocate(UTF_8_MAX_BYTES_PER_CHAR);
+
+  protected CharBuffer allocateCharBuffer(int l) {
+    return CharBuffer.allocate(l);
   }
 
-  private static CharsetDecoder configureReplaceCodingErrorActions(CharsetDecoder decoder) {
-    return decoder.onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
+  private void ensureCapacity(int l) {
+    if (charBuffer.position() == 0) {
+      if (charBuffer.capacity() < l) {
+        charBuffer = allocateCharBuffer(l);
+      }
+    } else if (charBuffer.remaining() < l) {
+      CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
+      charBuffer.flip();
+      newCharBuffer.put(charBuffer);
+      charBuffer = newCharBuffer;
+    }
+  }
+
+  public void reset() {
+    configureReplaceCodingErrorActions(decoder.reset());
+    charBuffer.clear();
+    splitCharBuffer.clear();
   }
 
   private static int moreThanOneByteCharSize(byte firstByte) {
@@ -89,32 +104,6 @@ private static boolean isContinuation(byte b) {
     return b >> 6 == -2;
   }
 
-  protected CharBuffer allocateCharBuffer(int l) {
-    return CharBuffer.allocate(l);
-  }
-
-  private void ensureCapacity(int l) {
-    if (charBuffer.position() == 0) {
-      if (charBuffer.capacity() < l) {
-        charBuffer = allocateCharBuffer(l);
-      }
-    } else if (charBuffer.remaining() < l) {
-      CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
-      charBuffer.flip();
-      newCharBuffer.put(charBuffer);
-      charBuffer = newCharBuffer;
-    }
-  }
-
-  public void reset() {
-    configureReplaceCodingErrorActions(decoder.reset());
-    charBuffer.clear();
-    splitCharBuffer.clear();
-    totalSize = 0;
-    totalNioBuffers = 0;
-    withoutArray = false;
-  }
-
   private boolean stashContinuationBytes(ByteBuffer nioBuffer, int missingBytes) {
     for (int i = 0; i < missingBytes; i++) {
       byte b = nioBuffer.get();
@@ -176,14 +165,14 @@ protected void decodePartial(ByteBuffer nioBuffer, boolean endOfInput) {
     }
   }
 
-  private void decode(ByteBuffer[] nioBuffers) {
+  private void decode(ByteBuffer[] nioBuffers, int length) {
     int count = nioBuffers.length;
     for (int i = 0; i < count; i++) {
       decodePartial(nioBuffers[i].duplicate(), i == count - 1);
     }
   }
 
-  private void decodeSingleNioBuffer(ByteBuffer nioBuffer) {
+  private void decodeSingleNioBuffer(ByteBuffer nioBuffer, int length) {
     decoder.decode(nioBuffer, charBuffer, true);
   }
 
@@ -191,72 +180,27 @@ public String decode(ByteBuf buf) {
     if (buf.isDirect()) {
       return buf.toString(UTF_8);
     }
-    decodeHead0(buf);
-    return charBuffer.toString();
-  }
-
-  public char[] decodeChars(ByteBuf buf) {
-    if (buf.isDirect()) {
-      return buf.toString(UTF_8).toCharArray();
-    }
-    decodeHead0(buf);
-    return toCharArray(charBuffer);
-  }
-
-  public String decode(ByteBuf... bufs) {
-    if (bufs.length == 1) {
-      return decode(bufs[0]);
-    }
-
-    inspectByteBufs(bufs);
-    if (withoutArray) {
-      return ByteBufUtils.byteBuf2String0(UTF_8, bufs);
-    } else {
-      decodeHeap0(bufs);
-      return charBuffer.toString();
-    }
-  }
-
-  public char[] decodeChars(ByteBuf... bufs) {
-    if (bufs.length == 1) {
-      return decodeChars(bufs[0]);
-    }
-
-    inspectByteBufs(bufs);
-    if (withoutArray) {
-      return ByteBufUtils.byteBuf2Chars0(UTF_8, bufs);
-    } else {
-      decodeHeap0(bufs);
-      return toCharArray(charBuffer);
-    }
-  }
 
-  private void decodeHead0(ByteBuf buf) {
     int length = buf.readableBytes();
     ensureCapacity(length);
 
     if (buf.nioBufferCount() == 1) {
-      decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate());
+      decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate(), length);
     } else {
-      decode(buf.nioBuffers());
+      decode(buf.nioBuffers(), buf.readableBytes());
     }
-    charBuffer.flip();
+
+    return charBuffer.flip().toString();
   }
 
-  private void decodeHeap0(ByteBuf[] bufs) {
-    ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
-    int i = 0;
-    for (ByteBuf buf : bufs) {
-      for (ByteBuffer nioBuffer : buf.nioBuffers()) {
-        nioBuffers[i++] = nioBuffer;
-      }
+  public String decode(ByteBuf... bufs) {
+    if (bufs.length == 1) {
+      return decode(bufs[0]);
     }
-    ensureCapacity(totalSize);
-    decode(nioBuffers);
-    charBuffer.flip();
-  }
 
-  private void inspectByteBufs(ByteBuf[] bufs) {
+    int totalSize = 0;
+    int totalNioBuffers = 0;
+    boolean withoutArray = false;
     for (ByteBuf buf : bufs) {
       if (!buf.hasArray()) {
         withoutArray = true;
@@ -265,5 +209,23 @@ private void inspectByteBufs(ByteBuf[] bufs) {
       totalSize += buf.readableBytes();
       totalNioBuffers += buf.nioBufferCount();
     }
+
+    if (withoutArray) {
+      return ByteBufUtils.byteBuf2StringDefault(UTF_8, bufs);
+
+    } else {
+      ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
+      int i = 0;
+      for (ByteBuf buf : bufs) {
+        for (ByteBuffer nioBuffer : buf.nioBuffers()) {
+          nioBuffers[i++] = nioBuffer;
+        }
+      }
+
+      ensureCapacity(totalSize);
+      decode(nioBuffers, totalSize);
+
+      return charBuffer.flip().toString();
+    }
   }
 }
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
index cc326364b..7f7d6ac60 100644
--- a/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoderTest.java
@@ -13,85 +13,86 @@
  */
 package org.asynchttpclient.netty.util;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import org.testng.annotations.Test;
+import static java.nio.charset.StandardCharsets.*;
+import static org.testng.Assert.*;
 
 import java.util.Arrays;
 
-import static java.nio.charset.StandardCharsets.*;
-import static org.testng.Assert.*;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import org.testng.annotations.Test;
 
 public class Utf8ByteBufCharsetDecoderTest {
 
-  @Test
-  public void testByteBuf2BytesHasBackingArray() {
-    byte[] inputBytes = "testdata".getBytes(US_ASCII);
-    ByteBuf buf = Unpooled.wrappedBuffer(inputBytes);
-    try {
-      byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
-      assertEquals(output, inputBytes);
-    } finally {
-      buf.release();
+    @Test
+    public void testByteBuf2BytesHasBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf buf = Unpooled.wrappedBuffer(inputBytes);
+        try {
+            byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
+            assertEquals(output, inputBytes);
+        } finally {
+            buf.release();
+        }
     }
-  }
 
-  @Test
-  public void testByteBuf2BytesNoBackingArray() {
-    byte[] inputBytes = "testdata".getBytes(US_ASCII);
-    ByteBuf buf = Unpooled.directBuffer();
-    try {
-      buf.writeBytes(inputBytes);
-      byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
-      assertEquals(output, inputBytes);
-    } finally {
-      buf.release();
+    @Test
+    public void testByteBuf2BytesNoBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf buf = Unpooled.directBuffer();
+        try {
+            buf.writeBytes(inputBytes);
+            byte[] output = ByteBufUtils.byteBuf2Bytes(buf);
+            assertEquals(output, inputBytes);
+        } finally {
+            buf.release();
+        }
     }
-  }
 
-  @Test
-  public void byteBufs2StringShouldBeAbleToDealWithCharsWithVariableBytesLength() throws Exception {
-    String inputString = "°ä–";
-    byte[] inputBytes = inputString.getBytes(UTF_8);
+    @Test
+    public void byteBufs2StringShouldBeAbleToDealWithCharsWithVariableBytesLength() throws Exception {
+        String inputString = "°ä–";
+        byte[] inputBytes = inputString.getBytes(UTF_8);
 
-    for (int i = 1; i < inputBytes.length - 1; i++) {
-      ByteBuf buf1 = Unpooled.wrappedBuffer(inputBytes, 0, i);
-      ByteBuf buf2 = Unpooled.wrappedBuffer(inputBytes, i, inputBytes.length - i);
-      try {
-        String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
-        assertEquals(s, inputString);
-      } finally {
-        buf1.release();
-        buf2.release();
-      }
+        for (int i = 1; i < inputBytes.length - 1; i++) {
+            ByteBuf buf1 = Unpooled.wrappedBuffer(inputBytes, 0, i);
+            ByteBuf buf2 = Unpooled.wrappedBuffer(inputBytes, i, inputBytes.length - i);
+            try {
+                String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
+                assertEquals(s, inputString);
+            } finally {
+                buf1.release();
+                buf2.release();
+            }
+        }
     }
-  }
 
-  @Test
-  public void byteBufs2StringShouldBeAbleToDealWithBrokenCharsTheSameWayAsJavaImpl() throws Exception {
-    String inputString = "foo 加特林岩石 bar";
-    byte[] inputBytes = inputString.getBytes(UTF_8);
+    @Test
+    public void byteBufs2StringShouldBeAbleToDealWithBrokenCharsTheSameWayAsJavaImpl() throws Exception {
+        String inputString = "foo 加特林岩石 bar";
+        byte[] inputBytes = inputString.getBytes(UTF_8);
 
-    int droppedBytes = 1;
+        int droppedBytes = 1;
 
-    for (int i = 1; i < inputBytes.length - 1 - droppedBytes; i++) {
-      byte[] part1 = Arrays.copyOfRange(inputBytes, 0, i);
-      byte[] part2 = Arrays.copyOfRange(inputBytes, i + droppedBytes, inputBytes.length);
-      byte[] merged = new byte[part1.length + part2.length];
-      System.arraycopy(part1, 0, merged, 0, part1.length);
-      System.arraycopy(part2, 0, merged, part1.length, part2.length);
+        for (int i = 1; i < inputBytes.length - 1 - droppedBytes; i++) {
+            byte[] part1 = Arrays.copyOfRange(inputBytes, 0, i);
+            byte[] part2 = Arrays.copyOfRange(inputBytes, i + droppedBytes, inputBytes.length);
+            byte[] merged = new byte[part1.length + part2.length];
+            System.arraycopy(part1, 0, merged, 0, part1.length);
+            System.arraycopy(part2, 0, merged, part1.length, part2.length);
 
-      ByteBuf buf1 = Unpooled.wrappedBuffer(part1);
-      ByteBuf buf2 = Unpooled.wrappedBuffer(part2);
-      try {
-        String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
-        String javaString = new String(merged, UTF_8);
-        assertNotEquals(s, inputString);
-        assertEquals(s, javaString);
-      } finally {
-        buf1.release();
-        buf2.release();
-      }
+            ByteBuf buf1 = Unpooled.wrappedBuffer(part1);
+            ByteBuf buf2 = Unpooled.wrappedBuffer(part2);
+            try {
+                String s = ByteBufUtils.byteBuf2String(UTF_8, buf1, buf2);
+                String javaString = new String(merged, UTF_8);
+                assertNotEquals(s, inputString);
+                assertEquals(s, javaString);
+            } finally {
+                buf1.release();
+                buf2.release();
+            }
+        }
     }
-  }
 }
diff --git a/pom.xml b/pom.xml
index 89b04807a..aa8fbb416 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,410 +1,401 @@
-<?xml version="1.0" encoding="UTF-8"?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>org.asynchttpclient</groupId>
-  <artifactId>async-http-client-project</artifactId>
-  <name>Asynchronous Http Client Project</name>
-  <version>2.2.1-SNAPSHOT</version>
-  <packaging>pom</packaging>
-  <description>
-    The Async Http Client (AHC) library's purpose is to allow Java
-    applications to easily execute HTTP requests and
-    asynchronously process the response.
-  </description>
-  <url>http://github.com/AsyncHttpClient/async-http-client</url>
-  <scm>
-    <url>https://github.com/AsyncHttpClient/async-http-client</url>
-    <connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</connection>
-    <developerConnection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</developerConnection>
-  </scm>
-  <issueManagement>
-    <system>jira</system>
-    <url>https://issues.sonatype.org/browse/AHC</url>
-  </issueManagement>
-  <mailingLists>
-    <mailingList>
-      <name>asynchttpclient</name>
-      <archive>http://groups.google.com/group/asynchttpclient/topics</archive>
-      <subscribe>http://groups.google.com/group/asynchttpclient/subscribe</subscribe>
-      <unsubscribe>http://groups.google.com/group/asynchttpclient/subscribe</unsubscribe>
-      <post>asynchttpclient@googlegroups.com</post>
-    </mailingList>
-  </mailingLists>
+	<parent>
+		<groupId>org.sonatype.oss</groupId>
+		<artifactId>oss-parent</artifactId>
+		<version>9</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<groupId>org.asynchttpclient</groupId>
+	<artifactId>async-http-client-project</artifactId>
+	<name>Asynchronous Http Client Project</name>
+	<version>2.1.0-SNAPSHOT</version>
+	<packaging>pom</packaging>
+	<description>
+        The Async Http Client (AHC) library's purpose is to allow Java
+        applications to easily execute HTTP requests and
+        asynchronously process the response.
+    </description>
+	<url>http://github.com/AsyncHttpClient/async-http-client</url>
+	<scm>
+		<url>https://github.com/AsyncHttpClient/async-http-client</url>
+		<connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</connection>
+		<developerConnection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</developerConnection>
+	</scm>
+	<issueManagement>
+		<system>jira</system>
+		<url>https://issues.sonatype.org/browse/AHC</url>
+	</issueManagement>
+	<mailingLists>
+		<mailingList>
+			<name>asynchttpclient</name>
+			<archive>http://groups.google.com/group/asynchttpclient/topics</archive>
+			<subscribe>http://groups.google.com/group/asynchttpclient/subscribe</subscribe>
+			<unsubscribe>http://groups.google.com/group/asynchttpclient/subscribe</unsubscribe>
+			<post>asynchttpclient@googlegroups.com</post>
+		</mailingList>
+	</mailingLists>
 
-  <prerequisites>
-    <maven>3.0.0</maven>
-  </prerequisites>
-  <developers>
-    <developer>
-      <id>slandelle</id>
-      <name>Stephane Landelle</name>
-      <email>slandelle@gatling.io</email>
-    </developer>
-  </developers>
-  <licenses>
-    <license>
-      <name>Apache License 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <build>
-    <resources>
-      <resource>
-        <filtering>true</filtering>
-        <directory>src/main/resources/</directory>
-      </resource>
-    </resources>
-    <extensions>
-      <!-- Enabling the use of SSH -->
-      <extension>
-        <groupId>org.apache.maven.wagon</groupId>
-        <artifactId>wagon-ssh-external</artifactId>
-        <version>1.0-beta-6</version>
-      </extension>
-      <extension>
-        <groupId>org.apache.maven.scm</groupId>
-        <artifactId>maven-scm-provider-gitexe</artifactId>
-        <version>1.6</version>
-      </extension>
-      <extension>
-        <groupId>org.apache.maven.scm</groupId>
-        <artifactId>maven-scm-manager-plexus</artifactId>
-        <version>1.6</version>
-      </extension>
-    </extensions>
-    <defaultGoal>install</defaultGoal>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.6.1</version>
-        <configuration>
-          <source>${source.property}</source>
-          <target>${target.property}</target>
-          <maxmem>1024m</maxmem>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-surefire-plugin</artifactId>
-        <version>2.19.1</version>
-        <configuration>
-          <redirectTestOutputToFile>${surefire.redirectTestOutputToFile}</redirectTestOutputToFile>
-          <systemPropertyVariables>
-            <org.asynchttpclient.shutdownQuietPeriod>10</org.asynchttpclient.shutdownQuietPeriod>
-            <org.asynchttpclient.shutdownTimeout>100</org.asynchttpclient.shutdownTimeout>
-            <sun.net.spi.nameservice.nameservers>8.8.8.8</sun.net.spi.nameservice.nameservers>
-            <sun.net.spi.nameservice.provider.1>dns,sun</sun.net.spi.nameservice.provider.1>
-          </systemPropertyVariables>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-enforcer-plugin</artifactId>
-        <version>1.4.1</version>
-        <executions>
-          <execution>
-            <id>enforce-versions</id>
-            <goals>
-              <goal>enforce</goal>
-            </goals>
-            <configuration>
-              <rules>
-                <requireJavaVersion>
-                  <version>${source.property}</version>
-                </requireJavaVersion>
-              </rules>
-            </configuration>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <artifactId>maven-resources-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <encoding>UTF-8</encoding>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-release-plugin</artifactId>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-      </plugin>
-      <plugin>
-        <artifactId>maven-source-plugin</artifactId>
-        <version>3.0.1</version>
-        <executions>
-          <execution>
-            <id>attach-sources</id>
-            <phase>verify</phase>
-            <goals>
-              <goal>jar-no-fork</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-  </build>
-  <profiles>
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>test-output</id>
-      <properties>
-        <surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
-      </properties>
-    </profile>
-  </profiles>
-  <distributionManagement>
-    <repository>
-      <id>sonatype-nexus-staging</id>
-      <name>Sonatype Release</name>
-      <url>http://oss.sonatype.org/service/local/staging/deploy/maven2
-      </url>
-    </repository>
-    <snapshotRepository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>sonatype-nexus-snapshots</name>
-      <url>${distMgmtSnapshotsUrl}</url>
-    </snapshotRepository>
-  </distributionManagement>
-  <modules>
-    <module>netty-utils</module>
-    <module>client</module>
-    <module>extras</module>
-    <module>example</module>
-  </modules>
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-buffer</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-codec-http</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-codec</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-codec-socks</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-handler-proxy</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-common</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-transport</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-handler</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-resolver-dns</artifactId>
-        <version>${netty.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.netty</groupId>
-        <artifactId>netty-transport-native-epoll</artifactId>
-        <classifier>linux-x86_64</classifier>
-        <version>${netty.version}</version>
-        <optional>true</optional>
-      </dependency>
-      <dependency>
-        <groupId>org.reactivestreams</groupId>
-        <artifactId>reactive-streams</artifactId>
-        <version>${reactive-streams.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.typesafe.netty</groupId>
-        <artifactId>netty-reactive-streams</artifactId>
-        <version>${netty-reactive-streams.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex.rxjava2</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava2.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-  <dependencies>
-    <dependency>
-      <groupId>org.slf4j</groupId>
-      <artifactId>slf4j-api</artifactId>
-      <version>${slf4j.version}</version>
-    </dependency>
-    <!-- Test dependencies -->
-    <dependency>
-      <groupId>ch.qos.logback</groupId>
-      <artifactId>logback-classic</artifactId>
-      <version>${logback.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.testng</groupId>
-      <artifactId>testng</artifactId>
-      <version>${testng.version}</version>
-      <scope>test</scope>
-      <exclusions>
-        <exclusion>
-          <groupId>org.beanshell</groupId>
-          <artifactId>bsh</artifactId>
-        </exclusion>
-      </exclusions>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty</groupId>
-      <artifactId>jetty-servlet</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty</groupId>
-      <artifactId>jetty-servlets</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty</groupId>
-      <artifactId>jetty-security</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty</groupId>
-      <artifactId>jetty-proxy</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty.websocket</groupId>
-      <artifactId>websocket-server</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty.websocket</groupId>
-      <artifactId>websocket-servlet</artifactId>
-      <version>${jetty.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.tomcat.embed</groupId>
-      <artifactId>tomcat-embed-core</artifactId>
-      <version>${tomcat.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>commons-io</groupId>
-      <artifactId>commons-io</artifactId>
-      <version>${commons-io.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>commons-fileupload</groupId>
-      <artifactId>commons-fileupload</artifactId>
-      <version>${commons-fileupload.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.e-movimento.tinytools</groupId>
-      <artifactId>privilegedaccessor</artifactId>
-      <version>${privilegedaccessor.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.powermock</groupId>
-      <artifactId>powermock-module-testng</artifactId>
-      <version>${powermock.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.powermock</groupId>
-      <artifactId>powermock-api-mockito</artifactId>
-      <version>${powermock.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <properties>
-    <distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
-    <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
-    <source.property>1.8</source.property>
-    <target.property>1.8</target.property>
-    <netty.version>4.1.20.Final</netty.version>
-    <slf4j.version>1.7.25</slf4j.version>
-    <reactive-streams.version>1.0.2</reactive-streams.version>
-    <netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
-    <rxjava.version>1.3.4</rxjava.version>
-    <rxjava2.version>2.1.8</rxjava2.version>
-    <logback.version>1.2.3</logback.version>
-    <testng.version>6.13.1</testng.version>
-    <jetty.version>9.4.8.v20171121</jetty.version>
-    <tomcat.version>9.0.2</tomcat.version>
-    <commons-io.version>2.6</commons-io.version>
-    <commons-fileupload.version>1.3.3</commons-fileupload.version>
-    <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-    <powermock.version>1.6.6</powermock.version>
-  </properties>
+	<prerequisites>
+		<maven>3.0.0</maven>
+	</prerequisites>
+	<developers>
+		<developer>
+			<id>slandelle</id>
+			<name>Stephane Landelle</name>
+			<email>slandelle@gatling.io</email>
+		</developer>
+	</developers>
+	<licenses>
+		<license>
+			<name>Apache License 2.0</name>
+			<url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
+			<distribution>repo</distribution>
+		</license>
+	</licenses>
+	<build>
+		<resources>
+			<resource>
+				<filtering>true</filtering>
+				<directory>src/main/resources/</directory>
+			</resource>
+		</resources>
+		<extensions>
+			<!-- Enabling the use of SSH -->
+
+			<extension>
+				<groupId>org.apache.maven.wagon</groupId>
+				<artifactId>wagon-ssh-external</artifactId>
+				<version>1.0-beta-6</version>
+			</extension>
+			<extension>
+				<groupId>org.apache.maven.scm</groupId>
+				<artifactId>maven-scm-provider-gitexe</artifactId>
+				<version>1.6</version>
+			</extension>
+			<extension>
+				<groupId>org.apache.maven.scm</groupId>
+				<artifactId>maven-scm-manager-plexus</artifactId>
+				<version>1.6</version>
+			</extension>
+		</extensions>
+		<defaultGoal>install</defaultGoal>
+		<plugins>
+			<plugin>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<version>3.6.1</version>
+				<configuration>
+					<source>${source.property}</source>
+					<target>${target.property}</target>
+					<maxmem>1024m</maxmem>
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-surefire-plugin</artifactId>
+				<version>2.19.1</version>
+				<configuration>
+					<redirectTestOutputToFile>${surefire.redirectTestOutputToFile}</redirectTestOutputToFile>
+					<systemPropertyVariables>
+						<org.asynchttpclient.shutdownQuietPeriod>10</org.asynchttpclient.shutdownQuietPeriod>
+						<org.asynchttpclient.shutdownTimeout>100</org.asynchttpclient.shutdownTimeout>
+						<sun.net.spi.nameservice.nameservers>8.8.8.8</sun.net.spi.nameservice.nameservers>
+						<sun.net.spi.nameservice.provider.1>dns,sun</sun.net.spi.nameservice.provider.1>
+					</systemPropertyVariables>
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-enforcer-plugin</artifactId>
+				<version>1.4.1</version>
+				<executions>
+					<execution>
+						<id>enforce-versions</id>
+						<goals>
+							<goal>enforce</goal>
+						</goals>
+						<configuration>
+							<rules>
+								<requireJavaVersion>
+									<version>${source.property}</version>
+								</requireJavaVersion>
+							</rules>
+						</configuration>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<artifactId>maven-resources-plugin</artifactId>
+				<version>3.0.2</version>
+				<configuration>
+					<encoding>UTF-8</encoding>
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-release-plugin</artifactId>
+				<configuration>
+					<autoVersionSubmodules>true</autoVersionSubmodules>
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-jar-plugin</artifactId>
+				<version>3.0.2</version>
+			</plugin>
+			<plugin>
+				<artifactId>maven-source-plugin</artifactId>
+				<version>3.0.1</version>
+				<executions>
+					<execution>
+						<id>attach-sources</id>
+						<phase>verify</phase>
+						<goals>
+							<goal>jar-no-fork</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+		<pluginManagement>
+			<plugins>
+				<plugin>
+					<artifactId>maven-javadoc-plugin</artifactId>
+					<version>2.10.4</version>
+				</plugin>
+			</plugins>
+		</pluginManagement>
+	</build>
+	<profiles>
+		<profile>
+			<id>release-sign-artifacts</id>
+			<activation>
+				<property>
+					<name>performRelease</name>
+					<value>true</value>
+				</property>
+			</activation>
+			<build>
+				<plugins>
+					<plugin>
+						<artifactId>maven-gpg-plugin</artifactId>
+						<executions>
+							<execution>
+								<id>sign-artifacts</id>
+								<phase>verify</phase>
+								<goals>
+									<goal>sign</goal>
+								</goals>
+							</execution>
+						</executions>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+		<profile>
+			<id>test-output</id>
+			<properties>
+				<surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
+			</properties>
+		</profile>
+	</profiles>
+	<distributionManagement>
+		<repository>
+			<id>sonatype-nexus-staging</id>
+			<name>Sonatype Release</name>
+			<url>http://oss.sonatype.org/service/local/staging/deploy/maven2
+            </url>
+		</repository>
+		<snapshotRepository>
+			<id>sonatype-nexus-snapshots</id>
+			<name>sonatype-nexus-snapshots</name>
+			<url>${distMgmtSnapshotsUrl}</url>
+		</snapshotRepository>
+	</distributionManagement>
+	<modules>
+		<module>netty-utils</module>
+		<module>client</module>
+		<module>extras</module>
+		<module>example</module>
+	</modules>
+	<dependencyManagement>
+		<dependencies>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-buffer</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-codec-http</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-codec</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-common</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-transport</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-handler</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-resolver-dns</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-transport-native-epoll</artifactId>
+				<classifier>linux-x86_64</classifier>
+				<version>${netty.version}</version>
+				<optional>true</optional>
+			</dependency>
+			<dependency>
+				<groupId>org.reactivestreams</groupId>
+				<artifactId>reactive-streams</artifactId>
+				<version>${reactive-streams.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>com.typesafe.netty</groupId>
+				<artifactId>netty-reactive-streams</artifactId>
+				<version>${netty-reactive-streams.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.reactivex</groupId>
+				<artifactId>rxjava</artifactId>
+				<version>${rxjava.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.reactivex.rxjava2</groupId>
+				<artifactId>rxjava</artifactId>
+				<version>${rxjava2.version}</version>
+			</dependency>
+		</dependencies>
+	</dependencyManagement>
+	<dependencies>
+		<dependency>
+			<groupId>org.slf4j</groupId>
+			<artifactId>slf4j-api</artifactId>
+			<version>${slf4j.version}</version>
+		</dependency>
+		<!-- Test dependencies -->
+		<dependency>
+			<groupId>ch.qos.logback</groupId>
+			<artifactId>logback-classic</artifactId>
+			<version>${logback.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.testng</groupId>
+			<artifactId>testng</artifactId>
+			<version>${testng.version}</version>
+			<scope>test</scope>
+			<exclusions>
+				<exclusion>
+					<groupId>org.beanshell</groupId>
+					<artifactId>bsh</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-servlet</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-servlets</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-security</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-proxy</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty.websocket</groupId>
+			<artifactId>websocket-server</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty.websocket</groupId>
+			<artifactId>websocket-servlet</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.tomcat.embed</groupId>
+			<artifactId>tomcat-embed-core</artifactId>
+			<version>${tomcat.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>commons-io</groupId>
+			<artifactId>commons-io</artifactId>
+			<version>${commons-io.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>commons-fileupload</groupId>
+			<artifactId>commons-fileupload</artifactId>
+			<version>${commons-fileupload.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.e-movimento.tinytools</groupId>
+			<artifactId>privilegedaccessor</artifactId>
+			<version>${privilegedaccessor.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.powermock</groupId>
+			<artifactId>powermock-module-testng</artifactId>
+			<version>${powermock.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.powermock</groupId>
+			<artifactId>powermock-api-mockito</artifactId>
+			<version>${powermock.version}</version>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<properties>
+		<distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
+		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
+		<source.property>1.8</source.property>
+		<target.property>1.8</target.property>
+		<netty.version>4.1.15.Final</netty.version>
+		<slf4j.version>1.7.25</slf4j.version>
+		<reactive-streams.version>1.0.0</reactive-streams.version>
+		<netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
+		<rxjava.version>1.3.0</rxjava.version>
+		<rxjava2.version>2.1.3</rxjava2.version>
+		<logback.version>1.2.3</logback.version>
+		<testng.version>6.11</testng.version>
+		<jetty.version>9.4.6.v20170531</jetty.version>
+		<tomcat.version>8.5.20</tomcat.version>
+		<commons-io.version>2.5</commons-io.version>
+		<commons-fileupload.version>1.3.3</commons-fileupload.version>
+		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
+		<powermock.version>1.6.6</powermock.version>
+	</properties>
 </project>
+
