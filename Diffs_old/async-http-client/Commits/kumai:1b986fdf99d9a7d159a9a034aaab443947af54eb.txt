diff --git a/src/main/java/com/ning/http/client/ProxyServer.java b/src/main/java/com/ning/http/client/ProxyServer.java
index 5a3023805..784ba97e4 100644
--- a/src/main/java/com/ning/http/client/ProxyServer.java
+++ b/src/main/java/com/ning/http/client/ProxyServer.java
@@ -102,7 +102,7 @@ public String getPassword() {
         return password;
     }
 
-    public URI getUri() {
+    public URI getURI() {
         return uri;
     }
 
diff --git a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
index 2df221a16..f75de1c9d 100644
--- a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -2283,7 +2283,7 @@ void doAsyncTrackedConnection(final Request request,
                                       final GrizzlyResponseFuture requestFuture,
                                       final CompletionHandler<Connection> connectHandler)
         throws IOException, ExecutionException, InterruptedException {
-            Connection c = pool.poll(getPoolKey(request));
+            Connection c = pool.poll(getPoolKey(request, requestFuture.getProxy()));
             if (c == null) {
                 if (!connectionMonitor.acquire()) {
                     throw new IOException("Max connections exceeded");
@@ -2331,8 +2331,8 @@ private Connection obtainConnection0(final Request request,
 
             final URI uri = request.getURI();
             final ProxyServer proxy = requestFuture.getProxy();
-            String host = ((proxy != null) ? proxy.getHost() : uri.getHost());
-            int port = ((proxy != null) ? proxy.getPort() : uri.getPort());
+            String host = (proxy != null) ? proxy.getHost() : uri.getHost();
+            int port = (proxy != null) ? proxy.getPort() : uri.getPort();
             int cTimeout = provider.clientConfig.getConnectionTimeoutInMs();
             FutureImpl<Connection> future = Futures.createSafeFuture();
             CompletionHandler<Connection> ch = Futures.toCompletionHandler(future,
@@ -2348,26 +2348,16 @@ private Connection obtainConnection0(final Request request,
             }
         }
 
-        private ProxyServer getProxyServer(Request request) {
-
-            ProxyServer proxyServer = request.getProxyServer();
-            if (proxyServer == null) {
-                proxyServer = provider.clientConfig.getProxyServer();
-            }
-            return proxyServer;
-
-        }
-
         boolean returnConnection(final Request request, final Connection c) {
+            ProxyServer proxyServer = ProxyUtils.getProxyServer(provider.clientConfig, request);
             final boolean result = (DO_NOT_CACHE.get(c) == null
-                                       && pool.offer(getPoolKey(request), c));
+                                       && pool.offer(getPoolKey(request, proxyServer), c));
             if (result) {
                 if (provider.resolver != null) {
                     provider.resolver.setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
                 }
             }
             return result;
-
         }
 
 
@@ -2421,9 +2411,9 @@ public void updated(Connection result) {
             };
         }
 
-        private static String getPoolKey(final Request request) {
-            final ConnectionPoolKeyStrategy keyStrategy = request.getConnectionPoolKeyStrategy();
-            return keyStrategy.getKey(request.getURI());
+        private static String getPoolKey(Request request, ProxyServer proxyServer) {
+            URI uri = proxyServer != null? proxyServer.getURI(): request.getURI();
+            return request.getConnectionPoolKeyStrategy().getKey(uri);
         }
 
         // ------------------------------------------------------ Nested Classes
diff --git a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
index c413d13bd..3cb78f465 100644
--- a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
@@ -163,11 +163,10 @@ private void configure(JDKAsyncHttpProviderConfig config) {
     }
 
     private HttpURLConnection createUrlConnection(Request request) throws IOException {
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
         Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
         Proxy proxy = null;
-        if (!avoidProxy && proxyServer != null || realm != null) {
+        if (proxyServer != null || realm != null) {
             try {
                 proxy = configureProxyAndAuth(proxyServer, realm);
             } catch (AuthenticationException e) {
@@ -177,10 +176,9 @@ private HttpURLConnection createUrlConnection(Request request) throws IOExceptio
 
         HttpURLConnection urlConnection = null;
         if (proxy == null) {
-            urlConnection =
-                    (HttpURLConnection) AsyncHttpProviderUtils.createUri(request.getUrl()).toURL().openConnection(Proxy.NO_PROXY);
+            urlConnection = (HttpURLConnection) request.getURI().toURL().openConnection(Proxy.NO_PROXY);
         } else {
-            urlConnection = (HttpURLConnection) AsyncHttpProviderUtils.createUri(request.getUrl()).toURL().openConnection(proxy);
+            urlConnection = (HttpURLConnection) proxyServer.getURI().toURL().openConnection(proxy);
         }
 
         if (request.getUrl().startsWith("https")) {
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index 25cae1f62..5f3b16e5d 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -201,25 +201,25 @@ public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
             socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
             this.allowReleaseSocketChannelFactory = true;
         } else {
-        	// check if external NioClientSocketChannelFactory is defined
+            // check if external NioClientSocketChannelFactory is defined
             Object oo = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.SOCKET_CHANNEL_FACTORY);
             if (oo != null && NioClientSocketChannelFactory.class.isAssignableFrom(oo.getClass())) {
-            	this.socketChannelFactory = NioClientSocketChannelFactory.class.cast(oo);
+                this.socketChannelFactory = NioClientSocketChannelFactory.class.cast(oo);
 
-            	// cannot allow releasing shared channel factory
-            	this.allowReleaseSocketChannelFactory = false;
+                // cannot allow releasing shared channel factory
+                this.allowReleaseSocketChannelFactory = false;
             } else {
-            	ExecutorService e;
-            	Object o = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE);
-            	if (o != null && ExecutorService.class.isAssignableFrom(o.getClass())) {
-            		e = ExecutorService.class.cast(o);
-            	} else {
-            		e = Executors.newCachedThreadPool();
-            	}
-            	int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
-            	log.debug("Number of application's worker threads is {}", numWorkers);
-            	socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
-            	this.allowReleaseSocketChannelFactory = true;
+                ExecutorService e;
+                Object o = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE);
+                if (o != null && ExecutorService.class.isAssignableFrom(o.getClass())) {
+                    e = ExecutorService.class.cast(o);
+                } else {
+                    e = Executors.newCachedThreadPool();
+                }
+                int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
+                log.debug("Number of application's worker threads is {}", numWorkers);
+                socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
+                this.allowReleaseSocketChannelFactory = true;
             }
         }
         plainBootstrap = new ClientBootstrap(socketChannelFactory);
@@ -629,7 +629,7 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
             nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
         } else {
             String path = null;
-            if (proxyServer != null && !isSecure(uri) && !config.isUseRelativeURIsWithSSLProxies())
+            if (proxyServer != null && !(isSecure(uri) && config.isUseRelativeURIsWithSSLProxies()))
                 path = uri.toString();
             else if (uri.getRawQuery() != null)
                 path = uri.getRawPath() + "?" + uri.getRawQuery();
@@ -901,11 +901,11 @@ public void close() {
             config.executorService().shutdown();
             config.reaper().shutdown();
             if (this.allowReleaseSocketChannelFactory) {
-            	socketChannelFactory.releaseExternalResources();
-            	plainBootstrap.releaseExternalResources();
-            	secureBootstrap.releaseExternalResources();
-            	webSocketBootstrap.releaseExternalResources();
-            	secureWebSocketBootstrap.releaseExternalResources();
+                socketChannelFactory.releaseExternalResources();
+                plainBootstrap.releaseExternalResources();
+                secureBootstrap.releaseExternalResources();
+                webSocketBootstrap.releaseExternalResources();
+                secureWebSocketBootstrap.releaseExternalResources();
             }
         } catch (Throwable t) {
             log.warn("Unexpected error on close", t);
@@ -956,7 +956,8 @@ public Response prepareResponse(final HttpResponseStatus status,
             if (f != null && f.reuseChannel() && f.channel() != null) {
                 channel = f.channel();
             } else {
-                channel = lookupInCache(uri, request.getConnectionPoolKeyStrategy());
+                URI connectionKeyUri = useProxy? proxyServer.getURI() : uri;
+                channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
             }
         }
 
@@ -1306,18 +1307,24 @@ private Realm ntlmProxyChallenge(List<String> wwwAuth,
         } else {
             realmBuilder = new Realm.RealmBuilder();
         }
-        newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
+        newRealm = realmBuilder
                 .setUri(request.getURI().getPath())
                 .setMethodName(request.getMethod())
                 .build();
 
         return newRealm;
     }
+    
+    private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
+        URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
+        return future.getConnectionPoolKeyStrategy().getKey(uri);
+    }
 
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final boolean keepAlive, final URI uri) {
+    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
         ctx.setAttachment(new AsyncCallable(future) {
             public Object call() throws Exception {
-                if (keepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(future.getConnectionPoolKeyStrategy().getKey(uri), ctx.getChannel())) {
+                
+                if (future.getKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
                     return null;
                 }
 
@@ -1353,7 +1360,7 @@ private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc
         future.touch();
 
         log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+        drainChannel(ctx, future);
         nextRequest(newRequest, future);
         return;
     }
@@ -1510,10 +1517,9 @@ private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandle
 
     private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
         if (lastValidChunk && future.getKeepAlive()) {
-            drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+            drainChannel(ctx, future);
         } else {
-            if (future.getKeepAlive() && ctx.getChannel().isReadable() &&
-                    connectionsPool.offer(future.getConnectionPoolKeyStrategy().getKey(future.getURI()), ctx.getChannel())) {
+            if (future.getKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
                 markAsDone(future, ctx);
                 return;
             }
@@ -2066,8 +2072,8 @@ private boolean redirect(Request request,
                             && config.isStrict302Handling())) {
                         nBuilder.setMethod("GET");
                     }
-                    final URI initialConnectionUri = future.getURI();
                     final boolean initialConnectionKeepAlive = future.getKeepAlive();
+                    final String initialPoolKey = getPoolKey(future);
                     future.setURI(uri);
                     String newUrl = uri.toString();
                     if (request.getUrl().startsWith(WEBSOCKET)) {
@@ -2085,11 +2091,9 @@ private boolean redirect(Request request,
                         nBuilder.addOrReplaceCookie(c);
                     }
 
-                    final String connectionPoolKey = future.getConnectionPoolKeyStrategy().getKey(initialConnectionUri);
                     AsyncCallable ac = new AsyncCallable(future) {
                         public Object call() throws Exception {
-                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() &&
-                                    connectionsPool.offer(connectionPoolKey, ctx.getChannel())) {
+                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(initialPoolKey, ctx.getChannel())) {
                                 return null;
                             }
                             finishChannel(ctx);
@@ -2186,7 +2190,7 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                     //}
 
                     if (statusCode == 401
-                    		&& realm != null
+                            && realm != null
                             && wwwAuth.size() > 0
                             && !future.getAndSetAuth(true)) {
 
@@ -2220,7 +2224,7 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                         log.debug("Sending authentication to {}", request.getUrl());
                         AsyncCallable ac = new AsyncCallable(future) {
                             public Object call() throws Exception {
-                                drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+                                drainChannel(ctx, future);
                                 nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
                                 return null;
                             }
@@ -2244,7 +2248,7 @@ public Object call() throws Exception {
 
                     List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
                     if (statusCode == 407
-                    		&& realm != null
+                            && realm != null
                             && proxyAuth.size() > 0
                             && !future.getAndSetAuth(true)) {
 
@@ -2310,7 +2314,7 @@ public Object call() throws Exception {
                     if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
                         updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
                         markAsDone(future, ctx);
-                        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+                        drainChannel(ctx, future);
                     }
 
                 } else if (e.getMessage() instanceof HttpChunk) {
@@ -2363,9 +2367,9 @@ public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
         private static final byte OPCODE_BINARY = 0x2;
         private static final byte OPCODE_UNKNOWN = -1;
 
-    	   protected ChannelBuffer byteBuffer = null;
-    	   protected StringBuilder textBuffer = null;
-    	   protected byte pendingOpcode = OPCODE_UNKNOWN;
+           protected ChannelBuffer byteBuffer = null;
+           protected StringBuilder textBuffer = null;
+           protected byte pendingOpcode = OPCODE_UNKNOWN;
  
         // @Override
         public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
@@ -2444,10 +2448,10 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
                 final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
 
                 if(frame instanceof TextWebSocketFrame) {
-                	pendingOpcode = OPCODE_TEXT;
+                    pendingOpcode = OPCODE_TEXT;
                 }
                 else if(frame instanceof BinaryWebSocketFrame) {
-                	pendingOpcode = OPCODE_BINARY;
+                    pendingOpcode = OPCODE_BINARY;
                 }
                 
                 HttpChunk webSocketChunk = new HttpChunk() {
