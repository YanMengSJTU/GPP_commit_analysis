diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index 9db866f3e..ad66cd64e 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -15,50 +15,42 @@
  */
 package com.ning.http.client.providers.netty;
 
+import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static com.ning.http.util.DateUtil.millisTime;
 import static com.ning.http.util.MiscUtil.isNonEmpty;
+import static org.jboss.netty.channel.Channels.pipeline;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLEngine;
 
-import com.ning.org.jboss.netty.handler.codec.http.CookieDecoder;
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHandler.STATE;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.ConnectionPoolKeyStrategy;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProgressAsyncHandler;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.RandomAccessBody;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.ntlm.NTLMEngine;
-import com.ning.http.client.ntlm.NTLMEngineException;
-import com.ning.http.client.providers.netty.spnego.SpnegoEngine;
-import com.ning.http.client.websocket.WebSocketUpgradeHandler;
-import com.ning.http.multipart.MultipartBody;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.util.CleanupChannelGroup;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
-import com.ning.http.util.UTF8UrlEncoder;
 import org.jboss.netty.bootstrap.ClientBootstrap;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBufferOutputStream;
@@ -107,38 +99,48 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLEngine;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
-import java.nio.charset.Charset;
-import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-import static org.jboss.netty.channel.Channels.pipeline;
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHandler.STATE;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+import com.ning.http.client.ConnectionPoolKeyStrategy;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.MaxRedirectException;
+import com.ning.http.client.PerRequestConfig;
+import com.ning.http.client.ProgressAsyncHandler;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.RandomAccessBody;
+import com.ning.http.client.Realm;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.filter.FilterContext;
+import com.ning.http.client.filter.FilterException;
+import com.ning.http.client.filter.IOExceptionFilter;
+import com.ning.http.client.filter.ResponseFilter;
+import com.ning.http.client.generators.InputStreamBodyGenerator;
+import com.ning.http.client.listener.TransferCompletionHandler;
+import com.ning.http.client.ntlm.NTLMEngine;
+import com.ning.http.client.ntlm.NTLMEngineException;
+import com.ning.http.client.providers.netty.spnego.SpnegoEngine;
+import com.ning.http.client.websocket.WebSocketUpgradeHandler;
+import com.ning.http.multipart.MultipartBody;
+import com.ning.http.multipart.MultipartRequestEntity;
+import com.ning.http.util.AsyncHttpProviderUtils;
+import com.ning.http.util.AuthenticatorUtils;
+import com.ning.http.util.CleanupChannelGroup;
+import com.ning.http.util.ProxyUtils;
+import com.ning.http.util.SslUtils;
+import com.ning.http.util.UTF8UrlEncoder;
+import com.ning.org.jboss.netty.handler.codec.http.CookieDecoder;
 
 public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
     private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
@@ -166,17 +168,16 @@
     private int httpsClientCodecMaxHeaderSize = 8192;
     private int httpsClientCodecMaxChunkSize = 8192;
 
-    private final ChannelGroup openChannels = new
-            CleanupChannelGroup("asyncHttpClient") {
-                @Override
-                public boolean remove(Object o) {
-                    boolean removed = super.remove(o);
-                    if (removed && trackConnections) {
-                        freeConnections.release();
-                    }
-                    return removed;
-                }
-            };
+    private final ChannelGroup openChannels = new CleanupChannelGroup("asyncHttpClient") {
+        @Override
+        public boolean remove(Object o) {
+            boolean removed = super.remove(o);
+            if (removed && trackConnections) {
+                freeConnections.release();
+            }
+            return removed;
+        }
+    };
     private final ConnectionsPool<String, Channel> connectionsPool;
     private Semaphore freeConnections = null;
     private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
@@ -191,8 +192,7 @@ public boolean remove(Object o) {
 
     public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
 
-        if (config.getAsyncHttpProviderConfig() != null
-                && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
+        if (config.getAsyncHttpProviderConfig() != null && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
             asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
         } else {
             asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
@@ -252,9 +252,9 @@ public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
 
     @Override
     public String toString() {
-        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",
-                config.getMaxTotalConnections() - freeConnections.availablePermits(),
-                openChannels.toString(),
+        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",//
+                config.getMaxTotalConnections() - freeConnections.availablePermits(),//
+                openChannels.toString(),//
                 connectionsPool.toString());
     }
 
@@ -312,39 +312,15 @@ public ChannelPipeline getPipeline() throws Exception {
     }
 
     protected void configureHttpClientCodec() {
-        httpClientCodecMaxInitialLineLength = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH,
-            Integer.class,
-            httpClientCodecMaxInitialLineLength
-        );
-        httpClientCodecMaxHeaderSize = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_HEADER_SIZE,
-            Integer.class,
-            httpClientCodecMaxHeaderSize
-        );
-        httpClientCodecMaxChunkSize = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE,
-            Integer.class,
-            httpClientCodecMaxChunkSize
-        );
+        httpClientCodecMaxInitialLineLength = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH, Integer.class, httpClientCodecMaxInitialLineLength);
+        httpClientCodecMaxHeaderSize = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_HEADER_SIZE, Integer.class, httpClientCodecMaxHeaderSize);
+        httpClientCodecMaxChunkSize = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTP_CLIENT_CODEC_MAX_CHUNK_SIZE, Integer.class, httpClientCodecMaxChunkSize);
     }
 
     protected void configureHttpsClientCodec() {
-        httpsClientCodecMaxInitialLineLength = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH,
-            Integer.class,
-            httpsClientCodecMaxInitialLineLength
-        );
-        httpsClientCodecMaxHeaderSize = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_HEADER_SIZE,
-            Integer.class,
-            httpsClientCodecMaxHeaderSize
-        );
-        httpsClientCodecMaxChunkSize = asyncHttpProviderConfig.getProperty(
-            NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_CHUNK_SIZE,
-            Integer.class,
-            httpsClientCodecMaxChunkSize
-        );
+        httpsClientCodecMaxInitialLineLength = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_INITIAL_LINE_LENGTH, Integer.class, httpsClientCodecMaxInitialLineLength);
+        httpsClientCodecMaxHeaderSize = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_HEADER_SIZE, Integer.class, httpsClientCodecMaxHeaderSize);
+        httpsClientCodecMaxChunkSize = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.HTTPS_CLIENT_CODEC_MAX_CHUNK_SIZE, Integer.class, httpsClientCodecMaxChunkSize);
     }
 
     void constructSSLPipeline(final NettyConnectListener<?> cl) {
@@ -427,11 +403,11 @@ private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException
     }
 
     private HttpClientCodec createHttpClientCodec() {
-      return new HttpClientCodec(httpClientCodecMaxInitialLineLength, httpClientCodecMaxHeaderSize, httpClientCodecMaxChunkSize);
+        return new HttpClientCodec(httpClientCodecMaxInitialLineLength, httpClientCodecMaxHeaderSize, httpClientCodecMaxChunkSize);
     }
 
     private HttpClientCodec createHttpsClientCodec() {
-      return new HttpClientCodec(httpsClientCodecMaxInitialLineLength, httpsClientCodecMaxHeaderSize, httpsClientCodecMaxChunkSize);
+        return new HttpClientCodec(httpsClientCodecMaxInitialLineLength, httpsClientCodecMaxHeaderSize, httpsClientCodecMaxChunkSize);
     }
 
     private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
@@ -446,14 +422,10 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
         return channel;
     }
 
-    protected final <T> void writeRequest(final Channel channel,
-                                          final AsyncHttpClientConfig config,
-                                          final NettyResponseFuture<T> future,
-                                          final HttpRequest nettyRequest) {
+    protected final <T> void writeRequest(final Channel channel, final AsyncHttpClientConfig config, final NettyResponseFuture<T> future, final HttpRequest nettyRequest) {
         try {
             /**
-             * If the channel is dead because it was pooled and the remote server decided to close it,
-             * we just let it go and the closeChannel do it's work.
+             * If the channel is dead because it was pooled and the remote server decided to close it, we just let it go and the closeChannel do it's work.
              */
             if (!channel.isOpen() || !channel.isConnected()) {
                 return;
@@ -493,8 +465,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                     }
                 }
 
-                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(
-                        new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
+                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
             }
 
             // Leave it to true.
@@ -592,7 +563,7 @@ public void operationComplete(ChannelFuture cf) {
 
         try {
             future.touch();
-            int delay = Math.min(config.getIdleConnectionTimeoutInMs(), requestTimeout(config, future.getRequest().getPerRequestConfig()));
+            int delay = Math.min(config.getIdleConnectionTimeoutInMs(), requestTimeoutInMs(config, future.getRequest().getPerRequestConfig()));
             if (delay != -1 && !future.isDone() && !future.isCancelled()) {
                 ReaperFuture reaperFuture = new ReaperFuture(future);
                 Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, delay, TimeUnit.MILLISECONDS);
@@ -605,8 +576,7 @@ public void operationComplete(ChannelFuture cf) {
 
     }
 
-    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
-                                                    boolean allowConnect, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
+    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri, boolean allowConnect, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
 
         String method = request.getMethod();
         if (allowConnect && proxyServer != null && isSecure(uri)) {
@@ -616,17 +586,12 @@ protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Re
     }
 
     private static SpnegoEngine getSpnegoEngine() {
-        if(spnegoEngine == null)
+        if (spnegoEngine == null)
             spnegoEngine = new SpnegoEngine();
         return spnegoEngine;
     }
 
-    private static HttpRequest construct(AsyncHttpClientConfig config,
-                                         Request request,
-                                         HttpMethod m,
-                                         URI uri,
-                                         ChannelBuffer buffer,
-                                         ProxyServer proxyServer) throws IOException {
+    private static HttpRequest construct(AsyncHttpClientConfig config, Request request, HttpMethod m, URI uri, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
 
         String host = AsyncHttpProviderUtils.getHost(uri);
 
@@ -704,47 +669,44 @@ else if (uri.getRawQuery() != null)
             }
 
             switch (realm.getAuthScheme()) {
-                case BASIC:
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(realm));
-                    break;
-                case DIGEST:
-                    if (isNonEmpty(realm.getNonce())) {
-                        try {
-                            nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                                    AuthenticatorUtils.computeDigestAuthentication(realm));
-                        } catch (NoSuchAlgorithmException e) {
-                            throw new SecurityException(e);
-                        }
-                    }
-                    break;
-                case NTLM:
-                    try {
-                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                                ntlmEngine.generateType1Msg("NTLM " + domain, authHost));
-                    } catch (NTLMEngineException e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                    break;
-                case KERBEROS:
-                case SPNEGO:
-                    String challengeHeader = null;
-                    String server = proxyServer == null ? host : proxyServer.getHost();
+            case BASIC:
+                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(realm));
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce())) {
                     try {
-                        challengeHeader = getSpnegoEngine().generateToken(server);
-                    } catch (Throwable e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
+                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeDigestAuthentication(realm));
+                    } catch (NoSuchAlgorithmException e) {
+                        throw new SecurityException(e);
                     }
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-                    break;
-                case NONE:
-                    break;
-                default:
-                    throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
+                }
+                break;
+            case NTLM:
+                try {
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, ntlmEngine.generateType1Msg("NTLM " + domain, authHost));
+                } catch (NTLMEngineException e) {
+                    IOException ie = new IOException();
+                    ie.initCause(e);
+                    throw ie;
+                }
+                break;
+            case KERBEROS:
+            case SPNEGO:
+                String challengeHeader = null;
+                String server = proxyServer == null ? host : proxyServer.getHost();
+                try {
+                    challengeHeader = getSpnegoEngine().generateToken(server);
+                } catch (Throwable e) {
+                    IOException ie = new IOException();
+                    ie.initCause(e);
+                    throw ie;
+                }
+                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+                break;
+            case NONE:
+                break;
+            default:
+                throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
             }
         }
 
@@ -763,8 +725,7 @@ else if (uri.getRawQuery() != null)
                     List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
                     if (!(auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM"))) {
                         try {
-                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
-                                    proxyServer.getHost());
+                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(), proxyServer.getHost());
                             nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
                         } catch (NTLMEngineException e) {
                             IOException ie = new IOException();
@@ -773,8 +734,7 @@ else if (uri.getRawQuery() != null)
                         }
                     }
                 } else {
-                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(proxyServer));
+                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(proxyServer));
                 }
             }
         }
@@ -859,7 +819,7 @@ else if (uri.getRawQuery() != null)
                     }
 
                     MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getHeaders());
-                    
+
                     nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
                     nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
 
@@ -925,9 +885,7 @@ public void close() {
 
     /* @Override */
 
-    public Response prepareResponse(final HttpResponseStatus status,
-                                    final HttpResponseHeaders headers,
-                                    final List<HttpResponseBodyPart> bodyParts) {
+    public Response prepareResponse(final HttpResponseStatus status, final HttpResponseHeaders headers, final List<HttpResponseBodyPart> bodyParts) {
         return new NettyResponse(status, headers, bodyParts);
     }
 
@@ -941,8 +899,7 @@ public Response prepareResponse(final HttpResponseStatus status,
         doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
     }
 
-    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f,
-                                              boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
+    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
 
         if (isClose.get()) {
             throw new IOException("Closed");
@@ -967,14 +924,13 @@ public Response prepareResponse(final HttpResponseStatus status,
             if (f != null && f.reuseChannel() && f.channel() != null) {
                 channel = f.channel();
             } else {
-                URI connectionKeyUri = useProxy? proxyServer.getURI() : uri;
+                URI connectionKeyUri = useProxy ? proxyServer.getURI() : uri;
                 channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
             }
         }
 
         ChannelBuffer bufferedBytes = null;
-        if (f != null && f.getRequest().getFile() == null &&
-                !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
+        if (f != null && f.getRequest().getFile() == null && !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
             bufferedBytes = f.getNettyRequest().getContent();
         }
 
@@ -1069,9 +1025,9 @@ public Response prepareResponse(final HttpResponseStatus status,
                 remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
             }
 
-            if(request.getLocalAddress() != null){
+            if (request.getLocalAddress() != null) {
                 channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
-            }else{
+            } else {
                 channelFuture = bootstrap.connect(remoteAddress);
             }
 
@@ -1126,7 +1082,7 @@ public Response prepareResponse(final HttpResponseStatus status,
         return c.future();
     }
 
-    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
+    protected static int requestTimeoutInMs(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
         int result;
         if (perRequestConfig != null) {
             int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
@@ -1152,7 +1108,6 @@ private void finishChannel(final ChannelHandlerContext ctx) {
 
         log.debug("Closing Channel {} ", ctx.getChannel());
 
-
         try {
             ctx.getChannel().close();
         } catch (Throwable t) {
@@ -1167,7 +1122,7 @@ private void finishChannel(final ChannelHandlerContext ctx) {
 
     @Override
     public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-        //call super to reset the read timeout
+        // call super to reset the read timeout
         super.messageReceived(ctx, e);
         IN_IO_THREAD.set(Boolean.TRUE);
         if (ctx.getAttachment() == null) {
@@ -1204,12 +1159,7 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
         p.handle(ctx, e);
     }
 
-    private Realm kerberosChallenge(List<String> proxyAuth,
-                                    Request request,
-                                    ProxyServer proxyServer,
-                                    FluentCaseInsensitiveStringsMap headers,
-                                    Realm realm,
-                                    NettyResponseFuture<?> future) throws NTLMEngineException {
+    private Realm kerberosChallenge(List<String> proxyAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
 
         URI uri = request.getURI();
         String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
@@ -1225,10 +1175,7 @@ private Realm kerberosChallenge(List<String> proxyAuth,
             } else {
                 realmBuilder = new Realm.RealmBuilder();
             }
-            return realmBuilder.setUri(uri.getRawPath())
-                    .setMethodName(request.getMethod())
-                    .setScheme(Realm.AuthScheme.KERBEROS)
-                    .build();
+            return realmBuilder.setUri(uri.getRawPath()).setMethodName(request.getMethod()).setScheme(Realm.AuthScheme.KERBEROS).build();
         } catch (Throwable throwable) {
             if (proxyAuth.contains("NTLM")) {
                 return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
@@ -1238,12 +1185,7 @@ private Realm kerberosChallenge(List<String> proxyAuth,
         }
     }
 
-    private Realm ntlmChallenge(List<String> wwwAuth,
-                                Request request,
-                                ProxyServer proxyServer,
-                                FluentCaseInsensitiveStringsMap headers,
-                                Realm realm,
-                                NettyResponseFuture<?> future) throws NTLMEngineException {
+    private Realm ntlmChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
 
         boolean useRealm = (proxyServer == null && realm != null);
 
@@ -1258,19 +1200,14 @@ private Realm ntlmChallenge(List<String> wwwAuth,
 
             URI uri = request.getURI();
             headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                    .setUri(uri.getRawPath())
-                    .setMethodName(request.getMethod())
-                    .setNtlmMessageType2Received(true)
-                    .build();
+            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(uri.getRawPath()).setMethodName(request.getMethod()).setNtlmMessageType2Received(true).build();
             future.getAndSetAuth(false);
         } else {
             headers.remove(HttpHeaders.Names.AUTHORIZATION);
 
             if (wwwAuth.get(0).startsWith("NTLM ")) {
                 String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-                String challengeHeader = ntlmEngine.generateType3Msg(principal, password,
-                        ntlmDomain, ntlmHost, serverChallenge);
+                String challengeHeader = ntlmEngine.generateType3Msg(principal, password, ntlmDomain, ntlmHost, serverChallenge);
 
                 headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
             }
@@ -1284,31 +1221,19 @@ private Realm ntlmChallenge(List<String> wwwAuth,
                 realmBuilder = new Realm.RealmBuilder();
                 authScheme = Realm.AuthScheme.NTLM;
             }
-            newRealm = realmBuilder.setScheme(authScheme)
-                    .setUri(request.getURI().getPath())
-                    .setMethodName(request.getMethod())
-                    .build();
+            newRealm = realmBuilder.setScheme(authScheme).setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
         }
 
         return newRealm;
     }
 
-    private Realm ntlmProxyChallenge(List<String> wwwAuth,
-                                     Request request,
-                                     ProxyServer proxyServer,
-                                     FluentCaseInsensitiveStringsMap headers,
-                                     Realm realm,
-                                     NettyResponseFuture<?> future) throws NTLMEngineException {
+    private Realm ntlmProxyChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
         future.getAndSetAuth(false);
         headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
 
         if (wwwAuth.get(0).startsWith("NTLM ")) {
             String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(),
-                    proxyServer.getPassword(),
-                    proxyServer.getNtlmDomain(),
-                    proxyServer.getHost(),
-                    serverChallenge);
+            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getNtlmDomain(), proxyServer.getHost(), serverChallenge);
             headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
         }
         Realm newRealm;
@@ -1318,14 +1243,11 @@ private Realm ntlmProxyChallenge(List<String> wwwAuth,
         } else {
             realmBuilder = new Realm.RealmBuilder();
         }
-        newRealm = realmBuilder
-                .setUri(request.getURI().getPath())
-                .setMethodName(request.getMethod())
-                .build();
+        newRealm = realmBuilder.setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
 
         return newRealm;
     }
-    
+
     private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
         URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
         return future.getConnectionPoolKeyStrategy().getKey(uri);
@@ -1334,7 +1256,7 @@ private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLExce
     private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
         ctx.setAttachment(new AsyncCallable(future) {
             public Object call() throws Exception {
-                
+
                 if (future.getKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
                     return null;
                 }
@@ -1454,8 +1376,7 @@ public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws
             future.touch();
 
             if (config.getIOExceptionFilters().size() > 0) {
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                        .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
                 fc = handleIoException(fc, future);
 
                 if (fc.replayRequest() && !future.cannotBeReplay()) {
@@ -1485,11 +1406,8 @@ protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future)
 
         connectionsPool.removeAll(channel);
 
-        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null
-                && NettyResponseFuture.class.isAssignableFrom(
-                channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
-            future = (NettyResponseFuture<?>)
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null && NettyResponseFuture.class.isAssignableFrom(channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
+            future = (NettyResponseFuture<?>) channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
         }
 
         if (future == null || future.cannotBeReplay()) {
@@ -1558,23 +1476,20 @@ private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future
         return state;
     }
 
-    //Simple marker for stopping publishing bytes.
+    // Simple marker for stopping publishing bytes.
 
     final static class DiscardEvent {
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
-            throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
         Channel channel = e.getChannel();
         Throwable cause = e.getCause();
         NettyResponseFuture<?> future = null;
 
-        /** Issue 81
-        if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) {
-            return;
-        }
-        */
+        /**
+         * Issue 81 if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) { return; }
+         */
         if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
             return;
         }
@@ -1597,8 +1512,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                 if (IOException.class.isAssignableFrom(cause.getClass())) {
 
                     if (config.getIOExceptionFilters().size() > 0) {
-                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                                .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
                         fc = handleIoException(fc, future);
 
                         if (fc.replayRequest()) {
@@ -1646,8 +1560,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
     protected static boolean abortOnConnectCloseException(Throwable cause) {
         try {
             for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl")
-                        && element.getMethodName().equals("checkConnect")) {
+                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl") && element.getMethodName().equals("checkConnect")) {
                     return true;
                 }
             }
@@ -1664,8 +1577,7 @@ protected static boolean abortOnConnectCloseException(Throwable cause) {
     protected static boolean abortOnDisconnectException(Throwable cause) {
         try {
             for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler")
-                        && element.getMethodName().equals("channelDisconnected")) {
+                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler") && element.getMethodName().equals("channelDisconnected")) {
                     return true;
                 }
             }
@@ -1682,8 +1594,7 @@ protected static boolean abortOnDisconnectException(Throwable cause) {
     protected static boolean abortOnReadCloseException(Throwable cause) {
 
         for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("read")) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("read")) {
                 return true;
             }
         }
@@ -1698,8 +1609,7 @@ protected static boolean abortOnReadCloseException(Throwable cause) {
     protected static boolean abortOnWriteCloseException(Throwable cause) {
 
         for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("write")) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("write")) {
                 return true;
             }
         }
@@ -1723,19 +1633,19 @@ private final static int computeAndSetContentLength(Request request, HttpRequest
         return length;
     }
 
-    public static <T> NettyResponseFuture<T> newFuture(URI uri,
-                                                       Request request,
-                                                       AsyncHandler<T> asyncHandler,
-                                                       HttpRequest nettyRequest,
-                                                       AsyncHttpClientConfig config,
-                                                       NettyAsyncHttpProvider provider,
-                                                       ProxyServer proxyServer) {
+    public static <T> NettyResponseFuture<T> newFuture(URI uri, Request request, AsyncHandler<T> asyncHandler, HttpRequest nettyRequest, AsyncHttpClientConfig config, NettyAsyncHttpProvider provider, ProxyServer proxyServer) {
 
-        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest,
-                requestTimeout(config, request.getPerRequestConfig()), config.getIdleConnectionTimeoutInMs(), provider, request.getConnectionPoolKeyStrategy(), proxyServer);
+        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri,//
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                requestTimeoutInMs(config, request.getPerRequestConfig()),//
+                config.getIdleConnectionTimeoutInMs(),//
+                provider,//
+                request.getConnectionPoolKeyStrategy(),//
+                proxyServer);
 
-        if (request.getHeaders().getFirstValue("Expect") != null
-                && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
+        if (request.getHeaders().getFirstValue("Expect") != null && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
             f.getAndSetWriteBody(false);
         }
         return f;
@@ -1769,9 +1679,7 @@ public void operationComplete(ChannelFuture cf) {
                     return;
                 }
 
-                if (ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                        || abortOnReadCloseException(cause)
-                        || abortOnWriteCloseException(cause)) {
+                if (ClosedChannelException.class.isAssignableFrom(cause.getClass()) || abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
 
                     if (log.isDebugEnabled()) {
                         log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
@@ -1791,13 +1699,10 @@ public void operationComplete(ChannelFuture cf) {
             future.touch();
 
             /**
-             * We need to make sure we aren't in the middle of an authorization process before publishing events
-             * as we will re-publish again the same event after the authorization, causing unpredictable behavior.
+             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization, causing unpredictable behavior.
              */
             Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
-            boolean startPublishing = future.isInAuth()
-                    || realm == null
-                    || realm.getUsePreemptiveAuth() == true;
+            boolean startPublishing = future.isInAuth() || realm == null || realm.getUsePreemptiveAuth() == true;
 
             if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
                 if (notifyHeaders) {
@@ -1817,10 +1722,8 @@ public void operationProgressed(ChannelFuture cf, long amount, long current, lon
     }
 
     /**
-     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run
-     * them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future
-     * this wrapper will release the references to the channel and the nettyResponseFuture immediately. Otherwise,
-     * the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
+     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future this wrapper will release the references to the channel and the
+     * nettyResponseFuture immediately. Otherwise, the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
      */
     private final class ReaperFuture implements Future, Runnable {
         private Future scheduledFuture;
@@ -1870,6 +1773,12 @@ public boolean isDone() {
             return scheduledFuture.isDone();
         }
 
+        private void expire(String message) {
+            log.debug("{} for {}", message, nettyResponseFuture);
+            abort(nettyResponseFuture, new TimeoutException(message));
+            nettyResponseFuture = null;
+        }
+
         /**
          * @Override
          */
@@ -1879,22 +1788,22 @@ public synchronized void run() {
                 return;
             }
 
-            if (nettyResponseFuture != null && nettyResponseFuture.hasExpired()
-                    && !nettyResponseFuture.isDone() && !nettyResponseFuture.isCancelled()) {
-                log.debug("Request Timeout expired for {}\n", nettyResponseFuture);
+            boolean futureDone = nettyResponseFuture.isDone();
+            boolean futureCanceled = nettyResponseFuture.isCancelled();
 
-                int requestTimeout = config.getRequestTimeoutInMs();
-                PerRequestConfig p = nettyResponseFuture.getRequest().getPerRequestConfig();
-                if (p != null && p.getRequestTimeoutInMs() != -1) {
-                    requestTimeout = p.getRequestTimeoutInMs();
-                }
+            if (nettyResponseFuture != null && !futureDone && !futureCanceled) {
 
-                abort(nettyResponseFuture, new TimeoutException(String.format("No response received after %s", requestTimeout)));
+                long now = millisTime();
+                if (nettyResponseFuture.hasRequestTimedOut(now)) {
+                    long age = (now - nettyResponseFuture.getStart()) / 1000000;
+                    expire("Request reached time out of " + nettyResponseFuture.getRequestTimeoutInMs() + " ms after " + age + " ms");
 
-                nettyResponseFuture = null;
-            }
+                } else if (nettyResponseFuture.hasConnectionIdleTimedOut(now)) {
+                    long age = (now - nettyResponseFuture.getStart()) / 1000000;
+                    expire("Request reached idle time out of " + nettyResponseFuture.getIdleConnectionTimeoutInMs() + " ms after " + age + " ms");
+                }
 
-            if (nettyResponseFuture == null || nettyResponseFuture.isDone() || nettyResponseFuture.isCancelled()) {
+            } else if (nettyResponseFuture == null || futureDone || futureCanceled) {
                 cancel(true);
             }
         }
@@ -1959,9 +1868,7 @@ public long getCount() {
         public long transferTo(WritableByteChannel target, long position) throws IOException {
             long count = this.count - position;
             if (count < 0 || position < 0) {
-                throw new IllegalArgumentException(
-                        "position out of range: " + position +
-                                " (expected: 0 - " + (this.count - 1) + ")");
+                throw new IllegalArgumentException("position out of range: " + position + " (expected: 0 - " + (this.count - 1) + ")");
             }
             if (count == 0) {
                 return 0L;
@@ -2054,17 +1961,11 @@ private static final boolean validateWebSocketRequest(Request request, AsyncHand
         return true;
     }
 
-    private boolean redirect(Request request,
-                             NettyResponseFuture<?> future,
-                             HttpResponse response,
-                             final ChannelHandlerContext ctx) throws Exception {
+    private boolean redirect(Request request, NettyResponseFuture<?> future, HttpResponse response, final ChannelHandlerContext ctx) throws Exception {
 
         int statusCode = response.getStatus().getCode();
         boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
-        if (redirectEnabled && (statusCode == 302
-                || statusCode == 301
-                || statusCode == 303
-                || statusCode == 307)) {
+        if (redirectEnabled && (statusCode == 302 || statusCode == 301 || statusCode == 303 || statusCode == 307)) {
 
             if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
                 // We must allow 401 handling again.
@@ -2074,13 +1975,9 @@ private boolean redirect(Request request,
                 URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
                 boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
                 if (!uri.toString().equals(future.getURI().toString())) {
-                    final RequestBuilder nBuilder = stripQueryString ?
-                            new RequestBuilder(future.getRequest()).setQueryParameters(null)
-                            : new RequestBuilder(future.getRequest());
+                    final RequestBuilder nBuilder = stripQueryString ? new RequestBuilder(future.getRequest()).setQueryParameters(null) : new RequestBuilder(future.getRequest());
 
-                    if (!(statusCode < 302 || statusCode > 303)
-                            && !(statusCode == 302
-                            && config.isStrict302Handling())) {
+                    if (!(statusCode < 302 || statusCode > 303) && !(statusCode == 302 && config.isStrict302Handling())) {
                         nBuilder.setMethod("GET");
                     }
                     final boolean initialConnectionKeepAlive = future.getKeepAlive();
@@ -2166,12 +2063,7 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
 
                     HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
                     HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    FilterContext fc = new FilterContext.FilterContextBuilder()
-                            .asyncHandler(handler)
-                            .request(request)
-                            .responseStatus(status)
-                            .responseHeaders(responseHeaders)
-                            .build();
+                    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(request).responseStatus(status).responseHeaders(responseHeaders).build();
 
                     for (ResponseFilter asyncFilter : config.getResponseFilters()) {
                         try {
@@ -2198,14 +2090,11 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                     final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
                     final RequestBuilder builder = new RequestBuilder(future.getRequest());
 
-                    //if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
-                    //    builder.setUrl(future.getURI().toString());
-                    //}
+                    // if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
+                    // builder.setUrl(future.getURI().toString());
+                    // }
 
-                    if (statusCode == 401
-                            && realm != null
-                            && wwwAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
+                    if (statusCode == 401 && realm != null && wwwAuth.size() > 0 && !future.getAndSetAuth(true)) {
 
                         future.setState(NettyResponseFuture.STATE.NEW);
                         // NTLM
@@ -2214,25 +2103,19 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                             // SPNEGO KERBEROS
                         } else if (wwwAuth.contains("Negotiate")) {
                             newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
+                            if (newRealm == null)
+                                return;
                         } else {
                             Realm.RealmBuilder realmBuilder;
                             if (realm != null) {
-                                realmBuilder = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                                ;
+                                realmBuilder = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme());
                             } else {
                                 realmBuilder = new Realm.RealmBuilder();
                             }
-                            newRealm = realmBuilder
-                                    .setUri(request.getURI().getPath())
-                                    .setMethodName(request.getMethod())
-                                    .setUsePreemptiveAuth(true)
-                                    .parseWWWAuthenticateHeader(wwwAuth.get(0))
-                                    .build();
+                            newRealm = realmBuilder.setUri(request.getURI().getPath()).setMethodName(request.getMethod()).setUsePreemptiveAuth(true).parseWWWAuthenticateHeader(wwwAuth.get(0)).build();
                         }
 
-                        final Realm nr = new Realm.RealmBuilder().clone(newRealm)
-                                .setUri(request.getUrl()).build();
+                        final Realm nr = new Realm.RealmBuilder().clone(newRealm).setUri(request.getUrl()).build();
 
                         log.debug("Sending authentication to {}", request.getUrl());
                         AsyncCallable ac = new AsyncCallable(future) {
@@ -2260,10 +2143,7 @@ public Object call() throws Exception {
                     }
 
                     List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
-                    if (statusCode == 407
-                            && realm != null
-                            && proxyAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
+                    if (statusCode == 407 && realm != null && proxyAuth.size() > 0 && !future.getAndSetAuth(true)) {
 
                         log.debug("Sending proxy authentication to {}", request.getUrl());
 
@@ -2274,7 +2154,8 @@ public Object call() throws Exception {
                             // SPNEGO KERBEROS
                         } else if (proxyAuth.contains("Negotiate")) {
                             newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
+                            if (newRealm == null)
+                                return;
                         } else {
                             newRealm = future.getRequest().getRealm();
                         }
@@ -2286,8 +2167,7 @@ public Object call() throws Exception {
                         return;
                     }
 
-                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)
-                            && statusCode == 200) {
+                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT) && statusCode == 200) {
 
                         log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
 
@@ -2308,7 +2188,8 @@ public Object call() throws Exception {
                         return;
                     }
 
-                    if (redirect(request, future, response, ctx)) return;
+                    if (redirect(request, future, response, ctx))
+                        return;
 
                     if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
                         finishUpdate(future, ctx, response.isChunked());
@@ -2334,11 +2215,9 @@ public Object call() throws Exception {
                     HttpChunk chunk = (HttpChunk) e.getMessage();
 
                     if (handler != null) {
-                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler,
-                                new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
+                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
                             if (chunk instanceof DefaultHttpChunkTrailer) {
-                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(),
-                                        future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
+                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(), future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
                             }
                             finishUpdate(future, ctx, !chunk.isLast());
                         }
@@ -2346,8 +2225,7 @@ public Object call() throws Exception {
                 }
             } catch (Exception t) {
                 if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                            .request(future.getRequest()).ioException(IOException.class.cast(t)).build();
+                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(IOException.class.cast(t)).build();
                     fc = handleIoException(fc, future);
 
                     if (fc.replayRequest()) {
@@ -2380,10 +2258,10 @@ public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
         private static final byte OPCODE_BINARY = 0x2;
         private static final byte OPCODE_UNKNOWN = -1;
 
-           protected ChannelBuffer byteBuffer = null;
-           protected StringBuilder textBuffer = null;
-           protected byte pendingOpcode = OPCODE_UNKNOWN;
- 
+        protected ChannelBuffer byteBuffer = null;
+        protected StringBuilder textBuffer = null;
+        protected byte pendingOpcode = OPCODE_UNKNOWN;
+
         // @Override
         public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
             NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
@@ -2395,12 +2273,7 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
 
                 HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
                 HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder()
-                        .asyncHandler(h)
-                        .request(request)
-                        .responseStatus(s)
-                        .responseHeaders(responseHeaders)
-                        .build();
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(h).request(request).responseStatus(s).responseHeaders(responseHeaders).build();
                 for (ResponseFilter asyncFilter : config.getResponseFilters()) {
                     try {
                         fc = asyncFilter.filter(fc);
@@ -2423,10 +2296,10 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
                 }
 
                 future.setHttpResponse(response);
-                if (redirect(request, future, response, ctx)) return;
+                if (redirect(request, future, response, ctx))
+                    return;
 
-                final org.jboss.netty.handler.codec.http.HttpResponseStatus status =
-                        new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
+                final org.jboss.netty.handler.codec.http.HttpResponseStatus status = new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
 
                 final boolean validStatus = response.getStatus().equals(status);
                 final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
@@ -2460,13 +2333,12 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
             } else if (e.getMessage() instanceof WebSocketFrame) {
                 final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
 
-                if(frame instanceof TextWebSocketFrame) {
+                if (frame instanceof TextWebSocketFrame) {
                     pendingOpcode = OPCODE_TEXT;
-                }
-                else if(frame instanceof BinaryWebSocketFrame) {
+                } else if (frame instanceof BinaryWebSocketFrame) {
                     pendingOpcode = OPCODE_BINARY;
                 }
-                
+
                 HttpChunk webSocketChunk = new HttpChunk() {
                     private ChannelBuffer content;
 
@@ -2494,11 +2366,10 @@ public void setContent(ChannelBuffer content) {
                     NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
 
                     if (webSocket != null) {
-                        if(pendingOpcode == OPCODE_BINARY) {
-                            webSocket.onBinaryFragment(rp.getBodyPartBytes(),frame.isFinalFragment());
-                        }
-                        else {
-                            webSocket.onTextFragment(frame.getBinaryData().toString(UTF8),frame.isFinalFragment());
+                        if (pendingOpcode == OPCODE_BINARY) {
+                            webSocket.onBinaryFragment(rp.getBodyPartBytes(), frame.isFinalFragment());
+                        } else {
+                            webSocket.onTextFragment(frame.getBinaryData().toString(UTF8), frame.isFinalFragment());
                         }
 
                         if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
@@ -2518,7 +2389,7 @@ public void setContent(ChannelBuffer content) {
             }
         }
 
-        //@Override
+        // @Override
         public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
             try {
                 log.warn("onError {}", e);
@@ -2539,7 +2410,7 @@ public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
             }
         }
 
-        //@Override
+        // @Override
         public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
             log.trace("onClose {}", e);
             if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
index dae8095c4..fff32feca 100755
--- a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
@@ -17,17 +17,6 @@
 
 import static com.ning.http.util.DateUtil.millisTime;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.ConnectionPoolKeyStrategy;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Request;
-import com.ning.http.client.listenable.AbstractListenableFuture;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.util.concurrent.Callable;
@@ -42,9 +31,21 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.ConnectionPoolKeyStrategy;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.Request;
+import com.ning.http.client.listenable.AbstractListenableFuture;
+
 /**
  * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
- *
+ * 
  * @param <V>
  */
 public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
@@ -53,17 +54,14 @@
     public final static String MAX_RETRY = "com.ning.http.client.providers.netty.maxRetry";
 
     enum STATE {
-        NEW,
-        POOLED,
-        RECONNECTED,
-        CLOSED,
+        NEW, POOLED, RECONNECTED, CLOSED,
     }
 
     private final CountDownLatch latch = new CountDownLatch(1);
     private final AtomicBoolean isDone = new AtomicBoolean(false);
     private final AtomicBoolean isCancelled = new AtomicBoolean(false);
     private AsyncHandler<V> asyncHandler;
-    private final int responseTimeoutInMs;
+    private final int requestTimeoutInMs;
     private final int idleConnectionTimeoutInMs;
     private Request request;
     private HttpRequest nettyRequest;
@@ -92,18 +90,18 @@
     private final ConnectionPoolKeyStrategy connectionPoolKeyStrategy;
     private final ProxyServer proxyServer;
 
-    public NettyResponseFuture(URI uri,
-                               Request request,
-                               AsyncHandler<V> asyncHandler,
-                               HttpRequest nettyRequest,
-                               int responseTimeoutInMs,
-                               int idleConnectionTimeoutInMs,
-                               NettyAsyncHttpProvider asyncHttpProvider,
-                               ConnectionPoolKeyStrategy connectionPoolKeyStrategy,
-                               ProxyServer proxyServer) {
+    public NettyResponseFuture(URI uri,//
+            Request request,//
+            AsyncHandler<V> asyncHandler,//
+            HttpRequest nettyRequest,//
+            int requestTimeoutInMs,//
+            int idleConnectionTimeoutInMs,//
+            NettyAsyncHttpProvider asyncHttpProvider,//
+            ConnectionPoolKeyStrategy connectionPoolKeyStrategy,//
+            ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
-        this.responseTimeoutInMs = responseTimeoutInMs;
+        this.requestTimeoutInMs = requestTimeoutInMs;
         this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
         this.request = request;
         this.nettyRequest = nettyRequest;
@@ -164,7 +162,8 @@ void setAsyncHandler(AsyncHandler<V> asyncHandler) {
     public boolean cancel(boolean force) {
         cancelReaper();
 
-        if (isCancelled.get()) return false;
+        if (isCancelled.get())
+            return false;
 
         try {
             channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
@@ -187,13 +186,20 @@ public boolean cancel(boolean force) {
 
     /**
      * Is the Future still valid
-     *
+     * 
      * @return <code>true</code> if response has expired and should be terminated.
      */
     public boolean hasExpired() {
         long now = millisTime();
-        return idleConnectionTimeoutInMs != -1 && ((now - touch.get()) >= idleConnectionTimeoutInMs)
-                || responseTimeoutInMs != -1 && ((now - start) >= responseTimeoutInMs);
+        return hasConnectionIdleTimedOut(now) || hasRequestTimedOut(now);
+    }
+
+    public boolean hasConnectionIdleTimedOut(long now) {
+        return idleConnectionTimeoutInMs != -1 && (now - touch.get()) >= idleConnectionTimeoutInMs;
+    }
+
+    public boolean hasRequestTimedOut(long now) {
+        return requestTimeoutInMs != -1 && (now - start) >= requestTimeoutInMs;
     }
 
     /**
@@ -202,7 +208,7 @@ public boolean hasExpired() {
     /* @Override */
     public V get() throws InterruptedException, ExecutionException {
         try {
-            return get(responseTimeoutInMs, TimeUnit.MILLISECONDS);
+            return get(requestTimeoutInMs, TimeUnit.MILLISECONDS);
         } catch (TimeoutException e) {
             cancelReaper();
             throw new ExecutionException(e);
@@ -324,7 +330,8 @@ public final void done(Callable callable) {
     public final void abort(final Throwable t) {
         cancelReaper();
 
-        if (isDone.get() || isCancelled.get()) return;
+        if (isDone.get() || isCancelled.get())
+            return;
 
         exEx.compareAndSet(null, new ExecutionException(t));
         if (!throwableCalled.getAndSet(true)) {
@@ -478,38 +485,45 @@ public void setRequest(Request request) {
     }
 
     /**
-     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be
-     * closed by an unexpected IOException, and in some situation we can recover from that exception.
-     *
+     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can recover from that exception.
+     * 
      * @return true if that {@link Future} cannot be recovered.
      */
     public boolean cannotBeReplay() {
-        return isDone()
-                || !canRetry()
-                || isCancelled()
-                || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0)
-                || isInAuth();
+        return isDone() || !canRetry() || isCancelled() || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0) || isInAuth();
+    }
+
+    public long getStart() {
+        return start;
+    }
+
+    public long getRequestTimeoutInMs() {
+        return requestTimeoutInMs;
+    }
+
+    public long getIdleConnectionTimeoutInMs() {
+        return idleConnectionTimeoutInMs;
     }
 
     @Override
     public String toString() {
-        return "NettyResponseFuture{" +
-                "currentRetry=" + currentRetry +
-                ",\n\tisDone=" + isDone +
-                ",\n\tisCancelled=" + isCancelled +
-                ",\n\tasyncHandler=" + asyncHandler +
-                ",\n\tresponseTimeoutInMs=" + responseTimeoutInMs +
-                ",\n\tnettyRequest=" + nettyRequest +
-                ",\n\tcontent=" + content +
-                ",\n\turi=" + uri +
-                ",\n\tkeepAlive=" + keepAlive +
-                ",\n\thttpResponse=" + httpResponse +
-                ",\n\texEx=" + exEx +
-                ",\n\tredirectCount=" + redirectCount +
-                ",\n\treaperFuture=" + reaperFuture +
-                ",\n\tinAuth=" + inAuth +
-                ",\n\tstatusReceived=" + statusReceived +
-                ",\n\ttouch=" + touch +
+        return "NettyResponseFuture{" + //
+                "currentRetry=" + currentRetry + //
+                ",\n\tisDone=" + isDone + //
+                ",\n\tisCancelled=" + isCancelled + //
+                ",\n\tasyncHandler=" + asyncHandler + //
+                ",\n\trequestTimeoutInMs=" + requestTimeoutInMs + //
+                ",\n\tnettyRequest=" + nettyRequest + //
+                ",\n\tcontent=" + content + //
+                ",\n\turi=" + uri + //
+                ",\n\tkeepAlive=" + keepAlive + //
+                ",\n\thttpResponse=" + httpResponse + //
+                ",\n\texEx=" + exEx + //
+                ",\n\tredirectCount=" + redirectCount + //
+                ",\n\treaperFuture=" + reaperFuture + //
+                ",\n\tinAuth=" + inAuth + //
+                ",\n\tstatusReceived=" + statusReceived + //
+                ",\n\ttouch=" + touch + //
                 '}';
     }
 
