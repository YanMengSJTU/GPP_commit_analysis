diff --git a/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java b/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
index 3900ab85d..7ace29cdd 100644
--- a/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
+++ b/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
@@ -83,6 +83,28 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
 
         this.derived = ahc != null;
     }
+    
+    public Future<Response> post(Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        
+        for ( Part part : parts ) {
+            r.addBodyPart( part );
+        }
+        
+        return execute(r, null, null);
+    }
+    
+    public Future<Response> post(BodyConsumer consumer, Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        
+        for ( Part part : parts ) {
+            r.addBodyPart( part );
+        }
+        
+        return execute(r, consumer, null);
+    }
 
     public Future<Response> post(BodyGenerator bodyGenerator) throws IOException {
         RequestBuilder r = rebuildRequest(requestBuilder.build());
@@ -111,7 +133,28 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
         r.setBody(bodyGenerator);
         return execute(r, bodyConsumer, throwableHandler);
     }
-
+    
+    public Future<Response> put(Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        
+        for ( Part part : parts ) {
+            r.addBodyPart( part );
+        }
+        
+        return execute(r, null, null);
+    }
+    
+    public Future<Response> put(BodyConsumer consumer, Part... parts) throws IOException {
+        RequestBuilder r = rebuildRequest(requestBuilder.build());
+        r.setMethod("POST");
+        
+        for ( Part part : parts ) {
+            r.addBodyPart( part );
+        }
+        
+        return execute(r, consumer, null);
+    }
     public Future<Response> put(BodyGenerator bodyGenerator, BodyConsumer bodyConsumer) throws IOException {
         RequestBuilder r = rebuildRequest(requestBuilder.build());
         r.setMethod("PUT");
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index 07772e955..7ad86d64f 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -47,6 +47,7 @@
 import com.ning.http.multipart.MultipartRequestEntity;
 import com.ning.http.util.AsyncHttpProviderUtils;
 import com.ning.http.util.AuthenticatorUtils;
+import com.ning.http.util.CleanupChannelGroup;
 import com.ning.http.util.ProxyUtils;
 import com.ning.http.util.SslUtils;
 import com.ning.http.util.UTF8UrlEncoder;
@@ -144,13 +145,14 @@
 
     private final ClientSocketChannelFactory socketChannelFactory;
 
-    private final ChannelGroup openChannels = new DefaultChannelGroup("asyncHttpClient") {
-        @Override
-        public boolean remove(Object o) {
-            maxConnections.decrementAndGet();
-            return super.remove(o);
-        }
-    };
+    private final ChannelGroup openChannels = new
+            CleanupChannelGroup("asyncHttpClient") {
+                @Override
+                public boolean remove(Object o) {
+                    maxConnections.decrementAndGet();
+                    return super.remove(o);
+                }
+            };
 
     private final ConnectionsPool<String, Channel> connectionsPool;
 
@@ -699,7 +701,6 @@ public void close() {
                 }
             }
 
-            openChannels.close();
             config.executorService().shutdown();
             config.reaper().shutdown();
             socketChannelFactory.releaseExternalResources();
diff --git a/src/main/java/com/ning/http/util/CleanupChannelGroup.java b/src/main/java/com/ning/http/util/CleanupChannelGroup.java
new file mode 100644
index 000000000..23ecc2f30
--- /dev/null
+++ b/src/main/java/com/ning/http/util/CleanupChannelGroup.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2010-2011 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * Copyright 2010 Bruno de Carvalho
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.ning.http.util;
+
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.group.ChannelGroupFuture;
+import org.jboss.netty.channel.group.DefaultChannelGroup;
+import org.jboss.netty.channel.group.DefaultChannelGroupFuture;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
+ * supposed to be called once.
+ *
+ * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
+ */
+public class CleanupChannelGroup extends DefaultChannelGroup {
+
+    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
+
+    // internal vars --------------------------------------------------------------------------------------------------
+
+    private final AtomicBoolean closed;
+    private final ReentrantReadWriteLock lock;
+
+    // constructors ---------------------------------------------------------------------------------------------------
+
+    public CleanupChannelGroup() {
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    public CleanupChannelGroup(String name) {
+        super(name);
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    // DefaultChannelGroup --------------------------------------------------------------------------------------------
+
+    @Override
+    public ChannelGroupFuture close() {
+        this.lock.writeLock().lock();
+        try {
+            if (!this.closed.getAndSet(true)) {
+                // First time close() is called.
+                return super.close();
+            } else {
+                Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
+                logger.debug("CleanupChannelGroup Already closed");
+                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public boolean add(Channel channel) {
+        // Synchronization must occur to avoid add() and close() overlap (thus potentially leaving one channel open).
+        // This could also be done by synchronizing the method itself but using a read lock here (rather than a
+        // synchronized() block) allows multiple concurrent calls to add().
+        this.lock.readLock().lock();
+        try {
+            if (this.closed.get()) {
+                // Immediately close channel, as close() was already called.
+                channel.close();
+                return false;
+            }
+
+            return super.add(channel);
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+}
diff --git a/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java b/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
index ec9d071a5..e3521e36e 100644
--- a/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
+++ b/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
@@ -1,17 +1,14 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2010-2011 Sonatype, Inc. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package com.ning.http.client.async;
 
diff --git a/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java b/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java
new file mode 100644
index 000000000..89522d7bd
--- /dev/null
+++ b/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (c) 2010-2011 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.async;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.providers.netty.NettyAsyncHttpProviderConfig;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+
+import static org.testng.Assert.assertTrue;
+
+
+public class RetryNonBlockingIssue {
+
+    private URI servletEndpointUri;
+
+    private Server server;
+
+    private int port1;
+
+    public static int findFreePort() throws IOException {
+        ServerSocket socket = null;
+
+        try {
+            // 0 is open a socket on any free port
+            socket = new ServerSocket(0);
+            return socket.getLocalPort();
+        } finally {
+            if (socket != null) {
+                socket.close();
+            }
+        }
+    }
+
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        server = new Server();
+
+        port1 = findFreePort();
+
+        Connector listener = new SelectChannelConnector();
+        listener.setHost("127.0.0.1");
+        listener.setPort(port1);
+
+        server.addConnector(listener);
+
+
+        ServletContextHandler context = new
+                ServletContextHandler(ServletContextHandler.SESSIONS);
+
+        context.setContextPath("/");
+        server.setHandler(context);
+        context.addServlet(new ServletHolder(new
+                MockExceptionServlet()), "/*");
+
+        server.start();
+
+        servletEndpointUri = new URI("http://127.0.0.1:" + port1 + "/");
+    }
+
+    @AfterMethod
+    public void stop() {
+
+        try {
+            if (server != null) server.stop();
+        } catch (Exception e) {
+        }
+
+
+    }
+
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient
+            fetcher, int requests,String action, String id) throws IOException {
+        RequestBuilder builder = new RequestBuilder("GET");
+        builder.addQueryParameter(action, "1");
+
+        builder.addQueryParameter("maxRequests", "" + requests);
+        builder.addQueryParameter("id", id);
+        builder.setUrl(servletEndpointUri.toString());
+        com.ning.http.client.Request r = builder.build();
+        return fetcher.executeRequest(r);
+
+    }
+
+    /**
+     * Tests that a head request can be made
+     *
+     * @throws IOException
+     * @throws ExecutionException
+     * @throws InterruptedException
+     */
+    @Test
+    public void testRetryNonBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(30000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            res.add(testMethodRequest(c,
+                    3, "servlet", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "io", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c,
+                    3, "normal", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "500", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "500", UUID.randomUUID().toString()));
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @Test
+    public void testRetryBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(30000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+            
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            res.add(testMethodRequest(c,
+                    3, "servlet", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "io", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c,
+                    3, "normal", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "500", UUID.randomUUID().toString()));
+            res.add(testMethodRequest(c, 3, "500", UUID.randomUUID().toString()));
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    public class MockExceptionServlet extends HttpServlet {
+
+        private Map<String, Integer> requests = new
+                ConcurrentHashMap<String, Integer>();
+
+        private synchronized int increment(String id) {
+            int val = 0;
+            if (requests.containsKey(id)) {
+                Integer i = requests.get(id);
+                val = i + 1;
+                requests.put(id, val);
+            } else {
+                requests.put(id, 1);
+                val = 1;
+            }
+            System.out.println("REQUESTS: " + requests);
+            return val;
+        }
+
+        public void service(HttpServletRequest req, HttpServletResponse res)
+                throws ServletException, IOException {
+            String maxRequests = req.getParameter("maxRequests");
+            int max = 0;
+            try {
+                max = Integer.parseInt(maxRequests);
+            }
+            catch (NumberFormatException e) {
+                max = 3;
+            }
+            String id = req.getParameter("id");
+            int requestNo = increment(id);
+            String servlet = req.getParameter("servlet");
+            String io = req.getParameter("io");
+            String error = req.getParameter("500");
+
+
+            if (requestNo >= max) {
+                res.setHeader("Success-On-Attempt", "" + requestNo);
+                res.setHeader("id", id);
+                if (servlet != null && servlet.trim().length() > 0)
+                    res.setHeader("type", "servlet");
+                if (error != null && error.trim().length() > 0)
+                    res.setHeader("type", "500");
+                if (io != null && io.trim().length() > 0)
+                    res.setHeader("type", "io");
+                res.setStatus(200);
+                res.setContentLength(0);
+                return;
+            }
+
+
+            res.setStatus(200);
+            res.setContentLength(100);
+            res.setContentType("application/octet-stream");
+
+            res.flushBuffer();
+
+            if (servlet != null && servlet.trim().length() > 0)
+                throw new ServletException("Servlet Exception");
+
+            if (io != null && io.trim().length() > 0)
+                throw new IOException("IO Exception");
+
+            if (error != null && error.trim().length() > 0)
+                res.sendError(500, "servlet process was 500");
+        }
+
+    }
+}
+
diff --git a/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java b/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
index 266bf1d7f..7eaa5ea2a 100644
--- a/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
+++ b/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
@@ -27,6 +27,7 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.ByteArrayPart;
 import com.ning.http.client.Response;
 import com.ning.http.client.SimpleAsyncHttpClient;
 import com.ning.http.client.consumers.AppendableBodyConsumer;
@@ -219,13 +220,13 @@ public void testNullUrl() throws Exception {
     public void testCloseDerivedValidMaster() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
-    
+
         derived.get().get();
-    
+
         derived.close();
-    
+
         Response response = client.get().get();
-    
+
         assertEquals(response.getStatusCode(), 200);
     }
 
@@ -233,9 +234,9 @@ public void testCloseDerivedValidMaster() throws Exception {
     public void testCloseMasterInvalidDerived() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
-    
+
         client.close();
-    
+
         try {
             derived.get().get();
             fail("Expected closed AHC");
@@ -244,4 +245,48 @@ public void testCloseMasterInvalidDerived() throws Exception {
         }
     }
 
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultiPartPut() throws Exception {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
+        
+        Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+        
+        String body = response.getResponseBody();
+        String contentType = response.getHeader("X-Content-Type");
+        
+        assertTrue(contentType.contains("multipart/form-data"));
+        
+        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+        
+        assertTrue(body.startsWith("--" + boundary));
+        assertTrue(body.trim().endsWith("--" + boundary + "--"));
+        assertTrue(body.contains("Content-Disposition:"));
+        assertTrue(body.contains("Content-Type: application/test"));
+        assertTrue(body.contains("name=\"baPart"));
+        assertTrue(body.contains("filename=\"fileName"));
+        
+    }
+    
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultiPartPost() throws Exception {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
+        
+        Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+        
+        String body = response.getResponseBody();
+        String contentType = response.getHeader("X-Content-Type");
+        
+        assertTrue(contentType.contains("multipart/form-data"));
+        
+        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+        
+        assertTrue(body.startsWith("--" + boundary));
+        assertTrue(body.trim().endsWith("--" + boundary + "--"));
+        assertTrue(body.contains("Content-Disposition:"));
+        assertTrue(body.contains("Content-Type: application/test"));
+        assertTrue(body.contains("name=\"baPart"));
+        assertTrue(body.contains("filename=\"fileName"));
+        
+    }
+
 }
