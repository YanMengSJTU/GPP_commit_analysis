diff --git a/pom.xml b/pom.xml
index e57b11013..1879030f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.sonatype.oss</groupId>
         <artifactId>oss-parent</artifactId>
@@ -66,6 +67,14 @@
                     <groupId>commons-logging</groupId>
                     <artifactId>commons-logging</artifactId>
                 </exclusion>
+                <exclusion>
+                    <groupId>org.slf4j</groupId>
+                    <artifactId>slf4j-api</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>log4j</groupId>
+                    <artifactId>log4j</artifactId>
+                </exclusion>
             </exclusions>
         </dependency>
 
@@ -74,14 +83,14 @@
             <artifactId>slf4j-api</artifactId>
             <version>1.6.1</version>
         </dependency>
-        
+
         <!-- Test dependencies -->
-         <dependency>
+        <dependency>
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
             <version>0.9.26</version>
             <scope>test</scope>
-        </dependency>       
+        </dependency>
         <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
@@ -159,14 +168,14 @@
         </dependency>
     </dependencies>
     <build>
-      <extensions>
-        <!-- Enabling the use of SSH -->
-        <extension>
-          <groupId>org.apache.maven.wagon</groupId>
-          <artifactId>wagon-ssh-external</artifactId>
-          <version>1.0-beta-6</version>
-        </extension>
-      </extensions>
+        <extensions>
+            <!-- Enabling the use of SSH -->
+            <extension>
+                <groupId>org.apache.maven.wagon</groupId>
+                <artifactId>wagon-ssh-external</artifactId>
+                <version>1.0-beta-6</version>
+            </extension>
+        </extensions>
         <defaultGoal>install</defaultGoal>
         <plugins>
             <plugin>
@@ -198,7 +207,8 @@
                 <configuration>
                     <manifestLocation>META-INF</manifestLocation>
                     <instructions>
-                        <Bundle-Version>$(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))</Bundle-Version>
+                        <Bundle-Version>$(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))
+                        </Bundle-Version>
                         <Bundle-Vendor>Sonatype</Bundle-Vendor>
                         <Import-Package>
                             org.jboss.netty.*;resolution:=optional,
@@ -326,25 +336,50 @@
                         <configuration>
                             <shadedArtifactAttached>true</shadedArtifactAttached>
                             <shadedClassifierName>shaded</shadedClassifierName>
-                            <artifactSet>                  
+                            <artifactSet>
                                 <excludes>
-                                    <exclude>commons-codec:commons-codec</exclude>                                                                                                            
-                                    <exclude>commons-lang:commons-lang</exclude>                                                                        
-                                    <exclude>commons-logging:commons-logging</exclude>                                    
+                                    <exclude>commons-codec:commons-codec</exclude>
+                                    <exclude>commons-lang:commons-lang</exclude>
+                                    <exclude>commons-logging:commons-logging</exclude>
                                     <exclude>junit:junit</exclude>
                                     <exclude>log4j:log4j</exclude>
                                     <exclude>commons-httpclient:commons-httpclient</exclude>
                                 </excludes>
                             </artifactSet>
                             <transformers>
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" />
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer" />
-                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer" />
+                                <transformer
+                                        implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
+                                <transformer
+                                        implementation="org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer"/>
+                                <transformer
+                                        implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"/>
                             </transformers>
                         </configuration>
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>clirr-maven-plugin</artifactId>
+                <version>2.3</version>
+                <configuration>
+                    <excludes>
+                        <exclude>**/AsyncHandler$STATE</exclude>
+                        <exclude>**/ProxyServer$Protocol</exclude>
+                        <exclude>**/Realm$AuthScheme</exclude>
+                        <exclude>**/SimpleAsyncHttpClient$ErrorDocumentBehaviour</exclude>
+                    </excludes>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>check-api-compat</id>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>check-no-fork</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
         </plugins>
     </build>
     <profiles>
diff --git a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
index 07534d406..7d3b8df26 100644
--- a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
@@ -99,6 +99,8 @@
 
     private Authenticator jdkAuthenticator;
 
+    private boolean bufferResponseInMemory = false;
+
     public JDKAsyncHttpProvider(AsyncHttpClientConfig config) {
 
         this.config = config;
@@ -112,6 +114,10 @@ private void configure(JDKAsyncHttpProviderConfig config) {
         for(Map.Entry<String,String> e: config.propertiesSet()) {
             System.setProperty(e.getKey(), e.getValue());
         }
+
+        if (config.getProperty(JDKAsyncHttpProviderConfig.FORCE_RESPONSE_BUFFERING) != null) {
+            bufferResponseInMemory = true;
+        }
     }
     public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException {
         return execute(request, handler, null);
@@ -317,7 +323,7 @@ public T call() throws Exception {
 
                     int byteToRead = urlConnection.getContentLength();
                     InputStream stream = is;
-                    /* if (byteToRead <= 0) */ {  // content-length is not always defined properly by servers
+                    if (bufferResponseInMemory || byteToRead <= 0) {
                         int[] lengthWrapper = new int[1];
                         byte[] bytes = AsyncHttpProviderUtils.readFully(is, lengthWrapper);
                         stream = new ByteArrayInputStream(bytes, 0, lengthWrapper[0]);
diff --git a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java
index 6670ce64e..4801fded5 100644
--- a/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java
+++ b/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java
@@ -20,8 +20,9 @@
 
 public class JDKAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String,String> {
 
-    private final ConcurrentHashMap<String, String> properties = new ConcurrentHashMap<String, String>();
+    public static final String FORCE_RESPONSE_BUFFERING = "bufferResponseInMemory";
 
+    private final ConcurrentHashMap<String, String> properties = new ConcurrentHashMap<String, String>();
 
     public AsyncHttpProviderConfig addProperty(String name, String value) {
         properties.put(name, value);
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index c84632714..ad36bdb82 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -147,9 +147,8 @@
             CleanupChannelGroup("asyncHttpClient") {
                 @Override
                 public boolean remove(Object o) {
-                    boolean removed = super.remove(o);  // LQ
+                    boolean removed = super.remove(o);
                     if( removed ) {
-                        // decrement maxConnections only if the channel has been removed.
                         maxConnections.decrementAndGet();
                     }
                     return removed;
@@ -206,7 +205,7 @@ public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
         trackConnections = (config.getMaxTotalConnections() != -1);
     }
 
-    // LQ
+    @Override
     public String toString() {
         return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",
                 maxConnections.get(),
@@ -497,7 +496,7 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                 nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
             }
         } else {
-            log.warn("Host for Uri {} was null", uri.getHost());
+            host = "127.0.0.1";
         }
 
         if (!m.equals(HttpMethod.CONNECT)) {
@@ -790,7 +789,7 @@ public Response prepareResponse(final HttpResponseStatus status,
             try {
                 asyncHandler.onThrowable(ex);   
             } catch (Throwable t) {
-                log.warn("asyncHandler.onThrowable",t);
+                log.warn("!connectionsPool.canCacheConnection()",t);
             }
             throw ex;
         }
@@ -869,9 +868,6 @@ protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConf
     }
 
     private void closeChannel(final ChannelHandlerContext ctx) {
-        if (trackConnections && openChannels.contains(ctx.getChannel())) {
-            maxConnections.decrementAndGet();
-        }
         connectionsPool.removeAll(ctx.getChannel());
         finishChannel(ctx);
     }
@@ -907,8 +903,13 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
         if (ctx.getAttachment() instanceof DiscardEvent) {
             return;
         } else if (ctx.getAttachment() instanceof AsyncCallable) {
-            HttpChunk chunk = (HttpChunk) e.getMessage();
-            if (chunk.isLast()) {
+            if (e.getMessage() instanceof HttpChunk) {
+                HttpChunk chunk = (HttpChunk) e.getMessage();
+                if (chunk.isLast()) {
+                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+                    ac.call();
+                }
+            } else {
                 AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
                 ac.call();
             }
@@ -1047,12 +1048,18 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
                     final Realm nr = newRealm;
 
                     log.debug("Sending authentication to {}", request.getUrl());
-
-                    if (future.getKeepAlive()) {
-                        future.attachChannel(ctx.getChannel(), true);
+                    AsyncCallable ac = new AsyncCallable(future) {
+                        public Object call() throws Exception {
+                            nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
+                            return null;
+                        }
+                    };
+                    if (future.getKeepAlive() && response.isChunked()) {
+                        // We must make sure there is no bytes left before executing the next request.                        
+                        ctx.setAttachment(ac);
+                    } else {
+                        ac.call();
                     }
-
-                    nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
                     return;
                 }
 
@@ -1085,13 +1092,12 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
                         future.attachChannel(ctx.getChannel(), true);
                     }
 
-                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
+                    final RequestBuilder builder = new RequestBuilder(future.getRequest());                    
                     try {
                         upgradeProtocol(ctx.getChannel().getPipeline(), request.getUrl(), proxyServer);
                     } catch (Throwable ex) {
                         abort(future, ex);
                     }
-
                     nextRequest(builder.build(), future);
                     return;
                 }
@@ -1109,18 +1115,26 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
                         if (!uri.toString().equalsIgnoreCase(future.getURI().toString())) {
                             final RequestBuilder builder = new RequestBuilder(future.getRequest());
                             final URI initialConnectionUri = future.getURI();
+                            final boolean initialConnectionKeepAlive = future.getKeepAlive();
                             future.setURI(uri);
                             final String newUrl = uri.toString();
 
                             log.debug("Redirecting to {}", newUrl);
 
+                            AsyncCallable ac = new AsyncCallable(future) {
+                                public Object call() throws Exception {
+                                    drainChannel(ctx, future, initialConnectionKeepAlive, initialConnectionUri);
+                                    nextRequest(builder.setUrl(newUrl).build(), future);
+                                    return null;
+                                }
+                            };
+
                             if (response.isChunked()) {
-                                drainChannel(ctx, future, initialConnectionUri);
+                                // We must make sure there is no bytes left before executing the next request.
+                                ctx.setAttachment(ac);
                             } else {
-                                closeChannel(ctx);
+                                ac.call();
                             }
-
-                            nextRequest(builder.setUrl(newUrl).build(), future);
                             return;
                         }
                     } else {
@@ -1146,7 +1160,7 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
                 if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
                     updateBodyAndInterrupt(handler, new ResponseBodyPart(future.getURI(), response, this));
                     markAsDoneAndCacheConnection(future, ctx);
-                    drainChannel(ctx, future, future.getURI());
+                    drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
                     return;
                 }
 
@@ -1184,10 +1198,10 @@ public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) thr
         }
     }
 
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final URI uri){
+    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final boolean keepAlive, final URI uri){
         ctx.setAttachment(new AsyncCallable(future) {
             public Object call() throws Exception {
-                if (future.getKeepAlive() && ctx.getChannel().isReadable()) {
+                if (keepAlive && ctx.getChannel().isReadable()) {
                     if (!connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(uri), ctx.getChannel())) {
                         finishChannel(ctx);
                     }
@@ -1220,7 +1234,7 @@ private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc
         future.touch();
 
         log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future, future.getURI());
+        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
         nextRequest(newRequest, future);
         return;
     }
@@ -1375,9 +1389,9 @@ private void markAsDoneAndCacheConnection(final NettyResponseFuture<?> future, f
 
     private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean isChunked) throws IOException {
         if (isChunked && future.getKeepAlive()) {
-            drainChannel(ctx, future, future.getURI());
+            drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
         } else {
-             if (future.getKeepAlive() && ctx.getChannel().isReadable()) {
+            if (future.getKeepAlive() && ctx.getChannel().isReadable()) {
                 if (!connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(future.getURI()), ctx.getChannel())) {
                     finishChannel(ctx);
                 }
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java b/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
index 3a27fcf32..8ec40aa3a 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
@@ -54,6 +54,10 @@ public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
      * {@inheritDoc}
      */
     public boolean offer(String uri, Channel channel) {
+        if (isClosed.get()) {
+            return false;
+        }
+
         if (!provider.getConfig().isSslConnectionPoolEnabled() && uri.startsWith("https") ) {
             return false;
         }
@@ -73,10 +77,14 @@ public boolean offer(String uri, Channel channel) {
         if (config.getMaxConnectionPerHost() == -1 || size < config.getMaxConnectionPerHost()) {
             added = pooledConnectionForHost.add(channel);
             if (added) {
-                Timeout t = timer.newTimeout(new IdleRunner(channel, pooledConnectionForHost),
-                        config.getIdleConnectionInPoolTimeoutInMs(), TimeUnit.MILLISECONDS);
-                trackedIdleConnections.put(channel, t);
-                log.debug("ConnectionsPool increment totalConnections {}", trackedIdleConnections.size());
+                try {
+                    Timeout t = timer.newTimeout(new IdleRunner(channel, pooledConnectionForHost),
+                            config.getIdleConnectionInPoolTimeoutInMs(), TimeUnit.MILLISECONDS);
+                    trackedIdleConnections.put(channel, t);
+                    log.debug("ConnectionsPool increment totalConnections {}", trackedIdleConnections.size());
+                } catch (IllegalStateException e) {
+                    log.trace("HashedWheelTimer", e);   
+                }
             }
         } else {
             log.debug("Maximum number of requests per host reached {} for {}", config.getMaxConnectionPerHost(), uri);
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
index 72d6d15bb..76be3cdee 100755
--- a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
@@ -81,6 +81,7 @@
     private final int maxRetry;
     private boolean writeHeaders;
     private boolean writeBody;
+    private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
 
     public NettyResponseFuture(URI uri,
                                Request request,
@@ -146,10 +147,12 @@ public boolean cancel(boolean force) {
         } catch (Throwable t) {
             // Ignore
         }
-        try {
-            asyncHandler.onThrowable(new CancellationException());
-        } catch (Throwable t) {
-            logger.warn("cancel", t);
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(new CancellationException());
+            } catch (Throwable t) {
+                logger.warn("cancel", t);
+            }
         }
         if (reaperFuture != null) reaperFuture.cancel(true);
         latch.countDown();
@@ -197,12 +200,14 @@ public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException,
             if (expired) {
                 isCancelled.set(true);
                 TimeoutException te = new TimeoutException(String.format("No response received after %s", l));
-                try {
-                    asyncHandler.onThrowable(te);
-                } catch (Throwable t) {
-                    logger.debug("asyncHandler.onThrowable", t);
-                } finally {
-                    throw te;
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(te);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        throw te;
+                    }
                 }
             }
             isDone.set(true);
@@ -228,12 +233,14 @@ V getContent() throws ExecutionException {
             try {
                 update = asyncHandler.onCompleted();
             } catch (Throwable ex) {
-                try {
-                    asyncHandler.onThrowable(ex);
-                } catch (Throwable t) {
-                    logger.debug("asyncHandler.onThrowable", t);
-                } finally {
-                    throw new RuntimeException(ex);
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        throw new RuntimeException(ex);
+                    }
                 }
             }
             content.compareAndSet(null, update);
@@ -272,13 +279,15 @@ public final void abort(final Throwable t) {
         if (isDone.get() || isCancelled.get()) return;
 
         exEx.compareAndSet(null, new ExecutionException(t));
-        try {
-            asyncHandler.onThrowable(t);
-        } catch (Throwable te) {
-            logger.debug("asyncHandler.onThrowable", te);
-        } finally {
-            isCancelled.set(true);
-            latch.countDown();
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                logger.debug("asyncHandler.onThrowable", te);
+            } finally {
+                isCancelled.set(true);
+                latch.countDown();
+            }
         }
     }
 
diff --git a/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java b/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
index eaaaf40d3..cb39b928f 100644
--- a/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
+++ b/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
@@ -433,11 +433,10 @@ public static Cookie parseCookie(String value) {
             }
         }
 
-        // Normalization of maxAge (LQ)
-        if( maxAge < -1 ) {
+        if (maxAge < -1) {
             maxAge = -1;
         }
-        
+
         return new Cookie(domain, cookieName, cookieValue, path, maxAge, secure);
     }
 
diff --git a/src/main/java/com/ning/http/util/UTF8UrlEncoder.java b/src/main/java/com/ning/http/util/UTF8UrlEncoder.java
index e06d9ee08..a7d463f4f 100644
--- a/src/main/java/com/ning/http/util/UTF8UrlEncoder.java
+++ b/src/main/java/com/ning/http/util/UTF8UrlEncoder.java
@@ -19,13 +19,15 @@
  * Convenience class that encapsulates details of "percent encoding"
  * (as per RFC-3986, see [http://www.ietf.org/rfc/rfc3986.txt]).
  */
-public class UTF8UrlEncoder
-{
+public class UTF8UrlEncoder {
+    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.com.ning.http.util.UTF8UrlEncoder.encodeSpaceUsingPlus") == null ? false : true;
+
     /**
      * Encoding table used for figuring out ascii characters that must be escaped
      * (all non-Ascii characers need to be encoded anyway)
      */
     private final static int[] SAFE_ASCII = new int[128];
+
     static {
         for (int i = 'a'; i <= 'z'; ++i) {
             SAFE_ASCII[i] = 1;
@@ -43,18 +45,17 @@
     }
 
     private final static char[] HEX = "0123456789ABCDEF".toCharArray();
-    
-    private UTF8UrlEncoder() { }
 
-    public static String encode(String input) 
-    {
+    private UTF8UrlEncoder() {
+    }
+
+    public static String encode(String input) {
         StringBuilder sb = new StringBuilder(input.length() + 16);
         appendEncoded(sb, input);
         return sb.toString();
     }
-    
-    public static StringBuilder appendEncoded(StringBuilder sb, String input)
-    {
+
+    public static StringBuilder appendEncoded(StringBuilder sb, String input) {
         final int[] safe = SAFE_ASCII;
 
         for (int i = 0, len = input.length(); i < len; ++i) {
@@ -71,21 +72,20 @@ public static StringBuilder appendEncoded(StringBuilder sb, String input)
         }
         return sb;
     }
-    
-    private final static void appendSingleByteEncoded(StringBuilder sb, int value)
-    {
-        // The space char must be converted into a + (some servers doesn't support the %20 notation for space)  
-        if (value == 32) {
+
+    private final static void appendSingleByteEncoded(StringBuilder sb, int value) {
+
+        if (encodeSpaceUsingPlus && value == 32) {
             sb.append('+');
             return;
-        }     
+        }
+
         sb.append('%');
         sb.append(HEX[value >> 4]);
         sb.append(HEX[value & 0xF]);
     }
 
-    private final static void appendMultiByteEncoded(StringBuilder sb, int value)
-    {
+    private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
         // two or three bytes? (ignoring surrogate pairs for now, which would yield 4 bytes)
         if (value < 0x800) {
             appendSingleByteEncoded(sb, (0xc0 | (value >> 6)));
