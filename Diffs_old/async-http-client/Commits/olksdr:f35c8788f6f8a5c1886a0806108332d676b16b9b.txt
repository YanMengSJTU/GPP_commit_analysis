diff --git a/README.md b/README.md
index 640a41e10..047711c22 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ Async Http Client library purpose is to allow Java applications to easily execut
 <dependency>
   <groupId>com.ning</groupId>
   <artifactId>async-http-client</artifactId>
-  <version>1.7.8</version>
+  <version>1.7.16</version>
 </dependency>
 ```
 
@@ -29,7 +29,7 @@ Future<Response> f = asyncHttpClient.prepareGet("http://www.ning.com/").execute(
 Response r = f.get();
 ```
 
-Note that in this case all the content must be read fully in memory, even if you used `getResponseBodyAsStream()' method on returned `Response` object.
+Note that in this case all the content must be read fully in memory, even if you used `getResponseBodyAsStream()` method on returned `Response` object.
 
 You can also accomplish asynchronous (non-blocking) operation without using a Future if you want to receive and process the response in your handler:
 
@@ -180,3 +180,5 @@ Keep up to date on the library development by joining the Asynchronous HTTP Clie
 [Google Group](http://groups.google.com/group/asynchttpclient)
 
 or follow us on [Twitter](http://twitter.com/jfarcand)
+
+[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/6433679063b2351599c6ca44a08246a2 "githalytics.com")](http://githalytics.com/AsyncHttpClient/async-http-client)
diff --git a/api/pom.xml b/api/pom.xml
index 5890a3e22..78a6cba8d 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -2,16 +2,13 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
-        <groupId>com.ning</groupId>
+        <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
+        <version>2.0.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
     <artifactId>async-http-client-api</artifactId>
     <name>Asynchronous Http Client API</name>
-    <version>1.8.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
     <description>
         The Async Http Client (AHC) API classes.
     </description>
@@ -37,7 +34,7 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.6.2</version>
+            <version>1.7.5</version>
         </dependency>
     </dependencies>
 
diff --git a/api/src/main/java/com/ning/http/client/Cookie.java b/api/src/main/java/com/ning/http/client/Cookie.java
deleted file mode 100644
index 26fd46920..000000000
--- a/api/src/main/java/com/ning/http/client/Cookie.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package com.ning.http.client;
-
-import java.util.Collections;
-import java.util.Set;
-import java.util.TreeSet;
-
-public class Cookie {
-    private final String domain;
-    private final String name;
-    private final String value;
-    private final String path;
-    private final int maxAge;
-    private final boolean secure;
-    private final int version;
-    private Set<Integer> ports = Collections.emptySet();
-    private Set<Integer> unmodifiablePorts = ports;
-
-    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure) {
-        this.domain = domain;
-        this.name = name;
-        this.value = value;
-        this.path = path;
-        this.maxAge = maxAge;
-        this.secure = secure;
-        this.version = 1;
-    }
-
-    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure, int version) {
-        this.domain = domain;
-        this.name = name;
-        this.value = value;
-        this.path = path;
-        this.maxAge = maxAge;
-        this.secure = secure;
-        this.version = version;
-    }
-
-    public String getDomain() {
-        return domain;
-    }
-
-    public String getName() {
-        return name == null ? "" : name;
-    }
-
-    public String getValue() {
-        return value == null ? "" : value;
-    }
-
-    public String getPath() {
-        return path;
-    }
-
-    public int getMaxAge() {
-        return maxAge;
-    }
-
-    public boolean isSecure() {
-        return secure;
-    }
-
-    public int getVersion() {
-        return version;
-    }
-
-    public Set<Integer> getPorts() {
-        if (unmodifiablePorts == null) {
-            unmodifiablePorts = Collections.unmodifiableSet(ports);
-        }
-        return unmodifiablePorts;
-    }
-
-    public void setPorts(int... ports) {
-        if (ports == null) {
-            throw new NullPointerException("ports");
-        }
-
-        int[] portsCopy = ports.clone();
-        if (portsCopy.length == 0) {
-            unmodifiablePorts = this.ports = Collections.emptySet();
-        } else {
-            Set<Integer> newPorts = new TreeSet<Integer>();
-            for (int p : portsCopy) {
-                if (p <= 0 || p > 65535) {
-                    throw new IllegalArgumentException("port out of range: " + p);
-                }
-                newPorts.add(Integer.valueOf(p));
-            }
-            this.ports = newPorts;
-            unmodifiablePorts = null;
-        }
-    }
-
-    public void setPorts(Iterable<Integer> ports) {
-        Set<Integer> newPorts = new TreeSet<Integer>();
-        for (int p : ports) {
-            if (p <= 0 || p > 65535) {
-                throw new IllegalArgumentException("port out of range: " + p);
-            }
-            newPorts.add(Integer.valueOf(p));
-        }
-        if (newPorts.isEmpty()) {
-            unmodifiablePorts = this.ports = Collections.emptySet();
-        } else {
-            this.ports = newPorts;
-            unmodifiablePorts = null;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return String.format("Cookie: domain=%s, name=%s, value=%s, path=%s, maxAge=%d, secure=%s",
-                domain, name, value, path, maxAge, secure);
-    }
-}
diff --git a/api/src/main/java/com/ning/http/client/PerRequestConfig.java b/api/src/main/java/com/ning/http/client/PerRequestConfig.java
deleted file mode 100644
index 9f0d84395..000000000
--- a/api/src/main/java/com/ning/http/client/PerRequestConfig.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client;
-
-/**
- * Per request configuration.
- *
- * @author Hubert Iwaniuk
- * @deprecated Per request properties are set on request directly or via builder. This class will be gone in next major release.
- */
-public class PerRequestConfig {
-    private final ProxyServer proxyServer;
-    private int requestTimeoutInMs;
-
-    public PerRequestConfig() {
-        this(null, 0);
-    }
-
-    public PerRequestConfig(ProxyServer proxyServer, int requestTimeoutInMs) {
-        this.proxyServer = proxyServer;
-        this.requestTimeoutInMs = requestTimeoutInMs;
-    }
-
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-
-    public int getRequestTimeoutInMs() {
-        return requestTimeoutInMs;
-    }
-
-    public void setRequestTimeoutInMs(int requestTimeoutInMs) {
-        this.requestTimeoutInMs = requestTimeoutInMs;
-    }
-}
diff --git a/api/src/main/java/com/ning/http/client/extra/ThrottleRequestFilter.java b/api/src/main/java/com/ning/http/client/extra/ThrottleRequestFilter.java
deleted file mode 100644
index 49da8c157..000000000
--- a/api/src/main/java/com/ning/http/client/extra/ThrottleRequestFilter.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.extra;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.RequestFilter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A {@link com.ning.http.client.filter.RequestFilter} throttles requests and block when the number of permits is reached, waiting for
- * the response to arrives before executing the next request.
- */
-public class ThrottleRequestFilter implements RequestFilter {
-    private final static Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
-    @SuppressWarnings("unused")
-    private final int maxConnections;
-    private final Semaphore available;
-    private final int maxWait;
-
-    public ThrottleRequestFilter(int maxConnections) {
-        this.maxConnections = maxConnections;
-        this.maxWait = Integer.MAX_VALUE;
-        available = new Semaphore(maxConnections, true);
-    }
-
-    public ThrottleRequestFilter(int maxConnections, int maxWait) {
-        this.maxConnections = maxConnections;
-        this.maxWait = maxWait;
-        available = new Semaphore(maxConnections, true);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-
-        try {
-            if (logger.isDebugEnabled()) {
-                logger.debug("Current Throttling Status {}", available.availablePermits());
-            }
-            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
-                throw new FilterException(
-                        String.format("No slot available for processing Request %s with AsyncHandler %s",
-                                ctx.getRequest(), ctx.getAsyncHandler()));
-            }
-            ;
-        } catch (InterruptedException e) {
-            throw new FilterException(
-                    String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
-        }
-
-        return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler())).build();
-    }
-
-    private class AsyncHandlerWrapper<T> implements AsyncHandler<T> {
-
-        private final AsyncHandler<T> asyncHandler;
-
-        public AsyncHandlerWrapper(AsyncHandler<T> asyncHandler) {
-            this.asyncHandler = asyncHandler;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        /* @Override */
-        public void onThrowable(Throwable t) {
-            try {
-                asyncHandler.onThrowable(t);
-            } finally {
-                available.release();
-                if (logger.isDebugEnabled()) {
-                    logger.debug("Current Throttling Status after onThrowable {}", available.availablePermits());
-                }
-            }
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        /* @Override */
-        public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-            return asyncHandler.onBodyPartReceived(bodyPart);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        /* @Override */
-        public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-            return asyncHandler.onStatusReceived(responseStatus);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        /* @Override */
-        public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-            return asyncHandler.onHeadersReceived(headers);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        /* @Override */
-        public T onCompleted() throws Exception {
-            available.release();
-            if (logger.isDebugEnabled()) {
-                logger.debug("Current Throttling Status {}", available.availablePermits());
-            }
-            return asyncHandler.onCompleted();
-        }
-    }
-}
diff --git a/api/src/main/java/com/ning/http/client/websocket/DefaultWebSocketListener.java b/api/src/main/java/com/ning/http/client/websocket/DefaultWebSocketListener.java
deleted file mode 100644
index 4db626b0d..000000000
--- a/api/src/main/java/com/ning/http/client/websocket/DefaultWebSocketListener.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
- *
- * Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
- *
- * The contents of this file are subject to the terms of either the GNU
- * General Public License Version 2 only ("GPL") or the Common Development
- * and Distribution License("CDDL") (collectively, the "License").  You
- * may not use this file except in compliance with the License.  You can
- * obtain a copy of the License at
- * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
- * or packager/legal/LICENSE.txt.  See the License for the specific
- * language governing permissions and limitations under the License.
- *
- * When distributing the software, include this License Header Notice in each
- * file and include the License file at packager/legal/LICENSE.txt.
- *
- * GPL Classpath Exception:
- * Oracle designates this particular file as subject to the "Classpath"
- * exception as provided by Oracle in the GPL Version 2 section of the License
- * file that accompanied this code.
- *
- * Modifications:
- * If applicable, add the following below the License Header, with the fields
- * enclosed by brackets [] replaced by your own identifying information:
- * "Portions Copyright [year] [name of copyright owner]"
- *
- * Contributor(s):
- * If you wish your version of this file to be governed by only the CDDL or
- * only the GPL Version 2, indicate your decision by adding "[Contributor]
- * elects to include this software in this distribution under the [CDDL or GPL
- * Version 2] license."  If you don't indicate a single choice of license, a
- * recipient has the option to distribute your version of this file under
- * either the CDDL, the GPL Version 2 or to extend the choice of license to
- * its licensees as provided above.  However, if you add GPL Version 2 code
- * and therefore, elected the GPL Version 2 license, then the option applies
- * only if the new code is made subject to such option by the copyright
- * holder.
- */
-package com.ning.http.client.websocket;
-
-/**
- * Default WebSocketListener implementation.  Most methods are no-ops.  This 
- * allows for quick override customization without clutter of methods that the
- * developer isn't interested in dealing with.
- * 
- * @since 1.7.0
- */
-public class DefaultWebSocketListener implements  WebSocketByteListener, WebSocketTextListener, WebSocketPingListener, WebSocketPongListener {
-
-    protected WebSocket webSocket;
-    
-    // -------------------------------------- Methods from WebSocketByteListener
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onMessage(byte[] message) {
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onFragment(byte[] fragment, boolean last) {
-    }
-
-    
-    // -------------------------------------- Methods from WebSocketPingListener
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onPing(byte[] message) {
-    }
-
-    
-    // -------------------------------------- Methods from WebSocketPongListener
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onPong(byte[] message) {
-    }
-    
-    
-    // -------------------------------------- Methods from WebSocketTextListener
-
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onMessage(String message) {
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onFragment(String fragment, boolean last) {
-    }
-    
-    
-    // ------------------------------------------ Methods from WebSocketListener
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onOpen(WebSocket websocket) {
-        this.webSocket = websocket;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onClose(WebSocket websocket) {
-        this.webSocket = null;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onError(Throwable t) {
-    }
-}
diff --git a/api/src/main/java/com/ning/http/client/AsyncCompletionHandler.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
similarity index 88%
rename from api/src/main/java/com/ning/http/client/AsyncCompletionHandler.java
rename to api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index ebc171d07..b8e8d7088 100644
--- a/api/src/main/java/com/ning/http/client/AsyncCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -22,7 +22,7 @@
 /**
  * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)} convenience method which gets called
  * when the {@link Response} processing is finished.  This class also implement the {@link ProgressAsyncHandler} callback,
- * all doing nothing except returning {@link com.ning.http.client.AsyncHandler.STATE#CONTINUE}
+ * all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.STATE#CONTINUE}
  *
  * @param <T> Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
  */
@@ -86,7 +86,7 @@ public void onThrowable(Throwable t) {
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     public STATE onHeaderWriteCompleted() {
         return STATE.CONTINUE;
@@ -96,7 +96,7 @@ public STATE onHeaderWriteCompleted() {
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     public STATE onContentWriteCompleted() {
         return STATE.CONTINUE;
@@ -108,7 +108,7 @@ public STATE onContentWriteCompleted() {
      * @param amount  The amount of bytes to transfer.
      * @param current The amount of bytes transferred
      * @param total   The total number of bytes transferred
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     public STATE onContentWriteProgress(long amount, long current, long total) {
         return STATE.CONTINUE;
diff --git a/api/src/main/java/com/ning/http/client/AsyncCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/AsyncCompletionHandlerBase.java
rename to api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index 434d086e7..c98ee9450 100644
--- a/api/src/main/java/com/ning/http/client/AsyncCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/api/src/main/java/com/ning/http/client/AsyncHandler.java b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
similarity index 99%
rename from api/src/main/java/com/ning/http/client/AsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/AsyncHandler.java
index 02b62e170..3e6631a7a 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * An asynchronous handler or callback which gets invoked as soon as some data is available when
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/AsyncHttpClient.java
rename to api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index d4d4e3157..0966f12ba 100755
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -14,13 +14,13 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.Request.EntityWriter;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.RequestFilter;
-import com.ning.http.client.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.Request.EntityWriter;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.resumable.ResumableAsyncHandler;
 import java.io.Closeable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -42,7 +42,7 @@
  * </pre></blockquote
  * <p/>
  * The code above will block until the response is fully received. To execute asynchronous HTTP request, you
- * create an {@link AsyncHandler} or its abstract implementation, {@link com.ning.http.client.AsyncCompletionHandler}
+ * create an {@link AsyncHandler} or its abstract implementation, {@link AsyncCompletionHandler}
  * <p/>
  * <blockquote><pre>
  *       AsyncHttpClient c = new AsyncHttpClient();
@@ -75,7 +75,7 @@
  *      &#125;);
  *      Integer statusCode = f.get();
  * </pre></blockquote
- * The {@link AsyncCompletionHandler#onCompleted(com.ning.http.client.Response)} will be invoked once the http response has been fully read, which include
+ * The {@link AsyncCompletionHandler#onCompleted(Response)} will be invoked once the http response has been fully read, which include
  * the http headers and the response body. Note that the entire response will be buffered in memory.
  * <p/>
  * You can also have more control about the how the response is asynchronously processed by using a {@link AsyncHandler}
@@ -145,10 +145,9 @@
      * provider is explicitly specified by the developer.
      */
     private static final String[] DEFAULT_PROVIDERS = {
-        "com.ning.http.client.providers.netty.NettyAsyncHttpProvider",
-        "com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider",
-        "com.ning.http.client.providers.apache.ApacheAsyncHttpProvider",
-        "com.ning.http.client.providers.jdk.JDKAsyncHttpProvider"
+        "org.asynchttpclient.providers.netty.NettyAsyncHttpProvider",
+        "org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider",
+        "org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider"
     };
 
     private final AsyncHttpProvider httpProvider;
@@ -171,11 +170,11 @@
      * <ul>
      *     <li>netty</li>
      *     <li>grizzly</li>
-     *     <li>apache</li>
+     *     <li>JDK</li>
      * </ul>
      *
      * If none of those providers are found, then the runtime will default to
-     * the {@link com.ning.http.client.providers.jdk.JDKAsyncHttpProvider}.
+     * the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider}.
      */
     public AsyncHttpClient() {
         this(new AsyncHttpClientConfig.Builder().build());
@@ -200,11 +199,11 @@ public AsyncHttpClient(AsyncHttpProvider provider) {
      * <ul>
      *     <li>netty</li>
      *     <li>grizzly</li>
-     *     <li>apache</li>
+     *     <li>JDK</li>
      * </ul>
      *
      * If none of those providers are found, then the runtime will default to
-     * the {@link com.ning.http.client.providers.jdk.JDKAsyncHttpProvider}.
+     * the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider}.
      *
      * @param config a {@link AsyncHttpClientConfig}
      */
@@ -317,12 +316,12 @@ public BoundRequestBuilder setBody(byte[] data) throws IllegalArgumentException
         }
 
         @Override
-        public BoundRequestBuilder setBody(EntityWriter dataWriter, long length) throws IllegalArgumentException {
+        public BoundRequestBuilder setBody(Request.EntityWriter dataWriter, long length) throws IllegalArgumentException {
             return super.setBody(dataWriter, length);
         }
 
         @Override
-        public BoundRequestBuilder setBody(EntityWriter dataWriter) {
+        public BoundRequestBuilder setBody(Request.EntityWriter dataWriter) {
             return super.setBody(dataWriter);
         }
 
@@ -380,9 +379,9 @@ public BoundRequestBuilder setSignatureCalculator(SignatureCalculator signatureC
 
 
     /**
-     * Return the asynchronous {@link com.ning.http.client.AsyncHttpProvider}
+     * Return the asynchronous {@link AsyncHttpProvider}
      *
-     * @return an {@link com.ning.http.client.AsyncHttpProvider}
+     * @return an {@link AsyncHttpProvider}
      */
     @SuppressWarnings("UnusedDeclaration")
     public AsyncHttpProvider getProvider() {
@@ -433,9 +432,9 @@ public boolean isClosed() {
     }
 
     /**
-     * Return the {@link com.ning.http.client.AsyncHttpClientConfig}
+     * Return the {@link AsyncHttpClientConfig}
      *
-     * @return {@link com.ning.http.client.AsyncHttpClientConfig}
+     * @return {@link AsyncHttpClientConfig}
      */
     @SuppressWarnings("UnusedDeclaration")
     public AsyncHttpClientConfig getConfig() {
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
similarity index 73%
rename from api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
rename to api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 677b2c4aa..8e6cfa2d4 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -13,13 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.RequestFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.util.AllowAllHostnameVerifier;
-import com.ning.http.util.ProxyUtils;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.util.AllowAllHostnameVerifier;
+import org.asynchttpclient.util.ProxyUtils;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
@@ -35,22 +35,23 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this
  * object default behavior by doing:
  * <p/>
- * -Dcom.ning.http.client.AsyncHttpClientConfig.nameOfTheProperty
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.nameOfTheProperty
  * ex:
  * <p/>
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultMaxTotalConnections
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultMaxTotalConnections
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultMaxConnectionsPerHost
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultConnectionTimeoutInMS
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultIdleConnectionInPoolTimeoutInMS
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultRequestTimeoutInMS
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultRedirectsEnabled
- * -Dcom.ning.http.client.AsyncHttpClientConfig.defaultMaxRedirects
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxTotalConnections
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxTotalConnections
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxConnectionsPerHost
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultConnectionTimeoutInMS
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultIdleConnectionInPoolTimeoutInMS
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultRequestTimeoutInMS
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultRedirectsEnabled
+ * -Dorg.asynchttpclient.AsyncHttpClientConfig.defaultMaxRedirects
  */
 public class AsyncHttpClientConfig {
 
@@ -109,6 +110,12 @@
     protected int ioThreadMultiplier;
     protected boolean strict302Handling;
     protected int maxConnectionLifeTimeInMs;
+    protected boolean useRelativeURIsWithSSLProxies;
+    protected boolean spdyEnabled;
+    protected int spdyInitialWindowSize;
+    protected int spdyMaxConcurrentStreams;
+    protected boolean rfc6265CookieEncoding;
+    protected boolean asyncConnectMode;
 
     protected AsyncHttpClientConfig() {
     }
@@ -143,7 +150,13 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   boolean removeQueryParamOnRedirect,
                                   HostnameVerifier hostnameVerifier,
                                   int ioThreadMultiplier,
-                                  boolean strict302Handling) {
+                                  boolean strict302Handling,
+                                  boolean useRelativeURIsWithSSLProxies,
+                                  boolean spdyEnabled,
+                                  int spdyInitialWindowSize,
+                                  int spdyMaxConcurrentStreams,
+                                  boolean rfc6265CookieEncoding,
+                                  boolean asyncConnectMode) {
 
         this.maxTotalConnections = maxTotalConnections;
         this.maxConnectionPerHost = maxConnectionPerHost;
@@ -174,6 +187,7 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.hostnameVerifier = hostnameVerifier;
         this.ioThreadMultiplier = ioThreadMultiplier;
         this.strict302Handling = strict302Handling;
+        this.useRelativeURIsWithSSLProxies = useRelativeURIsWithSSLProxies;
 
         if (applicationThreadPool == null) {
             this.applicationThreadPool = Executors.newCachedThreadPool();
@@ -182,6 +196,11 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         }
         this.proxyServer = proxyServer;
         this.useRawUrl = useRawUrl;
+        this.spdyEnabled = spdyEnabled;
+        this.spdyInitialWindowSize = spdyInitialWindowSize;
+        this.spdyMaxConcurrentStreams = spdyMaxConcurrentStreams;
+        this.rfc6265CookieEncoding = rfc6265CookieEncoding;
+        this.asyncConnectMode = asyncConnectMode;
     }
 
     /**
@@ -194,54 +213,54 @@ public ScheduledExecutorService reaper() {
     }
 
     /**
-     * Return the maximum number of connections an {@link com.ning.http.client.AsyncHttpClient} can handle.
+     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections an {@link com.ning.http.client.AsyncHttpClient} can handle.
+     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
      */
     public int getMaxTotalConnections() {
         return maxTotalConnections;
     }
 
     /**
-     * Return the maximum number of connections per hosts an {@link com.ning.http.client.AsyncHttpClient} can handle.
+     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections per host an {@link com.ning.http.client.AsyncHttpClient} can handle.
+     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
      */
     public int getMaxConnectionPerHost() {
         return maxConnectionPerHost;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      *
-     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      */
     public int getConnectionTimeoutInMs() {
         return connectionTimeOutInMs;
     }
 
     /**
-     * Return the maximum time, in milliseconds, a {@link com.ning.http.client.websocket.WebSocket} may be idle before being timed out.
-     * @return the maximum time, in milliseconds, a {@link com.ning.http.client.websocket.WebSocket} may be idle before being timed out.
+     * Return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
+     * @return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
      */
     public int getWebSocketIdleTimeoutInMs() {
         return webSocketIdleTimeoutInMs;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      *
-     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      */
     public int getIdleConnectionTimeoutInMs() {
         return idleConnectionTimeoutInMs;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
      * in pool.
      *
-     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
      *         in pool.
      */
     public int getIdleConnectionInPoolTimeoutInMs() {
@@ -249,9 +268,9 @@ public int getIdleConnectionInPoolTimeoutInMs() {
     }
 
     /**
-     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
      *
-     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
      */
     public int getRequestTimeoutInMs() {
         return requestTimeoutInMs;
@@ -324,9 +343,9 @@ public ExecutorService executorService() {
     }
 
     /**
-     * An instance of {@link com.ning.http.client.ProxyServer} used by an {@link AsyncHttpClient}
+     * An instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
      *
-     * @return instance of {@link com.ning.http.client.ProxyServer}
+     * @return instance of {@link ProxyServer}
      */
     public ProxyServer getProxyServer() {
         return proxyServer;
@@ -373,9 +392,9 @@ public SSLEngine newSSLEngine() {
     }
 
     /**
-     * Return the {@link com.ning.http.client.AsyncHttpProviderConfig}
+     * Return the {@link AsyncHttpProviderConfig}
      *
-     * @return the {@link com.ning.http.client.AsyncHttpProviderConfig}
+     * @return the {@link AsyncHttpProviderConfig}
      */
     public AsyncHttpProviderConfig<?, ?> getAsyncHttpProviderConfig() {
         return providerConfig;
@@ -452,6 +471,27 @@ public boolean isUseRawUrl() {
         return useRawUrl;
     }
 
+    /**
+     * @return whether or not SPDY is enabled.
+     */
+    public boolean isSpdyEnabled() {
+        return spdyEnabled;
+    }
+
+    /**
+     * @return the windows size new SPDY sessions should be initialized to.
+     */
+    public int getSpdyInitialWindowSize() {
+        return spdyInitialWindowSize;
+    }
+
+    /**
+     * @return the maximum number of concurrent streams over one SPDY session.
+     */
+    public int getSpdyMaxConcurrentStreams() {
+        return spdyMaxConcurrentStreams;
+    }
+
     /**
      * Return true if the query parameters will be stripped from the request when a redirect is requested.
      *
@@ -504,14 +544,43 @@ public boolean isStrict302Handling() {
     }
 
     /**
-     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     * @return<code>true</code> if AHC should use relative URIs instead of absolute ones when talking with a SSL proxy,
+     *  otherwise <code>false</code>.
+     *  
+     *  @since 1.7.12
+     */
+    public boolean isUseRelativeURIsWithSSLProxies() {
+        return useRelativeURIsWithSSLProxies;
+    }
+
+    /**
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      *
-     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      */
     public int getMaxConnectionLifeTimeInMs() {
         return maxConnectionLifeTimeInMs;
     }
 
+    /**
+     * @return<code>true</code> if AHC should use rfc6265 for encoding client side cookies, otherwise <code>false</code>.
+     * 
+     * @since 1.7.18
+     */
+    public boolean isRfc6265CookieEncoding() {
+        return rfc6265CookieEncoding;
+    }
+
+    /**
+     * @return <code>true</code> if the underlying provider should make new connections asynchronously or not.  By default
+     *  new connections are made synchronously.
+     *
+     * @since 2.0.0
+     */
+    public boolean isAsyncConnectMode() {
+        return asyncConnectMode;
+    }
+
     /**
      * Builder for an {@link AsyncHttpClient}
      */
@@ -530,20 +599,9 @@ public int getMaxConnectionLifeTimeInMs() {
         private String userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "AsyncHttpClient/" + AHC_VERSION);
         private boolean useProxyProperties = Boolean.getBoolean(ASYNC_CLIENT + "useProxyProperties");
         private boolean allowPoolingConnection = true;
-        private ScheduledExecutorService reaper = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
-            public Thread newThread(Runnable r) {
-                Thread t = new Thread(r, "AsyncHttpClient-Reaper");
-                t.setDaemon(true);
-                return t;
-            }
-        });
-        private ExecutorService applicationThreadPool = Executors.newCachedThreadPool(new ThreadFactory() {
-            public Thread newThread(Runnable r) {
-                Thread t = new Thread(r, "AsyncHttpClient-Callback");
-                t.setDaemon(true);
-                return t;
-            }
-        });
+        private boolean useRelativeURIsWithSSLProxies = Boolean.getBoolean(ASYNC_CLIENT + "useRelativeURIsWithSSLProxies");
+        private ScheduledExecutorService reaper;
+        private ExecutorService applicationThreadPool;
         private ProxyServer proxyServer = null;
         private SSLContext sslContext;
         private SSLEngineFactory sslEngineFactory;
@@ -561,14 +619,19 @@ public Thread newThread(Runnable r) {
         private HostnameVerifier hostnameVerifier = new AllowAllHostnameVerifier();
         private int ioThreadMultiplier = 2;
         private boolean strict302Handling;
+        private boolean spdyEnabled;
+        private int spdyInitialWindowSize = 10 * 1024 * 1024;
+        private int spdyMaxConcurrentStreams = 100;
+        private boolean rfc6265CookieEncoding;
+        private boolean asyncConnectMode;
 
         public Builder() {
         }
 
         /**
-         * Set the maximum number of connections an {@link com.ning.http.client.AsyncHttpClient} can handle.
+         * Set the maximum number of connections an {@link AsyncHttpClient} can handle.
          *
-         * @param defaultMaxTotalConnections the maximum number of connections an {@link com.ning.http.client.AsyncHttpClient} can handle.
+         * @param defaultMaxTotalConnections the maximum number of connections an {@link AsyncHttpClient} can handle.
          * @return a {@link Builder}
          */
         public Builder setMaximumConnectionsTotal(int defaultMaxTotalConnections) {
@@ -577,9 +640,9 @@ public Builder setMaximumConnectionsTotal(int defaultMaxTotalConnections) {
         }
 
         /**
-         * Set the maximum number of connections per hosts an {@link com.ning.http.client.AsyncHttpClient} can handle.
+         * Set the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
          *
-         * @param defaultMaxConnectionPerHost the maximum number of connections per host an {@link com.ning.http.client.AsyncHttpClient} can handle.
+         * @param defaultMaxConnectionPerHost the maximum number of connections per host an {@link AsyncHttpClient} can handle.
          * @return a {@link Builder}
          */
         public Builder setMaximumConnectionsPerHost(int defaultMaxConnectionPerHost) {
@@ -588,9 +651,9 @@ public Builder setMaximumConnectionsPerHost(int defaultMaxConnectionPerHost) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
          *
-         * @param defaultConnectionTimeOutInMs the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+         * @param defaultConnectionTimeOutInMs the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
          * @return a {@link Builder}
          */
         public Builder setConnectionTimeoutInMs(int defaultConnectionTimeOutInMs) {
@@ -599,10 +662,10 @@ public Builder setConnectionTimeoutInMs(int defaultConnectionTimeOutInMs) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link com.ning.http.client.websocket.WebSocket} can stay idle.
+         * Set the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
          *
          * @param defaultWebSocketIdleTimeoutInMs
-         *         the maximum time in millisecond an {@link com.ning.http.client.websocket.WebSocket} can stay idle.
+         *         the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
          * @return a {@link Builder}
          */
         public Builder setWebSocketIdleTimeoutInMs(int defaultWebSocketIdleTimeoutInMs) {
@@ -611,10 +674,10 @@ public Builder setWebSocketIdleTimeoutInMs(int defaultWebSocketIdleTimeoutInMs)
         }
 
         /**
-         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
          *
          * @param defaultIdleConnectionTimeoutInMs
-         *         the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+         *         the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
          * @return a {@link Builder}
          */
         public Builder setIdleConnectionTimeoutInMs(int defaultIdleConnectionTimeoutInMs) {
@@ -623,11 +686,11 @@ public Builder setIdleConnectionTimeoutInMs(int defaultIdleConnectionTimeoutInMs
         }
 
         /**
-         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
          * idle in pool.
          *
          * @param defaultIdleConnectionInPoolTimeoutInMs
-         *         the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection
+         *         the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
          *         idle in pool.
          * @return a {@link Builder}
          */
@@ -637,9 +700,9 @@ public Builder setIdleConnectionInPoolTimeoutInMs(int defaultIdleConnectionInPoo
         }
 
         /**
-         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
          *
-         * @param defaultRequestTimeoutInMs the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+         * @param defaultRequestTimeoutInMs the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
          * @return a {@link Builder}
          */
         public Builder setRequestTimeoutInMs(int defaultRequestTimeoutInMs) {
@@ -707,7 +770,7 @@ public Builder setAllowPoolingConnection(boolean allowPoolingConnection) {
          *
          * @param allowPoolingConnection true if connection can be pooled by a {@link ConnectionsPool}
          * @return a {@link Builder}
-         * @deprecated - Use {@link com.ning.http.client.AsyncHttpClientConfig.Builder#setAllowPoolingConnection(boolean)}
+         * @deprecated - Use {@link AsyncHttpClientConfig.Builder#setAllowPoolingConnection(boolean)}
          */
         public Builder setKeepAlive(boolean allowPoolingConnection) {
             this.allowPoolingConnection = allowPoolingConnection;
@@ -721,7 +784,6 @@ public Builder setKeepAlive(boolean allowPoolingConnection) {
          * @return a {@link Builder}
          */
         public Builder setScheduledExecutorService(ScheduledExecutorService reaper) {
-            if (this.reaper != null) this.reaper.shutdown();
             this.reaper = reaper;
             return this;
         }
@@ -735,15 +797,14 @@ public Builder setScheduledExecutorService(ScheduledExecutorService reaper) {
          * @return a {@link Builder}
          */
         public Builder setExecutorService(ExecutorService applicationThreadPool) {
-            if (this.applicationThreadPool != null) this.applicationThreadPool.shutdown();
             this.applicationThreadPool = applicationThreadPool;
             return this;
         }
 
         /**
-         * Set an instance of {@link com.ning.http.client.ProxyServer} used by an {@link AsyncHttpClient}
+         * Set an instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
          *
-         * @param proxyServer instance of {@link com.ning.http.client.ProxyServer}
+         * @param proxyServer instance of {@link ProxyServer}
          * @return a {@link Builder}
          */
         public Builder setProxyServer(ProxyServer proxyServer) {
@@ -781,9 +842,9 @@ public SSLEngine newSSLEngine() throws GeneralSecurityException {
         }
 
         /**
-         * Set the {@link com.ning.http.client.AsyncHttpProviderConfig}
+         * Set the {@link AsyncHttpProviderConfig}
          *
-         * @param providerConfig the {@link com.ning.http.client.AsyncHttpProviderConfig}
+         * @param providerConfig the {@link AsyncHttpProviderConfig}
          * @return a {@link Builder}
          */
         public Builder setAsyncHttpClientProviderConfig(AsyncHttpProviderConfig<?, ?> providerConfig) {
@@ -814,9 +875,9 @@ public Builder setRealm(Realm realm) {
         }
 
         /**
-         * Add an {@link com.ning.http.client.filter.RequestFilter} that will be invoked before {@link com.ning.http.client.AsyncHttpClient#executeRequest(Request)}
+         * Add an {@link org.asynchttpclient.filter.RequestFilter} that will be invoked before {@link AsyncHttpClient#executeRequest(Request)}
          *
-         * @param requestFilter {@link com.ning.http.client.filter.RequestFilter}
+         * @param requestFilter {@link org.asynchttpclient.filter.RequestFilter}
          * @return this
          */
         public Builder addRequestFilter(RequestFilter requestFilter) {
@@ -825,9 +886,9 @@ public Builder addRequestFilter(RequestFilter requestFilter) {
         }
 
         /**
-         * Remove an {@link com.ning.http.client.filter.RequestFilter} that will be invoked before {@link com.ning.http.client.AsyncHttpClient#executeRequest(Request)}
+         * Remove an {@link org.asynchttpclient.filter.RequestFilter} that will be invoked before {@link AsyncHttpClient#executeRequest(Request)}
          *
-         * @param requestFilter {@link com.ning.http.client.filter.RequestFilter}
+         * @param requestFilter {@link org.asynchttpclient.filter.RequestFilter}
          * @return this
          */
         public Builder removeRequestFilter(RequestFilter requestFilter) {
@@ -836,10 +897,10 @@ public Builder removeRequestFilter(RequestFilter requestFilter) {
         }
 
         /**
-         * Add an {@link com.ning.http.client.filter.ResponseFilter} that will be invoked as soon as the response is
+         * Add an {@link org.asynchttpclient.filter.ResponseFilter} that will be invoked as soon as the response is
          * received, and before {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
          *
-         * @param responseFilter an {@link com.ning.http.client.filter.ResponseFilter}
+         * @param responseFilter an {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder addResponseFilter(ResponseFilter responseFilter) {
@@ -848,10 +909,10 @@ public Builder addResponseFilter(ResponseFilter responseFilter) {
         }
 
         /**
-         * Remove an {@link com.ning.http.client.filter.ResponseFilter} that will be invoked as soon as the response is
+         * Remove an {@link org.asynchttpclient.filter.ResponseFilter} that will be invoked as soon as the response is
          * received, and before {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
          *
-         * @param responseFilter an {@link com.ning.http.client.filter.ResponseFilter}
+         * @param responseFilter an {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder removeResponseFilter(ResponseFilter responseFilter) {
@@ -860,10 +921,10 @@ public Builder removeResponseFilter(ResponseFilter responseFilter) {
         }
 
         /**
-         * Add an {@link com.ning.http.client.filter.IOExceptionFilter} that will be invoked when an {@link java.io.IOException}
+         * Add an {@link org.asynchttpclient.filter.IOExceptionFilter} that will be invoked when an {@link java.io.IOException}
          * occurs during the download/upload operations.
          *
-         * @param ioExceptionFilter an {@link com.ning.http.client.filter.ResponseFilter}
+         * @param ioExceptionFilter an {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
@@ -872,10 +933,10 @@ public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
         }
 
         /**
-         * Remove an {@link com.ning.http.client.filter.IOExceptionFilter} tthat will be invoked when an {@link java.io.IOException}
+         * Remove an {@link org.asynchttpclient.filter.IOExceptionFilter} tthat will be invoked when an {@link java.io.IOException}
          * occurs during the download/upload operations.
          *
-         * @param ioExceptionFilter an {@link com.ning.http.client.filter.ResponseFilter}
+         * @param ioExceptionFilter an {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
@@ -1004,6 +1065,92 @@ public Builder setMaxConnectionLifeTimeInMs(int maxConnectionLifeTimeInMs) {
            return this;
         }
 
+        /**
+         * Configures this AHC instance to use relative URIs instead of absolute ones when talking with a SSL proxy.
+         *
+         * @param useRelativeURIsWithSSLProxies
+         * @return this
+         *
+         * @since 1.7.2
+         */
+        public Builder setUseRelativeURIsWithSSLProxies(boolean useRelativeURIsWithSSLProxies) {
+            this.useRelativeURIsWithSSLProxies = useRelativeURIsWithSSLProxies;
+            return this;
+        }
+
+        /**
+         * Enables SPDY support.  Note that doing so, will currently disable WebSocket support
+         * for this client instance.  If not explicitly enabled, spdy will not be used.
+         *
+         * @param spdyEnabled configures spdy support.
+         *
+         * @return this
+         *
+         * @since 2.0
+         */
+        public Builder setSpdyEnabled(boolean spdyEnabled) {
+            this.spdyEnabled = spdyEnabled;
+            return this;
+        }
+
+        /**
+         * Configures the initial window size for the SPDY session.
+         *
+         * @param spdyInitialWindowSize the initial window size.
+         *
+         * @return this
+         *
+         * @since 2.0
+         */
+        public Builder setSpdyInitialWindowSize(int spdyInitialWindowSize) {
+            this.spdyInitialWindowSize = spdyInitialWindowSize;
+            return this;
+        }
+
+        /**
+         * Configures the maximum number of concurrent streams over a single
+         * SPDY session.
+         *
+         * @param spdyMaxConcurrentStreams the maximum number of concurrent
+         *                                 streams over a single SPDY session.
+         *
+         * @return this
+         *
+         * @since 2.0
+         */
+        public Builder setSpdyMaxConcurrentStreams(int spdyMaxConcurrentStreams) {
+            this.spdyMaxConcurrentStreams = spdyMaxConcurrentStreams;
+            return this;
+        }
+
+        /**
+         * Configures this AHC instance to use RFC 6265 cookie encoding style
+         * 
+         * @param rfc6265CookieEncoding
+         * @return this
+         * 
+         * @since 1.7.18
+         */
+        public Builder setRfc6265CookieEncoding(boolean rfc6265CookieEncoding) {
+            this.rfc6265CookieEncoding = rfc6265CookieEncoding;
+            return this;
+        }
+
+        /**
+         * Configures how the underlying providers make new connections.  By default,
+         * connections will be made synchronously.
+         *
+         * @param asyncConnectMode pass <code>true</code> to enable async connect mode.
+         *
+         * @return this
+         *
+         * @since 2.0.0
+         */
+        public Builder setAsyncConnectMode(boolean asyncConnectMode) {
+            this.asyncConnectMode = asyncConnectMode;
+            return this;
+        }
+
         /**
          * Create a config builder with values taken from the given prototype configuration.
          *
@@ -1047,6 +1194,9 @@ public Builder(AsyncHttpClientConfig prototype) {
             removeQueryParamOnRedirect = prototype.isRemoveQueryParamOnRedirect();
             hostnameVerifier = prototype.getHostnameVerifier();
             strict302Handling = prototype.isStrict302Handling();
+            useRelativeURIsWithSSLProxies = prototype.isUseRelativeURIsWithSSLProxies();
+            rfc6265CookieEncoding = prototype.isRfc6265CookieEncoding();
+            asyncConnectMode = prototype.isAsyncConnectMode();
         }
 
         /**
@@ -1055,6 +1205,29 @@ public Builder(AsyncHttpClientConfig prototype) {
          * @return an {@link AsyncHttpClientConfig}
          */
         public AsyncHttpClientConfig build() {
+            
+            if (reaper == null) {
+                reaper = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
+                    public Thread newThread(Runnable r) {
+                        Thread t = new Thread(r, "AsyncHttpClient-Reaper");
+                        t.setDaemon(true);
+                        return t;
+                    }
+                });
+            }
+
+            if (applicationThreadPool == null) {
+                applicationThreadPool =
+                        Executors.newCachedThreadPool(new ThreadFactory() {
+                            final AtomicInteger counter = new AtomicInteger();
+                            public Thread newThread(Runnable r) {
+                                Thread t = new Thread(r,
+                                                      "AsyncHttpClient-Callback-" + counter.incrementAndGet());
+                                t.setDaemon(true);
+                                return t;
+                            }
+                        });
+            }
 
             if (applicationThreadPool.isShutdown()) {
                 throw new IllegalStateException("ExecutorServices closed");
@@ -1095,7 +1268,13 @@ public AsyncHttpClientConfig build() {
                     removeQueryParamOnRedirect,
                     hostnameVerifier,
                     ioThreadMultiplier,
-                    strict302Handling);
+                    strict302Handling,
+                    useRelativeURIsWithSSLProxies,
+                    spdyEnabled,
+                    spdyInitialWindowSize,
+                    spdyMaxConcurrentStreams,
+                    rfc6265CookieEncoding,
+                    asyncConnectMode);
         }
     }
 }
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
rename to api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
index 0aaf12361..4e48491b3 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.RequestFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.util.ProxyUtils;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.RequestFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.util.ProxyUtils;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
similarity index 86%
rename from api/src/main/java/com/ning/http/client/AsyncHttpProvider.java
rename to api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
index 49e771569..da96a0497 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpProvider.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
@@ -13,16 +13,18 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
 
 /**
  * Interface to be used when implementing custom asynchronous I/O HTTP client.
- * By default, the {@link com.ning.http.client.providers.netty.NettyAsyncHttpProvider} is used.
+ * By default, the {@link org.asynchttpclient.providers.jdk.JDKAsyncHttpProvider} is used if
+ * none of the other provider modules are found on the classpath.
  */
-public interface AsyncHttpProvider {
+public interface AsyncHttpProvider extends Closeable {
 
     /**
      * Execute the request and invoke the {@link AsyncHandler} when the response arrive.
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpProviderConfig.java b/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
similarity index 89%
rename from api/src/main/java/com/ning/http/client/AsyncHttpProviderConfig.java
rename to api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
index f006bc32c..48b9cd565 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpProviderConfig.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpProviderConfig.java
@@ -10,20 +10,20 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.util.Map;
 import java.util.Set;
 
 /**
- * {@link com.ning.http.client.AsyncHttpProvider} proprietary configurable properties. Note that properties are
+ * {@link AsyncHttpProvider} proprietary configurable properties. Note that properties are
  * <strong>AsyncHttpProvider</strong> dependent, so make sure you consult the AsyncHttpProvider's documentation
  * about what is supported and what's not.
  */
 public interface AsyncHttpProviderConfig<U, V> {
 
     /**
-     * Add a property that will be used when the AsyncHttpClient initialize its {@link com.ning.http.client.AsyncHttpProvider}
+     * Add a property that will be used when the AsyncHttpClient initialize its {@link AsyncHttpProvider}
      *
      * @param name  the name of the property
      * @param value the value of the property
diff --git a/api/src/main/java/com/ning/http/client/Body.java b/api/src/main/java/org/asynchttpclient/Body.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/Body.java
rename to api/src/main/java/org/asynchttpclient/Body.java
index 309fbec5a..dacf0642d 100644
--- a/api/src/main/java/com/ning/http/client/Body.java
+++ b/api/src/main/java/org/asynchttpclient/Body.java
@@ -11,15 +11,16 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
  * A request body.
  */
-public interface Body {
+public interface Body extends Closeable {
 
     /**
      * Gets the length of the body.
diff --git a/api/src/main/java/com/ning/http/client/BodyConsumer.java b/api/src/main/java/org/asynchttpclient/BodyConsumer.java
similarity index 92%
rename from api/src/main/java/com/ning/http/client/BodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/BodyConsumer.java
index b092ec121..ccebd5e8b 100644
--- a/api/src/main/java/com/ning/http/client/BodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/BodyConsumer.java
@@ -11,15 +11,16 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
  * A simple API to be used with the {@link SimpleAsyncHttpClient} class in order to process response's bytes.
  */
-public interface BodyConsumer {
+public interface BodyConsumer extends Closeable {
 
     /**
      * Consume the received bytes.
diff --git a/api/src/main/java/com/ning/http/client/BodyDeferringAsyncHandler.java b/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/BodyDeferringAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
index 3171d78aa..1bf49bbb0 100644
--- a/api/src/main/java/com/ning/http/client/BodyDeferringAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.Response.ResponseBuilder;
+import org.asynchttpclient.Response.ResponseBuilder;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -74,7 +74,8 @@
  * </pre>
  */
 public class BodyDeferringAsyncHandler implements AsyncHandler<Response> {
-    private final ResponseBuilder responseBuilder = new ResponseBuilder();
+    private final Response.ResponseBuilder
+            responseBuilder = new Response.ResponseBuilder();
 
     private final CountDownLatch headersArrived = new CountDownLatch(1);
 
diff --git a/api/src/main/java/com/ning/http/client/BodyGenerator.java b/api/src/main/java/org/asynchttpclient/BodyGenerator.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/BodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/BodyGenerator.java
index 35fe38628..804d28f96 100644
--- a/api/src/main/java/com/ning/http/client/BodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/BodyGenerator.java
@@ -11,7 +11,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/com/ning/http/client/ByteArrayPart.java b/api/src/main/java/org/asynchttpclient/ByteArrayPart.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/ByteArrayPart.java
rename to api/src/main/java/org/asynchttpclient/ByteArrayPart.java
index 3d7c73186..87311f0f1 100644
--- a/api/src/main/java/com/ning/http/client/ByteArrayPart.java
+++ b/api/src/main/java/org/asynchttpclient/ByteArrayPart.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 public class ByteArrayPart implements Part {
     private String name;
diff --git a/api/src/main/java/com/ning/http/client/ConnectionPoolKeyStrategy.java b/api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java
similarity index 95%
rename from api/src/main/java/com/ning/http/client/ConnectionPoolKeyStrategy.java
rename to api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java
index 3beb10d3e..49603dabe 100644
--- a/api/src/main/java/com/ning/http/client/ConnectionPoolKeyStrategy.java
+++ b/api/src/main/java/org/asynchttpclient/ConnectionPoolKeyStrategy.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.net.URI;
 
diff --git a/api/src/main/java/com/ning/http/client/ConnectionsPool.java b/api/src/main/java/org/asynchttpclient/ConnectionsPool.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/ConnectionsPool.java
rename to api/src/main/java/org/asynchttpclient/ConnectionsPool.java
index 1feb843d8..c76c855b7 100644
--- a/api/src/main/java/com/ning/http/client/ConnectionsPool.java
+++ b/api/src/main/java/org/asynchttpclient/ConnectionsPool.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * An interface used by an {@link AsyncHttpProvider} for caching http connections.
diff --git a/api/src/main/java/org/asynchttpclient/Cookie.java b/api/src/main/java/org/asynchttpclient/Cookie.java
new file mode 100644
index 000000000..8ba53605f
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/Cookie.java
@@ -0,0 +1,270 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.TreeSet;
+
+public class Cookie implements Comparable<Cookie>{
+    private final String domain;
+    private final String name;
+    private final String value;
+    private final String rawValue;
+    private final String path;
+    private final int maxAge;
+    private final boolean secure;
+    private final int version;
+    private final boolean httpOnly;
+    private final boolean discard;
+    private final String comment;
+    private final String commentUrl;
+
+    private Set<Integer> ports = Collections.emptySet();
+    private Set<Integer> unmodifiablePorts = ports;
+
+    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure) {
+        this(domain, name, value, path, maxAge, secure, 1);
+    }
+
+    public Cookie(String domain, String name, String value, String path, int maxAge, boolean secure, int version) {
+        this(domain, name, value, value, path, maxAge, secure, version, false, false, null, null, Collections.<Integer> emptySet());
+    }
+
+    public Cookie(String domain, String name, String value, String rawValue, String path, int maxAge, boolean secure, int version, boolean httpOnly, boolean discard, String comment, String commentUrl, Iterable<Integer> ports) {
+
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+        name = name.trim();
+        if (name.length() == 0) {
+            throw new IllegalArgumentException("empty name");
+        }
+
+        for (int i = 0; i < name.length(); i++) {
+            char c = name.charAt(i);
+            if (c > 127) {
+                throw new IllegalArgumentException("name contains non-ascii character: " + name);
+            }
+
+            // Check prohibited characters.
+            switch (c) {
+            case '\t':
+            case '\n':
+            case 0x0b:
+            case '\f':
+            case '\r':
+            case ' ':
+            case ',':
+            case ';':
+            case '=':
+                throw new IllegalArgumentException("name contains one of the following prohibited characters: " + "=,; \\t\\r\\n\\v\\f: " + name);
+            }
+        }
+
+        if (name.charAt(0) == '$') {
+            throw new IllegalArgumentException("name starting with '$' not allowed: " + name);
+        }
+
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+
+        this.name = name;
+        this.value = value;
+        this.rawValue = rawValue;
+        this.domain = validateValue("domain", domain);
+        this.path = validateValue("path", path);
+        this.maxAge = maxAge;
+        this.secure = secure;
+        this.version = version;
+        this.httpOnly = httpOnly;
+
+        if (version > 0) {
+            this.comment = validateValue("comment", comment);
+        } else {
+            this.comment = null;
+        }
+        if (version > 1) {
+            this.discard = discard;
+            this.commentUrl = validateValue("commentUrl", commentUrl);
+            setPorts(ports);
+        } else {
+            this.discard = false;
+            this.commentUrl = null;
+        }
+    }
+
+    public String getDomain() {
+        return domain;
+    }
+
+    public String getName() {
+        return name == null ? "" : name;
+    }
+
+    public String getValue() {
+        return value == null ? "" : value;
+    }
+    
+    public String getRawValue() {
+        return rawValue;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    public int getMaxAge() {
+        return maxAge;
+    }
+
+    public boolean isSecure() {
+        return secure;
+    }
+
+    public int getVersion() {
+        return version;
+    }
+
+    public String getComment() {
+        return this.comment;
+    }
+
+    public String getCommentUrl() {
+        return this.commentUrl;
+    }
+
+    public boolean isHttpOnly() {
+        return httpOnly;
+    }
+
+    public boolean isDiscard() {
+        return discard;
+    }
+
+    public Set<Integer> getPorts() {
+        if (unmodifiablePorts == null) {
+            unmodifiablePorts = Collections.unmodifiableSet(ports);
+        }
+        return unmodifiablePorts;
+    }
+
+    private void setPorts(Iterable<Integer> ports) {
+        Set<Integer> newPorts = new TreeSet<Integer>();
+        for (int p : ports) {
+            if (p <= 0 || p > 65535) {
+                throw new IllegalArgumentException("port out of range: " + p);
+            }
+            newPorts.add(Integer.valueOf(p));
+        }
+        if (newPorts.isEmpty()) {
+            unmodifiablePorts = this.ports = Collections.emptySet();
+        } else {
+            this.ports = newPorts;
+            unmodifiablePorts = null;
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder();
+        buf.append(getName());
+        buf.append('=');
+        buf.append(getValue());
+        if (getDomain() != null) {
+            buf.append("; domain=");
+            buf.append(getDomain());
+        }
+        if (getPath() != null) {
+            buf.append("; path=");
+            buf.append(getPath());
+        }
+        if (getComment() != null) {
+            buf.append("; comment=");
+            buf.append(getComment());
+        }
+        if (getMaxAge() >= 0) {
+            buf.append("; maxAge=");
+            buf.append(getMaxAge());
+            buf.append('s');
+        }
+        if (isSecure()) {
+            buf.append("; secure");
+        }
+        if (isHttpOnly()) {
+            buf.append("; HTTPOnly");
+        }
+        return buf.toString();
+    }
+
+    private String validateValue(String name, String value) {
+        if (value == null) {
+            return null;
+        }
+        value = value.trim();
+        if (value.length() == 0) {
+            return null;
+        }
+        for (int i = 0; i < value.length(); i++) {
+            char c = value.charAt(i);
+            switch (c) {
+            case '\r':
+            case '\n':
+            case '\f':
+            case 0x0b:
+            case ';':
+                throw new IllegalArgumentException(name + " contains one of the following prohibited characters: " + ";\\r\\n\\f\\v (" + value + ')');
+            }
+        }
+        return value;
+    }
+
+    public int compareTo(Cookie c) {
+        int v;
+        v = getName().compareToIgnoreCase(c.getName());
+        if (v != 0) {
+            return v;
+        }
+
+        if (getPath() == null) {
+            if (c.getPath() != null) {
+                return -1;
+            }
+        } else if (c.getPath() == null) {
+            return 1;
+        } else {
+            v = getPath().compareTo(c.getPath());
+            if (v != 0) {
+                return v;
+            }
+        }
+
+        if (getDomain() == null) {
+            if (c.getDomain() != null) {
+                return -1;
+            }
+        } else if (c.getDomain() == null) {
+            return 1;
+        } else {
+            v = getDomain().compareToIgnoreCase(c.getDomain());
+            return v;
+        }
+
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/com/ning/http/client/DefaultConnectionPoolStrategy.java b/api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/DefaultConnectionPoolStrategy.java
rename to api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java
index c56f65612..b312155c4 100644
--- a/api/src/main/java/com/ning/http/client/DefaultConnectionPoolStrategy.java
+++ b/api/src/main/java/org/asynchttpclient/DefaultConnectionPoolStrategy.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.net.URI;
 
-import com.ning.http.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
 public enum DefaultConnectionPoolStrategy implements ConnectionPoolKeyStrategy {
 
diff --git a/api/src/main/java/com/ning/http/client/FilePart.java b/api/src/main/java/org/asynchttpclient/FilePart.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/FilePart.java
rename to api/src/main/java/org/asynchttpclient/FilePart.java
index 714395a74..c5cc15860 100644
--- a/api/src/main/java/com/ning/http/client/FilePart.java
+++ b/api/src/main/java/org/asynchttpclient/FilePart.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.File;
 
diff --git a/api/src/main/java/com/ning/http/client/FluentCaseInsensitiveStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
similarity index 99%
rename from api/src/main/java/com/ning/http/client/FluentCaseInsensitiveStringsMap.java
rename to api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
index 009af7e43..5f8c54232 100644
--- a/api/src/main/java/com/ning/http/client/FluentCaseInsensitiveStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
@@ -14,7 +14,9 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -66,7 +68,7 @@ public FluentCaseInsensitiveStringsMap(Map<String, Collection<String>> src) {
      * @return This object
      */
     public FluentCaseInsensitiveStringsMap add(String key, String... values) {
-        if ((values != null) && (values.length > 0)) {
+        if (isNonEmpty(values)) {
             add(key, Arrays.asList(values));
         }
         return this;
diff --git a/api/src/main/java/com/ning/http/client/FluentStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/FluentStringsMap.java
rename to api/src/main/java/org/asynchttpclient/FluentStringsMap.java
index 5c7142861..2001413e1 100644
--- a/api/src/main/java/com/ning/http/client/FluentStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
@@ -14,7 +14,9 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -61,30 +63,12 @@ public FluentStringsMap(Map<String, Collection<String>> src) {
      * @return This object
      */
     public FluentStringsMap add(String key, String... values) {
-        if ((values != null) && (values.length > 0)) {
+        if (isNonEmpty(values)) {
             add(key, Arrays.asList(values));
         }
         return this;
     }
 
-    private List<String> fetchValues(Collection<String> values) {
-        List<String> result = null;
-
-        if (values != null) {
-            for (String value : values) {
-                if (value == null) {
-                    value = "";
-                }
-                if (result == null) {
-                    // lazy initialization
-                    result = new ArrayList<String>();
-                }
-                result.add(value);
-            }
-        }
-        return result;
-    }
-
     /**
      * Adds the specified values and returns this object.
      *
@@ -94,17 +78,13 @@ public FluentStringsMap add(String key, String... values) {
      * @return This object
      */
     public FluentStringsMap add(String key, Collection<String> values) {
-        if (key != null) {
-            List<String> nonNullValues = fetchValues(values);
-
-            if (nonNullValues != null) {
-                List<String> curValues = this.values.get(key);
+        if (key != null && isNonEmpty(values)) {
+            List<String> curValues = this.values.get(key);
 
-                if (curValues == null) {
-                    curValues = new ArrayList<String>();
-                    this.values.put(key, curValues);
-                }
-                curValues.addAll(nonNullValues);
+            if (curValues == null) {
+                this.values.put(key, new ArrayList<String>(values));
+            } else {
+                curValues.addAll(values);
             }
         }
         return this;
@@ -160,12 +140,10 @@ public FluentStringsMap replace(final String key, final String... values) {
      */
     public FluentStringsMap replace(final String key, final Collection<String> values) {
         if (key != null) {
-            List<String> nonNullValues = fetchValues(values);
-
-            if (nonNullValues == null) {
+            if (values == null) {
                 this.values.remove(key);
             } else {
-                this.values.put(key, nonNullValues);
+                this.values.put(key, new ArrayList<String>(values));
             }
         }
         return this;
diff --git a/api/src/main/java/com/ning/http/client/HttpContent.java b/api/src/main/java/org/asynchttpclient/HttpContent.java
similarity index 91%
rename from api/src/main/java/com/ning/http/client/HttpContent.java
rename to api/src/main/java/org/asynchttpclient/HttpContent.java
index 334def923..219e2411c 100644
--- a/api/src/main/java/com/ning/http/client/HttpContent.java
+++ b/api/src/main/java/org/asynchttpclient/HttpContent.java
@@ -13,12 +13,12 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.net.URI;
 
 /**
- * Base class for callback class used by {@link com.ning.http.client.AsyncHandler}
+ * Base class for callback class used by {@link AsyncHandler}
  */
 public class HttpContent {
     protected final AsyncHttpProvider provider;
diff --git a/api/src/main/java/com/ning/http/client/HttpResponseBodyPart.java b/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/HttpResponseBodyPart.java
rename to api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 63e98cc59..2a8655e2d 100644
--- a/api/src/main/java/com/ning/http/client/HttpResponseBodyPart.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/api/src/main/java/com/ning/http/client/HttpResponseHeaders.java b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/HttpResponseHeaders.java
rename to api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
index c3842cf12..54c894f71 100644
--- a/api/src/main/java/com/ning/http/client/HttpResponseHeaders.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.net.URI;
 
diff --git a/api/src/main/java/com/ning/http/client/HttpResponseStatus.java b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/HttpResponseStatus.java
rename to api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index f90b30c5a..3581e4658 100644
--- a/api/src/main/java/com/ning/http/client/HttpResponseStatus.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.net.URI;
 
diff --git a/api/src/main/java/com/ning/http/client/ListenableFuture.java b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
similarity index 99%
rename from api/src/main/java/com/ning/http/client/ListenableFuture.java
rename to api/src/main/java/org/asynchttpclient/ListenableFuture.java
index 371c5540b..f40012e76 100755
--- a/api/src/main/java/com/ning/http/client/ListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -28,7 +28,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
diff --git a/api/src/main/java/com/ning/http/client/MaxRedirectException.java b/api/src/main/java/org/asynchttpclient/MaxRedirectException.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/MaxRedirectException.java
rename to api/src/main/java/org/asynchttpclient/MaxRedirectException.java
index bdffe0236..f39f70d90 100644
--- a/api/src/main/java/com/ning/http/client/MaxRedirectException.java
+++ b/api/src/main/java/org/asynchttpclient/MaxRedirectException.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * Thrown when the {@link AsyncHttpClientConfig#getMaxRedirects()} has been reached.
diff --git a/api/src/main/java/com/ning/http/client/Part.java b/api/src/main/java/org/asynchttpclient/Part.java
similarity index 95%
rename from api/src/main/java/com/ning/http/client/Part.java
rename to api/src/main/java/org/asynchttpclient/Part.java
index 95e34eeca..521cad838 100644
--- a/api/src/main/java/com/ning/http/client/Part.java
+++ b/api/src/main/java/org/asynchttpclient/Part.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * Interface for the parts in a multipart request.
diff --git a/api/src/main/java/com/ning/http/client/ProgressAsyncHandler.java b/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
similarity index 83%
rename from api/src/main/java/com/ning/http/client/ProgressAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
index 3c0363d8f..a562addc4 100644
--- a/api/src/main/java/com/ning/http/client/ProgressAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * An extended {@link AsyncHandler} with two extra callback who get invoked during the content upload to a remote server.
@@ -22,7 +22,7 @@
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     STATE onHeaderWriteCompleted();
 
@@ -30,7 +30,7 @@
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     STATE onContentWriteCompleted();
 
@@ -41,7 +41,7 @@
      * @param amount  The amount of bytes to transfer.
      * @param current The amount of bytes transferred
      * @param total   The total number of bytes transferred
-     * @return a {@link com.ning.http.client.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
      */
     STATE onContentWriteProgress(long amount, long current, long total);
 
diff --git a/api/src/main/java/com/ning/http/client/ProxyServer.java b/api/src/main/java/org/asynchttpclient/ProxyServer.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/ProxyServer.java
rename to api/src/main/java/org/asynchttpclient/ProxyServer.java
index f0551329a..d7d841c3f 100644
--- a/api/src/main/java/com/ning/http/client/ProxyServer.java
+++ b/api/src/main/java/org/asynchttpclient/ProxyServer.java
@@ -14,12 +14,15 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+
 /**
  * Represents a proxy server.
  */
@@ -44,21 +47,24 @@ public String toString() {
         }
     }
 
-    private String encoding = "UTF-8";
     private final List<String> nonProxyHosts = new ArrayList<String>();
     private final Protocol protocol;
     private final String host;
     private final String principal;
     private final String password;
-    private int port;
+    private final int port;
+    private final URI uri;
+    private String encoding = "UTF-8";
     private String ntlmDomain = System.getProperty("http.auth.ntlm.domain", "");
 
     private boolean isBasic = true;
-    
+
+    @Deprecated
     public boolean isBasic() {
 		return isBasic;
 	}
 
+    @Deprecated
 	public void setBasic(boolean isBasic) {
 		this.isBasic = isBasic;
 	}
@@ -69,6 +75,7 @@ public ProxyServer(final Protocol protocol, final String host, final int port, S
         this.port = port;
         this.principal = principal;
         this.password = password;
+        this.uri = AsyncHttpProviderUtils.createUri(toString());
     }
 
     public ProxyServer(final String host, final int port, String principal, String password) {
@@ -116,6 +123,10 @@ public String getEncoding() {
         return encoding;
     }
 
+    public URI getURI() {
+        return uri;
+    }
+
     public ProxyServer addNonProxyHost(String uri) {
         nonProxyHosts.add(uri);
         return this;
@@ -141,7 +152,7 @@ public String getNtlmDomain() {
 
     @Override
     public String toString() {
-        return String.format("%s://%s:%d", protocol.toString(), host, port);
+        return protocol + "://" + host + ":" + port;
     }
 }
 
diff --git a/api/src/main/java/com/ning/http/client/RandomAccessBody.java b/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/RandomAccessBody.java
rename to api/src/main/java/org/asynchttpclient/RandomAccessBody.java
index c4ee2f233..95aa0fb1a 100644
--- a/api/src/main/java/com/ning/http/client/RandomAccessBody.java
+++ b/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
@@ -11,7 +11,7 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
diff --git a/api/src/main/java/com/ning/http/client/Realm.java b/api/src/main/java/org/asynchttpclient/Realm.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/Realm.java
rename to api/src/main/java/org/asynchttpclient/Realm.java
index 10da77fa0..de213f74c 100644
--- a/api/src/main/java/com/ning/http/client/Realm.java
+++ b/api/src/main/java/org/asynchttpclient/Realm.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright 2010-2013 Ning, Inc.
  *
  * Ning licenses this file to you under the Apache License, version 2.0
  * (the "License"); you may not use this file except in compliance with the
@@ -14,7 +14,9 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
@@ -431,7 +433,7 @@ public RealmBuilder parseWWWAuthenticateHeader(String headerLine) {
             setAlgorithm(match(headerLine, "algorithm"));
             setOpaque(match(headerLine, "opaque"));
             setQop(match(headerLine, "qop"));
-            if (getNonce() != null && !getNonce().equalsIgnoreCase("")) {
+            if (isNonEmpty(getNonce())) {
                 setScheme(AuthScheme.DIGEST);
             } else {
                 setScheme(AuthScheme.BASIC);
@@ -444,7 +446,7 @@ public RealmBuilder parseProxyAuthenticateHeader(String headerLine) {
             setNonce(match(headerLine, "nonce"));
             setOpaque(match(headerLine, "opaque"));
             setQop(match(headerLine, "qop"));
-            if (getNonce() != null && !getNonce().equalsIgnoreCase("")) {
+            if (isNonEmpty(getNonce())) {
                 setScheme(AuthScheme.DIGEST);
             } else {
                 setScheme(AuthScheme.BASIC);
@@ -538,7 +540,7 @@ private void newResponse() throws UnsupportedEncodingException {
                     .append(uri).toString().getBytes("ISO-8859-1"));
             byte[] ha2 = md.digest();
 
-            if(qop==null || qop.equals("")) {
+            if(qop==null || qop.length() == 0) {
                  md.update(new StringBuilder(toBase16(ha1))
                     .append(':')
                     .append(nonce)
@@ -599,7 +601,7 @@ private static String toBase16(byte[] bytes) {
         public Realm build() {
 
             // Avoid generating
-            if (nonce != null && !nonce.equals("")) {
+            if (isNonEmpty(nonce)) {
                 newCnonce();
                 try {
                     newResponse();
diff --git a/api/src/main/java/com/ning/http/client/Request.java b/api/src/main/java/org/asynchttpclient/Request.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/Request.java
rename to api/src/main/java/org/asynchttpclient/Request.java
index eb31a23fb..056f93ee0 100644
--- a/api/src/main/java/com/ning/http/client/Request.java
+++ b/api/src/main/java/org/asynchttpclient/Request.java
@@ -14,13 +14,14 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.InetAddress;
+import java.net.URI;
 import java.util.Collection;
 import java.util.List;
 
@@ -44,14 +45,6 @@
         public void writeEntity(OutputStream out) throws IOException;
     }
 
-    /**
-     * Return the request's type (GET, POST, etc.)
-     *
-     * @return the request's type (GET, POST, etc.)
-     * @deprecated - use getMethod
-     */
-    public String getReqType();
-
     /**
      * Return the request's method name (GET, POST, etc.)
      *
@@ -66,6 +59,10 @@
      */
     public String getUrl();
 
+    public URI getOriginalURI();
+    public URI getURI();
+    public URI getRawURI();
+
     /**
      * Return the InetAddress to override
      *
@@ -210,11 +207,11 @@
     public boolean isRedirectOverrideSet();
 
     /**
-     * Return Per request configuration.
+     * Return the request time out in milliseconds.
      *
-     * @return Per request configuration.
+     * @return requestTimeoutInMs.
      */
-    public PerRequestConfig getPerRequestConfig();
+    public int getRequestTimeoutInMs();
 
     /**
      * Return the HTTP Range header value, or
diff --git a/api/src/main/java/com/ning/http/client/RequestBuilder.java b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/RequestBuilder.java
rename to api/src/main/java/org/asynchttpclient/RequestBuilder.java
index 50aaad585..4702419ac 100644
--- a/api/src/main/java/com/ning/http/client/RequestBuilder.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -13,9 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.Request.EntityWriter;
+import org.asynchttpclient.Request.EntityWriter;
 
 import java.io.InputStream;
 import java.util.Collection;
@@ -23,6 +23,8 @@
 
 /**
  * Builder for a {@link Request}.
+ * Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds,
+ * so modifying the builder will modify the request even after it has been built.
  */
 public class RequestBuilder extends RequestBuilderBase<RequestBuilder> {
 
@@ -103,7 +105,7 @@ public RequestBuilder setBody(EntityWriter dataWriter) {
      * @return a {@link RequestBuilder}
      * @throws IllegalArgumentException
      * @see #setBody(BodyGenerator) InputStreamBodyGenerator(inputStream)
-     * @see com.ning.http.client.generators.InputStreamBodyGenerator
+     * @see org.asynchttpclient.generators.InputStreamBodyGenerator
      * @deprecated {@link #setBody(BodyGenerator)} setBody(new InputStreamBodyGenerator(inputStream))
      */
     @Override
diff --git a/api/src/main/java/com/ning/http/client/RequestBuilderBase.java b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
similarity index 83%
rename from api/src/main/java/com/ning/http/client/RequestBuilderBase.java
rename to api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index 367fc751d..f22ff4491 100644
--- a/api/src/main/java/com/ning/http/client/RequestBuilderBase.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright 2010-2013 Ning, Inc.
  *
  * Ning licenses this file to you under the Apache License, version 2.0
  * (the "License"); you may not use this file except in compliance with the
@@ -13,10 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.Request.EntityWriter;
-import com.ning.http.util.UTF8UrlEncoder;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+import org.asynchttpclient.Request.EntityWriter;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.UTF8UrlEncoder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,17 +39,21 @@
 
 /**
  * Builder for {@link Request}
- *
+ * 
  * @param <T>
  */
 public abstract class RequestBuilderBase<T extends RequestBuilderBase<T>> {
     private final static Logger logger = LoggerFactory.getLogger(RequestBuilderBase.class);
 
+    private static final URI DEFAULT_REQUEST_URL = URI.create("http://localhost");
+
     private static final class RequestImpl implements Request {
         private String method;
-        private String url = null;
-        private InetAddress address = null;
-        private InetAddress localAddress = null;
+        private URI originalUri;
+        private URI uri;
+        private URI rawUri;
+        private InetAddress address;
+        private InetAddress localAddress;
         private FluentCaseInsensitiveStringsMap headers = new FluentCaseInsensitiveStringsMap();
         private Collection<Cookie> cookies = new ArrayList<Cookie>();
         private byte[] byteData;
@@ -63,10 +70,10 @@
         private Realm realm;
         private File file;
         private Boolean followRedirects;
-        private PerRequestConfig perRequestConfig;
-        private long rangeOffset = 0;
+        private int requestTimeoutInMs;
+        private long rangeOffset;
         public String charset;
-        private boolean useRawUrl = false;
+        private boolean useRawUrl;
         private ConnectionPoolKeyStrategy connectionPoolKeyStrategy = DefaultConnectionPoolStrategy.INSTANCE;
 
         public RequestImpl(boolean useRawUrl) {
@@ -76,9 +83,7 @@ public RequestImpl(boolean useRawUrl) {
         public RequestImpl(Request prototype) {
             if (prototype != null) {
                 this.method = prototype.getMethod();
-                String prototypeUrl = prototype.getUrl();
-                int pos = prototypeUrl.indexOf("?");
-                this.url = pos > 0 ? prototypeUrl.substring(0, pos) : prototypeUrl;
+                this.originalUri = prototype.getOriginalURI();
                 this.address = prototype.getInetAddress();
                 this.localAddress = prototype.getLocalAddress();
                 this.headers = new FluentCaseInsensitiveStringsMap(prototype.getHeaders());
@@ -97,7 +102,7 @@ public RequestImpl(Request prototype) {
                 this.realm = prototype.getRealm();
                 this.file = prototype.getFile();
                 this.followRedirects = prototype.isRedirectOverrideSet()? prototype.isRedirectEnabled() : null;
-                this.perRequestConfig = prototype.getPerRequestConfig();
+                this.requestTimeoutInMs = prototype.getRequestTimeoutInMs();
                 this.rangeOffset = prototype.getRangeOffset();
                 this.charset = prototype.getBodyEncoding();
                 this.useRawUrl = prototype.isUseRawUrl();
@@ -107,20 +112,10 @@ public RequestImpl(Request prototype) {
 
         /* @Override */
 
-        public String getReqType() {
-            return getMethod();
-        }
-
         public String getMethod() {
             return method;
         }
 
-        /* @Override */
-
-        public String getUrl() {
-            return toUrl(true);
-        }
-
         public InetAddress getInetAddress() {
             return address;
         }
@@ -128,42 +123,74 @@ public InetAddress getInetAddress() {
         public InetAddress getLocalAddress() {
             return localAddress;
         }
-        
-        private String toUrl(boolean encode) {
 
-            if (url == null) {
+        private String removeTrailingSlash(URI uri) {
+            String uriString = uri.toString();
+            if (uriString.endsWith("/")) {
+                return uriString.substring(0, uriString.length() - 1);
+            } else {
+                return uriString;
+            }
+        }
+
+        /* @Override */
+        public String getUrl() {
+            return removeTrailingSlash(getURI());
+        }
+
+        /* @Override */
+        public String getRawUrl() {
+            return removeTrailingSlash(getRawURI());
+        }
+
+        public URI getOriginalURI() {
+            return originalUri;
+        }
+
+        public URI getURI() {
+            if (uri == null)
+                uri = toURI(true);
+            return uri;
+        }
+
+        public URI getRawURI() {
+            if (rawUri == null)
+                rawUri = toURI(false);
+            return rawUri;
+        }
+
+        private URI toURI(boolean encode) {
+
+            if (originalUri == null) {
                 logger.debug("setUrl hasn't been invoked. Using http://localhost");
-                url = "http://localhost";
+                originalUri = DEFAULT_REQUEST_URL;
             }
 
-            String uri = url;
-            if (!uri.startsWith("ws")) {
-                try {
-                    uri = URI.create(url).toURL().toString();
-                } catch (Throwable e) {
-                    throw new IllegalArgumentException("Illegal URL: " + url, e);
-                }
+            AsyncHttpProviderUtils.validateSupportedScheme(originalUri);
+
+            StringBuilder builder = new StringBuilder();
+            builder.append(originalUri.getScheme()).append("://").append(originalUri.getAuthority());
+            if (isNonEmpty(originalUri.getRawPath())) {
+                builder.append(originalUri.getRawPath());
+            } else {
+                builder.append("/");
             }
 
-            if (queryParams != null && !queryParams.isEmpty()) {
+            if (isNonEmpty(queryParams)) {
 
-                StringBuilder builder = new StringBuilder();
-                if (!url.substring(8).contains("/")) { // no other "/" than http[s]:// -> http://localhost:1234
-                    builder.append("/");
-                }
                 builder.append("?");
 
-                for (Iterator<Entry<String, List<String>>> i = queryParams.iterator(); i.hasNext(); ) {
+                for (Iterator<Entry<String, List<String>>> i = queryParams.iterator(); i.hasNext();) {
                     Map.Entry<String, List<String>> param = i.next();
                     String name = param.getKey();
-                    for (Iterator<String> j = param.getValue().iterator(); j.hasNext(); ) {
+                    for (Iterator<String> j = param.getValue().iterator(); j.hasNext();) {
                         String value = j.next();
                         if (encode) {
                             UTF8UrlEncoder.appendEncoded(builder, name);
                         } else {
                             builder.append(name);
                         }
-                        if (value != null && !value.equals("")) {
+                        if (value != null) {
                             builder.append('=');
                             if (encode) {
                                 UTF8UrlEncoder.appendEncoded(builder, value);
@@ -179,14 +206,9 @@ private String toUrl(boolean encode) {
                         builder.append('&');
                     }
                 }
-                uri += builder.toString();
             }
-            return uri;
-        }
 
-        /* @Override */
-        public String getRawUrl() {
-            return toUrl(false);
+            return URI.create(builder.toString());
         }
 
         /* @Override */
@@ -277,8 +299,8 @@ public boolean isRedirectOverrideSet(){
             return followRedirects != null;
         }
 
-        public PerRequestConfig getPerRequestConfig() {
-            return perRequestConfig;
+        public int getRequestTimeoutInMs() {
+            return requestTimeoutInMs;
         }
 
         public long getRangeOffset() {
@@ -290,12 +312,12 @@ public String getBodyEncoding() {
         }
 
         public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
-        	return connectionPoolKeyStrategy;
+            return connectionPoolKeyStrategy;
         }
 
         @Override
         public String toString() {
-            StringBuilder sb = new StringBuilder(url);
+            StringBuilder sb = new StringBuilder(getURI().toString());
 
             sb.append("\t");
             sb.append(method);
@@ -344,7 +366,9 @@ protected RequestBuilderBase(Class<T> derived, Request prototype) {
     }
 
     public T setUrl(String url) {
-        request.url = buildUrl(url);
+        request.originalUri = buildURI(url);
+        request.uri = null;
+        request.rawUri = null;
         return derived.cast(this);
     }
 
@@ -358,42 +382,41 @@ public T setLocalInetAddress(InetAddress address) {
         return derived.cast(this);
     }
 
-    private String buildUrl(String url) {
+    private URI buildURI(String url) {
         URI uri = URI.create(url);
-        StringBuilder buildedUrl = new StringBuilder();
 
-        if (uri.getScheme() != null) {
-            buildedUrl.append(uri.getScheme());
-            buildedUrl.append("://");
-        }
-
-        if (uri.getAuthority() != null) {
-            buildedUrl.append(uri.getAuthority());
-        }
-        if (uri.getRawPath() != null) {
-            buildedUrl.append(uri.getRawPath());
-        } else {
+        if (uri.getRawPath() == null) {
             // AHC-96
             // Let's try to derive it
+            StringBuilder buildedUrl = new StringBuilder();
+
+            if (uri.getScheme() != null) {
+                buildedUrl.append(uri.getScheme());
+                buildedUrl.append("://");
+            }
+
+            if (uri.getAuthority() != null) {
+                buildedUrl.append(uri.getAuthority());
+            }
             if (url.indexOf("://") == -1) {
                 String s = buildedUrl.toString();
                 url = s + url.substring(uri.getScheme().length() + 1);
-                return buildUrl(url);
+                return buildURI(url);
             } else {
-                throw new IllegalArgumentException("Invalid url " + uri.toString());
+                throw new IllegalArgumentException("Invalid url "  + uri.toString());
             }
         }
 
-        if (uri.getRawQuery() != null && !uri.getRawQuery().equals("")) {
+        if (isNonEmpty(uri.getRawQuery())) {
             String[] queries = uri.getRawQuery().split("&");
             int pos;
             for (String query : queries) {
-                pos = query.indexOf("=");
+                pos = query.indexOf('=');
                 if (pos <= 0) {
                     addQueryParameter(query, null);
                 } else {
                     try {
-                        if (this.useRawUrl) {
+                        if (useRawUrl) {
                             addQueryParameter(query.substring(0, pos), query.substring(pos + 1));
                         } else {
                             addQueryParameter(URLDecoder.decode(query.substring(0, pos), "UTF-8"), URLDecoder.decode(query.substring(pos + 1), "UTF-8"));
@@ -404,10 +427,9 @@ private String buildUrl(String url) {
                 }
             }
         }
-        return buildedUrl.toString();
+        return uri;
     }
 
-
     public T setVirtualHost(String virtualHost) {
         request.virtualHost = virtualHost;
         return derived.cast(this);
@@ -589,8 +611,8 @@ public T setFollowRedirects(boolean followRedirects) {
         return derived.cast(this);
     }
 
-    public T setPerRequestConfig(PerRequestConfig perRequestConfig) {
-        request.perRequestConfig = perRequestConfig;
+    public T setRequestTimeoutInMs(int requestTimeoutInMs) {
+        request.requestTimeoutInMs = requestTimeoutInMs;
         return derived.cast(this);
     }
 
@@ -610,8 +632,8 @@ public T setBodyEncoding(String charset) {
     }
 
     public T setConnectionPoolKeyStrategy(ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
-    	request.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
-    	return derived.cast(this);
+        request.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
+        return derived.cast(this);
     }
 
     public Request build() {
@@ -631,13 +653,7 @@ public Request build() {
     }
 
     private boolean allowBody(String method) {
-        if (method.equalsIgnoreCase("GET") || method.equalsIgnoreCase("OPTIONS")
-                && method.equalsIgnoreCase("TRACE")
-                && method.equalsIgnoreCase("HEAD")) {
-            return false;
-        } else {
-            return true;
-        }
+        return !(method.equalsIgnoreCase("GET") || method.equalsIgnoreCase("OPTIONS") || method.equalsIgnoreCase("TRACE") || method.equalsIgnoreCase("HEAD"));
     }
 
     public T addOrReplaceCookie(Cookie cookie) {
diff --git a/api/src/main/java/com/ning/http/client/Response.java b/api/src/main/java/org/asynchttpclient/Response.java
similarity index 81%
rename from api/src/main/java/com/ning/http/client/Response.java
rename to api/src/main/java/org/asynchttpclient/Response.java
index e245247cd..3db376606 100644
--- a/api/src/main/java/com/ning/http/client/Response.java
+++ b/api/src/main/java/org/asynchttpclient/Response.java
@@ -14,18 +14,19 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URI;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * Represents the asynchronous HTTP response callback for an {@link com.ning.http.client.AsyncCompletionHandler}
+ * Represents the asynchronous HTTP response callback for an {@link AsyncCompletionHandler}
  */
 public interface Response {
     /**
@@ -33,14 +34,14 @@
      *
      * @return The status code
      */
-    public int getStatusCode();
+    int getStatusCode();
 
     /**
      * Returns the status text for the request.
      *
      * @return The status text
      */
-    public String getStatusText();
+    String getStatusText();
 
     /**
      * Return the entire response body as a byte[].
@@ -48,7 +49,15 @@
      * @return the entire response body as a byte[].
      * @throws IOException
      */
-    public byte[] getResponseBodyAsBytes() throws IOException;
+    byte[] getResponseBodyAsBytes() throws IOException;
+    
+    /**
+     * Return the entire response body as a ByteBuffer.
+     *
+     * @return the entire response body as a ByteBuffer.
+     * @throws IOException
+     */
+    ByteBuffer getResponseBodyAsByteBuffer() throws IOException;
 
     /**
      * Returns an input stream for the response body. Note that you should not try to get this more than once,
@@ -57,7 +66,7 @@
      * @return The input stream
      * @throws java.io.IOException
      */
-    public InputStream getResponseBodyAsStream() throws IOException;
+    InputStream getResponseBodyAsStream() throws IOException;
 
     /**
      * Returns the first maxLength bytes of the response body as a string. Note that this does not check
@@ -69,7 +78,7 @@
      * @return The response body
      * @throws java.io.IOException
      */
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException;
+    String getResponseBodyExcerpt(int maxLength, String charset) throws IOException;
 
     /**
      * Return the entire response body as a String.
@@ -78,7 +87,7 @@
      * @return the entire response body as a String.
      * @throws IOException
      */
-    public String getResponseBody(String charset) throws IOException;
+    String getResponseBody(String charset) throws IOException;
 
     /**
      * Returns the first maxLength bytes of the response body as a string. Note that this does not check
@@ -89,7 +98,7 @@
      * @return The response body
      * @throws java.io.IOException
      */
-    public String getResponseBodyExcerpt(int maxLength) throws IOException;
+    String getResponseBodyExcerpt(int maxLength) throws IOException;
 
     /**
      * Return the entire response body as a String.
@@ -97,7 +106,7 @@
      * @return the entire response body as a String.
      * @throws IOException
      */
-    public String getResponseBody() throws IOException;
+    String getResponseBody() throws IOException;
 
     /**
      * Return the request {@link URI}. Note that if the request got redirected, the value of the {@link URI} will be
@@ -106,30 +115,30 @@
      * @return the request {@link URI}.
      * @throws MalformedURLException
      */
-    public URI getUri() throws MalformedURLException;
+    URI getUri() throws MalformedURLException;
 
     /**
      * Return the content-type header value.
      *
      * @return the content-type header value.
      */
-    public String getContentType();
+    String getContentType();
 
     /**
      * Return the response header
      *
      * @return the response header
      */
-    public String getHeader(String name);
+    String getHeader(String name);
 
     /**
      * Return a {@link List} of the response header value.
      *
      * @return the response header
      */
-    public List<String> getHeaders(String name);
+    List<String> getHeaders(String name);
 
-    public FluentCaseInsensitiveStringsMap getHeaders();
+    FluentCaseInsensitiveStringsMap getHeaders();
 
     /**
      * Return true if the response redirects to another object.
@@ -143,38 +152,37 @@
      *
      * @return The textual representation
      */
-    public String toString();
+    String toString();
 
     /**
      * Return the list of {@link Cookie}.
      */
-    public List<Cookie> getCookies();
+    List<Cookie> getCookies();
 
     /**
      * Return true if the response's status has been computed by an {@link AsyncHandler}
      *
      * @return true if the response's status has been computed by an {@link AsyncHandler}
      */
-    public boolean hasResponseStatus();
+    boolean hasResponseStatus();
 
     /**
      * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the
-     * either {@link com.ning.http.client.AsyncHandler#onStatusReceived(HttpResponseStatus)}
-     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link com.ning.http.client.AsyncHandler.STATE#ABORT}
+     * either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
+     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
      *
      * @return true if the response's headers has been computed by an {@link AsyncHandler}
      */
-    public boolean hasResponseHeaders();
+    boolean hasResponseHeaders();
 
     /**
      * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the
-     * either {@link com.ning.http.client.AsyncHandler#onStatusReceived(HttpResponseStatus)}
-     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link com.ning.http.client.AsyncHandler.STATE#ABORT}
+     * either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
+     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
      *
      * @return true if the response's body has been computed by an {@link AsyncHandler}
      */
-    public boolean hasResponseBody();
-
+    boolean hasResponseBody();
 
     public static class ResponseBuilder {
         private final List<HttpResponseBodyPart> bodies =
diff --git a/api/src/main/java/com/ning/http/client/ResumableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/ResumableBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
index 018bd648e..4fa002590 100644
--- a/api/src/main/java/com/ning/http/client/ResumableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
@@ -11,7 +11,7 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/com/ning/http/client/SSLEngineFactory.java b/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/SSLEngineFactory.java
rename to api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
index 1e5fc5873..394ab9bfe 100644
--- a/api/src/main/java/com/ning/http/client/SSLEngineFactory.java
+++ b/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 import javax.net.ssl.SSLEngine;
 import java.security.GeneralSecurityException;
diff --git a/api/src/main/java/com/ning/http/client/SignatureCalculator.java b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/SignatureCalculator.java
rename to api/src/main/java/org/asynchttpclient/SignatureCalculator.java
index 8c31cc8d0..baa96ba3c 100644
--- a/api/src/main/java/com/ning/http/client/SignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * Interface that allows injecting signature calculator into
diff --git a/api/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
rename to api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
index 719375301..ccbb0f2aa 100644
--- a/api/src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
@@ -10,16 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.resumable.ResumableAsyncHandler;
-import com.ning.http.client.resumable.ResumableIOExceptionFilter;
-import com.ning.http.client.simple.HeaderMap;
-import com.ning.http.client.simple.SimpleAHCTransferListener;
+import org.asynchttpclient.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.resumable.ResumableIOExceptionFilter;
+import org.asynchttpclient.simple.HeaderMap;
+import org.asynchttpclient.simple.SimpleAHCTransferListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.net.ssl.SSLContext;
+
+import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Map;
@@ -28,8 +30,8 @@
 import java.util.concurrent.ScheduledExecutorService;
 
 /**
- * Simple implementation of {@link AsyncHttpClient} and it's related builders ({@link com.ning.http.client.AsyncHttpClientConfig},
- * {@link Realm}, {@link com.ning.http.client.ProxyServer} and {@link com.ning.http.client.AsyncHandler}. You can
+ * Simple implementation of {@link AsyncHttpClient} and it's related builders ({@link AsyncHttpClientConfig},
+ * {@link Realm}, {@link ProxyServer} and {@link AsyncHandler}. You can
  * build powerful application by just using this class.
  * <p/>
  * This class rely on {@link BodyGenerator} and {@link BodyConsumer} for handling the request and response body. No
@@ -57,7 +59,7 @@
  * Future<Response> future = client.post(new FileodyGenerator(myFile), new OutputStreamBodyConsumer(o));
  * </pre></blockquote>
  */
-public class SimpleAsyncHttpClient {
+public class SimpleAsyncHttpClient implements Closeable {
 
     private final static Logger logger = LoggerFactory.getLogger(SimpleAsyncHttpClient.class);
     private final AsyncHttpClientConfig config;
@@ -688,15 +690,15 @@ public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHand
             this.delegate = delegate;
         }
 
-        public com.ning.http.client.AsyncHandler.STATE onHeaderWriteCompleted() {
+        public AsyncHandler.STATE onHeaderWriteCompleted() {
             return delegate.onHeaderWriteCompleted();
         }
 
-        public com.ning.http.client.AsyncHandler.STATE onContentWriteCompleted() {
+        public AsyncHandler.STATE onContentWriteCompleted() {
             return delegate.onContentWriteCompleted();
         }
 
-        public com.ning.http.client.AsyncHandler.STATE onContentWriteProgress(long amount, long current, long total) {
+        public AsyncHandler.STATE onContentWriteProgress(long amount, long current, long total) {
             return delegate.onContentWriteProgress(amount, current, total);
         }
     }
diff --git a/api/src/main/java/com/ning/http/client/StringPart.java b/api/src/main/java/org/asynchttpclient/StringPart.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/StringPart.java
rename to api/src/main/java/org/asynchttpclient/StringPart.java
index acdb49b19..cd0c617c5 100644
--- a/api/src/main/java/com/ning/http/client/StringPart.java
+++ b/api/src/main/java/org/asynchttpclient/StringPart.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * A string multipart part.
diff --git a/api/src/main/java/com/ning/http/client/ThrowableHandler.java b/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/ThrowableHandler.java
rename to api/src/main/java/org/asynchttpclient/ThrowableHandler.java
index 5f017fd4b..cbafe5901 100644
--- a/api/src/main/java/com/ning/http/client/ThrowableHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
@@ -11,7 +11,7 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
  * Simple {@link Throwable} handler to be used with {@link SimpleAsyncHttpClient}
diff --git a/api/src/main/java/com/ning/http/client/UpgradeHandler.java b/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/UpgradeHandler.java
rename to api/src/main/java/org/asynchttpclient/UpgradeHandler.java
index 861e3abe0..9ed5e4a7b 100644
--- a/api/src/main/java/com/ning/http/client/UpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
 /**
- * Invoked when an {@link AsyncHandler.STATE#UPGRADE} is returned. Currently the library only support {@link com.ning.http.client.websocket.WebSocket}
+ * Invoked when an {@link AsyncHandler.STATE#UPGRADE} is returned. Currently the library only support {@link org.asynchttpclient.websocket.WebSocket}
  * as type.
  *
  * @param <T>
diff --git a/api/src/main/java/com/ning/http/client/consumers/AppendableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
similarity index 80%
rename from api/src/main/java/com/ning/http/client/consumers/AppendableBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
index bbd03d887..c69ac0698 100644
--- a/api/src/main/java/com/ning/http/client/consumers/AppendableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.consumers;
+package org.asynchttpclient.consumers;
 
-import com.ning.http.client.BodyConsumer;
+import org.asynchttpclient.BodyConsumer;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -41,7 +41,10 @@ public AppendableBodyConsumer(Appendable appendable) {
      */
     /* @Override */
     public void consume(ByteBuffer byteBuffer) throws IOException {
-        appendable.append(new String(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.remaining(), encoding));
+        appendable.append(new String(byteBuffer.array(),
+                                     byteBuffer.arrayOffset() + byteBuffer.position(),
+                                     byteBuffer.remaining(),
+                                     encoding));
     }
 
     /**
diff --git a/api/src/main/java/com/ning/http/client/consumers/ByteBufferBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/consumers/ByteBufferBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
index e1d07bbaa..8ab464122 100644
--- a/api/src/main/java/com/ning/http/client/consumers/ByteBufferBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.consumers;
+package org.asynchttpclient.consumers;
 
-import com.ning.http.client.BodyConsumer;
+import org.asynchttpclient.BodyConsumer;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/com/ning/http/client/consumers/FileBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
similarity index 84%
rename from api/src/main/java/com/ning/http/client/consumers/FileBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
index ad8b7e288..531228bcc 100644
--- a/api/src/main/java/com/ning/http/client/consumers/FileBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.consumers;
+package org.asynchttpclient.consumers;
 
-import com.ning.http.client.ResumableBodyConsumer;
+import org.asynchttpclient.ResumableBodyConsumer;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -35,7 +35,9 @@ public FileBodyConsumer(RandomAccessFile file) {
     /* @Override */
     public void consume(ByteBuffer byteBuffer) throws IOException {
         // TODO: Channel.transferFrom may be a good idea to investigate.
-        file.write(byteBuffer.array());
+        file.write(byteBuffer.array(),
+                   byteBuffer.arrayOffset() + byteBuffer.position(),
+                   byteBuffer.remaining());
     }
 
     /**
diff --git a/api/src/main/java/com/ning/http/client/consumers/OutputStreamBodyConsumer.java b/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
similarity index 80%
rename from api/src/main/java/com/ning/http/client/consumers/OutputStreamBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
index 324fd08d3..7ab4d1184 100644
--- a/api/src/main/java/com/ning/http/client/consumers/OutputStreamBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.consumers;
+package org.asynchttpclient.consumers;
 
-import com.ning.http.client.BodyConsumer;
+import org.asynchttpclient.BodyConsumer;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -34,7 +34,9 @@ public OutputStreamBodyConsumer(OutputStream outputStream) {
      */
     /* @Override */
     public void consume(ByteBuffer byteBuffer) throws IOException {
-        outputStream.write(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.remaining());
+        outputStream.write(byteBuffer.array(),
+                           byteBuffer.arrayOffset() + byteBuffer.position(),
+                           byteBuffer.remaining());
     }
 
     /**
diff --git a/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
new file mode 100644
index 000000000..fcbce72bc
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
@@ -0,0 +1,73 @@
+package org.asynchttpclient.extra;
+
+import java.util.concurrent.Semaphore;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class AsyncHandlerWrapper<T> implements AsyncHandler<T> {
+
+	private final static Logger logger = LoggerFactory.getLogger(AsyncHandlerWrapper.class);
+	private final AsyncHandler<T> asyncHandler;
+	private final Semaphore available;
+
+	public AsyncHandlerWrapper(AsyncHandler<T> asyncHandler, Semaphore available) {
+		this.asyncHandler = asyncHandler;
+		this.available = available;
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public void onThrowable(Throwable t) {
+		try {
+			asyncHandler.onThrowable(t);
+		} finally {
+			available.release();
+			if (logger.isDebugEnabled()) {
+				logger.debug("Current Throttling Status after onThrowable {}", available.availablePermits());
+			}
+		}
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+		return asyncHandler.onBodyPartReceived(bodyPart);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+		return asyncHandler.onStatusReceived(responseStatus);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+		return asyncHandler.onHeadersReceived(headers);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public T onCompleted() throws Exception {
+		available.release();
+		if (logger.isDebugEnabled()) {
+			logger.debug("Current Throttling Status {}", available.availablePermits());
+		}
+		return asyncHandler.onCompleted();
+	}
+}
\ No newline at end of file
diff --git a/api/src/main/java/com/ning/http/client/extra/ResumableRandomAccessFileListener.java b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
similarity index 88%
rename from api/src/main/java/com/ning/http/client/extra/ResumableRandomAccessFileListener.java
rename to api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
index e823e8d18..546b59a11 100644
--- a/api/src/main/java/com/ning/http/client/extra/ResumableRandomAccessFileListener.java
+++ b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
@@ -10,16 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.extra;
+package org.asynchttpclient.extra;
 
-import com.ning.http.client.resumable.ResumableListener;
+import org.asynchttpclient.resumable.ResumableListener;
+import org.asynchttpclient.resumable.ResumableListener;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
 /**
- * A {@link com.ning.http.client.listener.TransferListener} which use a {@link RandomAccessFile} for storing the received bytes.
+ * A {@link org.asynchttpclient.listener.TransferListener} which use a {@link RandomAccessFile} for storing the received bytes.
  */
 public class ResumableRandomAccessFileListener implements ResumableListener {
     private final RandomAccessFile file;
diff --git a/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
new file mode 100644
index 000000000..2dcb6087e
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extra;
+
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.RequestFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A {@link org.asynchttpclient.filter.RequestFilter} throttles requests and block when the number of permits is reached, waiting for
+ * the response to arrives before executing the next request.
+ */
+public class ThrottleRequestFilter implements RequestFilter {
+	private final static Logger logger = LoggerFactory.getLogger(ThrottleRequestFilter.class);
+	private final Semaphore available;
+	private final int maxWait;
+
+	public ThrottleRequestFilter(int maxConnections) {
+		this(maxConnections, Integer.MAX_VALUE);
+	}
+
+	public ThrottleRequestFilter(int maxConnections, int maxWait) {
+		this.maxWait = maxWait;
+		available = new Semaphore(maxConnections, true);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	/* @Override */
+	public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+
+		try {
+			if (logger.isDebugEnabled()) {
+				logger.debug("Current Throttling Status {}", available.availablePermits());
+			}
+			if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS)) {
+				throw new FilterException(String.format(
+						"No slot available for processing Request %s with AsyncHandler %s", ctx.getRequest(),
+						ctx.getAsyncHandler()));
+			}
+		} catch (InterruptedException e) {
+			throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(),
+					ctx.getAsyncHandler()));
+		}
+
+		return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(
+				new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available)).build();
+	}
+}
\ No newline at end of file
diff --git a/api/src/main/java/com/ning/http/client/filter/FilterContext.java b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
similarity index 92%
rename from api/src/main/java/com/ning/http/client/filter/FilterContext.java
rename to api/src/main/java/org/asynchttpclient/filter/FilterContext.java
index 29228b725..5a5dc1400 100644
--- a/api/src/main/java/com/ning/http/client/filter/FilterContext.java
+++ b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.filter;
+package org.asynchttpclient.filter;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Request;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
 
 import java.io.IOException;
 
@@ -26,9 +26,9 @@
  * gets invoked before the response gets processed, e.g. before authorization, redirection and invokation of {@link AsyncHandler}
  * gets processed.
  * <p/>
- * Invoking {@link com.ning.http.client.filter.FilterContext#getResponseStatus()} returns an instance of {@link HttpResponseStatus}
+ * Invoking {@link FilterContext#getResponseStatus()} returns an instance of {@link HttpResponseStatus}
  * that can be used to decide if the response processing should continue or not. You can stop the current response processing
- * and replay the request but creating a {@link FilterContext}. The {@link com.ning.http.client.AsyncHttpProvider}
+ * and replay the request but creating a {@link FilterContext}. The {@link org.asynchttpclient.AsyncHttpProvider}
  * will interrupt the processing and "replay" the associated {@link Request} instance.
  */
 public class FilterContext<T> {
diff --git a/api/src/main/java/com/ning/http/client/filter/FilterException.java b/api/src/main/java/org/asynchttpclient/filter/FilterException.java
similarity index 88%
rename from api/src/main/java/com/ning/http/client/filter/FilterException.java
rename to api/src/main/java/org/asynchttpclient/filter/FilterException.java
index b467dd4c7..739ecf774 100644
--- a/api/src/main/java/com/ning/http/client/filter/FilterException.java
+++ b/api/src/main/java/org/asynchttpclient/filter/FilterException.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.filter;
+package org.asynchttpclient.filter;
 
 /**
- * An exception that can be thrown by an {@link com.ning.http.client.AsyncHandler} to interrupt invocation of
+ * An exception that can be thrown by an {@link org.asynchttpclient.AsyncHandler} to interrupt invocation of
  * the {@link RequestFilter} and {@link ResponseFilter}. It also interrupt the request and response processing.
  */
 @SuppressWarnings("serial")
diff --git a/api/src/main/java/com/ning/http/client/filter/IOExceptionFilter.java b/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
similarity index 85%
rename from api/src/main/java/com/ning/http/client/filter/IOExceptionFilter.java
rename to api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
index eb0a0fd23..947314627 100644
--- a/api/src/main/java/com/ning/http/client/filter/IOExceptionFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/IOExceptionFilter.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.filter;
+package org.asynchttpclient.filter;
 
 /**
  * This filter is invoked when an {@link java.io.IOException} occurs during an http transaction.
@@ -18,8 +18,8 @@
 public interface IOExceptionFilter {
 
     /**
-     * An {@link com.ning.http.client.AsyncHttpProvider} will invoke {@link IOExceptionFilter#filter} and will
-     * use the returned {@link FilterContext} to replay the {@link com.ning.http.client.Request} or abort the processing.
+     * An {@link org.asynchttpclient.AsyncHttpProvider} will invoke {@link IOExceptionFilter#filter} and will
+     * use the returned {@link FilterContext} to replay the {@link org.asynchttpclient.Request} or abort the processing.
      *
      * @param ctx a {@link FilterContext}
      * @return {@link FilterContext}. The {@link FilterContext} instance may not the same as the original one.
diff --git a/api/src/main/java/com/ning/http/client/filter/RequestFilter.java b/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
similarity index 89%
rename from api/src/main/java/com/ning/http/client/filter/RequestFilter.java
rename to api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
index 552cadd08..520db598c 100644
--- a/api/src/main/java/com/ning/http/client/filter/RequestFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/RequestFilter.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.filter;
+package org.asynchttpclient.filter;
 
 /**
  * A Filter interface that gets invoked before making an actual request.
@@ -18,7 +18,7 @@
 public interface RequestFilter {
 
     /**
-     * An {@link com.ning.http.client.AsyncHttpProvider} will invoke {@link RequestFilter#filter} and will use the
+     * An {@link org.asynchttpclient.AsyncHttpProvider} will invoke {@link RequestFilter#filter} and will use the
      * returned {@link FilterContext#getRequest()} and {@link FilterContext#getAsyncHandler()} to continue the request
      * processing.
      *
diff --git a/api/src/main/java/com/ning/http/client/filter/ResponseFilter.java b/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
similarity index 91%
rename from api/src/main/java/com/ning/http/client/filter/ResponseFilter.java
rename to api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
index c77aea30d..8c26bcca9 100644
--- a/api/src/main/java/com/ning/http/client/filter/ResponseFilter.java
+++ b/api/src/main/java/org/asynchttpclient/filter/ResponseFilter.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.filter;
+package org.asynchttpclient.filter;
 
 /**
  * A Filter interface that gets invoked before making the processing of the response bytes. {@link ResponseFilter} are invoked
@@ -20,7 +20,7 @@
 public interface ResponseFilter {
 
     /**
-     * An {@link com.ning.http.client.AsyncHttpProvider} will invoke {@link ResponseFilter#filter} and will use the
+     * An {@link org.asynchttpclient.AsyncHttpProvider} will invoke {@link ResponseFilter#filter} and will use the
      * returned {@link FilterContext#replayRequest()} and {@link FilterContext#getAsyncHandler()} to decide if the response
      * processing can continue. If {@link FilterContext#replayRequest()} return true, a new request will be made
      * using {@link FilterContext#getRequest()} and the current response processing will be ignored.
diff --git a/api/src/main/java/com/ning/http/client/generators/ByteArrayBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/generators/ByteArrayBodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
index c56893d0a..0ff4a346e 100644
--- a/api/src/main/java/com/ning/http/client/generators/ByteArrayBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.generators;
+package org.asynchttpclient.generators;
 
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/com/ning/http/client/generators/FileBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/generators/FileBodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
index c1ff9ef88..dd6e88dbf 100644
--- a/api/src/main/java/com/ning/http/client/generators/FileBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.generators;
+package org.asynchttpclient.generators;
 
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.RandomAccessBody;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.RandomAccessBody;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/api/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
index 12660ca43..797b93af3 100644
--- a/api/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
@@ -11,10 +11,10 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.generators;
+package org.asynchttpclient.generators;
 
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -43,7 +43,7 @@ public InputStreamBodyGenerator(InputStream inputStream) {
         if (inputStream.markSupported()) {
             inputStream.mark(0);
         } else {
-            logger.warn("inputStream.markSupported() not supported. Some features will not works");
+            logger.info("inputStream.markSupported() not supported. Some features will not works");
         }
     }
 
diff --git a/api/src/main/java/com/ning/http/client/listenable/AbstractListenableFuture.java b/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/listenable/AbstractListenableFuture.java
rename to api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
index a0f9575e6..031775284 100644
--- a/api/src/main/java/com/ning/http/client/listenable/AbstractListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
@@ -26,9 +26,9 @@
  * limitations under the License.
  */
 
-package com.ning.http.client.listenable;
+package org.asynchttpclient.listenable;
 
-import com.ning.http.client.ListenableFuture;
+import org.asynchttpclient.ListenableFuture;
 
 import java.util.concurrent.Executor;
 
diff --git a/api/src/main/java/com/ning/http/client/listenable/ExecutionList.java b/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
similarity index 99%
rename from api/src/main/java/com/ning/http/client/listenable/ExecutionList.java
rename to api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
index 84d9bef13..a6e3cba83 100644
--- a/api/src/main/java/com/ning/http/client/listenable/ExecutionList.java
+++ b/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
@@ -26,7 +26,7 @@
  * limitations under the License.
  */
 
-package com.ning.http.client.listenable;
+package org.asynchttpclient.listenable;
 
 import java.util.Queue;
 import java.util.concurrent.Executor;
diff --git a/api/src/main/java/com/ning/http/client/listener/TransferCompletionHandler.java b/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
similarity index 87%
rename from api/src/main/java/com/ning/http/client/listener/TransferCompletionHandler.java
rename to api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
index 6d71cbd23..59703c258 100644
--- a/api/src/main/java/com/ning/http/client/listener/TransferCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
@@ -10,13 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.listener;
+package org.asynchttpclient.listener;
 
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.Response;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -27,7 +29,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
- * A {@link com.ning.http.client.AsyncHandler} that can be used to notify a set of {@link com.ning.http.client.listener.TransferListener}
+ * A {@link org.asynchttpclient.AsyncHandler} that can be used to notify a set of {@link TransferListener}
  * <p/>
  * <blockquote><pre>
  * AsyncHttpClient client = new AsyncHttpClient();
@@ -65,8 +67,8 @@
     private AtomicLong totalBytesToTransfer = new AtomicLong(0);
 
     /**
-     * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link com.ning.http.client.Response#getResponseBody()},
-     * {@link com.ning.http.client.Response#getResponseBodyAsStream()} and {@link Response#getResponseBodyExcerpt(int)} will
+     * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
+     * {@link org.asynchttpclient.Response#getResponseBodyAsStream()} and {@link Response#getResponseBodyExcerpt(int)} will
      * throw an IllegalStateException if called.
      */
     public TransferCompletionHandler() {
@@ -75,7 +77,7 @@ public TransferCompletionHandler() {
 
     /**
      * Create a TransferCompletionHandler that can or cannot accumulate bytes and make it available when
-     * {@link com.ning.http.client.Response#getResponseBody()} get called. The default is false.
+     * {@link org.asynchttpclient.Response#getResponseBody()} get called. The default is false.
      *
      * @param accumulateResponseBytes true to accumulates bytes in memory.
      */
@@ -84,9 +86,9 @@ public TransferCompletionHandler(boolean accumulateResponseBytes) {
     }
 
     /**
-     * Add a {@link com.ning.http.client.listener.TransferListener}
+     * Add a {@link TransferListener}
      *
-     * @param t a {@link com.ning.http.client.listener.TransferListener}
+     * @param t a {@link TransferListener}
      * @return this
      */
     public TransferCompletionHandler addTransferListener(TransferListener t) {
@@ -95,9 +97,9 @@ public TransferCompletionHandler addTransferListener(TransferListener t) {
     }
 
     /**
-     * Remove a {@link com.ning.http.client.listener.TransferListener}
+     * Remove a {@link TransferListener}
      *
-     * @param t a {@link com.ning.http.client.listener.TransferListener}
+     * @param t a {@link TransferListener}
      * @return this
      */
     public TransferCompletionHandler removeTransferListener(TransferListener t) {
@@ -106,7 +108,7 @@ public TransferCompletionHandler removeTransferListener(TransferListener t) {
     }
 
     /**
-     * Associate a {@link com.ning.http.client.listener.TransferCompletionHandler.TransferAdapter} with this listener.
+     * Associate a {@link TransferCompletionHandler.TransferAdapter} with this listener.
      *
      * @param transferAdapter {@link TransferAdapter}
      */
@@ -144,7 +146,7 @@ public Response onCompleted(Response response) throws Exception {
      */
     public STATE onHeaderWriteCompleted() {
         List<String> list = transferAdapter.getHeaders().get("Content-Length");
-        if (list != null && list.size() > 0 && list.get(0) != "") {
+        if (isNonEmpty(list) && list.get(0).length() != 0) {
             totalBytesToTransfer.set(Long.valueOf(list.get(0)));
         }
 
diff --git a/api/src/main/java/com/ning/http/client/listener/TransferListener.java b/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/listener/TransferListener.java
rename to api/src/main/java/org/asynchttpclient/listener/TransferListener.java
index 580c3cba5..7ae234446 100644
--- a/api/src/main/java/com/ning/http/client/listener/TransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.listener;
+package org.asynchttpclient.listener;
 
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/com/ning/http/multipart/ByteArrayPartSource.java b/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java
similarity index 97%
rename from api/src/main/java/com/ning/http/multipart/ByteArrayPartSource.java
rename to api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java
index 80ae3f59e..62b218d3d 100644
--- a/api/src/main/java/com/ning/http/multipart/ByteArrayPartSource.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPartSource.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
diff --git a/api/src/main/java/com/ning/http/multipart/FilePart.java b/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
similarity index 65%
rename from api/src/main/java/com/ning/http/multipart/FilePart.java
rename to api/src/main/java/org/asynchttpclient/multipart/FilePart.java
index 5548085f0..6cbab86a5 100644
--- a/api/src/main/java/com/ning/http/multipart/FilePart.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -23,7 +23,7 @@
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
 public class FilePart extends PartBase {
@@ -51,43 +51,40 @@
     /**
      * Attachment's file name as a byte array
      */
-    private static final byte[] FILE_NAME_BYTES =
-            MultipartEncodingUtil.getAsciiBytes(FILE_NAME);
+    private static final byte[] FILE_NAME_BYTES = MultipartEncodingUtil.getAsciiBytes(FILE_NAME);
 
     /**
      * Source of the file part.
      */
-    private PartSource source;
+    private final PartSource source;
 
     /**
      * FilePart Constructor.
-     *
-     * @param name        the name for this part
-     * @param partSource  the source for this part
-     * @param contentType the content type for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset     the charset encoding for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CHARSET default} is used
+     * 
+     * @param name the name for this part
+     * @param partSource the source for this part
+     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
+     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
+     * @param contentId
      */
-    public FilePart(String name, PartSource partSource, String contentType, String charset) {
+    public FilePart(String name, PartSource partSource, String contentType, String charset, String contentId) {
 
-        super(
-                name,
-                contentType == null ? DEFAULT_CONTENT_TYPE : contentType,
-                charset == null ? "ISO-8859-1" : charset,
-                DEFAULT_TRANSFER_ENCODING
-        );
+        super(name, contentType == null ? DEFAULT_CONTENT_TYPE : contentType, charset == null ? "ISO-8859-1" : charset, DEFAULT_TRANSFER_ENCODING, contentId);
 
         if (partSource == null) {
             throw new IllegalArgumentException("Source may not be null");
         }
         this.source = partSource;
     }
+    
+    public FilePart(String name, PartSource partSource, String contentType, String charset) {
+        this(name, partSource, contentType, charset, null);
+    }
 
     /**
      * FilePart Constructor.
-     *
-     * @param name       the name for this part
+     * 
+     * @param name the name for this part
      * @param partSource the source for this part
      */
     public FilePart(String name, PartSource partSource) {
@@ -96,77 +93,64 @@ public FilePart(String name, PartSource partSource) {
 
     /**
      * FilePart Constructor.
-     *
+     * 
      * @param name the name of the file part
      * @param file the file to post
-     * @throws java.io.FileNotFoundException if the <i>file</i> is not a normal
-     *                                       file or if it is not readable.
+     * @throws java.io.FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
      */
-    public FilePart(String name, File file)
-            throws FileNotFoundException {
+    public FilePart(String name, File file) throws FileNotFoundException {
         this(name, new FilePartSource(file), null, null);
     }
 
     /**
      * FilePart Constructor.
-     *
-     * @param name        the name of the file part
-     * @param file        the file to post
-     * @param contentType the content type for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset     the charset encoding for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CHARSET default} is used
-     * @throws FileNotFoundException if the <i>file</i> is not a normal
-     *                               file or if it is not readable.
-     */
-    public FilePart(String name, File file, String contentType, String charset)
-            throws FileNotFoundException {
+     * 
+     * @param name the name of the file part
+     * @param file the file to post
+     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
+     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
+     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
+     */
+    public FilePart(String name, File file, String contentType, String charset) throws FileNotFoundException {
         this(name, new FilePartSource(file), contentType, charset);
     }
 
     /**
      * FilePart Constructor.
-     *
-     * @param name     the name of the file part
+     * 
+     * @param name the name of the file part
      * @param fileName the file name
-     * @param file     the file to post
-     * @throws FileNotFoundException if the <i>file</i> is not a normal
-     *                               file or if it is not readable.
+     * @param file the file to post
+     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
      */
-    public FilePart(String name, String fileName, File file)
-            throws FileNotFoundException {
+    public FilePart(String name, String fileName, File file) throws FileNotFoundException {
         this(name, new FilePartSource(fileName, file), null, null);
     }
 
     /**
      * FilePart Constructor.
-     *
-     * @param name        the name of the file part
-     * @param fileName    the file name
-     * @param file        the file to post
-     * @param contentType the content type for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CONTENT_TYPE default} is used
-     * @param charset     the charset encoding for this part, if <code>null</code> the
-     *                    {@link #DEFAULT_CHARSET default} is used
-     * @throws FileNotFoundException if the <i>file</i> is not a normal
-     *                               file or if it is not readable.
-     */
-    public FilePart(String name, String fileName, File file, String contentType, String charset)
-            throws FileNotFoundException {
+     * 
+     * @param name the name of the file part
+     * @param fileName the file name
+     * @param file the file to post
+     * @param contentType the content type for this part, if <code>null</code> the {@link #DEFAULT_CONTENT_TYPE default} is used
+     * @param charset the charset encoding for this part, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
+     * @throws FileNotFoundException if the <i>file</i> is not a normal file or if it is not readable.
+     */
+    public FilePart(String name, String fileName, File file, String contentType, String charset) throws FileNotFoundException {
         this(name, new FilePartSource(fileName, file), contentType, charset);
     }
 
     /**
      * Write the disposition header to the output stream
-     *
+     * 
      * @param out The output stream
      * @throws java.io.IOException If an IO problem occurs
      */
-    protected void sendDispositionHeader(OutputStream out)
-            throws IOException {
-        super.sendDispositionHeader(out);
+    protected void sendDispositionHeader(OutputStream out) throws IOException {
         String filename = this.source.getFileName();
         if (filename != null) {
+            super.sendDispositionHeader(out);
             out.write(FILE_NAME_BYTES);
             out.write(QUOTE_BYTES);
             out.write(MultipartEncodingUtil.getAsciiBytes(filename));
@@ -176,7 +160,7 @@ protected void sendDispositionHeader(OutputStream out)
 
     /**
      * Write the data in "source" to the specified stream.
-     *
+     * 
      * @param out The output stream.
      * @throws IOException if an IO problem occurs.
      */
@@ -202,17 +186,17 @@ protected void sendData(OutputStream out) throws IOException {
         }
     }
 
-	public void setStalledTime(long ms) {
-		_stalledTime = ms;
-	}
+    public void setStalledTime(long ms) {
+        _stalledTime = ms;
+    }
 
-	public long getStalledTime() {
-		return _stalledTime;
-	}
+    public long getStalledTime() {
+        return _stalledTime;
+    }
 
     /**
      * Returns the source of the file part.
-     *
+     * 
      * @return The source.
      */
     protected PartSource getSource() {
@@ -221,7 +205,7 @@ protected PartSource getSource() {
 
     /**
      * Return the length of the data.
-     *
+     * 
      * @return The length.
      * @throws IOException if an IO problem occurs
      */
@@ -229,6 +213,6 @@ protected long lengthOfData() throws IOException {
         return source.getLength();
     }
 
-	private long _stalledTime = -1;
+    private long _stalledTime = -1;
 
 }
diff --git a/api/src/main/java/com/ning/http/multipart/FilePartSource.java b/api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java
similarity index 77%
rename from api/src/main/java/com/ning/http/multipart/FilePartSource.java
rename to api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java
index f3b28add1..0e9a74991 100644
--- a/api/src/main/java/com/ning/http/multipart/FilePartSource.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FilePartSource.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -24,7 +24,7 @@
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
 public class FilePartSource implements PartSource {
@@ -41,22 +41,19 @@
 
     /**
      * Constructor for FilePartSource.
-     *
+     * 
      * @param file the FilePart source File.
-     * @throws java.io.FileNotFoundException if the file does not exist or
-     *                                       cannot be read
+     * @throws java.io.FileNotFoundException if the file does not exist or cannot be read
      */
     public FilePartSource(File file) throws FileNotFoundException {
         this.file = file;
         if (file != null) {
             if (!file.isFile()) {
-                final String errorMessage = 
-                    String.format("File is not a normal file (%s).", file.getAbsolutePath());
+                final String errorMessage = String.format("File is not a normal file (%s).", file.getAbsolutePath());
                 throw new FileNotFoundException(errorMessage);
             }
             if (!file.canRead()) {
-                final String errorMessage = 
-                    String.format("File is not readable (%s).", file.getAbsolutePath());
+                final String errorMessage = String.format("File is not readable (%s).", file.getAbsolutePath());
                 throw new FileNotFoundException(errorMessage);
             }
             this.fileName = file.getName();
@@ -65,23 +62,19 @@ public FilePartSource(File file) throws FileNotFoundException {
 
     /**
      * Constructor for FilePartSource.
-     *
+     * 
      * @param fileName the file name of the FilePart
-     * @param file     the source File for the FilePart
-     * @throws FileNotFoundException if the file does not exist or
-     *                               cannot be read
+     * @param file the source File for the FilePart
+     * @throws FileNotFoundException if the file does not exist or cannot be read
      */
-    public FilePartSource(String fileName, File file)
-            throws FileNotFoundException {
+    public FilePartSource(String fileName, File file) throws FileNotFoundException {
         this(file);
-        if (fileName != null) {
-            this.fileName = fileName;
-        }
+        this.fileName = fileName;
     }
 
     /**
      * Return the length of the file
-     *
+     * 
      * @return the length of the file.
      * @see PartSource#getLength()
      */
@@ -95,17 +88,17 @@ public long getLength() {
 
     /**
      * Return the current filename
-     *
+     * 
      * @return the filename.
      * @see PartSource#getFileName()
      */
     public String getFileName() {
-        return (fileName == null) ? "noname" : fileName;
+        return fileName;
     }
 
     /**
      * Return a new {@link java.io.FileInputStream} for the current filename.
-     *
+     * 
      * @return the new input stream.
      * @throws java.io.IOException If an IO problem occurs.
      * @see PartSource#createInputStream()
@@ -114,7 +107,7 @@ public InputStream createInputStream() throws IOException {
         if (this.file != null) {
             return new FileInputStream(this.file);
         } else {
-            return new ByteArrayInputStream(new byte[]{});
+            return new ByteArrayInputStream(new byte[] {});
         }
     }
 
@@ -122,5 +115,4 @@ public File getFile() {
         return file;
     }
 
-
 }
diff --git a/api/src/main/java/com/ning/http/multipart/FilePartStallHandler.java b/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
similarity index 97%
rename from api/src/main/java/com/ning/http/multipart/FilePartStallHandler.java
rename to api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
index 460aea8b6..d52db46af 100644
--- a/api/src/main/java/com/ning/http/multipart/FilePartStallHandler.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.util.Timer;
 import java.util.TimerTask;
diff --git a/api/src/main/java/com/ning/http/multipart/FileUploadStalledException.java b/api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java
similarity index 95%
rename from api/src/main/java/com/ning/http/multipart/FileUploadStalledException.java
rename to api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java
index 1533027fd..031f9354a 100644
--- a/api/src/main/java/com/ning/http/multipart/FileUploadStalledException.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java
@@ -10,7 +10,7 @@
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/com/ning/http/multipart/MultipartBody.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
similarity index 92%
rename from api/src/main/java/com/ning/http/multipart/MultipartBody.java
rename to api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
index fe97ed8c1..97a998f8b 100644
--- a/api/src/main/java/com/ning/http/multipart/MultipartBody.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
@@ -10,10 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
-import com.ning.http.client.RandomAccessBody;
+import org.asynchttpclient.RandomAccessBody;
 
+import org.asynchttpclient.ByteArrayPart;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,7 +35,7 @@
 
     private byte[] boundary;
     private long contentLength;
-    private List<com.ning.http.client.Part> parts;
+    private List<org.asynchttpclient.Part> parts;
     private List<RandomAccessFile> files;
     private int startPart;
     private final static Logger logger = LoggerFactory.getLogger(MultipartBody.class);
@@ -48,8 +49,8 @@
 
     enum FileLocation {NONE, START, MIDDLE, END}
 
-    public MultipartBody(List<com.ning.http.client.Part> parts, String boundary, String contentLength) {
-        this.boundary = MultipartEncodingUtil.getAsciiBytes(boundary.substring("multipart/form-data; boundary=".length()));
+    public MultipartBody(List<org.asynchttpclient.Part> parts, String contentType, String contentLength) {
+        this.boundary = MultipartEncodingUtil.getAsciiBytes(contentType.substring(contentType.indexOf("boundary=") + "boundary=".length()));
         this.contentLength = Long.parseLong(contentLength);
         this.parts = parts;
 
@@ -85,7 +86,7 @@ public long read(ByteBuffer buffer) throws IOException {
 
             boolean full = false;
             while (!full && !doneWritingParts) {
-                com.ning.http.client.Part part = null;
+                org.asynchttpclient.Part part = null;
                 if (startPart < parts.size()) {
                     part = parts.get(startPart);
                 }
@@ -115,7 +116,7 @@ public long read(ByteBuffer buffer) throws IOException {
                     initializeStringPart(currentPart);
 
                     startPart++;
-                } else if (part instanceof com.ning.http.client.StringPart) {
+                } else if (part instanceof org.asynchttpclient.StringPart) {
                     StringPart currentPart = generateClientStringpart(part);
 
                     initializeStringPart(currentPart);
@@ -135,7 +136,7 @@ public long read(ByteBuffer buffer) throws IOException {
                             doneWritingParts = true;
                         }
                     }
-                } else if (part instanceof com.ning.http.client.FilePart) {
+                } else if (part instanceof org.asynchttpclient.FilePart) {
                     if (fileLocation == FileLocation.NONE) {
                         currentFilePart = generateClientFilePart(part);
                         initializeFilePart(currentFilePart);
@@ -149,9 +150,9 @@ public long read(ByteBuffer buffer) throws IOException {
                             doneWritingParts = true;
                         }
                     }
-                } else if (part instanceof com.ning.http.client.ByteArrayPart) {
-                    com.ning.http.client.ByteArrayPart bytePart =
-                            (com.ning.http.client.ByteArrayPart) part;
+                } else if (part instanceof ByteArrayPart) {
+                    ByteArrayPart bytePart =
+                            (ByteArrayPart) part;
 
                     if (fileLocation == FileLocation.NONE) {
                         currentFilePart =
@@ -316,7 +317,7 @@ public long transferTo(long position, long count, WritableByteChannel target)
 
         int tempPart = startPart;
 
-        for (com.ning.http.client.Part part : parts) {
+        for (org.asynchttpclient.Part part : parts) {
             if (part instanceof Part) {
                 overallLength += handleMultiPart(target, (Part) part);
             } else {
@@ -338,18 +339,18 @@ public long transferTo(long position, long count, WritableByteChannel target)
     }
 
     private long handleClientPart(
-            WritableByteChannel target, com.ning.http.client.Part part) throws IOException {
+            WritableByteChannel target, org.asynchttpclient.Part part) throws IOException {
 
-        if (part.getClass().equals(com.ning.http.client.StringPart.class)) {
+        if (part.getClass().equals(org.asynchttpclient.StringPart.class)) {
             StringPart currentPart = generateClientStringpart(part);
 
             return handleStringPart(target, currentPart);
-        } else if (part.getClass().equals(com.ning.http.client.FilePart.class)) {
+        } else if (part.getClass().equals(org.asynchttpclient.FilePart.class)) {
             FilePart filePart = generateClientFilePart(part);
 
             return handleFilePart(target, filePart);
-        } else if (part.getClass().equals(com.ning.http.client.ByteArrayPart.class)) {
-            com.ning.http.client.ByteArrayPart bytePart = (com.ning.http.client.ByteArrayPart) part;
+        } else if (part.getClass().equals(ByteArrayPart.class)) {
+            ByteArrayPart bytePart = (ByteArrayPart) part;
 
             FilePart filePart = generateClientByteArrayPart(bytePart);
 
@@ -360,23 +361,25 @@ private long handleClientPart(
     }
 
     private FilePart generateClientByteArrayPart(
-            com.ning.http.client.ByteArrayPart bytePart) {
+            ByteArrayPart bytePart) {
         ByteArrayPartSource source = new ByteArrayPartSource(bytePart.getFileName(), bytePart.getData());
 
         FilePart filePart = new FilePart(bytePart.getName(), source, bytePart.getMimeType(), bytePart.getCharSet());
         return filePart;
     }
 
-    private FilePart generateClientFilePart(com.ning.http.client.Part part)
+    private FilePart generateClientFilePart(org.asynchttpclient.Part part)
             throws FileNotFoundException {
-        com.ning.http.client.FilePart currentPart = (com.ning.http.client.FilePart) part;
+        org.asynchttpclient.FilePart
+                currentPart = (org.asynchttpclient.FilePart) part;
 
         FilePart filePart = new FilePart(currentPart.getName(), currentPart.getFile(), currentPart.getMimeType(), currentPart.getCharSet());
         return filePart;
     }
 
-    private StringPart generateClientStringpart(com.ning.http.client.Part part) {
-        com.ning.http.client.StringPart stringPart = (com.ning.http.client.StringPart) part;
+    private StringPart generateClientStringpart(org.asynchttpclient.Part part) {
+        org.asynchttpclient.StringPart
+                stringPart = (org.asynchttpclient.StringPart) part;
 
         StringPart currentPart = new StringPart(stringPart.getName(), stringPart.getValue(), stringPart.getCharset());
         return currentPart;
@@ -430,6 +433,7 @@ private ByteArrayOutputStream generateFileStart(FilePart filePart)
         filePart.sendDispositionHeader(overhead);
         filePart.sendContentTypeHeader(overhead);
         filePart.sendTransferEncodingHeader(overhead);
+        filePart.sendContentIdHeader(overhead);
         filePart.sendEndOfHeader(overhead);
         return overhead;
     }
diff --git a/api/src/main/java/com/ning/http/multipart/MultipartEncodingUtil.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java
similarity index 98%
rename from api/src/main/java/com/ning/http/multipart/MultipartEncodingUtil.java
rename to api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java
index 1185100ec..4542f824e 100644
--- a/api/src/main/java/com/ning/http/multipart/MultipartEncodingUtil.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/MultipartEncodingUtil.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.UnsupportedEncodingException;
 
diff --git a/api/src/main/java/com/ning/http/multipart/MultipartRequestEntity.java b/api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java
similarity index 69%
rename from api/src/main/java/com/ning/http/multipart/MultipartRequestEntity.java
rename to api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java
index 0d93447a2..356bb59d0 100644
--- a/api/src/main/java/com/ning/http/multipart/MultipartRequestEntity.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/MultipartRequestEntity.java
@@ -13,9 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
-import com.ning.http.client.FluentStringsMap;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -25,7 +27,7 @@
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
 public class MultipartRequestEntity implements RequestEntity {
@@ -38,12 +40,11 @@
     /**
      * The pool of ASCII chars to be used for generating a multipart boundary.
      */
-    private static byte[] MULTIPART_CHARS = MultipartEncodingUtil.getAsciiBytes(
-            "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    private static byte[] MULTIPART_CHARS = MultipartEncodingUtil.getAsciiBytes("-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
 
     /**
      * Generates a random multipart boundary string.
-     *
+     * 
      * @return
      */
     private static byte[] generateMultipartBoundary() {
@@ -64,42 +65,35 @@
 
     private byte[] multipartBoundary;
 
-    private FluentStringsMap methodParams;
+    private final String contentType;
 
     /**
      * Creates a new multipart entity containing the given parts.
-     *
-     * @param parts        The parts to include.
-     * @param methodParams The params of the HttpMethod using this entity.
+     * 
+     * @param parts The parts to include.
+     * @param requestHeader
      */
-    public MultipartRequestEntity(Part[] parts, FluentStringsMap methodParams) {
+    public MultipartRequestEntity(Part[] parts, FluentCaseInsensitiveStringsMap requestHeaders) {
         if (parts == null) {
             throw new IllegalArgumentException("parts cannot be null");
         }
-        if (methodParams == null) {
-            methodParams = new FluentStringsMap();
-        }
+        String contentTypeHeader = requestHeaders.getFirstValue("Content-Type");
+        if (isNonEmpty(contentTypeHeader))
+            this.contentType = contentTypeHeader;
+        else
+            this.contentType = MULTIPART_FORM_CONTENT_TYPE;
         this.parts = parts;
-        this.methodParams = methodParams;
     }
 
     /**
-     * Returns the MIME boundary string that is used to demarcate boundaries of
-     * this part. The first call to this method will implicitly create a new
-     * boundary string. To create a boundary string first the
-     * HttpMethodParams.MULTIPART_BOUNDARY parameter is considered. Otherwise
-     * a random one is generated.
-     *
+     * Returns the MIME boundary string that is used to demarcate boundaries of this part. The first call to this method will implicitly create a new boundary string. To create a boundary string first the HttpMethodParams.MULTIPART_BOUNDARY parameter is considered. Otherwise a
+     * random one is generated.
+     * 
      * @return The boundary string of this entity in ASCII encoding.
      */
     protected byte[] getMultipartBoundary() {
         if (multipartBoundary == null) {
-            String temp = methodParams.get("") == null ? null : methodParams.get("").iterator().next();
-            if (temp != null) {
-                multipartBoundary = MultipartEncodingUtil.getAsciiBytes(temp);
-            } else {
-                multipartBoundary = generateMultipartBoundary();
-            }
+            multipartBoundary = generateMultipartBoundary();
         }
         return multipartBoundary;
     }
@@ -116,14 +110,18 @@ public boolean isRepeatable() {
         return true;
     }
 
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
      * @see org.apache.commons.httpclient.methods.RequestEntity#writeRequest(java.io.OutputStream)
      */
     public void writeRequest(OutputStream out) throws IOException {
         Part.sendParts(out, parts, getMultipartBoundary());
     }
 
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
      * @see org.apache.commons.httpclient.methods.RequestEntity#getContentLength()
      */
     public long getContentLength() {
@@ -135,14 +133,22 @@ public long getContentLength() {
         }
     }
 
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
      * @see org.apache.commons.httpclient.methods.RequestEntity#getContentType()
      */
     public String getContentType() {
-        StringBuffer buffer = new StringBuffer(MULTIPART_FORM_CONTENT_TYPE);
-        buffer.append("; boundary=");
-        buffer.append(MultipartEncodingUtil.getAsciiString(getMultipartBoundary()));
-        return buffer.toString();
+        if (contentType.contains("boundary="))
+            return contentType;
+        else {
+            StringBuilder buffer = new StringBuilder(contentType);
+            if (!contentType.endsWith(";"))
+                buffer.append(";");
+            buffer.append(" boundary=");
+            buffer.append(MultipartEncodingUtil.getAsciiString(getMultipartBoundary()));
+            return buffer.toString();
+        }
     }
 
 }
diff --git a/api/src/main/java/com/ning/http/multipart/Part.java b/api/src/main/java/org/asynchttpclient/multipart/Part.java
similarity index 82%
rename from api/src/main/java/com/ning/http/multipart/Part.java
rename to api/src/main/java/org/asynchttpclient/multipart/Part.java
index f1d5d3080..3d71bf524 100644
--- a/api/src/main/java/com/ning/http/multipart/Part.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/Part.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -21,10 +21,10 @@
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
-public abstract class Part implements com.ning.http.client.Part {
+public abstract class Part implements org.asynchttpclient.Part {
 
     /**
      * The boundary
@@ -32,8 +32,7 @@
     protected static final String BOUNDARY = "----------------314159265358979323846";
 
     /**
-     * The default boundary to be used if etBoundaryBytes(byte[]) has not
-     * been called.
+     * The default boundary to be used if etBoundaryBytes(byte[]) has not been called.
      */
     private static final byte[] DEFAULT_BOUNDARY_BYTES = MultipartEncodingUtil.getAsciiBytes(BOUNDARY);
 
@@ -105,12 +104,21 @@
     /**
      * Content type header as a byte array
      */
-    static final byte[] CONTENT_TRANSFER_ENCODING_BYTES =
-            MultipartEncodingUtil.getAsciiBytes(CONTENT_TRANSFER_ENCODING);
+    static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_TRANSFER_ENCODING);
+
+    /**
+     * Content type header
+     */
+    protected static final String CONTENT_ID = "Content-ID: ";
+
+    /**
+     * Content type header as a byte array
+     */
+    static final byte[] CONTENT_ID_BYTES = MultipartEncodingUtil.getAsciiBytes(CONTENT_ID);
 
     /**
      * Return the boundary string.
-     *
+     * 
      * @return the boundary string
      * @deprecated uses a constant string. Rather use {@link #getPartBoundary}
      */
@@ -125,36 +133,37 @@ public static String getBoundary() {
 
     /**
      * Return the name of this part.
-     *
+     * 
      * @return The name.
      */
     public abstract String getName();
 
     /**
      * Returns the content type of this part.
-     *
+     * 
      * @return the content type, or <code>null</code> to exclude the content type header
      */
     public abstract String getContentType();
 
     /**
      * Return the character encoding of this part.
-     *
-     * @return the character encoding, or <code>null</code> to exclude the character
-     *         encoding header
+     * 
+     * @return the character encoding, or <code>null</code> to exclude the character encoding header
      */
     public abstract String getCharSet();
 
     /**
      * Return the transfer encoding of this part.
-     *
+     * 
      * @return the transfer encoding, or <code>null</code> to exclude the transfer encoding header
      */
     public abstract String getTransferEncoding();
 
+    public abstract String getContentId();
+
     /**
      * Gets the part boundary to be used.
-     *
+     * 
      * @return the part boundary as an array of bytes.
      * @since 3.0
      */
@@ -168,10 +177,8 @@ public static String getBoundary() {
     }
 
     /**
-     * Sets the part boundary.  Only meant to be used by
-     * {@link Part#sendParts(java.io.OutputStream, Part[], byte[])}
-     * and {@link Part#getLengthOfParts(Part[], byte[])}
-     *
+     * Sets the part boundary. Only meant to be used by {@link Part#sendParts(java.io.OutputStream, Part[], byte[])} and {@link Part#getLengthOfParts(Part[], byte[])}
+     * 
      * @param boundaryBytes An array of ASCII bytes.
      * @since 3.0
      */
@@ -181,9 +188,8 @@ void setPartBoundary(byte[] boundaryBytes) {
 
     /**
      * Tests if this part can be sent more than once.
-     *
-     * @return <code>true</code> if {@link #sendData(java.io.OutputStream)} can be successfully called
-     *         more than once.
+     * 
+     * @return <code>true</code> if {@link #sendData(java.io.OutputStream)} can be successfully called more than once.
      * @since 3.0
      */
     public boolean isRepeatable() {
@@ -192,32 +198,34 @@ public boolean isRepeatable() {
 
     /**
      * Write the start to the specified output stream
-     *
+     * 
      * @param out The output stream
      * @throws java.io.IOException If an IO problem occurs.
      */
     protected void sendStart(OutputStream out) throws IOException {
         out.write(EXTRA_BYTES);
         out.write(getPartBoundary());
-        out.write(CRLF_BYTES);
     }
 
     /**
      * Write the content disposition header to the specified output stream
-     *
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
     protected void sendDispositionHeader(OutputStream out) throws IOException {
-        out.write(CONTENT_DISPOSITION_BYTES);
-        out.write(QUOTE_BYTES);
-        out.write(MultipartEncodingUtil.getAsciiBytes(getName()));
-        out.write(QUOTE_BYTES);
+        if (getName() != null) {
+            out.write(CRLF_BYTES);
+            out.write(CONTENT_DISPOSITION_BYTES);
+            out.write(QUOTE_BYTES);
+            out.write(MultipartEncodingUtil.getAsciiBytes(getName()));
+            out.write(QUOTE_BYTES);
+        }
     }
 
     /**
      * Write the content type header to the specified output stream
-     *
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -236,9 +244,8 @@ protected void sendContentTypeHeader(OutputStream out) throws IOException {
     }
 
     /**
-     * Write the content transfer encoding header to the specified
-     * output stream
-     *
+     * Write the content transfer encoding header to the specified output stream
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -251,9 +258,24 @@ protected void sendTransferEncodingHeader(OutputStream out) throws IOException {
         }
     }
 
+    /**
+     * Write the content ID header to the specified output stream
+     * 
+     * @param out The output stream
+     * @throws IOException If an IO problem occurs.
+     */
+    protected void sendContentIdHeader(OutputStream out) throws IOException {
+        String contentId = getContentId();
+        if (contentId != null) {
+            out.write(CRLF_BYTES);
+            out.write(CONTENT_ID_BYTES);
+            out.write(MultipartEncodingUtil.getAsciiBytes(contentId));
+        }
+    }
+
     /**
      * Write the end of the header to the output stream
-     *
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -264,7 +286,7 @@ protected void sendEndOfHeader(OutputStream out) throws IOException {
 
     /**
      * Write the data to the specified output stream
-     *
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -272,7 +294,7 @@ protected void sendEndOfHeader(OutputStream out) throws IOException {
 
     /**
      * Return the length of the main content
-     *
+     * 
      * @return long The length.
      * @throws IOException If an IO problem occurs
      */
@@ -280,7 +302,7 @@ protected void sendEndOfHeader(OutputStream out) throws IOException {
 
     /**
      * Write the end data to the output stream.
-     *
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -289,10 +311,8 @@ protected void sendEnd(OutputStream out) throws IOException {
     }
 
     /**
-     * Write all the data to the output stream.
-     * If you override this method make sure to override
-     * #length() as well
-     *
+     * Write all the data to the output stream. If you override this method make sure to override #length() as well
+     * 
      * @param out The output stream
      * @throws IOException If an IO problem occurs.
      */
@@ -306,12 +326,9 @@ public void send(OutputStream out) throws IOException {
         sendEnd(out);
     }
 
-
     /**
-     * Return the full length of all the data.
-     * If you override this method make sure to override
-     * #send(OutputStream) as well
-     *
+     * Return the full length of all the data. If you override this method make sure to override #send(OutputStream) as well
+     * 
      * @return long The length.
      * @throws IOException If an IO problem occurs
      */
@@ -324,6 +341,7 @@ public long length() throws IOException {
         sendDispositionHeader(overhead);
         sendContentTypeHeader(overhead);
         sendTransferEncodingHeader(overhead);
+        sendContentIdHeader(overhead);
         sendEndOfHeader(overhead);
         sendEnd(overhead);
         return overhead.size() + lengthOfData();
@@ -331,7 +349,7 @@ public long length() throws IOException {
 
     /**
      * Return a string representation of this object.
-     *
+     * 
      * @return A string representation of this object.
      * @see java.lang.Object#toString()
      */
@@ -341,27 +359,25 @@ public String toString() {
 
     /**
      * Write all parts and the last boundary to the specified output stream.
-     *
-     * @param out   The stream to write to.
+     * 
+     * @param out The stream to write to.
      * @param parts The parts to write.
      * @throws IOException If an I/O error occurs while writing the parts.
      */
-    public static void sendParts(OutputStream out, final Part[] parts)
-            throws IOException {
+    public static void sendParts(OutputStream out, final Part[] parts) throws IOException {
         sendParts(out, parts, DEFAULT_BOUNDARY_BYTES);
     }
 
     /**
      * Write all parts and the last boundary to the specified output stream.
-     *
-     * @param out          The stream to write to.
-     * @param parts        The parts to write.
+     * 
+     * @param out The stream to write to.
+     * @param parts The parts to write.
      * @param partBoundary The ASCII bytes to use as the part boundary.
      * @throws IOException If an I/O error occurs while writing the parts.
      * @since 3.0
      */
-    public static void sendParts(OutputStream out, Part[] parts, byte[] partBoundary)
-            throws IOException {
+    public static void sendParts(OutputStream out, Part[] parts, byte[] partBoundary) throws IOException {
 
         if (parts == null) {
             throw new IllegalArgumentException("Parts may not be null");
@@ -380,8 +396,7 @@ public static void sendParts(OutputStream out, Part[] parts, byte[] partBoundary
         out.write(CRLF_BYTES);
     }
 
-    public static void sendMessageEnd(OutputStream out, byte[] partBoundary)
-            throws IOException {
+    public static void sendMessageEnd(OutputStream out, byte[] partBoundary) throws IOException {
 
         if (partBoundary == null || partBoundary.length == 0) {
             throw new IllegalArgumentException("partBoundary may not be empty");
@@ -395,14 +410,13 @@ public static void sendMessageEnd(OutputStream out, byte[] partBoundary)
 
     /**
      * Write all parts and the last boundary to the specified output stream.
-     *
-     * @param out  The stream to write to.
+     * 
+     * @param out The stream to write to.
      * @param part The part to write.
      * @throws IOException If an I/O error occurs while writing the parts.
      * @since N/A
      */
-    public static void sendPart(OutputStream out, Part part, byte[] partBoundary)
-            throws IOException {
+    public static void sendPart(OutputStream out, Part part, byte[] partBoundary) throws IOException {
 
         if (part == null) {
             throw new IllegalArgumentException("Parts may not be null");
@@ -414,20 +428,19 @@ public static void sendPart(OutputStream out, Part part, byte[] partBoundary)
 
     /**
      * Return the total sum of all parts and that of the last boundary
-     *
+     * 
      * @param parts The parts.
      * @return The total length
      * @throws IOException If an I/O error occurs while writing the parts.
      */
-    public static long getLengthOfParts(Part[] parts)
-            throws IOException {
+    public static long getLengthOfParts(Part[] parts) throws IOException {
         return getLengthOfParts(parts, DEFAULT_BOUNDARY_BYTES);
     }
 
     /**
      * Gets the length of the multipart message including the given parts.
-     *
-     * @param parts        The parts.
+     * 
+     * @param parts The parts.
      * @param partBoundary The ASCII bytes to use as the part boundary.
      * @return The total length
      * @throws IOException If an I/O error occurs while writing the parts.
diff --git a/api/src/main/java/com/ning/http/multipart/PartBase.java b/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
similarity index 81%
rename from api/src/main/java/com/ning/http/multipart/PartBase.java
rename to api/src/main/java/org/asynchttpclient/multipart/PartBase.java
index 415bb4918..c65c00668 100644
--- a/api/src/main/java/com/ning/http/multipart/PartBase.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
 public abstract class PartBase extends Part {
@@ -42,15 +42,18 @@
      */
     private String transferEncoding;
 
+    private String contentId;
+
     /**
      * Constructor.
-     *
-     * @param name             The name of the part
-     * @param contentType      The content type, or <code>null</code>
-     * @param charSet          The character encoding, or <code>null</code>
+     * 
+     * @param name The name of the part
+     * @param contentType The content type, or <code>null</code>
+     * @param charSet The character encoding, or <code>null</code>
      * @param transferEncoding The transfer encoding, or <code>null</code>
+     * @param contentId The content id, or <code>null</code>
      */
-    public PartBase(String name, String contentType, String charSet, String transferEncoding) {
+    public PartBase(String name, String contentType, String charSet, String transferEncoding, String contentId) {
 
         if (name == null) {
             throw new IllegalArgumentException("Name must not be null");
@@ -59,11 +62,12 @@ public PartBase(String name, String contentType, String charSet, String transfer
         this.contentType = contentType;
         this.charSet = charSet;
         this.transferEncoding = transferEncoding;
+        this.contentId = contentId;
     }
 
     /**
      * Returns the name.
-     *
+     * 
      * @return The name.
      */
     public String getName() {
@@ -72,7 +76,7 @@ public String getName() {
 
     /**
      * Returns the content type of this part.
-     *
+     * 
      * @return String The name.
      */
     public String getContentType() {
@@ -81,7 +85,7 @@ public String getContentType() {
 
     /**
      * Return the character encoding of this part.
-     *
+     * 
      * @return String The name.
      */
     public String getCharSet() {
@@ -90,7 +94,7 @@ public String getCharSet() {
 
     /**
      * Returns the transfer encoding of this part.
-     *
+     * 
      * @return String The name.
      */
     public String getTransferEncoding() {
@@ -99,9 +103,8 @@ public String getTransferEncoding() {
 
     /**
      * Sets the character encoding.
-     *
-     * @param charSet the character encoding, or <code>null</code> to exclude the character
-     *                encoding header
+     * 
+     * @param charSet the character encoding, or <code>null</code> to exclude the character encoding header
      */
     public void setCharSet(String charSet) {
         this.charSet = charSet;
@@ -109,7 +112,7 @@ public void setCharSet(String charSet) {
 
     /**
      * Sets the content type.
-     *
+     * 
      * @param contentType the content type, or <code>null</code> to exclude the content type header
      */
     public void setContentType(String contentType) {
@@ -118,7 +121,7 @@ public void setContentType(String contentType) {
 
     /**
      * Sets the part name.
-     *
+     * 
      * @param name
      */
     public void setName(String name) {
@@ -130,12 +133,18 @@ public void setName(String name) {
 
     /**
      * Sets the transfer encoding.
-     *
-     * @param transferEncoding the transfer encoding, or <code>null</code> to exclude the
-     *                         transfer encoding header
+     * 
+     * @param transferEncoding the transfer encoding, or <code>null</code> to exclude the transfer encoding header
      */
     public void setTransferEncoding(String transferEncoding) {
         this.transferEncoding = transferEncoding;
     }
 
+    public String getContentId() {
+        return contentId;
+    }
+
+    public void setContentId(String contentId) {
+        this.contentId = contentId;
+    }
 }
diff --git a/api/src/main/java/com/ning/http/multipart/PartSource.java b/api/src/main/java/org/asynchttpclient/multipart/PartSource.java
similarity index 97%
rename from api/src/main/java/com/ning/http/multipart/PartSource.java
rename to api/src/main/java/org/asynchttpclient/multipart/PartSource.java
index eecf859c3..798ae16eb 100644
--- a/api/src/main/java/com/ning/http/multipart/PartSource.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/PartSource.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/api/src/main/java/com/ning/http/multipart/RequestEntity.java b/api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java
similarity index 98%
rename from api/src/main/java/com/ning/http/multipart/RequestEntity.java
rename to api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java
index d0f6bbe06..99bf7bbf4 100644
--- a/api/src/main/java/com/ning/http/multipart/RequestEntity.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/RequestEntity.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/api/src/main/java/com/ning/http/multipart/StringPart.java b/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
similarity index 78%
rename from api/src/main/java/com/ning/http/multipart/StringPart.java
rename to api/src/main/java/org/asynchttpclient/multipart/StringPart.java
index 431362c8b..447d54035 100644
--- a/api/src/main/java/com/ning/http/multipart/StringPart.java
+++ b/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
@@ -13,14 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.multipart;
+package org.asynchttpclient.multipart;
 
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
- *
+ * 
  * @link http://hc.apache.org/httpclient-3.x/
  */
 public class StringPart extends PartBase {
@@ -48,24 +48,19 @@
     /**
      * The String value of this part.
      */
-    private String value;
+    private final String value;
 
     /**
      * Constructor.
-     *
-     * @param name    The name of the part
-     * @param value   the string to post
-     * @param charset the charset to be used to encode the string, if <code>null</code>
-     *                the {@link #DEFAULT_CHARSET default} is used
+     * 
+     * @param name The name of the part
+     * @param value the string to post
+     * @param charset the charset to be used to encode the string, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
+     * @param contentId the content id
      */
-    public StringPart(String name, String value, String charset) {
+    public StringPart(String name, String value, String charset, String contentId) {
 
-        super(
-                name,
-                DEFAULT_CONTENT_TYPE,
-                charset == null ? DEFAULT_CHARSET : charset,
-                DEFAULT_TRANSFER_ENCODING
-        );
+        super(name, DEFAULT_CONTENT_TYPE, charset == null ? DEFAULT_CHARSET : charset, DEFAULT_TRANSFER_ENCODING, contentId);
         if (value == null) {
             throw new IllegalArgumentException("Value may not be null");
         }
@@ -76,20 +71,23 @@ public StringPart(String name, String value, String charset) {
         this.value = value;
     }
 
+    public StringPart(String name, String value, String charset) {
+        this(name, value, charset, null);
+    }
+
     /**
      * Constructor.
-     *
-     * @param name  The name of the part
+     * 
+     * @param name The name of the part
      * @param value the string to post
      */
     public StringPart(String name, String value) {
-        this(name, value, null);
+        this(name, value, null, null);
     }
 
     /**
-     * Gets the content in bytes.  Bytes are lazily created to allow the charset to be changed
-     * after the part is created.
-     *
+     * Gets the content in bytes. Bytes are lazily created to allow the charset to be changed after the part is created.
+     * 
      * @return the content in bytes
      */
     private byte[] getContent() {
@@ -101,7 +99,7 @@ public StringPart(String name, String value) {
 
     /**
      * Writes the data to the given OutputStream.
-     *
+     * 
      * @param out the OutputStream to write to
      * @throws java.io.IOException if there is a write error
      */
@@ -111,7 +109,7 @@ protected void sendData(OutputStream out) throws IOException {
 
     /**
      * Return the length of the data.
-     *
+     * 
      * @return The length of the data.
      * @throws IOException If an IO problem occurs
      */
@@ -119,7 +117,9 @@ protected long lengthOfData() throws IOException {
         return getContent().length;
     }
 
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
      * @see org.apache.commons.httpclient.methods.multipart.BasePart#setCharSet(java.lang.String)
      */
     public void setCharSet(String charSet) {
diff --git a/api/src/main/java/com/ning/http/client/ntlm/NTLMEngine.java b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
similarity index 99%
rename from api/src/main/java/com/ning/http/client/ntlm/NTLMEngine.java
rename to api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
index a56c9bf14..00da92497 100644
--- a/api/src/main/java/com/ning/http/client/ntlm/NTLMEngine.java
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -36,9 +36,9 @@
  *
  */
 
-package com.ning.http.client.ntlm;
+package org.asynchttpclient.ntlm;
 
-import com.ning.http.util.Base64;
+import org.asynchttpclient.util.Base64;
 
 import javax.crypto.Cipher;
 import javax.crypto.spec.SecretKeySpec;
@@ -123,7 +123,7 @@ final String getResponseFor(String message, String username, String password,
                                 String host, String domain) throws NTLMEngineException {
 
         final String response;
-        if (message == null || message.trim().equals("")) {
+        if (message == null || message.trim().length() == 0) {
             response = getType1Message(host, domain);
         } else {
             Type2Message t2m = new Type2Message(message);
diff --git a/api/src/main/java/com/ning/http/client/ntlm/NTLMEngineException.java b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/ntlm/NTLMEngineException.java
rename to api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
index d1c557520..25d3f162e 100644
--- a/api/src/main/java/com/ning/http/client/ntlm/NTLMEngineException.java
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
@@ -36,7 +36,7 @@
  *
  */
 
-package com.ning.http.client.ntlm;
+package org.asynchttpclient.ntlm;
 
 /**
  * Signals NTLM protocol failure.
diff --git a/api/src/main/java/com/ning/http/client/oauth/ConsumerKey.java b/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/oauth/ConsumerKey.java
rename to api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
index 91f846827..5b270ac2d 100644
--- a/api/src/main/java/com/ning/http/client/oauth/ConsumerKey.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/ConsumerKey.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client.oauth;
+package org.asynchttpclient.oauth;
 
 /**
  * Value class for OAuth consumer keys.
diff --git a/api/src/main/java/com/ning/http/client/oauth/OAuthSignatureCalculator.java b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/oauth/OAuthSignatureCalculator.java
rename to api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index e33ad87c7..cd2508894 100644
--- a/api/src/main/java/com/ning/http/client/oauth/OAuthSignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -14,16 +14,15 @@
  * under the License.
  *
  */
-package com.ning.http.client.oauth;
-
-
-import com.ning.http.client.FluentStringsMap;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilderBase;
-import com.ning.http.client.SignatureCalculator;
-import com.ning.http.util.Base64;
-import com.ning.http.util.UTF8Codec;
-import com.ning.http.util.UTF8UrlEncoder;
+package org.asynchttpclient.oauth;
+
+import org.asynchttpclient.FluentStringsMap;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilderBase;
+import org.asynchttpclient.SignatureCalculator;
+import org.asynchttpclient.util.Base64;
+import org.asynchttpclient.util.UTF8Codec;
+import org.asynchttpclient.util.UTF8UrlEncoder;
 
 import java.util.ArrayList;
 import java.util.Arrays;
diff --git a/api/src/main/java/com/ning/http/client/oauth/RequestToken.java b/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
similarity index 98%
rename from api/src/main/java/com/ning/http/client/oauth/RequestToken.java
rename to api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
index 8607f8a9e..78b3758b4 100644
--- a/api/src/main/java/com/ning/http/client/oauth/RequestToken.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/RequestToken.java
@@ -14,7 +14,7 @@
  * under the License.
  *
  */
-package com.ning.http.client.oauth;
+package org.asynchttpclient.oauth;
 
 /**
  * Value class used for OAuth tokens (request secret, access secret);
diff --git a/api/src/main/java/com/ning/http/client/oauth/ThreadSafeHMAC.java b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
similarity index 87%
rename from api/src/main/java/com/ning/http/client/oauth/ThreadSafeHMAC.java
rename to api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
index 0157a9df7..784583f1b 100644
--- a/api/src/main/java/com/ning/http/client/oauth/ThreadSafeHMAC.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
@@ -14,9 +14,10 @@
  * under the License.
  *
  */
-package com.ning.http.client.oauth;
+package org.asynchttpclient.oauth;
 
-import com.ning.http.util.UTF8Codec;
+import org.asynchttpclient.util.UTF8UrlEncoder;
+import org.asynchttpclient.util.UTF8Codec;
 
 import javax.crypto.Mac;
 import javax.crypto.spec.SecretKeySpec;
@@ -36,7 +37,7 @@
     private final Mac mac;
 
     public ThreadSafeHMAC(ConsumerKey consumerAuth, RequestToken userAuth) {
-        byte[] keyBytes = UTF8Codec.toUTF8(consumerAuth.getSecret() + "&" + userAuth.getSecret());
+        byte[] keyBytes = UTF8Codec.toUTF8(UTF8UrlEncoder.encode(consumerAuth.getSecret()) + "&" + UTF8UrlEncoder.encode(userAuth.getSecret()));
         SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
 
         // Get an hmac_sha1 instance and initialize with the signing key
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java
new file mode 100644
index 000000000..2b33cbf97
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoder.java
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.org.jboss.netty.handler.codec.http;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.HashSet;
+
+import org.asynchttpclient.org.jboss.netty.util.internal.StringUtil;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+
+/**
+ * Decodes an HTTP header value into {@link Cookie}s. This decoder can decode the HTTP cookie version 0, 1, and 2.
+ * 
+ * <pre>
+ * {@link HttpRequest} req = ...;
+ * String value = req.getHeader("Cookie");
+ * Set&lt;{@link Cookie}&gt; cookies = new {@link CookieDecoder}().decode(value);
+ * </pre>
+ * 
+ * @see CookieEncoder
+ * 
+ * @apiviz.stereotype utility
+ * @apiviz.has org.jboss.netty.handler.codec.http.Cookie oneway - - decodes
+ */
+public class CookieDecoder {
+
+    private static final char COMMA = ',';
+
+    /**
+     * Creates a new decoder.
+     */
+    private CookieDecoder() {
+    }
+
+    /**
+     * Decodes the specified HTTP header value into {@link Cookie}s.
+     * 
+     * @return the decoded {@link Cookie}s
+     */
+    public static Set<Cookie> decode(String header) {
+        List<String> names = new ArrayList<String>(8);
+        List<String> values = new ArrayList<String>(8);
+        List<String> rawValues = new ArrayList<String>(8);
+        extractKeyValuePairs(header, names, values, rawValues);
+
+        if (names.isEmpty()) {
+            return Collections.emptySet();
+        }
+
+        int i;
+        int version = 0;
+
+        // $Version is the only attribute that can appear before the actual
+        // cookie name-value pair.
+        if (names.get(0).equalsIgnoreCase(CookieHeaderNames.VERSION)) {
+            try {
+                version = Integer.parseInt(values.get(0));
+            } catch (NumberFormatException e) {
+                // Ignore.
+            }
+            i = 1;
+        } else {
+            i = 0;
+        }
+
+        if (names.size() <= i) {
+            // There's a version attribute, but nothing more.
+            return Collections.emptySet();
+        }
+
+        Set<Cookie> cookies = new HashSet<Cookie>();
+        for (; i < names.size(); i++) {
+            String name = names.get(i);
+            String value = values.get(i);
+            String rawValue = rawValues.get(i);
+            if (value == null) {
+                value = "";
+            }
+            if (rawValue == null) {
+                rawValue = "";
+            }
+
+            String cookieName = name;
+            String cookieValue = value;
+            String cookieRawValue = rawValue;
+            boolean discard = false;
+            boolean secure = false;
+            boolean httpOnly = false;
+            String comment = null;
+            String commentURL = null;
+            String domain = null;
+            String path = null;
+            int maxAge = -1;
+            List<Integer> ports = Collections.emptyList();
+
+            for (int j = i + 1; j < names.size(); j++, i++) {
+                name = names.get(j);
+                value = values.get(j);
+
+                if (CookieHeaderNames.DISCARD.equalsIgnoreCase(name)) {
+                    discard = true;
+                } else if (CookieHeaderNames.SECURE.equalsIgnoreCase(name)) {
+                    secure = true;
+                } else if (CookieHeaderNames.HTTPONLY.equalsIgnoreCase(name)) {
+                    httpOnly = true;
+                } else if (CookieHeaderNames.COMMENT.equalsIgnoreCase(name)) {
+                    comment = value;
+                } else if (CookieHeaderNames.COMMENTURL.equalsIgnoreCase(name)) {
+                    commentURL = value;
+                } else if (CookieHeaderNames.DOMAIN.equalsIgnoreCase(name)) {
+                    domain = value;
+                } else if (CookieHeaderNames.PATH.equalsIgnoreCase(name)) {
+                    path = value;
+                } else if (CookieHeaderNames.EXPIRES.equalsIgnoreCase(name)) {
+                    try {
+                        maxAge = AsyncHttpProviderUtils.convertExpireField(value);
+                    } catch (Exception e) {
+                        // original behavior, is this correct at all (expires field with max-age semantics)?
+                        try {
+                            maxAge = Math.max(Integer.valueOf(value), 0);
+                        } catch (NumberFormatException e1) {
+                            // ignore failure to parse -> treat as session cookie
+                        }
+                    }
+                } else if (CookieHeaderNames.MAX_AGE.equalsIgnoreCase(name)) {
+                    maxAge = Integer.parseInt(value);
+                } else if (CookieHeaderNames.VERSION.equalsIgnoreCase(name)) {
+                    version = Integer.parseInt(value);
+                } else if (CookieHeaderNames.PORT.equalsIgnoreCase(name)) {
+                    String[] portList = StringUtil.split(value, COMMA);
+                    ports = new ArrayList<Integer>(2);
+                    for (String s1 : portList) {
+                        try {
+                            ports.add(Integer.valueOf(s1));
+                        } catch (NumberFormatException e) {
+                            // Ignore.
+                        }
+                    }
+                } else {
+                    break;
+                }
+            }
+
+            Cookie c = new Cookie(domain, cookieName, cookieValue, cookieRawValue, path, maxAge, secure, version, httpOnly, discard, comment, commentURL, ports);
+            cookies.add(c);
+        }
+
+        return cookies;
+    }
+
+    private static void extractKeyValuePairs(final String header, final List<String> names, final List<String> values, final List<String> rawValues) {
+
+        final int headerLen = header.length();
+        loop: for (int i = 0;;) {
+
+            // Skip spaces and separators.
+            for (;;) {
+                if (i == headerLen) {
+                    break loop;
+                }
+                switch (header.charAt(i)) {
+                case '\t':
+                case '\n':
+                case 0x0b:
+                case '\f':
+                case '\r':
+                case ' ':
+                case ',':
+                case ';':
+                    i++;
+                    continue;
+                }
+                break;
+            }
+
+            // Skip '$'.
+            for (;;) {
+                if (i == headerLen) {
+                    break loop;
+                }
+                if (header.charAt(i) == '$') {
+                    i++;
+                    continue;
+                }
+                break;
+            }
+
+            String name;
+            String value;
+            String rawValue;
+
+            if (i == headerLen) {
+                name = null;
+                value = null;
+                rawValue = null;
+            } else {
+                int newNameStart = i;
+                keyValLoop: for (;;) {
+                    switch (header.charAt(i)) {
+                    case ';':
+                        // NAME; (no value till ';')
+                        name = header.substring(newNameStart, i);
+                        value = null;
+                        rawValue = null;
+                        break keyValLoop;
+                    case '=':
+                        // NAME=VALUE
+                        name = header.substring(newNameStart, i);
+                        i++;
+                        if (i == headerLen) {
+                            // NAME= (empty value, i.e. nothing after '=')
+                            value = "";
+                            rawValue = "";
+                            break keyValLoop;
+                        }
+
+                        int newValueStart = i;
+                        char c = header.charAt(i);
+                        if (c == '"' || c == '\'') {
+                            // NAME="VALUE" or NAME='VALUE'
+                            StringBuilder newValueBuf = new StringBuilder(header.length() - i);
+                            StringBuilder newRawValueBuf = new StringBuilder(header.length() - i);
+                            newRawValueBuf.append(c);
+                            final char q = c;
+                            boolean hadBackslash = false;
+                            i++;
+                            for (;;) {
+                                if (i == headerLen) {
+                                    value = newValueBuf.toString();
+                                    rawValue = newRawValueBuf.toString();
+                                    break keyValLoop;
+                                }
+                                if (hadBackslash) {
+                                    hadBackslash = false;
+                                    c = header.charAt(i++);
+                                    newRawValueBuf.append(c);
+                                    switch (c) {
+                                    case '\\':
+                                    case '"':
+                                    case '\'':
+                                        // Escape last backslash.
+                                        newValueBuf.setCharAt(newValueBuf.length() - 1, c);
+                                        break;
+                                    default:
+                                        // Do not escape last backslash.
+                                        newValueBuf.append(c);
+                                    }
+                                } else {
+                                    c = header.charAt(i++);
+                                    newRawValueBuf.append(c);
+                                    if (c == q) {
+                                        value = newValueBuf.toString();
+                                        rawValue = newRawValueBuf.toString();
+                                        break keyValLoop;
+                                    }
+                                    newValueBuf.append(c);
+                                    if (c == '\\') {
+                                        hadBackslash = true;
+                                    }
+                                }
+                            }
+                        } else {
+                            // NAME=VALUE;
+                            int semiPos = header.indexOf(';', i);
+                            if (semiPos > 0) {
+                                value = rawValue = header.substring(newValueStart, semiPos);
+                                i = semiPos;
+                            } else {
+                                value = rawValue = header.substring(newValueStart);
+                                i = headerLen;
+                            }
+                        }
+                        break keyValLoop;
+                    default:
+                        i++;
+                    }
+
+                    if (i == headerLen) {
+                        // NAME (no value till the end of string)
+                        name = header.substring(newNameStart);
+                        value = rawValue = null;
+                        break;
+                    }
+                }
+            }
+
+            names.add(name);
+            values.add(value);
+            rawValues.add(rawValue);
+        }
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java
new file mode 100644
index 000000000..7a8ff6768
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieEncoder.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.org.jboss.netty.handler.codec.http;
+
+import java.util.Collection;
+
+import org.asynchttpclient.Cookie;
+
+/**
+ * Encodes {@link Cookie}s into an HTTP header value.  This encoder can encode
+ * the HTTP cookie version 0, 1, and 2.
+ * <p>
+ * This encoder is stateful.  It maintains an internal data structure that
+ * holds the {@link Cookie}s added by the {@link #addCookie(String, String)}
+ * method.  Once {@link #encode()} is called, all added {@link Cookie}s are
+ * encoded into an HTTP header value and all {@link Cookie}s in the internal
+ * data structure are removed so that the encoder can start over.
+ * <pre>
+ * // Client-side example
+ * {@link HttpRequest} req = ...;
+ * {@link CookieEncoder} encoder = new {@link CookieEncoder}(false);
+ * encoder.addCookie("JSESSIONID", "1234");
+ * res.setHeader("Cookie", encoder.encode());
+ *
+ * // Server-side example
+ * {@link HttpResponse} res = ...;
+ * {@link CookieEncoder} encoder = new {@link CookieEncoder}(true);
+ * encoder.addCookie("JSESSIONID", "1234");
+ * res.setHeader("Set-Cookie", encoder.encode());
+ * </pre>
+ *
+ * @see CookieDecoder
+ *
+ * @apiviz.stereotype utility
+ * @apiviz.has        org.jboss.netty.handler.codec.http.Cookie oneway - - encodes
+ */
+// This fork brings support for RFC6265, that's used if the Cookie has a raw value
+public final class CookieEncoder {
+
+    private CookieEncoder() {
+    }
+    
+    public static String encodeClientSide(Collection<Cookie> cookies, boolean useRFC6265Style) {
+        StringBuilder sb = new StringBuilder();
+
+        for (Cookie cookie: cookies) {
+            if (useRFC6265Style)
+                encodeRFC6265Style(sb, cookie);
+            else
+                encodeRFC2965Style(sb, cookie);
+        }
+
+        if (sb.length() > 0) {
+            sb.setLength(sb.length() - 2);
+        }
+        return sb.toString();
+    }
+    
+    private static void encodeRFC6265Style(StringBuilder sb, Cookie cookie) {
+        addUnquoted(sb, cookie.getName(), cookie.getRawValue());
+    }
+    
+    private static void encodeRFC2965Style(StringBuilder sb, Cookie cookie) {
+        if (cookie.getVersion() >= 1) {
+            add(sb, '$' + CookieHeaderNames.VERSION, 1);
+        }
+
+        add(sb, cookie.getName(), cookie.getValue());
+
+        if (cookie.getPath() != null) {
+            add(sb, '$' + CookieHeaderNames.PATH, cookie.getPath());
+        }
+
+        if (cookie.getDomain() != null) {
+            add(sb, '$' + CookieHeaderNames.DOMAIN, cookie.getDomain());
+        }
+
+        if (cookie.getVersion() >= 1) {
+            if (!cookie.getPorts().isEmpty()) {
+                sb.append('$');
+                sb.append(CookieHeaderNames.PORT);
+                sb.append((char) HttpConstants.EQUALS);
+                sb.append((char) HttpConstants.DOUBLE_QUOTE);
+                for (int port: cookie.getPorts()) {
+                    sb.append(port);
+                    sb.append((char) HttpConstants.COMMA);
+                }
+                sb.setCharAt(sb.length() - 1, (char) HttpConstants.DOUBLE_QUOTE);
+                sb.append((char) HttpConstants.SEMICOLON);
+                sb.append((char) HttpConstants.SP);
+            }
+        }
+    }
+
+    private static void add(StringBuilder sb, String name, String val) {
+        if (val == null) {
+            addQuoted(sb, name, "");
+            return;
+        }
+
+        for (int i = 0; i < val.length(); i ++) {
+            char c = val.charAt(i);
+            switch (c) {
+            case '\t': case ' ': case '"': case '(':  case ')': case ',':
+            case '/':  case ':': case ';': case '<':  case '=': case '>':
+            case '?':  case '@': case '[': case '\\': case ']':
+            case '{':  case '}':
+                addQuoted(sb, name, val);
+                return;
+            }
+        }
+
+        addUnquoted(sb, name, val);
+    }
+
+    private static void addUnquoted(StringBuilder sb, String name, String val) {
+        sb.append(name);
+        sb.append((char) HttpConstants.EQUALS);
+        sb.append(val);
+        sb.append((char) HttpConstants.SEMICOLON);
+        sb.append((char) HttpConstants.SP);
+    }
+
+    private static void addQuoted(StringBuilder sb, String name, String val) {
+        if (val == null) {
+            val = "";
+        }
+
+        sb.append(name);
+        sb.append((char) HttpConstants.EQUALS);
+        sb.append((char) HttpConstants.DOUBLE_QUOTE);
+        sb.append(val.replace("\\", "\\\\").replace("\"", "\\\""));
+        sb.append((char) HttpConstants.DOUBLE_QUOTE);
+        sb.append((char) HttpConstants.SEMICOLON);
+        sb.append((char) HttpConstants.SP);
+    }
+
+    private static void add(StringBuilder sb, String name, int val) {
+        sb.append(name);
+        sb.append((char) HttpConstants.EQUALS);
+        sb.append(val);
+        sb.append((char) HttpConstants.SEMICOLON);
+        sb.append((char) HttpConstants.SP);
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
new file mode 100644
index 000000000..523cb479d
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieHeaderNames.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.org.jboss.netty.handler.codec.http;
+
+final class CookieHeaderNames {
+    static final String PATH = "Path";
+
+    static final String EXPIRES = "Expires";
+
+    static final String MAX_AGE = "Max-Age";
+
+    static final String DOMAIN = "Domain";
+
+    static final String SECURE = "Secure";
+
+    static final String HTTPONLY = "HTTPOnly";
+
+    static final String COMMENT = "Comment";
+
+    static final String COMMENTURL = "CommentURL";
+
+    static final String DISCARD = "Discard";
+
+    static final String PORT = "Port";
+
+    static final String VERSION = "Version";
+
+    private CookieHeaderNames() {
+        // Unused.
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java
new file mode 100644
index 000000000..c5b4212bf
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/HttpConstants.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.org.jboss.netty.handler.codec.http;
+
+import java.nio.charset.Charset;
+
+public final class HttpConstants {
+
+    /**
+     * Horizontal space
+     */
+    public static final byte SP = 32;
+
+    /**
+     * Horizontal tab
+     */
+    public static final byte HT = 9;
+
+    /**
+     * Carriage return
+     */
+    public static final byte CR = 13;
+
+    /**
+     * Equals '='
+     */
+    public static final byte EQUALS = 61;
+
+    /**
+     * Line feed character
+     */
+    public static final byte LF = 10;
+
+    /**
+     * Colon ':'
+     */
+    public static final byte COLON = 58;
+
+    /**
+     * Semicolon ';'
+     */
+    public static final byte SEMICOLON = 59;
+
+    /**
+     * Comma ','
+     */
+    public static final byte COMMA = 44;
+
+    /**
+     * Double quote '"'
+     */
+    public static final byte DOUBLE_QUOTE = '"';
+
+    /**
+     * Default character set (UTF-8)
+     */
+    public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
+
+    private HttpConstants() {
+        // Unused
+    }
+}
+
diff --git a/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java b/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java
new file mode 100644
index 000000000..b828761d0
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/org/jboss/netty/util/internal/StringUtil.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.org.jboss.netty.util.internal;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * String utility class.
+ */
+public final class StringUtil {
+
+    private StringUtil() {
+        // Unused.
+    }
+
+    private static final String EMPTY_STRING = "";
+
+    /**
+     * Splits the specified {@link String} with the specified delimiter.  This operation is a simplified and optimized
+     * version of {@link String#split(String)}.
+     */
+    public static String[] split(String value, char delim) {
+        final int end = value.length();
+        final List<String> res = new ArrayList<String>();
+
+        int start = 0;
+        for (int i = 0; i < end; i ++) {
+            if (value.charAt(i) == delim) {
+                if (start == i) {
+                    res.add(EMPTY_STRING);
+                } else {
+                    res.add(value.substring(start, i));
+                }
+                start = i + 1;
+            }
+        }
+
+        if (start == 0) { // If no delimiter was found in the value
+            res.add(value);
+        } else {
+            if (start != end) {
+                // Add the last element if it's not empty.
+                res.add(value.substring(start, end));
+            } else {
+                // Truncate trailing empty elements.
+                for (int i = res.size() - 1; i >= 0; i --) {
+                    if (res.get(i).length() == 0) {
+                        res.remove(i);
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+
+        return res.toArray(new String[res.size()]);
+    }
+}
diff --git a/api/src/main/java/com/ning/http/client/providers/ResponseBase.java b/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
similarity index 82%
rename from api/src/main/java/com/ning/http/client/providers/ResponseBase.java
rename to api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
index 1f98acf53..d22a511ea 100644
--- a/api/src/main/java/com/ning/http/client/providers/ResponseBase.java
+++ b/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
@@ -1,18 +1,21 @@
-package com.ning.http.client.providers;
+package org.asynchttpclient.providers;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
+import java.nio.ByteBuffer;
 import java.util.Collections;
 import java.util.List;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import com.ning.http.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
 public abstract class ResponseBase implements Response
 {
@@ -42,7 +45,6 @@ public final String getStatusText() {
         return status.getStatusText();
     }
 
-
     /* @Override */
     public final URI getUri() /*throws MalformedURLException*/ {
         return status.getUrl();
@@ -78,6 +80,10 @@ public final boolean isRedirected() {
         return AsyncHttpProviderUtils.contentToBytes(bodyParts);
     }
 
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return ByteBuffer.wrap(getResponseBodyAsBytes());
+    }
+
     /* @Override */
     public String getResponseBody() throws IOException {
         return getResponseBody(DEFAULT_CHARSET);
@@ -122,10 +128,10 @@ public boolean hasResponseStatus() {
     }
 
     public boolean hasResponseHeaders() {
-        return headers != null && !headers.getHeaders().isEmpty();
+        return headers != null && isNonEmpty(headers.getHeaders());
     }
 
     public boolean hasResponseBody() {
-        return bodyParts != null && !bodyParts.isEmpty();
+        return isNonEmpty(bodyParts);
     }
 }
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java
similarity index 88%
rename from api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java
index 6bd46a78f..c7a79c0dd 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,37 +10,41 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.Body;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProgressAsyncHandler;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
-import com.ning.http.util.UTF8UrlEncoder;
+package org.asynchttpclient.providers.jdk;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.ProgressAsyncHandler;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.multipart.MultipartRequestEntity;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.ProxyUtils;
+import org.asynchttpclient.util.SslUtils;
+import org.asynchttpclient.util.UTF8UrlEncoder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -76,7 +80,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
 
-import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
 
 public class JDKAsyncHttpProvider implements AsyncHttpProvider {
     private final static Logger logger = LoggerFactory.getLogger(JDKAsyncHttpProvider.class);
@@ -129,12 +133,11 @@ private void configure(JDKAsyncHttpProviderConfig config) {
             throw new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
         }
 
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
         Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
-        if (!avoidProxy && (proxyServer != null || realm != null)) {
+        if (proxyServer != null || realm != null) {
             try {
-                /*Proxy proxy =*/ configureProxyAndAuth(proxyServer, realm);
+                configureProxyAndAuth(proxyServer, realm);
             } catch (AuthenticationException e) {
                 throw new IOException(e.getMessage());
             }
@@ -142,9 +145,7 @@ private void configure(JDKAsyncHttpProviderConfig config) {
 
         HttpURLConnection urlConnection = createUrlConnection(request);
 
-        PerRequestConfig conf = request.getPerRequestConfig();
-        int requestTimeout = (conf != null && conf.getRequestTimeoutInMs() != 0) ?
-                conf.getRequestTimeoutInMs() : config.getRequestTimeoutInMs();
+        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
 
         JDKDelegateFuture<T> delegate = null;
         if (future != null) {
@@ -161,11 +162,10 @@ private void configure(JDKAsyncHttpProviderConfig config) {
     }
 
     private HttpURLConnection createUrlConnection(Request request) throws IOException {
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
         Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
         Proxy proxy = null;
-        if (!avoidProxy && proxyServer != null || realm != null) {
+        if (proxyServer != null || realm != null) {
             try {
                 proxy = configureProxyAndAuth(proxyServer, realm);
             } catch (AuthenticationException e) {
@@ -173,13 +173,8 @@ private HttpURLConnection createUrlConnection(Request request) throws IOExceptio
             }
         }
 
-        HttpURLConnection urlConnection = null;
-        if (proxy == null) {
-            urlConnection =
-                    (HttpURLConnection) AsyncHttpProviderUtils.createUri(request.getUrl()).toURL().openConnection(Proxy.NO_PROXY);
-        } else {
-            urlConnection = (HttpURLConnection) AsyncHttpProviderUtils.createUri(request.getUrl()).toURL().openConnection(proxy);
-        }
+        HttpURLConnection urlConnection = (HttpURLConnection)
+            request.getURI().toURL().openConnection(proxy == null ? Proxy.NO_PROXY : proxy);
 
         if (request.getUrl().startsWith("https")) {
             HttpsURLConnection secure = (HttpsURLConnection) urlConnection;
@@ -373,7 +368,7 @@ public T call() throws Exception {
             } catch (Throwable t) {
                 logger.debug(t.getMessage(), t);
 
-                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
+                if (IOException.class.isAssignableFrom(t.getClass()) && !config.getIOExceptionFilters().isEmpty()) {
                     FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(asyncHandler)
                             .request(request).ioException(IOException.class.cast(t)).build();
 
@@ -429,12 +424,8 @@ private Throwable filterException(Throwable t) {
             }
 
             if (SocketTimeoutException.class.isAssignableFrom(t.getClass())) {
-                int responseTimeoutInMs = config.getRequestTimeoutInMs();
-
-                if (request.getPerRequestConfig() != null && request.getPerRequestConfig().getRequestTimeoutInMs() != -1) {
-                    responseTimeoutInMs = request.getPerRequestConfig().getRequestTimeoutInMs();
-                }
-                t = new TimeoutException(String.format("No response received after %s", responseTimeoutInMs));
+                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
+                t = new TimeoutException("No response received after " + requestTimeout);
             }
 
             if (SSLHandshakeException.class.isAssignableFrom(t.getClass())) {
@@ -448,14 +439,12 @@ private Throwable filterException(Throwable t) {
 
         private void configure(URI uri, HttpURLConnection urlConnection, Request request) throws IOException, AuthenticationException {
 
-            PerRequestConfig conf = request.getPerRequestConfig();
-            int requestTimeout = (conf != null && conf.getRequestTimeoutInMs() != 0) ?
-                    conf.getRequestTimeoutInMs() : config.getRequestTimeoutInMs();
-
-            urlConnection.setConnectTimeout(config.getConnectionTimeoutInMs());
+            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
 
-            if (requestTimeout != -1)
+            if (requestTimeout != 0) {
+                urlConnection.setConnectTimeout(requestTimeout);
                 urlConnection.setReadTimeout(requestTimeout);
+            }
 
             urlConnection.setInstanceFollowRedirects(false);
             String host = uri.getHost();
@@ -492,11 +481,10 @@ private void configure(URI uri, HttpURLConnection urlConnection, Request request
                 }
             }
 
-            String ka = config.getAllowPoolingConnection() ? "keep-alive" : "close";
+            String ka = AsyncHttpProviderUtils.keepAliveHeaderValue(config);
             urlConnection.setRequestProperty("Connection", ka);
-            ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-            boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
-            if (!avoidProxy) {
+            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
+            if (proxyServer != null) {
                 urlConnection.setRequestProperty("Proxy-Connection", ka);
                 if (proxyServer.getPrincipal() != null) {
                     urlConnection.setRequestProperty("Proxy-Authorization", AuthenticatorUtils.computeBasicAuthentication(proxyServer));
@@ -516,7 +504,7 @@ private void configure(URI uri, HttpURLConnection urlConnection, Request request
                                 AuthenticatorUtils.computeBasicAuthentication(realm));
                         break;
                     case DIGEST:
-                        if (realm.getNonce() != null && !realm.getNonce().equals("")) {
+                        if (isNonEmpty(realm.getNonce())) {
                             try {
                                 urlConnection.setRequestProperty("Authorization",
                                         AuthenticatorUtils.computeDigestAuthentication(realm));
@@ -552,7 +540,7 @@ private void configure(URI uri, HttpURLConnection urlConnection, Request request
                                                                   config));
             }
 
-            if (request.getCookies() != null && !request.getCookies().isEmpty()) {
+            if (isNonEmpty(request.getCookies())) {
                 urlConnection.setRequestProperty("Cookie", AsyncHttpProviderUtils.encodeCookies(request.getCookies()));
             }
 
@@ -619,7 +607,7 @@ private void configure(URI uri, HttpURLConnection urlConnection, Request request
                         lenght = MAX_BUFFERED_BYTES;
                     }
 
-                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
+                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getHeaders());
 
                     urlConnection.setRequestProperty("Content-Type", mre.getContentType());
                     urlConnection.setRequestProperty("Content-Length", String.valueOf(mre.getContentLength()));
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java
index 700c1716b..8d743a21a 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProviderConfig.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKAsyncHttpProviderConfig.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHttpProviderConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
 
 import java.util.Map;
 import java.util.Set;
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKDelegateFuture.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java
similarity index 89%
rename from api/src/main/java/com/ning/http/client/providers/jdk/JDKDelegateFuture.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java
index b3da007d1..62dede5fd 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKDelegateFuture.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKDelegateFuture.java
@@ -10,10 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.ListenableFuture;
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ListenableFuture;
 
 import java.net.HttpURLConnection;
 import java.util.concurrent.Callable;
@@ -67,7 +68,7 @@ public V get(long timeout, TimeUnit unit) throws InterruptedException, Execution
                 content = innerFuture.get(timeout, unit);
             }
         } catch (Throwable t) {
-            if (!contentProcessed.get() && timeout != -1 && ((System.currentTimeMillis() - touch.get()) <= responseTimeoutInMs)) {
+            if (!contentProcessed.get() && timeout != -1 && ((millisTime() - touch.get()) <= responseTimeoutInMs)) {
                 return get(timeout, unit);
             }
             timedOut.set(true);
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKFuture.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/providers/jdk/JDKFuture.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java
index 023abf30c..2810a33f2 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKFuture.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKFuture.java
@@ -10,10 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.listenable.AbstractListenableFuture;
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,7 +42,7 @@
     protected final AtomicBoolean timedOut = new AtomicBoolean(false);
     protected final AtomicBoolean isDone = new AtomicBoolean(false);
     protected final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
-    protected final AtomicLong touch = new AtomicLong(System.currentTimeMillis());
+    protected final AtomicLong touch = new AtomicLong(millisTime());
     protected final AtomicBoolean contentProcessed = new AtomicBoolean(false);
     protected final HttpURLConnection urlConnection;
     private boolean writeHeaders;
@@ -126,7 +128,7 @@ public V get(long timeout, TimeUnit unit) throws InterruptedException, Execution
                 content = innerFuture.get(timeout, unit);
             }
         } catch (TimeoutException t) {
-            if (!contentProcessed.get() && timeout != -1 && ((System.currentTimeMillis() - touch.get()) <= responseTimeoutInMs)) {
+            if (!contentProcessed.get() && timeout != -1 && ((millisTime() - touch.get()) <= responseTimeoutInMs)) {
                 return get(timeout, unit);
             }
 
@@ -149,7 +151,7 @@ public V get(long timeout, TimeUnit unit) throws InterruptedException, Execution
      * @return <code>true</code> if response has expired and should be terminated.
      */
     public boolean hasExpired() {
-        return responseTimeoutInMs != -1 && ((System.currentTimeMillis() - touch.get()) > responseTimeoutInMs);
+        return responseTimeoutInMs != -1 && ((millisTime() - touch.get()) > responseTimeoutInMs);
     }
 
     /**
@@ -157,7 +159,7 @@ public boolean hasExpired() {
      */
     /* @Override  */
     public void touch() {
-        touch.set(System.currentTimeMillis());
+        touch.set(millisTime());
     }
 
     /**
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java
similarity index 80%
rename from api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java
index 56bc330e5..682db9fc4 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/JDKResponse.java
@@ -10,14 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.providers.ResponseBase;
-import com.ning.http.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.providers.ResponseBase;
+import org.asynchttpclient.providers.ResponseBase;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -53,8 +55,7 @@ public String getResponseBodyExcerpt(int maxLength, String charset) throws IOExc
                 // TODO: ask for parsed header
                 List<String> v = header.getValue();
                 for (String value : v) {
-                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                    cookies.add(cookie);
+                    cookies.addAll(CookieDecoder.decode(value));
                 }
             }
         }
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseBodyPart.java b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java
similarity index 94%
rename from api/src/main/java/com/ning/http/client/providers/jdk/ResponseBodyPart.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java
index f745df343..3081baee6 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseBodyPart.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseBodyPart.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseBodyPart;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseBodyPart;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseHeaders.java b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java
similarity index 86%
rename from api/src/main/java/com/ning/http/client/providers/jdk/ResponseHeaders.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java
index c4f3fe486..1a07b53c0 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseHeaders.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseHeaders.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseHeaders;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
 
 import java.net.HttpURLConnection;
 import java.net.URI;
@@ -51,7 +51,7 @@ private FluentCaseInsensitiveStringsMap computerHeaders() {
     /**
      * Return the HTTP header
      *
-     * @return an {@link com.ning.http.client.FluentCaseInsensitiveStringsMap}
+     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
      */
     @Override
     public FluentCaseInsensitiveStringsMap getHeaders() {
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseStatus.java b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/providers/jdk/ResponseStatus.java
rename to api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java
index 7f27e2dc5..d88d21168 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/ResponseStatus.java
+++ b/api/src/main/java/org/asynchttpclient/providers/jdk/ResponseStatus.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.jdk;
+package org.asynchttpclient.providers.jdk;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseStatus;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseStatus;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
diff --git a/api/src/main/java/com/ning/http/client/resumable/PropertiesBasedResumableProcessor.java b/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
similarity index 91%
rename from api/src/main/java/com/ning/http/client/resumable/PropertiesBasedResumableProcessor.java
rename to api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
index efb6dea06..85ebb2bde 100644
--- a/api/src/main/java/com/ning/http/client/resumable/PropertiesBasedResumableProcessor.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -24,7 +24,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
- * A {@link com.ning.http.client.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
+ * A {@link org.asynchttpclient.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
  * to store the download index information.
  */
 public class PropertiesBasedResumableProcessor implements ResumableAsyncHandler.ResumableProcessor {
@@ -60,11 +60,11 @@ public void save(Map<String, Long> map) {
         FileOutputStream os = null;
         try {
 
-            if (!TMP.mkdirs()) {
+            if (!TMP.exists() && !TMP.mkdirs()) {
                 throw new IllegalStateException("Unable to create directory: " + TMP.getAbsolutePath());
             }
             File f = new File(TMP, storeName);
-            if (!f.createNewFile()) {
+            if (!f.exists() && !f.createNewFile()) {
                 throw new IllegalStateException("Unable to create temp file: " + f.getAbsolutePath());
             }
             if (!f.canWrite()) {
@@ -90,7 +90,7 @@ public void save(Map<String, Long> map) {
     }
 
     private static String append(Map.Entry<String, Long> e) {
-        return new StringBuffer(e.getKey()).append("=").append(e.getValue()).append("\n").toString();
+        return new StringBuilder(e.getKey()).append("=").append(e.getValue()).append("\n").toString();
     }
 
     /**
diff --git a/api/src/main/java/com/ning/http/client/resumable/ResumableAsyncHandler.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
similarity index 95%
rename from api/src/main/java/com/ning/http/client/resumable/ResumableAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
index b1eda42f8..3200f5486 100644
--- a/api/src/main/java/com/ning/http/client/resumable/ResumableAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
@@ -10,17 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.resumable;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.Response.ResponseBuilder;
-import com.ning.http.client.listener.TransferCompletionHandler;
+package org.asynchttpclient.resumable;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.Response.ResponseBuilder;
+import org.asynchttpclient.listener.TransferCompletionHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,7 +34,7 @@
 /**
  * An {@link AsyncHandler} which support resumable download, e.g when used with an {@link ResumableIOExceptionFilter},
  * this handler can resume the download operation at the point it was before the interruption occured. This prevent having to
- * download the entire file again. It's the responsibility of the {@link com.ning.http.client.listener.TransferListener}
+ * download the entire file again. It's the responsibility of the {@link org.asynchttpclient.listener.TransferListener}
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <p/>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
diff --git a/api/src/main/java/com/ning/http/client/resumable/ResumableIOExceptionFilter.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
similarity index 73%
rename from api/src/main/java/com/ning/http/client/resumable/ResumableIOExceptionFilter.java
rename to api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
index 7e2bd1d25..2b686f7ba 100644
--- a/api/src/main/java/com/ning/http/client/resumable/ResumableIOExceptionFilter.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
@@ -10,15 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
-import com.ning.http.client.Request;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
 
 /**
- * Simple {@link IOExceptionFilter} that replay the current {@link com.ning.http.client.Request} using
+ * Simple {@link org.asynchttpclient.filter.IOExceptionFilter} that replay the current {@link org.asynchttpclient.Request} using
  * a {@link ResumableAsyncHandler}
  */
 public class ResumableIOExceptionFilter implements IOExceptionFilter {
diff --git a/api/src/main/java/com/ning/http/client/resumable/ResumableListener.java b/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
similarity index 97%
rename from api/src/main/java/com/ning/http/client/resumable/ResumableListener.java
rename to api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
index 0b55ac225..252236cba 100644
--- a/api/src/main/java/com/ning/http/client/resumable/ResumableListener.java
+++ b/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/com/ning/http/client/simple/HeaderMap.java b/api/src/main/java/org/asynchttpclient/simple/HeaderMap.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/simple/HeaderMap.java
rename to api/src/main/java/org/asynchttpclient/simple/HeaderMap.java
index f081e2ff3..92476cc6a 100644
--- a/api/src/main/java/com/ning/http/client/simple/HeaderMap.java
+++ b/api/src/main/java/org/asynchttpclient/simple/HeaderMap.java
@@ -1,4 +1,4 @@
-package com.ning.http.client.simple;
+package org.asynchttpclient.simple;
 
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
@@ -13,7 +13,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 
 import java.util.Collection;
 import java.util.List;
diff --git a/api/src/main/java/com/ning/http/client/simple/SimpleAHCTransferListener.java b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/simple/SimpleAHCTransferListener.java
rename to api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
index 39d780c32..b8e300f02 100644
--- a/api/src/main/java/com/ning/http/client/simple/SimpleAHCTransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
@@ -1,4 +1,4 @@
-package com.ning.http.client.simple;
+package org.asynchttpclient.simple;
 
 /*
  * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
@@ -13,14 +13,14 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import com.ning.http.client.SimpleAsyncHttpClient;
+import org.asynchttpclient.SimpleAsyncHttpClient;
 
 /**
  * A simple transfer listener for use with the {@link SimpleAsyncHttpClient}.
  * <p/>
  * Note: This listener does not cover requests failing before a connection is
  * established. For error handling, see
- * {@link com.ning.http.client.SimpleAsyncHttpClient.Builder#setDefaultThrowableHandler(com.ning.http.client.ThrowableHandler)}
+ * {@link org.asynchttpclient.SimpleAsyncHttpClient.Builder#setDefaultThrowableHandler(org.asynchttpclient.ThrowableHandler)}
  *
  * @author Benjamin Hanzelmann
  */
diff --git a/api/src/main/java/com/ning/http/util/AllowAllHostnameVerifier.java b/api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java
similarity index 96%
rename from api/src/main/java/com/ning/http/util/AllowAllHostnameVerifier.java
rename to api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java
index 0223cc1ee..d32424daf 100644
--- a/api/src/main/java/com/ning/http/util/AllowAllHostnameVerifier.java
+++ b/api/src/main/java/org/asynchttpclient/util/AllowAllHostnameVerifier.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
diff --git a/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
similarity index 78%
rename from api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
rename to api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
index 6d417cf93..70ab5a60a 100644
--- a/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
@@ -10,20 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
-
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.ByteArrayPart;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FilePart;
-import com.ning.http.client.FluentStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.Part;
-import com.ning.http.client.StringPart;
-import com.ning.http.multipart.ByteArrayPartSource;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.multipart.PartSource;
+package org.asynchttpclient.util;
 
 import java.io.ByteArrayInputStream;
 import java.io.FileNotFoundException;
@@ -32,20 +19,37 @@
 import java.io.SequenceInputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URI;
-import java.text.ParseException;
+import java.net.URISyntaxException;
+import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Date;
 import java.util.List;
 import java.util.Locale;
 import java.util.Vector;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.ByteArrayPart;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FilePart;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Part;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.StringPart;
+import org.asynchttpclient.multipart.ByteArrayPartSource;
+import org.asynchttpclient.multipart.MultipartRequestEntity;
+import org.asynchttpclient.multipart.PartSource;
+
 /**
- * {@link com.ning.http.client.AsyncHttpProvider} common utilities.
+ * {@link org.asynchttpclient.AsyncHttpProvider} common utilities.
  * <p/>
  * The cookies's handling code is from the Netty framework.
  */
 public class AsyncHttpProviderUtils {
+    
     private final static byte[] NO_BYTES = new byte[0];
 
     public final static String DEFAULT_CHARSET = "ISO-8859-1";
@@ -58,14 +62,13 @@
 
             return new SimpleDateFormat[]
                     {
-                            new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy", Locale.US),  //ASCTIME
+                            new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US), // RFC1123
                             new SimpleDateFormat("EEEE, dd-MMM-yy HH:mm:ss zzz", Locale.US), //RFC1036
+                            new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy", Locale.US), //ASCTIME
                             new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US),
                             new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US),
                             new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US),
-                            new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss Z", Locale.US),
-                            new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US) // RFC1123
-
+                            new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss Z", Locale.US)
                     };
         }
     };
@@ -140,14 +143,18 @@
 
     static final String VERSION = "Version";
 
-    public final static URI createUri(String u) {
-        URI uri = URI.create(u);
+    public static final void validateSupportedScheme(URI uri) {
         final String scheme = uri.getScheme();
         if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws")
                 && !scheme.equalsIgnoreCase("wss")) {
-            throw new IllegalArgumentException("The URI scheme, of the URI " + u
+            throw new IllegalArgumentException("The URI scheme, of the URI " + uri
                     + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
         }
+    }
+
+    public final static URI createUri(String u) {
+        URI uri = URI.create(u);
+        validateSupportedScheme(uri);
 
         String path = uri.getPath();
         if (path == null) {
@@ -274,19 +281,48 @@ public final static String getHost(URI uri) {
     public final static URI getRedirectUri(URI uri, String location) {
         if(location == null)
             throw new IllegalArgumentException("URI " + uri + " was redirected to null location");
-        URI newUri = uri.resolve(location);
+        
+        URI locationURI = null;
+        try {
+            locationURI = new URI(location);
+        } catch (URISyntaxException e) {
+            // rich, we have a badly encoded location, let's try to encode the query params
+            String[] parts = location.split("\\?");
+            if (parts.length != 2) {
+                throw new IllegalArgumentException("Don't know how to turn this location into a proper URI:" + location, e);
+            } else {
+                StringBuilder properUrl = new StringBuilder(location.length()).append(parts[0]).append("?");
+                
+                String[] queryParams = parts[1].split("&");
+                for (int i = 0; i < queryParams.length; i++) {
+                    String queryParam = queryParams[i];
+                    if (i != 0)
+                        properUrl.append("&");
+                    String[] nameValue = queryParam.split("=", 2);
+                    UTF8UrlEncoder.appendEncoded(properUrl, nameValue[0]);
+                    if (nameValue.length == 2) {
+                        properUrl.append("=");
+                        UTF8UrlEncoder.appendEncoded(properUrl, nameValue[1]);
+                    }
+                }
+                
+                locationURI = URI.create(properUrl.toString());
+            }
+        }
+        
+        URI redirectUri = uri.resolve(locationURI);
 
-        String scheme = newUri.getScheme();
+        String scheme = redirectUri.getScheme();
 
         if (scheme == null || !scheme.equalsIgnoreCase("http")
                 && !scheme.equalsIgnoreCase("https")
                 && !scheme.equals("ws")
                 && !scheme.equals("wss")) {
-            throw new IllegalArgumentException("The URI scheme, of the URI " + newUri
+            throw new IllegalArgumentException("The URI scheme, of the URI " + redirectUri
                     + ", must be equal (ignoring case) to 'ws, 'wss', 'http', or 'https'");
         }
 
-        return newUri;
+        return redirectUri.normalize();
     }
 
     public final static int getPort(URI uri) {
@@ -300,30 +336,30 @@ public final static int getPort(URI uri) {
      * This is quite ugly as our internal names are duplicated, but we build on top of HTTP Client implementation.
      *
      * @param params
-     * @param methodParams
+     * @param requestHeaders
      * @return a MultipartRequestEntity.
      * @throws java.io.FileNotFoundException
      */
-    public final static MultipartRequestEntity createMultipartRequestEntity(List<Part> params, FluentStringsMap methodParams) throws FileNotFoundException {
-        com.ning.http.multipart.Part[] parts = new com.ning.http.multipart.Part[params.size()];
+    public final static MultipartRequestEntity createMultipartRequestEntity(List<Part> params, FluentCaseInsensitiveStringsMap requestHeaders) throws FileNotFoundException {
+        org.asynchttpclient.multipart.Part[] parts = new org.asynchttpclient.multipart.Part[params.size()];
         int i = 0;
 
         for (Part part : params) {
-            if (part instanceof com.ning.http.multipart.Part) {
-                parts[i] = (com.ning.http.multipart.Part) part;
+            if (part instanceof org.asynchttpclient.multipart.Part) {
+                parts[i] = (org.asynchttpclient.multipart.Part) part;
             } else if (part instanceof StringPart) {
-                parts[i] = new com.ning.http.multipart.StringPart(part.getName(),
+                parts[i] = new org.asynchttpclient.multipart.StringPart(part.getName(),
                         ((StringPart) part).getValue(),
                         ((StringPart) part).getCharset());
             } else if (part instanceof FilePart) {
-                parts[i] = new com.ning.http.multipart.FilePart(part.getName(),
+                parts[i] = new org.asynchttpclient.multipart.FilePart(part.getName(),
                         ((FilePart) part).getFile(),
                         ((FilePart) part).getMimeType(),
                         ((FilePart) part).getCharSet());
 
             } else if (part instanceof ByteArrayPart) {
                 PartSource source = new ByteArrayPartSource(((ByteArrayPart) part).getFileName(), ((ByteArrayPart) part).getData());
-                parts[i] = new com.ning.http.multipart.FilePart(part.getName(),
+                parts[i] = new org.asynchttpclient.multipart.FilePart(part.getName(),
                         source,
                         ((ByteArrayPart) part).getMimeType(),
                         ((ByteArrayPart) part).getCharSet());
@@ -336,7 +372,7 @@ public final static MultipartRequestEntity createMultipartRequestEntity(List<Par
             }
             ++i;
         }
-        return new MultipartRequestEntity(parts, methodParams);
+        return new MultipartRequestEntity(parts, requestHeaders);
     }
 
     public final static byte[] readFully(InputStream in, int[] lengthWrapper) throws IOException {
@@ -469,7 +505,7 @@ private static void add(StringBuilder sb, String name, int val) {
 
     public static String constructUserAgent(Class<? extends AsyncHttpProvider> httpProvider,
                                             AsyncHttpClientConfig config) {
-        return new StringBuffer(config.getUserAgent())
+        return new StringBuilder(config.getUserAgent())
                 .append(' ')
                 .append('(')
                 .append(httpProvider.getSimpleName())
@@ -503,85 +539,28 @@ public static String parseCharset(String contentType) {
         return null;
     }
 
-    public static Cookie parseCookie(String value) {
-        String[] fields = value.split(";\\s*");
-        String[] cookie = fields[0].split("=", 2);
-        String cookieName = cookie[0];
-        String cookieValue = (cookie.length == 1) ? null : cookie[1];
-
-        int maxAge = -1;
-        String path = null;
-        String domain = null;
-        boolean secure = false;
-
-        boolean maxAgeSet = false;
-        boolean expiresSet = false;
-
-        for (int j = 1; j < fields.length; j++) {
-            if ("secure".equalsIgnoreCase(fields[j])) {
-                secure = true;
-            } else if (fields[j].indexOf('=') > 0) {
-                String[] f = fields[j].split("=");
-                if (f.length == 1) continue; // Add protection against null field values
-
-                // favor 'max-age' field over 'expires'
-                if (!maxAgeSet && "max-age".equalsIgnoreCase(f[0])) {
-                    try {
-                        maxAge = Math.max(Integer.valueOf(removeQuote(f[1])), 0);
-                    } catch (NumberFormatException e1) {
-                        // ignore failure to parse -> treat as session cookie
-                        // invalidate a previously parsed expires-field
-                        maxAge = -1;
-                    }
-                    maxAgeSet = true;
-                } else if (!maxAgeSet && !expiresSet && "expires".equalsIgnoreCase(f[0])) {
-                    try {
-                        maxAge = Math.max(convertExpireField(f[1]), 0);
-                    } catch (Exception e) {
-                        // original behavior, is this correct at all (expires field with max-age semantics)?
-                        try {
-                            maxAge = Math.max(Integer.valueOf(f[1]), 0);
-                        } catch (NumberFormatException e1) {
-                            // ignore failure to parse -> treat as session cookie
-                        }
-                    }
-                    expiresSet = true;
-                } else if ("domain".equalsIgnoreCase(f[0])) {
-                    domain = f[1];
-                } else if ("path".equalsIgnoreCase(f[0])) {
-                    path = f[1];
-                }
-            }
-        }
-
-        return new Cookie(domain, cookieName, cookieValue, path, maxAge, secure);
-    }
-
-    public static int convertExpireField(String timestring) throws Exception {
-        Exception exception = null;
+    public static int convertExpireField(String timestring) {
         String trimmedTimeString = removeQuote(timestring.trim());
-        long now = System.currentTimeMillis();
+
         for (SimpleDateFormat sdf : simpleDateFormat.get()) {
-            try {
-                long expire = sdf.parse(trimmedTimeString).getTime();
-                return (int) ((expire - now) / 1000);
-            } catch (ParseException e) {
-                exception = e;
-            } catch (NumberFormatException e) {
-                exception = e;
+            Date date = sdf.parse(trimmedTimeString, new ParsePosition(0));
+            if (date != null) {
+                long now = System.currentTimeMillis();
+                long maxAgeMillis = date.getTime() - now;
+                return (int) (maxAgeMillis / 1000) + (maxAgeMillis % 1000 != 0 ? 1 : 0);
             }
         }
 
-        throw exception;
+        throw new IllegalArgumentException("Not a valid expire field " + trimmedTimeString);
     }
 
     private final static String removeQuote(String s) {
-        if (s.startsWith("\"")) {
-            s = s.substring(1);
-        }
+        if (MiscUtil.isNonEmpty(s)) {
+            if (s.charAt(0) == '"')
+                s = s.substring(1);
 
-        if (s.endsWith("\"")) {
-            s = s.substring(0, s.length() - 1);
+            if (s.charAt(s.length() - 1) == '"')
+                s = s.substring(0, s.length() - 1);
         }
         return s;
     }
@@ -595,4 +574,12 @@ public static void checkBodyParts(int statusCode, Collection<HttpResponseBodyPar
             throw new IllegalStateException(BODY_NOT_COMPUTED);
         }
     }
+
+    public static String keepAliveHeaderValue(AsyncHttpClientConfig config) {
+        return config.getAllowPoolingConnection() ? "keep-alive" : "close";
+    }
+
+    public static int requestTimeout(AsyncHttpClientConfig config, Request request) {
+        return request.getRequestTimeoutInMs() != 0 ? request.getRequestTimeoutInMs() : config.getRequestTimeoutInMs();
+    }
 }
diff --git a/api/src/main/java/com/ning/http/util/AuthenticatorUtils.java b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
similarity index 91%
rename from api/src/main/java/com/ning/http/util/AuthenticatorUtils.java
rename to api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index 10a6bdb11..27ff662c2 100644
--- a/api/src/main/java/com/ning/http/util/AuthenticatorUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,10 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Realm;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
 
 import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
@@ -40,7 +42,7 @@ public static String computeDigestAuthentication(Realm realm) throws NoSuchAlgor
         builder.append("algorithm").append('=').append(realm.getAlgorithm()).append(", ");
 
         construct(builder, "response", realm.getResponse());
-        if (realm.getOpaque() != null && realm.getOpaque() != null && realm.getOpaque().equals("") == false)
+        if (isNonEmpty(realm.getOpaque()))
             construct(builder, "opaque", realm.getOpaque());
         builder.append("qop").append('=').append(realm.getQop()).append(", ");
         builder.append("nc").append('=').append(realm.getNc()).append(", ");
diff --git a/api/src/main/java/com/ning/http/util/Base64.java b/api/src/main/java/org/asynchttpclient/util/Base64.java
similarity index 99%
rename from api/src/main/java/com/ning/http/util/Base64.java
rename to api/src/main/java/org/asynchttpclient/util/Base64.java
index fe5d54829..c6141d065 100644
--- a/api/src/main/java/com/ning/http/util/Base64.java
+++ b/api/src/main/java/org/asynchttpclient/util/Base64.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 /**
  * Implements the "base64" binary encoding scheme as defined by
diff --git a/api/src/main/java/com/ning/http/util/DateUtil.java b/api/src/main/java/org/asynchttpclient/util/DateUtil.java
similarity index 98%
rename from api/src/main/java/com/ning/http/util/DateUtil.java
rename to api/src/main/java/org/asynchttpclient/util/DateUtil.java
index dc1f12042..dfc0d55ef 100644
--- a/api/src/main/java/com/ning/http/util/DateUtil.java
+++ b/api/src/main/java/org/asynchttpclient/util/DateUtil.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 /*
  * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/java/org/apache/commons/httpclient/util/DateUtil.java,v 1.2 2004/12/24 20:36:13 olegk Exp $
@@ -226,7 +226,9 @@ public DateParseException() {
         public DateParseException(String message) {
             super(message);
         }
-
     }
 
+    public static long millisTime() {
+        return System.nanoTime() / 1000000;
+    }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyDeferringAsyncHandlerTest.java b/api/src/main/java/org/asynchttpclient/util/MiscUtil.java
similarity index 50%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
rename to api/src/main/java/org/asynchttpclient/util/MiscUtil.java
index 91627853f..b65d1e4a7 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
+++ b/api/src/main/java/org/asynchttpclient/util/MiscUtil.java
@@ -10,19 +10,33 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.util;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BodyDeferringAsyncHandlerTest;
-import com.ning.http.client.async.ProviderUtil;
+import java.util.Collection;
+import java.util.Map;
 
-public class NettyBodyDeferringAsyncHandlerTest extends
-        BodyDeferringAsyncHandlerTest {
+public class MiscUtil {
 
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+    private MiscUtil() {
     }
 
+    public static boolean isNonEmpty(String string) {
+        return string != null && !string.isEmpty();
+    }
+
+    public static boolean isNonEmpty(Object[] array) {
+        return array != null && array.length != 0;
+    }
+
+    public static boolean isNonEmpty(byte[] array) {
+        return array != null && array.length != 0;
+    }
+
+    public static boolean isNonEmpty(Collection<?> collection) {
+        return collection != null && !collection.isEmpty();
+    }
+
+    public static boolean isNonEmpty(Map<?, ?> map) {
+        return map != null && !map.isEmpty();
+    }
 }
diff --git a/api/src/main/java/com/ning/http/util/ProxyUtils.java b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
similarity index 85%
rename from api/src/main/java/com/ning/http/util/ProxyUtils.java
rename to api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index a3bd9f58e..6e33588f6 100644
--- a/api/src/main/java/com/ning/http/util/ProxyUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -10,16 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.ProxyServer.Protocol;
-import com.ning.http.client.Request;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 
-import java.net.URI;
 import java.util.List;
 import java.util.Properties;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.ProxyServer.Protocol;
+import org.asynchttpclient.Request;
+
 /**
  * Utilities for Proxy handling.
  *
@@ -27,7 +29,7 @@
  */
 public class ProxyUtils {
 
-    private static final String PROPERTY_PREFIX = "com.ning.http.client.AsyncHttpClientConfig.proxy.";
+    private static final String PROPERTY_PREFIX = "org.asynchttpclient.AsyncHttpClientConfig.proxy.";
 
     /**
      * The host to use as proxy.
@@ -59,6 +61,19 @@
      */
     public static final String PROXY_PASSWORD = PROPERTY_PREFIX + "password";
 
+    /**
+     * @param config the global config
+     * @param request the request
+     * @return the proxy server to be used for this request (can be null)
+     */
+    public static ProxyServer getProxyServer(AsyncHttpClientConfig config, Request request) {
+        ProxyServer proxyServer = request.getProxyServer();
+        if (proxyServer == null) {
+            proxyServer = config.getProxyServer();
+        }
+        return ProxyUtils.avoidProxy(proxyServer, request) ? null : proxyServer;
+    }
+    
     /**
      * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to
      * target host. If <code>null</code> proxy is passed in, this method returns true -- since there is NO proxy, we
@@ -70,7 +85,7 @@
      * @return true if we have to avoid proxy use (obeying non-proxy hosts settings), false otherwise.
      */
     public static boolean avoidProxy(final ProxyServer proxyServer, final Request request) {
-        return avoidProxy(proxyServer, AsyncHttpProviderUtils.getHost(URI.create(request.getUrl())));
+        return avoidProxy(proxyServer, AsyncHttpProviderUtils.getHost(request.getOriginalURI()));
     }
 
     /**
@@ -89,7 +104,7 @@ public static boolean avoidProxy(final ProxyServer proxyServer, final String tar
 
             List<String> nonProxyHosts = proxyServer.getNonProxyHosts();
 
-            if (nonProxyHosts != null && nonProxyHosts.size() > 0) {
+            if (isNonEmpty(nonProxyHosts)) {
                 for (String nonProxyHost : nonProxyHosts) {
                     if (nonProxyHost.startsWith("*") && nonProxyHost.length() > 1
                             && targetHost.endsWith(nonProxyHost.substring(1).toLowerCase())) {
diff --git a/api/src/main/java/com/ning/http/util/SslUtils.java b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
similarity index 99%
rename from api/src/main/java/com/ning/http/util/SslUtils.java
rename to api/src/main/java/org/asynchttpclient/util/SslUtils.java
index dc5f2643e..2ac9769b1 100644
--- a/api/src/main/java/com/ning/http/util/SslUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.KeyManagerFactory;
diff --git a/api/src/main/java/com/ning/http/util/UTF8Codec.java b/api/src/main/java/org/asynchttpclient/util/UTF8Codec.java
similarity index 98%
rename from api/src/main/java/com/ning/http/util/UTF8Codec.java
rename to api/src/main/java/org/asynchttpclient/util/UTF8Codec.java
index 29ee4cc20..8a18326cd 100644
--- a/api/src/main/java/com/ning/http/util/UTF8Codec.java
+++ b/api/src/main/java/org/asynchttpclient/util/UTF8Codec.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 import java.io.UnsupportedEncodingException;
 
diff --git a/api/src/main/java/com/ning/http/util/UTF8UrlEncoder.java b/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
similarity index 96%
rename from api/src/main/java/com/ning/http/util/UTF8UrlEncoder.java
rename to api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
index a7d463f4f..80b5ca4e8 100644
--- a/api/src/main/java/com/ning/http/util/UTF8UrlEncoder.java
+++ b/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
@@ -13,14 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
 /**
  * Convenience class that encapsulates details of "percent encoding"
  * (as per RFC-3986, see [http://www.ietf.org/rfc/rfc3986.txt]).
  */
 public class UTF8UrlEncoder {
-    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.com.ning.http.util.UTF8UrlEncoder.encodeSpaceUsingPlus") == null ? false : true;
+    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.UTF8UrlEncoder.encodeSpaceUsingPlus") == null ? false : true;
 
     /**
      * Encoding table used for figuring out ascii characters that must be escaped
diff --git a/api/src/main/java/com/ning/http/client/webdav/WebDavCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/webdav/WebDavCompletionHandlerBase.java
rename to api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index 2d025825e..74ac5ab68 100644
--- a/api/src/main/java/com/ning/http/client/webdav/WebDavCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -11,14 +11,14 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.webdav;
-
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
+package org.asynchttpclient.webdav;
+
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -103,7 +103,7 @@ public void onThrowable(Throwable t) {
     /**
      * Invoked once the HTTP response has been fully read.
      *
-     * @param response The {@link com.ning.http.client.Response}
+     * @param response The {@link org.asynchttpclient.Response}
      * @return Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
      */
     abstract public T onCompleted(WebDavResponse response) throws Exception;
diff --git a/api/src/main/java/com/ning/http/client/webdav/WebDavResponse.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
similarity index 90%
rename from api/src/main/java/com/ning/http/client/webdav/WebDavResponse.java
rename to api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
index c77cee032..340e4be2e 100644
--- a/api/src/main/java/com/ning/http/client/webdav/WebDavResponse.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
@@ -10,17 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.webdav;
+package org.asynchttpclient.webdav;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.Response;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.Response;
 import org.w3c.dom.Document;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URI;
+import java.nio.ByteBuffer;
 import java.util.List;
 
 /**
@@ -49,6 +50,10 @@ public String getStatusText() {
         return response.getResponseBodyAsBytes();
     }
 
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return response.getResponseBodyAsByteBuffer();
+    }
+
     public InputStream getResponseBodyAsStream() throws IOException {
         return response.getResponseBodyAsStream();
     }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java b/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
new file mode 100644
index 000000000..218d5ab32
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.websocket;
+
+/**
+ * Default WebSocketListener implementation.  Most methods are no-ops.  This 
+ * allows for quick override customization without clutter of methods that the
+ * developer isn't interested in dealing with.
+ * 
+ * @since 1.7.0
+ */
+public class DefaultWebSocketListener implements  WebSocketByteListener, WebSocketTextListener, WebSocketPingListener, WebSocketPongListener {
+
+    protected WebSocket webSocket;
+    
+    // -------------------------------------- Methods from WebSocketByteListener
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMessage(byte[] message) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onFragment(byte[] fragment, boolean last) {
+    }
+
+    
+    // -------------------------------------- Methods from WebSocketPingListener
+    
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPing(byte[] message) {
+    }
+
+    
+    // -------------------------------------- Methods from WebSocketPongListener
+    
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPong(byte[] message) {
+    }
+    
+    
+    // -------------------------------------- Methods from WebSocketTextListener
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMessage(String message) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onFragment(String fragment, boolean last) {
+    }
+    
+    
+    // ------------------------------------------ Methods from WebSocketListener
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onOpen(WebSocket websocket) {
+        this.webSocket = websocket;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onClose(WebSocket websocket) {
+        this.webSocket = null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onError(Throwable t) {
+    }
+}
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocket.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocket.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
index 3917a6b4a..9e9c981c1 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocket.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
@@ -10,12 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
+
+import java.io.Closeable;
 
 /**
  * A Websocket client
  */
-public interface WebSocket {
+public interface WebSocket extends Closeable {
 
     /**
      * Send a byte message.
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketByteListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketByteListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
index e4f9362f1..86ed26180 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketByteListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * A {@link WebSocketListener} for bytes
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketCloseCodeReasonListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketCloseCodeReasonListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java
index af524527b..ad1b25f0b 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketCloseCodeReasonListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * Extend the normal close listener with one that support the WebSocket's code and reason.
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
index 360f66cf2..bf187be07 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * A generic {@link WebSocketListener} for WebSocket events. Use the appropriate listener for receiving message bytes.
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketPingListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
similarity index 95%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketPingListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
index 5980c67b9..7abc8ab4a 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketPingListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * A WebSocket's Ping Listener
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketPongListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
similarity index 95%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketPongListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
index 559abc97b..f140a2208 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketPongListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * A WebSocket's Pong Listener
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketTextListener.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
similarity index 96%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketTextListener.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
index 1b56319a8..d52bfad0e 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketTextListener.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
 /**
  * A {@link WebSocketListener} for text message
diff --git a/api/src/main/java/com/ning/http/client/websocket/WebSocketUpgradeHandler.java b/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
similarity index 93%
rename from api/src/main/java/com/ning/http/client/websocket/WebSocketUpgradeHandler.java
rename to api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
index 46ef3fa8b..870d74c54 100644
--- a/api/src/main/java/com/ning/http/client/websocket/WebSocketUpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.UpgradeHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.UpgradeHandler;
 
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -35,6 +35,7 @@
     @SuppressWarnings("unused")
     private final long maxTextSize;
     private final AtomicBoolean ok = new AtomicBoolean(false);
+    private final AtomicBoolean onSuccessCalled = new AtomicBoolean(false);
 
     private WebSocketUpgradeHandler(Builder b) {
         l = b.l;
@@ -51,6 +52,10 @@ public final void onThrowable(Throwable t) {
         onFailure(t);
     }
 
+    public boolean touchSuccess(){
+        return onSuccessCalled.getAndSet(true);
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/api/src/main/java/com/ning/http/client/version.properties b/api/src/main/resources/org/asynchttpclient/version.properties
similarity index 100%
rename from api/src/main/java/com/ning/http/client/version.properties
rename to api/src/main/resources/org/asynchttpclient/version.properties
diff --git a/api/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java b/api/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java
deleted file mode 100755
index 7724e9c48..000000000
--- a/api/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java
+++ /dev/null
@@ -1,1621 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpClientConfig.Builder;
-import com.ning.http.client.AsyncHttpClientConfigBean;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.Part;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.StringPart;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.nio.channels.UnresolvedAddressException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
-
-public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
-    private static final String UTF_8 = "text/html;charset=UTF-8";
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncProviderEncodingTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html?q=+%20x").build();
-        String requestUrl = request.getUrl();
-        Assert.assertEquals(requestUrl, "http://foo.com/foo.html?q=%20%20x");
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
-
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
-
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/foo.html?q=%20%20x");
-        p.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncProviderEncodingTest2() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html")
-                .addQueryParameter("q", "a b")
-                .build();
-
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
-
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
-
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/foo.html?q=a%20b");
-        p.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void emptyRequestURI() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com")
-                .build();
-
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
-
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
-
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/");
-        p.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncProviderContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
-        URL url = new URL(getTargetUrl());
-        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.connect();
-
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    int contentLenght = -1;
-                    if (response.getHeader("content-length") != null) {
-                        contentLenght = Integer.valueOf(response.getHeader("content-length"));
-                    }
-                    int ct = connection.getContentLength();
-                    assertEquals(contentLenght, ct);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("Unexpected exception", t);
-                } finally {
-                    l.countDown();
-                }
-            }
-
-
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-
-        p.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncContentTypeGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getContentType(), UTF_8);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        p.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncHeaderGETTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getContentType(), UTF_8);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        n.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncHeaderPOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
-
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    System.out.println(">>>>> " + response.getStatusText());
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        assertEquals(response.getHeader("X-Test" + i), "Test" + i);
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        n.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncParamPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        for (int i = 0; i < 5; i++) {
-            m.put("param_" + i, Arrays.asList("value_" + i));
-        }
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).build();
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                    }
-
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        n.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncStatusHEADTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
-        Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        try {
-            String s = response.getResponseBody();
-            Assert.assertEquals("",s);
-        } catch (IllegalStateException ex) {
-            fail();
-        }
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        n.close();
-
-    }
-
-    // TODO: fix test
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = false)
-    public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setRequestTimeoutInMs(120 * 1000).build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD")
-                .setUrl(getTargetUrl())
-                .build();
-
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.fail();
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    assertEquals(t.getClass(), IOException.class);
-                    assertEquals(t.getMessage(), "No response received. Connection timed out");
-                } finally {
-                    l.countDown();
-                }
-
-            }
-        }).get();
-
-        if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        n.close();
-
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncNullSchemeTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        try {
-            c.prepareGet("www.sun.com").execute();
-            Assert.fail();
-        } catch (IllegalArgumentException ex) {
-            Assert.assertTrue(true);
-        }
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetTransferEncodingTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
-
-        c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader("Transfer-Encoding"), "chunked");
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetHeadersTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-        c.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        assertEquals(response.getHeader("X-Test" + i), "Test" + i);
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetCookieTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-
-        final Cookie coo = new Cookie("/", "foo", "value", "/", -1, false);
-        c.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    List<Cookie> cookies = response.getCookies();
-                    assertEquals(cookies.size(), 1);
-                    assertEquals(cookies.get(0).toString(), coo.toString());
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostDefaultContentType() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        c.preparePost(getTargetUrl()).addParameter("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    FluentCaseInsensitiveStringsMap h = response.getHeaders();
-                    assertEquals(h.getJoinedValue("X-Content-Type", ", "), "application/x-www-form-urlencoded");
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostBodyIsoTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response r = c.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
-        assertEquals(r.getResponseBody().getBytes("ISO-8859-1"),"\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
-        c.close();
-    }
-    
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostBytesTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostInputStreamTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPutInputStreamTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-        c.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostEntityWriterTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        final StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        byte[] bytes = sb.toString().getBytes();
-        h.add("Content-Length", String.valueOf(bytes.length));
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(new Request.EntityWriter() {
-
-            /* @Override */
-            public void writeEntity(OutputStream out) throws IOException {
-                out.write(sb.toString().getBytes("UTF-8"));
-            }
-        }).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostMultiPartTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-
-        Part p = new StringPart("foo", "bar");
-
-        c.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    String xContentType = response.getHeader("X-Content-Type");
-                    String boundary = xContentType.substring(
-                            (xContentType.indexOf("boundary") + "boundary".length() + 1));
-
-                    String s = response.getResponseBodyExcerpt(boundary.length() + "--".length()).substring("--".length());
-                    assertEquals(boundary, s);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostBasicGZIPTest() throws Throwable {
-
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader("X-Accept-Encoding"), "gzip");
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostProxyTest() throws Throwable {
-
-        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        Response response = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-        }).get();
-
-
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-Proxy-Connection"), "keep-alive");
-        c.close();
-    }
-
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncRequestVirtualServerPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        for (int i = 0; i < 5; i++) {
-            m.put("param_" + i, Arrays.asList("value_" + i));
-        }
-        Request request = new RequestBuilder("POST")
-                .setUrl(getTargetUrl())
-                .setHeaders(h)
-                .setParameters(m)
-                .setVirtualHost("localhost:" + port1)
-                .build();
-
-        Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
-
-        assertEquals(response.getStatusCode(), 200);
-        if (response.getHeader("X-Host").startsWith("localhost")) {
-            assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
-        } else {
-            assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
-        }
-        n.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPutTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        Response response = c.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
-
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostLatchBytesTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                    }
-                    return response;
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostDelayCancelTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
-
-        Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter(){
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-        });
-        future.cancel(true);
-        Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
-        Assert.assertNull(response);
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostDelayBytesTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
-
-        try {
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                }
-            });
-
-            future.get(10, TimeUnit.SECONDS);
-        } catch (ExecutionException ex) {            
-            if (ex.getCause() != null && TimeoutException.class.isAssignableFrom(ex.getCause().getClass())) {
-                Assert.assertTrue(true);
-            }
-        } catch (TimeoutException te) {
-            Assert.assertTrue(true);
-        } catch (IllegalStateException ex) {
-            Assert.assertTrue(false);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostNullBytesTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
-
-        Response response = future.get();
-        Assert.assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostListenerBytesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        final CountDownLatch l = new CountDownLatch(1);
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Latch time out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidFuture() throws Throwable {
-
-        int dummyPort = findFreePort();
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicInteger count = new AtomicInteger();
-        for (int i = 0; i < 20; i++) {
-            try {
-                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                    /* @Override */
-                    public void onThrowable(Throwable t) {
-                        count.incrementAndGet();
-                    }
-                }).get();
-                assertNull(response, "Should have thrown ExecutionException");
-            } catch (ExecutionException ex) {
-                Throwable cause = ex.getCause();
-                if (!(cause instanceof ConnectException)) {
-                    fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
-                }
-            }
-        }
-        assertEquals(count.get(), 20);
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidPortFuture() throws Throwable {
-
-        int dummyPort = findFreePort();
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                /* @Override */
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                }
-            }).get();
-            assertNull(response, "Should have thrown ExecutionException");
-        } catch (ExecutionException ex) {
-            Throwable cause = ex.getCause();
-            if (!(cause instanceof ConnectException)) {
-                fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
-            }
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        // pick a random unused local port
-        int port = findFreePort();
-
-        try {
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                /* @Override */
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                }
-            }).get();
-            assertNull(response, "No ExecutionException was thrown");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidHandlerPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        int port = findFreePort();
-
-        c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                try {
-                    assertEquals(t.getClass(), ConnectException.class);
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncConnectInvalidHandlerHost() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-
-        c.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                if (t != null) {
-                    if (t.getClass().equals(ConnectException.class)) {
-                        l.countDown();
-                    } else if (t.getClass().equals(UnresolvedAddressException.class)) {
-                        l.countDown();
-                    }
-                }
-            }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        c.close();
-    }
-
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidFuturePort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicBoolean rightCause = new AtomicBoolean(false);
-        // pick a random unused local port
-        int port = findFreePort();
-
-        try {
-            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                    called.set(true);
-                    if (t instanceof ConnectException) {
-                        rightCause.set(true);
-                    }
-                }
-            }).get();
-            assertNull(response, "No ExecutionException was thrown");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        }
-        assertTrue(called.get(), "onThrowable should get called.");
-        assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
-
-        Assert.assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncResponseBodyTooLarge() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
-
-        Assert.assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncResponseEmptyBody() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
-
-        assertEquals(response.getResponseBody(),"");
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "asyncAPI"})
-    public void asyncAPIContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-        });
-
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "asyncAPI"})
-    public void asyncAPIHandlerExceptionTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                throw new IllegalStateException("FOO");
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t.getMessage() != null) {
-                        assertEquals(t.getMessage(), "FOO");
-                    }
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetDelayHandlerTest() throws Throwable {
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("LockThread", "true");
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(5 * 1000).build());
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    Assert.fail("Must not receive a response");
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t instanceof TimeoutException) {
-                        Assert.assertTrue(true);
-                    } else {
-                        Assert.fail("Unexpected exception", t);
-                    }
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetQueryStringTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    Assert.assertTrue(response.getHeader("X-pathInfo") != null);
-                    Assert.assertTrue(response.getHeader("X-queryString") != null);
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-        };
-
-        Request req = new RequestBuilder("GET")
-                .setUrl(getTargetUrl() + "?foo=bar").build();
-
-        client.executeRequest(req, handler).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoGetKeepAliveHandlerTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-            String remoteAddr = null;
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                assertEquals(response.getStatusCode(), 200);
-                if (remoteAddr == null) {
-                    remoteAddr = response.getHeader("X-KEEP-ALIVE");
-                    l.countDown();
-                } else {
-                    assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
-                    l.countDown();
-                }
-
-                return response;
-            }
-        };
-
-        client.prepareGet(getTargetUrl()).execute(handler).get();
-        client.prepareGet(getTargetUrl()).execute(handler);
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncDoGetMaxRedirectTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaximumNumberOfRedirects(0).setFollowRedirects(true).build());
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.fail("Should not be here");
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                try {
-                    assertEquals(t.getClass(), MaxRedirectException.class);
-                } finally {
-                    l.countDown();
-                }
-            }
-        };
-
-        client.prepareGet("http://google.com/").execute(handler);
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncDoGetNestedTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
-
-        final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
-
-            private final static int MAX_NESTED = 2;
-
-            private AtomicInteger nestedCount = new AtomicInteger(0);
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    if (nestedCount.getAndIncrement() < MAX_NESTED) {
-                        System.out.println("Executing a nested request: " + nestedCount);
-                        client.prepareGet("http://google.com/").execute(this);
-                    }
-                } finally {
-                    l.countDown();
-                }
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-            }
-        };
-
-
-        client.prepareGet("http://www.google.com/").execute(handler);
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncDoGetStreamAndBodyTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet("http://www.google.com/").execute().get();
-
-        r.getResponseBody();
-        r.getResponseBodyAsStream();
-
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncUrlWithoutPathTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet("http://www.google.com").execute().get();
-
-        r.getResponseBody();
-        r.getResponseBodyAsStream();
-
-        client.close();
-    }
-
-    @Test(groups = {"default_provider", "async"})
-    public void optionsTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareOptions(getTargetUrl()).execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
-
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testAwsS3() throws Exception {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().build());
-        Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-        if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
-            fail("No response Body");
-        } else {
-            assertEquals(response.getStatusCode(), 403);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testAsyncHttpProviderConfig() throws Exception {
-
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
-        Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-        if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
-            fail("No response Body");
-        } else {
-            assertEquals(response.getStatusCode(), 403);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void idleRequestTimeoutTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(5000).setRequestTimeoutInMs(10000).build());
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-
-        long t1 = System.currentTimeMillis();
-        try {
-            c.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-                /* @Override */
-                public void onThrowable(Throwable t) {
-//                    t.printStackTrace();
-                }
-
-            }).get();
-            Assert.fail();
-        } catch (Throwable ex) {
-            final long elapsedTime = System.currentTimeMillis() - t1;
-            System.out.println("EXPIRED: " + (elapsedTime));
-            Assert.assertNotNull(ex.getCause());
-            Assert.assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostCancelTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
-
-        final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
-        ex.set(null);
-        try {
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    if (t instanceof CancellationException) {
-                        ex.set((CancellationException)t);
-                    }
-                    t.printStackTrace();
-                }
-                
-            });
-
-            future.cancel(true);
-        } catch (IllegalStateException ise) {
-            fail();
-        }
-        Assert.assertNotNull(ex.get());
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void getShouldAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
-        builder.setBody("Boo!");
-        builder.execute();
-    }
-
-    @Test(groups = {"standalone", "default_provider"}, expectedExceptions = IllegalArgumentException.class)
-    public void headShouldNotAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareHead(getTargetUrl());
-        builder.setBody("Boo!");
-        builder.execute();
-    }
-
-    protected String getBrokenTargetUrl() {
-        return String.format("http:127.0.0.1:%d/foo/test", port1);
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void invalidUri() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getBrokenTargetUrl());
-        Response r = c.executeRequest(builder.build()).get();
-        assertEquals(200, r.getStatusCode());
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncHttpClientConfigBeanTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
-        Response r = c.executeRequest(builder.build()).get();
-        assertEquals(200, r.getStatusCode());
-    }
-
-    @Test(groups = {"default_provider", "async"})
-    public void bodyAsByteTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet(getTargetUrl()).execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getResponseBodyAsBytes(), new byte[]{});
-
-        client.close();
-    }
-
-    @Test(groups = {"default_provider", "async"})
-    public void mirrorByteTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Response r = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(new String(r.getResponseBodyAsBytes(), "UTF-8"), "MIRROR");
-
-        client.close();
-    }
-
-    protected abstract AsyncHttpProviderConfig getProviderConfig();
-}
diff --git a/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java b/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
deleted file mode 100644
index 512153b28..000000000
--- a/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
+++ /dev/null
@@ -1,557 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public abstract class AsyncStreamHandlerTest extends AbstractBasicTest {
-    private final static String RESPONSE = "param_1_";
-    private final static String UTF8 = "text/html;charset=utf-8";
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamGETTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                try {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                    return STATE.ABORT;
-                } finally {
-                    l.countDown();
-                }
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("", t);
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(5, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamPOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(10, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamInterruptTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-
-        final AtomicBoolean a = new AtomicBoolean(true);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.ABORT;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                a.set(false);
-                Assert.fail("Interrupted not working");
-                return STATE.ABORT;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("", t);
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        l.await(5, TimeUnit.SECONDS);
-        Assert.assertTrue(a.get());
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamFutureTest() throws Throwable {
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Future<String> f = c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString().trim();
-                Assert.assertEquals(r, RESPONSE);
-                return r;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("", t);
-            }
-        });
-
-        try {
-            String r = f.get(5, TimeUnit.SECONDS);
-            Assert.assertNotNull(r);
-            Assert.assertEquals(r.trim(), RESPONSE);
-        } catch (TimeoutException ex) {
-            Assert.fail();
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamThrowableRefusedTest() throws Throwable {
-
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                throw new RuntimeException("FOO");
-            }
-
-            @Override
-
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t.getMessage() != null) {
-                        Assert.assertEquals(t.getMessage(), "FOO");
-                    }
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-
-        if (!l.await(10, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncStreamReusePOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
-                }
-
-            }
-        });
-
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-
-        // Let do the same again
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void asyncStream301WithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), "text/html; charset=utf-8");
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString();
-                Assert.assertTrue(r.contains("301 Moved"));
-                l.countDown();
-                return r;
-            }
-        });
-
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void asyncStream301RedirectWithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getFirstValue( "server" ), "gws");
-                // This assertion below is not an invariant, since implicitly contains locale-dependant settings
-                // and fails when run in country having own localized Google site and it's locale relies on something
-                // other than ISO-8859-1.
-                // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
-                // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
-                // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
-                //
-                // Assert.assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString();
-                Assert.assertTrue(!r.contains("301 Moved"));
-                l.countDown();
-
-                return r;
-            }
-        });
-
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"}, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
-    public void asyncStreamJustStatusLine() throws Throwable {
-        final int STATUS = 0;
-        final int COMPLETED = 1;
-        final int OTHER = 2;
-        final boolean[] whatCalled = new boolean[]{false, false, false};
-        final CountDownLatch latch = new CountDownLatch(1);
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
-            private int status = -1;
-
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-            }
-
-            /* @Override */
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-                return STATE.ABORT;
-            }
-
-            /* @Override */
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                whatCalled[STATUS] = true;
-                System.out.println(responseStatus);
-                status = responseStatus.getStatusCode();
-                latch.countDown();
-                return STATE.ABORT;
-            }
-
-            /* @Override */
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-                return STATE.ABORT;
-            }
-
-            /* @Override */
-            public Integer onCompleted() throws Exception {
-                whatCalled[COMPLETED] = true;
-                latch.countDown();
-                return status;
-            }
-        });
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout");
-            return;
-        }
-        Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-        Assert.assertEquals((int) status, 200, "Expected status code failed.");
-
-        if (!whatCalled[STATUS]) {
-            Assert.fail("onStatusReceived not called.");
-        }
-        if (!whatCalled[COMPLETED]) {
-            Assert.fail("onCompleted not called.");
-        }
-        if (whatCalled[OTHER]) {
-            Assert.fail("Other method of AsyncHandler got called.");
-        }
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void asyncOptionsTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final String[] expected = {
-            "GET","HEAD","OPTIONS","POST","TRACE"
-        };
-        c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                String[] values = h.get("Allow").get(0).split(",|, ");
-                Assert.assertNotNull(values);
-                Assert.assertEquals(values.length, expected.length);
-                Arrays.sort(values);
-                Assert.assertEquals(values, expected);
-                return STATE.ABORT;
-            }
-
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    return "OK";
-                } finally {
-                    l.countDown();
-                }
-            }
-        });
-
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void closeConnectionTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
-
-            private Response.ResponseBuilder builder = new Response.ResponseBuilder();
-
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                builder.accumulate(content);
-                return STATE.CONTINUE;
-            }
-
-            public void onThrowable(Throwable t) {
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.accumulate(content);
-
-                if (content.isLast()) {
-                    content.markUnderlyingConnectionAsClosed();
-                }
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                builder.accumulate(responseStatus);
-
-                return STATE.CONTINUE;
-            }
-
-            public Response onCompleted() throws Exception {
-                return builder.build();
-            }
-        }).get();
-
-        Assert.assertNotNull(r);
-        Assert.assertEquals(r.getStatusCode(), 200);
-        c.close();
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/async/ComplexClientTest.java b/api/src/test/java/com/ning/http/client/async/ComplexClientTest.java
deleted file mode 100644
index 6b7a30ffa..000000000
--- a/api/src/test/java/com/ning/http/client/async/ComplexClientTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
-import org.testng.annotations.Test;
-
-import java.util.concurrent.TimeUnit;
-
-import static org.testng.Assert.assertEquals;
-
-public abstract class ComplexClientTest extends AbstractBasicTest {
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void multipleRequestsTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-
-        // twice
-        response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void urlWithoutSlashTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1))
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-        c.close();
-    }
-
-}
diff --git a/api/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java b/api/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java
deleted file mode 100644
index 27a591787..000000000
--- a/api/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
-public abstract class ConnectionPoolTest extends AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMaxTotalConnections() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 3; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-                Response response = client.prepareGet(url).execute().get();
-                log.info("{} response [{}].", i, response);
-            } catch (Exception ex) {
-                exception = ex;
-            }
-        }
-        assertNull(exception);
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 20; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-
-                if (i < 5) {
-                    client.prepareGet(url).execute().get();
-                } else {
-                    client.prepareGet(url).execute();
-                }
-            } catch (Exception ex) {
-                exception = ex;
-                break;
-            }
-        }
-        assertNotNull(exception);
-        assertNotNull(exception.getMessage());
-        assertEquals(exception.getMessage(),"Too many connections 1");
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = true, invocationCount = 10, alwaysRun = true)
-    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
-
-        final Map<String, Boolean> remoteAddresses = new
-                ConcurrentHashMap<String, Boolean>();
-
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-                        System.out.println("ON COMPLETED INVOKED " +
-                                response.getHeader("X-KEEP-ALIVE"));
-                        try {
-                            assertEquals(response.getStatusCode(), 200);
-                            remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
-                        } finally {
-                            l.countDown();
-                        }
-                        return response;
-                    }
-                };
-
-        client.prepareGet(getTargetUrl()).execute(handler).get();
-        server.stop();
-        server.start();
-        client.prepareGet(getTargetUrl()).execute(handler);
-
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
-        }
-
-        assertEquals(remoteAddresses.size(), 2);
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public abstract void testInvalidConnectionsPool();
-
-    @Test(groups = {"standalone", "default_provider"})
-    public abstract void testValidConnectionsPool();
-
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-
-        // twice
-        Exception exception = null;
-        try {
-            c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            fail("Should throw exception. Too many connections issued.");
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
-        }
-        assertNotNull(exception);
-        assertEquals(exception.getMessage(), "Too many connections 1");
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void multipleMaxConnectionOpenTestWithQuery() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl() + "?foo=bar")
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), "foo_" + body);
-
-        // twice
-        Exception exception = null;
-        try {
-            response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
-        }
-        assertNull(exception);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
-    }
-
-    /**
-     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception.
-     * The onComplete method must be only called once.
-     *
-     * @throws Throwable if something wrong happens.
-     */
-    @Test(groups = {"standalone", "default_provider"})
-    public void win7DisconnectTest() throws Throwable {
-        final AtomicInteger count = new AtomicInteger(0);
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-
-                        count.incrementAndGet();
-                        StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-                        IOException t = new IOException();
-                        t.setStackTrace(new StackTraceElement[]{e});
-                        throw t;
-                    }
-                };
-
-        try {
-            client.prepareGet(getTargetUrl()).execute(handler).get();
-            fail("Must have received an exception");
-        } catch (ExecutionException ex) {
-            assertNotNull(ex);
-            assertNotNull(ex.getCause());
-            assertEquals(ex.getCause().getCause().getClass(), IOException.class);
-            assertEquals(count.get(), 1);
-        }
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void asyncHandlerOnThrowableTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final AtomicInteger count = new AtomicInteger();
-        final String THIS_IS_NOT_FOR_YOU = "This is not for you";
-        final CountDownLatch latch = new CountDownLatch(16);
-        for (int i = 0; i < 16; i++) {
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    throw new Exception(THIS_IS_NOT_FOR_YOU);
-                }
-            });
-
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                /* @Override */
-                public void onThrowable(Throwable t) {
-                    if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
-                        count.incrementAndGet();
-                    }
-                }
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    latch.countDown();
-                    return response;
-                }
-            });
-        }
-        latch.await(TIMEOUT, TimeUnit.SECONDS);
-        assertEquals(count.get(), 0);
-        client.close();
-    }
-
-}
-
diff --git a/api/src/test/java/com/ning/http/client/async/EmptyBodyTest.java b/api/src/test/java/com/ning/http/client/async/EmptyBodyTest.java
deleted file mode 100644
index 873e1bba8..000000000
--- a/api/src/test/java/com/ning/http/client/async/EmptyBodyTest.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.assertNotNull;
-
-import static org.testng.Assert.fail;
-
-/**
- * Tests case where response doesn't have body.
- *
- * @author Hubert Iwaniuk
- */
-public abstract class EmptyBodyTest extends AbstractBasicTest {
-    private class NoBodyResponseHandler extends AbstractHandler {
-        public void handle(
-                String s,
-                Request request,
-                HttpServletRequest req,
-                HttpServletResponse resp)
-                throws IOException, ServletException {
-
-            if (!req.getMethod().equalsIgnoreCase("PUT")) {
-                resp.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                resp.setStatus(204);                
-            }
-            request.setHandled(true);
-        }
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new NoBodyResponseHandler();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testEmptyBody() throws IOException {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final AtomicBoolean err = new AtomicBoolean(false);
-        final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
-        final AtomicBoolean status = new AtomicBoolean(false);
-        final AtomicInteger headers = new AtomicInteger(0);
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-            public void onThrowable(Throwable t) {
-                fail("Got throwable.", t);
-                err.set(true);
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                String s = new String(e.getBodyPartBytes());
-                log.info("got part: {}", s);
-                if (s.equals("")) {
-                    //noinspection ThrowableInstanceNeverThrown
-                    log.warn("Sampling stacktrace.",
-                            new Throwable("trace that, we should not get called for empty body."));
-                }
-                queue.put(s);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
-                status.set(true);
-                return AsyncHandler.STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
-                if (headers.incrementAndGet() == 2) {
-                    throw new Exception("Analyze this.");
-                }
-                return STATE.CONTINUE;
-            }
-
-            public Object onCompleted() throws Exception {
-                latch.countDown();
-                return null;
-            }
-        });
-        try {
-            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
-        }
-        assertFalse(err.get());
-        assertEquals(queue.size(), 0);
-        assertTrue(status.get());
-        assertEquals(headers.get(), 1);
-        ahc.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testPutEmptyBody() throws Throwable {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 204);
-        assertEquals(response.getResponseBody(), "");
-        assertTrue(InputStream.class.isAssignableFrom(response.getResponseBodyAsStream().getClass()));
-        assertEquals(response.getResponseBodyAsStream().read(), -1); 
-
-        ahc.close();
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/async/FollowingThreadTest.java b/api/src/test/java/com/ning/http/client/async/FollowingThreadTest.java
deleted file mode 100644
index b8de801eb..000000000
--- a/api/src/test/java/com/ning/http/client/async/FollowingThreadTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeoutException;
-
-
-/**
- * Simple stress test for exercising the follow redirect.
- */
-public abstract class FollowingThreadTest extends AbstractBasicTest {
-
-    private final static int COUNT = 10;
-
-    @Test(timeOut = 30 * 1000, groups = {"online", "default_provider", "scalability"})
-    public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-
-        final CountDownLatch countDown = new CountDownLatch(COUNT);
-        ExecutorService pool = Executors.newCachedThreadPool();
-        for (int i = 0; i < COUNT; i++) {
-            pool.submit(new Runnable() {
-
-                private int status;
-
-                public void run() {
-                    final CountDownLatch l = new CountDownLatch(1);
-                    final AsyncHttpClient ahc = getAsyncHttpClient(
-                            new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-                    try {
-                        ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
-
-                            public void onThrowable(Throwable t) {
-                                t.printStackTrace();
-                            }
-
-                            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                                System.out.println(new String(bodyPart.getBodyPartBytes()));
-                                return STATE.CONTINUE;
-                            }
-
-                            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                                status = responseStatus.getStatusCode();
-                                System.out.println(responseStatus.getStatusText());
-                                return STATE.CONTINUE;
-                            }
-
-                            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                                return STATE.CONTINUE;
-                            }
-
-                            public Integer onCompleted() throws Exception {
-                                l.countDown();
-                                return status;
-                            }
-                        });
-
-                        l.await();
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    } finally {
-                        ahc.close();
-                        countDown.countDown();
-                    }
-                }
-            });
-        }
-        countDown.await();
-    }
-
-}
\ No newline at end of file
diff --git a/api/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java b/api/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java
deleted file mode 100644
index abf99aaf9..000000000
--- a/api/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License. You may obtain a copy of the License at:
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-public abstract class MaxTotalConnectionTest extends AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMaxTotalConnectionsExceedingException() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://github.com/"};
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
-
-        boolean caughtError = false;
-        for (int i = 0; i < urls.length; i++) {
-            try {
-                client.prepareGet(urls[i]).execute();
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                Assert.assertEquals(1, i);
-                caughtError = true;
-            }
-        }
-        Assert.assertTrue(caughtError);
-        client.close();
-    }
-
-    @Test
-    public void testMaxTotalConnections() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://lenta.ru"};
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(2)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
-
-        for (String url : urls) {
-            try {
-                client.prepareGet(url).execute();
-            } catch (IOException e) {
-                Assert.fail("Smth wrong with connections handling!");
-            }
-        }
-        client.close();
-    }
-
-
-    /**
-     * JFA: Disable this test for 1.2.0 release as it can easily fail because a request may complete
-     * before the second one is made, hence failing. The issue occurs frequently on Linux.
-     */
-    @Test(enabled = false)
-    public void testMaxTotalConnectionsCorrectExceptionHandling() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://github.com/"};
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
-
-        List<Future<Response>> futures = new ArrayList<Future<Response>>();
-        boolean caughtError = false;
-        for (int i = 0; i < urls.length; i++) {
-            try {
-                Future<Response> future = client.prepareGet(urls[i]).execute();
-                if (future != null) {
-                    futures.add(future);
-                }
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                Assert.assertEquals(i, 1);
-                caughtError = true;
-            }
-        }
-        Assert.assertTrue(caughtError);
-
-        // get results of executed requests
-        for (Future<Response> future : futures) {
-            try {
-                /*Response res =*/ future.get();
-            } catch (InterruptedException e) {
-                log.error("Error!", e);
-            } catch (ExecutionException e) {
-                log.error("Error!", e);
-            }
-        }
-
-        // try to execute once again, expecting that 1 connection is released
-        caughtError = false;
-        for (int i = 0; i < urls.length; i++) {
-            try {
-                client.prepareGet(urls[i]).execute();
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                Assert.assertEquals(i, 1);
-                caughtError = true;
-            }
-        }
-        Assert.assertTrue(caughtError);
-        client.close();
-    }
-}
-
-
diff --git a/api/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java b/api/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
deleted file mode 100644
index 6bf0b416b..000000000
--- a/api/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * @author Hubert Iwaniuk
- */
-public abstract class MultipleHeaderTest extends AbstractBasicTest{
-    private ExecutorService executorService;
-    private ServerSocket serverSocket;
-    private Future<?> voidFuture;
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMultipleOtherHeaders()
-            throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] xffHeaders = new String[]{null, null};
-
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(req, new AsyncHandler<Void>() {
-            public void onThrowable(Throwable t) {
-                t.printStackTrace(System.out);
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
-                int i = 0;
-                for (String header : response.getHeaders().get("X-Forwarded-For")) {
-                    xffHeaders[i++] = header;
-                }
-                latch.countDown();
-                return STATE.CONTINUE;
-            }
-
-            public Void onCompleted() throws Exception {
-                return null;
-            }
-        }).get(3, TimeUnit.SECONDS);
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Time out");
-        }
-        Assert.assertNotNull(xffHeaders[0]);
-        Assert.assertNotNull(xffHeaders[1]);
-        try {
-            Assert.assertEquals(xffHeaders[0], "abc");
-            Assert.assertEquals(xffHeaders[1], "def");
-        } catch (AssertionError ex) {
-            Assert.assertEquals(xffHeaders[1], "abc");
-            Assert.assertEquals(xffHeaders[0], "def");
-        }
-        ahc.close();
-    }
-
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMultipleEntityHeaders()
-            throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] clHeaders = new String[]{null, null};
-
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(req, new AsyncHandler<Void>() {
-            public void onThrowable(Throwable t) {
-                t.printStackTrace(System.out);
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
-                try {
-                    int i = 0;
-                    for (String header : response.getHeaders().get("Content-Length")) {
-                        clHeaders[i++] = header;
-                    }
-                } finally {
-                    latch.countDown();
-                }
-                return STATE.CONTINUE;
-            }
-
-            public Void onCompleted() throws Exception {
-                return null;
-            }
-        }).get(3, TimeUnit.SECONDS);
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Time out");
-        }
-        Assert.assertNotNull(clHeaders[0]);
-        Assert.assertNotNull(clHeaders[1]);
-
-        // We can predict the order
-        try {
-            Assert.assertEquals(clHeaders[0], "2");
-            Assert.assertEquals(clHeaders[1], "1");
-        } catch (Throwable ex) {
-            Assert.assertEquals(clHeaders[0], "1");
-            Assert.assertEquals(clHeaders[1], "2");
-        }
-        ahc.close();
-
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setUpGlobal() throws Exception {
-        port1 = findFreePort();
-
-        serverSocket = new ServerSocket(port1);
-        executorService = Executors.newFixedThreadPool(1);
-        voidFuture = executorService.submit(new Callable<Void>() {
-            public Void call() throws Exception {
-                Socket socket;
-                while ((socket = serverSocket.accept()) != null) {
-                    InputStream inputStream = socket.getInputStream();
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-                    String req = reader.readLine().split(" ")[1];
-                    int i = inputStream.available();
-                    long l = inputStream.skip(i);
-                    Assert.assertEquals(l, i);
-                    socket.shutdownInput();
-                    if (req.endsWith("MultiEnt")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" +
-                                "Connection: close\n" +
-                                "Content-Type: text/plain; charset=iso-8859-1\n" +
-                                "Content-Length: 2\n" +
-                                "Content-Length: 1\n" +
-                                "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    } else if (req.endsWith("MultiOther")) {
-                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" +
-                                "Connection: close\n" +
-                                "Content-Type: text/plain; charset=iso-8859-1\n" +
-                                "Content-Length: 1\n" +
-                                "X-Forwarded-For: abc\n" +
-                                "X-Forwarded-For: def\n" +
-                                "\n0\n");
-                        outputStreamWriter.flush();
-                        socket.shutdownOutput();
-                    }
-                }
-                return null;
-            }
-        });
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void tearDownGlobal() throws Exception {
-        voidFuture.cancel(true);
-        executorService.shutdownNow();
-        serverSocket.close();
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java b/api/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java
deleted file mode 100644
index 80acc7942..000000000
--- a/api/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.eclipse.jetty.server.nio.SelectChannelConnector;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-import static org.testng.Assert.assertEquals;
-
-public abstract class NonAsciiContentLengthTest extends AbstractBasicTest {
-
-
-	public void setUpServer() throws Exception {
-		server = new Server();
-		port1 = findFreePort();
-		Connector listener = new SelectChannelConnector();
-
-		listener.setHost("127.0.0.1");
-		listener.setPort(port1);
-		server.addConnector(listener);
-		server.setHandler(new AbstractHandler() {
-
-			public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)
-			    throws IOException, ServletException {
-				int MAX_BODY_SIZE = 1024; //Can only handle bodies of up to 1024 bytes.
-				byte[] b = new byte[MAX_BODY_SIZE];
-				int offset = 0;
-				int numBytesRead;
-				ServletInputStream is = request.getInputStream();
-				try {
-					while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
-						offset += numBytesRead;
-					}
-				} finally {
-					is.close();
-				}
-				assertEquals(request.getContentLength(), offset);
-				response.setStatus(200);
-				response.setCharacterEncoding(request.getCharacterEncoding());
-				response.setContentLength(request.getContentLength());
-				ServletOutputStream os = response.getOutputStream();
-				try {
-					os.write(b, 0, offset);
-				} finally {
-					os.close();
-				}
-			}
-		});
-		server.start();
-	}
-
-	@Test(groups = { "standalone", "default_provider" })
-	public void testNonAsciiContentLength() throws Exception {
-		setUpServer();
-		execute("test");
-		execute("\u4E00"); // Unicode CJK ideograph for one
-	}
-
-	protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
-		AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-		BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding("UTF-8");
-		Future<Response> f = r.execute();
-		Response resp = f.get();
-		assertEquals(resp.getStatusCode(), 200);
-		assertEquals(body, resp.getResponseBody("UTF-8"));
-		client.close();
-	}
-
-}
diff --git a/api/src/test/java/com/ning/http/client/async/PostWithQSTest.java b/api/src/test/java/com/ning/http/client/async/PostWithQSTest.java
deleted file mode 100644
index d99498bd1..000000000
--- a/api/src/test/java/com/ning/http/client/async/PostWithQSTest.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
-/**
- * Tests POST request with Query String.
- *
- * @author Hubert Iwaniuk
- */
-public abstract class PostWithQSTest extends AbstractBasicTest {
-
-    /**
-     * POST with QS server part.
-     */
-    private class PostWithQSHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
-            if ("POST".equalsIgnoreCase(request.getMethod())) {
-                String qs = request.getQueryString();
-                if (qs != null && !qs.equals("") && request.getContentLength() == 3) {
-                    ServletInputStream is = request.getInputStream();
-                    response.setStatus(HttpServletResponse.SC_OK);
-                    byte buf[] = new byte[is.available()];
-                    is.readLine(buf, 0, is.available());
-                    ServletOutputStream os = response.getOutputStream();
-                    os.println(new String(buf));
-                    os.flush();
-                    os.close();
-                } else {
-                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
-                }
-            } else { // this handler is to handle POST request
-                response.sendError(HttpServletResponse.SC_FORBIDDEN);
-            }
-        }
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-            /* @Override */
-            public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a")) {
-                    throw new IOException(status.getUrl().toURL().toString());
-                }
-                return super.onStatusReceived(status);
-            }
-
-        });
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
-
-            /* @Override */
-            public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
-                    throw new IOException("failed to parse the query properly");
-                }
-                return super.onStatusReceived(status);
-            }
-
-        });
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new PostWithQSHandler();
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/async/ProviderUtil.java b/api/src/test/java/com/ning/http/client/async/ProviderUtil.java
deleted file mode 100644
index eb3d77cf1..000000000
--- a/api/src/test/java/com/ning/http/client/async/ProviderUtil.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License.  You may obtain a copy of the License at:
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.jdk.JDKAsyncHttpProvider;
-
-public class ProviderUtil {
-
-
-    public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
-        if (config == null) {
-            return new AsyncHttpClient();
-        } else {
-            return new AsyncHttpClient(config);
-        }
-    }
-
-    public static AsyncHttpClient jdkProvider(AsyncHttpClientConfig config) {
-        if (config == null) {
-            return new AsyncHttpClient(new JDKAsyncHttpProvider(new AsyncHttpClientConfig.Builder().build()));
-        } else {
-            return new AsyncHttpClient(new JDKAsyncHttpProvider(config));
-        }
-    }
-
-}
diff --git a/api/src/test/java/com/ning/http/client/async/RemoteSiteTest.java b/api/src/test/java/com/ning/http/client/async/RemoteSiteTest.java
deleted file mode 100644
index 25f1c3680..000000000
--- a/api/src/test/java/com/ning/http/client/async/RemoteSiteTest.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.io.InputStream;
-import java.net.URLEncoder;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.AssertJUnit.assertTrue;
-
-/**
- * Unit tests for remote site.
- * <p/>
- * see http://github.com/MSch/ning-async-http-client-bug/tree/master
- *
- * @author Martin Schurrer
- */
-public abstract class RemoteSiteTest extends AbstractBasicTest{
-
-    public static final String URL = "http://google.com?q=";
-    public static final String REQUEST_PARAM = "github github \n" +
-            "github";
-    
-    @Test(groups = {"online", "default_provider"})
-    public void testGoogleCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        // Works
-        Response response = c.prepareGet("http://www.google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testMailGoogleCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://mail.google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        // Works
-        Response response = c.prepareGet("http://microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testWwwMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testUpdateMicrosoftCom() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void testGoogleComWithTimeout() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        // Works
-        Response response = c.prepareGet("http://google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD")
-                .setUrl("http://www.google.com/")
-                .build();
-
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.assertEquals(response.getStatusCode(), 200);
-                l.countDown();
-                return response;
-            }
-        }).get();
-
-        if (!l.await(5, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
-        p.close();
-    }
-
-    @Test(groups = {"online", "default_provider"}, enabled = false)
-    public void invalidStreamTest2() throws Throwable {
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-                .setRequestTimeoutInMs(10000)
-                .setFollowRedirects(true)
-                .setAllowPoolingConnection(false)
-                .setMaximumNumberOfRedirects(6)
-                .build();
-
-        AsyncHttpClient c = getAsyncHttpClient(config);
-        try {
-            Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
-            if (response != null) {
-                System.out.println(response);
-            }
-        } catch (Throwable t) {
-            t.printStackTrace();
-            assertNotNull(t.getCause());
-            assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void asyncFullBodyProperlyRead() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
-
-        InputStream stream = r.getResponseBodyAsStream();
-        int available = stream.available();
-        int[] lengthWrapper = new int[1];
-        /*byte[] bytes =*/ AsyncHttpProviderUtils.readFully(stream, lengthWrapper);
-        int byteToRead = lengthWrapper[0];
-
-        Assert.assertEquals(available, byteToRead);
-        client.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})    
-    public void testUrlRequestParametersEncoding() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
-        log.info(String.format("Executing request [%s] ...", requestUrl2));
-        Response response = client.prepareGet(requestUrl2).execute().get();
-        Assert.assertEquals(response.getStatusCode(), 301);
-    }
-
-    /**
-     * See  https://issues.sonatype.org/browse/AHC-61
-     * @throws Throwable
-     */
-    @Test(groups = {"online", "default_provider"})
-    public void testAHC60() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
-        Assert.assertEquals(response.getStatusCode(), 200);
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void stripQueryStringTest() throws Throwable {
-
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet("http://www.freakonomics.com/?p=55846")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-
-
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void stripQueryStringNegativeTest() throws Throwable {
-
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder()
-                .setRemoveQueryParamsOnRedirect(false).setFollowRedirects(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet("http://www.freakonomics.com/?p=55846")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-
-
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"})
-    public void evilCoookieTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        RequestBuilder builder2 = new RequestBuilder("GET");
-        builder2.setFollowRedirects(true);
-        builder2.setUrl("http://www.google.com/");
-        builder2.addHeader("Content-Type", "text/plain");
-        builder2.addCookie(new com.ning.http.client.Cookie(".google.com", "evilcookie", "test", "/", 10, false));
-        com.ning.http.client.Request request2 = builder2.build();
-        Response response = c.executeRequest(request2).get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
-    }
-
-    @Test(groups = {"online", "default_provider"}, enabled = false)
-    public void testAHC62Com() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        // Works
-        Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
-
-            private Response.ResponseBuilder builder = new Response.ResponseBuilder();
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                System.out.println(bodyPart.getBodyPartBytes().length);
-                builder.accumulate(bodyPart);
-
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                builder.accumulate(responseStatus);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                builder.accumulate(headers);
-                return STATE.CONTINUE;
-            }
-
-            public Response onCompleted() throws Exception {
-                return builder.build();
-            }
-        }).get(10, TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertTrue(response.getResponseBody().length() >= 3870);
-    }
-
-}
-
diff --git a/api/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java b/api/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java
deleted file mode 100644
index 4206f6b96..000000000
--- a/api/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.async;
-
-import static org.testng.Assert.*;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.concurrent.Future;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
-import com.ning.http.client.SimpleAsyncHttpClient;
-import com.ning.http.client.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
-import com.ning.http.client.consumers.OutputStreamBodyConsumer;
-
-/**
- * @author Benjamin Hanzelmann
- *
- */
-public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testAccumulateErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour( ErrorDocumentBehaviour.ACCUMULATE ).build();
-    
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-    
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 404);
-        assertEquals(o.toString(), "");
-        assertTrue(response.getResponseBody().startsWith("<html>"));
-    
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testOmitErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour( ErrorDocumentBehaviour.OMIT ).build();
-    
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-    
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 404);
-        assertEquals(o.toString(), "");
-        assertEquals(response.getResponseBody(), "");
-        client.close();
-    }
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient( AsyncHttpClientConfig config )
-    {
-        // disabled
-        return null;
-    }
-
-    @Override
-    public AbstractHandler configureHandler()
-        throws Exception
-    {
-        return new AbstractHandler() {
-    
-            public void handle( String target, org.eclipse.jetty.server.Request baseRequest,
-                                HttpServletRequest request, HttpServletResponse response )
-                throws IOException, ServletException
-            {
-                response.sendError( 404 );
-                baseRequest.setHandled( true );
-            }
-        };
-    }
-
-}
diff --git a/api/src/test/java/com/ning/http/client/async/TransferListenerTest.java b/api/src/test/java/com/ning/http/client/async/TransferListenerTest.java
deleted file mode 100644
index e2b80690c..000000000
--- a/api/src/test/java/com/ning/http/client/async/TransferListenerTest.java
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.Response;
-import com.ning.http.client.generators.FileBodyGenerator;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.listener.TransferListener;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Enumeration;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
-public abstract class TransferListenerTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
-
-    private class BasicHandler extends AbstractHandler {
-
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes);
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-        }
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new BasicHandler();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void basicGetTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<ByteBuffer> bb = new AtomicReference<ByteBuffer>();
-        final AtomicBoolean completed = new AtomicBoolean(false);
-
-        TransferCompletionHandler tl = new TransferCompletionHandler();
-        tl.addTransferListener(new TransferListener() {
-
-            public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
-                hSent.set(headers);
-            }
-
-            public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
-                hRead.set(headers);
-            }
-
-            public void onBytesReceived(ByteBuffer buffer) {
-                bb.set(buffer);
-            }
-
-            public void onBytesSent(ByteBuffer buffer) {
-            }
-
-            public void onRequestResponseCompleted() {
-                completed.set(true);
-            }
-
-            public void onThrowable(Throwable t) {
-                throwable.set(t);
-            }
-        });
-
-        try {
-            Response response = c.prepareGet(getTargetUrl())
-                    .execute(tl).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertNotNull(bb.get());
-            assertNull(throwable.get());
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void basicPutTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-        final AtomicInteger bbSentLenght = new AtomicInteger(0);
-
-        final AtomicBoolean completed = new AtomicBoolean(false);
-
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-        File largeFile = createTempFile(bytes, (int) repeats);
-
-        TransferCompletionHandler tl = new TransferCompletionHandler();
-        tl.addTransferListener(new TransferListener() {
-
-            public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
-                hSent.set(headers);
-            }
-
-            public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
-                hRead.set(headers);
-            }
-
-            public void onBytesReceived(ByteBuffer buffer) {
-                bbReceivedLenght.addAndGet(buffer.capacity());
-            }
-
-            public void onBytesSent(ByteBuffer buffer) {
-                bbSentLenght.addAndGet(buffer.capacity());
-            }
-
-            public void onRequestResponseCompleted() {
-                completed.set(true);
-            }
-
-            public void onThrowable(Throwable t) {
-                throwable.set(t);
-            }
-        });
-
-        try {
-            Response response = c.preparePut(getTargetUrl()).setBody(largeFile)
-                    .execute(tl).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertEquals(bbReceivedLenght.get(), largeFile.length());
-            assertEquals(bbSentLenght.get(), largeFile.length());
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void basicPutBodyTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
-        final AtomicInteger bbSentLenght = new AtomicInteger(0);
-
-        final AtomicBoolean completed = new AtomicBoolean(false);
-
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-        File largeFile = createTempFile(bytes, (int) repeats);
-
-        TransferCompletionHandler tl = new TransferCompletionHandler();
-        tl.addTransferListener(new TransferListener() {
-
-            public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
-                hSent.set(headers);
-            }
-
-            public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
-                hRead.set(headers);
-            }
-
-            public void onBytesReceived(ByteBuffer buffer) {
-                bbReceivedLenght.addAndGet(buffer.capacity());
-            }
-
-            public void onBytesSent(ByteBuffer buffer) {
-                bbSentLenght.addAndGet(buffer.capacity());
-            }
-
-            public void onRequestResponseCompleted() {
-                completed.set(true);
-            }
-
-            public void onThrowable(Throwable t) {
-                throwable.set(t);
-            }
-        });
-
-        try {
-            Response response = c.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(largeFile))
-                    .execute(tl).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertNotNull(hRead.get());
-            assertNotNull(hSent.get());
-            assertEquals(bbReceivedLenght.get(), largeFile.length());
-            assertEquals(bbSentLenght.get(), largeFile.length());
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        }
-        c.close();
-    }
-
-    public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
-    }
-
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
-        TMP.mkdirs();
-        TMP.deleteOnExit();
-        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
-        write(pattern, repeat, tmpFile);
-
-        return tmpFile;
-    }
-
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
-        file.deleteOnExit();
-        file.getParentFile().mkdirs();
-        FileOutputStream out = null;
-        try {
-            out = new FileOutputStream(file);
-            for (int i = 0; i < repeat; i++) {
-                out.write(pattern);
-            }
-        }
-        finally {
-            if (out != null) {
-                out.close();
-            }
-        }
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java b/api/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java
deleted file mode 100644
index 987e9d6c9..000000000
--- a/api/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-
-/**
- * Zero copy test which use FileChannel.transfer under the hood . The same SSL test is also covered in {@link com.ning.http.client.async.BasicHttpsTest}
- */
-public abstract class ZeroCopyFileTest extends AbstractBasicTest {
-
-    private class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes);
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-        }
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final AtomicBoolean headerSent = new AtomicBoolean(false);
-        final AtomicBoolean operationCompleted = new AtomicBoolean(false);
-
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncCompletionHandler<Response>() {
-
-            public STATE onHeaderWriteCompleted() {
-                headerSent.set(true);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onContentWriteCompleted() {
-                operationCompleted.set(true);
-                return STATE.CONTINUE;
-            }
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        assertTrue(operationCompleted.get());
-        assertTrue(headerSent.get());
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(file).execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
-
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ZeroCopyHandler();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
-            public void onThrowable(Throwable t) {
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                bodyPart.writeTo(stream);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public Response onCompleted() throws Exception {
-                return null;
-            }
-        });
-        Response resp = f.get();
-        stream.close();
-        assertNull(resp);
-        assertEquals(file.length(), tmp.length());
-        client.close();
-
-    }
-
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
-            public void onThrowable(Throwable t) {
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                bodyPart.writeTo(stream);
-
-                if (bodyPart.getBodyPartBytes().length == 0) {
-                    return STATE.ABORT;
-                }
-                          
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
-
-            public Response onCompleted() throws Exception {
-                return null;
-            }
-        });
-        Response resp = f.get();
-        stream.close();
-        assertNull(resp);
-        assertEquals(file.length(), tmp.length());
-        client.close();
-
-    }
-
-}
diff --git a/api/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java b/api/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java
deleted file mode 100644
index 11442de99..000000000
--- a/api/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.websocket;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import org.testng.annotations.Test;
-
-import javax.servlet.http.HttpServletRequest;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
-
-public abstract class ByteMessageTest extends AbstractBasicTest {
-
-    private final class EchoByteWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnBinaryMessage {
-
-        private Connection connection;
-
-        @Override
-        public void onOpen(Connection connection) {
-            this.connection = connection;
-            connection.setMaxBinaryMessageSize(1000);
-        }
-
-        @Override
-        public void onClose(int i, String s) {
-            connection.close();
-        }
-
-        @Override
-        public void onMessage(byte[] bytes, int i, int i1) {
-            try {
-                connection.sendMessage(bytes, i, i1);
-            } catch (IOException e) {
-                try {
-                    connection.sendMessage("FAIL");
-                } catch (IOException e1) {
-                    e1.printStackTrace();
-                }
-            }
-        }
-    }
-
-    @Override
-    public WebSocketHandler getWebSocketHandler() {
-        return new WebSocketHandler() {
-            @Override
-            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
-                return new EchoByteWebSocket();
-            }
-        };
-    }
-
-    @Test
-    public void echoByte() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                    @Override
-                    public void onOpen(WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onMessage(byte[] message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(byte[] fragment, boolean last) {
-                    }
-                }).build()).get();
-
-        websocket.sendMessage("ECHO".getBytes());
-
-        latch.await();
-        assertEquals(text.get(), "ECHO".getBytes());
-    }
-
-    @Test
-    public void echoTwoMessagesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                    @Override
-                    public void onOpen(WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onMessage(byte[] message) {
-                        if (text.get() == null) {
-                            text.set(message);
-                        } else {
-                            byte[] n = new byte[text.get().length + message.length];
-                            System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                            System.arraycopy(message, 0, n, text.get().length, message.length);
-                            text.set(n);
-                        }
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(byte[] fragment, boolean last) {
-                    }
-                }).build()).get();
-
-        websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO".getBytes());
-    }
-
-    @Test
-    public void echoOnOpenMessagesTest() throws Throwable {
-            AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-            final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
-
-            /*WebSocket websocket =*/ c.prepareGet(getTargetUrl())
-                    .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                        @Override
-                        public void onOpen(WebSocket websocket) {
-                            websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
-                        }
-
-                        @Override
-                        public void onClose(WebSocket websocket) {
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onError(Throwable t) {
-                            t.printStackTrace();
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onMessage(byte[] message) {
-                            if (text.get() == null) {
-                                text.set(message);
-                            } else {
-                                byte[] n = new byte[text.get().length + message.length];
-                                System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                                System.arraycopy(message, 0, n, text.get().length, message.length);
-                                text.set(n);
-                            }
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onFragment(byte[] fragment, boolean last) {
-                        }
-                    }).build()).get();
-
-            latch.await();
-            assertEquals(text.get(), "ECHOECHO".getBytes());
-    }
-
-
-    public void echoFragments() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-                final CountDownLatch latch = new CountDownLatch(1);
-                final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
-
-                WebSocket websocket = c.prepareGet(getTargetUrl())
-                        .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                            @Override
-                            public void onOpen(WebSocket websocket) {
-                            }
-
-                            @Override
-                            public void onClose(WebSocket websocket) {
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onError(Throwable t) {
-                                t.printStackTrace();
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onMessage(byte[] message) {
-                                if (text.get() == null) {
-                                    text.set(message);
-                                } else {
-                                    byte[] n = new byte[text.get().length + message.length];
-                                    System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                                    System.arraycopy(message, 0, n, text.get().length, message.length);
-                                    text.set(n);
-                                }
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onFragment(byte[] fragment, boolean last) {
-                            }
-                        }).build()).get();
-                websocket.stream("ECHO".getBytes(), false);
-                websocket.stream("ECHO".getBytes(), true);
-                latch.await();
-                assertEquals(text.get(), "ECHOECHO".getBytes());
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java b/api/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java
deleted file mode 100644
index 4fc1a19f0..000000000
--- a/api/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.websocket;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import org.testng.annotations.Test;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
-public abstract class CloseCodeReasonMessageTest extends TextMessageTest {
-
-    @Test(timeOut = 60000)
-    public void onCloseWithCode() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
-
-        websocket.close();
-
-        latch.await();
-        assertTrue(text.get().startsWith("1000"));
-    }
-
-    @Test(timeOut = 60000)
-    public void onCloseWithCodeServerClose() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
-
-        latch.await();
-        final String[] parts = text.get().split(" ");
-        assertEquals(parts.length, 5);
-        assertEquals(parts[0], "1000-Idle");
-        assertEquals(parts[1], "for");
-        assertTrue(Integer.parseInt(parts[2].substring(0, parts[2].indexOf('m'))) > 10000);
-        assertEquals(parts[3], ">");
-        assertEquals(parts[4], "10000ms");
-    }
-
-    public final static class Listener implements WebSocketListener, WebSocketCloseCodeReasonListener {
-
-        final CountDownLatch latch;
-        final AtomicReference<String> text;
-
-        public Listener(CountDownLatch latch, AtomicReference<String> text) {
-            this.latch = latch;
-            this.text = text;
-        }
-
-        //@Override
-        public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-        }
-
-        //@Override
-        public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-        }
-
-        public void onClose(WebSocket websocket, int code, String reason) {
-            text.set(code + "-" + reason);
-            latch.countDown();
-        }
-
-        //@Override
-        public void onError(Throwable t) {
-            t.printStackTrace();
-            latch.countDown();
-        }
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/websocket/TextMessageTest.java b/api/src/test/java/com/ning/http/client/websocket/TextMessageTest.java
deleted file mode 100644
index 3130674fd..000000000
--- a/api/src/test/java/com/ning/http/client/websocket/TextMessageTest.java
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.websocket;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import org.testng.annotations.Test;
-
-import javax.servlet.http.HttpServletRequest;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
-public abstract class TextMessageTest extends AbstractBasicTest {
-
-    public static final class EchoTextWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnTextMessage {
-
-        private Connection connection;
-
-        @Override
-        public void onOpen(Connection connection) {
-            this.connection = connection;
-            connection.setMaxTextMessageSize(1000);
-        }
-
-        @Override
-        public void onClose(int i, String s) {
-            connection.close();
-        }
-
-        @Override
-        public void onMessage(String s) {
-            try {
-                connection.sendMessage(s);
-            } catch (IOException e) {
-                try {
-                    connection.sendMessage("FAIL");
-                } catch (IOException e1) {
-                    e1.printStackTrace();
-                }
-            }
-        }
-    }
-
-    @Override
-    public WebSocketHandler getWebSocketHandler() {
-        return new WebSocketHandler() {
-            @Override
-            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
-                return new EchoTextWebSocket();
-            }
-        };
-    }
-
-
-
-    @Test(timeOut = 60000)
-    public void onOpen() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        /*WebSocket websocket =*/ c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnOpen");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-
-        latch.await();
-        assertEquals(text.get(), "OnOpen");
-    }
-
-    @Test(timeOut = 60000)
-    public void onEmptyListenerTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        WebSocket websocket = null;
-        try {
-            websocket = c.prepareGet(getTargetUrl())
-                    .execute(new WebSocketUpgradeHandler.Builder().build()).get();
-        } catch (Throwable t) {
-            fail();
-        }
-        assertTrue(websocket != null);
-    }
-
-    @Test(timeOut = 60000)
-    public void onFailureTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-//        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        Throwable t = null;
-        try {
-            /* WebSocket websocket =*/ c.prepareGet("ws://abcdefg")
-                    .execute(new WebSocketUpgradeHandler.Builder().build()).get();
-        } catch (Throwable t2) {
-            t = t2;
-        }
-        assertTrue(t != null);
-    }
-
-    @Test(timeOut = 60000)
-    public void onTimeoutCloseTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        /*WebSocket websocket =*/ c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnClose");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        latch.await();
-        assertEquals(text.get(), "OnClose");
-    }
-
-    @Test(timeOut = 60000)
-    public void onClose() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnClose");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.close();
-
-        latch.await();
-        assertEquals(text.get(), "OnClose");
-    }
-
-    @Test(timeOut = 60000)
-    public void echoText() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.sendTextMessage("ECHO");
-
-        latch.await();
-        assertEquals(text.get(), "ECHO");
-    }
-
-    @Test(timeOut = 60000)
-    public void echoDoubleListenerText() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(text.get() + message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.sendTextMessage("ECHO");
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
-    }
-
-    @Test
-    public void echoTwoMessagesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        /*WebSocket websocket =*/ c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(text.get() + message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        websocket.sendTextMessage("ECHO").sendTextMessage("ECHO");
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
-    }
-
-
-    public void echoFragments() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.streamText("ECHO", false);
-        websocket.streamText("ECHO", true);
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
-    }
-
-}
diff --git a/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java b/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java
deleted file mode 100644
index e2bab0876..000000000
--- a/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.util;
-
-import com.ning.http.client.Cookie;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-public class TestAsyncHttpProviderUtils
-{
-    @Test(groups="fast")
-    public void testCookieParsing()
-    {
-        String cookieValue = "ID=a3be7f468f2a528c:FF=0:TM=1397369269:LM=134759269:S=XZQK3o8HJ1mytzgz";
-        String testCookie = "PREF=" + cookieValue + "; expires=Thu, 11-Sep-2013 13:14:29 GMT; path=/; domain=.google.co.uk";
-        Cookie cookie = AsyncHttpProviderUtils.parseCookie(testCookie);
-        
-        Assert.assertEquals(cookie.getValue(), cookieValue);
-    }
-}
diff --git a/api/src/test/java/com/ning/http/client/RealmTest.java b/api/src/test/java/org/asynchttpclient/RealmTest.java
similarity index 96%
rename from api/src/test/java/com/ning/http/client/RealmTest.java
rename to api/src/test/java/org/asynchttpclient/RealmTest.java
index 71ba2d44e..1cef822c2 100644
--- a/api/src/test/java/com/ning/http/client/RealmTest.java
+++ b/api/src/test/java/org/asynchttpclient/RealmTest.java
@@ -10,10 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client;
+package org.asynchttpclient;
 
-import com.ning.http.client.Realm.AuthScheme;
-import com.ning.http.client.Realm.RealmBuilder;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Realm.RealmBuilder;
 import org.testng.Assert;
 import java.math.BigInteger;
 import java.security.MessageDigest;
diff --git a/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
similarity index 95%
rename from api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java
rename to api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
index 9fc2c0509..3e6c368f7 100644
--- a/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
@@ -13,16 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
new file mode 100755
index 000000000..e1c3c9187
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
@@ -0,0 +1,1729 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.ConnectException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.channels.UnresolvedAddressException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.AsyncHttpClientConfigBean;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.Part;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.StringPart;
+
+public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
+    private static final String UTF_8 = "text/html;charset=UTF-8";
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncProviderEncodingTest() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html?q=+%20x").build();
+            String requestUrl = request.getUrl();
+            Assert.assertEquals(requestUrl, "http://foo.com/foo.html?q=%20%20x");
+            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
+
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/foo.html?q=%20%20x");
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncProviderEncodingTest2() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html").addQueryParameter("q", "a b").build();
+
+            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
+
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/foo.html?q=a%20b");
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void emptyRequestURI() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com").build();
+
+            Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
+
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/");
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncProviderContentLenghtGETTest() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            URL url = new URL(getTargetUrl());
+            final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.connect();
+
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        int contentLenght = -1;
+                        if (response.getHeader("content-length") != null) {
+                            contentLenght = Integer.valueOf(response.getHeader("content-length"));
+                        }
+                        int ct = connection.getContentLength();
+                        assertEquals(contentLenght, ct);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("Unexpected exception", t);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncContentTypeGETTest() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getContentType(), UTF_8);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncHeaderGETTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getContentType(), UTF_8);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncHeaderPOSTTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
+
+            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        System.out.println(">>>>> " + response.getStatusText());
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncParamPOSTTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            for (int i = 0; i < 5; i++) {
+                m.put("param_" + i, Arrays.asList("value_" + i));
+            }
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).build();
+            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                        }
+
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncStatusHEADTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
+            Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            try {
+                String s = response.getResponseBody();
+                Assert.assertEquals("", s);
+            } catch (IllegalStateException ex) {
+                fail();
+            }
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    // TODO: fix test
+    @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
+    public void asyncStatusHEADContentLenghtTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(120 * 1000).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
+
+            n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.fail();
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        assertEquals(t.getClass(), IOException.class);
+                        assertEquals(t.getMessage(), "No response received. Connection timed out");
+                    } finally {
+                        l.countDown();
+                    }
+
+                }
+            }).get();
+
+            if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncNullSchemeTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+
+        try {
+            c.prepareGet("www.sun.com").execute();
+            Assert.fail();
+        } catch (IllegalArgumentException ex) {
+            Assert.assertTrue(true);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetTransferEncodingTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("Transfer-Encoding"), "chunked");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetHeadersTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+            c.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetCookieTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+
+            final Cookie coo = new Cookie("/", "foo", "value", "/", -1, false);
+            c.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        List<Cookie> cookies = response.getCookies();
+                        assertEquals(cookies.size(), 1);
+                        assertEquals(cookies.get(0).toString(), coo.toString());
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostDefaultContentType() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            c.preparePost(getTargetUrl()).addParameter("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        FluentCaseInsensitiveStringsMap h = response.getHeaders();
+                        assertEquals(h.getJoinedValue("X-Content-Type", ", "), "application/x-www-form-urlencoded");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostBodyIsoTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response r = c.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
+            assertEquals(r.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostBytesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostInputStreamTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPutInputStreamTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
+
+            c.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostEntityWriterTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+
+            final StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+            byte[] bytes = sb.toString().getBytes();
+            h.add("Content-Length", String.valueOf(bytes.length));
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(new Request.EntityWriter() {
+
+                /* @Override */
+                public void writeEntity(OutputStream out) throws IOException {
+                    out.write(sb.toString().getBytes("UTF-8"));
+                }
+            }).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostMultiPartTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            Part p = new StringPart("foo", "bar");
+
+            c.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        String xContentType = response.getHeader("X-Content-Type");
+                        String boundary = xContentType.substring((xContentType.indexOf("boundary") + "boundary".length() + 1));
+
+                        String s = response.getResponseBodyExcerpt(boundary.length() + "--".length()).substring("--".length());
+                        assertEquals(boundary, s);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostBasicGZIPTest() throws Throwable {
+        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build();
+        AsyncHttpClient c = getAsyncHttpClient(cf);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Accept-Encoding"), "gzip");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostProxyTest() throws Throwable {
+        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build();
+        AsyncHttpClient c = getAsyncHttpClient(cf);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            Response response = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                }
+            }).get();
+
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncRequestVirtualServerPOSTTest() throws Throwable {
+        AsyncHttpClient n = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            for (int i = 0; i < 5; i++) {
+                m.put("param_" + i, Arrays.asList("value_" + i));
+            }
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).setVirtualHost("localhost:" + port1).build();
+
+            Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
+
+            assertEquals(response.getStatusCode(), 200);
+            if (response.getHeader("X-Host").startsWith("localhost")) {
+                assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
+            } else {
+                assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
+            }
+        } finally {
+            n.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPutTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            Response response = c.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
+
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostLatchBytesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                        return response;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostDelayCancelTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
+
+            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public void onThrowable(Throwable t) {
+                }
+            });
+            future.cancel(true);
+            Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
+            Assert.assertNull(response);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostDelayBytesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
+
+            try {
+                Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        t.printStackTrace();
+                    }
+                });
+
+                future.get(10, TimeUnit.SECONDS);
+            } catch (ExecutionException ex) {
+                if (ex.getCause() != null && TimeoutException.class.isAssignableFrom(ex.getCause().getClass())) {
+                    Assert.assertTrue(true);
+                }
+            } catch (TimeoutException te) {
+                Assert.assertTrue(true);
+            } catch (IllegalStateException ex) {
+                Assert.assertTrue(false);
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostNullBytesTest() throws Throwable {
+
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
+
+            Response response = future.get();
+            Assert.assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostListenerBytesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.setLength(sb.length() - 1);
+
+            final CountDownLatch l = new CountDownLatch(1);
+
+            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Latch time out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidFuture() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            int dummyPort = findFreePort();
+            final AtomicInteger count = new AtomicInteger();
+            for (int i = 0; i < 20; i++) {
+                try {
+                    Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                        /* @Override */
+                        public void onThrowable(Throwable t) {
+                            count.incrementAndGet();
+                        }
+                    }).get();
+                    assertNull(response, "Should have thrown ExecutionException");
+                } catch (ExecutionException ex) {
+                    Throwable cause = ex.getCause();
+                    if (!(cause instanceof ConnectException)) {
+                        fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
+                    }
+                }
+            }
+            assertEquals(count.get(), 20);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidPortFuture() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            int dummyPort = findFreePort();
+            try {
+                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        t.printStackTrace();
+                    }
+                }).get();
+                assertNull(response, "Should have thrown ExecutionException");
+            } catch (ExecutionException ex) {
+                Throwable cause = ex.getCause();
+                if (!(cause instanceof ConnectException)) {
+                    fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
+                }
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidPort() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            // pick a random unused local port
+            int port = findFreePort();
+
+            try {
+                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        t.printStackTrace();
+                    }
+                }).get();
+                assertNull(response, "No ExecutionException was thrown");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidHandlerPort() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            int port = findFreePort();
+
+            c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    try {
+                        assertEquals(t.getClass(), ConnectException.class);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncConnectInvalidHandlerHost() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            c.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    if (t != null) {
+                        if (t.getClass().equals(ConnectException.class)) {
+                            l.countDown();
+                        } else if (t.getClass().equals(UnresolvedAddressException.class)) {
+                            l.countDown();
+                        }
+                    }
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidFuturePort() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final AtomicBoolean called = new AtomicBoolean(false);
+            final AtomicBoolean rightCause = new AtomicBoolean(false);
+            // pick a random unused local port
+            int port = findFreePort();
+
+            try {
+                Response response = c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        called.set(true);
+                        if (t instanceof ConnectException) {
+                            rightCause.set(true);
+                        }
+                    }
+                }).get();
+                assertNull(response, "No ExecutionException was thrown");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
+            }
+            assertTrue(called.get(), "onThrowable should get called.");
+            assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncContentLenghtGETTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("Unexpected exception", t);
+                }
+            }).get();
+
+            Assert.assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncResponseBodyTooLarge() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("Unexpected exception", t);
+                }
+            }).get();
+
+            Assert.assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncResponseEmptyBody() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("Unexpected exception", t);
+                }
+            }).get();
+
+            assertEquals(response.getResponseBody(), "");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
+    public void asyncAPIContentLenghtGETTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
+
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
+    public void asyncAPIHandlerExceptionTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
+
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    throw new IllegalStateException("FOO");
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t.getMessage() != null) {
+                            assertEquals(t.getMessage(), "FOO");
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetDelayHandlerTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(5 * 1000).build());
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("LockThread", "true");
+
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
+
+            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        Assert.fail("Must not receive a response");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t instanceof TimeoutException) {
+                            Assert.assertTrue(true);
+                        } else {
+                            Assert.fail("Unexpected exception", t);
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetQueryStringTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
+
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        Assert.assertTrue(response.getHeader("X-pathInfo") != null);
+                        Assert.assertTrue(response.getHeader("X-queryString") != null);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            };
+
+            Request req = new RequestBuilder("GET").setUrl(getTargetUrl() + "?foo=bar").build();
+
+            client.executeRequest(req, handler).get();
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoGetKeepAliveHandlerTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
+
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                String remoteAddr = null;
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    assertEquals(response.getStatusCode(), 200);
+                    if (remoteAddr == null) {
+                        remoteAddr = response.getHeader("X-KEEP-ALIVE");
+                        l.countDown();
+                    } else {
+                        assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
+                        l.countDown();
+                    }
+
+                    return response;
+                }
+            };
+
+            client.prepareGet(getTargetUrl()).execute(handler).get();
+            client.prepareGet(getTargetUrl()).execute(handler);
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncDoGetMaxRedirectTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaximumNumberOfRedirects(0).setFollowRedirects(true).build());
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
+
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.fail("Should not be here");
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    try {
+                        assertEquals(t.getClass(), MaxRedirectException.class);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            };
+
+            client.prepareGet("http://google.com/").execute(handler);
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncDoGetNestedTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
+
+            final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
+
+                private final static int MAX_NESTED = 2;
+
+                private AtomicInteger nestedCount = new AtomicInteger(0);
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        if (nestedCount.getAndIncrement() < MAX_NESTED) {
+                            System.out.println("Executing a nested request: " + nestedCount);
+                            client.prepareGet("http://google.com/").execute(this);
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+            };
+
+            client.prepareGet("http://www.google.com/").execute(handler);
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncDoGetStreamAndBodyTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.prepareGet("http://www.google.com/").execute().get();
+
+            r.getResponseBody();
+            r.getResponseBodyAsStream();
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncUrlWithoutPathTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.prepareGet("http://www.google.com").execute().get();
+
+            r.getResponseBody();
+            r.getResponseBodyAsStream();
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "default_provider", "async" })
+    public void optionsTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.prepareOptions(getTargetUrl()).execute().get();
+
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testAwsS3() throws Exception {
+        final AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
+                fail("No response Body");
+            } else {
+                assertEquals(response.getStatusCode(), 403);
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testAsyncHttpProviderConfig() throws Exception {
+
+        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
+        try {
+            Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
+                fail("No response Body");
+            } else {
+                assertEquals(response.getStatusCode(), 403);
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void idleRequestTimeoutTest() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(5000).setRequestTimeoutInMs(10000).build());
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+
+            long t1 = millisTime();
+            try {
+                c.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        // t.printStackTrace();
+                    }
+
+                }).get();
+                Assert.fail();
+            } catch (Throwable ex) {
+                final long elapsedTime = millisTime() - t1;
+                System.out.println("EXPIRED: " + (elapsedTime));
+                Assert.assertNotNull(ex.getCause());
+                Assert.assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostCancelTest() throws Throwable {
+
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
+
+            final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
+            ex.set(null);
+            try {
+                Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        if (t instanceof CancellationException) {
+                            ex.set((CancellationException) t);
+                        }
+                        t.printStackTrace();
+                    }
+
+                });
+
+                future.cancel(true);
+            } catch (IllegalStateException ise) {
+                fail();
+            }
+            Assert.assertNotNull(ex.get());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void getShouldAllowBody() throws IllegalArgumentException, IOException {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
+            builder.setBody("Boo!");
+            builder.execute();
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = IllegalArgumentException.class)
+    public void headShouldNotAllowBody() throws IllegalArgumentException, IOException {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = c.prepareHead(getTargetUrl());
+            builder.setBody("Boo!");
+            builder.execute();
+        } finally {
+            c.close();
+        }
+    }
+
+    protected String getBrokenTargetUrl() {
+        return String.format("http:127.0.0.1:%d/foo/test", port1);
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void invalidUri() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getBrokenTargetUrl());
+            Response r = c.executeRequest(builder.build()).get();
+            assertEquals(200, r.getStatusCode());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncHttpClientConfigBeanTest() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
+            Response r = c.executeRequest(builder.build()).get();
+            assertEquals(200, r.getStatusCode());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "default_provider", "async" })
+    public void bodyAsByteTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        Response r = client.prepareGet(getTargetUrl()).execute().get();
+
+        assertEquals(r.getStatusCode(), 200);
+        assertEquals(r.getResponseBodyAsBytes(), new byte[] {});
+
+        client.close();
+    }
+
+    @Test(groups = { "default_provider", "async" })
+    public void mirrorByteTest() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
+
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(new String(r.getResponseBodyAsBytes(), "UTF-8"), "MIRROR");
+        } finally {
+            client.close();
+        }
+    }
+
+    protected abstract AsyncHttpProviderConfig getProviderConfig();
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
new file mode 100644
index 000000000..a2ab86cfc
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
@@ -0,0 +1,578 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public abstract class AsyncStreamHandlerTest extends AbstractBasicTest {
+    private final static String RESPONSE = "param_1_";
+    private final static String UTF8 = "text/html;charset=utf-8";
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamGETTest() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    try {
+                        FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                        Assert.assertNotNull(h);
+                        Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                        return STATE.ABORT;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("", t);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamPOSTTest() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        h.add("Content-Type", "application/x-www-form-urlencoded");
+        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+        m.put("param_1", Arrays.asList("value_1"));
+
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(10, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamInterruptTest() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        h.add("Content-Type", "application/x-www-form-urlencoded");
+
+        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+        m.put("param_1", Arrays.asList("value_1"));
+
+        final AtomicBoolean a = new AtomicBoolean(true);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.ABORT;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                    a.set(false);
+                    Assert.fail("Interrupted not working");
+                    return STATE.ABORT;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("", t);
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            l.await(5, TimeUnit.SECONDS);
+            Assert.assertTrue(a.get());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamFutureTest() throws Throwable {
+        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+        m.put("param_1", Arrays.asList("value_1"));
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Future<String> f = c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString().trim();
+                    Assert.assertEquals(r, RESPONSE);
+                    return r;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("", t);
+                }
+            });
+
+            try {
+                String r = f.get(5, TimeUnit.SECONDS);
+                Assert.assertNotNull(r);
+                Assert.assertEquals(r.trim(), RESPONSE);
+            } catch (TimeoutException ex) {
+                Assert.fail();
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamThrowableRefusedTest() throws Throwable {
+
+        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    throw new RuntimeException("FOO");
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t.getMessage() != null) {
+                            Assert.assertEquals(t.getMessage(), "FOO");
+                        }
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(10, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncStreamReusePOSTTest() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        h.add("Content-Type", "application/x-www-form-urlencoded");
+
+        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+        m.put("param_1", Arrays.asList("value_1"));
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
+
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+
+            // Let do the same again
+            c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void asyncStream301WithBody() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), "text/html; charset=utf-8");
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString();
+                    Assert.assertTrue(r.contains("301 Moved"));
+                    l.countDown();
+                    return r;
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void asyncStream301RedirectWithBody() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        try {
+            c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getFirstValue("server"), "gws");
+                    // This assertion below is not an invariant, since implicitly contains locale-dependant settings
+                    // and fails when run in country having own localized Google site and it's locale relies on something
+                    // other than ISO-8859-1.
+                    // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
+                    // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
+                    // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
+                    //
+                    // Assert.assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString();
+                    Assert.assertTrue(!r.contains("301 Moved"));
+                    l.countDown();
+
+                    return r;
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
+    public void asyncStreamJustStatusLine() throws Throwable {
+        final int STATUS = 0;
+        final int COMPLETED = 1;
+        final int OTHER = 2;
+        final boolean[] whatCalled = new boolean[] { false, false, false };
+        final CountDownLatch latch = new CountDownLatch(1);
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
+                private int status = -1;
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                }
+
+                /* @Override */
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
+
+                /* @Override */
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    whatCalled[STATUS] = true;
+                    System.out.println(responseStatus);
+                    status = responseStatus.getStatusCode();
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
+
+                /* @Override */
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
+
+                /* @Override */
+                public Integer onCompleted() throws Exception {
+                    whatCalled[COMPLETED] = true;
+                    latch.countDown();
+                    return status;
+                }
+            });
+
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout");
+                return;
+            }
+            Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
+            Assert.assertEquals((int) status, 200, "Expected status code failed.");
+
+            if (!whatCalled[STATUS]) {
+                Assert.fail("onStatusReceived not called.");
+            }
+            if (!whatCalled[COMPLETED]) {
+                Assert.fail("onCompleted not called.");
+            }
+            if (whatCalled[OTHER]) {
+                Assert.fail("Other method of AsyncHandler got called.");
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void asyncOptionsTest() throws Throwable {
+        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
+            c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    String[] values = h.get("Allow").get(0).split(",|, ");
+                    Assert.assertNotNull(values);
+                    Assert.assertEquals(values.length, expected.length);
+                    Arrays.sort(values);
+                    Assert.assertEquals(values, expected);
+                    return STATE.ABORT;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        return "OK";
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void closeConnectionTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    builder.accumulate(content);
+                    return STATE.CONTINUE;
+                }
+
+                public void onThrowable(Throwable t) {
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.accumulate(content);
+
+                    if (content.isLast()) {
+                        content.markUnderlyingConnectionAsClosed();
+                    }
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+
+                    return STATE.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get();
+
+            Assert.assertNotNull(r);
+            Assert.assertEquals(r.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java b/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
similarity index 58%
rename from api/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java
rename to api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
index faeaee7cc..1c7f78c5e 100644
--- a/api/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
@@ -13,13 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
@@ -47,7 +47,7 @@
 
 /**
  * Tests default asynchronous life cycle.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class AsyncStreamLifecycleTest extends AbstractBasicTest {
@@ -63,8 +63,7 @@ public void tearDownGlobal() throws Exception {
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
-            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
                 resp.setContentType("text/plain;charset=utf-8");
                 resp.setStatus(200);
                 final Continuation continuation = ContinuationSupport.getContinuation(req);
@@ -100,62 +99,64 @@ public void run() {
         };
     }
 
-    //TODO Netty only.
+    // TODO Netty only.
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testStream() throws IOException {
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final AtomicBoolean err = new AtomicBoolean(false);
-        final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
-        final AtomicBoolean status = new AtomicBoolean(false);
-        final AtomicInteger headers = new AtomicInteger(0);
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-            public void onThrowable(Throwable t) {
-                fail("Got throwable.", t);
-                err.set(true);
-            }
+        try {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                String s = new String(e.getBodyPartBytes());
-                log.info("got part: {}", s);
-                if (s.equals("")) {
-                    //noinspection ThrowableInstanceNeverThrown
-                    log.warn("Sampling stacktrace.",
-                            new Throwable("trace that, we should not get called for empty body."));
+                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    String s = new String(e.getBodyPartBytes());
+                    log.info("got part: {}", s);
+                    if (s.equals("")) {
+                        // noinspection ThrowableInstanceNeverThrown
+                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    }
+                    queue.put(s);
+                    return STATE.CONTINUE;
                 }
-                queue.put(s);
-                return STATE.CONTINUE;
-            }
 
-            public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
-                status.set(true);
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
-                if (headers.incrementAndGet() == 2) {
-                    throw new Exception("Analyze this.");
+                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public Object onCompleted() throws Exception {
-                latch.countDown();
-                return null;
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            try {
+                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
             }
-        });
-        try {
-            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
+            assertFalse(err.get());
+            assertEquals(queue.size(), 2);
+            assertTrue(queue.contains("part1"));
+            assertTrue(queue.contains("part2"));
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
+        } finally {
+            ahc.close();
         }
-        assertFalse(err.get());
-        assertEquals(queue.size(), 2);
-        assertTrue(queue.contains("part1"));
-        assertTrue(queue.contains("part2"));
-        assertTrue(status.get());
-        assertEquals(headers.get(), 1);
-        ahc.close();
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java b/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
similarity index 66%
rename from api/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java
rename to api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
index 13a9ef529..fb9159599 100644
--- a/api/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Response;
 import org.apache.log4j.ConsoleAppender;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
@@ -49,8 +49,7 @@
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
-public abstract class AuthTimeoutTest
-        extends AbstractBasicTest {
+public abstract class AuthTimeoutTest extends AbstractBasicTest {
 
     private final static String user = "user";
 
@@ -58,8 +57,7 @@
 
     protected AsyncHttpClient client;
 
-    public void setUpServer(String auth)
-            throws Exception {
+    public void setUpServer(String auth) throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
@@ -78,7 +76,7 @@ public void setUpServer(String auth)
 
         Constraint constraint = new Constraint();
         constraint.setName(auth);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -105,10 +103,8 @@ public void setUpServer(String auth)
         log.info("Local HTTP server started successfully");
     }
 
-    private class SimpleHandler
-            extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response)
-                throws IOException, ServletException {
+    private class SimpleHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
 
@@ -128,150 +124,135 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get();
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicPreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicPreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get();
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get();
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestPreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestPreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get();
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicFutureAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicFutureAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
 
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicFuturePreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
 
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestFutureAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestFutureAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestFuturePreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     protected void inspectException(Throwable t) {
         assertNotNull(t.getCause());
         assertEquals(t.getCause().getClass(), IOException.class);
-        if (!t.getCause().getMessage().startsWith("Remotely Closed")){
+        if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
             fail();
-        };
+        }
     }
 
-    protected Future<Response> execute(boolean preemptive)
-            throws IOException {
-        client =
-                getAsyncHttpClient(
-                        new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).setConnectionTimeoutInMs(20000).setRequestTimeoutInMs(2000).build());
-        AsyncHttpClient.BoundRequestBuilder r =
-                client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content",
-                        "Test");
+    protected Future<Response> execute(boolean preemptive) throws IOException {
+        client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).setConnectionTimeoutInMs(20000).setRequestTimeoutInMs(2000).build());
+        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content", "Test");
         Future<Response> f = r.execute();
         return f;
     }
@@ -286,8 +267,7 @@ protected String getTargetUrl() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new SimpleHandler();
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/BasicAuthTest.java b/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
similarity index 55%
rename from api/src/test/java/com/ning/http/client/async/BasicAuthTest.java
rename to api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
index 8f3422e81..361e57be5 100644
--- a/api/src/test/java/com/ning/http/client/async/BasicAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
@@ -13,19 +13,19 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Response;
-import com.ning.http.client.SimpleAsyncHttpClient;
-import com.ning.http.client.consumers.AppendableBodyConsumer;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SimpleAsyncHttpClient;
+import org.asynchttpclient.consumers.AppendableBodyConsumer;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
 import org.apache.log4j.ConsoleAppender;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
@@ -79,8 +79,7 @@ public void setUpGlobal() throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(
-                new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
+        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
 
         port1 = findFreePort();
         Connector listener = new SelectChannelConnector();
@@ -95,7 +94,7 @@ public void setUpGlobal() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -134,8 +133,7 @@ private String getFileContent(final File file) {
                 }
                 return sb.toString();
             }
-            throw new IllegalArgumentException("File does not exist or cannot be read: "
-                    + file.getCanonicalPath());
+            throw new IllegalArgumentException("File does not exist or cannot be read: " + file.getCanonicalPath());
         } catch (IOException ioe) {
             throw new IllegalStateException(ioe);
         } finally {
@@ -164,7 +162,7 @@ private void setUpSecondServer() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__DIGEST_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -178,8 +176,7 @@ private void setUpSecondServer() throws Exception {
         ConstraintSecurityHandler security = new ConstraintSecurityHandler() {
 
             @Override
-            public void handle(String arg0, Request arg1, HttpServletRequest arg2, HttpServletResponse arg3)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest arg2, HttpServletResponse arg3) throws IOException, ServletException {
                 System.err.println("request in security handler");
                 System.err.println("Authorization: " + arg2.getHeader("Authorization"));
                 System.err.println("RequestUri: " + arg2.getRequestURI());
@@ -205,10 +202,7 @@ private void stopSecondServer() throws Exception {
     }
 
     private class RedirectHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             System.err.println("redirecthandler");
             System.err.println("request: " + request.getRequestURI());
@@ -235,10 +229,7 @@ public void handle(String s,
     }
 
     private class SimpleHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             if (request.getHeader("X-401") != null) {
                 response.setStatus(401);
@@ -251,7 +242,6 @@ public void handle(String s,
             response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
             response.setStatus(200);
 
-
             int size = 10 * 1024;
             if (request.getContentLength() > 0) {
                 size = request.getContentLength();
@@ -268,28 +258,30 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = null;
         try {
             setUpSecondServer();
             client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setMaximumNumberOfRedirects(10).build());
             AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl2())
-                    // .setHeader( "X-302", "/bla" )
+            // .setHeader( "X-302", "/bla" )
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
 
             Future<Response> f = r.execute();
@@ -299,7 +291,8 @@ public void redirectAndBasicAuthTest() throws Exception, ExecutionException, Tim
             assertNotNull(resp.getHeader("X-Auth"));
 
         } finally {
-            if (client != null) client.close();
+            if (client != null)
+                client.close();
             stopSecondServer();
         }
     }
@@ -313,152 +306,165 @@ protected String getTargetUrl2() {
         return "http://127.0.0.1:" + port2 + "/uff";
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setHeader("X-401", "401").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setHeader("X-401", "401").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
 
-            private HttpResponseStatus status;
+            Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
 
+                private HttpResponseStatus status;
 
-            public void onThrowable(Throwable t) {
+                public void onThrowable(Throwable t) {
 
-            }
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                this.status = responseStatus;
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    this.status = responseStatus;
 
-                if (status.getStatusCode() != 200) {
-                    return STATE.ABORT;
+                    if (status.getStatusCode() != 200) {
+                        return STATE.ABORT;
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public Integer onCompleted() throws Exception {
-                return status.getStatusCode();
-            }
-        });
-        Integer statusCode = f.get(10, TimeUnit.SECONDS);
-        assertNotNull(statusCode);
-        assertEquals(statusCode.intValue(), 401);
-        client.close();
+                public Integer onCompleted() throws Exception {
+                    return status.getStatusCode();
+                }
+            });
+            Integer statusCode = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(statusCode);
+            assertEquals(statusCode.intValue(), 401);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(true).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(true).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 401);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        ByteArrayInputStream is = new ByteArrayInputStream("test".getBytes());
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(is).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(30, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "test");
-        client.close();
+        try {
+            ByteArrayInputStream is = new ByteArrayInputStream("test".getBytes());
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(is).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(30, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "test");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthAsyncConfigTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build()).build());
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file);
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build()).build());
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file);
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileNoKeepAliveTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(false).build());
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
     @Override
@@ -466,40 +472,38 @@ public AbstractHandler configureHandler() throws Exception {
         return new SimpleHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void StringBufferBodyConsumerTest() throws Throwable {
-
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-                .setRealmPrincipal(user)
-                .setRealmPassword(admin)
-                .setUrl(getTargetUrl())
-                .setHeader("Content-Type", "text/html").build();
-
-        StringBuilder s = new StringBuilder();
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void StringBuilderBodyConsumerTest() throws Throwable {
 
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(s.toString(), MY_MESSAGE);
-        assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(response.getHeader("X-Auth"));
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setRealmPrincipal(user).setRealmPassword(admin).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            StringBuilder s = new StringBuilder();
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(s.toString(), MY_MESSAGE);
+            assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(response.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 }
-
diff --git a/api/src/test/java/com/ning/http/client/async/BasicHttpsTest.java b/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
similarity index 68%
rename from api/src/test/java/com/ning/http/client/async/BasicHttpsTest.java
rename to api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
index bcd508e2d..619f52322 100644
--- a/api/src/test/java/com/ning/http/client/async/BasicHttpsTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig.Builder;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -65,10 +65,7 @@
     public static class EchoHandler extends AbstractHandler {
 
         /* @Override */
-        public void handle(String pathInContext,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws ServletException, IOException {
+        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
 
             httpResponse.setContentType("text/html; charset=utf-8");
             Enumeration<?> e = httpRequest.getHeaderNames();
@@ -122,10 +119,15 @@ public void handle(String pathInContext,
                 size = httpRequest.getContentLength();
             }
             byte[] bytes = new byte[size];
+            int pos = 0;
             if (bytes.length > 0) {
-                //noinspection ResultOfMethodCallIgnored
-                int read = httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes, 0, read);
+                int read = 0;
+                while (read != -1) {
+                    read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
+                    pos += read;
+                }
+
+                httpResponse.getOutputStream().write(bytes);
             }
 
             httpResponse.setStatus(200);
@@ -161,8 +163,7 @@ protected int findFreePort() throws IOException {
             socket = new ServerSocket(0);
 
             return socket.getLocalPort();
-        }
-        finally {
+        } finally {
             if (socket != null) {
                 socket.close();
             }
@@ -203,110 +204,96 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPostTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLRequestsTest() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
 
-        // twice
-        response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // twice
+            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLWithoutCacheTest() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).setAllowSslConnectionPool(false).build());
+        try {
+            String body = "hello there";
+            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
-        String body = "hello there";
-        c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute();
-
-        c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute();
+            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
-       Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get();
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get();
 
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void reconnectsAfterFailedCertificationPath() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
-
-        final String body = "hello there";
-
-        TRUST_SERVER_CERT.set(false);
         try {
-            // first request fails because server certificate is rejected
+            final String body = "hello there";
+
+            TRUST_SERVER_CERT.set(false);
             try {
-                c.preparePost(getTargetUrl())
-                        .setBody(body)
-                        .setHeader("Content-Type", "text/html")
-                        .execute().get(TIMEOUT, TimeUnit.SECONDS);
-            }
-            catch (final ExecutionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof ConnectException) {
-                    assertNotNull(cause.getCause());
-                    assertTrue(cause.getCause() instanceof SSLHandshakeException);
-                } else {
-                    assertTrue(cause instanceof SSLHandshakeException);
+                // first request fails because server certificate is rejected
+                try {
+                    c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+                } catch (final ExecutionException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof ConnectException) {
+                        assertNotNull(cause.getCause());
+                        assertTrue(cause.getCause() instanceof SSLHandshakeException);
+                    } else {
+                        assertTrue(cause instanceof SSLHandshakeException);
+                    }
                 }
-            }
 
-            TRUST_SERVER_CERT.set(true);
+                TRUST_SERVER_CERT.set(true);
 
-            // second request should succeed
-            final Response response = c.preparePost(getTargetUrl())
-                    .setBody(body)
-                    .setHeader("Content-Type", "text/html")
-                    .execute().get(TIMEOUT, TimeUnit.SECONDS);
+                // second request should succeed
+                final Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getResponseBody(), body);
-        }
-        finally {
-            TRUST_SERVER_CERT.set(true);
+                assertEquals(response.getResponseBody(), body);
+            } finally {
+                TRUST_SERVER_CERT.set(true);
+            }
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     private static SSLContext createSSLContext() {
@@ -323,15 +310,14 @@ private static SSLContext createSSLContext() {
 
             // Initialize the SSLContext to work with our key managers.
             KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[]{DUMMY_TRUST_MANAGER};
+            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
             SecureRandom secureRandom = new SecureRandom();
 
             SSLContext sslContext = SSLContext.getInstance("TLS");
             sslContext.init(keyManagers, trustManagers, secureRandom);
 
             return sslContext;
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             throw new Error("Failed to initialize the server-side SSLContext", e);
         }
     }
@@ -342,17 +328,14 @@ private static SSLContext createSSLContext() {
             return new X509Certificate[0];
         }
 
-        public void checkClientTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
         }
 
-        public void checkServerTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             if (!TRUST_SERVER_CERT.get()) {
                 throw new CertificateException("Server certificate not trusted.");
             }
         }
     };
 
-
 }
diff --git a/api/src/test/java/com/ning/http/client/async/BodyChunkTest.java b/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
similarity index 58%
rename from api/src/test/java/com/ning/http/client/async/BodyChunkTest.java
rename to api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
index 8db2bfb64..449863277 100644
--- a/api/src/test/java/com/ning/http/client/async/BodyChunkTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
@@ -13,13 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
@@ -31,7 +31,7 @@
 
     private final static String MY_MESSAGE = "my message";
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void negativeContentTypeTest() throws Throwable {
 
         AsyncHttpClientConfig.Builder confbuilder = new AsyncHttpClientConfig.Builder();
@@ -41,23 +41,21 @@ public void negativeContentTypeTest() throws Throwable {
 
         // Create client
         AsyncHttpClient client = getAsyncHttpClient(confbuilder.build());
+        try {
 
-        RequestBuilder requestBuilder = new RequestBuilder("POST")
-                .setUrl(getTargetUrl())
-                .setHeader("Content-Type", "message/rfc822");
+            RequestBuilder requestBuilder = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeader("Content-Type", "message/rfc822");
 
-        requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+            requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-        Future<Response> future = client.executeRequest(requestBuilder.build());
+            Future<Response> future = client.executeRequest(requestBuilder.build());
 
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBody(), MY_MESSAGE);
-        
-        client.close();
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
 }
-
-
diff --git a/api/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
similarity index 51%
rename from api/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
index 48e1836a6..e6bf47bf9 100644
--- a/api/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.BodyDeferringAsyncHandler;
-import com.ning.http.client.BodyDeferringAsyncHandler.BodyDeferringInputStream;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BodyDeferringAsyncHandler;
+import org.asynchttpclient.BodyDeferringAsyncHandler.BodyDeferringInputStream;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
@@ -44,9 +44,7 @@
 
     public static class SlowAndBigHandler extends AbstractHandler {
 
-        public void handle(String pathInContext, Request request,
-                HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-                throws IOException, ServletException {
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             // 512MB large download
             // 512 * 1024 * 1024 = 536870912
@@ -56,8 +54,7 @@ public void handle(String pathInContext, Request request,
 
             httpResponse.flushBuffer();
 
-            final boolean wantFailure = httpRequest
-                    .getHeader("X-FAIL-TRANSFER") != null;
+            final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
             final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
 
             OutputStream os = httpResponse.getOutputStream();
@@ -104,8 +101,7 @@ public int getByteCount() {
     }
 
     // simple stream copy just to "consume". It closes streams.
-    public static void copy(InputStream in, OutputStream out)
-            throws IOException {
+    public static void copy(InputStream in, OutputStream out) throws IOException {
         byte[] buf = new byte[1024];
         int len;
         while ((len = in.read(buf)) > 0) {
@@ -122,116 +118,103 @@ public AbstractHandler configureHandler() throws Exception {
 
     public AsyncHttpClientConfig getAsyncHttpClientConfig() {
         // for this test brevity's sake, we are limiting to 1 retries
-        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0)
-                .setRequestTimeoutInMs(10000).build();
+        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).setRequestTimeoutInMs(10000).build();
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredSimple() throws IOException, ExecutionException,
-            TimeoutException, InterruptedException {
+    public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        Future<Response> f = r.execute(bdah);
-        Response resp = bdah.getResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // we got headers only, it's probably not all yet here (we have BIG file
-        // downloading)
-        assertEquals(true, HALF_GIG >= cos.getByteCount());
-
-        // now be polite and wait for body arrival too (otherwise we would be
-        // dropping the "line" on server)
-        f.get();
-        // it all should be here now
-        assertEquals(true, HALF_GIG == cos.getByteCount());
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertEquals(true, HALF_GIG >= cos.getByteCount());
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            f.get();
+            // it all should be here now
+            assertEquals(true, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
-    public void deferredSimpleWithFailure() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(
-                "http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure")
-                .addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        Future<Response> f = r.execute(bdah);
-        Response resp = bdah.getResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // we got headers only, it's probably not all yet here (we have BIG file
-        // downloading)
-        assertEquals(true, HALF_GIG >= cos.getByteCount());
-
-        // now be polite and wait for body arrival too (otherwise we would be
-        // dropping the "line" on server)
         try {
-            f.get();
-            Assert.fail("get() should fail with IOException!");
-        } catch (Exception e) {
-            // good
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertEquals(true, HALF_GIG >= cos.getByteCount());
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            try {
+                f.get();
+                Assert.fail("get() should fail with IOException!");
+            } catch (Exception e) {
+                // good
+            }
+            // it's incomplete, there was an error
+            assertEquals(false, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
         }
-        // it's incomplete, there was an error
-        assertEquals(false, HALF_GIG == cos.getByteCount());
-        client.close();
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredInputStreamTrick() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + port1
-                        + "/deferredInputStreamTrick");
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
 
-        PipedOutputStream pos = new PipedOutputStream();
-        PipedInputStream pis = new PipedInputStream(pos);
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
 
-        Future<Response> f = r.execute(bdah);
+            Future<Response> f = r.execute(bdah);
 
-        BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
 
-        Response resp = is.getAsapResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // "consume" the body, but our code needs input stream
-        CountingOutputStream cos = new CountingOutputStream();
-        copy(is, cos);
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            copy(is, cos);
 
-        // now we don't need to be polite, since consuming and closing
-        // BodyDeferringInputStream does all.
-        // it all should be here now
-        assertEquals(true, HALF_GIG == cos.getByteCount());
-        client.close();
+            // now we don't need to be polite, since consuming and closing
+            // BodyDeferringInputStream does all.
+            // it all should be here now
+            assertEquals(true, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredInputStreamTrickWithFailure() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(
-                "http://127.0.0.1:" + port1
-                        + "/deferredInputStreamTrickWithFailure").addHeader(
-                "X-FAIL-TRANSFER", Boolean.TRUE.toString());
+        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
 
         PipedOutputStream pos = new PipedOutputStream();
         PipedInputStream pis = new PipedInputStream(pos);
@@ -244,10 +227,7 @@ public void deferredInputStreamTrickWithFailure() throws IOException,
         Response resp = is.getAsapResponse();
         assertNotNull(resp);
         assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
+        assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
         // "consume" the body, but our code needs input stream
         CountingOutputStream cos = new CountingOutputStream();
         try {
@@ -260,25 +240,24 @@ public void deferredInputStreamTrickWithFailure() throws IOException,
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testConnectionRefused() throws IOException, ExecutionException,
-            TimeoutException, InterruptedException {
+    public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         int newPortWithoutAnyoneListening = findFreePort();
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening
-                        + "/testConnectionRefused");
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        r.execute(bdah);
         try {
-            bdah.getResponse();
-            Assert.fail("IOException should be thrown here!");
-        } catch (IOException e) {
-            // good
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            r.execute(bdah);
+            try {
+                bdah.getResponse();
+                Assert.fail("IOException should be thrown here!");
+            } catch (IOException e) {
+                // good
+            }
+        } finally {
+            client.close();
         }
-
-        client.close();
     }
 
 }
diff --git a/api/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java b/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
similarity index 65%
rename from api/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java
rename to api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
index 58c36c224..1a6763a43 100644
--- a/api/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
@@ -33,15 +33,11 @@
 import static org.testng.Assert.*;
 
 public abstract class ByteBufferCapacityTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -75,43 +71,43 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicByteBufferTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-        File largeFile = createTempFile(bytes, (int) repeats);
-        final AtomicInteger byteReceived = new AtomicInteger();
-
         try {
-            Response response = c.preparePut(getTargetUrl()).setBody(largeFile)
-                    .execute(new AsyncCompletionHandlerAdapter() {
-                        /* @Override */
-                        public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                            byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
-                            return super.onBodyPartReceived(content);
-                        }
-
-                    }).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(byteReceived.get(), largeFile.length());
-            assertEquals(response.getResponseBody().length(), largeFile.length());
-
-        } catch (IOException ex) {
-            fail("Should have timed out");
+            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
+            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
+            File largeFile = createTempFile(bytes, (int) repeats);
+            final AtomicInteger byteReceived = new AtomicInteger();
+
+            try {
+                Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
+                    /* @Override */
+                    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                        byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
+                        return super.onBodyPartReceived(content);
+                    }
+
+                }).get();
+
+                assertNotNull(response);
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(byteReceived.get(), largeFile.length());
+                assertEquals(response.getResponseBody().length(), largeFile.length());
+
+            } catch (IOException ex) {
+                fail("Should have timed out");
+            }
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -120,8 +116,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -130,8 +125,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/api/src/test/java/com/ning/http/client/async/ChunkingTest.java b/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
similarity index 93%
rename from api/src/test/java/com/ning/http/client/async/ChunkingTest.java
rename to api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
index 1860da24d..9334cf38b 100644
--- a/api/src/test/java/com/ning/http/client/async/ChunkingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
@@ -10,14 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.BufferedInputStream;
@@ -101,7 +102,7 @@ private void doTest(boolean customChunkedInputStream) throws Exception {
                 // made buff in stream big enough to mark.
                 builder.setBody(new InputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(getTestFile()), 400000)));
             }
-            com.ning.http.client.Request r = builder.build();
+            Request r = builder.build();
             Response res = null;
 
             try {
diff --git a/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java b/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
new file mode 100644
index 000000000..8bf0bc6e6
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.testng.annotations.Test;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.testng.Assert.assertEquals;
+
+public abstract class ComplexClientTest extends AbstractBasicTest {
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void multipleRequestsTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String body = "hello there";
+
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), body);
+
+            // twice
+            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void urlWithoutSlashTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String body = "hello there";
+
+            Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java b/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
new file mode 100644
index 000000000..ccc7d3901
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
+public abstract class ConnectionPoolTest extends AbstractBasicTest {
+    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMaxTotalConnections() {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 3; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+                    Response response = client.prepareGet(url).execute().get();
+                    log.info("{} response [{}].", i, response);
+                } catch (Exception ex) {
+                    exception = ex;
+                }
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMaxTotalConnectionsException() {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 20; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+
+                    if (i < 5) {
+                        client.prepareGet(url).execute().get();
+                    } else {
+                        client.prepareGet(url).execute();
+                    }
+                } catch (Exception ex) {
+                    exception = ex;
+                    break;
+                }
+            }
+            assertNotNull(exception);
+            assertNotNull(exception.getMessage());
+            assertEquals(exception.getMessage(), "Too many connections 1");
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" }, enabled = true, invocationCount = 10, alwaysRun = true)
+    public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
+
+            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<String, Boolean>();
+
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    System.out.println("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            };
+
+            client.prepareGet(getTargetUrl()).execute(handler).get();
+            server.stop();
+            server.start();
+            client.prepareGet(getTargetUrl()).execute(handler);
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+
+            assertEquals(remoteAddresses.size(), 2);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public abstract void testInvalidConnectionsPool();
+
+    @Test(groups = { "standalone", "default_provider" })
+    public abstract void testValidConnectionsPool();
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void multipleMaxConnectionOpenTest() throws Throwable {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
+
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), body);
+
+            // twice
+            Exception exception = null;
+            try {
+                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                fail("Should throw exception. Too many connections issued.");
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertEquals(exception.getMessage(), "Too many connections 1");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void multipleMaxConnectionOpenTestWithQuery() throws Throwable {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
+
+            // once
+            Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), "foo_" + body);
+
+            // twice
+            Exception exception = null;
+            try {
+                response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    /**
+     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
+     * 
+     * @throws Throwable
+     *             if something wrong happens.
+     */
+    @Test(groups = { "standalone", "default_provider" })
+    public void win7DisconnectTest() throws Throwable {
+        final AtomicInteger count = new AtomicInteger(0);
+
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+
+                    count.incrementAndGet();
+                    StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
+                    IOException t = new IOException();
+                    t.setStackTrace(new StackTraceElement[] { e });
+                    throw t;
+                }
+            };
+
+            try {
+                client.prepareGet(getTargetUrl()).execute(handler).get();
+                fail("Must have received an exception");
+            } catch (ExecutionException ex) {
+                assertNotNull(ex);
+                assertNotNull(ex.getCause());
+                assertEquals(ex.getCause().getClass(), IOException.class);
+                assertEquals(count.get(), 1);
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void asyncHandlerOnThrowableTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final AtomicInteger count = new AtomicInteger();
+            final String THIS_IS_NOT_FOR_YOU = "This is not for you";
+            final CountDownLatch latch = new CountDownLatch(16);
+            for (int i = 0; i < 16; i++) {
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw new Exception(THIS_IS_NOT_FOR_YOU);
+                    }
+                });
+
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
+                            count.incrementAndGet();
+                        }
+                    }
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        latch.countDown();
+                        return response;
+                    }
+                });
+            }
+            latch.await(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(count.get(), 0);
+        } finally {
+            client.close();
+        }
+    }
+
+}
diff --git a/api/src/test/java/com/ning/http/client/async/DigestAuthTest.java b/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
similarity index 66%
rename from api/src/test/java/com/ning/http/client/async/DigestAuthTest.java
rename to api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
index 21cbfa91c..dbd83a400 100644
--- a/api/src/test/java/com/ning/http/client/async/DigestAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Response;
 import org.apache.log4j.ConsoleAppender;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
@@ -60,8 +60,7 @@ public void setUpGlobal() throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(
-                new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
+        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
 
         port1 = findFreePort();
         Connector listener = new SelectChannelConnector();
@@ -76,7 +75,7 @@ public void setUpGlobal() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -103,10 +102,7 @@ public void setUpGlobal() throws Exception {
     }
 
     private class SimpleHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             response.addHeader("X-Auth", request.getHeader("Authorization"));
             response.setStatus(200);
@@ -115,50 +111,51 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user)
-                        .setPassword(admin)
-                        .setRealmName("MyRealm")
-                        .setScheme(Realm.AuthScheme.DIGEST).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(60, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(resp.getHeader("X-Auth"));
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").setScheme(Realm.AuthScheme.DIGEST).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user)
-                        .setPassword(admin)
-                        .setRealmName("MyRealm").build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(60, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(resp.getHeader("X-Auth"));
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).setScheme(Realm.AuthScheme.DIGEST).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(20, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 401);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).setScheme(Realm.AuthScheme.DIGEST).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(20, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java b/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
new file mode 100644
index 000000000..13924201c
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.assertNotNull;
+
+import static org.testng.Assert.fail;
+
+/**
+ * Tests case where response doesn't have body.
+ * 
+ * @author Hubert Iwaniuk
+ */
+public abstract class EmptyBodyTest extends AbstractBasicTest {
+    private class NoBodyResponseHandler extends AbstractHandler {
+        public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
+
+            if (!req.getMethod().equalsIgnoreCase("PUT")) {
+                resp.setStatus(HttpServletResponse.SC_OK);
+            } else {
+                resp.setStatus(204);
+            }
+            request.setHandled(true);
+        }
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new NoBodyResponseHandler();
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testEmptyBody() throws IOException {
+        AsyncHttpClient ahc = getAsyncHttpClient(null);
+        try {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    String s = new String(e.getBodyPartBytes());
+                    log.info("got part: {}", s);
+                    if (s.equals("")) {
+                        // noinspection ThrowableInstanceNeverThrown
+                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    }
+                    queue.put(s);
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return AsyncHandler.STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return STATE.CONTINUE;
+                }
+
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            try {
+                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
+            }
+            assertFalse(err.get());
+            assertEquals(queue.size(), 0);
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
+        } finally {
+            ahc.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testPutEmptyBody() throws Throwable {
+        AsyncHttpClient ahc = getAsyncHttpClient(null);
+        try {
+            Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 204);
+            assertEquals(response.getResponseBody(), "");
+            assertTrue(InputStream.class.isAssignableFrom(response.getResponseBodyAsStream().getClass()));
+            assertEquals(response.getResponseBodyAsStream().read(), -1);
+        } finally {
+            ahc.close();
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/ErrorResponseTest.java b/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
similarity index 72%
rename from api/src/test/java/com/ning/http/client/async/ErrorResponseTest.java
rename to api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
index 0613c27ef..97d038f59 100644
--- a/api/src/test/java/com/ning/http/client/async/ErrorResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
@@ -14,10 +14,10 @@
  * under the License.
  *
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -35,15 +35,14 @@
 
 /**
  * Tests to reproduce issues with handling of error responses
- *
+ * 
  * @author Tatu Saloranta
  */
 public abstract class ErrorResponseTest extends AbstractBasicTest {
     final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
 
     private static class ErrorHandler extends AbstractHandler {
-        public void handle(String s, Request r,
-                           HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             try {
                 Thread.sleep(210L);
             } catch (InterruptedException e) {
@@ -61,18 +60,18 @@ public AbstractHandler configureHandler() throws Exception {
         return new ErrorHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .prepareGet("http://127.0.0.1:" + port1 + "/foo")
-                .addHeader("Accepts", "*/*")
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 400);
-        String respStr = resp.getResponseBody();
-        assertEquals(BAD_REQUEST_STR, respStr);
-        client.close();
+        try {
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 400);
+            String respStr = resp.getResponseBody();
+            assertEquals(BAD_REQUEST_STR, respStr);
+        } finally {
+            client.close();
+        }
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java b/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
similarity index 68%
rename from api/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java
rename to api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
index 8ebb82d34..d522ab05f 100644
--- a/api/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
@@ -13,10 +13,10 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -38,10 +38,7 @@
 public abstract class Expect100ContinueTest extends AbstractBasicTest {
 
     private class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int size = 10 * 1024;
             if (httpRequest.getContentLength() > 0) {
@@ -58,21 +55,22 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void Expect100Continue() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
 
-        ClassLoader cl = getClass().getClassLoader();
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(file).execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
-
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(file).execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/api/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java b/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
similarity index 69%
rename from api/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java
rename to api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
index 87dd3aa37..2247181f7 100644
--- a/api/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.FilePart;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FilePart;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
@@ -35,43 +35,44 @@
 
 import static org.testng.FileAssert.fail;
 
-public abstract class FilePartLargeFileTest
-        extends AbstractBasicTest {
+public abstract class FilePartLargeFileTest extends AbstractBasicTest {
 
     private File largeFile;
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutImageFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutImageFile() throws Exception {
         largeFile = getTestFile();
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100 * 6000).build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
-
-        rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream" , "UTF-8"));
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
+            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
 
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutLargeTextFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutLargeTextFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 * 1024 / bytes.length) + 1;
         largeFile = createTempFile(bytes, (int) repeats);
 
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
-        AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream" , "UTF-8"));
+            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
     private static File getTestFile() {
@@ -96,12 +97,10 @@ public void after() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
-            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
                 ServletInputStream in = req.getInputStream();
                 byte[] b = new byte[8192];
@@ -125,11 +124,9 @@ public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServle
         };
     }
 
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -139,8 +136,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -149,8 +145,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/api/src/test/java/com/ning/http/client/async/FilterTest.java b/api/src/test/java/org/asynchttpclient/async/FilterTest.java
similarity index 72%
rename from api/src/test/java/com/ning/http/client/async/FilterTest.java
rename to api/src/test/java/org/asynchttpclient/async/FilterTest.java
index b71bb5566..6f843e5c4 100644
--- a/api/src/test/java/com/ning/http/client/async/FilterTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FilterTest.java
@@ -10,17 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.extra.ThrottleRequestFilter;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.ResponseFilter;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.extra.ThrottleRequestFilter;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
@@ -42,10 +42,7 @@
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -65,67 +62,70 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(100));
 
         AsyncHttpClient c = getAsyncHttpClient(b.build());
-
-        Response response = c.preparePost(getTargetUrl())
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+        try {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void loadThrottleTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(10));
 
         AsyncHttpClient c = getAsyncHttpClient(b.build());
+        try {
+            List<Future<Response>> futures = new ArrayList<Future<Response>>();
+            for (int i = 0; i < 200; i++) {
+                futures.add(c.preparePost(getTargetUrl()).execute());
+            }
 
-        List<Future<Response>> futures = new ArrayList<Future<Response>>();
-        for (int i = 0; i < 200; i++) {
-            futures.add(c.preparePost(getTargetUrl()).execute());
-        }
-
-        for (Future<Response> f : futures) {
-            Response r = f.get();
-            assertNotNull(f.get());
-            assertEquals(r.getStatusCode(), 200);
+            for (Future<Response> f : futures) {
+                Response r = f.get();
+                assertNotNull(f.get());
+                assertEquals(r.getStatusCode(), 200);
+            }
+        } finally {
+            c.close();
         }
-
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void maxConnectionsText() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(0, 1000));
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            /*Response response =*/ c.preparePost(getTargetUrl()).execute().get();
+            /* Response response = */c.preparePost(getTargetUrl()).execute().get();
             fail("Should have timed out");
         } catch (IOException ex) {
             assertNotNull(ex);
             assertEquals(ex.getCause().getClass(), FilterException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addResponseFilter(new ResponseFilter() {
 
-            //@Override
+            // @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 return ctx;
             }
@@ -134,18 +134,18 @@ public void basicResponseFilterTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -165,19 +165,19 @@ public void replayResponseFilterTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayStatusCodeResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -197,19 +197,19 @@ public void replayStatusCodeResponseFilterTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayHeaderResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -218,16 +218,10 @@ public void replayHeaderResponseFilterTest() throws Throwable {
 
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
 
-                if (ctx.getResponseHeaders() != null
-                        && ctx.getResponseHeaders().getHeaders().getFirstValue("Ping").equals("Pong")
-                        && replay.getAndSet(false)) {
+                if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().getHeaders().getFirstValue("Ping").equals("Pong") && replay.getAndSet(false)) {
 
                     Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
-                    return new FilterContext.FilterContextBuilder<T>()
-                            .asyncHandler(ctx.getAsyncHandler())
-                            .request(request)
-                            .replayRequest(true)
-                            .build();
+                    return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
                 }
                 return ctx;
             }
@@ -236,15 +230,15 @@ public void replayHeaderResponseFilterTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong")
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("Ping"), "Pong");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/FluentCaseInsensitiveStringsMapTest.java b/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
similarity index 99%
rename from api/src/test/java/com/ning/http/client/async/FluentCaseInsensitiveStringsMapTest.java
rename to api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
index 69e90e4e3..d58631801 100644
--- a/api/src/test/java/com/ning/http/client/async/FluentCaseInsensitiveStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
@@ -13,9 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.testng.annotations.Test;
 
 import java.util.Arrays;
diff --git a/api/src/test/java/com/ning/http/client/async/FluentStringsMapTest.java b/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
similarity index 99%
rename from api/src/test/java/com/ning/http/client/async/FluentStringsMapTest.java
rename to api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
index d6c679598..ffbb651a7 100644
--- a/api/src/test/java/com/ning/http/client/async/FluentStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
@@ -13,9 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.FluentStringsMap;
+import org.asynchttpclient.FluentStringsMap;
 import org.testng.annotations.Test;
 
 import java.util.Arrays;
@@ -119,8 +119,8 @@ public void nullValueTest() {
 
         map.add("foo", (String) null);
 
-        assertEquals(map.getFirstValue("foo"), "");
-        assertEquals(map.getJoinedValue("foo", ", "), "");
+        assertEquals(map.getFirstValue("foo"), null);
+        assertEquals(map.getJoinedValue("foo", ", "), null);
         assertEquals(map.get("foo").size(), 1);
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java b/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
new file mode 100644
index 000000000..c86ad22ae
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * Simple stress test for exercising the follow redirect.
+ */
+public abstract class FollowingThreadTest extends AbstractBasicTest {
+
+    private final static int COUNT = 10;
+
+    @Test(timeOut = 30 * 1000, groups = { "online", "default_provider", "scalability" })
+    public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+
+        final CountDownLatch countDown = new CountDownLatch(COUNT);
+        ExecutorService pool = Executors.newCachedThreadPool();
+        try {
+            for (int i = 0; i < COUNT; i++) {
+                pool.submit(new Runnable() {
+
+                    private int status;
+
+                    public void run() {
+                        final CountDownLatch l = new CountDownLatch(1);
+                        final AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+                        try {
+                            ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
+
+                                public void onThrowable(Throwable t) {
+                                    t.printStackTrace();
+                                }
+
+                                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                                    System.out.println(new String(bodyPart.getBodyPartBytes()));
+                                    return STATE.CONTINUE;
+                                }
+
+                                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                                    status = responseStatus.getStatusCode();
+                                    System.out.println(responseStatus.getStatusText());
+                                    return STATE.CONTINUE;
+                                }
+
+                                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                                    return STATE.CONTINUE;
+                                }
+
+                                public Integer onCompleted() throws Exception {
+                                    l.countDown();
+                                    return status;
+                                }
+                            });
+
+                            l.await();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        } finally {
+                            ahc.close();
+                            countDown.countDown();
+                        }
+                    }
+                });
+            }
+            countDown.await();
+        } finally {
+            pool.shutdown();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/api/src/test/java/com/ning/http/client/async/Head302Test.java b/api/src/test/java/org/asynchttpclient/async/Head302Test.java
similarity index 66%
rename from api/src/test/java/com/ning/http/client/async/Head302Test.java
rename to api/src/test/java/org/asynchttpclient/async/Head302Test.java
index d73397326..a01b47c91 100644
--- a/api/src/test/java/com/ning/http/client/async/Head302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/Head302Test.java
@@ -13,13 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -36,7 +36,7 @@
 
 /**
  * Tests HEAD request that gets 302 response.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class Head302Test extends AbstractBasicTest {
@@ -44,10 +44,7 @@
      * Handler that does Found (302) in response to HEAD method.
      */
     private class Head302handler extends AbstractHandler {
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("HEAD".equalsIgnoreCase(request.getMethod())) {
                 if (request.getPathInfo().endsWith("_moved")) {
                     response.setStatus(HttpServletResponse.SC_OK);
@@ -61,24 +58,27 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
 
-        client.executeRequest(request, new AsyncCompletionHandlerBase() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                l.countDown();
-                return super.onCompleted(response);
-            }
-        }).get(3, TimeUnit.SECONDS);
+            client.executeRequest(request, new AsyncCompletionHandlerBase() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    l.countDown();
+                    return super.onCompleted(response);
+                }
+            }).get(3, TimeUnit.SECONDS);
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     @Override
diff --git a/api/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java b/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
similarity index 70%
rename from api/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java
rename to api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
index bd0725c71..1b5238bab 100644
--- a/api/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig.Builder;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -56,10 +56,7 @@
     public static class EchoHandler extends AbstractHandler {
 
         /* @Override */
-        public void handle(String pathInContext,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws ServletException, IOException {
+        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
 
             httpResponse.setContentType("text/html; charset=utf-8");
             Enumeration<?> e = httpRequest.getHeaderNames();
@@ -113,10 +110,15 @@ public void handle(String pathInContext,
                 size = httpRequest.getContentLength();
             }
             byte[] bytes = new byte[size];
+            int pos = 0;
             if (bytes.length > 0) {
-                //noinspection ResultOfMethodCallIgnored
-                int read = httpRequest.getInputStream().read(bytes);
-                httpResponse.getOutputStream().write(bytes, 0, read);
+                int read = 0;
+                while (read != -1) {
+                    read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
+                    pos += read;
+                }
+
+                httpResponse.getOutputStream().write(bytes);
             }
 
             httpResponse.setStatus(200);
@@ -193,91 +195,106 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void positiveHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new PositiveHostVerifier()).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void negativeHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new NegativeHostVerifier()).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-            fail("ConnectException expected");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+                fail("ConnectException expected");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
+            }
+        } finally {
+            client.close();
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void remoteIDHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("bouette")).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-            fail("ConnectException expected");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+                fail("ConnectException expected");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
+            }
+        } finally {
+            client.close();
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void remoteNegHostnameVerifierTest() throws Throwable {
-    	// request is made to 127.0.0.1, but cert presented for localhost - this should fail
+        // request is made to 127.0.0.1, but cert presented for localhost - this should fail
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("localhost")).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-            fail("ConnectException expected");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+                fail("ConnectException expected");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
+            }
+        } finally {
+            client.close();
         }
     }
-    
-    @Test(groups = {"standalone", "default_provider"})
+
+    @Test(groups = { "standalone", "default_provider" })
     public void remotePosHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("127.0.0.1")).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Response resp = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");           
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Response resp = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute().get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
     public static class PositiveHostVerifier implements HostnameVerifier {
@@ -326,7 +343,7 @@ private static SSLContext createSSLContext() {
 
             // Initialize the SSLContext to work with our key managers.
             KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[]{DUMMY_TRUST_MANAGER};
+            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
             SecureRandom secureRandom = new SecureRandom();
 
             SSLContext sslContext = SSLContext.getInstance("TLS");
@@ -344,12 +361,10 @@ private static SSLContext createSSLContext() {
             return new X509Certificate[0];
         }
 
-        public void checkClientTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
         }
 
-        public void checkServerTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             if (!TRUST_SERVER_CERT.get()) {
                 throw new CertificateException("Server certificate not trusted.");
             }
diff --git a/api/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java b/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
similarity index 74%
rename from api/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java
rename to api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
index 7cd04b99b..45fa83842 100644
--- a/api/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -137,63 +133,61 @@ private static int getPort(URI uri) {
         return port;
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void httpToHttpsRedirect() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2())
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        c.close();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+        } finally {
+            c.close();
+        }
     }
 
     public String getTargetUrl2() {
         return String.format("https://127.0.0.1:%d/foo/test", port2);
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void httpToHttpsProperConfig() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2() + "/test2")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-
-        // Test if the internal channel is downgraded to clean http.
-        response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2() + "/foo2")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        c.close();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+
+            // Test if the internal channel is downgraded to clean http.
+            response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativeLocationUrl() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", "/foo/test")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        assertEquals(response.getUri().toString(), getTargetUrl());
-        c.close();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getUri().toString(), getTargetUrl());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/IdleStateHandlerTest.java b/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
similarity index 95%
rename from api/src/test/java/com/ning/http/client/async/IdleStateHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
index 2ccd40e2d..f42b23446 100644
--- a/api/src/test/java/com/ning/http/client/async/IdleStateHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
@@ -13,10 +13,10 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
diff --git a/api/src/test/java/com/ning/http/client/async/InputStreamTest.java b/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
similarity index 57%
rename from api/src/test/java/com/ning/http/client/async/InputStreamTest.java
rename to api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
index 70ceb4b48..95d28480a 100644
--- a/api/src/test/java/com/ning/http/client/async/InputStreamTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -36,10 +36,7 @@
 public abstract class InputStreamTest extends AbstractBasicTest {
 
     private class InputStreamHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
                 byte[] b = new byte[3];
                 request.getInputStream().read(b, 0, 3);
@@ -54,43 +51,46 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-        InputStream is = new InputStream() {
+            InputStream is = new InputStream() {
 
-            public int readAllowed;
+                public int readAllowed;
 
-            @Override
-            public int available() {
-                return 1; // Fake
-            }
-
-            @Override
-            public int read() throws IOException {
-                int fakeCount = readAllowed++;
-                if (fakeCount == 0) {
-                    return (int) 'a';
-                } else if (fakeCount == 1) {
-                    return (int) 'b';
-                } else if (fakeCount == 2) {
-                    return (int) 'c';
-                } else {
-                    return -1;
+                @Override
+                public int available() {
+                    return 1; // Fake
                 }
 
-            }
-        };
+                @Override
+                public int read() throws IOException {
+                    int fakeCount = readAllowed++;
+                    if (fakeCount == 0) {
+                        return (int) 'a';
+                    } else if (fakeCount == 1) {
+                        return (int) 'b';
+                    } else if (fakeCount == 2) {
+                        return (int) 'c';
+                    } else {
+                        return -1;
+                    }
 
-        Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("X-Param"), "abc");
-        c.close();
+                }
+            };
+
+            Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), "abc");
+        } finally {
+            c.close();
+        }
     }
 
     @Override
diff --git a/api/src/test/java/com/ning/http/client/async/ListenableFutureTest.java b/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
similarity index 55%
rename from api/src/test/java/com/ning/http/client/async/ListenableFutureTest.java
rename to api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
index 6de42566a..9f9f9ef5f 100644
--- a/api/src/test/java/com/ning/http/client/async/ListenableFutureTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
@@ -27,28 +27,31 @@
 
 public abstract class ListenableFutureTest extends AbstractBasicTest {
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testListenableFuture() throws Throwable {
         final AtomicInteger statusCode = new AtomicInteger(500);
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final CountDownLatch latch = new CountDownLatch(1);
-        final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-        future.addListener(new Runnable(){
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+            future.addListener(new Runnable() {
 
-            public void run() {
-                try {
-                    statusCode.set(future.get().getStatusCode());
-                    latch.countDown();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                } catch (ExecutionException e) {
-                    e.printStackTrace();
+                public void run() {
+                    try {
+                        statusCode.set(future.get().getStatusCode());
+                        latch.countDown();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    } catch (ExecutionException e) {
+                        e.printStackTrace();
+                    }
                 }
-            }
-        }, Executors.newFixedThreadPool(1));
+            }, Executors.newFixedThreadPool(1));
 
-        latch.await(10, TimeUnit.SECONDS);
-        assertEquals(statusCode.get(), 200);
-        ahc.close();
+            latch.await(10, TimeUnit.SECONDS);
+            assertEquals(statusCode.get(), 200);
+        } finally {
+            ahc.close();
+        }
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java b/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
similarity index 58%
rename from api/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java
rename to api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
index d0dd9ea34..5ac600592 100644
--- a/api/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java
+++ b/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
@@ -14,10 +14,10 @@
  * under the License.
  *
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.nio.SelectChannelConnector;
@@ -43,96 +43,82 @@
 
     private static URI servletEndpointUri;
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testMaxConnectionsWithinThreads() {
 
-        String[] urls = new String[]{
-                servletEndpointUri.toString(),
-                servletEndpointUri.toString()};
-
-
-        final AsyncHttpClient client =
-               getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build());
-
-
-        final Boolean[] caughtError = new Boolean[]{Boolean.FALSE};
-        List<Thread> ts = new ArrayList<Thread>();
-        for (int i = 0; i < urls.length; i++) {
-            final String url = urls[i];
-            Thread t = new Thread() {
-                public void run() {
-                    try {
-                        client.prepareGet(url).execute();
-                    } catch (IOException e) {
-                        // assert that 2nd request fails, because maxTotalConnections=1
-                        //            		System.out.println(i);
-                        caughtError[0] = true;
-                        System.err.println("============");
-                        e.printStackTrace();
-                        System.err.println("============");
+        String[] urls = new String[] { servletEndpointUri.toString(), servletEndpointUri.toString() };
 
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+
+        try {
+            final Boolean[] caughtError = new Boolean[] { Boolean.FALSE };
+            List<Thread> ts = new ArrayList<Thread>();
+            for (int i = 0; i < urls.length; i++) {
+                final String url = urls[i];
+                Thread t = new Thread() {
+                    public void run() {
+                        try {
+                            client.prepareGet(url).execute();
+                        } catch (IOException e) {
+                            // assert that 2nd request fails, because maxTotalConnections=1
+                            // System.out.println(i);
+                            caughtError[0] = true;
+                            System.err.println("============");
+                            e.printStackTrace();
+                            System.err.println("============");
+
+                        }
                     }
+                };
+                t.start();
+                ts.add(t);
+            }
+
+            for (Thread t : ts) {
+                try {
+                    t.join();
+                } catch (InterruptedException e) {
+                    // TODO Auto-generated catch block
+                    e.printStackTrace();
                 }
-            };
-            t.start();
-            ts.add(t);
-        }
+            }
 
-        for (Thread t : ts) {
+            // Let the threads finish
             try {
-                t.join();
-            } catch (InterruptedException e) {
+                Thread.sleep(4500);
+            } catch (InterruptedException e1) {
                 // TODO Auto-generated catch block
-                e.printStackTrace();
+                e1.printStackTrace();
             }
-        }
-
-
-        // Let the threads finish
-        try {
-            Thread.sleep(4500);
-        } catch (InterruptedException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        }
-
-        assertTrue("Max Connections should have been reached", caughtError[0]);
-
 
-        boolean errorInNotThread = false;
-        for (int i = 0; i < urls.length; i++) {
-            final String url = urls[i];
+            assertTrue("Max Connections should have been reached", caughtError[0]);
+
+            boolean errorInNotThread = false;
+            for (int i = 0; i < urls.length; i++) {
+                final String url = urls[i];
+                try {
+                    client.prepareGet(url).execute();
+                    // client.prepareGet(url).execute();
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    // System.out.println(i);
+                    errorInNotThread = true;
+                    System.err.println("============");
+                    e.printStackTrace();
+                    System.err.println("============");
+                }
+            }
+            // Let the request finish
             try {
-                client.prepareGet(url).execute();
-                // client.prepareGet(url).execute();
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                // System.out.println(i);
-                errorInNotThread = true;
-                System.err.println("============");
-                e.printStackTrace();
-                System.err.println("============");
+                Thread.sleep(2500);
+            } catch (InterruptedException e1) {
+                // TODO Auto-generated catch block
+                e1.printStackTrace();
             }
+            assertTrue("Max Connections should have been reached", errorInNotThread);
+        } finally {
+            client.close();
         }
-        // Let the request finish
-        try {
-            Thread.sleep(2500);
-        } catch (InterruptedException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        }
-        assertTrue("Max Connections should have been reached", errorInNotThread);
-
-
-        client.close();
-
-
     }
 
     @Override
@@ -149,7 +135,6 @@ public void setUpGlobal() throws Exception {
 
         server.addConnector(listener);
 
-
         ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
 
         context.setContextPath("/");
@@ -186,8 +171,7 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
             try {
                 sleepTime = Integer.parseInt(req.getParameter("timeout"));
 
-            }
-            catch (NumberFormatException e) {
+            } catch (NumberFormatException e) {
                 sleepTime = DEFAULT_TIMEOUT;
             }
 
@@ -201,8 +185,7 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
                 System.out.println("Servlet is awake for");
                 System.out.println("=======================================");
                 System.out.flush();
-            }
-            catch (Exception e) {
+            } catch (Exception e) {
 
             }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java b/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
new file mode 100644
index 000000000..947d36c55
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+public abstract class MaxTotalConnectionTest extends AbstractBasicTest {
+    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMaxTotalConnectionsExceedingException() {
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        try {
+            boolean caughtError = false;
+            for (int i = 0; i < urls.length; i++) {
+                try {
+                    client.prepareGet(urls[i]).execute();
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    Assert.assertEquals(1, i);
+                    caughtError = true;
+                }
+            }
+            Assert.assertTrue(caughtError);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test
+    public void testMaxTotalConnections() {
+        String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(2).setMaximumConnectionsPerHost(1).build());
+        try {
+            for (String url : urls) {
+                try {
+                    client.prepareGet(url).execute();
+                } catch (IOException e) {
+                    Assert.fail("Smth wrong with connections handling!");
+                }
+            }
+        } finally {
+            client.close();
+        }
+    }
+
+    /**
+     * JFA: Disable this test for 1.2.0 release as it can easily fail because a request may complete before the second one is made, hence failing. The issue occurs frequently on Linux.
+     */
+    @Test(enabled = false)
+    public void testMaxTotalConnectionsCorrectExceptionHandling() {
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        try {
+            List<Future<Response>> futures = new ArrayList<Future<Response>>();
+            boolean caughtError = false;
+            for (int i = 0; i < urls.length; i++) {
+                try {
+                    Future<Response> future = client.prepareGet(urls[i]).execute();
+                    if (future != null) {
+                        futures.add(future);
+                    }
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    Assert.assertEquals(i, 1);
+                    caughtError = true;
+                }
+            }
+            Assert.assertTrue(caughtError);
+
+            // get results of executed requests
+            for (Future<Response> future : futures) {
+                try {
+                    /* Response res = */future.get();
+                } catch (InterruptedException e) {
+                    log.error("Error!", e);
+                } catch (ExecutionException e) {
+                    log.error("Error!", e);
+                }
+            }
+
+            // try to execute once again, expecting that 1 connection is released
+            caughtError = false;
+            for (int i = 0; i < urls.length; i++) {
+                try {
+                    client.prepareGet(urls[i]).execute();
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    Assert.assertEquals(i, 1);
+                    caughtError = true;
+                }
+            }
+            Assert.assertTrue(caughtError);
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/MultipartUploadTest.java b/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
similarity index 91%
rename from api/src/test/java/com/ning/http/client/async/MultipartUploadTest.java
rename to api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
index 70af4c875..2b7cc355b 100644
--- a/api/src/test/java/com/ning/http/client/async/MultipartUploadTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
@@ -10,16 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ByteArrayPart;
-import com.ning.http.client.FilePart;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.StringPart;
-import com.ning.http.util.AsyncHttpProviderUtils;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ByteArrayPart;
+import org.asynchttpclient.FilePart;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.StringPart;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 import org.apache.commons.fileupload.FileItemIterator;
 import org.apache.commons.fileupload.FileItemStream;
 import org.apache.commons.fileupload.FileUploadException;
@@ -68,7 +69,7 @@
  */
 public abstract class MultipartUploadTest extends AbstractBasicTest {
     private String servletEndpointRedirectUrl;
-    public static byte GZIPTEXT[] = new byte[]{31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48, 58, 54, 6, 0, 0, 0};
+    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48, 58, 54, 6, 0, 0, 0 };
 
     @BeforeClass
     public void setUp() throws Exception {
@@ -128,7 +129,7 @@ private File getClasspathFile(String file) throws FileNotFoundException {
     /**
      * Tests that the streaming of a file works.
      */
-    @Test (enabled = true)
+    @Test(enabled = true)
     public void testSendingSmallFilesAndByteArray() {
         String expectedContents = "filecontent: hello";
         String expectedContents2 = "gzipcontent: hello";
@@ -153,7 +154,6 @@ public void testSendingSmallFilesAndByteArray() {
             fail("unable to find " + testResource2);
         }
 
-
         File testResource3File = null;
         try {
             testResource3File = getClasspathFile(testResource3);
@@ -177,7 +177,6 @@ public void testSendingSmallFilesAndByteArray() {
         gzipped.add(true);
         gzipped.add(false);
 
-
         boolean tmpFileCreated = false;
         File tmpFile = null;
         FileOutputStream os = null;
@@ -191,7 +190,6 @@ public void testSendingSmallFilesAndByteArray() {
             expected.add(expectedContents);
             gzipped.add(false);
 
-
         } catch (FileNotFoundException e1) {
             // TODO Auto-generated catch block
             e1.printStackTrace();
@@ -208,13 +206,10 @@ public void testSendingSmallFilesAndByteArray() {
             fail("Unable to test ByteArrayMultiPart, as unable to write to filesystem the tmp test content");
         }
 
-
-        AsyncHttpClientConfig.Builder bc =
-                new AsyncHttpClientConfig.Builder();
+        AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
 
         bc.setFollowRedirects(true);
 
-
         AsyncHttpClient c = new AsyncHttpClient(bc.build());
 
         try {
@@ -230,10 +225,9 @@ public void testSendingSmallFilesAndByteArray() {
             builder.addBodyPart(new StringPart("Height", "shrimplike", AsyncHttpProviderUtils.DEFAULT_CHARSET));
             builder.addBodyPart(new StringPart("Hair", "ridiculous", AsyncHttpProviderUtils.DEFAULT_CHARSET));
 
-            builder.addBodyPart(new ByteArrayPart("file4", "bytearray.txt", expectedContents.getBytes("UTF-8") ,"text/plain", "UTF-8"));
-
+            builder.addBodyPart(new ByteArrayPart("file4", "bytearray.txt", expectedContents.getBytes("UTF-8"), "text/plain", "UTF-8"));
 
-            com.ning.http.client.Request r = builder.build();
+            Request r = builder.build();
 
             Response res = c.executeRequest(r).get();
 
@@ -246,21 +240,20 @@ public void testSendingSmallFilesAndByteArray() {
             e.printStackTrace();
             fail("Download Exception");
         } finally {
+            c.close();
             FileUtils.deleteQuietly(tmpFile);
         }
     }
 
-
     /**
      * Test that the files were sent, based on the response from the servlet
-     *
+     * 
      * @param expectedContents
      * @param sourceFiles
      * @param r
      * @param deflate
      */
-    private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
-                              Response r, List<Boolean> deflate) {
+    private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r, List<Boolean> deflate) {
         String content = null;
         try {
             content = r.getResponseBody();
@@ -281,11 +274,10 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
 
         String[] responseFiles = tmpFiles.split(",");
         assertNotNull(responseFiles);
-        assertEquals( sourceFiles.size(), responseFiles.length);
-
+        assertEquals(sourceFiles.size(), responseFiles.length);
 
         System.out.println(Arrays.toString(responseFiles));
-        //assertTrue("File should exist: " + tmpFile.getAbsolutePath(),tmpFile.exists());
+        // assertTrue("File should exist: " + tmpFile.getAbsolutePath(),tmpFile.exists());
 
         int i = 0;
         for (File sourceFile : sourceFiles) {
@@ -313,7 +305,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                     IOUtils.closeQuietly(instream);
                 }
 
-
                 tmp = new File(responseFiles[i].trim());
                 System.out.println("==============================");
                 System.out.println(tmp.getAbsolutePath());
@@ -321,7 +312,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 System.out.flush();
                 assertTrue(tmp.exists());
 
-
                 instream = new FileInputStream(tmp);
                 ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
                 byte[] buf = new byte[8092];
@@ -357,7 +347,8 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 e.printStackTrace();
                 fail("Download Exception");
             } finally {
-                if (tmp != null) FileUtils.deleteQuietly(tmp);
+                if (tmp != null)
+                    FileUtils.deleteQuietly(tmp);
                 IOUtils.closeQuietly(instream);
                 i++;
             }
@@ -366,7 +357,7 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
 
     /**
      * Takes the content that is being passed to it, and streams to a file on disk
-     *
+     * 
      * @author dominict
      */
     public static class MockMultipartUploadServlet extends HttpServlet {
@@ -377,7 +368,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
         private int filesProcessed = 0;
         private int stringsProcessed = 0;
 
-
         public MockMultipartUploadServlet() {
 
         }
@@ -409,8 +399,7 @@ public int getStringsProcessed() {
         }
 
         @Override
-        public void service(HttpServletRequest request, HttpServletResponse response)
-                throws ServletException, IOException {
+        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             // Check that we have a file upload request
             boolean isMultipart = ServletFileUpload.isMultipartContent(request);
             if (isMultipart) {
@@ -428,12 +417,10 @@ public void service(HttpServletRequest request, HttpServletResponse response)
                             stream = item.openStream();
 
                             if (item.isFormField()) {
-                                System.out.println("Form field " + name + " with value "
-                                        + Streams.asString(stream) + " detected.");
+                                System.out.println("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
                                 incrementStringsProcessed();
                             } else {
-                                System.out.println("File field " + name + " with file name "
-                                        + item.getName() + " detected.");
+                                System.out.println("File field " + name + " with file name " + item.getName() + " detected.");
                                 // Process the input stream
                                 OutputStream os = null;
                                 try {
@@ -478,5 +465,4 @@ public void service(HttpServletRequest request, HttpServletResponse response)
 
     }
 
-
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java b/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
new file mode 100644
index 000000000..2ea4d395a
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * @author Hubert Iwaniuk
+ */
+public abstract class MultipleHeaderTest extends AbstractBasicTest {
+    private ExecutorService executorService;
+    private ServerSocket serverSocket;
+    private Future<?> voidFuture;
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] xffHeaders = new String[] { null, null };
+
+        AsyncHttpClient ahc = getAsyncHttpClient(null);
+        try {
+            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                    int i = 0;
+                    for (String header : response.getHeaders().get("X-Forwarded-For")) {
+                        xffHeaders[i++] = header;
+                    }
+                    latch.countDown();
+                    return STATE.CONTINUE;
+                }
+
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
+
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Time out");
+            }
+            Assert.assertNotNull(xffHeaders[0]);
+            Assert.assertNotNull(xffHeaders[1]);
+            try {
+                Assert.assertEquals(xffHeaders[0], "abc");
+                Assert.assertEquals(xffHeaders[1], "def");
+            } catch (AssertionError ex) {
+                Assert.assertEquals(xffHeaders[1], "abc");
+                Assert.assertEquals(xffHeaders[0], "def");
+            }
+        } finally {
+            ahc.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] clHeaders = new String[] { null, null };
+
+        AsyncHttpClient ahc = getAsyncHttpClient(null);
+        try {
+            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                    try {
+                        int i = 0;
+                        for (String header : response.getHeaders().get("Content-Length")) {
+                            clHeaders[i++] = header;
+                        }
+                    } finally {
+                        latch.countDown();
+                    }
+                    return STATE.CONTINUE;
+                }
+
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
+
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Time out");
+            }
+            Assert.assertNotNull(clHeaders[0]);
+            Assert.assertNotNull(clHeaders[1]);
+
+            // We can predict the order
+            try {
+                Assert.assertEquals(clHeaders[0], "2");
+                Assert.assertEquals(clHeaders[1], "1");
+            } catch (Throwable ex) {
+                Assert.assertEquals(clHeaders[0], "1");
+                Assert.assertEquals(clHeaders[1], "2");
+            }
+        } finally {
+            ahc.close();
+        }
+    }
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        port1 = findFreePort();
+
+        serverSocket = new ServerSocket(port1);
+        executorService = Executors.newFixedThreadPool(1);
+        voidFuture = executorService.submit(new Callable<Void>() {
+            public Void call() throws Exception {
+                Socket socket;
+                while ((socket = serverSocket.accept()) != null) {
+                    InputStream inputStream = socket.getInputStream();
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+                    String req = reader.readLine().split(" ")[1];
+                    int i = inputStream.available();
+                    long l = inputStream.skip(i);
+                    Assert.assertEquals(l, i);
+                    socket.shutdownInput();
+                    if (req.endsWith("MultiEnt")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n" + "Content-Length: 1\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    } else if (req.endsWith("MultiOther")) {
+                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n" + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
+                        outputStreamWriter.flush();
+                        socket.shutdownOutput();
+                    }
+                }
+                return null;
+            }
+        });
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws Exception {
+        voidFuture.cancel(true);
+        executorService.shutdownNow();
+        serverSocket.close();
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/NoNullResponseTest.java b/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
similarity index 54%
rename from api/src/test/java/com/ning/http/client/async/NoNullResponseTest.java
rename to api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
index cc9f0890e..779373891 100644
--- a/api/src/test/java/com/ning/http/client/async/NoNullResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright 2010-2013 Ning, Inc.
  *
  * Ning licenses this file to you under the Apache License, version 2.0
  * (the "License"); you may not use this file except in compliance with the
@@ -14,12 +14,12 @@
  * under the License.
  *
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
@@ -31,52 +31,47 @@
 import java.security.cert.X509Certificate;
 
 public abstract class NoNullResponseTest extends AbstractBasicTest {
-    private static final String VERISIGN_HTTPS_URL = "https://www.verisign.com";
+    private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
 
-    @Test(invocationCount = 4, groups = {"online", "default_provider"})
+    @Test(invocationCount = 4, groups = { "online", "default_provider" })
     public void multipleSslRequestsWithDelayAndKeepAlive() throws Throwable {
         final AsyncHttpClient client = create();
-        final BoundRequestBuilder builder = client.prepareGet(VERISIGN_HTTPS_URL);
-        final Response response1 = builder.execute().get();
-        Thread.sleep(5000);
-        final Response response2 = builder.execute().get();
-        if (response2 != null) {
-            System.out.println("Success (2nd response was not null).");
-        } else {
-            System.out.println("Failed (2nd response was null).");
+        try {
+            final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
+            final Response response1 = builder.execute().get();
+            Thread.sleep(5000);
+            final Response response2 = builder.execute().get();
+            if (response2 != null) {
+                System.out.println("Success (2nd response was not null).");
+            } else {
+                System.out.println("Failed (2nd response was null).");
+            }
+            Assert.assertNotNull(response1);
+            Assert.assertNotNull(response2);
+        } finally {
+            client.close();
         }
-        Assert.assertNotNull(response1);
-        Assert.assertNotNull(response2);
-        client.close();
     }
 
     private AsyncHttpClient create() throws GeneralSecurityException {
-        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder()
-                .setCompressionEnabled(true)
-                .setFollowRedirects(true)
-                .setSSLContext(getSSLContext())
-                .setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(10000)
-                .setIdleConnectionInPoolTimeoutInMs(60000)
-                .setRequestTimeoutInMs(10000)
-                .setMaximumConnectionsPerHost(-1)
-                .setMaximumConnectionsTotal(-1);
+        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setFollowRedirects(true).setSSLContext(getSSLContext()).setAllowPoolingConnection(true).setConnectionTimeoutInMs(10000)
+                .setIdleConnectionInPoolTimeoutInMs(60000).setRequestTimeoutInMs(10000).setMaximumConnectionsPerHost(-1).setMaximumConnectionsTotal(-1);
         return getAsyncHttpClient(configBuilder.build());
     }
 
     private SSLContext getSSLContext() throws GeneralSecurityException {
         final SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, new TrustManager[]{new MockTrustManager()}, null);
+        sslContext.init(null, new TrustManager[] { new MockTrustManager() }, null);
         return sslContext;
     }
 
     private static class MockTrustManager implements X509TrustManager {
         public X509Certificate[] getAcceptedIssuers() {
-            throw new UnsupportedOperationException();
+            return null;
         }
 
         public void checkClientTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
-            throw new UnsupportedOperationException();
+            // do nothing.
         }
 
         public void checkServerTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
diff --git a/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java b/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
new file mode 100644
index 000000000..924a9c90f
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import static org.testng.Assert.assertEquals;
+
+public abstract class NonAsciiContentLengthTest extends AbstractBasicTest {
+
+    public void setUpServer() throws Exception {
+        server = new Server();
+        port1 = findFreePort();
+        Connector listener = new SelectChannelConnector();
+
+        listener.setHost("127.0.0.1");
+        listener.setPort(port1);
+        server.addConnector(listener);
+        server.setHandler(new AbstractHandler() {
+
+            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
+                byte[] b = new byte[MAX_BODY_SIZE];
+                int offset = 0;
+                int numBytesRead;
+                ServletInputStream is = request.getInputStream();
+                try {
+                    while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
+                        offset += numBytesRead;
+                    }
+                } finally {
+                    is.close();
+                }
+                assertEquals(request.getContentLength(), offset);
+                response.setStatus(200);
+                response.setCharacterEncoding(request.getCharacterEncoding());
+                response.setContentLength(request.getContentLength());
+                ServletOutputStream os = response.getOutputStream();
+                try {
+                    os.write(b, 0, offset);
+                } finally {
+                    os.close();
+                }
+            }
+        });
+        server.start();
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testNonAsciiContentLength() throws Exception {
+        setUpServer();
+        execute("test");
+        execute("\u4E00"); // Unicode CJK ideograph for one
+    }
+
+    protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding("UTF-8");
+            Future<Response> f = r.execute();
+            Response resp = f.get();
+            assertEquals(resp.getStatusCode(), 200);
+            assertEquals(body, resp.getResponseBody("UTF-8"));
+        } finally {
+            client.close();
+        }
+    }
+
+}
diff --git a/api/src/test/java/com/ning/http/client/async/ParamEncodingTest.java b/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
similarity index 73%
rename from api/src/test/java/com/ning/http/client/async/ParamEncodingTest.java
rename to api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
index 02af3160e..6fcf4f8c0 100644
--- a/api/src/test/java/com/ning/http/client/async/ParamEncodingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
@@ -13,10 +13,10 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -30,19 +30,17 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 public abstract class ParamEncodingTest extends AbstractBasicTest {
 
     private class ParamEncoding extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
                 String p = request.getParameter("test");
-                if (p != null && !p.equals("")) {
+                if (isNonEmpty(p)) {
                     response.setStatus(HttpServletResponse.SC_OK);
                     response.addHeader("X-Param", p);
                 } else {
@@ -56,20 +54,20 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .preparePost("http://127.0.0.1:" + port1)
-                .addParameter("test", value)
-                .execute();
-        Response resp = f.get(10, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("X-Param"), value.trim());
-        client.close();
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addParameter("test", value).execute();
+            Response resp = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), value.trim());
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/api/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java b/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
similarity index 61%
rename from api/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java
rename to api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
index 756a25833..6ca782abe 100644
--- a/api/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -89,46 +85,38 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void redirected302Test() throws Throwable {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
 
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setFollowRedirects(true)
-                .setHeader("X-redirect", "http://www.microsoft.com/")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-
-        String anyMicrosoftPage = "http://www.microsoft.com[^:]*:80";
-        String baseUrl = getBaseUrl(response.getUri());
-        
-        c.close();
-        
-        assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+            String anyMicrosoftPage = "http://www.microsoft.com[^:]*:80";
+            String baseUrl = getBaseUrl(response.getUri());
+
+            assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void notRedirected302Test() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
 
-
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setFollowRedirects(false)
-                .setHeader("X-redirect", "http://www.microsoft.com/")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-
-        c.close();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
     }
 
     private String getBaseUrl(URI uri) {
@@ -148,41 +136,35 @@ private static int getPort(URI uri) {
         return port;
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirected302InvalidTest() throws Throwable {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
+        AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .setFollowRedirects(true)
-                    .setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2))
-                    .execute().get();
+            // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativeLocationUrl() throws Throwable {
         isSet.getAndSet(false);
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.preparePost(getTargetUrl())
-                .setFollowRedirects(true)
-                .setHeader("X-redirect", "/foo/test")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        assertEquals(response.getUri().toString(), getTargetUrl());
-        c.close();
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getUri().toString(), getTargetUrl());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java b/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
similarity index 62%
rename from api/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java
rename to api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
index e50bee78d..c98749bb4 100644
--- a/api/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
@@ -1,26 +1,26 @@
 /*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License. You may obtain a copy of the License at:
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
-package com.ning.http.client.async;
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.Response;
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
@@ -44,15 +44,13 @@
 
 /**
  * Per request timeout configuration test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class PerRequestTimeoutTest extends AbstractBasicTest {
     private static final String MSG = "Enough is enough.";
 
-    protected String getExpectedTimeoutMessage() {
-        return "No response received after 100";
-    }
+    protected abstract void checkTimeoutMessage(String message);
 
     @Override
     public AbstractHandler configureHandler() throws Exception {
@@ -95,101 +93,95 @@ public void run() {
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testRequestTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        PerRequestConfig requestConfig = new PerRequestConfig();
-        requestConfig.setRequestTimeoutInMs(100);
-        Future<Response> responseFuture =
-                client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(100).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
-            client.close();
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
             assertTrue(e.getCause() instanceof TimeoutException);
-            assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
+            checkTimeoutMessage(e.getCause().getMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
-        PerRequestConfig requestConfig = new PerRequestConfig();
-        requestConfig.setRequestTimeoutInMs(-1);
-        Future<Response> responseFuture =
-                client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(-1).execute();
             Response response = responseFuture.get();
             assertNotNull(response);
-            client.close();
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
             assertTrue(e.getCause() instanceof TimeoutException);
-            assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
+            checkTimeoutMessage(e.getCause().getMessage());
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalRequestTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
-        Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
-            client.close();
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
             assertTrue(e.getCause() instanceof TimeoutException);
-            assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
+            checkTimeoutMessage(e.getCause().getMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalIdleTimeout() throws IOException {
-        final long times[] = new long[]{-1, -1};
+        final long times[] = new long[] { -1, -1 };
 
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).build());
-        Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
+        try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                times[0] = System.currentTimeMillis();
-                return super.onBodyPartReceived(content);
-            }
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    times[0] = millisTime();
+                    return super.onBodyPartReceived(content);
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                times[1] = System.currentTimeMillis();
-                super.onThrowable(t);
-            }
-        });
-        try {
+                @Override
+                public void onThrowable(Throwable t) {
+                    times[1] = millisTime();
+                    super.onThrowable(t);
+                }
+            });
             Response response = responseFuture.get();
             assertNotNull(response);
             assertEquals(response.getResponseBody(), MSG + MSG);
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
-            log.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.",
-                    times[0], times[1], (times[1] - times[0])));
+            log.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
             fail("Timeouted on idle.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 }
diff --git a/api/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java b/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
similarity index 54%
rename from api/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java
rename to api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
index 9bfac1ff5..e741a6240 100644
--- a/api/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
@@ -11,17 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.ResponseFilter;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -35,10 +35,8 @@
 
 public abstract class PostRedirectGetTest extends AbstractBasicTest {
 
-
     // ------------------------------------------------------ Test Configuration
 
-
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new PostRedirectGetHandler();
@@ -46,123 +44,111 @@ public AbstractHandler configureHandler() throws Exception {
 
     // ------------------------------------------------------------ Test Methods
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet302Test() throws Exception {
         doTestPositive(302);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet302StrictTest() throws Exception {
         doTestNegative(302, true);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet303Test() throws Exception {
         doTestPositive(303);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet301Test() throws Exception {
         doTestNegative(301, false);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet307Test() throws Exception {
         doTestNegative(307, false);
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private void doTestNegative(final int status, boolean strict) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).
-                setStrict302Handling(strict).
-                addResponseFilter(new ResponseFilter() {
-                    @Override
-                    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                        // pass on the x-expect-get and remove the x-redirect
-                        // headers if found in the response
-                        ctx.getResponseHeaders().getHeaders().get("x-expect-post");
-                        ctx.getRequest().getHeaders().add("x-expect-post", "true");
-                        ctx.getRequest().getHeaders().remove("x-redirect");
-                        return ctx;
-                    }
-                }).build());
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl())
-                .addParameter("q", "a b")
-                .addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz")
-                .addHeader("x-negative", "true")
-                .build();
-        Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
             @Override
-            public Integer onCompleted(Response response) throws Exception {
-                return response.getStatusCode();
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().getHeaders().get("x-expect-post");
+                ctx.getRequest().getHeaders().add("x-expect-post", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
             }
+        }).build());
+        try {
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        int statusCode = responseFuture.get();
-        Assert.assertEquals(statusCode, 200);
-        p.close();
+            });
+            int statusCode = responseFuture.get();
+            Assert.assertEquals(statusCode, 200);
+        } finally {
+            p.close();
+        }
     }
 
-
     private void doTestPositive(final int status) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).
-                addResponseFilter(new ResponseFilter() {
-                    @Override
-                    public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-                        // pass on the x-expect-get and remove the x-redirect
-                        // headers if found in the response
-                        ctx.getResponseHeaders().getHeaders().get("x-expect-get");
-                        ctx.getRequest().getHeaders().add("x-expect-get", "true");
-                        ctx.getRequest().getHeaders().remove("x-redirect");
-                        return ctx;
-                    }
-                }).build());
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl())
-                .addParameter("q", "a b")
-                .addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz")
-                .build();
-        Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).addResponseFilter(new ResponseFilter() {
             @Override
-            public Integer onCompleted(Response response) throws Exception {
-                return response.getStatusCode();
+            public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().getHeaders().get("x-expect-get");
+                ctx.getRequest().getHeaders().add("x-expect-get", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
             }
+        }).build());
+        try {
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        int statusCode = responseFuture.get();
-        Assert.assertEquals(statusCode, 200);
-        p.close();
+            });
+            int statusCode = responseFuture.get();
+            Assert.assertEquals(statusCode, 200);
+        } finally {
+            p.close();
+        }
     }
 
-
     // ---------------------------------------------------------- Nested Classes
 
-
     public static class PostRedirectGetHandler extends AbstractHandler {
 
         final AtomicInteger counter = new AtomicInteger();
 
         /* @Override */
-        public void handle(String pathInContext,
-                           org.eclipse.jetty.server.Request request,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
             final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
@@ -212,7 +198,6 @@ public void handle(String pathInContext,
                 return;
             }
 
-
             httpResponse.sendError(500);
             httpResponse.getOutputStream().flush();
             httpResponse.getOutputStream().close();
diff --git a/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java b/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
new file mode 100644
index 000000000..442f38908
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+/**
+ * Tests POST request with Query String.
+ * 
+ * @author Hubert Iwaniuk
+ */
+public abstract class PostWithQSTest extends AbstractBasicTest {
+
+    /**
+     * POST with QS server part.
+     */
+    private class PostWithQSHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if ("POST".equalsIgnoreCase(request.getMethod())) {
+                String qs = request.getQueryString();
+                if (isNonEmpty(qs) && request.getContentLength() == 3) {
+                    ServletInputStream is = request.getInputStream();
+                    response.setStatus(HttpServletResponse.SC_OK);
+                    byte buf[] = new byte[is.available()];
+                    is.readLine(buf, 0, is.available());
+                    ServletOutputStream os = response.getOutputStream();
+                    os.println(new String(buf));
+                    os.flush();
+                    os.close();
+                } else {
+                    response.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
+                }
+            } else { // this handler is to handle POST request
+                response.sendError(HttpServletResponse.SC_FORBIDDEN);
+            }
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                /* @Override */
+                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=")) {
+                        throw new IOException(status.getUrl().toURL().toString());
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                /* @Override */
+                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
+                        throw new IOException("failed to parse the query properly");
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+
+                /* @Override */
+                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
+                        throw new IOException("failed to parse the query properly");
+                    }
+                    return super.onStatusReceived(status);
+                }
+
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new PostWithQSHandler();
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/ProxyTest.java b/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
similarity index 55%
rename from api/src/test/java/com/ning/http/client/async/ProxyTest.java
rename to api/src/test/java/org/asynchttpclient/async/ProxyTest.java
index 4129a4a72..94ee870f8 100644
--- a/api/src/test/java/com/ning/http/client/async/ProxyTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
@@ -13,14 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
 import static org.testng.Assert.*;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Response;
 
 import java.io.IOException;
 import java.net.ConnectException;
@@ -40,15 +40,12 @@
 
 /**
  * Proxy usage tests.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class ProxyTest extends AbstractBasicTest {
     private class ProxyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 response.addHeader("target", r.getUri().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
@@ -64,73 +61,83 @@ public AbstractHandler configureHandler() throws Exception {
         return new ProxyHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .setProxyServer(new ProxyServer("127.0.0.1", port1))
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .setProxyServer(new ProxyServer("127.0.0.1", port1))
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
         try {
 
             String target = "http://127.0.0.1:1234/";
-            client.prepareGet(target)
-                    .setProxyServer(new ProxyServer("127.0.0.1", port1).addNonProxyHost("127.0.0.1"))
-                    .execute().get();
+            client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1).addNonProxyHost("127.0.0.1")).execute().get();
             assertFalse(true);
         } catch (Throwable e) {
             assertNotNull(e.getCause());
             assertEquals(e.getCause().getClass(), ConnectException.class);
+        } finally {
+            client.close();
         }
+    }
 
-        client.close();
+    @Test(groups = { "standalone", "default_provider" })
+    public void testNonProxyHostIssue202() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            String target = "http://127.0.0.1:" + port1 + "/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1 - 1).addNonProxyHost("127.0.0.1")).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -148,29 +155,30 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
 
             AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
             AsyncHttpClient client = getAsyncHttpClient(cfg);
-
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
             try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                Response resp = f.get(3, TimeUnit.SECONDS);
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getHeader("target"), "/");
+
+                target = "http://localhost:1234/";
+                f = client.prepareGet(target).execute();
+                try {
+                    resp = f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+            } finally {
+                client.close();
             }
-            
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
@@ -184,24 +192,24 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
             System.setProperty("http.proxyPort", String.valueOf(port1));
             System.setProperty("http.nonProxyHosts", "localhost");
 
-            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().build();
-            AsyncHttpClient client = getAsyncHttpClient(cfg);
-
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            AsyncHttpClient client = getAsyncHttpClient(null);
             try {
-                f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                try {
+                    f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+            } finally {
+                client.close();
             }
-
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
@@ -214,31 +222,31 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
             System.setProperty("http.proxyHost", "127.0.0.1");
             System.setProperty("http.proxyPort", String.valueOf(port1));
             System.setProperty("http.nonProxyHosts", "localhost");
-            System.setProperty("com.ning.http.client.AsyncHttpClientConfig.useProxyProperties", "true");
-
-            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().build();
-            AsyncHttpClient client = getAsyncHttpClient(cfg);
+            System.setProperty("org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties", "true");
 
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            AsyncHttpClient client = getAsyncHttpClient(null);
             try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                Response resp = f.get(3, TimeUnit.SECONDS);
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getHeader("target"), "/");
+
+                target = "http://localhost:1234/";
+                f = client.prepareGet(target).execute();
+                try {
+                    resp = f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+            } finally {
+                client.close();
             }
-            
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
+
 }
diff --git a/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java b/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
similarity index 60%
rename from api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java
rename to api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
index a207828ce..61a2bc551 100644
--- a/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
@@ -10,15 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.SimpleAsyncHttpClient;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SimpleAsyncHttpClient;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -86,7 +86,7 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.setFollowRedirects(true);
@@ -95,28 +95,29 @@ public void testRequestProxy() throws IOException, InterruptedException, Executi
 
         AsyncHttpClientConfig config = b.build();
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-
-        RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
-        Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                log.debug(t.getMessage(), t);
-            }
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response r = responseFuture.get();
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        asyncHttpClient.close();
+        try {
+            RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
+            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    log.debug(t.getMessage(), t);
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response r = responseFuture.get();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            asyncHttpClient.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.setFollowRedirects(true);
@@ -126,44 +127,39 @@ public void testConfigProxy() throws IOException, InterruptedException, Executio
 
         AsyncHttpClientConfig config = b.build();
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-
-        RequestBuilder rb = new RequestBuilder("GET").setUrl(getTargetUrl2());
-        Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                log.debug(t.getMessage(), t);
-            }
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response r = responseFuture.get();
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        asyncHttpClient.close();
+        try {
+            RequestBuilder rb = new RequestBuilder("GET").setUrl(getTargetUrl2());
+            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    log.debug(t.getMessage(), t);
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response r = responseFuture.get();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            asyncHttpClient.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-                .setProxyProtocol(ProxyServer.Protocol.HTTPS)
-                .setProxyHost("127.0.0.1")
-                .setProxyPort(port1)
-                .setFollowRedirects(true)
-                .setUrl(getTargetUrl2())
-                .setHeader("Content-Type", "text/html").build();
-
-        Response r = client.get().get();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProxyProtocol(ProxyServer.Protocol.HTTPS).setProxyHost("127.0.0.1").setProxyPort(port1).setFollowRedirects(true).setUrl(getTargetUrl2()).setHeader("Content-Type", "text/html").build();
+        try {
+            Response r = client.get().get();
 
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        client.close();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            client.close();
+        }
     }
 }
-
diff --git a/api/src/test/java/com/ning/http/client/async/PutLargeFileTest.java b/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
similarity index 68%
rename from api/src/test/java/com/ning/http/client/async/PutLargeFileTest.java
rename to api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
index 728ab012f..bf7d10489 100644
--- a/api/src/test/java/com/ning/http/client/async/PutLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
@@ -34,46 +34,48 @@
 /**
  * @author Benjamin Hanzelmann
  */
-public abstract class PutLargeFileTest
-        extends AbstractBasicTest {
+public abstract class PutLargeFileTest extends AbstractBasicTest {
 
     private File largeFile;
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutLargeFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutLargeFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 * 1024 * 100 / bytes.length) + 1;
         largeFile = createTempFile(bytes, (int) repeats);
         int timeout = (int) (largeFile.length() / 1000);
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(timeout).build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.setBody(largeFile);
+            rb.setBody(largeFile);
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
-    public void testPutSmallFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" })
+    public void testPutSmallFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 / bytes.length) + 1;
-//        int timeout = (5000);
+        // int timeout = (5000);
         largeFile = createTempFile(bytes, (int) repeats);
 
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
-        AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.setBody(largeFile);
+            rb.setBody(largeFile);
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
     @AfterMethod
@@ -82,12 +84,10 @@ public void after() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
-            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
                 ServletInputStream in = req.getInputStream();
                 byte[] b = new byte[8092];
@@ -110,11 +110,9 @@ public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServle
         };
     }
 
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -124,8 +122,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -134,8 +131,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/api/src/test/java/com/ning/http/client/async/QueryParametersTest.java b/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
similarity index 56%
rename from api/src/test/java/com/ning/http/client/async/QueryParametersTest.java
rename to api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
index 028a9543d..2b6437a88 100644
--- a/api/src/test/java/com/ning/http/client/async/QueryParametersTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
@@ -13,10 +13,10 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.slf4j.LoggerFactory;
@@ -33,23 +33,21 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 /**
  * Testing query parameters support.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class QueryParametersTest extends AbstractBasicTest {
     private class QueryStringHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 String qs = request.getQueryString();
-                if (qs != null && !qs.equals("")) {
+                if (isNonEmpty(qs)) {
                     for (String qnv : qs.split("&")) {
                         String nv[] = qnv.split("=");
                         response.addHeader(nv[0], nv[1]);
@@ -70,61 +68,62 @@ public AbstractHandler configureHandler() throws Exception {
         return new QueryStringHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .prepareGet("http://127.0.0.1:" + port1)
-                .addQueryParameter("a", "1")
-                .addQueryParameter("b", "2")
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("a"), "1");
-        assertEquals(resp.getHeader("b"), "2");
-        client.close();
+        try {
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParameter("a", "1").addQueryParameter("b", "2").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("a"), "1");
+            assertEquals(resp.getHeader("b"), "2");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
         String URL = getTargetUrl() + "?q=";
         String REQUEST_PARAM = "github github \ngithub";
 
         AsyncHttpClient client = getAsyncHttpClient(null);
-        String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
-        LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
-        Response response = client.prepareGet(requestUrl2).execute().get();
-        String s = URLDecoder.decode(response.getHeader("q"), "UTF-8");
-        assertEquals(s, REQUEST_PARAM);
-        client.close();
+        try {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
+            LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            String s = URLDecoder.decode(response.getHeader("q"), "UTF-8");
+            assertEquals(s, REQUEST_PARAM);
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void urlWithColonTest_Netty() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String query = "test:colon:";
+            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        String query = "test:colon:";
-        Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query))
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
-        c.close();
+            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void urlWithColonTest_JDK() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String query = "test:colon:";
+            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        String query = "test:colon:";
-        Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query))
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
-        c.close();
+            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
+        } finally {
+            c.close();
+        }
     }
 
 }
diff --git a/api/src/test/java/com/ning/http/client/async/RC10KTest.java b/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
similarity index 81%
rename from api/src/test/java/com/ning/http/client/async/RC10KTest.java
rename to api/src/test/java/org/asynchttpclient/async/RC10KTest.java
index 51a1e0960..9b07accd8 100644
--- a/api/src/test/java/com/ning/http/client/async/RC10KTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
@@ -13,14 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -46,7 +46,7 @@
 
 /**
  * Reverse C10K Problem test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class RC10KTest extends AbstractBasicTest {
@@ -102,20 +102,22 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient ahc = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setMaximumConnectionsPerHost(C10K).setAllowPoolingConnection(true).build());
-        List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
-        int i = 0;
-        while (i < C10K) {
-            resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
-        }
-        i = 0;
-        for (Future<Integer> fResp : resps) {
-            Integer resp = fResp.get();
-            assertNotNull(resp);
-            assertEquals(resp.intValue(), i++);
+        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaximumConnectionsPerHost(C10K).setAllowPoolingConnection(true).build());
+        try {
+            List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
+            int i = 0;
+            while (i < C10K) {
+                resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+            }
+            i = 0;
+            for (Future<Integer> fResp : resps) {
+                Integer resp = fResp.get();
+                assertNotNull(resp);
+                assertEquals(resp.intValue(), i++);
+            }
+        } finally {
+            ahc.close();
         }
-        ahc.close();
     }
 
     private class MyAsyncHandler implements AsyncHandler<Integer> {
diff --git a/api/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java b/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
similarity index 93%
rename from api/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java
rename to api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
index 1feb09440..ee1c0c106 100644
--- a/api/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
@@ -13,14 +13,15 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.nio.SelectChannelConnector;
@@ -120,7 +121,7 @@ public void testGetRedirectFinalUrl() {
             RequestBuilder builder = new RequestBuilder("GET");
             builder.setUrl(servletEndpointRedirectUrl);
 
-            com.ning.http.client.Request r = builder.build();
+            Request r = builder.build();
 
             try {
                 ListenableFuture<Response> response = c.executeRequest(r);
diff --git a/api/src/test/java/com/ning/http/client/async/Relative302Test.java b/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
similarity index 66%
rename from api/src/test/java/com/ning/http/client/async/Relative302Test.java
rename to api/src/test/java/org/asynchttpclient/async/Relative302Test.java
index e8a72640b..9d73308e7 100644
--- a/api/src/test/java/com/ning/http/client/async/Relative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -89,26 +85,25 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void redirected302Test() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", "http://www.google.com/")
-                .execute().get();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
 
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        
-        String anyGoogleSubdomain = "http://www.google.[a-z]{1,}:80";
-        String baseUrl = getBaseUrl( response.getUri() );
-        
-        assertTrue(baseUrl.matches( anyGoogleSubdomain ), "response does not show redirection to " + anyGoogleSubdomain);
+            String anyGoogleSubdomain = "http://www\\.google\\.[a-z]+(\\.[a-z]+)*:80";
+            String baseUrl = getBaseUrl(response.getUri());
 
-        c.close();
+            assertTrue(baseUrl.matches(anyGoogleSubdomain), "response does not show redirection to " + anyGoogleSubdomain);
+        } finally {
+            c.close();
+        }
     }
 
     private String getBaseUrl(URI uri) {
@@ -128,7 +123,7 @@ private static int getPort(URI uri) {
         return port;
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirected302InvalidTest() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
@@ -136,59 +131,56 @@ public void redirected302InvalidTest() throws Throwable {
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try {
-            Response response = c.prepareGet(getTargetUrl())
-                    .setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2))
-                    .execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void absolutePathRedirectTest() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String redirectTarget = "/bar/test";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-        String redirectTarget = "/bar/test";
-        String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
-        
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", redirectTarget)
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getUri().toString(), destinationUrl);
-        
-        log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        
-        c.close();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
+
+            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativePathRedirectTest() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String redirectTarget = "bar/test1";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-        String redirectTarget = "bar/test1";
-        String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
-        
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", redirectTarget)
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getUri().toString(), destinationUrl);
-
-        log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        
-        c.close();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
+
+            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java b/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
new file mode 100644
index 000000000..8e609af81
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.async;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.AssertJUnit.assertTrue;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.Collections;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.Cookie;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+
+/**
+ * Unit tests for remote site.
+ * <p/>
+ * see http://github.com/MSch/ning-async-http-client-bug/tree/master
+ * 
+ * @author Martin Schurrer
+ */
+public abstract class RemoteSiteTest extends AbstractBasicTest {
+
+    public static final String URL = "http://google.com?q=";
+    public static final String REQUEST_PARAM = "github github \n" + "github";
+
+    @Test(groups = { "online", "default_provider" })
+    public void testGoogleCom() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+        try {
+            Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testMailGoogleCom() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+        try {
+            Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testMicrosoftCom() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+        try {
+            Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testWwwMicrosoftCom() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+
+        Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+        assertNotNull(response);
+        assertEquals(response.getStatusCode(), 302);
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testUpdateMicrosoftCom() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+        try {
+            Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testGoogleComWithTimeout() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
+        try {
+            Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void asyncStatusHEADContentLenghtTest() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl("http://www.google.com/").build();
+
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.assertEquals(response.getStatusCode(), 200);
+                    l.countDown();
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            p.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" }, enabled = false)
+    public void invalidStreamTest2() throws Throwable {
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).setFollowRedirects(true).setAllowPoolingConnection(false).setMaximumNumberOfRedirects(6).build();
+
+        AsyncHttpClient c = getAsyncHttpClient(config);
+        try {
+            Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
+            if (response != null) {
+                System.out.println(response);
+            }
+        } catch (Throwable t) {
+            t.printStackTrace();
+            assertNotNull(t.getCause());
+            assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void asyncFullBodyProperlyRead() throws Throwable {
+        final AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
+
+            InputStream stream = r.getResponseBodyAsStream();
+            int available = stream.available();
+            int[] lengthWrapper = new int[1];
+            /* byte[] bytes = */AsyncHttpProviderUtils.readFully(stream, lengthWrapper);
+            int byteToRead = lengthWrapper[0];
+
+            Assert.assertEquals(available, byteToRead);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void testUrlRequestParametersEncoding() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
+            log.info(String.format("Executing request [%s] ...", requestUrl2));
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            Assert.assertEquals(response.getStatusCode(), 301);
+        } finally {
+            client.close();
+        }
+    }
+
+    /**
+     * See https://issues.sonatype.org/browse/AHC-61
+     * 
+     * @throws Throwable
+     */
+    @Test(groups = { "online", "default_provider" })
+    public void testAHC60() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
+            Assert.assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void stripQueryStringTest() throws Throwable {
+
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
+        AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void stripQueryStringNegativeTest() throws Throwable {
+
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setRemoveQueryParamsOnRedirect(false).setFollowRedirects(true).build();
+        AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" })
+    public void evilCoookieTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            RequestBuilder builder2 = new RequestBuilder("GET");
+            builder2.setFollowRedirects(true);
+            builder2.setUrl("http://www.google.com/");
+            builder2.addHeader("Content-Type", "text/plain");
+            builder2.addCookie(new Cookie(".google.com", "evilcookie", "evilcookie", "test", "/", 10, false, 1, false, false, null, null, Collections.<Integer> emptySet()));
+            Request request2 = builder2.build();
+            Response response = c.executeRequest(request2).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "online", "default_provider" }, enabled = false)
+    public void testAHC62Com() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        try {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    System.out.println(bodyPart.getBodyPartBytes().length);
+                    builder.accumulate(bodyPart);
+
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return STATE.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getResponseBody().length() >= 3870);
+        } finally {
+            c.close();
+        }
+    }
+
+}
diff --git a/api/src/test/java/com/ning/http/client/async/RequestBuilderTest.java b/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
similarity index 96%
rename from api/src/test/java/com/ning/http/client/async/RequestBuilderTest.java
rename to api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
index 52714d3ed..586b74a50 100644
--- a/api/src/test/java/com/ning/http/client/async/RequestBuilderTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.FluentStringsMap;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
+import org.asynchttpclient.FluentStringsMap;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
diff --git a/api/src/test/java/com/ning/http/client/async/RetryRequestTest.java b/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
similarity index 88%
rename from api/src/test/java/com/ning/http/client/async/RetryRequestTest.java
rename to api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
index 3cd92523b..d9dc0970d 100644
--- a/api/src/test/java/com/ning/http/client/async/RetryRequestTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
+package org.asynchttpclient.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -29,9 +29,7 @@
 public abstract class RetryRequestTest extends AbstractBasicTest {
     public static class SlowAndBigHandler extends AbstractHandler {
 
-        public void handle(String pathInContext, Request request,
-                           HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-                throws IOException, ServletException {
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int load = 100;
             httpResponse.setStatus(200);
@@ -40,7 +38,6 @@ public void handle(String pathInContext, Request request,
 
             httpResponse.flushBuffer();
 
-
             OutputStream os = httpResponse.getOutputStream();
             for (int i = 0; i < load; i++) {
                 os.write(i % 255);
@@ -51,7 +48,6 @@ public void handle(String pathInContext, Request request,
                     // nuku
                 }
 
-
                 if (i > load / 10) {
                     httpResponse.sendError(500);
                 }
@@ -71,8 +67,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new SlowAndBigHandler();
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testMaxRetry() throws Throwable {
         AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).build());
         try {
@@ -84,8 +79,8 @@ public void testMaxRetry() throws Throwable {
             if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
                 fail();
             }
+        } finally {
+            ahc.close();
         }
-
-        ahc.close();
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
new file mode 100644
index 000000000..3baf664f2
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import static org.testng.Assert.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.concurrent.Future;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SimpleAsyncHttpClient;
+import org.asynchttpclient.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
+import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
+
+/**
+ * @author Benjamin Hanzelmann
+ * 
+ */
+public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testAccumulateErrorBody() throws Throwable {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertTrue(response.getResponseBody().startsWith("<html>"));
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testOmitErrorBody() throws Throwable {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertEquals(response.getResponseBody(), "");
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        // disabled
+        return null;
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+
+            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                response.sendError(404);
+                baseRequest.setHandled(true);
+            }
+        };
+    }
+
+}
diff --git a/api/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
similarity index 50%
rename from api/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
rename to api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
index 9697ffcb5..a8f09a3f9 100644
--- a/api/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
@@ -10,17 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.ByteArrayPart;
-import com.ning.http.client.Response;
-import com.ning.http.client.SimpleAsyncHttpClient;
-import com.ning.http.client.consumers.AppendableBodyConsumer;
-import com.ning.http.client.consumers.OutputStreamBodyConsumer;
-import com.ning.http.client.generators.FileBodyGenerator;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
-import com.ning.http.client.simple.HeaderMap;
-import com.ning.http.client.simple.SimpleAHCTransferListener;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.ByteArrayPart;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.SimpleAsyncHttpClient;
+import org.asynchttpclient.consumers.AppendableBodyConsumer;
+import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
+import org.asynchttpclient.generators.FileBodyGenerator;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.simple.HeaderMap;
+import org.asynchttpclient.simple.SimpleAHCTransferListener;
 import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
@@ -43,67 +43,68 @@
     @Test(groups = { "standalone", "default_provider" })
     public void inpuStreamBodyConsumerTest() throws Throwable {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBody(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void StringBufferBodyConsumerTest() throws Throwable {
-
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        StringBuilder s = new StringBuilder();
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+    public void StringBuilderBodyConsumerTest() throws Throwable {
 
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(s.toString(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            StringBuilder s = new StringBuilder();
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(s.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
 
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-
-        client.close();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     /**
@@ -111,31 +112,35 @@ public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
      */
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
     public void testPutZeroBytesFileTest() throws Throwable {
-        System.err.println("setting up client");
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain").build();
-
-        File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
-        tmpfile.deleteOnExit();
-
-        Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain")
+                .build();
+        try {
+            File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
+            tmpfile.deleteOnExit();
 
-        System.out.println("waiting for response");
-        Response response = future.get();
+            Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
 
-        tmpfile.delete();
+            System.out.println("waiting for response");
+            Response response = future.get();
 
-        assertEquals(response.getStatusCode(), 200);
+            tmpfile.delete();
 
-        client.close();
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDerive() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build();
         SimpleAsyncHttpClient derived = client.derive().build();
-
-        assertNotSame(derived, client);
+        try {
+            assertNotSame(derived, client);
+        } finally {
+            client.close();
+            derived.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -147,15 +152,16 @@ public void testDeriveOverrideURL() throws Exception {
         OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
         SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build();
-
-        Future<Response> future = derived.post(generator, consumer);
-
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-
-        client.close();
-        derived.close();
+        try {
+            Future<Response> future = derived.post(generator, consumer);
+
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+            derived.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -192,17 +198,20 @@ public void onBytesReceived(String url, long amount, long current, long total) {
         };
 
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).setHeader("Custom", "custom").setListener(listener).build();
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-        InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-        OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-        Future<Response> future = client.post(generator, consumer);
+            Future<Response> future = client.post(generator, consumer);
 
-        Response response = future.get();
-        client.close();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -219,14 +228,17 @@ public void testNullUrl() throws Exception {
     public void testCloseDerivedValidMaster() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
+        try {
+            derived.get().get();
 
-        derived.get().get();
-
-        derived.close();
+            derived.close();
 
-        Response response = client.get().get();
+            Response response = client.get().get();
 
-        assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -251,45 +263,49 @@ public void testCloseMasterInvalidDerived() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPut() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
-        
-        Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
-        
-        String body = response.getResponseBody();
-        String contentType = response.getHeader("X-Content-Type");
-        
-        assertTrue(contentType.contains("multipart/form-data"));
-        
-        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-        
-        assertTrue(body.startsWith("--" + boundary));
-        assertTrue(body.trim().endsWith("--" + boundary + "--"));
-        assertTrue(body.contains("Content-Disposition:"));
-        assertTrue(body.contains("Content-Type: application/test"));
-        assertTrue(body.contains("name=\"baPart"));
-        assertTrue(body.contains("filename=\"fileName"));
-        
+        try {
+            Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
+
+            assertTrue(contentType.contains("multipart/form-data"));
+
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        } finally {
+            client.close();
+        }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPost() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
-        
-        Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
-        
-        String body = response.getResponseBody();
-        String contentType = response.getHeader("X-Content-Type");
-        
-        assertTrue(contentType.contains("multipart/form-data"));
-        
-        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-        
-        assertTrue(body.startsWith("--" + boundary));
-        assertTrue(body.trim().endsWith("--" + boundary + "--"));
-        assertTrue(body.contains("Content-Disposition:"));
-        assertTrue(body.contains("Content-Type: application/test"));
-        assertTrue(body.contains("name=\"baPart"));
-        assertTrue(body.contains("filename=\"fileName"));
-        
+        try {
+            Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
+
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
+
+            assertTrue(contentType.contains("multipart/form-data"));
+
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        } finally {
+            client.close();
+        }
     }
 
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java b/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
new file mode 100644
index 000000000..48e18c1be
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.generators.FileBodyGenerator;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.listener.TransferListener;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Enumeration;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
+public abstract class TransferListenerTest extends AbstractBasicTest {
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
+
+    private class BasicHandler extends AbstractHandler {
+
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            Enumeration<?> e = httpRequest.getHeaderNames();
+            String param;
+            while (e.hasMoreElements()) {
+                param = e.nextElement().toString();
+                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
+            }
+
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                httpRequest.getInputStream().read(bytes);
+                httpResponse.getOutputStream().write(bytes);
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new BasicHandler();
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void basicGetTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicReference<ByteBuffer> bb = new AtomicReference<ByteBuffer>();
+            final AtomicBoolean completed = new AtomicBoolean(false);
+
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
+
+                public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
+                    hSent.set(headers);
+                }
+
+                public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
+                    hRead.set(headers);
+                }
+
+                public void onBytesReceived(ByteBuffer buffer) {
+                    bb.set(buffer);
+                }
+
+                public void onBytesSent(ByteBuffer buffer) {
+                }
+
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
+
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
+
+            try {
+                Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
+
+                assertNotNull(response);
+                assertEquals(response.getStatusCode(), 200);
+                assertNotNull(hRead.get());
+                assertNotNull(hSent.get());
+                assertNotNull(bb.get());
+                assertNull(throwable.get());
+            } catch (IOException ex) {
+                fail("Should have timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void basicPutTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+            final AtomicInteger bbSentLenght = new AtomicInteger(0);
+
+            final AtomicBoolean completed = new AtomicBoolean(false);
+
+            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
+            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
+            File largeFile = createTempFile(bytes, (int) repeats);
+
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
+
+                public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
+                    hSent.set(headers);
+                }
+
+                public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
+                    hRead.set(headers);
+                }
+
+                public void onBytesReceived(ByteBuffer buffer) {
+                    bbReceivedLenght.addAndGet(buffer.capacity());
+                }
+
+                public void onBytesSent(ByteBuffer buffer) {
+                    bbSentLenght.addAndGet(buffer.capacity());
+                }
+
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
+
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
+
+            try {
+                Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(tl).get();
+
+                assertNotNull(response);
+                assertEquals(response.getStatusCode(), 200);
+                assertNotNull(hRead.get());
+                assertNotNull(hSent.get());
+                assertEquals(bbReceivedLenght.get(), largeFile.length());
+                assertEquals(bbSentLenght.get(), largeFile.length());
+            } catch (IOException ex) {
+                fail("Should have timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void basicPutBodyTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+            final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
+            final AtomicInteger bbSentLenght = new AtomicInteger(0);
+
+            final AtomicBoolean completed = new AtomicBoolean(false);
+
+            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
+            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
+            File largeFile = createTempFile(bytes, (int) repeats);
+
+            TransferCompletionHandler tl = new TransferCompletionHandler();
+            tl.addTransferListener(new TransferListener() {
+
+                public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers) {
+                    hSent.set(headers);
+                }
+
+                public void onResponseHeadersReceived(FluentCaseInsensitiveStringsMap headers) {
+                    hRead.set(headers);
+                }
+
+                public void onBytesReceived(ByteBuffer buffer) {
+                    bbReceivedLenght.addAndGet(buffer.capacity());
+                }
+
+                public void onBytesSent(ByteBuffer buffer) {
+                    bbSentLenght.addAndGet(buffer.capacity());
+                }
+
+                public void onRequestResponseCompleted() {
+                    completed.set(true);
+                }
+
+                public void onThrowable(Throwable t) {
+                    throwable.set(t);
+                }
+            });
+
+            try {
+                Response response = c.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(largeFile)).execute(tl).get();
+
+                assertNotNull(response);
+                assertEquals(response.getStatusCode(), 200);
+                assertNotNull(hRead.get());
+                assertNotNull(hSent.get());
+                assertEquals(bbReceivedLenght.get(), largeFile.length());
+                assertEquals(bbSentLenght.get(), largeFile.length());
+            } catch (IOException ex) {
+                fail("Should have timed out");
+            }
+        } finally {
+            c.close();
+        }
+    }
+
+    public String getTargetUrl() {
+        return String.format("http://127.0.0.1:%d/foo/test", port1);
+    }
+
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
+        TMP.mkdirs();
+        TMP.deleteOnExit();
+        File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
+        write(pattern, repeat, tmpFile);
+
+        return tmpFile;
+    }
+
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
+        file.deleteOnExit();
+        file.getParentFile().mkdirs();
+        FileOutputStream out = null;
+        try {
+            out = new FileOutputStream(file);
+            for (int i = 0; i < repeat; i++) {
+                out.write(pattern);
+            }
+        } finally {
+            if (out != null) {
+                out.close();
+            }
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/async/WebDavBasicTest.java b/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
similarity index 53%
rename from api/src/test/java/com/ning/http/client/async/WebDavBasicTest.java
rename to api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
index 77b69dcf6..fb8d5abff 100644
--- a/api/src/test/java/com/ning/http/client/async/WebDavBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
@@ -10,14 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.async;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.webdav.WebDavCompletionHandlerBase;
-import com.ning.http.client.webdav.WebDavResponse;
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.webdav.WebDavCompletionHandlerBase;
+import org.asynchttpclient.webdav.WebDavResponse;
 import org.apache.catalina.Context;
 import org.apache.catalina.Engine;
 import org.apache.catalina.Host;
@@ -38,7 +38,6 @@
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 
-
 public abstract class WebDavBasicTest extends AbstractBasicTest {
 
     public Embedded embedded;
@@ -94,91 +93,101 @@ public void tearDownGlobal() throws InterruptedException, Exception {
         embedded.stop();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-
-        assertEquals(response.getStatusCode(), 201);
-
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+
+            assertEquals(response.getStatusCode(), 201);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 409);
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 409);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(propFindRequest).get();
-
-        assertEquals(response.getStatusCode(), 404);
-        c.close();
+        try {
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(propFindRequest).get();
+
+            assertEquals(response.getStatusCode(), 404);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request putRequest = new RequestBuilder("PUT").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
-        response = c.executeRequest(putRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
-        response = c.executeRequest(propFindRequest).get();
-
-        assertEquals(response.getStatusCode(), 207);
-        assertTrue(response.getResponseBody().contains("<status>HTTP/1.1 200 OK</status>"));
-        c.close();
-
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request putRequest = new RequestBuilder("PUT").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
+            response = c.executeRequest(putRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
+            response = c.executeRequest(propFindRequest).get();
+
+            assertEquals(response.getStatusCode(), 207);
+            assertTrue(response.getResponseBody().contains("<status>HTTP/1.1 200 OK</status>"));
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-        WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
-            /**
-             * {@inheritDoc}
-             */
-            /* @Override */
-            public void onThrowable(Throwable t) {
-
-                t.printStackTrace();
-            }
-
-            @Override
-            public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
-                return response;
-            }
-        }).get();
-
-        assertNotNull(webDavResponse);
-        assertEquals(webDavResponse.getStatusCode(), 200);
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
+                /**
+                 * {@inheritDoc}
+                 */
+                /* @Override */
+                public void onThrowable(Throwable t) {
+
+                    t.printStackTrace();
+                }
+
+                @Override
+                public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
+                    return response;
+                }
+            }).get();
+
+            assertNotNull(webDavResponse);
+            assertEquals(webDavResponse.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java b/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
new file mode 100644
index 000000000..c11a3ea5d
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.async;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+
+/**
+ * Zero copy test which use FileChannel.transfer under the hood . The same SSL test is also covered in {@link BasicHttpsTest}
+ */
+public abstract class ZeroCopyFileTest extends AbstractBasicTest {
+
+    private class ZeroCopyHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            int size = 10 * 1024;
+            if (httpRequest.getContentLength() > 0) {
+                size = httpRequest.getContentLength();
+            }
+            byte[] bytes = new byte[size];
+            if (bytes.length > 0) {
+                httpRequest.getInputStream().read(bytes);
+                httpResponse.getOutputStream().write(bytes);
+            }
+
+            httpResponse.setStatus(200);
+            httpResponse.getOutputStream().flush();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final AtomicBoolean headerSent = new AtomicBoolean(false);
+            final AtomicBoolean operationCompleted = new AtomicBoolean(false);
+
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncCompletionHandler<Response>() {
+
+                public STATE onHeaderWriteCompleted() {
+                    headerSent.set(true);
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onContentWriteCompleted() {
+                    operationCompleted.set(true);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertTrue(operationCompleted.get());
+            assertTrue(headerSent.get());
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(file).execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ZeroCopyHandler();
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+            tmp.deleteOnExit();
+            final FileOutputStream stream = new FileOutputStream(tmp);
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+                public void onThrowable(Throwable t) {
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    bodyPart.writeTo(stream);
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return null;
+                }
+            });
+            Response resp = f.get();
+            stream.close();
+            assertNull(resp);
+            assertEquals(file.length(), tmp.length());
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+            tmp.deleteOnExit();
+            final FileOutputStream stream = new FileOutputStream(tmp);
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+                public void onThrowable(Throwable t) {
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    bodyPart.writeTo(stream);
+
+                    if (bodyPart.getBodyPartBytes().length == 0) {
+                        return STATE.ABORT;
+                    }
+
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return null;
+                }
+            });
+            Response resp = f.get();
+            stream.close();
+            assertNull(resp);
+            assertEquals(file.length(), tmp.length());
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java b/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
similarity index 95%
rename from api/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java
rename to api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
index a2c393783..efd53a3bf 100644
--- a/api/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java
+++ b/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
@@ -11,10 +11,11 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.generators;
+package org.asynchttpclient.generators;
 
-import com.ning.http.client.Body;
+import org.asynchttpclient.Body;
 
+import org.asynchttpclient.generators.ByteArrayBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
@@ -22,7 +23,6 @@
 import java.util.Random;
 
 import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
 
 /**
  * @author Bryan Davis bpd@keynetics.com
diff --git a/api/src/test/java/com/ning/http/client/oauth/TestSignatureCalculator.java b/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
similarity index 88%
rename from api/src/test/java/com/ning/http/client/oauth/TestSignatureCalculator.java
rename to api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
index e75a1e981..f2256fad0 100644
--- a/api/src/test/java/com/ning/http/client/oauth/TestSignatureCalculator.java
+++ b/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
@@ -13,12 +13,15 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.oauth;
+package org.asynchttpclient.oauth;
 
+import org.asynchttpclient.oauth.ConsumerKey;
+import org.asynchttpclient.oauth.OAuthSignatureCalculator;
+import org.asynchttpclient.oauth.RequestToken;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
-import com.ning.http.client.FluentStringsMap;
+import org.asynchttpclient.FluentStringsMap;
 
 public class TestSignatureCalculator
 {
diff --git a/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java b/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
new file mode 100644
index 000000000..2c4e3853f
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.org.jboss.netty.handler.codec.http;
+
+import java.util.Set;
+
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.Cookie;
+
+public class CookieDecoderTest {
+    
+    @Test(groups = "fast")
+    public void testDecodeUnquoted() {
+        Set<Cookie> cookies = CookieDecoder.decode(
+                "foo=value; domain=/; path=/");
+        Assert.assertEquals(cookies.size(), 1);
+
+        Cookie first = cookies.iterator().next();
+        Assert.assertEquals(first.getValue(), "value");
+        Assert.assertEquals(first.getDomain(), "/");
+        Assert.assertEquals(first.getPath(), "/");
+    }
+
+    @Test(groups = "fast")
+    public void testDecodeQuoted() {
+        Set<Cookie> cookies = CookieDecoder.decode("ALPHA=\"VALUE1\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 13-Jan-2021 22:23:01 GMT; Secure; HttpOnly");
+        Assert.assertEquals(cookies.size(), 1);
+
+        Cookie first = cookies.iterator().next();
+        Assert.assertEquals(first.getValue(), "VALUE1");
+    }
+
+    @Test(groups = "fast")
+    public void testDecodeQuotedContainingEscapedQuote() {
+        Set<Cookie> cookies = CookieDecoder.decode("ALPHA=\"VALUE1\\\"\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 13-Jan-2021 22:23:01 GMT; Secure; HttpOnly");
+        Assert.assertEquals(cookies.size(), 1);
+
+        Cookie first = cookies.iterator().next();
+        Assert.assertEquals(first.getValue(), "VALUE1\"");
+    }
+}
\ No newline at end of file
diff --git a/api/src/test/java/com/ning/http/client/resumable/MapResumableProcessor.java b/api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java
similarity index 82%
rename from api/src/test/java/com/ning/http/client/resumable/MapResumableProcessor.java
rename to api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java
index 2e5734969..3dbf4e827 100644
--- a/api/src/test/java/com/ning/http/client/resumable/MapResumableProcessor.java
+++ b/api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java
@@ -1,6 +1,6 @@
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
-import com.ning.http.client.resumable.ResumableAsyncHandler.ResumableProcessor;
+import org.asynchttpclient.resumable.ResumableAsyncHandler.ResumableProcessor;
 
 import java.util.HashMap;
 import java.util.Map;
diff --git a/api/src/test/java/com/ning/http/client/resumable/PropertiesBasedResumableProcesserTest.java b/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
similarity index 89%
rename from api/src/test/java/com/ning/http/client/resumable/PropertiesBasedResumableProcesserTest.java
rename to api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
index 41d0d6894..ab958e529 100644
--- a/api/src/test/java/com/ning/http/client/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
@@ -1,4 +1,4 @@
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
@@ -13,6 +13,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
+import org.asynchttpclient.resumable.PropertiesBasedResumableProcessor;
 import org.testng.annotations.Test;
 
 import java.util.Map;
@@ -23,9 +24,8 @@
  * @author Benjamin Hanzelmann
  */
 public class PropertiesBasedResumableProcesserTest {
-    @Test (enabled = false)
-    public void testSaveLoad()
-            throws Exception {
+    @Test
+    public void testSaveLoad() throws Exception {
         PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
         p.put("http://localhost/test.url", 15L);
         p.put("http://localhost/test2.url", 50L);
diff --git a/api/src/test/java/com/ning/http/client/resumable/ResumableAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
similarity index 90%
rename from api/src/test/java/com/ning/http/client/resumable/ResumableAsyncHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
index 298983e0d..7feb70ce7 100644
--- a/api/src/test/java/com/ning/http/client/resumable/ResumableAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
@@ -1,4 +1,4 @@
-package com.ning.http.client.resumable;
+package org.asynchttpclient.resumable;
 
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
@@ -13,8 +13,9 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.resumable.ResumableAsyncHandler;
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertEquals;
diff --git a/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java b/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java
new file mode 100644
index 000000000..d1300614e
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/util/AsyncHttpProviderUtilsTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.net.URI;
+
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class AsyncHttpProviderUtilsTest {
+
+    @Test(groups = "fast")
+    public void getRedirectUriShouldHandleProperlyEncodedLocation() {
+
+        String url = "http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505";
+        URI uri = AsyncHttpProviderUtils.getRedirectUri(
+                URI.create("http://www.ebay.de"), url);
+        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
+    }
+
+    @Test(groups = "fast")
+    public void getRedirectUriShouldHandleRawQueryParamsLocation() {
+
+        String url = "http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC Lifebook E8310 Core2Duo T8100 2 1GHz 4GB DVD RW&_itemId=150731406505";
+        URI uri = AsyncHttpProviderUtils.getRedirectUri(URI.create("http://www.ebay.de"), url);
+        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
+    }
+    
+    @Test(groups = "fast")
+    public void getRedirectUriShouldHandleRelativeLocation() {
+
+        String url = "/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC Lifebook E8310 Core2Duo T8100 2 1GHz 4GB DVD RW&_itemId=150731406505";
+        URI uri = AsyncHttpProviderUtils.getRedirectUri(URI.create("http://www.ebay.de"), url);
+        Assert.assertEquals("http://www.ebay.de/sch/sis.html;jsessionid=92D73F80262E3EBED7E115ED01035DDA?_nkw=FSC%20Lifebook%20E8310%20Core2Duo%20T8100%202%201GHz%204GB%20DVD%20RW&_itemId=150731406505", uri.toString());
+    }
+}
diff --git a/api/src/test/java/com/ning/http/util/ProxyUtilsTest.java b/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
similarity index 91%
rename from api/src/test/java/com/ning/http/util/ProxyUtilsTest.java
rename to api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
index 1ccd206a8..24f1823d9 100644
--- a/api/src/test/java/com/ning/http/util/ProxyUtilsTest.java
+++ b/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.util.ProxyUtils;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
diff --git a/api/src/test/java/com/ning/http/util/TestUTF8UrlCodec.java b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
similarity index 92%
rename from api/src/test/java/com/ning/http/util/TestUTF8UrlCodec.java
rename to api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
index e675a1a61..21af50869 100644
--- a/api/src/test/java/com/ning/http/util/TestUTF8UrlCodec.java
+++ b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
@@ -13,8 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.util;
+package org.asynchttpclient.util;
 
+import org.asynchttpclient.util.UTF8UrlEncoder;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
diff --git a/api/src/test/java/com/ning/http/client/websocket/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
similarity index 96%
rename from api/src/test/java/com/ning/http/client/websocket/AbstractBasicTest.java
rename to api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
index a3bf5a638..bbff1213e 100644
--- a/api/src/test/java/com/ning/http/client/websocket/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.HandlerWrapper;
diff --git a/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
new file mode 100644
index 000000000..f9086515c
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketByteListener;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.http.HttpServletRequest;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.testng.Assert.assertEquals;
+
+public abstract class ByteMessageTest extends AbstractBasicTest {
+
+    private final class EchoByteWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnBinaryMessage {
+
+        private Connection connection;
+
+        @Override
+        public void onOpen(Connection connection) {
+            this.connection = connection;
+            connection.setMaxBinaryMessageSize(1000);
+        }
+
+        @Override
+        public void onClose(int i, String s) {
+            connection.close();
+        }
+
+        @Override
+        public void onMessage(byte[] bytes, int i, int i1) {
+            try {
+                connection.sendMessage(bytes, i, i1);
+            } catch (IOException e) {
+                try {
+                    connection.sendMessage("FAIL");
+                } catch (IOException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @Override
+    public WebSocketHandler getWebSocketHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
+                return new EchoByteWebSocket();
+            }
+        };
+    }
+
+    @Test
+    public void echoByte() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
+
+            WebSocket
+                    websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onMessage(byte[] message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
+
+            websocket.sendMessage("ECHO".getBytes());
+
+            latch.await();
+            assertEquals(text.get(), "ECHO".getBytes());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test
+    public void echoTwoMessagesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
+
+            websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test
+    public void echoOnOpenMessagesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+
+            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
+    }
+
+    public void echoFragments() throws Exception {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+
+        WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+            @Override
+            public void onOpen(WebSocket websocket) {
+            }
+
+            @Override
+            public void onClose(WebSocket websocket) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onError(Throwable t) {
+                t.printStackTrace();
+                latch.countDown();
+            }
+
+            @Override
+            public void onMessage(byte[] message) {
+                if (text.get() == null) {
+                    text.set(message);
+                } else {
+                    byte[] n = new byte[text.get().length + message.length];
+                    System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                    System.arraycopy(message, 0, n, text.get().length, message.length);
+                    text.set(n);
+                }
+                latch.countDown();
+            }
+
+            @Override
+            public void onFragment(byte[] fragment, boolean last) {
+            }
+        }).build()).get();
+        websocket.stream("ECHO".getBytes(), false);
+        websocket.stream("ECHO".getBytes(), true);
+        latch.await();
+        assertEquals(text.get(), "ECHOECHO".getBytes());
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
new file mode 100644
index 000000000..271ade791
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.testng.annotations.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+public abstract class CloseCodeReasonMessageTest extends TextMessageTest {
+
+    @Test(timeOut = 60000)
+    public void onCloseWithCode() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+
+            websocket.close();
+
+            latch.await();
+            assertTrue(text.get().startsWith("1000"));
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void onCloseWithCodeServerClose() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+
+            latch.await();
+            final String[] parts = text.get().split(" ");
+            assertEquals(parts.length, 5);
+            assertEquals(parts[0], "1000-Idle");
+            assertEquals(parts[1], "for");
+            assertTrue(Integer.parseInt(parts[2].substring(0, parts[2].indexOf('m'))) > 10000);
+            assertEquals(parts[3], ">");
+            assertEquals(parts[4], "10000ms");
+        } finally {
+            c.close();
+        }
+    }
+
+    public final static class Listener implements WebSocketListener,
+            WebSocketCloseCodeReasonListener {
+
+        final CountDownLatch latch;
+        final AtomicReference<String> text;
+
+        public Listener(CountDownLatch latch, AtomicReference<String> text) {
+            this.latch = latch;
+            this.text = text;
+        }
+
+        // @Override
+        public void onOpen(WebSocket websocket) {
+        }
+
+        // @Override
+        public void onClose(WebSocket websocket) {
+        }
+
+        public void onClose(WebSocket websocket, int code, String reason) {
+            text.set(code + "-" + reason);
+            latch.countDown();
+        }
+
+        // @Override
+        public void onError(Throwable t) {
+            t.printStackTrace();
+            latch.countDown();
+        }
+    }
+}
diff --git a/api/src/test/java/com/ning/http/client/websocket/RedirectTest.java b/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
similarity index 64%
rename from api/src/test/java/com/ning/http/client/websocket/RedirectTest.java
rename to api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
index 40d106516..dda880823 100644
--- a/api/src/test/java/com/ning/http/client/websocket/RedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
@@ -11,11 +11,13 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.websocket;
+package org.asynchttpclient.websocket;
 
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.eclipse.jetty.server.handler.HandlerList;
@@ -48,9 +50,6 @@ public void setUpGlobal() throws Exception {
 
         addConnector(_connector);
 
-
-
-
         port2 = findFreePort();
         final SelectChannelConnector connector2 = new SelectChannelConnector();
         connector2.setPort(port2);
@@ -58,13 +57,13 @@ public void setUpGlobal() throws Exception {
         WebSocketHandler _wsHandler = getWebSocketHandler();
         HandlerList list = new HandlerList();
         list.addHandler(new AbstractHandler() {
-                    @Override
-                    public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
-                        if (request.getLocalPort() == port2) {
-                            httpServletResponse.sendRedirect(getTargetUrl());
-                        }
-                    }
-                });
+            @Override
+            public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
+                if (request.getLocalPort() == port2) {
+                    httpServletResponse.sendRedirect(getTargetUrl());
+                }
+            }
+        });
         list.addHandler(_wsHandler);
         setHandler(list);
 
@@ -87,39 +86,39 @@ public WebSocketHandler getWebSocketHandler() {
     @Test(timeOut = 60000)
     public void testRedirectToWSResource() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getRedirectURL())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnOpen");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-
-        latch.await();
-        assertEquals(text.get(), "OnOpen");
-        websocket.close();
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
+            websocket.close();
+        } finally {
+            c.close();
+        }
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private String getRedirectURL() {
         return String.format("ws://127.0.0.1:%d/", port2);
     }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java b/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
new file mode 100644
index 000000000..c64efe4cd
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
@@ -0,0 +1,406 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketTextListener;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.http.HttpServletRequest;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+public abstract class TextMessageTest extends AbstractBasicTest {
+
+    public static final class EchoTextWebSocket implements org.eclipse.jetty.websocket.WebSocket, org.eclipse.jetty.websocket.WebSocket.OnTextMessage {
+
+        private Connection connection;
+
+        @Override
+        public void onOpen(Connection connection) {
+            this.connection = connection;
+            connection.setMaxTextMessageSize(1000);
+        }
+
+        @Override
+        public void onClose(int i, String s) {
+            connection.close();
+        }
+
+        @Override
+        public void onMessage(String s) {
+            try {
+                connection.sendMessage(s);
+            } catch (IOException e) {
+                try {
+                    connection.sendMessage("FAIL");
+                } catch (IOException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @Override
+    public WebSocketHandler getWebSocketHandler() {
+        return new WebSocketHandler() {
+            @Override
+            public org.eclipse.jetty.websocket.WebSocket doWebSocketConnect(HttpServletRequest httpServletRequest, String s) {
+                return new EchoTextWebSocket();
+            }
+        };
+    }
+
+    @Test(timeOut = 60000)
+    public void onOpen() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void onEmptyListenerTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            WebSocket websocket = null;
+            try {
+                websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+            } catch (Throwable t) {
+                fail();
+            }
+            assertTrue(websocket != null);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void onFailureTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            Throwable t = null;
+            try {
+                /* WebSocket websocket = */c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
+            } catch (Throwable t2) {
+                t = t2;
+            }
+            assertTrue(t != null);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void onTimeoutCloseTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnClose");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void onClose() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.close();
+
+            latch.await();
+            assertEquals(text.get(), "OnClose");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void echoText() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendTextMessage("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHO");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test(timeOut = 60000)
+    public void echoDoubleListenerText() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(text.get() + message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendTextMessage("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
+    }
+
+    @Test
+    public void echoTwoMessagesTest() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(text.get() + message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    websocket.sendTextMessage("ECHO").sendTextMessage("ECHO");
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
+    }
+
+    public void echoFragments() throws Throwable {
+        AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.streamText("ECHO", false);
+            websocket.streamText("ECHO", true);
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
+    }
+
+}
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
new file mode 100644
index 000000000..c759c8ebe
--- /dev/null
+++ b/extras/guava/pom.xml
@@ -0,0 +1,23 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <version>2.0.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-extras-guava</artifactId>
+    <name>Asynchronous Http Client Guava Extras</name>
+    <description>
+        The Async Http Client Guava Extras.
+    </description>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>14.0.1</version>
+        </dependency>
+    </dependencies>
+</project>
\ No newline at end of file
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java b/extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java
new file mode 100644
index 000000000..2576407a0
--- /dev/null
+++ b/extras/guava/src/main/java/org/asynchttpclient/extra/ListenableFutureAdapter.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extra;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import org.asynchttpclient.ListenableFuture;
+
+public final class ListenableFutureAdapter {
+
+    /**
+     * @param future an AHC ListenableFuture
+     * @return a Guava ListenableFuture
+     */
+    public static <V> com.google.common.util.concurrent.ListenableFuture<V> asGuavaFuture(final ListenableFuture<V> future) {
+
+        return new com.google.common.util.concurrent.ListenableFuture<V>() {
+
+            public boolean cancel(boolean mayInterruptIfRunning) {
+                return future.cancel(mayInterruptIfRunning);
+            }
+
+            public V get() throws InterruptedException, ExecutionException {
+                return future.get();
+            }
+
+            public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+                return future.get(timeout, unit);
+            }
+
+            public boolean isCancelled() {
+                return future.isCancelled();
+            }
+
+            public boolean isDone() {
+                return future.isDone();
+            }
+
+            public void addListener(final Runnable runnable, final Executor executor) {
+                future.addListener(runnable, executor);
+            }
+        };
+    }
+}
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java
new file mode 100644
index 000000000..c9b875927
--- /dev/null
+++ b/extras/guava/src/main/java/org/asynchttpclient/extra/RateLimitedThrottleRequestFilter.java
@@ -0,0 +1,95 @@
+package org.asynchttpclient.extra;
+
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.RequestFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.util.concurrent.RateLimiter;
+
+/**
+ * A {@link org.asynchttpclient.filter.RequestFilter} that extends the capability of
+ * {@link ThrottleRequestFilter} by allowing rate limiting per second in addition to the
+ * number of concurrent connections.
+ * 
+ *  The <code>maxWaitMs</code> argument is respected accross both permit acquistions. For 
+ *  example, if 1000 ms is given, and the filter spends 500 ms waiting for a connection,
+ *  it will only spend another 500 ms waiting for the rate limiter.
+ */
+public class RateLimitedThrottleRequestFilter implements RequestFilter {
+	private final static Logger logger = LoggerFactory.getLogger(RateLimitedThrottleRequestFilter.class);
+	private final Semaphore available;
+	private final int maxWaitMs;
+	private final RateLimiter rateLimiter;
+
+	public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond) {
+		this(maxConnections, rateLimitPerSecond, Integer.MAX_VALUE);
+	}
+
+	public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerSecond, int maxWaitMs) {
+		this.maxWaitMs = maxWaitMs;
+		this.rateLimiter = RateLimiter.create(rateLimitPerSecond);
+		available = new Semaphore(maxConnections, true);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+		try {
+			if (logger.isDebugEnabled()) {
+				logger.debug("Current Throttling Status {}", available.availablePermits());
+			}
+
+			long startOfWait = System.currentTimeMillis();
+			attemptConcurrencyPermitAcquistion(ctx);
+
+			attemptRateLimitedPermitAcquistion(ctx, startOfWait);
+		} catch (InterruptedException e) {
+			throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(),
+					ctx.getAsyncHandler()));
+		}
+
+		return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(
+				new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available)).build();
+	}
+
+	private <T> void attemptRateLimitedPermitAcquistion(FilterContext<T> ctx, long startOfWait) throws FilterException {
+		long wait = getMillisRemainingInMaxWait(startOfWait);
+
+		if (!rateLimiter.tryAcquire(wait, TimeUnit.MILLISECONDS)) {
+			throw new FilterException(String.format(
+					"Wait for rate limit exceeded during processing Request %s with AsyncHandler %s", ctx.getRequest(),
+					ctx.getAsyncHandler()));
+		}
+	}
+
+	private <T> void attemptConcurrencyPermitAcquistion(FilterContext<T> ctx) throws InterruptedException,
+			FilterException {
+		if (!available.tryAcquire(maxWaitMs, TimeUnit.MILLISECONDS)) {
+			throw new FilterException(String.format("No slot available for processing Request %s with AsyncHandler %s",
+					ctx.getRequest(), ctx.getAsyncHandler()));
+		}
+	}
+
+	private long getMillisRemainingInMaxWait(long startOfWait) {
+		int MINUTE_IN_MILLIS = 60000;
+		long durationLeft = maxWaitMs - (System.currentTimeMillis() - startOfWait);
+		long nonNegativeDuration = Math.max(durationLeft, 0);
+
+		// have to reduce the duration because there is a boundary case inside the Guava
+		// rate limiter where if the duration to wait is near Long.MAX_VALUE, the rate
+		// limiter's internal calculations can exceed Long.MAX_VALUE resulting in a 
+		// negative number which causes the tryAcquire() method to fail unexpectedly
+		if (Long.MAX_VALUE - nonNegativeDuration < MINUTE_IN_MILLIS) {
+			return nonNegativeDuration - MINUTE_IN_MILLIS;
+		}
+
+		return nonNegativeDuration;
+	}
+}
\ No newline at end of file
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
new file mode 100644
index 000000000..c79702732
--- /dev/null
+++ b/extras/jdeferred/pom.xml
@@ -0,0 +1,32 @@
+<!--
+  Copyright 2013 Ray Tsang
+  
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+  
+    http://www.apache.org/licenses/LICENSE-2.0
+  
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <groupId>org.asynchttpclient</groupId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>..</relativePath>
+  </parent>
+  <artifactId>async-http-client-extras-jdeferred</artifactId>
+  <dependencies>
+        <dependency>
+            <groupId>org.jdeferred</groupId>
+            <artifactId>jdeferred-core</artifactId>
+            <version>1.0.0</version>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java
new file mode 100644
index 000000000..570cc739d
--- /dev/null
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/AsyncHttpDeferredObject.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extra;
+
+import java.io.IOException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.jdeferred.Promise;
+import org.jdeferred.impl.DeferredObject;
+
+import org.asynchttpclient.AsyncHttpClient.BoundRequestBuilder;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Response;
+
+public class AsyncHttpDeferredObject extends DeferredObject<Response, Throwable, HttpProgress> {
+	public AsyncHttpDeferredObject(BoundRequestBuilder builder) throws IOException {
+		builder.execute(new AsyncCompletionHandler<Void>() {
+			@Override
+			public Void onCompleted(Response response) throws Exception {
+				AsyncHttpDeferredObject.this.resolve(response);
+				return null;
+			}
+			
+			@Override
+			public void onThrowable(Throwable t) {
+				AsyncHttpDeferredObject.this.reject(t);
+			}
+			
+			@Override
+			public AsyncHandler.STATE onContentWriteProgress(
+					long amount, long current, long total) {
+				AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
+				return super.onContentWriteProgress(amount, current, total);
+			}
+			
+			@Override
+			public AsyncHandler.STATE onBodyPartReceived(
+					HttpResponseBodyPart content) throws Exception {
+				AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
+				return super.onBodyPartReceived(content);
+			}
+		});
+	}
+	
+	public static Promise<Response, Throwable, HttpProgress> promise(final BoundRequestBuilder builder) throws IOException {
+		return new AsyncHttpDeferredObject(builder).promise();
+	}
+}
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java
new file mode 100644
index 000000000..d340a89c6
--- /dev/null
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/ContentWriteProgress.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extra;
+
+public class ContentWriteProgress implements HttpProgress {
+	private final long amount;
+	private final long current;
+	private final long total;
+
+	public ContentWriteProgress(long amount, long current, long total) {
+		this.amount = amount;
+		this.current = current;
+		this.total = total;
+	}
+
+	public long getAmount() {
+		return amount;
+	}
+
+	public long getCurrent() {
+		return current;
+	}
+
+	public long getTotal() {
+		return total;
+	}
+
+	@Override
+	public String toString() {
+		return "ContentWriteProgress [amount=" + amount + ", current="
+				+ current + ", total=" + total + "]";
+	}
+	
+}
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java
new file mode 100644
index 000000000..15af6debb
--- /dev/null
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpProgress.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extra;
+
+public interface HttpProgress {
+
+}
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java
new file mode 100644
index 000000000..16c84e9e1
--- /dev/null
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extra/HttpResponseBodyPartProgress.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extra;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+
+public class HttpResponseBodyPartProgress implements HttpProgress {
+	private final HttpResponseBodyPart part;
+
+	public HttpResponseBodyPartProgress(HttpResponseBodyPart part) {
+		this.part = part;
+	}
+
+	public HttpResponseBodyPart getPart() {
+		return part;
+	}
+	
+	@Override
+	public String toString() {
+		return "HttpResponseBodyPartProgress [part=" + part + "]";
+	}
+}
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
new file mode 100644
index 000000000..b3c2a900b
--- /dev/null
+++ b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2013 Ray Tsang
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.asynchttpclient.extra;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import junit.framework.Assert;
+import junit.framework.TestCase;
+
+import org.asynchttpclient.extra.AsyncHttpDeferredObject;
+import org.asynchttpclient.extra.HttpProgress;
+import org.jdeferred.DoneCallback;
+import org.jdeferred.ProgressCallback;
+import org.jdeferred.Promise;
+import org.jdeferred.impl.DefaultDeferredManager;
+import org.jdeferred.multiple.MultipleResults;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.Response;
+
+public class AsyncHttpTest extends TestCase {
+	protected DefaultDeferredManager deferredManager;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		deferredManager = new DefaultDeferredManager();
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+	}
+
+	public void testPromiseAdapter() throws IOException {
+		final CountDownLatch latch = new CountDownLatch(1);
+		final AtomicInteger successCount = new AtomicInteger();
+		final AtomicInteger progressCount = new AtomicInteger();
+
+		AsyncHttpClient client = new AsyncHttpClient();
+
+		Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject
+				.promise(client.prepareGet("http://www.ning.com"));
+		p1.done(new DoneCallback<Response>() {
+			@Override
+			public void onDone(Response response) {
+				try {
+					Assert.assertEquals(200, response.getStatusCode());
+					successCount.incrementAndGet();
+				} finally {
+					latch.countDown();
+				}
+			}
+		}).progress(new ProgressCallback<HttpProgress>() {
+
+			@Override
+			public void onProgress(HttpProgress progress) {
+				progressCount.incrementAndGet();
+			}
+		});
+
+		try {
+			latch.await();
+			Assert.assertTrue(progressCount.get() > 0);
+		} catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
+		}
+	}
+
+	public void testMultiplePromiseAdapter() throws IOException {
+		final CountDownLatch latch = new CountDownLatch(1);
+		final AtomicInteger successCount = new AtomicInteger();
+
+		AsyncHttpClient client = new AsyncHttpClient();
+
+		Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject
+				.promise(client.prepareGet("http://www.ning.com"));
+		Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject
+				.promise(client.prepareGet("http://www.google.com"));
+		AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(
+				client.prepareGet("http://jdeferred.org"));
+
+		deferredManager.when(p1, p2, deferredRequest).then(
+				new DoneCallback<MultipleResults>() {
+					@Override
+					public void onDone(MultipleResults result) {
+						try {
+							Assert.assertEquals(3, result.size());
+							Assert.assertEquals(200, ((Response) result.get(0)
+									.getResult()).getStatusCode());
+							Assert.assertEquals(200, ((Response) result.get(1)
+									.getResult()).getStatusCode());
+							Assert.assertEquals(200, ((Response) result.get(2)
+									.getResult()).getStatusCode());
+							successCount.incrementAndGet();
+						} finally {
+							latch.countDown();
+						}
+					}
+				});
+
+		try {
+			latch.await();
+		} catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
+		}
+	}
+
+}
diff --git a/extras/pom.xml b/extras/pom.xml
new file mode 100644
index 000000000..281689b29
--- /dev/null
+++ b/extras/pom.xml
@@ -0,0 +1,58 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-project</artifactId>
+        <version>2.0.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-extras-parent</artifactId>
+    <name>Asynchronous Http Client Extras Parent</name>
+    <packaging>pom</packaging>
+    <description>
+        The Async Http Client extras library parent.
+    </description>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <version>2.3.4</version>
+                <extensions>true</extensions>
+                <configuration>
+                    <manifestLocation>META-INF</manifestLocation>
+                    <instructions>
+                        <Bundle-Version>
+                            $(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))
+                        </Bundle-Version>
+                        <Bundle-Vendor>Sonatype</Bundle-Vendor>
+                    </instructions>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>osgi-bundle</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>bundle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+    <modules>
+        <module>guava</module>
+        <module>jdeferred</module>
+    </modules>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-api</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+    </dependencies>
+</project>
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index c475b6ec2..5227949fc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -8,10 +8,10 @@
         <version>5</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
+    <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
     <name>Asynchronous Http Client Project</name>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <packaging>pom</packaging>
     <description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -74,6 +74,11 @@
             <name>Ryan Lubke</name>
             <email>ryan.lubke@gmail.com</email>
         </developer>
+        <developer>
+            <id>slandelle</id>
+            <name>Stephane Landelle</name>
+            <email>slandelle@excilys.com</email>
+        </developer>
     </developers>
     <contributors>
         <contributor>
@@ -92,10 +97,7 @@
         <resources>
             <resource>
                 <filtering>true</filtering>
-                <directory>src/main/java/</directory>
-                <excludes>
-                    <exclude>**/*.java</exclude>
-                </excludes>
+                <directory>src/main/resources/</directory>
             </resource>
         </resources>
         <extensions>
@@ -151,13 +153,13 @@
                 <configuration>
                     <signature>
                         <groupId>org.codehaus.mojo.signature</groupId>
-                        <artifactId>java15</artifactId>
+                        <artifactId>java16</artifactId>
                         <version>1.0</version>
                     </signature>
                 </configuration>
                 <executions>
                     <execution>
-                        <id>check-java-1.5-compat</id>
+                        <id>check-java-1.6-compat</id>
                         <phase>process-classes</phase>
                         <goals>
                             <goal>check</goal>
@@ -300,7 +302,6 @@
                                     <exclude>commons-logging:commons-logging</exclude>
                                     <exclude>junit:junit</exclude>
                                     <exclude>log4j:log4j</exclude>
-                                    <exclude>commons-httpclient:commons-httpclient</exclude>
                                 </excludes>
                             </artifactSet>
                             <transformers>
@@ -490,6 +491,7 @@
     <modules>
         <module>api</module>
         <module>providers</module>
+        <module>extras</module>
         <module>site</module>
     </modules>
     <dependencies>
@@ -497,7 +499,7 @@
         <dependency>
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
-            <version>0.9.26</version>
+            <version>1.0.13</version>
             <scope>test</scope>
         </dependency>
         <dependency>
diff --git a/providers/apache/pom.xml b/providers/apache/pom.xml
deleted file mode 100644
index 5b976d74e..000000000
--- a/providers/apache/pom.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>com.ning</groupId>
-        <artifactId>async-http-client-providers-parent</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
-    <artifactId>async-http-client-apache-provider</artifactId>
-    <name>Asynchronous Http Client Apache Provider</name>
-    <version>1.8.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <description>
-        The Async Http Client Apache Provider.
-    </description>
-
-    <dependencies>
-        <dependency>
-            <groupId>commons-httpclient</groupId>
-            <artifactId>commons-httpclient</artifactId>
-            <version>3.1</version>
-        </dependency>
-        <dependency>
-            <groupId>commons-lang</groupId>
-            <artifactId>commons-lang</artifactId>
-            <version>2.4</version>
-        </dependency>
-        <dependency>
-            <groupId>commons-logging</groupId>
-            <artifactId>commons-logging</artifactId>
-            <version>1.1.1</version>
-        </dependency>
-    </dependencies>
-
-</project>
\ No newline at end of file
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java
deleted file mode 100644
index 2c11ab379..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java
+++ /dev/null
@@ -1,885 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.Body;
-import com.ning.http.client.ByteArrayPart;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FilePart;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.Part;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProgressAsyncHandler;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.StringPart;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.resumable.ResumableAsyncHandler;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.UTF8UrlEncoder;
-import org.apache.commons.httpclient.CircularRedirectException;
-import org.apache.commons.httpclient.Credentials;
-import org.apache.commons.httpclient.DefaultHttpMethodRetryHandler;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.httpclient.NoHttpResponseException;
-import org.apache.commons.httpclient.ProxyHost;
-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.auth.AuthScope;
-import org.apache.commons.httpclient.cookie.CookiePolicy;
-import org.apache.commons.httpclient.methods.ByteArrayRequestEntity;
-import org.apache.commons.httpclient.methods.DeleteMethod;
-import org.apache.commons.httpclient.methods.EntityEnclosingMethod;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.HeadMethod;
-import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
-import org.apache.commons.httpclient.methods.OptionsMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.PutMethod;
-import org.apache.commons.httpclient.methods.StringRequestEntity;
-import org.apache.commons.httpclient.methods.multipart.ByteArrayPartSource;
-import org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;
-import org.apache.commons.httpclient.methods.multipart.PartSource;
-import org.apache.commons.httpclient.params.HttpClientParams;
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.params.HttpMethodParams;
-import org.apache.commons.httpclient.protocol.Protocol;
-import org.apache.commons.httpclient.protocol.ProtocolSocketFactory;
-import org.apache.commons.httpclient.util.IdleConnectionTimeoutThread;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.ConnectException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.zip.GZIPInputStream;
-
-import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-
-
-/**
- * An {@link com.ning.http.client.AsyncHttpProvider} for Apache Http Client 3.1
- */
-public class ApacheAsyncHttpProvider implements AsyncHttpProvider {
-    private final static Logger logger = LoggerFactory.getLogger(ApacheAsyncHttpProvider.class);
-
-    private final AsyncHttpClientConfig config;
-    private final AtomicBoolean isClose = new AtomicBoolean(false);
-    private IdleConnectionTimeoutThread idleConnectionTimeoutThread;
-    private final AtomicInteger maxConnections = new AtomicInteger();
-    private final MultiThreadedHttpConnectionManager connectionManager;
-    private final HttpClientParams params;
-
-    static {
-        final SocketFactory factory = new TrustingSSLSocketFactory();
-        Protocol.registerProtocol("https", new Protocol("https", new ProtocolSocketFactory() {
-            public Socket createSocket(String string, int i, InetAddress inetAddress, int i1) throws IOException {
-                return factory.createSocket(string, i, inetAddress, i1);
-            }
-
-            public Socket createSocket(String string, int i, InetAddress inetAddress, int i1, HttpConnectionParams httpConnectionParams)
-                    throws IOException {
-                return factory.createSocket(string, i, inetAddress, i1);
-            }
-
-            public Socket createSocket(String string, int i) throws IOException {
-                return factory.createSocket(string, i);
-            }
-        }, 443));
-    }
-
-    public ApacheAsyncHttpProvider(AsyncHttpClientConfig config) {
-        this.config = config;
-        connectionManager = new MultiThreadedHttpConnectionManager();
-
-        params = new HttpClientParams();
-        params.setParameter(HttpMethodParams.SINGLE_COOKIE_HEADER, Boolean.TRUE);
-        params.setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);
-        params.setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler());
-
-        AsyncHttpProviderConfig<?, ?> providerConfig = config.getAsyncHttpProviderConfig();
-        if (providerConfig != null && ApacheAsyncHttpProvider.class.isAssignableFrom(providerConfig.getClass())) {
-            configure(ApacheAsyncHttpProviderConfig.class.cast(providerConfig));
-        }
-    }
-
-    private void configure(ApacheAsyncHttpProviderConfig config) {
-    }
-
-    public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException {
-        if (isClose.get()) {
-            throw new IOException("Closed");
-        }
-
-        if (ResumableAsyncHandler.class.isAssignableFrom(handler.getClass())) {
-            request = ResumableAsyncHandler.class.cast(handler).adjustRequestRange(request);
-        }
-
-        if (config.getMaxTotalConnections() > -1 && (maxConnections.get() + 1) > config.getMaxTotalConnections()) {
-            throw new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
-        }
-
-        if (idleConnectionTimeoutThread != null) {
-            idleConnectionTimeoutThread.shutdown();
-            idleConnectionTimeoutThread = null;
-        }
-
-        int requestTimeout = requestTimeout(config, request.getPerRequestConfig());
-        if (config.getIdleConnectionTimeoutInMs() > 0 && requestTimeout != -1 && requestTimeout < config.getIdleConnectionTimeoutInMs()) {
-            idleConnectionTimeoutThread = new IdleConnectionTimeoutThread();
-            idleConnectionTimeoutThread.setConnectionTimeout(config.getIdleConnectionTimeoutInMs());
-            idleConnectionTimeoutThread.addConnectionManager(connectionManager);
-            idleConnectionTimeoutThread.start();
-        }
-
-        HttpClient httpClient = new HttpClient(params, connectionManager);
-
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        if (realm != null) {
-            httpClient.getParams().setAuthenticationPreemptive(realm.getUsePreemptiveAuth());
-            Credentials defaultcreds = new UsernamePasswordCredentials(realm.getPrincipal(), realm.getPassword());
-            httpClient.getState().setCredentials(new AuthScope(null, -1, AuthScope.ANY_REALM), defaultcreds);
-        }
-
-        HttpMethodBase method = createMethod(httpClient, request);
-        ApacheResponseFuture<T> f = new ApacheResponseFuture<T>(handler, requestTimeout, request, method);
-        f.touch();
-
-        f.setInnerFuture(config.executorService().submit(new ApacheClientRunnable<T>(request, handler, method, f, httpClient)));
-        maxConnections.incrementAndGet();
-        return f;
-    }
-
-    public void close() {
-        if (idleConnectionTimeoutThread != null) {
-            idleConnectionTimeoutThread.shutdown();
-            idleConnectionTimeoutThread = null;
-        }
-        if (connectionManager != null) {
-            try {
-                connectionManager.shutdown();
-            } catch (Exception e) {
-                logger.error("Error shutting down connection manager", e);
-            }
-        }
-    }
-
-    public Response prepareResponse(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new ApacheResponse(status, headers, bodyParts);
-    }
-
-    private HttpMethodBase createMethod(HttpClient client, Request request) throws IOException, FileNotFoundException {
-        String methodName = request.getMethod();
-        HttpMethodBase method = null;
-        if (methodName.equalsIgnoreCase("POST") || methodName.equalsIgnoreCase("PUT")) {
-            EntityEnclosingMethod post = methodName.equalsIgnoreCase("POST") ? new PostMethod(request.getUrl()) : new PutMethod(request.getUrl());
-
-            String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
-
-            post.getParams().setContentCharset("ISO-8859-1");
-            if (request.getByteData() != null) {
-                post.setRequestEntity(new ByteArrayRequestEntity(request.getByteData()));
-                post.setRequestHeader("Content-Length", String.valueOf(request.getByteData().length));
-            } else if (request.getStringData() != null) {
-                post.setRequestEntity(new StringRequestEntity(request.getStringData(), "text/xml", bodyCharset));
-                post.setRequestHeader("Content-Length", String.valueOf(request.getStringData().getBytes(bodyCharset).length));
-            } else if (request.getStreamData() != null) {
-                InputStreamRequestEntity r = new InputStreamRequestEntity(request.getStreamData());
-                post.setRequestEntity(r);
-                post.setRequestHeader("Content-Length", String.valueOf(r.getContentLength()));
-
-            } else if (request.getParams() != null) {
-                StringBuilder sb = new StringBuilder();
-                for (final Map.Entry<String, List<String>> paramEntry : request.getParams()) {
-                    final String key = paramEntry.getKey();
-                    for (final String value : paramEntry.getValue()) {
-                        if (sb.length() > 0) {
-                            sb.append("&");
-                        }
-                        UTF8UrlEncoder.appendEncoded(sb, key);
-                        sb.append("=");
-                        UTF8UrlEncoder.appendEncoded(sb, value);
-                    }
-                }
-
-                post.setRequestHeader("Content-Length", String.valueOf(sb.length()));
-                post.setRequestEntity(new StringRequestEntity(sb.toString(), "text/xml", "ISO-8859-1"));
-
-                if (!request.getHeaders().containsKey("Content-Type")) {
-                    post.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
-                }
-            } else if (request.getParts() != null) {
-                MultipartRequestEntity mre = createMultipartRequestEntity(bodyCharset, request.getParts(), post.getParams());
-                post.setRequestEntity(mre);
-                post.setRequestHeader("Content-Type", mre.getContentType());
-                post.setRequestHeader("Content-Length", String.valueOf(mre.getContentLength()));
-            } else if (request.getEntityWriter() != null) {
-                post.setRequestEntity(new EntityWriterRequestEntity(request.getEntityWriter(), computeAndSetContentLength(request, post)));
-            } else if (request.getFile() != null) {
-                File file = request.getFile();
-                if (!file.isFile()) {
-                    throw new IOException(String.format(Thread.currentThread()
-                            + "File %s is not a file or doesn't exist", file.getAbsolutePath()));
-                }
-                post.setRequestHeader("Content-Length", String.valueOf(file.length()));
-
-                FileInputStream fis = new FileInputStream(file);
-                try {
-                    InputStreamRequestEntity r = new InputStreamRequestEntity(fis);
-                    post.setRequestEntity(r);
-                    post.setRequestHeader("Content-Length", String.valueOf(r.getContentLength()));
-                } finally {
-                    fis.close();
-                }
-            } else if (request.getBodyGenerator() != null) {
-                Body body = request.getBodyGenerator().createBody();
-                try {
-                    int length = (int) body.getContentLength();
-                    if (length < 0) {
-                        length = (int) request.getContentLength();
-                    }
-
-                    // TODO: This is suboptimal
-                    if (length >= 0) {
-                        post.setRequestHeader("Content-Length", String.valueOf(length));
-
-                        // This is totally sub optimal
-                        byte[] bytes = new byte[length];
-                        ByteBuffer buffer = ByteBuffer.wrap(bytes);
-                        for (; ; ) {
-                            buffer.clear();
-                            if (body.read(buffer) < 0) {
-                                break;
-                            }
-                        }
-                        post.setRequestEntity(new ByteArrayRequestEntity(bytes));
-                    }
-                } finally {
-                    try {
-                        body.close();
-                    } catch (IOException e) {
-                        logger.warn("Failed to close request body: {}", e.getMessage(), e);
-                    }
-                }
-            }
-
-            String expect = request.getHeaders().getFirstValue("Expect");
-            if (expect != null && expect.equalsIgnoreCase("100-Continue")) {
-                post.setUseExpectHeader(true);
-            }
-            method = post;
-        } else if (methodName.equalsIgnoreCase("DELETE")) {
-            method = new DeleteMethod(request.getUrl());
-        } else if (methodName.equalsIgnoreCase("HEAD")) {
-            method = new HeadMethod(request.getUrl());
-        } else if (methodName.equalsIgnoreCase("GET")) {
-            method = new GetMethod(request.getUrl());
-        } else if (methodName.equalsIgnoreCase("OPTIONS")) {
-            method = new OptionsMethod(request.getUrl());
-        } else {
-            throw new IllegalStateException(String.format("Invalid Method", methodName));
-        }
-
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
-        if (!avoidProxy) {
-
-            if (proxyServer.getPrincipal() != null) {
-                Credentials defaultcreds = new UsernamePasswordCredentials(proxyServer.getPrincipal(), proxyServer.getPassword());
-                client.getState().setCredentials(new AuthScope(null, -1, AuthScope.ANY_REALM), defaultcreds);
-            }
-
-            ProxyHost proxyHost = proxyServer == null ? null : new ProxyHost(proxyServer.getHost(), proxyServer.getPort());
-            client.getHostConfiguration().setProxyHost(proxyHost);
-        }
-        if(request.getLocalAddress()!=null) {
-            client.getHostConfiguration().setLocalAddress(request.getLocalAddress());
-        }
-
-        method.setFollowRedirects(false);
-        Collection<Cookie> cookies = request.getCookies();
-        if ((cookies != null) && !cookies.isEmpty()) {
-            method.setRequestHeader("Cookie", AsyncHttpProviderUtils.encodeCookies(request.getCookies()));
-        }
-
-        if (request.getHeaders() != null) {
-            for (String name : request.getHeaders().keySet()) {
-                if (!"host".equalsIgnoreCase(name)) {
-                    for (String value : request.getHeaders().get(name)) {
-                        method.setRequestHeader(name, value);
-                    }
-                }
-            }
-        }
-
-        String ua = request.getHeaders().getFirstValue("User-Agent");
-        if (ua != null) {
-            method.setRequestHeader("User-Agent", ua);
-        } else if (config.getUserAgent() != null) {
-            method.setRequestHeader("User-Agent", config.getUserAgent());
-        } else {
-            method.setRequestHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(ApacheAsyncHttpProvider.class, config));
-        }
-
-        if (config.isCompressionEnabled()) {
-            Header acceptableEncodingHeader = method.getRequestHeader("Accept-Encoding");
-            if (acceptableEncodingHeader != null) {
-                String acceptableEncodings = acceptableEncodingHeader.getValue();
-                if (acceptableEncodings.indexOf("gzip") == -1) {
-                    StringBuilder buf = new StringBuilder(acceptableEncodings);
-                    if (buf.length() > 1) {
-                        buf.append(",");
-                    }
-                    buf.append("gzip");
-                    method.setRequestHeader("Accept-Encoding", buf.toString());
-                }
-            } else {
-                method.setRequestHeader("Accept-Encoding", "gzip");
-            }
-        }
-
-        if (request.getVirtualHost() != null) {
-
-            String vs = request.getVirtualHost();
-            int index = vs.indexOf(":");
-            if (index > 0) {
-                vs = vs.substring(0, index);
-            }
-            method.getParams().setVirtualHost(vs);
-        }
-
-        return method;
-    }
-
-    private final static int computeAndSetContentLength(Request request, HttpMethodBase m) {
-        int lenght = (int) request.getContentLength();
-        if (lenght == -1 && m.getRequestHeader("Content-Length") != null) {
-            lenght = Integer.valueOf(m.getRequestHeader("Content-Length").getValue());
-        }
-
-        if (lenght != -1) {
-            m.setRequestHeader("Content-Length", String.valueOf(lenght));
-        }
-        return lenght;
-    }
-
-    public class ApacheClientRunnable<T> implements Callable<T> {
-
-        private final AsyncHandler<T> asyncHandler;
-        private HttpMethodBase method;
-        private final ApacheResponseFuture<T> future;
-        private Request request;
-        private final HttpClient httpClient;
-        private int currentRedirectCount;
-        private AtomicBoolean isAuth = new AtomicBoolean(false);
-        private boolean terminate = true;
-
-        public ApacheClientRunnable(Request request, AsyncHandler<T> asyncHandler, HttpMethodBase method, ApacheResponseFuture<T> future, HttpClient httpClient) {
-            this.asyncHandler = asyncHandler;
-            this.method = method;
-            this.future = future;
-            this.request = request;
-            this.httpClient = httpClient;
-        }
-
-        public T call() {
-            terminate = true;
-            AsyncHandler.STATE state = AsyncHandler.STATE.ABORT;
-            try {
-                URI uri = null;
-                try {
-                    uri = AsyncHttpProviderUtils.createUri(request.getRawUrl());
-                } catch (IllegalArgumentException u) {
-                    uri = AsyncHttpProviderUtils.createUri(request.getUrl());
-                }
-
-                int delay = requestTimeout(config, future.getRequest().getPerRequestConfig());
-                if (delay != -1) {
-                    ReaperFuture reaperFuture = new ReaperFuture(future);
-                    Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, delay, 500, TimeUnit.MILLISECONDS);
-                    reaperFuture.setScheduledFuture(scheduledFuture);
-                    future.setReaperFuture(reaperFuture);
-                }
-
-                if (TransferCompletionHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                    throw new IllegalStateException(TransferCompletionHandler.class.getName() + "not supported by this provider");
-                }
-
-                int statusCode = 200;
-                try {
-                    statusCode = httpClient.executeMethod(method);
-                } catch (CircularRedirectException ex) {
-                    // Quite ugly, but this is needed to unify 
-                    statusCode = 302;
-                    currentRedirectCount = config.getMaxRedirects();
-                }
-
-                ApacheResponseStatus status = new ApacheResponseStatus(uri, method, ApacheAsyncHttpProvider.this);
-                FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(asyncHandler).request(request).responseStatus(status).build();
-                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                    fc = asyncFilter.filter(fc);
-                    if (fc == null) {
-                        throw new NullPointerException("FilterContext is null");
-                    }
-                }
-
-                // The request has changed
-                if (fc.replayRequest()) {
-                    request = fc.getRequest();
-                    method = createMethod(httpClient, request);
-                    terminate = false;
-                    return call();
-                }
-
-                logger.debug("\n\nRequest {}\n\nResponse {}\n", request, method);
-
-                boolean redirectEnabled = (request.isRedirectEnabled() || config.isRedirectEnabled());
-                if (redirectEnabled && (statusCode == 302 || statusCode == 301)) {
-
-                    isAuth.set(false);
-
-                    if (currentRedirectCount++ < config.getMaxRedirects()) {
-                        String location = method.getResponseHeader("Location").getValue();
-                        URI rediUri = AsyncHttpProviderUtils.getRedirectUri(uri, location);
-                        String newUrl = rediUri.toString();
-
-                        if (!newUrl.equals(uri.toString())) {
-                            RequestBuilder builder = new RequestBuilder(request);
-
-                            logger.debug("Redirecting to {}", newUrl);
-
-                            request = builder.setUrl(newUrl).build();
-                            method = createMethod(httpClient, request);
-                            terminate = false;
-                            return call();
-                        }
-                    } else {
-                        throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-                    }
-                }
-
-                state = asyncHandler.onStatusReceived(status);
-                if (state == AsyncHandler.STATE.CONTINUE) {
-                    state = asyncHandler.onHeadersReceived(new ApacheResponseHeaders(uri, method, ApacheAsyncHttpProvider.this));
-                }
-
-                if (state == AsyncHandler.STATE.CONTINUE) {
-                    InputStream is = method.getResponseBodyAsStream();
-                    if (is != null) {
-                        Header h = method.getResponseHeader("Content-Encoding");
-                        if (h != null) {
-                            String contentEncoding = h.getValue();
-                            boolean isGZipped = contentEncoding == null ? false : "gzip".equalsIgnoreCase(contentEncoding);
-                            if (isGZipped) {
-                                is = new GZIPInputStream(is);
-                            }
-                        }
-
-                        int byteToRead = (int) method.getResponseContentLength();
-                        InputStream stream = is;
-                        if (byteToRead <= 0) {
-                            int[] lengthWrapper = new int[1];
-                            byte[] bytes = AsyncHttpProviderUtils.readFully(is, lengthWrapper);
-                            stream = new ByteArrayInputStream(bytes, 0, lengthWrapper[0]);
-                            byteToRead = lengthWrapper[0];
-                        }
-
-                        if (byteToRead > 0) {
-                            int minBytes = Math.min(8192, byteToRead);
-                            byte[] bytes = new byte[minBytes];
-                            int leftBytes = minBytes < 8192 ? minBytes : byteToRead;
-                            int read = 0;
-                            while (leftBytes > -1) {
-
-                                try {
-                                    read = stream.read(bytes);
-                                } catch (IOException ex) {
-                                    logger.warn("Connection closed", ex);
-                                    read = -1;
-                                }
-
-                                if (read == -1) {
-                                    break;
-                                }
-
-                                future.touch();
-
-                                byte[] b = new byte[read];
-                                System.arraycopy(bytes, 0, b, 0, read);
-                                leftBytes -= read;
-
-                                asyncHandler.onBodyPartReceived(new ApacheResponseBodyPart(uri, b, ApacheAsyncHttpProvider.this, leftBytes > -1));
-
-                            }
-                        }
-                    }
-
-                    if (method.getName().equalsIgnoreCase("HEAD")) {
-                        asyncHandler.onBodyPartReceived(new ApacheResponseBodyPart(uri, "".getBytes(), ApacheAsyncHttpProvider.this, true));
-                    }
-                }
-
-                if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
-                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
-                }
-
-                try {
-                    return asyncHandler.onCompleted();
-                } catch (Throwable t) {
-                    RuntimeException ex = new RuntimeException();
-                    ex.initCause(t);
-                    throw ex;
-                }
-            } catch (Throwable t) {
-
-                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(asyncHandler)
-                            .request(future.getRequest()).ioException(IOException.class.cast(t)).build();
-
-                    try {
-                        fc = handleIoException(fc);
-                    } catch (FilterException e) {
-                        if (config.getMaxTotalConnections() != -1) {
-                            maxConnections.decrementAndGet();
-                        }
-                        future.done(null);
-                        method.releaseConnection();
-                    }
-
-                    if (fc.replayRequest()) {
-                        request = fc.getRequest();
-                        return call();
-                    }
-                }
-
-                if (method.isAborted()) {
-                    return null;
-                }
-
-                logger.debug(t.getMessage(), t);
-
-                try {
-                    future.abort(filterException(t));
-                } catch (Throwable t2) {
-                    logger.error(t2.getMessage(), t2);
-                }
-            } finally {
-                if (terminate) {
-                    if (config.getMaxTotalConnections() != -1) {
-                        maxConnections.decrementAndGet();
-                    }
-                    future.done(null);
-
-                    // Crappy Apache HttpClient who blocks forever here with large files.
-                    config.executorService().submit(new Runnable() {
-
-                        public void run() {
-                            method.releaseConnection();
-                        }
-                    });
-                }
-            }
-            return null;
-        }
-
-        private Throwable filterException(Throwable t) {
-            if (UnknownHostException.class.isAssignableFrom(t.getClass())) {
-                t = new ConnectException(t.getMessage());
-            }
-
-            if (NoHttpResponseException.class.isAssignableFrom(t.getClass())) {
-                int responseTimeoutInMs = config.getRequestTimeoutInMs();
-
-                if (request.getPerRequestConfig() != null && request.getPerRequestConfig().getRequestTimeoutInMs() != -1) {
-                    responseTimeoutInMs = request.getPerRequestConfig().getRequestTimeoutInMs();
-                }
-                t = new TimeoutException(String.format("No response received after %s", responseTimeoutInMs));
-            }
-
-            if (SSLHandshakeException.class.isAssignableFrom(t.getClass())) {
-                Throwable t2 = new ConnectException();
-                t2.initCause(t);
-                t = t2;
-            }
-
-            return t;
-        }
-
-        private FilterContext<T> handleIoException(FilterContext<T> fc) throws FilterException {
-            for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            }
-            return fc;
-        }
-    }
-
-    private MultipartRequestEntity createMultipartRequestEntity(String charset, List<Part> params, HttpMethodParams methodParams) throws FileNotFoundException {
-        org.apache.commons.httpclient.methods.multipart.Part[] parts = new org.apache.commons.httpclient.methods.multipart.Part[params.size()];
-        int i = 0;
-
-        for (Part part : params) {
-            if (part instanceof StringPart) {
-                parts[i] = new org.apache.commons.httpclient.methods.multipart.StringPart(part.getName(),
-                        ((StringPart) part).getValue(),
-                        charset);
-            } else if (part instanceof FilePart) {
-                parts[i] = new org.apache.commons.httpclient.methods.multipart.FilePart(part.getName(),
-                        ((FilePart) part).getFile(),
-                        ((FilePart) part).getMimeType(),
-                        ((FilePart) part).getCharSet());
-
-            } else if (part instanceof ByteArrayPart) {
-                PartSource source = new ByteArrayPartSource(((ByteArrayPart) part).getFileName(), ((ByteArrayPart) part).getData());
-                parts[i] = new org.apache.commons.httpclient.methods.multipart.FilePart(part.getName(),
-                        source,
-                        ((ByteArrayPart) part).getMimeType(),
-                        ((ByteArrayPart) part).getCharSet());
-
-            } else if (part == null) {
-                throw new NullPointerException("Part cannot be null");
-            } else {
-                throw new IllegalArgumentException(String.format("Unsupported part type for multipart parameter %s",
-                        part.getName()));
-            }
-            ++i;
-        }
-        return new MultipartRequestEntity(parts, methodParams);
-    }
-
-    public class EntityWriterRequestEntity implements org.apache.commons.httpclient.methods.RequestEntity {
-        private Request.EntityWriter entityWriter;
-        private long contentLength;
-
-        public EntityWriterRequestEntity(Request.EntityWriter entityWriter, long contentLength) {
-            this.entityWriter = entityWriter;
-            this.contentLength = contentLength;
-        }
-
-        public long getContentLength() {
-            return contentLength;
-        }
-
-        public String getContentType() {
-            return null;
-        }
-
-        public boolean isRepeatable() {
-            return false;
-        }
-
-        public void writeRequest(OutputStream out) throws IOException {
-            entityWriter.writeEntity(out);
-        }
-    }
-
-    private static class TrustingSSLSocketFactory extends SSLSocketFactory {
-        private SSLSocketFactory delegate;
-
-        private TrustingSSLSocketFactory() {
-            try {
-                SSLContext sslcontext = SSLContext.getInstance("SSL");
-
-                sslcontext.init(null, new TrustManager[]{new TrustEveryoneTrustManager()}, new SecureRandom());
-                delegate = sslcontext.getSocketFactory();
-            } catch (KeyManagementException e) {
-                throw new IllegalStateException();
-            } catch (NoSuchAlgorithmException e) {
-                throw new IllegalStateException();
-            }
-        }
-
-        @Override
-        public Socket createSocket(String s, int i) throws IOException, UnknownHostException {
-            return delegate.createSocket(s, i);
-        }
-
-        @Override
-        public Socket createSocket(String s, int i, InetAddress inetAddress, int i1) throws IOException, UnknownHostException {
-            return delegate.createSocket(s, i, inetAddress, i1);
-        }
-
-        @Override
-        public Socket createSocket(InetAddress inetAddress, int i) throws IOException {
-            return delegate.createSocket(inetAddress, i);
-        }
-
-        @Override
-        public Socket createSocket(InetAddress inetAddress, int i, InetAddress inetAddress1, int i1) throws IOException {
-            return delegate.createSocket(inetAddress, i, inetAddress1, i1);
-        }
-
-        @Override
-        public String[] getDefaultCipherSuites() {
-            return delegate.getDefaultCipherSuites();
-        }
-
-        @Override
-        public String[] getSupportedCipherSuites() {
-            return delegate.getSupportedCipherSuites();
-        }
-
-        @Override
-        public Socket createSocket(Socket socket, String s, int i, boolean b) throws IOException {
-            return delegate.createSocket(socket, s, i, b);
-        }
-    }
-
-    private static class TrustEveryoneTrustManager implements X509TrustManager {
-        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
-            // do nothing
-        }
-
-        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
-            // do nothing
-        }
-
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
-    }
-
-    private final class ReaperFuture implements Future, Runnable {
-        private Future scheduledFuture;
-        private ApacheResponseFuture<?> apacheResponseFuture;
-
-        public ReaperFuture(ApacheResponseFuture<?> apacheResponseFuture) {
-            this.apacheResponseFuture = apacheResponseFuture;
-        }
-
-        public void setScheduledFuture(Future scheduledFuture) {
-            this.scheduledFuture = scheduledFuture;
-        }
-
-        /**
-         * @Override
-         */
-        public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-            //cleanup references to allow gc to reclaim memory independently
-            //of this Future lifecycle
-            this.apacheResponseFuture = null;
-            return this.scheduledFuture.cancel(mayInterruptIfRunning);
-        }
-
-        /**
-         * @Override
-         */
-        public Object get() throws InterruptedException, ExecutionException {
-            return this.scheduledFuture.get();
-        }
-
-        /**
-         * @Override
-         */
-        public Object get(long timeout, TimeUnit unit)
-                throws InterruptedException, ExecutionException,
-                TimeoutException {
-            return this.scheduledFuture.get(timeout, unit);
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isCancelled() {
-            return this.scheduledFuture.isCancelled();
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isDone() {
-            return this.scheduledFuture.isDone();
-        }
-
-        /**
-         * @Override
-         */
-        public synchronized void run() {
-            if (this.apacheResponseFuture != null && this.apacheResponseFuture.hasExpired()) {
-                logger.debug("Request Timeout expired for {}", this.apacheResponseFuture);
-
-                int requestTimeout = config.getRequestTimeoutInMs();
-                PerRequestConfig p = this.apacheResponseFuture.getRequest().getPerRequestConfig();
-                if (p != null && p.getRequestTimeoutInMs() != -1) {
-                    requestTimeout = p.getRequestTimeoutInMs();
-                }
-                apacheResponseFuture.abort(new TimeoutException(String.format("No response received after %s", requestTimeout)));
-
-                this.apacheResponseFuture = null;
-            }
-        }
-    }
-
-    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
-        int result;
-        if (perRequestConfig != null) {
-            int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
-            result = (prRequestTimeout != 0 ? prRequestTimeout : config.getRequestTimeoutInMs());
-        } else {
-            result = config.getRequestTimeoutInMs();
-        }
-        return result;
-    }
-}
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProviderConfig.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProviderConfig.java
deleted file mode 100644
index 8b2aee6d0..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHttpProviderConfig;
-
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-public class ApacheAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, String> {
-
-    private final ConcurrentHashMap<String, String> properties = new ConcurrentHashMap<String, String>();
-
-
-    public AsyncHttpProviderConfig addProperty(String name, String value) {
-        properties.put(name, value);
-        return this;
-    }
-
-    public String getProperty(String name) {
-        return properties.get(name);
-    }
-
-    public String removeProperty(String name) {
-        return properties.remove(name);
-    }
-
-    public Set<Map.Entry<String, String>> propertiesSet() {
-        return properties.entrySet();
-    }
-}
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java
deleted file mode 100644
index 43059dee7..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.Cookie;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.providers.ResponseBase;
-import com.ning.http.util.AsyncHttpProviderUtils;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-public class ApacheResponse extends ResponseBase {
-
-	public ApacheResponse(HttpResponseStatus status,
-                          HttpResponseHeaders headers,
-                          List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
-    }
-
-    /* @Override */
-
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, DEFAULT_CHARSET);
-    }
-
-    /* @Override */
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        charset = calculateCharset(charset);
-        String response = AsyncHttpProviderUtils.contentToString(bodyParts, charset);
-        return response.length() <= maxLength ? response : response.substring(0, maxLength);
-    }
-
-    /* @Override */
-    public List<Cookie> buildCookies() {
-    	List<Cookie> cookies = new ArrayList<Cookie>();
-        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                // TODO: ask for parsed header
-                List<String> v = header.getValue();
-                for (String value : v) {
-                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                    cookies.add(cookie);
-                }
-            }
-        }
-        return Collections.unmodifiableList(cookies);
-    }
-}
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseBodyPart.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseBodyPart.java
deleted file mode 100644
index de26208d1..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseBodyPart.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseBodyPart;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URI;
-import java.nio.ByteBuffer;
-
-/**
- * A callback class used when an HTTP response body is received.
- */
-public class ApacheResponseBodyPart extends HttpResponseBodyPart {
-
-    private final byte[] chunk;
-    private final boolean isLast;
-    private boolean closeConnection;
-
-    public ApacheResponseBodyPart(URI uri, byte[] chunk, AsyncHttpProvider provider, boolean last) {
-        super(uri, provider);
-        this.chunk = chunk;
-        isLast = last;
-    }
-
-    /**
-     * Return the response body's part bytes received.
-     *
-     * @return the response body's part bytes received.
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        return chunk;
-    }
-
-    @Override
-    public InputStream readBodyPartBytes() {
-        return new ByteArrayInputStream(chunk);
-    }
-
-    @Override
-    public int length() {
-        return chunk.length;
-    }
-    
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-        outputStream.write(chunk);
-        return chunk.length;
-    }
-
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return ByteBuffer.wrap(chunk);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isLast() {
-        return isLast;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsClosed() {
-        closeConnection = true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean closeUnderlyingConnection() {
-        return closeConnection;
-    }
-}
\ No newline at end of file
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseFuture.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseFuture.java
deleted file mode 100644
index 0b8abff3e..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseFuture.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.Request;
-import com.ning.http.client.listenable.AbstractListenableFuture;
-import org.apache.commons.httpclient.HttpMethodBase;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-
-public class ApacheResponseFuture<V> extends AbstractListenableFuture<V> {
-
-    private final static Logger logger = LoggerFactory.getLogger(ApacheResponseFuture.class);
-
-    private Future<V> innerFuture;
-    private final AsyncHandler<V> asyncHandler;
-    private final int responseTimeoutInMs;
-    private final AtomicBoolean cancelled = new AtomicBoolean(false);
-    private final AtomicBoolean timedOut = new AtomicBoolean(false);
-    private final AtomicBoolean isDone = new AtomicBoolean(false);
-    private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
-    private final AtomicLong touch = new AtomicLong(System.currentTimeMillis());
-    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    private final Request request;
-    private final HttpMethodBase method;
-    private Future<?> reaperFuture;
-    private boolean writeHeaders;
-    private boolean writeBody;
-
-    public ApacheResponseFuture(AsyncHandler<V> asyncHandler, int responseTimeoutInMs, Request request, HttpMethodBase method) {
-        this.asyncHandler = asyncHandler;
-        this.responseTimeoutInMs = responseTimeoutInMs == -1 ? Integer.MAX_VALUE : responseTimeoutInMs;
-        this.request = request;
-        this.method = method;
-        writeHeaders = true;
-        writeBody = true;
-    }
-
-    protected void setInnerFuture(Future<V> innerFuture) {
-        this.innerFuture = innerFuture;
-    }
-
-    public void done(Callable callable) {
-        isDone.set(true);
-        if (reaperFuture != null) {
-            reaperFuture.cancel(true);
-        }
-        super.done();
-    }
-
-    /**
-     * TODO.
-     *
-     * @param v The new content
-     */
-    public void content(V v) {
-    }
-
-    protected void setReaperFuture(Future<?> reaperFuture) {
-        if (this.reaperFuture != null) {
-            this.reaperFuture.cancel(true);
-        }
-        this.reaperFuture = reaperFuture;
-    }
-
-    @Override
-    public String toString() {
-        return "ApacheResponseFuture{" +
-                "innerFuture=" + innerFuture +
-                ", asyncHandler=" + asyncHandler +
-                ", responseTimeoutInMs=" + responseTimeoutInMs +
-                ", cancelled=" + cancelled +
-                ", timedOut=" + timedOut +
-                ", isDone=" + isDone +
-                ", exception=" + exception +
-                ", touch=" + touch +
-                ", contentProcessed=" + contentProcessed +
-                ", request=" + request +
-                ", method=" + method +
-                ", reaperFuture=" + reaperFuture +
-                '}';
-    }
-
-    public void abort(Throwable t) {
-        exception.set(t);
-        if (innerFuture != null) {
-            innerFuture.cancel(true);
-        }
-
-        if (method != null) {
-            method.abort();
-        }
-
-        if (reaperFuture != null) {
-            reaperFuture.cancel(true);
-        }
-        if (!timedOut.get() && !cancelled.get()) {
-            try {
-                asyncHandler.onThrowable(t);
-            } catch (Throwable t2) {
-                logger.debug("asyncHandler.onThrowable", t2);
-            }
-        }
-        super.done();
-    }
-
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        if (!cancelled.get() && innerFuture != null) {
-            method.abort();
-            try {
-                asyncHandler.onThrowable(new CancellationException());
-            } catch (Throwable t) {
-                logger.debug("asyncHandler.onThrowable", t);
-            }
-            cancelled.set(true);
-            if (reaperFuture != null) {
-                reaperFuture.cancel(true);
-            }
-            super.done();
-            return innerFuture.cancel(mayInterruptIfRunning);
-        } else {
-            super.done();
-            return false;
-        }
-    }
-
-    public boolean isCancelled() {
-        if (innerFuture != null) {
-            return innerFuture.isCancelled();
-        } else {
-            return false;
-        }
-    }
-
-    public boolean isDone() {
-        contentProcessed.set(true);
-        return innerFuture.isDone();
-    }
-
-    public V get() throws InterruptedException, ExecutionException {
-        try {
-            return get(responseTimeoutInMs, TimeUnit.MILLISECONDS);
-        } catch (TimeoutException e) {
-            throw new ExecutionException(e);
-        }
-    }
-
-    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        V content = null;
-        try {
-            if (innerFuture != null) {
-                content = innerFuture.get(timeout, unit);
-            }
-        } catch (TimeoutException t) {
-            if (!contentProcessed.get() && timeout != -1 && ((System.currentTimeMillis() - touch.get()) <= responseTimeoutInMs)) {
-                return get(timeout, unit);
-            }
-
-            if (exception.get() == null) {
-                timedOut.set(true);
-                throw new ExecutionException(new TimeoutException(String.format("No response received after %s", responseTimeoutInMs)));
-            }
-        } catch (CancellationException ce) {
-        }
-
-        if (exception.get() != null) {
-            throw new ExecutionException(exception.get());
-        }
-        return content;
-    }
-
-    /**
-     * Is the Future still valid
-     *
-     * @return <code>true</code> if response has expired and should be terminated.
-     */
-    public boolean hasExpired() {
-        return responseTimeoutInMs != -1 && ((System.currentTimeMillis() - touch.get()) >= responseTimeoutInMs);
-    }
-
-    public void touch() {
-        touch.set(System.currentTimeMillis());
-    }
-
-    public Request getRequest() {
-        return request;
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
-        boolean b = this.writeHeaders;
-        this.writeHeaders = writeHeaders;
-        return b;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean getAndSetWriteBody(boolean writeBody) {
-        boolean b = this.writeBody;
-        this.writeBody = writeBody;
-        return b;
-    }
-}
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseHeaders.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseHeaders.java
deleted file mode 100644
index 1940f4c97..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseHeaders.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseHeaders;
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpMethodBase;
-
-import java.net.URI;
-
-/**
- * A class that represent the HTTP headers.
- */
-public class ApacheResponseHeaders extends HttpResponseHeaders {
-
-    private final HttpMethodBase method;
-    private final FluentCaseInsensitiveStringsMap headers;
-
-    public ApacheResponseHeaders(URI uri, HttpMethodBase method, AsyncHttpProvider provider) {
-        super(uri, provider, false);
-        this.method = method;
-        headers = computerHeaders();
-    }
-
-    private FluentCaseInsensitiveStringsMap computerHeaders() {
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-
-        Header[] uh = method.getResponseHeaders();
-
-        for (Header e : uh) {
-            if (e.getName() != null) {
-                h.add(e.getName(), e.getValue());
-            }
-        }
-
-        uh = method.getResponseFooters();
-        for (Header e : uh) {
-            if (e.getName() != null) {
-                h.add(e.getName(), e.getValue());
-            }
-        }
-
-        return h;
-    }
-
-    /**
-     * Return the HTTP header
-     *
-     * @return an {@link com.ning.http.client.FluentCaseInsensitiveStringsMap}
-     */
-    @Override
-    public FluentCaseInsensitiveStringsMap getHeaders() {
-        return headers;
-    }
-}
\ No newline at end of file
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseStatus.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseStatus.java
deleted file mode 100644
index 64702c75a..000000000
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponseStatus.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.apache;
-
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseStatus;
-import org.apache.commons.httpclient.HttpMethodBase;
-
-import java.net.URI;
-
-/**
- * A class that represent the HTTP response' status line (code + text)
- */
-public class ApacheResponseStatus extends HttpResponseStatus {
-
-    private final HttpMethodBase method;
-
-    public ApacheResponseStatus(URI uri, HttpMethodBase method, AsyncHttpProvider provider) {
-        super(uri, provider);
-        this.method = method;
-    }
-
-    /**
-     * Return the response status code
-     *
-     * @return the response status code
-     */
-    public int getStatusCode() {
-        return method.getStatusCode();
-    }
-
-    /**
-     * Return the response status text
-     *
-     * @return the response status text
-     */
-    public String getStatusText() {
-        return method.getStatusText();
-    }
-
-    @Override
-    public String getProtocolName() {
-        return method.getStatusLine().getHttpVersion();
-    }
-
-    @Override
-    public int getProtocolMajorVersion() {
-        return 1; //TODO
-    }
-
-    @Override
-    public int getProtocolMinorVersion() {
-        return 1; //TODO
-    }
-
-    @Override
-    public String getProtocolText() {
-        return ""; //TODO
-    }
-
-}
\ No newline at end of file
diff --git a/providers/grizzly/pom.xml b/providers/grizzly/pom.xml
index b46943723..57f9ed182 100644
--- a/providers/grizzly/pom.xml
+++ b/providers/grizzly/pom.xml
@@ -2,33 +2,43 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
-        <groupId>com.ning</groupId>
+        <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-providers-parent</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
+        <version>2.0.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
     <artifactId>async-http-client-grizzly-provider</artifactId>
     <name>Asynchronous Http Client Grizzly Provider</name>
-    <version>1.8.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
     <description>
         The Async Http Client Grizzly Provider.
     </description>
 
+    <properties>
+        <grizzly.version>2.3.4-SNAPSHOT</grizzly.version>
+        <grizzly.npn.version>1.0</grizzly.npn.version>
+    </properties>
+
     <dependencies>
         <dependency>
             <groupId>org.glassfish.grizzly</groupId>
             <artifactId>grizzly-websockets</artifactId>
-            <version>2.3-beta8</version>
+            <version>${grizzly.version}</version>
         </dependency>
         <dependency>
-                   <groupId>com.ning</groupId>
-                   <artifactId>async-http-client-api</artifactId>
-                   <version>${project.version}</version>
-                   <scope>test</scope>
-                   <classifier>tests</classifier>
-               </dependency>
+            <groupId>org.glassfish.grizzly</groupId>
+            <artifactId>grizzly-spdy</artifactId>
+            <version>${grizzly.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.grizzly</groupId>
+            <artifactId>connection-pool</artifactId>
+            <version>${grizzly.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.grizzly</groupId>
+            <artifactId>grizzly-npn-api</artifactId>
+            <version>${grizzly.npn.version}</version>
+        </dependency>
     </dependencies>
 
     <repositories>
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
deleted file mode 100644
index 0ec44f4f3..000000000
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ /dev/null
@@ -1,2939 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package com.ning.http.client.providers.grizzly;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.FluentStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.Part;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.UpgradeHandler;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.websocket.WebSocket;
-import com.ning.http.client.websocket.WebSocketByteListener;
-import com.ning.http.client.websocket.WebSocketCloseCodeReasonListener;
-import com.ning.http.client.websocket.WebSocketListener;
-import com.ning.http.client.websocket.WebSocketPingListener;
-import com.ning.http.client.websocket.WebSocketPongListener;
-import com.ning.http.client.websocket.WebSocketTextListener;
-import com.ning.http.client.websocket.WebSocketUpgradeHandler;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
-
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.EmptyCompletionHandler;
-import org.glassfish.grizzly.FileTransfer;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.WriteResult;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.attributes.AttributeStorage;
-import org.glassfish.grizzly.filterchain.BaseFilter;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.filterchain.TransportFilter;
-import org.glassfish.grizzly.http.ContentEncoding;
-import org.glassfish.grizzly.http.EncodingFilter;
-import org.glassfish.grizzly.http.GZipContentEncoding;
-import org.glassfish.grizzly.http.HttpClientFilter;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.Method;
-import org.glassfish.grizzly.http.Protocol;
-import org.glassfish.grizzly.impl.FutureImpl;
-import org.glassfish.grizzly.utils.Charsets;
-import org.glassfish.grizzly.http.util.CookieSerializerUtils;
-import org.glassfish.grizzly.http.util.DataChunk;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.http.util.HttpStatus;
-import org.glassfish.grizzly.http.util.MimeHeaders;
-import org.glassfish.grizzly.impl.SafeFutureImpl;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.nio.transport.TCPNIOConnectorHandler;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransportBuilder;
-import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
-import org.glassfish.grizzly.ssl.SSLFilter;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
-import org.glassfish.grizzly.strategies.WorkerThreadIOStrategy;
-import org.glassfish.grizzly.utils.BufferOutputStream;
-import org.glassfish.grizzly.utils.DelayedExecutor;
-import org.glassfish.grizzly.utils.Futures;
-import org.glassfish.grizzly.utils.IdleTimeoutFilter;
-import org.glassfish.grizzly.websockets.DataFrame;
-import org.glassfish.grizzly.websockets.DefaultWebSocket;
-import org.glassfish.grizzly.websockets.HandShake;
-import org.glassfish.grizzly.websockets.HandshakeException;
-import org.glassfish.grizzly.websockets.ProtocolHandler;
-import org.glassfish.grizzly.websockets.Version;
-import org.glassfish.grizzly.websockets.WebSocketEngine;
-import org.glassfish.grizzly.websockets.WebSocketFilter;
-import org.glassfish.grizzly.websockets.draft06.ClosingFrame;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.SSLContext;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.InetSocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URLEncoder;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
-
-/**
- * A Grizzly 2.0-based implementation of {@link AsyncHttpProvider}.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-@SuppressWarnings("rawtypes")
-public class GrizzlyAsyncHttpProvider implements AsyncHttpProvider {
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(GrizzlyAsyncHttpProvider.class);
-    private static final boolean SEND_FILE_SUPPORT;
-    static {
-        SEND_FILE_SUPPORT = /*configSendFileSupport();*/ false;
-    }
-    private final Attribute<HttpTransactionContext> REQUEST_STATE_ATTR =
-            Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(HttpTransactionContext.class.getName());
-
-    private final BodyHandlerFactory bodyHandlerFactory = new BodyHandlerFactory();
-
-    private final TCPNIOTransport clientTransport;
-    private final AsyncHttpClientConfig clientConfig;
-    private final ConnectionManager connectionManager;
-
-    DelayedExecutor.Resolver<Connection> resolver;
-    private DelayedExecutor timeoutExecutor;
-
-
-
-
-    // ------------------------------------------------------------ Constructors
-
-
-    public GrizzlyAsyncHttpProvider(final AsyncHttpClientConfig clientConfig) {
-
-        this.clientConfig = clientConfig;
-        final TCPNIOTransportBuilder builder = TCPNIOTransportBuilder.newInstance();
-        clientTransport = builder.build();
-        initializeTransport(clientConfig);
-        connectionManager = new ConnectionManager(this, clientTransport);
-        try {
-            clientTransport.start();
-        } catch (IOException ioe) {
-            throw new RuntimeException(ioe);
-        }
-
-    }
-
-
-    // ------------------------------------------ Methods from AsyncHttpProvider
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public <T> ListenableFuture<T> execute(final Request request,
-            final AsyncHandler<T> handler) throws IOException {
-
-        final GrizzlyResponseFuture<T> future =
-                new GrizzlyResponseFuture<T>(this, request, handler);
-        future.setDelegate(SafeFutureImpl.<T>create());
-        final CompletionHandler<Connection>  connectHandler = new CompletionHandler<Connection>() {
-            @Override
-            public void cancelled() {
-                future.cancel(true);
-            }
-
-            @Override
-            public void failed(final Throwable throwable) {
-                future.abort(throwable);
-            }
-
-            @Override
-            public void completed(final Connection c) {
-                try {
-                    execute(c, request, handler, future);
-                } catch (Exception e) {
-                    if (e instanceof RuntimeException) {
-                        failed(e);
-                    } else if (e instanceof IOException) {
-                        failed(e);
-                    }
-                    if (LOGGER.isWarnEnabled()) {
-                        LOGGER.warn(e.toString(), e);
-                    }
-                }
-            }
-
-            @Override
-            public void updated(final Connection c) {
-                // no-op
-            }
-        };
-
-        try {
-            connectionManager.doAsyncTrackedConnection(request, future, connectHandler);
-        } catch (Exception e) {
-            if (e instanceof RuntimeException) {
-                throw (RuntimeException) e;
-            } else if (e instanceof IOException) {
-                throw (IOException) e;
-            }
-            if (LOGGER.isWarnEnabled()) {
-                LOGGER.warn(e.toString(), e);
-            }
-        }
-
-        return future;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void close() {
-
-        try {
-            connectionManager.destroy();
-            clientTransport.stop();
-            final ExecutorService service = clientConfig.executorService();
-            if (service != null) {
-                service.shutdown();
-            }
-            if (timeoutExecutor != null) {
-                timeoutExecutor.stop();
-            }
-        } catch (IOException ignored) { }
-
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public Response prepareResponse(HttpResponseStatus status,
-                                    HttpResponseHeaders headers,
-                                    List<HttpResponseBodyPart> bodyParts) {
-
-        return new GrizzlyResponse(status, headers, bodyParts);
-
-    }
-
-
-    // ------------------------------------------------------- Protected Methods
-
-
-    @SuppressWarnings({"unchecked"})
-    protected <T> ListenableFuture<T> execute(final Connection c,
-                                              final Request request,
-                                              final AsyncHandler<T> handler,
-                                              final GrizzlyResponseFuture<T> future)
-    throws IOException {
-
-        try {
-            if (getHttpTransactionContext(c) == null) {
-                setHttpTransactionContext(c,
-                        new HttpTransactionContext(future, request, handler));
-            }
-            c.write(request, createWriteCompletionHandler(future));
-        } catch (Exception e) {
-            if (e instanceof RuntimeException) {
-                throw (RuntimeException) e;
-            } else if (e instanceof IOException) {
-                throw (IOException) e;
-            }
-            if (LOGGER.isWarnEnabled()) {
-                LOGGER.warn(e.toString(), e);
-            }
-        }
-
-        return future;
-    }
-
-
-    protected void initializeTransport(final AsyncHttpClientConfig clientConfig) {
-
-        final FilterChainBuilder fcb = FilterChainBuilder.stateless();
-        fcb.add(new AsyncHttpClientTransportFilter());
-
-        final int timeout = clientConfig.getRequestTimeoutInMs();
-        if (timeout > 0) {
-            int delay = 500;
-            if (timeout < delay) {
-                delay = timeout - 10;
-                if (delay <= 0) {
-                    delay = timeout;
-                }
-            }
-            timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
-            timeoutExecutor.start();
-            final IdleTimeoutFilter.TimeoutResolver timeoutResolver =
-                    new IdleTimeoutFilter.TimeoutResolver() {
-                        @Override
-                        public long getTimeout(FilterChainContext ctx) {
-                            final HttpTransactionContext context =
-                                    GrizzlyAsyncHttpProvider.this.getHttpTransactionContext(ctx.getConnection());
-                            if (context != null) {
-                                if (context.isWSRequest) {
-                                    return clientConfig.getWebSocketIdleTimeoutInMs();
-                                }
-                                final PerRequestConfig config = context.request.getPerRequestConfig();
-                                if (config != null) {
-                                    final long timeout = config.getRequestTimeoutInMs();
-                                    if (timeout > 0) {
-                                        return timeout;
-                                    }
-                                }
-                            }
-                            return timeout;
-                        }
-                    };
-            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor,
-                    timeoutResolver,
-                    new IdleTimeoutFilter.TimeoutHandler() {
-                        public void onTimeout(Connection connection) {
-                            timeout(connection);
-                        }
-                    });
-            fcb.add(timeoutFilter);
-            resolver = timeoutFilter.getResolver();
-        }
-
-        SSLContext context = clientConfig.getSSLContext();
-        boolean defaultSecState = (context != null);
-        if (context == null) {
-            try {
-                context = SslUtils.getSSLContext();
-            } catch (Exception e) {
-                throw new IllegalStateException(e);
-            }
-        }
-        final SSLEngineConfigurator configurator =
-                new SSLEngineConfigurator(context,
-                        true,
-                        false,
-                        false);
-        final SwitchingSSLFilter filter = new SwitchingSSLFilter(configurator, defaultSecState);
-        fcb.add(filter);
-        GrizzlyAsyncHttpProviderConfig providerConfig =
-                        (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
-        final AsyncHttpClientEventFilter eventFilter;
-        if (providerConfig != null) {
-            eventFilter = new AsyncHttpClientEventFilter(this, (Integer) providerConfig.getProperty(MAX_HTTP_PACKET_HEADER_SIZE));
-        } else {
-            eventFilter = new AsyncHttpClientEventFilter(this);
-        }
-        final AsyncHttpClientFilter clientFilter =
-                new AsyncHttpClientFilter(clientConfig);
-        ContentEncoding[] encodings = eventFilter.getContentEncodings();
-        if (encodings.length > 0) {
-            for (ContentEncoding encoding : encodings) {
-                eventFilter.removeContentEncoding(encoding);
-            }
-        }
-        if (clientConfig.isCompressionEnabled()) {
-            eventFilter.addContentEncoding(
-                    new GZipContentEncoding(512,
-                                            512,
-                                            new ClientEncodingFilter()));
-        }
-        fcb.add(eventFilter);
-        fcb.add(clientFilter);
-        
-        if (providerConfig != null) {
-            final TransportCustomizer customizer = (TransportCustomizer)
-                    providerConfig.getProperty(TRANSPORT_CUSTOMIZER);
-            if (customizer != null) {
-                customizer.customize(clientTransport, fcb);
-            } else {
-                doDefaultTransportConfig();
-            }
-        } else {
-            doDefaultTransportConfig();
-        }
-        fcb.add(new WebSocketFilter());
-        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(-1);
-        clientTransport.setProcessor(fcb.build());
-
-    }
-
-
-    // ------------------------------------------------- Package Private Methods
-
-
-    void touchConnection(final Connection c, final Request request) {
-
-        final PerRequestConfig config = request.getPerRequestConfig();
-        if (config != null) {
-            final long timeout = config.getRequestTimeoutInMs();
-            if (timeout > 0) {
-                final long newTimeout = System.currentTimeMillis() + timeout;
-                if (resolver != null) {
-                    resolver.setTimeoutMillis(c, newTimeout);
-                }
-            }
-        } else {
-            final long timeout = clientConfig.getRequestTimeoutInMs();
-            if (timeout > 0) {
-                if (resolver != null) {
-                    resolver.setTimeoutMillis(c, System.currentTimeMillis() + timeout);
-                }
-            }
-        }
-
-    }
-
-
-    // --------------------------------------------------------- Private Methods
-
-
-    private static boolean configSendFileSupport() {
-
-        return !((System.getProperty("os.name").equalsIgnoreCase("linux")
-                && !linuxSendFileSupported())
-                || System.getProperty("os.name").equalsIgnoreCase("HP-UX"));
-    }
-
-
-    private static boolean linuxSendFileSupported() {
-        final String version = System.getProperty("java.version");
-        if (version.startsWith("1.6")) {
-            int idx = version.indexOf('_');
-            if (idx == -1) {
-                return false;
-            }
-            final int patchRev = Integer.parseInt(version.substring(idx + 1));
-            return (patchRev >= 18);
-        } else {
-            return version.startsWith("1.7") || version.startsWith("1.8");
-        }
-    }
-    
-    private void doDefaultTransportConfig() {
-        final ExecutorService service = clientConfig.executorService();
-        if (service != null) {
-            clientTransport.setIOStrategy(WorkerThreadIOStrategy.getInstance());
-            clientTransport.setWorkerThreadPool(service);
-        } else {
-            clientTransport.setIOStrategy(SameThreadIOStrategy.getInstance());
-        }
-    }
-
-    private <T> CompletionHandler<WriteResult> createWriteCompletionHandler(final GrizzlyResponseFuture<T> future) {
-        return new CompletionHandler<WriteResult>() {
-
-            public void cancelled() {
-                future.cancel(true);
-            }
-
-            public void failed(Throwable throwable) {
-                future.abort(throwable);
-            }
-
-            public void completed(WriteResult result) {
-            }
-
-            public void updated(WriteResult result) {
-                // no-op
-            }
-
-        };
-    }
-
-
-    void setHttpTransactionContext(final AttributeStorage storage,
-                                           final HttpTransactionContext httpTransactionState) {
-
-        if (httpTransactionState == null) {
-            REQUEST_STATE_ATTR.remove(storage);
-        } else {
-            REQUEST_STATE_ATTR.set(storage, httpTransactionState);
-        }
-
-    }
-
-    HttpTransactionContext getHttpTransactionContext(final AttributeStorage storage) {
-
-        return REQUEST_STATE_ATTR.get(storage);
-
-    }
-
-
-    void timeout(final Connection c) {
-
-        final HttpTransactionContext context = getHttpTransactionContext(c);
-        setHttpTransactionContext(c, null);
-        context.abort(new TimeoutException("Timeout exceeded"));
-
-    }
-
-    static int getPort(final URI uri, final int p) {
-        int port = p;
-        if (port == -1) {
-            final String protocol = uri.getScheme().toLowerCase();
-            if ("http".equals(protocol) || "ws".equals(protocol)) {
-                port = 80;
-            } else if ("https".equals(protocol) || "wss".equals(protocol)) {
-                port = 443;
-            } else {
-                throw new IllegalArgumentException("Unknown protocol: " + protocol);
-            }
-        }
-        return port;
-    }
-
-
-    @SuppressWarnings({"unchecked"})
-    boolean sendRequest(final FilterChainContext ctx,
-                     final Request request,
-                     final HttpRequestPacket requestPacket)
-    throws IOException {
-
-        boolean isWriteComplete = true;
-        
-        if (requestHasEntityBody(request)) {
-            final HttpTransactionContext context = getHttpTransactionContext(ctx.getConnection());
-            BodyHandler handler = bodyHandlerFactory.getBodyHandler(request);
-            if (requestPacket.getHeaders().contains(Header.Expect)
-                    && requestPacket.getHeaders().getValue(1).equalsIgnoreCase("100-Continue")) {
-                handler = new ExpectHandler(handler);
-            }
-            context.bodyHandler = handler;
-            isWriteComplete = handler.doHandle(ctx, request, requestPacket);
-        } else {
-            ctx.write(requestPacket, ctx.getTransportContext().getCompletionHandler());
-        }
-        LOGGER.debug("REQUEST: {}", requestPacket);
-        
-        return isWriteComplete;
-    }
-
-
-    private static boolean requestHasEntityBody(final Request request) {
-
-        final String method = request.getMethod();
-        return (Method.POST.matchesMethod(method)
-                || Method.PUT.matchesMethod(method)
-                || Method.PATCH.matchesMethod(method)
-                || Method.DELETE.matchesMethod(method));
-
-    }
-
-
-    // ----------------------------------------------------------- Inner Classes
-
-
-    private interface StatusHandler {
-
-        public enum InvocationStatus {
-            CONTINUE,
-            STOP
-        }
-
-        boolean handleStatus(final HttpResponsePacket httpResponse,
-                             final HttpTransactionContext httpTransactionContext,
-                             final FilterChainContext ctx);
-
-        boolean handlesStatus(final int statusCode);
-
-    } // END StatusHandler
-
-
-    final class HttpTransactionContext {
-
-        final AtomicInteger redirectCount = new AtomicInteger(0);
-
-        final int maxRedirectCount;
-        final boolean redirectsAllowed;
-        final GrizzlyAsyncHttpProvider provider =
-                GrizzlyAsyncHttpProvider.this;
-
-        Request request;
-        String requestUrl;
-        AsyncHandler handler;
-        BodyHandler bodyHandler;
-        StatusHandler statusHandler;
-        StatusHandler.InvocationStatus invocationStatus =
-                StatusHandler.InvocationStatus.CONTINUE;
-        GrizzlyResponseStatus responseStatus;
-        GrizzlyResponseFuture future;
-        String lastRedirectURI;
-        AtomicLong totalBodyWritten = new AtomicLong();
-        AsyncHandler.STATE currentState;
-        
-        String wsRequestURI;
-        boolean isWSRequest;
-        HandShake handshake;
-        ProtocolHandler protocolHandler;
-        WebSocket webSocket;
-        boolean establishingTunnel;
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        HttpTransactionContext(final GrizzlyResponseFuture future,
-                               final Request request,
-                               final AsyncHandler handler) {
-
-            this.future = future;
-            this.request = request;
-            this.handler = handler;
-            redirectsAllowed = provider.clientConfig.isRedirectEnabled();
-            maxRedirectCount = provider.clientConfig.getMaxRedirects();
-            this.requestUrl = request.getUrl();
-
-        }
-
-
-        // ----------------------------------------------------- Private Methods
-
-
-        HttpTransactionContext copy() {
-            final HttpTransactionContext newContext =
-                    new HttpTransactionContext(future,
-                                               request,
-                                               handler);
-            newContext.invocationStatus = invocationStatus;
-            newContext.bodyHandler = bodyHandler;
-            newContext.currentState = currentState;
-            newContext.statusHandler = statusHandler;
-            newContext.lastRedirectURI = lastRedirectURI;
-            newContext.redirectCount.set(redirectCount.get());
-            return newContext;
-
-        }
-
-
-        void abort(final Throwable t) {
-            if (future != null) {
-                future.abort(t);
-            }
-        }
-
-        void done(final Callable c) {
-            if (future != null) {
-                future.done(c);
-            }
-        }
-
-        @SuppressWarnings({"unchecked"})
-        void result(Object result) {
-            if (future != null) {
-                future.delegate.result(result);
-                future.done(null);
-            }
-        }
-
-        boolean isTunnelEstablished(final Connection c) {
-            return c.getAttributes().getAttribute("tunnel-established") != null;
-        }
-
-
-        void tunnelEstablished(final Connection c) {
-            c.getAttributes().setAttribute("tunnel-established", Boolean.TRUE);
-        }
-
-
-    } // END HttpTransactionContext
-
-
-    // ---------------------------------------------------------- Nested Classes
-
-    private static final class ContinueEvent implements FilterChainEvent {
-
-        private final HttpTransactionContext context;
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        ContinueEvent(final HttpTransactionContext context) {
-
-            this.context = context;
-
-        }
-
-
-        // --------------------------------------- Methods from FilterChainEvent
-
-
-        @Override
-        public Object type() {
-            return ContinueEvent.class;
-        }
-
-    } // END ContinueEvent
-
-
-    private final class AsyncHttpClientTransportFilter extends TransportFilter {
-
-        @Override
-        public NextAction handleRead(FilterChainContext ctx) throws IOException {
-            final HttpTransactionContext context = getHttpTransactionContext(ctx.getConnection());
-            if (context == null) {
-                return super.handleRead(ctx);
-            }
-            ctx.getTransportContext().setCompletionHandler(new CompletionHandler() {
-                @Override
-                public void cancelled() {
-
-                }
-
-                @Override
-                public void failed(Throwable throwable) {
-                    if (throwable instanceof EOFException) {
-                        context.abort(new IOException("Remotely Closed"));
-                    }
-                    context.abort(throwable);
-                }
-
-                @Override
-                public void completed(Object result) {
-                }
-
-                @Override
-                public void updated(Object result) {
-                }
-            });
-            return super.handleRead(ctx);
-        }
-
-    } // END AsyncHttpClientTransportFilter
-
-
-    private final class AsyncHttpClientFilter extends BaseFilter {
-
-
-        private final AsyncHttpClientConfig config;
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        AsyncHttpClientFilter(final AsyncHttpClientConfig config) {
-
-            this.config = config;
-
-        }
-
-
-        // --------------------------------------------- Methods from BaseFilter
-
-
-        @Override
-        public NextAction handleWrite(final FilterChainContext ctx)
-        throws IOException {
-
-            Object message = ctx.getMessage();
-            if (message instanceof Request) {
-                ctx.setMessage(null);
-                if (!sendAsGrizzlyRequest((Request) message, ctx)) {
-                    return ctx.getSuspendAction();
-                }
-            } else if (message instanceof Buffer) {
-                return ctx.getInvokeAction();
-            }
-
-            return ctx.getStopAction();
-        }
-
-        @Override
-        public NextAction handleEvent(final FilterChainContext ctx,
-                                      final FilterChainEvent event)
-        throws IOException {
-
-            final Object type = event.type();
-            if (type == ContinueEvent.class) {
-                final ContinueEvent continueEvent = (ContinueEvent) event;
-                ((ExpectHandler) continueEvent.context.bodyHandler).finish(ctx);
-            }
-
-            return ctx.getStopAction();
-
-        }
-
-//        @Override
-//        public NextAction handleRead(FilterChainContext ctx) throws IOException {
-//            Object message = ctx.getMessage();
-//            if (HttpPacket.isHttp(message)) {
-//                final HttpPacket packet = (HttpPacket) message;
-//                HttpResponsePacket responsePacket;
-//                if (HttpContent.isContent(packet)) {
-//                    responsePacket = (HttpResponsePacket) ((HttpContent) packet).getHttpHeader();
-//                } else {
-//                    responsePacket = (HttpResponsePacket) packet;
-//                }
-//                if (HttpStatus.SWITCHING_PROTOCOLS_101.statusMatches(responsePacket.getStatus())) {
-//                    return ctx.getStopAction();
-//                }
-//            }
-//            return super.handleRead(ctx);
-//        }
-
-        // ----------------------------------------------------- Private Methods
-
-
-        private boolean sendAsGrizzlyRequest(final Request request,
-                                          final FilterChainContext ctx)
-        throws IOException {
-
-            final HttpTransactionContext httpCtx = getHttpTransactionContext(ctx.getConnection());
-            if (isUpgradeRequest(httpCtx.handler) && isWSRequest(httpCtx.requestUrl)) {
-                httpCtx.isWSRequest = true;
-                convertToUpgradeRequest(httpCtx);
-            }
-            final URI uri = AsyncHttpProviderUtils.createUri(httpCtx.requestUrl);
-            final HttpRequestPacket.Builder builder = HttpRequestPacket.builder();
-            final String scheme = uri.getScheme();
-            boolean secure = "https".equals(scheme) || "wss".equals(scheme);
-            builder.method(request.getMethod());
-            builder.protocol(Protocol.HTTP_1_1);
-            String host = request.getVirtualHost();
-            if (host != null) {
-                builder.header(Header.Host, host);
-            } else {
-                if (uri.getPort() == -1) {
-                    builder.header(Header.Host, uri.getHost());
-                } else {
-                    builder.header(Header.Host, uri.getHost() + ':' + uri.getPort());
-                }
-            }
-            final ProxyServer proxy = getProxyServer(request);
-            final boolean useProxy = (proxy != null);
-            if (useProxy) {
-                if ((secure || httpCtx.isWSRequest) && !httpCtx.isTunnelEstablished(ctx.getConnection())) {
-                    ctx.notifyDownstream(new SwitchingSSLFilter.SSLSwitchingEvent(false, ctx.getConnection()));
-                    secure = false;
-                    httpCtx.establishingTunnel = true;
-                    builder.method(Method.CONNECT);
-                    builder.uri(AsyncHttpProviderUtils.getAuthority(uri));
-                } else {
-                    builder.uri(uri.toString());
-                }
-            } else {
-                builder.uri(uri.getPath());
-            }
-            if (requestHasEntityBody(request)) {
-                final long contentLength = request.getContentLength();
-                if (contentLength > 0) {
-                    builder.contentLength(contentLength);
-                    builder.chunked(false);
-                } else {
-                    builder.chunked(true);
-                }
-            }
-
-            HttpRequestPacket requestPacket;
-            if (httpCtx.isWSRequest && !httpCtx.establishingTunnel) {
-                try {
-                    final URI wsURI = new URI(httpCtx.wsRequestURI);
-                    httpCtx.protocolHandler = Version.DRAFT17.createHandler(true);
-                    httpCtx.handshake = httpCtx.protocolHandler.createHandShake(wsURI);
-                    requestPacket = (HttpRequestPacket)
-                            httpCtx.handshake.composeHeaders().getHttpHeader();
-                } catch (URISyntaxException e) {
-                    throw new IllegalArgumentException("Invalid WS URI: " + httpCtx.wsRequestURI);
-                }
-            } else {
-                requestPacket = builder.build();
-            }
-            requestPacket.setSecure(secure);
-            if (secure) {
-                ctx.notifyDownstream(new SwitchingSSLFilter.SSLSwitchingEvent(true, ctx.getConnection()));
-            }
-            if (!useProxy && !httpCtx.isWSRequest) {
-                addQueryString(request, requestPacket);
-            }
-            addHeaders(request, requestPacket);
-            addCookies(request, requestPacket);
-
-            if (useProxy) {
-                boolean avoidProxy = ProxyUtils.avoidProxy(proxy, request);
-                if (!avoidProxy) {
-                    if (!requestPacket.getHeaders().contains(Header.ProxyConnection)) {
-                        requestPacket.setHeader(Header.ProxyConnection, "keep-alive");
-                    }
-
-                    if (proxy.getPrincipal() != null && proxy.isBasic()) {
-                    	requestPacket.setHeader(Header.ProxyAuthorization, AuthenticatorUtils.computeBasicAuthentication(proxy));
-                    }
-                    
-                }
-            }
-            final AsyncHandler h = httpCtx.handler;
-            if (h != null) {
-                if (TransferCompletionHandler.class.isAssignableFrom(h.getClass())) {
-                    final FluentCaseInsensitiveStringsMap map =
-                            new FluentCaseInsensitiveStringsMap(request.getHeaders());
-                    TransferCompletionHandler.class.cast(h).transferAdapter(new GrizzlyTransferAdapter(map));
-                }
-            }
-            return sendRequest(ctx, request, requestPacket);
-
-        }
-
-        private boolean isUpgradeRequest(final AsyncHandler handler) {
-            return (handler instanceof UpgradeHandler);
-        }
-
-
-        private boolean isWSRequest(final String requestUri) {
-            return (requestUri.charAt(0) == 'w' && requestUri.charAt(1) == 's');
-        }
-
-        
-        private void convertToUpgradeRequest(final HttpTransactionContext ctx) {
-            final int colonIdx = ctx.requestUrl.indexOf(':');
-
-            if (colonIdx < 2 || colonIdx > 3) {
-                throw new IllegalArgumentException("Invalid websocket URL: " + ctx.requestUrl);
-            }
-
-            final StringBuilder sb = new StringBuilder(ctx.requestUrl);
-            sb.replace(0, colonIdx, ((colonIdx == 2) ? "http" : "https"));
-            ctx.wsRequestURI = ctx.requestUrl;
-            ctx.requestUrl = sb.toString();
-        }
-
-        
-        private ProxyServer getProxyServer(Request request) {
-
-            ProxyServer proxyServer = request.getProxyServer();
-            if (proxyServer == null) {
-                proxyServer = config.getProxyServer();
-            }
-            return proxyServer;
-
-        }
-
-
-        private void addHeaders(final Request request,
-                                final HttpRequestPacket requestPacket) {
-
-            final FluentCaseInsensitiveStringsMap map = request.getHeaders();
-            if (map != null && !map.isEmpty()) {
-                for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
-                    final String headerName = entry.getKey();
-                    final List<String> headerValues = entry.getValue();
-                    if (headerValues != null && !headerValues.isEmpty()) {
-                        for (final String headerValue : headerValues) {
-                            requestPacket.addHeader(headerName, headerValue);
-                        }
-                    }
-                }
-            }
-
-            final MimeHeaders headers = requestPacket.getHeaders();
-            if (!headers.contains(Header.Connection)) {
-                requestPacket.addHeader(Header.Connection, "keep-alive");
-            }
-
-            if (!headers.contains(Header.Accept)) {
-                requestPacket.addHeader(Header.Accept, "*/*");
-            }
-
-            if (!headers.contains(Header.UserAgent)) {
-                requestPacket.addHeader(Header.UserAgent, config.getUserAgent());
-            }
-
-
-        }
-
-
-        private void addCookies(final Request request,
-                                final HttpRequestPacket requestPacket) {
-
-            final Collection<Cookie> cookies = request.getCookies();
-            if (cookies != null && !cookies.isEmpty()) {
-                StringBuilder sb = new StringBuilder(128);
-                org.glassfish.grizzly.http.Cookie[] gCookies =
-                        new org.glassfish.grizzly.http.Cookie[cookies.size()];
-                convertCookies(cookies, gCookies);
-                CookieSerializerUtils.serializeClientCookies(sb, gCookies);
-                requestPacket.addHeader(Header.Cookie, sb.toString());
-            }
-
-        }
-
-
-        private void convertCookies(final Collection<Cookie> cookies,
-                                    final org.glassfish.grizzly.http.Cookie[] gCookies) {
-            int idx = 0;
-            for (final Cookie cookie : cookies) {
-                final org.glassfish.grizzly.http.Cookie gCookie =
-                        new org.glassfish.grizzly.http.Cookie(cookie.getName(), cookie.getValue());
-                gCookie.setDomain(cookie.getDomain());
-                gCookie.setPath(cookie.getPath());
-                gCookie.setVersion(cookie.getVersion());
-                gCookie.setMaxAge(cookie.getMaxAge());
-                gCookie.setSecure(cookie.isSecure());
-                gCookies[idx] = gCookie;
-                idx++;
-            }
-
-        }
-
-
-        private void addQueryString(final Request request,
-                                    final HttpRequestPacket requestPacket) {
-
-            final FluentStringsMap map = request.getQueryParams();
-            if (map != null && !map.isEmpty()) {
-                StringBuilder sb = new StringBuilder(128);
-                for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
-                    final String name = entry.getKey();
-                    final List<String> values = entry.getValue();
-                    if (values != null && !values.isEmpty()) {
-                        try {
-                            for (int i = 0, len = values.size(); i < len; i++) {
-                                final String value = values.get(i);
-                                if (value != null && value.length() > 0) {
-                                    sb.append(URLEncoder.encode(name, "UTF-8")).append('=')
-                                        .append(URLEncoder.encode(values.get(i), "UTF-8")).append('&');
-                                } else {
-                                    sb.append(URLEncoder.encode(name, "UTF-8")).append('&');
-                                }
-                            }
-                        } catch (UnsupportedEncodingException ignored) {
-                        }
-                    }
-                }
-                String queryString = sb.deleteCharAt((sb.length() - 1)).toString();
-
-                requestPacket.setQueryString(queryString);
-            }
-
-        }
-
-    } // END AsyncHttpClientFiler
-
-
-    private static final class AsyncHttpClientEventFilter extends HttpClientFilter {
-
-        private final Map<Integer,StatusHandler> HANDLER_MAP = new HashMap<Integer,StatusHandler>();
-
-
-        private final GrizzlyAsyncHttpProvider provider;
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        AsyncHttpClientEventFilter(final GrizzlyAsyncHttpProvider provider) {
-            this(provider, DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
-        }
-
-
-        AsyncHttpClientEventFilter(final GrizzlyAsyncHttpProvider provider,
-                                   final int maxHeaderSize) {
-
-            super(maxHeaderSize);
-            this.provider = provider;
-            HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(),
-                            AuthorizationHandler.INSTANCE);
-            HANDLER_MAP.put(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.getStatusCode(),
-                    ProxyAuthorizationHandler.INSTANCE);
-            HANDLER_MAP.put(HttpStatus.MOVED_PERMANENTLY_301.getStatusCode(),
-                    RedirectHandler.INSTANCE);
-            HANDLER_MAP.put(HttpStatus.FOUND_302.getStatusCode(),
-                    RedirectHandler.INSTANCE);
-            HANDLER_MAP.put(HttpStatus.TEMPORARY_REDIRECT_307.getStatusCode(),
-                    RedirectHandler.INSTANCE);
-
-        }
-
-
-        // --------------------------------------- Methods from HttpClientFilter
-
-
-        @Override
-        public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
-
-            provider.getHttpTransactionContext(ctx.getConnection()).abort(error);
-
-        }
-
-
-        @Override
-        protected void onHttpContentParsed(HttpContent content,
-                                           FilterChainContext ctx) {
-
-            final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(ctx.getConnection());
-            final AsyncHandler handler = context.handler;
-            if (handler != null && context.currentState != AsyncHandler.STATE.ABORT) {
-                try {
-                    context.currentState = handler.onBodyPartReceived(
-                            new GrizzlyResponseBodyPart(content,
-                                    null,
-                                    ctx.getConnection(),
-                                    provider));
-                } catch (Exception e) {
-                    handler.onThrowable(e);
-                }
-            }
-
-        }
-
-        @Override
-        protected void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
-            final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
-            final AsyncHandler handler = context.handler;
-            if (handler != null) {
-                if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                    ((TransferCompletionHandler) handler).onHeaderWriteCompleted();
-                }
-            }
-        }
-
-        @Override
-        protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
-            final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
-            final AsyncHandler handler = context.handler;
-            if (handler != null) {
-                if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                    final int written = content.getContent().remaining();
-                    final long total = context.totalBodyWritten.addAndGet(written);
-                    ((TransferCompletionHandler) handler).onContentWriteProgress(
-                            written,
-                            total,
-                            content.getHttpHeader().getContentLength());
-                }
-            }
-        }
-
-        @Override
-        protected void onInitialLineParsed(HttpHeader httpHeader,
-                                           FilterChainContext ctx) {
-
-            super.onInitialLineParsed(httpHeader, ctx);
-            if (httpHeader.isSkipRemainder()) {
-                return;
-            }
-            final Connection connection = ctx.getConnection();
-            final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(connection);
-            final int status = ((HttpResponsePacket) httpHeader).getStatus();
-            if (context.establishingTunnel && HttpStatus.OK_200.statusMatches(status)) {
-                return;
-            }
-            if (HttpStatus.CONINTUE_100.statusMatches(status)) {
-                ctx.notifyUpstream(new ContinueEvent(context));
-                return;
-            }
-
-
-            if (context.statusHandler != null && !context.statusHandler.handlesStatus(status)) {
-                context.statusHandler = null;
-                context.invocationStatus = StatusHandler.InvocationStatus.CONTINUE;
-            } else {
-                context.statusHandler = null;
-            }
-            if (context.invocationStatus == StatusHandler.InvocationStatus.CONTINUE) {
-                if (HANDLER_MAP.containsKey(status)) {
-                    context.statusHandler = HANDLER_MAP.get(status);
-                }
-                if (context.statusHandler instanceof RedirectHandler) {
-                    if (!isRedirectAllowed(context)) {
-                        context.statusHandler = null;
-                    }
-                }
-            }
-            if (isRedirectAllowed(context)) {
-                if (isRedirect(status)) {
-                    if (context.statusHandler == null) {
-                        context.statusHandler = RedirectHandler.INSTANCE;
-                    }
-                    context.redirectCount.incrementAndGet();
-                    if (redirectCountExceeded(context)) {
-                        httpHeader.setSkipRemainder(true);
-                        context.abort(new MaxRedirectException());
-                    }
-                } else {
-                    if (context.redirectCount.get() > 0) {
-                        context.redirectCount.set(0);
-                    }
-                }
-            }
-            final GrizzlyResponseStatus responseStatus =
-                        new GrizzlyResponseStatus((HttpResponsePacket) httpHeader,
-                                                  getURI(context.requestUrl),
-                                                  provider);
-            context.responseStatus = responseStatus;
-            if (context.statusHandler != null) {
-                return;
-            }
-            if (context.currentState != AsyncHandler.STATE.ABORT) {
-
-                try {
-                    final AsyncHandler handler = context.handler;
-                    if (handler != null) {
-                        context.currentState = handler.onStatusReceived(responseStatus);
-                        if (context.isWSRequest && context.currentState == AsyncHandler.STATE.ABORT) {
-                            httpHeader.setSkipRemainder(true);
-                            context.abort(new HandshakeException("Upgrade failed"));
-                        }
-                    }
-                } catch (Exception e) {
-                    httpHeader.setSkipRemainder(true);
-                    context.abort(e);
-                }
-            }
-
-        }
-
-
-        @Override
-        protected void onHttpHeaderError(final HttpHeader httpHeader,
-                                         final FilterChainContext ctx,
-                                         final Throwable t) throws IOException {
-
-            t.printStackTrace();
-            httpHeader.setSkipRemainder(true);
-            final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(ctx.getConnection());
-            context.abort(t);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        @Override
-        protected void onHttpHeadersParsed(HttpHeader httpHeader,
-                                           FilterChainContext ctx) {
-
-            super.onHttpHeadersParsed(httpHeader, ctx);
-            LOGGER.debug("RESPONSE: {}", httpHeader);
-            if (httpHeader.containsHeader(Header.Connection)) {
-                if ("close".equals(httpHeader.getHeader(Header.Connection))) {
-                    ConnectionManager.markConnectionAsDoNotCache(ctx.getConnection());
-                }
-            }
-            final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
-            
-            if (httpHeader.isSkipRemainder() || (context.establishingTunnel && context.statusHandler==null)) {
-                return;
-            }
-
-            final AsyncHandler handler = context.handler;
-            final List<ResponseFilter> filters = context.provider.clientConfig.getResponseFilters();
-            final GrizzlyResponseHeaders responseHeaders = new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader,
-                                    null,
-                                    provider);
-            if (!filters.isEmpty()) {
-                FilterContext fc = new FilterContext.FilterContextBuilder()
-                        .asyncHandler(handler).request(context.request)
-                        .responseHeaders(responseHeaders)
-                        .responseStatus(context.responseStatus).build();
-                try {
-                    for (final ResponseFilter f : filters) {
-                        fc = f.filter(fc);
-                    }
-                } catch (Exception e) {
-                    context.abort(e);
-                }
-                if (fc.replayRequest()) {
-                    httpHeader.setSkipRemainder(true);
-                    final Request newRequest = fc.getRequest();
-                    final AsyncHandler newHandler = fc.getAsyncHandler();
-                    try {
-                        final ConnectionManager m =
-                                context.provider.connectionManager;
-                        final Connection c =
-                                m.obtainConnection(newRequest,
-                                                   context.future);
-                        final HttpTransactionContext newContext =
-                                context.copy();
-                        context.future = null;
-                        provider.setHttpTransactionContext(c, newContext);
-                        try {
-                            context.provider.execute(c,
-                                                     newRequest,
-                                                     newHandler,
-                                                     context.future);
-                        } catch (IOException ioe) {
-                            newContext.abort(ioe);
-                        }
-                    } catch (Exception e) {
-                        context.abort(e);
-                    }
-                    return;
-                }
-            }
-            if (context.statusHandler != null && context.invocationStatus == StatusHandler.InvocationStatus.CONTINUE) {
-                final boolean result = context.statusHandler.handleStatus(((HttpResponsePacket) httpHeader),
-                                                                          context,
-                                                                          ctx);
-                if (!result) {
-                    httpHeader.setSkipRemainder(true);
-                    return;
-                }
-            }
-            if (context.isWSRequest) {
-                try {
-                	//in case of DIGEST auth protocol handler is null and just returning here is working
-                	if(context.protocolHandler == null) 
-                	{
-                		return;
-                		//context.protocolHandler = Version.DRAFT17.createHandler(true);
-                		//context.currentState = AsyncHandler.STATE.UPGRADE;
-                	}
-                	
-                    context.protocolHandler.setConnection(ctx.getConnection());
-                    DefaultWebSocket ws = new DefaultWebSocket(context.protocolHandler);
-                    context.webSocket = new GrizzlyWebSocketAdapter(ws);
-                    if (context.currentState == AsyncHandler.STATE.UPGRADE) {
-                        httpHeader.setChunked(false);
-                        ws.onConnect();
-                        WebSocketEngine.getEngine().setWebSocketHolder(ctx.getConnection(),
-                                context.protocolHandler,
-                                ws);
-                        ((WebSocketUpgradeHandler) context.handler).onSuccess(context.webSocket);
-                        final int wsTimeout = context.provider.clientConfig.getWebSocketIdleTimeoutInMs();
-                        IdleTimeoutFilter.setCustomTimeout(ctx.getConnection(),
-                                ((wsTimeout <= 0)
-                                        ? IdleTimeoutFilter.FOREVER
-                                        : wsTimeout),
-                                TimeUnit.MILLISECONDS);
-                        context.result(handler.onCompleted());
-                    } else {
-                        httpHeader.setSkipRemainder(true);
-                        ((WebSocketUpgradeHandler) context.handler).
-                                onClose(context.webSocket,
-                                        1002,
-                                        "WebSocket protocol error: unexpected HTTP response status during handshake.");
-                        context.result(null);
-                    }
-                } catch (Exception e) {
-                    httpHeader.setSkipRemainder(true);
-                    context.abort(e);
-                }
-            } else {
-                if (context.currentState != AsyncHandler.STATE.ABORT) {
-                    try {
-                        context.currentState = handler.onHeadersReceived(
-                                responseHeaders);
-                    } catch (Exception e) {
-                        httpHeader.setSkipRemainder(true);
-                        context.abort(e);
-                    }
-                }
-            }
-
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-
-            boolean result;
-            if (httpHeader.isSkipRemainder()) {
-                clearResponse(ctx.getConnection());
-                cleanup(ctx, provider);
-                return false;
-            }
-
-            result = super.onHttpPacketParsed(httpHeader, ctx);
-
-            final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
-            if (context.establishingTunnel
-                    && HttpStatus.OK_200.statusMatches(
-                        ((HttpResponsePacket) httpHeader).getStatus())) {
-                context.establishingTunnel = false;
-                final Connection c = ctx.getConnection();
-                context.tunnelEstablished(c);
-                try {
-                    context.provider.execute(c,
-                            context.request,
-                            context.handler,
-                            context.future);
-                    return result;
-                } catch (IOException e) {
-                    context.abort(e);
-                    return result;
-                }
-            } else {
-                cleanup(ctx, provider);
-                final AsyncHandler handler = context.handler;
-                if (handler != null) {
-                    try {
-                        context.result(handler.onCompleted());
-                    } catch (Exception e) {
-                        context.abort(e);
-                    }
-                } else {
-                    context.done(null);
-                }
-
-                return result;
-            }
-        }
-
-
-        // ----------------------------------------------------- Private Methods
-
-
-        private static boolean isRedirectAllowed(final HttpTransactionContext ctx) {
-            boolean allowed = ctx.request.isRedirectEnabled();
-            if (ctx.request.isRedirectOverrideSet()) {
-                return allowed;
-            }
-            if (!allowed) {
-                allowed = ctx.redirectsAllowed;
-            }
-            return allowed;
-        }
-
-        private static HttpTransactionContext cleanup(final FilterChainContext ctx,
-                                                      final GrizzlyAsyncHttpProvider provider) {
-
-            final Connection c = ctx.getConnection();
-            final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(c);
-            context.provider.setHttpTransactionContext(c, null);
-            if (!context.provider.connectionManager.canReturnConnection(c)) {
-                context.abort(new IOException("Maximum pooled connections exceeded"));
-            } else {
-                if (!context.provider.connectionManager.returnConnection(context.requestUrl, c)) {
-                    ctx.getConnection().close();
-                }
-            }
-
-            return context;
-
-        }
-
-
-        private static URI getURI(String url) {
-
-            return AsyncHttpProviderUtils.createUri(url);
-
-        }
-
-
-        private static boolean redirectCountExceeded(final HttpTransactionContext context) {
-
-            return (context.redirectCount.get() > context.maxRedirectCount);
-
-        }
-
-
-        private static boolean isRedirect(final int status) {
-
-            return HttpStatus.MOVED_PERMANENTLY_301.statusMatches(status)
-                    || HttpStatus.FOUND_302.statusMatches(status)
-                    || HttpStatus.SEE_OTHER_303.statusMatches(status)
-                    || HttpStatus.TEMPORARY_REDIRECT_307.statusMatches(status);
-
-        }
-
-
-        // ------------------------------------------------------- Inner Classes
-
-
-        private static final class AuthorizationHandler implements StatusHandler {
-
-            private static final AuthorizationHandler INSTANCE =
-                    new AuthorizationHandler();
-
-            // -------------------------------------- Methods from StatusHandler
-
-
-            public boolean handlesStatus(int statusCode) {
-                return (HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
-            }
-
-            @SuppressWarnings({"unchecked"})
-            public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                     final HttpTransactionContext httpTransactionContext,
-                                     final FilterChainContext ctx) {
-
-                final String auth = responsePacket.getHeader(Header.WWWAuthenticate);
-                if (auth == null) {
-                    throw new IllegalStateException("401 response received, but no WWW-Authenticate header was present");
-                }
-
-                Realm realm = httpTransactionContext.request.getRealm();
-                if (realm == null) {
-                    realm = httpTransactionContext.provider.clientConfig.getRealm();
-                }
-                if (realm == null) {
-                    httpTransactionContext.invocationStatus = InvocationStatus.STOP;
-                    return true;
-                }
-
-                responsePacket.setSkipRemainder(true); // ignore the remainder of the response
-
-                final Request req = httpTransactionContext.request;
-                realm = new Realm.RealmBuilder().clone(realm)
-                                .setScheme(realm.getAuthScheme())
-                                .setUri(URI.create(httpTransactionContext.requestUrl).getPath())
-                                .setMethodName(req.getMethod())
-                                .setUsePreemptiveAuth(true)
-                                .parseWWWAuthenticateHeader(auth)
-                                .build();
-                if (auth.toLowerCase().startsWith("basic")) {
-                    req.getHeaders().remove(Header.Authorization.toString());
-                    try {
-                        req.getHeaders().add(Header.Authorization.toString(),
-                                             AuthenticatorUtils.computeBasicAuthentication(realm));
-                    } catch (UnsupportedEncodingException ignored) {
-                    }
-                } else if (auth.toLowerCase().startsWith("digest")) {
-                    req.getHeaders().remove(Header.Authorization.toString());
-                    try {
-                        req.getHeaders().add(Header.Authorization.toString(),
-                                             AuthenticatorUtils.computeDigestAuthentication(realm));
-                    } catch (NoSuchAlgorithmException e) {
-                        throw new IllegalStateException("Digest authentication not supported", e);
-                    } catch (UnsupportedEncodingException e) {
-                        throw new IllegalStateException("Unsupported encoding.", e);
-                    }
-                } else {
-                    throw new IllegalStateException("Unsupported authorization method: " + auth);
-                }
-
-                final ConnectionManager m = httpTransactionContext.provider.connectionManager;
-                try {
-                    final Connection c = m.obtainConnection(req,
-                                                            httpTransactionContext.future);
-                    final HttpTransactionContext newContext =
-                            httpTransactionContext.copy();
-                    httpTransactionContext.future = null;
-                    httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
-                    newContext.invocationStatus = InvocationStatus.STOP;
-                    try {
-                        httpTransactionContext.provider.execute(c,
-                                                                req,
-                                                                httpTransactionContext.handler,
-                                                                httpTransactionContext.future);
-                        return false;
-                    } catch (IOException ioe) {
-                        newContext.abort(ioe);
-                        return false;
-                    }
-                } catch (Exception e) {
-                    httpTransactionContext.abort(e);
-                }
-                httpTransactionContext.invocationStatus = InvocationStatus.STOP;
-                return false;
-            }
-
-        } // END AuthorizationHandler
-
-        private static final class ProxyAuthorizationHandler implements StatusHandler {
-
-            private static final ProxyAuthorizationHandler INSTANCE =
-                    new ProxyAuthorizationHandler();
-
-            // -------------------------------------- Methods from StatusHandler
-
-
-            public boolean handlesStatus(int statusCode) {
-                return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.statusMatches(statusCode));
-            }
-
-            @SuppressWarnings({"unchecked"})
-            public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                     final HttpTransactionContext httpTransactionContext,
-                                     final FilterChainContext ctx) {
-
-                final String proxy_auth = responsePacket.getHeader(Header.ProxyAuthenticate);
-                if (proxy_auth == null) {
-                    throw new IllegalStateException("407 response received, but no Proxy Authenticate header was present");
-                }
-
-                final Request req = httpTransactionContext.request;
-                ProxyServer proxyServer = httpTransactionContext.provider.clientConfig.getProxyServer();
-                String principal = proxyServer.getPrincipal();
-                String password = proxyServer.getPassword();
-                Realm realm = new Realm.RealmBuilder().setPrincipal(principal)
-                				.setPassword(password)
-                                .setUri("/")
-                                .setMethodName("CONNECT")
-                                .setUsePreemptiveAuth(true)
-                                .parseProxyAuthenticateHeader(proxy_auth)
-                                .build();
-                if (proxy_auth.toLowerCase().startsWith("basic")) {
-                    req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-                    req.getHeaders().remove(Header.ProxyAuthorization.toString());
-                    try {
-                        req.getHeaders().add(Header.ProxyAuthorization.toString(),
-                                             AuthenticatorUtils.computeBasicAuthentication(realm));
-                    } catch (UnsupportedEncodingException ignored) {
-                    }
-                } else if (proxy_auth.toLowerCase().startsWith("digest")) {
-                    req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-                    req.getHeaders().remove(Header.ProxyAuthorization.toString());
-                    try {
-                        req.getHeaders().add(Header.ProxyAuthorization.toString(),
-                                             AuthenticatorUtils.computeDigestAuthentication(realm));
-                    } catch (NoSuchAlgorithmException e) {
-                        throw new IllegalStateException("Digest authentication not supported", e);
-                    } catch (UnsupportedEncodingException e) {
-                        throw new IllegalStateException("Unsupported encoding.", e);
-                    }
-                } else {
-                    throw new IllegalStateException("Unsupported authorization method: " + proxy_auth);
-                }
-
-                final ConnectionManager m = httpTransactionContext.provider.connectionManager;
-                try {
-                    final Connection c = m.obtainConnection(req,
-                                                            httpTransactionContext.future);
-                    final HttpTransactionContext newContext =
-                            httpTransactionContext.copy();
-                    httpTransactionContext.future = null;
-                    httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
-                    newContext.invocationStatus = InvocationStatus.STOP;
-                    try {
-                        httpTransactionContext.provider.execute(c,
-                                                                req,
-                                                                httpTransactionContext.handler,
-                                                                httpTransactionContext.future);
-                        return false;
-                    } catch (IOException ioe) {
-                        newContext.abort(ioe);
-                        return false;
-                    }
-                } catch (Exception e) {
-                    httpTransactionContext.abort(e);
-                }
-                httpTransactionContext.invocationStatus = InvocationStatus.STOP;
-                return false;
-            }
-
-        } // END AuthorizationHandler
-
-
-        private static final class RedirectHandler implements StatusHandler {
-
-            private static final RedirectHandler INSTANCE = new RedirectHandler();
-
-
-            // ------------------------------------------ Methods from StatusHandler
-
-
-            public boolean handlesStatus(int statusCode) {
-                return (isRedirect(statusCode));
-            }
-
-            @SuppressWarnings({"unchecked"})
-            public boolean handleStatus(final HttpResponsePacket responsePacket,
-                                        final HttpTransactionContext httpTransactionContext,
-                                        final FilterChainContext ctx) {
-
-                final String redirectURL = responsePacket.getHeader(Header.Location);
-                if (redirectURL == null) {
-                    throw new IllegalStateException("redirect received, but no location header was present");
-                }
-
-                URI orig;
-                if (httpTransactionContext.lastRedirectURI == null) {
-                    orig = AsyncHttpProviderUtils.createUri(httpTransactionContext.requestUrl);
-                } else {
-                    orig = AsyncHttpProviderUtils.getRedirectUri(AsyncHttpProviderUtils.createUri(httpTransactionContext.requestUrl),
-                                                                 httpTransactionContext.lastRedirectURI);
-                }
-                httpTransactionContext.lastRedirectURI = redirectURL;
-                Request requestToSend;
-                URI uri = AsyncHttpProviderUtils.getRedirectUri(orig, redirectURL);
-                if (!uri.toString().equalsIgnoreCase(orig.toString())) {
-                    requestToSend = newRequest(uri,
-                                               responsePacket,
-                                               httpTransactionContext,
-                                               sendAsGet(responsePacket,  httpTransactionContext));
-                } else {
-                    httpTransactionContext.statusHandler = null;
-                    httpTransactionContext.invocationStatus = InvocationStatus.CONTINUE;
-                        try {
-                            httpTransactionContext.handler.onStatusReceived(httpTransactionContext.responseStatus);
-                        } catch (Exception e) {
-                            httpTransactionContext.abort(e);
-                        }
-                    return true;
-                }
-
-                final ConnectionManager m = httpTransactionContext.provider.connectionManager;
-                try {
-                    final Connection c = m.obtainConnection(requestToSend,
-                                                            httpTransactionContext.future);
-                    if (switchingSchemes(orig, uri)) {
-                        try {
-                            notifySchemeSwitch(ctx, c, uri);
-                        } catch (IOException ioe) {
-                            httpTransactionContext.abort(ioe);
-                        }
-                    }
-                    final HttpTransactionContext newContext =
-                            httpTransactionContext.copy();
-                    httpTransactionContext.future = null;
-                    newContext.invocationStatus = InvocationStatus.CONTINUE;
-                    newContext.request = requestToSend;
-                    newContext.requestUrl = requestToSend.getUrl();
-                    httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
-                    httpTransactionContext.provider.execute(c,
-                                                            requestToSend,
-                                                            newContext.handler,
-                                                            newContext.future);
-                    return false;
-                } catch (Exception e) {
-                    httpTransactionContext.abort(e);
-                }
-
-                httpTransactionContext.invocationStatus = InvocationStatus.CONTINUE;
-                return true;
-
-            }
-
-
-            // ------------------------------------------------- Private Methods
-
-            private boolean sendAsGet(final HttpResponsePacket response,
-                                      final HttpTransactionContext ctx) {
-                final int statusCode = response.getStatus();
-                return !(statusCode < 302 || statusCode > 303)
-                          && !(statusCode == 302
-                             && ctx.provider.clientConfig.isStrict302Handling());
-            }
-
-
-            private boolean switchingSchemes(final URI oldUri,
-                                             final URI newUri) {
-
-                return !oldUri.getScheme().equals(newUri.getScheme());
-
-            }
-
-            private void notifySchemeSwitch(final FilterChainContext ctx,
-                                            final Connection c,
-                                            final URI uri) throws IOException {
-
-                ctx.notifyDownstream(new SwitchingSSLFilter.SSLSwitchingEvent(
-                                               "https".equals(uri.getScheme()), c));
-            }
-
-        } // END RedirectHandler
-
-
-        // ----------------------------------------------------- Private Methods
-
-
-        private static Request newRequest(final URI uri,
-                                          final HttpResponsePacket response,
-                                          final HttpTransactionContext ctx,
-                                          boolean asGet) {
-
-            final RequestBuilder builder = new RequestBuilder(ctx.request);
-            if (asGet) {
-                builder.setMethod("GET");
-            }
-            builder.setUrl(uri.toString());
-
-            if (ctx.provider.clientConfig.isRemoveQueryParamOnRedirect()) {
-                builder.setQueryParameters(null);
-            }
-            for (String cookieStr : response.getHeaders().values(Header.Cookie)) {
-                Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
-                builder.addOrReplaceCookie(c);
-            }
-            return builder.build();
-
-        }
-
-
-    } // END AsyncHttpClientEventFilter
-
-
-    private static final class ClientEncodingFilter implements EncodingFilter {
-
-
-        // ----------------------------------------- Methods from EncodingFilter
-
-
-        public boolean applyEncoding(HttpHeader httpPacket) {
-
-           httpPacket.addHeader(Header.AcceptEncoding, "gzip");
-           return true;
-
-        }
-
-
-        public boolean applyDecoding(HttpHeader httpPacket) {
-
-            final HttpResponsePacket httpResponse = (HttpResponsePacket) httpPacket;
-            final DataChunk bc = httpResponse.getHeaders().getValue(Header.ContentEncoding);
-            return bc != null && bc.indexOf("gzip", 0) != -1;
-
-        }
-
-
-    } // END ClientContentEncoding
-
-
-    private static final class NonCachingPool implements ConnectionsPool<String,Connection> {
-
-
-        // ---------------------------------------- Methods from ConnectionsPool
-
-
-        public boolean offer(String uri, Connection connection) {
-            return false;
-        }
-
-        public Connection poll(String uri) {
-            return null;
-        }
-
-        public boolean removeAll(Connection connection) {
-            return false;
-        }
-
-        public boolean canCacheConnection() {
-            return true;
-        }
-
-        public void destroy() {
-            // no-op
-        }
-
-    } // END NonCachingPool
-
-
-    private static interface BodyHandler {
-
-        static int MAX_CHUNK_SIZE = 8192;
-
-        boolean handlesBodyType(final Request request);
-
-        boolean doHandle(final FilterChainContext ctx,
-                      final Request request,
-                      final HttpRequestPacket requestPacket) throws IOException;
-
-    } // END BodyHandler
-
-
-    private final class BodyHandlerFactory {
-
-        private final BodyHandler[] HANDLERS = new BodyHandler[] {
-            new StringBodyHandler(),
-            new ByteArrayBodyHandler(),
-            new ParamsBodyHandler(),
-            new EntityWriterBodyHandler(),
-            new StreamDataBodyHandler(),
-            new PartsBodyHandler(),
-            new FileBodyHandler(),
-            new BodyGeneratorBodyHandler()
-        };
-
-        public BodyHandler getBodyHandler(final Request request) {
-            for (final BodyHandler h : HANDLERS) {
-                if (h.handlesBodyType(request)) {
-                    return h;
-                }
-            }
-            return new NoBodyHandler();
-        }
-
-    } // END BodyHandlerFactory
-
-
-    private static final class ExpectHandler implements BodyHandler {
-
-        private final BodyHandler delegate;
-        private Request request;
-        private HttpRequestPacket requestPacket;
-
-        // -------------------------------------------------------- Constructors
-
-
-        private ExpectHandler(final BodyHandler delegate) {
-
-            this.delegate = delegate;
-
-        }
-
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(Request request) {
-            return delegate.handlesBodyType(request);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(FilterChainContext ctx, Request request, HttpRequestPacket requestPacket) throws IOException {
-            this.request = request;
-            this.requestPacket = requestPacket;
-            ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            return true;
-        }
-
-        public void finish(final FilterChainContext ctx) throws IOException {
-            delegate.doHandle(ctx, request, requestPacket);
-        }
-
-    } // END ContinueHandler
-
-
-    private final class ByteArrayBodyHandler implements BodyHandler {
-
-
-        // -------------------------------------------- Methods from BodyHandler
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getByteData() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            String charset = request.getBodyEncoding();
-            if (charset == null) {
-                charset = Charsets.DEFAULT_CHARACTER_ENCODING;
-            }
-            final byte[] data = new String(request.getByteData(), charset).getBytes(charset);
-            final MemoryManager mm = ctx.getMemoryManager();
-            final Buffer gBuffer = Buffers.wrap(mm, data);
-            if (requestPacket.getContentLength() == -1) {
-                    if (!clientConfig.isCompressionEnabled()) {
-                        requestPacket.setContentLengthLong(data.length);
-                    }
-                }
-            final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            return true;
-        }
-    }
-
-
-    private final class StringBodyHandler implements BodyHandler {
-
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getStringData() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            String charset = request.getBodyEncoding();
-            if (charset == null) {
-                charset = Charsets.DEFAULT_CHARACTER_ENCODING;
-            }
-            final byte[] data = request.getStringData().getBytes(charset);
-            final MemoryManager mm = ctx.getMemoryManager();
-            final Buffer gBuffer = Buffers.wrap(mm, data);
-            if (requestPacket.getContentLength() == -1) {
-                if (!clientConfig.isCompressionEnabled()) {
-                    requestPacket.setContentLengthLong(data.length);
-                }
-            }
-            final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            return true;
-        }
-
-    } // END StringBodyHandler
-
-
-    private static final class NoBodyHandler implements BodyHandler {
-
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return false;
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            final HttpContent content = requestPacket.httpContentBuilder().content(Buffers.EMPTY_BUFFER).build();
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            return true;
-        }
-
-    } // END NoBodyHandler
-
-
-    private final class ParamsBodyHandler implements BodyHandler {
-
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            final FluentStringsMap params = request.getParams();
-            return (params != null && !params.isEmpty());
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            if (requestPacket.getContentType() == null) {
-                requestPacket.setContentType("application/x-www-form-urlencoded");
-            }
-            StringBuilder sb = null;
-            String charset = request.getBodyEncoding();
-            if (charset == null) {
-                charset = Charsets.DEFAULT_CHARACTER_ENCODING;
-            }
-            final FluentStringsMap params = request.getParams();
-            if (!params.isEmpty()) {
-                for (Map.Entry<String, List<String>> entry : params.entrySet()) {
-                    String name = entry.getKey();
-                    List<String> values = entry.getValue();
-                    if (values != null && !values.isEmpty()) {
-                        if (sb == null) {
-                            sb = new StringBuilder(128);
-                        }
-                        for (String value : values) {
-                            if (sb.length() > 0) {
-                                sb.append('&');
-                            }
-                            sb.append(URLEncoder.encode(name, charset))
-                                    .append('=').append(URLEncoder.encode(value, charset));
-                        }
-                    }
-                }
-            }
-            if (sb != null) {
-                final byte[] data = sb.toString().getBytes(charset);
-                final MemoryManager mm = ctx.getMemoryManager();
-                final Buffer gBuffer = Buffers.wrap(mm, data);
-                final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-                if (requestPacket.getContentLength() == -1) {
-                    if (!clientConfig.isCompressionEnabled()) {
-                        requestPacket.setContentLengthLong(data.length);
-                    }
-                }
-                content.setLast(true);
-                ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            }
-            return true;
-        }
-
-    } // END ParamsBodyHandler
-
-
-    private static final class EntityWriterBodyHandler implements BodyHandler {
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getEntityWriter() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            final MemoryManager mm = ctx.getMemoryManager();
-            Buffer b = mm.allocate(512);
-            BufferOutputStream o = new BufferOutputStream(mm, b, true);
-            final Request.EntityWriter writer = request.getEntityWriter();
-            writer.writeEntity(o);
-            b = o.getBuffer();
-            b.trim();
-            if (b.hasRemaining()) {
-                final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
-                content.setLast(true);
-                ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            }
-
-            return true;
-        }
-
-    } // END EntityWriterBodyHandler
-
-
-    private static final class StreamDataBodyHandler implements BodyHandler {
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getStreamData() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            final MemoryManager mm = ctx.getMemoryManager();
-            Buffer buffer = mm.allocate(512);
-            final byte[] b = new byte[512];
-            int read;
-            final InputStream in = request.getStreamData();
-            try {
-                in.reset();
-            } catch (IOException ioe) {
-                if (LOGGER.isDebugEnabled()) {
-                    LOGGER.debug(ioe.toString(), ioe);
-                }
-            }
-            if (in.markSupported()) {
-                in.mark(0);
-            }
-
-            while ((read = in.read(b)) != -1) {
-                if (read > buffer.remaining()) {
-                    buffer = mm.reallocate(buffer, buffer.capacity() + 512);
-                }
-                buffer.put(b, 0, read);
-            }
-            buffer.trim();
-            if (buffer.hasRemaining()) {
-                final HttpContent content = requestPacket.httpContentBuilder().content(buffer).build();
-                buffer.allowBufferDispose(false);
-                content.setLast(true);
-                ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            }
-            
-            return true;
-        }
-
-    } // END StreamDataBodyHandler
-
-
-    private static final class PartsBodyHandler implements BodyHandler {
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            final List<Part> parts = request.getParts();
-            return (parts != null && !parts.isEmpty());
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            MultipartRequestEntity mre =
-                    AsyncHttpProviderUtils.createMultipartRequestEntity(
-                            request.getParts(),
-                            request.getParams());
-            requestPacket.setContentLengthLong(mre.getContentLength());
-            requestPacket.setContentType(mre.getContentType());
-            final MemoryManager mm = ctx.getMemoryManager();
-            Buffer b = mm.allocate(512);
-            BufferOutputStream o = new BufferOutputStream(mm, b, true);
-            mre.writeRequest(o);
-            b = o.getBuffer();
-            b.trim();
-            if (b.hasRemaining()) {
-                final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
-                content.setLast(true);
-                ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            }
-
-            return true;
-        }
-
-    } // END PartsBodyHandler
-
-
-    private final class FileBodyHandler implements BodyHandler {
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getFile() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            final File f = request.getFile();
-            requestPacket.setContentLengthLong(f.length());
-            final HttpTransactionContext context = getHttpTransactionContext(ctx.getConnection());
-            if (!SEND_FILE_SUPPORT || requestPacket.isSecure()) {
-                final FileInputStream fis = new FileInputStream(request.getFile());
-                final MemoryManager mm = ctx.getMemoryManager();
-                AtomicInteger written = new AtomicInteger();
-                boolean last = false;
-                try {
-                    for (byte[] buf = new byte[MAX_CHUNK_SIZE]; !last; ) {
-                        Buffer b = null;
-                        int read;
-                        if ((read = fis.read(buf)) < 0) {
-                            last = true;
-                            b = Buffers.EMPTY_BUFFER;
-                        }
-                        if (b != Buffers.EMPTY_BUFFER) {
-                            written.addAndGet(read);
-                            b = Buffers.wrap(mm, buf, 0, read);
-                        }
-
-                        final HttpContent content =
-                                requestPacket.httpContentBuilder().content(b).
-                                        last(last).build();
-                        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-                    }
-                } finally {
-                    try {
-                        fis.close();
-                    } catch (IOException ignored) {
-                    }
-                }
-            } else {
-                // write the headers
-                ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-                ctx.write(new FileTransfer(f), new EmptyCompletionHandler<WriteResult>() {
-
-                    @Override
-                    public void updated(WriteResult result) {
-                        final AsyncHandler handler = context.handler;
-                        if (handler != null) {
-                            if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
-                                final long written = result.getWrittenSize();
-                                final long total = context.totalBodyWritten.addAndGet(written);
-                                ((TransferCompletionHandler) handler).onContentWriteProgress(
-                                        written,
-                                        total,
-                                        requestPacket.getContentLength());
-                            }
-                        }
-                    }
-                });
-            }
-
-            return true;
-        }
-
-    } // END FileBodyHandler
-
-
-    private static final class BodyGeneratorBodyHandler implements BodyHandler {
-
-        // -------------------------------------------- Methods from BodyHandler
-
-
-        public boolean handlesBodyType(final Request request) {
-            return (request.getBodyGenerator() != null);
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public boolean doHandle(final FilterChainContext ctx,
-                             final Request request,
-                             final HttpRequestPacket requestPacket)
-        throws IOException {
-
-            final BodyGenerator generator = request.getBodyGenerator();
-            final Body bodyLocal = generator.createBody();
-            final long len = bodyLocal.getContentLength();
-            if (len > 0) {
-                requestPacket.setContentLengthLong(len);
-            } else {
-                requestPacket.setChunked(true);
-            }
-
-            final MemoryManager mm = ctx.getMemoryManager();
-            boolean last = false;
-
-            while (!last) {
-                Buffer buffer = mm.allocate(MAX_CHUNK_SIZE);
-                buffer.allowBufferDispose(true);
-                
-                final long readBytes = bodyLocal.read(buffer.toByteBuffer());
-                if (readBytes > 0) {
-                    buffer.position((int) readBytes);
-                    buffer.trim();
-                } else {
-                    buffer.dispose();
-                    
-                    if (readBytes < 0) {
-                        last = true;
-                        buffer = Buffers.EMPTY_BUFFER;
-                    } else {
-                        // pass the context to bodyLocal to be able to
-                        // continue body transferring once more data is available
-                        if (generator instanceof FeedableBodyGenerator) {
-                            ((FeedableBodyGenerator) generator).initializeAsynchronousTransfer(ctx, requestPacket);
-                            return false;
-                        } else {
-                            throw new IllegalStateException("BodyGenerator unexpectedly returned 0 bytes available");
-                        }
-                    }
-                }
-
-                final HttpContent content =
-                        requestPacket.httpContentBuilder().content(buffer).
-                                last(last).build();
-                ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            }
-            
-            return true;
-        }
-
-    } // END BodyGeneratorBodyHandler
-
-
-    static class ConnectionManager {
-
-        private static final Attribute<Boolean> DO_NOT_CACHE =
-            Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(ConnectionManager.class.getName());
-        private final ConnectionsPool<String,Connection> pool;
-        private final TCPNIOConnectorHandler connectionHandler;
-        private final ConnectionMonitor connectionMonitor;
-        private final GrizzlyAsyncHttpProvider provider;
-
-        // -------------------------------------------------------- Constructors
-
-        @SuppressWarnings("unchecked")
-        ConnectionManager(final GrizzlyAsyncHttpProvider provider,
-                          final TCPNIOTransport transport) {
-
-            ConnectionsPool<String,Connection> connectionPool;
-            this.provider = provider;
-            final AsyncHttpClientConfig config = provider.clientConfig;
-            if (config.getAllowPoolingConnection()) {
-                ConnectionsPool pool = config.getConnectionsPool();
-                if (pool != null) {
-                    //noinspection unchecked
-                    connectionPool = (ConnectionsPool<String, Connection>) pool;
-                } else {
-                    connectionPool = new GrizzlyConnectionsPool((config));
-                }
-            } else {
-                connectionPool = new NonCachingPool();
-            }
-            pool = connectionPool;
-            connectionHandler = TCPNIOConnectorHandler.builder(transport).build();
-            final int maxConns = provider.clientConfig.getMaxTotalConnections();
-            connectionMonitor = new ConnectionMonitor(maxConns);
-
-
-        }
-
-        // ----------------------------------------------------- Private Methods
-
-        static void markConnectionAsDoNotCache(final Connection c) {
-            DO_NOT_CACHE.set(c, Boolean.TRUE);
-        }
-
-        static boolean isConnectionCacheable(final Connection c) {
-            final Boolean canCache =  DO_NOT_CACHE.get(c);
-            return ((canCache != null) ? canCache : false);
-        }
-
-        void doAsyncTrackedConnection(final Request request,
-                                      final GrizzlyResponseFuture requestFuture,
-                                      final CompletionHandler<Connection> connectHandler)
-        throws IOException, ExecutionException, InterruptedException {
-            final String url = request.getUrl();
-            Connection c = pool.poll(AsyncHttpProviderUtils.getBaseUrl(url));
-            if (c == null) {
-                if (!connectionMonitor.acquire()) {
-                    throw new IOException("Max connections exceeded");
-                }
-                doAsyncConnect(url, request, requestFuture, connectHandler);
-            } else {
-                provider.touchConnection(c, request);
-                connectHandler.completed(c);
-            }
-
-        }
-
-        Connection obtainConnection(final Request request,
-                                    final GrizzlyResponseFuture requestFuture)
-        throws IOException, ExecutionException, InterruptedException, TimeoutException {
-
-            final Connection c = (obtainConnection0(request.getUrl(),
-                                                    request,
-                                                    requestFuture));
-            DO_NOT_CACHE.set(c, Boolean.TRUE);
-            return c;
-
-        }
-
-        void doAsyncConnect(final String url,
-                            final Request request,
-                            final GrizzlyResponseFuture requestFuture,
-                            final CompletionHandler<Connection> connectHandler)
-        throws IOException, ExecutionException, InterruptedException {
-
-            final URI uri = AsyncHttpProviderUtils.createUri(url);
-            ProxyServer proxy = getProxyServer(request);
-            if (ProxyUtils.avoidProxy(proxy, request)) {
-                proxy = null;
-            }
-            String host = ((proxy != null) ? proxy.getHost() : uri.getHost());
-            int port = ((proxy != null) ? proxy.getPort() : uri.getPort());
-            if(request.getLocalAddress()!=null) {
-                connectionHandler.connect(new InetSocketAddress(host, getPort(uri, port)), new InetSocketAddress(request.getLocalAddress(), 0),
-                        createConnectionCompletionHandler(request, requestFuture, connectHandler));
-            } else {
-                connectionHandler.connect(new InetSocketAddress(host, getPort(uri, port)),
-                        createConnectionCompletionHandler(request, requestFuture, connectHandler));
-            }
-
-        }
-
-        private Connection obtainConnection0(final String url,
-                                             final Request request,
-                                             final GrizzlyResponseFuture requestFuture)
-        throws IOException, ExecutionException, InterruptedException, TimeoutException {
-
-            final URI uri = AsyncHttpProviderUtils.createUri(url);
-            ProxyServer proxy = getProxyServer(request);
-            if (ProxyUtils.avoidProxy(proxy, request)) {
-                proxy = null;
-            }
-            String host = ((proxy != null) ? proxy.getHost() : uri.getHost());
-            int port = ((proxy != null) ? proxy.getPort() : uri.getPort());
-            int cTimeout = provider.clientConfig.getConnectionTimeoutInMs();
-            FutureImpl<Connection> future = Futures.createSafeFuture();
-            CompletionHandler<Connection> ch = Futures.toCompletionHandler(future,
-                    createConnectionCompletionHandler(request, requestFuture, null));
-            if (cTimeout > 0) {
-                connectionHandler.connect(new InetSocketAddress(host, getPort(uri, port)),
-                        ch);
-                return future.get(cTimeout, TimeUnit.MILLISECONDS);
-            } else {
-                connectionHandler.connect(new InetSocketAddress(host, getPort(uri, port)),
-                        ch);
-                return future.get();
-            }
-        }
-
-        private ProxyServer getProxyServer(Request request) {
-
-            ProxyServer proxyServer = request.getProxyServer();
-            if (proxyServer == null) {
-                proxyServer = provider.clientConfig.getProxyServer();
-            }
-            return proxyServer;
-
-        }
-
-        boolean returnConnection(final String url, final Connection c) {
-            final boolean result = (DO_NOT_CACHE.get(c) == null
-                                       && pool.offer(AsyncHttpProviderUtils.getBaseUrl(url), c));
-            if (result) {
-                if (provider.resolver != null) {
-                    provider.resolver.setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
-                }
-            }
-            return result;
-
-        }
-
-
-        boolean canReturnConnection(final Connection c) {
-
-            return (DO_NOT_CACHE.get(c) != null || pool.canCacheConnection());
-
-        }
-
-
-        void destroy() {
-
-            pool.destroy();
-
-        }
-
-        CompletionHandler<Connection> createConnectionCompletionHandler(final Request request,
-                                                                        final GrizzlyResponseFuture future,
-                                                                        final CompletionHandler<Connection> wrappedHandler) {
-            return new CompletionHandler<Connection>() {
-                public void cancelled() {
-                    if (wrappedHandler != null) {
-                        wrappedHandler.cancelled();
-                    } else {
-                        future.cancel(true);
-                    }
-                }
-
-                public void failed(Throwable throwable) {
-                    if (wrappedHandler != null) {
-                        wrappedHandler.failed(throwable);
-                    } else {
-                        future.abort(throwable);
-                    }
-                }
-
-                public void completed(Connection connection) {
-                    future.setConnection(connection);
-                    provider.touchConnection(connection, request);
-                    if (wrappedHandler != null) {
-                        connection.addCloseListener(connectionMonitor);
-                        wrappedHandler.completed(connection);
-                    }
-                }
-
-                public void updated(Connection result) {
-                    if (wrappedHandler != null) {
-                        wrappedHandler.updated(result);
-                    }
-                }
-            };
-        }
-
-        // ------------------------------------------------------ Nested Classes
-
-        private static class ConnectionMonitor implements Connection.CloseListener {
-
-        private final Semaphore connections;
-
-            // ------------------------------------------------------------ Constructors
-
-
-            ConnectionMonitor(final int maxConnections) {
-                if (maxConnections != -1) {
-                    connections = new Semaphore(maxConnections);
-                } else {
-                    connections = null;
-                }
-            }
-
-            // ----------------------------------- Methods from Connection.CloseListener
-
-
-            public boolean acquire() {
-
-                return (connections == null || connections.tryAcquire());
-
-            }
-
-            @Override
-            public void onClosed(Connection connection, Connection.CloseType closeType) throws IOException {
-
-                if (connections != null) {
-                    connections.release();
-                }
-
-            }
-
-        } // END ConnectionMonitor
-
-    } // END ConnectionManager
-
-    static final class SwitchingSSLFilter extends SSLFilter {
-
-        private final boolean secureByDefault;
-        final Attribute<Boolean> CONNECTION_IS_SECURE =
-            Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class.getName());
-
-        // -------------------------------------------------------- Constructors
-
-
-        SwitchingSSLFilter(final SSLEngineConfigurator clientConfig,
-                           final boolean secureByDefault) {
-
-            super(null, clientConfig);
-            this.secureByDefault = secureByDefault;
-
-        }
-
-
-        // ---------------------------------------------- Methods from SSLFilter
-
-
-        @Override
-        public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException {
-
-            if (event.type() == SSLSwitchingEvent.class) {
-                final SSLSwitchingEvent se = (SSLSwitchingEvent) event;
-                CONNECTION_IS_SECURE.set(se.connection, se.secure);
-                return ctx.getStopAction();
-            }
-            return ctx.getInvokeAction();
-
-        }
-
-        @Override
-        public NextAction handleRead(FilterChainContext ctx) throws IOException {
-
-            if (isSecure(ctx.getConnection())) {
-                return super.handleRead(ctx);
-            }
-            return ctx.getInvokeAction();
-
-        }
-
-        @Override
-        public NextAction handleWrite(FilterChainContext ctx) throws IOException {
-
-            if (isSecure(ctx.getConnection())) {
-                return super.handleWrite(ctx);
-            }
-            return ctx.getInvokeAction();
-
-        }
-
-
-        // ----------------------------------------------------- Private Methods
-
-
-        private boolean isSecure(final Connection c) {
-
-            Boolean secStatus = CONNECTION_IS_SECURE.get(c);
-            if (secStatus == null) {
-                secStatus = secureByDefault;
-            }
-            return secStatus;
-
-        }
-
-
-        // ------------------------------------------------------ Nested Classes
-
-        static final class SSLSwitchingEvent implements FilterChainEvent {
-
-            final boolean secure;
-            final Connection connection;
-
-            // ---------------------------------------------------- Constructors
-
-
-            SSLSwitchingEvent(final boolean secure, final Connection c) {
-
-                this.secure = secure;
-                connection = c;
-
-            }
-
-            // ----------------------------------- Methods from FilterChainEvent
-
-
-            @Override
-            public Object type() {
-                return SSLSwitchingEvent.class;
-            }
-
-        } // END SSLSwitchingEvent
-
-    } // END SwitchingSSLFilter
-
-    private static final class GrizzlyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        public GrizzlyTransferAdapter(FluentCaseInsensitiveStringsMap headers) throws IOException {
-            super(headers);
-        }
-
-
-        // ---------------------------------------- Methods from TransferAdapter
-
-
-        @Override
-        public void getBytes(byte[] bytes) {
-            // TODO implement
-        }
-
-    } // END GrizzlyTransferAdapter
-    
-    
-    private static final class GrizzlyWebSocketAdapter implements WebSocket {
-        
-        private final org.glassfish.grizzly.websockets.WebSocket gWebSocket;
-
-        // -------------------------------------------------------- Constructors
-        
-        
-        GrizzlyWebSocketAdapter(final org.glassfish.grizzly.websockets.WebSocket gWebSocket) {
-            this.gWebSocket = gWebSocket;            
-        }
-        
-        
-        // ------------------------------------------ Methods from AHC WebSocket
-        
-        
-        @Override
-        public WebSocket sendMessage(byte[] message) {
-            gWebSocket.send(message);
-            return this;
-        }
-
-        @Override
-        public WebSocket stream(byte[] fragment, boolean last) {
-            if (fragment != null && fragment.length > 0) {
-                gWebSocket.stream(last, fragment, 0, fragment.length);
-            }
-            return this;
-        }
-
-        @Override
-        public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
-            if (fragment != null && fragment.length > 0) {
-                gWebSocket.stream(last, fragment, offset, len);
-            }
-            return this;
-        }
-
-        @Override
-        public WebSocket sendTextMessage(String message) {
-            gWebSocket.send(message);
-            return this;
-        }
-
-        @Override
-        public WebSocket streamText(String fragment, boolean last) {
-            gWebSocket.stream(last, fragment);
-            return this;
-        }
-
-        @Override
-        public WebSocket sendPing(byte[] payload) {
-            gWebSocket.sendPing(payload);
-            return this;
-        }
-
-        @Override
-        public WebSocket sendPong(byte[] payload) {
-            gWebSocket.sendPong(payload);
-            return this;
-        }
-
-        @Override
-        public WebSocket addWebSocketListener(WebSocketListener l) {
-            gWebSocket.add(new AHCWebSocketListenerAdapter(l, this));
-            return this;
-        }
-
-        @Override
-        public WebSocket removeWebSocketListener(WebSocketListener l) {
-            gWebSocket.remove(new AHCWebSocketListenerAdapter(l, this));
-            return this;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return gWebSocket.isConnected();
-        }
-
-        @Override
-        public void close() {
-            gWebSocket.close();
-        }
-        
-    } // END GrizzlyWebSocketAdapter
-
-
-    private static final class AHCWebSocketListenerAdapter implements org.glassfish.grizzly.websockets.WebSocketListener {
-
-        private final WebSocketListener ahcListener;
-        private final WebSocket webSocket;
-
-        // -------------------------------------------------------- Constructors
-
-
-        AHCWebSocketListenerAdapter(final WebSocketListener ahcListener, WebSocket webSocket) {
-            this.ahcListener = ahcListener;
-            this.webSocket = webSocket;
-        }
-
-
-        // ------------------------------ Methods from Grizzly WebSocketListener
-
-
-        @Override
-        public void onClose(org.glassfish.grizzly.websockets.WebSocket gWebSocket, DataFrame dataFrame) {
-            try {
-                if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    ClosingFrame cf = ClosingFrame.class.cast(dataFrame);
-                    WebSocketCloseCodeReasonListener.class.cast(ahcListener).onClose(webSocket, cf.getCode(), cf.getReason());
-                } else {
-                    ahcListener.onClose(webSocket);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onConnect(org.glassfish.grizzly.websockets.WebSocket gWebSocket) {
-            try {
-                ahcListener.onOpen(webSocket);
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, String s) {
-            try {
-                if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketTextListener.class.cast(ahcListener).onMessage(s);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-            try {
-                if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketByteListener.class.cast(ahcListener).onMessage(bytes);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onPing(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-            try {
-                if (WebSocketPingListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketPingListener.class.cast(ahcListener).onPing(bytes);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onPong(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-            try {
-                if (WebSocketPongListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketPongListener.class.cast(ahcListener).onPong(bytes);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, String s, boolean b) {
-            try {
-                if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketTextListener.class.cast(ahcListener).onFragment(s, b);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes, boolean b) {
-            try {
-                if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
-                    WebSocketByteListener.class.cast(ahcListener).onFragment(bytes, b);
-                }
-            } catch (Throwable e) {
-                ahcListener.onError(e);
-            }
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            AHCWebSocketListenerAdapter that = (AHCWebSocketListenerAdapter) o;
-
-            if (ahcListener != null ? !ahcListener.equals(that.ahcListener) : that.ahcListener != null)
-                return false;
-            if (webSocket != null ? !webSocket.equals(that.webSocket) : that.webSocket != null)
-                return false;
-
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = ahcListener != null ? ahcListener.hashCode() : 0;
-            result = 31 * result + (webSocket != null ? webSocket.hashCode() : 0);
-            return result;
-        }
-    } // END AHCWebSocketListenerAdapter
-    
-}
-
-
-
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java
deleted file mode 100644
index ee2377150..000000000
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java
+++ /dev/null
@@ -1,467 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package com.ning.http.client.providers.grizzly;
-
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ConnectionsPool;
-
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.attributes.NullaryFunction;
-import org.glassfish.grizzly.utils.DataStructures;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * {@link ConnectionsPool} implementation.
- * 
- * @author The Grizzly Team
- * @since 1.7.0
- */
-@SuppressWarnings("rawtypes")
-public class GrizzlyConnectionsPool implements ConnectionsPool<String,Connection> {
-
-    private final static Logger LOG = LoggerFactory.getLogger(GrizzlyConnectionsPool.class);
-
-    private final ConcurrentHashMap<String,DelayedExecutor.IdleConnectionQueue> connectionsPool =
-            new ConcurrentHashMap<String,DelayedExecutor.IdleConnectionQueue>();
-    private final AtomicBoolean closed = new AtomicBoolean(false);
-    private final AtomicInteger totalCachedConnections = new AtomicInteger(0);
-    private final boolean cacheSSLConnections;
-    private final int maxConnectionsPerHost;
-    private final int maxConnections;
-    private final boolean unlimitedConnections;
-    private final long timeout;
-    private final DelayedExecutor delayedExecutor;
-    private final Connection.CloseListener listener;
-
-
-    // ------------------------------------------------------------ Constructors
-
-
-    public GrizzlyConnectionsPool(final AsyncHttpClientConfig config) {
-
-        cacheSSLConnections = config.isSslConnectionPoolEnabled();
-        timeout = config.getIdleConnectionInPoolTimeoutInMs();
-        maxConnectionsPerHost = config.getMaxConnectionPerHost();
-        maxConnections = config.getMaxTotalConnections();
-        unlimitedConnections = (maxConnections == -1);
-        delayedExecutor = new DelayedExecutor(Executors.newSingleThreadExecutor());
-        delayedExecutor.start();
-        listener = new Connection.CloseListener() {
-            @Override
-            public void onClosed(Connection connection, Connection.CloseType closeType) throws IOException {
-                if (closeType == Connection.CloseType.REMOTELY) {
-                    if (LOG.isInfoEnabled()) {
-                        LOG.info("Remote closed connection ({}).  Removing from cache", connection.toString());
-                    }
-                }
-                GrizzlyConnectionsPool.this.removeAll(connection);
-            }
-        };
-
-    }
-
-
-    // -------------------------------------------- Methods from ConnectionsPool
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean offer(String uri, Connection connection) {
-
-        if (cacheSSLConnections && isSecure(uri)) {
-            return false;
-        }
-
-        DelayedExecutor.IdleConnectionQueue conQueue = connectionsPool.get(uri);
-        if (conQueue == null) {
-            LOG.debug("Creating new Connection queue for uri [{}] and connection [{}]",
-                        uri, connection);
-            DelayedExecutor.IdleConnectionQueue newPool =
-                    delayedExecutor.createIdleConnectionQueue(timeout);
-            conQueue = connectionsPool.putIfAbsent(uri, newPool);
-            if (conQueue == null) {
-                conQueue = newPool;
-            }
-        }
-
-        final int size = conQueue.size();
-        if (maxConnectionsPerHost == -1 || size < maxConnectionsPerHost) {
-            conQueue.offer(connection);
-            connection.addCloseListener(listener);
-            final int total = totalCachedConnections.incrementAndGet();
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("[offer] Pooling connection [{}] for uri [{}].  Current size (for host; before pooling): [{}].  Max size (for host): [{}].  Total number of cached connections: [{}].",
-                        new Object[]{connection, uri, size, maxConnectionsPerHost, total});
-            }
-            return true;
-        }
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("[offer] Unable to pool connection [{}] for uri [{}]. Current size (for host): [{}].  Max size (for host): [{}].  Total number of cached connections: [{}].",
-                    new Object[]{connection, uri, size, maxConnectionsPerHost, totalCachedConnections.get()});
-        }
-
-        return false;
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public Connection poll(String uri) {
-
-        if (!cacheSSLConnections && isSecure(uri)) {
-            return null;
-        }
-
-        Connection connection = null;
-        DelayedExecutor.IdleConnectionQueue conQueue = connectionsPool.get(uri);
-        if (conQueue != null) {
-            boolean poolEmpty = false;
-            while (!poolEmpty && connection == null) {
-                if (!conQueue.isEmpty()) {
-                    connection = conQueue.poll();
-                }
-
-                if (connection == null) {
-                    poolEmpty = true;
-                } else if (!connection.isOpen()) {
-                    removeAll(connection);
-                    connection = null;
-                }
-            }
-        } else {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("[poll] No existing queue for uri [{}].",
-                        new Object[]{uri});
-            }
-        }
-        if (connection != null) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("[poll] Found pooled connection [{}] for uri [{}].",
-                        new Object[]{connection, uri});
-            }
-            totalCachedConnections.decrementAndGet();
-            connection.removeCloseListener(listener);
-        }
-        return connection;
-
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean removeAll(Connection connection) {
-
-        if (connection == null || closed.get()) {
-            return false;
-        }
-        connection.removeCloseListener(listener);
-        boolean isRemoved = false;
-        for (Map.Entry<String, DelayedExecutor.IdleConnectionQueue> entry : connectionsPool.entrySet()) {
-            boolean removed = entry.getValue().remove(connection);
-            isRemoved |= removed;
-        }
-        return isRemoved;
-
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean canCacheConnection() {
-
-        return !(!closed.get()
-                       && !unlimitedConnections
-                       && totalCachedConnections.get() >= maxConnections);
-
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void destroy() {
-
-        if (closed.getAndSet(true)) {
-            return;
-        }
-
-        for (Map.Entry<String, DelayedExecutor.IdleConnectionQueue> entry : connectionsPool.entrySet()) {
-            entry.getValue().destroy();
-        }
-        connectionsPool.clear();
-        delayedExecutor.stop();
-        delayedExecutor.getThreadPool().shutdownNow();
-
-    }
-
-
-    // --------------------------------------------------------- Private Methods
-
-
-    private boolean isSecure(String uri) {
-
-        return (uri.charAt(0) == 'h' && uri.charAt(4) == 's');
-
-    }
-
-
-    // ---------------------------------------------------------- Nested Classes
-
-
-    private static final class DelayedExecutor {
-
-        public final static long UNSET_TIMEOUT = -1;
-        private final ExecutorService threadPool;
-        private final DelayedRunnable runnable = new DelayedRunnable();
-        private final BlockingQueue<IdleConnectionQueue> queues =
-                DataStructures.getLTQInstance(IdleConnectionQueue.class);
-        private final Object sync = new Object();
-        private volatile boolean isStarted;
-        private final long checkIntervalMs;
-
-
-        // -------------------------------------------------------- Constructors
-
-
-        private DelayedExecutor(final ExecutorService threadPool) {
-            this(threadPool, 1000, TimeUnit.MILLISECONDS);
-        }
-
-
-        // ----------------------------------------------------- Private Methods
-
-        private DelayedExecutor(final ExecutorService threadPool,
-                               final long checkInterval,
-                               final TimeUnit timeunit) {
-            this.threadPool = threadPool;
-            this.checkIntervalMs = TimeUnit.MILLISECONDS.convert(checkInterval, timeunit);
-        }
-
-        private void start() {
-            synchronized (sync) {
-                if (!isStarted) {
-                    isStarted = true;
-                    threadPool.execute(runnable);
-                }
-            }
-        }
-
-        private void stop() {
-            synchronized (sync) {
-                if (isStarted) {
-                    isStarted = false;
-                    sync.notify();
-                }
-            }
-        }
-
-        private ExecutorService getThreadPool() {
-            return threadPool;
-        }
-
-        private IdleConnectionQueue createIdleConnectionQueue(final long timeout) {
-            final IdleConnectionQueue queue = new IdleConnectionQueue(timeout);
-            queues.add(queue);
-            return queue;
-        }
-
-        @SuppressWarnings({"NumberEquality"})
-        private static boolean wasModified(final Long l1, final Long l2) {
-            return l1 != l2 && (l1 != null ? !l1.equals(l2) : !l2.equals(l1));
-        }
-
-
-        // ------------------------------------------------------- Inner Classes
-
-
-        private class DelayedRunnable implements Runnable {
-
-            @Override
-            public void run() {
-                while (isStarted) {
-                    final long currentTimeMs = System.currentTimeMillis();
-
-                    for (final IdleConnectionQueue delayQueue : queues) {
-                        if (delayQueue.queue.isEmpty()) continue;
-
-                        final TimeoutResolver resolver = delayQueue.resolver;
-
-                        for (Iterator<Connection> it = delayQueue.queue.iterator(); it.hasNext(); ) {
-                            final Connection<?> element = (Connection<?>) it.next();
-                            final Long timeoutMs = resolver.getTimeoutMs(element);
-
-                            if (timeoutMs == null || timeoutMs == UNSET_TIMEOUT) {
-                                it.remove();
-                                if (wasModified(timeoutMs,
-                                                resolver.getTimeoutMs(element))) {
-                                    delayQueue.queue.offer(element);
-                                }
-                            } else if (currentTimeMs - timeoutMs >= 0) {
-                                it.remove();
-                                if (wasModified(timeoutMs,
-                                                resolver.getTimeoutMs(element))) {
-                                    delayQueue.queue.offer(element);
-                                } else {
-                                    try {
-                                        if (LOG.isDebugEnabled()) {
-                                            LOG.debug("Idle connection ({}) detected.  Removing from cache.", element.toString());
-                                        }
-                                        element.close().markForRecycle(true);
-                                    } catch (Exception ignored) {
-                                    }
-                                }
-                            }
-                        }
-                    }
-
-                    synchronized (sync) {
-                        if (!isStarted) return;
-
-                        try {
-                            sync.wait(checkIntervalMs);
-                        } catch (InterruptedException ignored) {
-                        }
-                    }
-                }
-            }
-
-        } // END DelayedRunnable
-
-
-        final class IdleConnectionQueue {
-            final ConcurrentLinkedQueue<Connection> queue =
-                    new ConcurrentLinkedQueue<Connection>();
-
-
-            final TimeoutResolver resolver = new TimeoutResolver();
-            final long timeout;
-            final AtomicInteger count = new AtomicInteger(0);
-
-            // ---------------------------------------------------- Constructors
-
-
-            public IdleConnectionQueue(final long timeout) {
-                this.timeout = timeout;
-            }
-
-
-            // ------------------------------------------------- Private Methods
-
-
-            void offer(final Connection c) {
-                if (timeout >= 0) {
-                    resolver.setTimeoutMs(c, System.currentTimeMillis() + timeout);
-                }
-                queue.offer(c);
-                count.incrementAndGet();
-            }
-
-            Connection poll() {
-                count.decrementAndGet();
-                return queue.poll();
-            }
-
-            boolean remove(final Connection c) {
-                if (timeout >= 0) {
-                    resolver.removeTimeout(c);
-
-                }
-                count.decrementAndGet();
-                return queue.remove(c);
-            }
-
-            int size() {
-                return count.get();
-            }
-            
-            boolean isEmpty() {
-                return (count.get() == 0);
-            }
-
-            void destroy() {
-                for (Connection c : queue) {
-                    c.close().markForRecycle(true);
-                }
-                queue.clear();
-                queues.remove(this);
-            }
-
-        } // END IdleConnectionQueue
-
-
-        // ------------------------------------------------------ Nested Classes
-
-
-        static final class TimeoutResolver {
-
-            private static final String IDLE_ATTRIBUTE_NAME = "grizzly-ahc-conn-pool-idle-attribute";
-            private static final Attribute<IdleRecord> IDLE_ATTR =
-                    Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(
-                            IDLE_ATTRIBUTE_NAME, new NullaryFunction<IdleRecord>() {
-
-                        @Override
-                        public IdleRecord evaluate() {
-                            return new IdleRecord();
-                        }
-                    });
-
-
-            // ------------------------------------------------- Private Methods
-
-
-            boolean removeTimeout(final Connection c) {
-                IDLE_ATTR.get(c).timeoutMs = 0;
-                return true;
-            }
-
-            Long getTimeoutMs(final Connection c) {
-                return IDLE_ATTR.get(c).timeoutMs;
-            }
-
-            void setTimeoutMs(final Connection c, final long timeoutMs) {
-                IDLE_ATTR.get(c).timeoutMs = timeoutMs;
-            }
-
-
-            // -------------------------------------------------- Nested Classes
-
-            static final class IdleRecord {
-
-                volatile long timeoutMs;
-
-            } // END IdleRecord
-
-        } // END TimeoutResolver
-
-    } // END DelayedExecutor
-
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
new file mode 100644
index 000000000..51fc80a16
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.CompletionHandler;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.Grizzly;
+import org.glassfish.grizzly.GrizzlyFuture;
+import org.glassfish.grizzly.attributes.Attribute;
+import org.glassfish.grizzly.connectionpool.EndpointKey;
+import org.glassfish.grizzly.filterchain.FilterChainBuilder;
+import org.glassfish.grizzly.impl.FutureImpl;
+import org.glassfish.grizzly.utils.Futures;
+import org.glassfish.grizzly.utils.IdleTimeoutFilter;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public class ConnectionManager {
+
+    private static final Attribute<Boolean> DO_NOT_CACHE =
+        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(ConnectionManager.class.getName());
+    private final ConnectionPool connectionPool;
+    private final GrizzlyAsyncHttpProvider provider;
+    private final boolean canDestroyPool;
+    private final Map<String,EndpointKey<SocketAddress>> endpointKeyMap = new HashMap<String,EndpointKey<SocketAddress>>();
+    private final FilterChainBuilder secureBuilder;
+    private final FilterChainBuilder nonSecureBuilder;
+    private final boolean asyncConnect;
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    @SuppressWarnings("unchecked")
+    ConnectionManager(final GrizzlyAsyncHttpProvider provider,
+                      final ConnectionPool connectionPool,
+                      final FilterChainBuilder secureBuilder,
+                      final FilterChainBuilder nonSecureBuilder) {
+
+
+        this.provider = provider;
+        final AsyncHttpClientConfig config = provider.getClientConfig();
+        if (connectionPool != null) {
+            this.connectionPool = connectionPool;
+            canDestroyPool = false;
+        } else {
+            this.connectionPool =
+                    new ConnectionPool(config.getMaxConnectionPerHost(),
+                                       config.getMaxTotalConnections(),
+                                       null,
+                                       config.getConnectionTimeoutInMs(),
+                                       config.getIdleConnectionInPoolTimeoutInMs(),
+                                       2000);
+            canDestroyPool = true;
+        }
+        this.secureBuilder = secureBuilder;
+        this.nonSecureBuilder = nonSecureBuilder;
+        asyncConnect = config.isAsyncConnectMode();
+
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public void doTrackedConnection(final Request request,
+                                    final GrizzlyResponseFuture requestFuture,
+                                    final CompletionHandler<Connection> connectHandler)
+    throws IOException {
+        final EndpointKey<SocketAddress> key =
+                getEndPointKey(request, requestFuture.getProxyServer());
+
+        if (asyncConnect) {
+            connectionPool.take(key, connectHandler);
+        } else {
+            IOException ioe = null;
+            GrizzlyFuture<Connection> future = connectionPool.take(key);
+            try {
+                // No explicit timeout when calling get() here as the Grizzly
+                // endpoint pool will time it out based on the connect timeout
+                // setting.
+                connectHandler.completed(future.get());
+            } catch (CancellationException e) {
+                connectHandler.cancelled();
+            } catch (ExecutionException ee) {
+                final Throwable cause = ee.getCause();
+                if (cause instanceof ConnectionPool.MaxCapacityException) {
+                    ioe = (IOException) cause;
+                } else {
+                    connectHandler.failed(ee.getCause());
+                }
+            } catch (Exception ie) {
+                connectHandler.failed(ie);
+            }
+            if (ioe != null) {
+                throw ioe;
+            }
+        }
+    }
+
+    public Connection obtainConnection(final Request request,
+                                       final GrizzlyResponseFuture requestFuture)
+    throws ExecutionException, InterruptedException, TimeoutException {
+
+        final Connection c = obtainConnection0(request, requestFuture);
+        markConnectionAsDoNotCache(c);
+        return c;
+
+    }
+
+    // --------------------------------------------------Package Private Methods
+
+
+    static void markConnectionAsDoNotCache(final Connection c) {
+        DO_NOT_CACHE.set(c, Boolean.TRUE);
+    }
+
+    static boolean isConnectionCacheable(final Connection c) {
+        final Boolean canCache =  DO_NOT_CACHE.get(c);
+        return ((canCache != null) ? canCache : false);
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+    private EndpointKey<SocketAddress> getEndPointKey(final Request request,
+                                                      final ProxyServer proxyServer) {
+        final String stringKey = getPoolKey(request, proxyServer);
+        EndpointKey<SocketAddress> key = endpointKeyMap.get(stringKey);
+        if (key == null) {
+            synchronized (endpointKeyMap) {
+                key = endpointKeyMap.get(stringKey);
+                if (key == null) {
+                    SocketAddress address =
+                            getRemoteAddress(request, proxyServer);
+                    InetAddress localAddress = request.getLocalAddress();
+                    InetSocketAddress localSocketAddress = null;
+                    if (localAddress != null) {
+                        localSocketAddress = new InetSocketAddress(localAddress.getHostName(), 0);
+                    }
+                    ProxyAwareConnectorHandler handler =
+                            ProxyAwareConnectorHandler
+                                    .builder(provider.clientTransport)
+                                    .setNonSecureFilterChainTemplate(nonSecureBuilder)
+                                    .setSecureFilterChainTemplate(secureBuilder)
+                                    .setAsyncHttpClientConfig(provider.getClientConfig())
+                                    .setURI(request.getURI())
+                                    .setProxyServer(proxyServer)
+                                    .build();
+                    EndpointKey<SocketAddress> localKey =
+                            new EndpointKey<SocketAddress>(stringKey,
+                                               address,
+                                               localSocketAddress,
+                                               handler);
+                    endpointKeyMap.put(stringKey, localKey);
+                    key = localKey;
+                }
+            }
+        }
+        return key;
+    }
+
+    private SocketAddress getRemoteAddress(final Request request,
+                                           final ProxyServer proxyServer) {
+        final URI requestUri = request.getURI();
+        final String host = ((proxyServer != null)
+                ? proxyServer.getHost()
+                : requestUri.getHost());
+        final int port = ((proxyServer != null)
+                ? proxyServer.getPort()
+                : requestUri.getPort());
+        return new InetSocketAddress(host, getPort(request.getURI(), port));
+    }
+
+    private static int getPort(final URI uri, final int p) {
+        int port = p;
+        if (port == -1) {
+            final String protocol = uri.getScheme().toLowerCase();
+            if ("http".equals(protocol) || "ws".equals(protocol)) {
+                port = 80;
+            } else if ("https".equals(protocol) || "wss".equals(protocol)) {
+                port = 443;
+            } else {
+                throw new IllegalArgumentException(
+                        "Unknown protocol: " + protocol);
+            }
+        }
+        return port;
+    }
+
+    private Connection obtainConnection0(final Request request,
+                                         final GrizzlyResponseFuture requestFuture)
+    throws ExecutionException, InterruptedException, TimeoutException {
+
+        final int cTimeout = provider.getClientConfig().getConnectionTimeoutInMs();
+        final FutureImpl<Connection> future = Futures.createSafeFuture();
+        final CompletionHandler<Connection> ch = Futures.toCompletionHandler(future,
+                createConnectionCompletionHandler(request, requestFuture, null));
+        final ProxyServer proxyServer = requestFuture.getProxyServer();
+        final SocketAddress address = getRemoteAddress(request, proxyServer);
+        ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler
+                            .builder(provider.clientTransport)
+                            .setNonSecureFilterChainTemplate(nonSecureBuilder)
+                            .setSecureFilterChainTemplate(secureBuilder)
+                            .setAsyncHttpClientConfig(provider.getClientConfig())
+                            .setURI(request.getURI())
+                            .setProxyServer(proxyServer)
+                            .build();
+        if (cTimeout > 0) {
+            handler.connect(address, ch);
+            return future.get(cTimeout, MILLISECONDS);
+        } else {
+            handler.connect(address, ch);
+            return future.get();
+        }
+    }
+
+    boolean returnConnection(final Connection c) {
+        final boolean result = (DO_NOT_CACHE.get(c) == null
+                                   && connectionPool.release(c));
+        if (result) {
+            if (provider.getResolver() != null) {
+                provider.getResolver().setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
+            }
+        }
+        return result;
+
+    }
+
+
+    void destroy() {
+
+        if (canDestroyPool) {
+            connectionPool.close();
+        }
+
+    }
+
+    CompletionHandler<Connection> createConnectionCompletionHandler(final Request request,
+                                                                    final GrizzlyResponseFuture future,
+                                                                    final CompletionHandler<Connection> wrappedHandler) {
+        return new CompletionHandler<Connection>() {
+            public void cancelled() {
+                if (wrappedHandler != null) {
+                    wrappedHandler.cancelled();
+                } else {
+                    future.cancel(true);
+                }
+            }
+
+            public void failed(Throwable throwable) {
+                if (wrappedHandler != null) {
+                    wrappedHandler.failed(throwable);
+                } else {
+                    future.abort(throwable);
+                }
+            }
+
+            public void completed(Connection connection) {
+                future.setConnection(connection);
+                provider.touchConnection(connection, request);
+                if (wrappedHandler != null) {
+                    //connection.addCloseListener(connectionMonitor);
+                    wrappedHandler.completed(connection);
+                }
+            }
+
+            public void updated(Connection result) {
+                if (wrappedHandler != null) {
+                    wrappedHandler.updated(result);
+                }
+            }
+        };
+    }
+
+    private static String getPoolKey(final Request request, ProxyServer proxyServer) {
+        final ConnectionPoolKeyStrategy keyStrategy = request.getConnectionPoolKeyStrategy();
+        URI uri = proxyServer != null ? proxyServer.getURI() : request.getURI();
+        return keyStrategy.getKey(uri);
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
new file mode 100644
index 000000000..dae88f302
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.glassfish.grizzly.connectionpool.EndpointKey;
+import org.glassfish.grizzly.connectionpool.MultiEndpointPool;
+import org.glassfish.grizzly.connectionpool.SingleEndpointPool;
+import org.glassfish.grizzly.utils.DelayedExecutor;
+
+import java.io.IOException;
+import java.net.SocketAddress;
+
+/**
+ * Extension of standard Grizzly {@link MultiEndpointPool}.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public class ConnectionPool extends MultiEndpointPool<SocketAddress>{
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public ConnectionPool(final int maxConnectionsPerEndpoint,
+                          final int maxConnectionsTotal,
+                          final DelayedExecutor delayedExecutor,
+                          final long connectTimeoutMillis,
+                          final long keepAliveTimeoutMillis,
+                          final long keepAliveCheckIntervalMillis) {
+        super(null, maxConnectionsPerEndpoint,
+              maxConnectionsTotal, delayedExecutor, connectTimeoutMillis,
+              keepAliveTimeoutMillis, keepAliveCheckIntervalMillis, -1, -1);
+    }
+
+
+    // ------------------------------------------ Methods from MultiEndpointPool
+
+
+    protected SingleEndpointPool<SocketAddress> obtainSingleEndpointPool(
+            final EndpointKey<SocketAddress> endpointKey) throws IOException {
+        SingleEndpointPool<SocketAddress> sePool =
+                endpointToPoolMap.get(endpointKey);
+        if (sePool == null) {
+            synchronized (poolSync) {
+                checkNotClosed();
+                if (isMaxCapacityReached()) {
+                    throw new MaxCapacityException();
+                }
+                sePool = endpointToPoolMap.get(endpointKey);
+                if (sePool == null) {
+                    sePool = createSingleEndpointPool(endpointKey);
+                    endpointToPoolMap.put(endpointKey, sePool);
+                }
+            }
+        }
+
+        return sePool;
+    }
+
+
+    // ---------------------------------------------------------- Nested Classes
+
+
+    public static final class MaxCapacityException extends IOException {
+
+        public MaxCapacityException() {
+            super("Maximum pool capacity has been reached");
+        }
+
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
new file mode 100644
index 000000000..46a6830ff
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
@@ -0,0 +1,534 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
+import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
+import org.asynchttpclient.providers.grizzly.statushandler.AuthorizationHandler;
+import org.asynchttpclient.providers.grizzly.statushandler.ProxyAuthorizationHandler;
+import org.asynchttpclient.providers.grizzly.statushandler.RedirectHandler;
+import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
+import org.asynchttpclient.providers.grizzly.websocket.GrizzlyWebSocketAdapter;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpHeader;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.ProcessingState;
+import org.glassfish.grizzly.http.Protocol;
+import org.glassfish.grizzly.http.util.Header;
+import org.glassfish.grizzly.http.util.HttpStatus;
+import org.glassfish.grizzly.utils.IdleTimeoutFilter;
+import org.glassfish.grizzly.websockets.HandshakeException;
+import org.glassfish.grizzly.websockets.SimpleWebSocket;
+import org.glassfish.grizzly.websockets.WebSocketHolder;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+import static org.asynchttpclient.AsyncHandler.STATE.ABORT;
+import static org.asynchttpclient.AsyncHandler.STATE.UPGRADE;
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
+
+public final class EventHandler {
+
+    private static final Map<Integer, StatusHandler> HANDLER_MAP =
+            new HashMap<Integer, StatusHandler>();
+
+    static {
+        HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(),
+                AuthorizationHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.getStatusCode(),
+                ProxyAuthorizationHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.MOVED_PERMANENTLY_301.getStatusCode(),
+                RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.FOUND_302.getStatusCode(),
+                RedirectHandler.INSTANCE);
+        HANDLER_MAP.put(HttpStatus.TEMPORARY_REDIRECT_307.getStatusCode(),
+                RedirectHandler.INSTANCE);
+    }
+
+
+    private final GrizzlyAsyncHttpProvider provider;
+    GrizzlyAsyncHttpProvider.Cleanup cleanup;
+
+
+    // -------------------------------------------------------- Constructors
+
+
+    EventHandler(final GrizzlyAsyncHttpProvider provider) {
+        this.provider = provider;
+    }
+
+
+    // ----------------------------------------------------- Event Callbacks
+
+
+    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
+
+        HttpTransactionContext.get(ctx.getConnection()).abort(error);
+
+    }
+
+
+    public void onHttpContentParsed(HttpContent content,
+                                    FilterChainContext ctx) {
+
+        final HttpTransactionContext context =
+                HttpTransactionContext.get(ctx.getConnection());
+        final AsyncHandler handler = context.getHandler();
+        if (handler != null && context.getCurrentState() != ABORT) {
+            try {
+                context.setCurrentState(handler.onBodyPartReceived(
+                        new GrizzlyResponseBodyPart(content,
+                                                    context.getRequest().getURI(),
+                                                    ctx.getConnection(),
+                                                    provider)));
+            } catch (Exception e) {
+                handler.onThrowable(e);
+            }
+        }
+
+    }
+
+    @SuppressWarnings("UnusedParameters")
+    public void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        final AsyncHandler handler = context.getHandler();
+        if (handler != null) {
+            if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
+                ((TransferCompletionHandler) handler).onHeaderWriteCompleted();
+            }
+        }
+    }
+
+    public void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        final AsyncHandler handler = context.getHandler();
+        if (handler != null) {
+            if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
+                final int written = content.getContent().remaining();
+                final long total = context.getTotalBodyWritten().addAndGet(
+                        written);
+                ((TransferCompletionHandler) handler).onContentWriteProgress(
+                        written,
+                        total,
+                        content.getHttpHeader().getContentLength());
+            }
+        }
+    }
+
+    public void onInitialLineParsed(HttpHeader httpHeader,
+                                       FilterChainContext ctx) {
+
+        //super.onInitialLineParsed(httpHeader, ctx);
+        if (httpHeader.isSkipRemainder()) {
+            return;
+        }
+        final Connection connection = ctx.getConnection();
+        final HttpTransactionContext context =
+                HttpTransactionContext.get(connection);
+        final int status = ((HttpResponsePacket) httpHeader).getStatus();
+        if (context.isEstablishingTunnel() && HttpStatus.OK_200.statusMatches(status)) {
+            return;
+        }
+        if (HttpStatus.CONINTUE_100.statusMatches(status)) {
+            ctx.notifyUpstream(new ContinueEvent(context));
+            return;
+        }
+
+        StatusHandler statusHandler = context.getStatusHandler();
+        context.setStatusHandler(null);
+        if (statusHandler != null && !statusHandler.handlesStatus(status)) {
+            context.setStatusHandler(null);
+            context.setInvocationStatus(CONTINUE);
+        }
+
+        if (context.getInvocationStatus() == CONTINUE) {
+            if (HANDLER_MAP.containsKey(status)) {
+                context.setStatusHandler(HANDLER_MAP.get(status));
+            }
+            if (context.getStatusHandler() instanceof RedirectHandler) {
+                if (!isRedirectAllowed(context)) {
+                    context.setStatusHandler(null);
+                }
+            }
+        }
+        if (isRedirectAllowed(context)) {
+            if (isRedirect(status)) {
+                if (context.getStatusHandler() == null) {
+                    context.setStatusHandler(RedirectHandler.INSTANCE);
+                }
+                context.getRedirectCount().incrementAndGet();
+                if (redirectCountExceeded(context)) {
+                    httpHeader.setSkipRemainder(true);
+                    context.abort(new MaxRedirectException());
+                }
+            } else {
+                if (context.getRedirectCount().get() > 0) {
+                    context.getRedirectCount().set(0);
+                }
+            }
+        }
+        final GrizzlyResponseStatus responseStatus =
+                new GrizzlyResponseStatus((HttpResponsePacket) httpHeader,
+                        context.getRequest().getURI(),
+                        provider);
+        context.setResponseStatus(responseStatus);
+        if (context.getStatusHandler() != null) {
+            return;
+        }
+        if (context.getCurrentState() != ABORT) {
+
+            try {
+                final AsyncHandler handler = context.getHandler();
+                if (handler != null) {
+                    context.setCurrentState(handler.onStatusReceived(responseStatus));
+                    if (context.isWSRequest() && context.getCurrentState() == ABORT) {
+                        httpHeader.setSkipRemainder(true);
+                        context.abort(new HandshakeException("Upgrade failed"));
+                    }
+                }
+            } catch (Exception e) {
+                httpHeader.setSkipRemainder(true);
+                context.abort(e);
+            }
+        }
+
+    }
+
+
+    public void onHttpHeaderError(final HttpHeader httpHeader,
+                                     final FilterChainContext ctx,
+                                     final Throwable t) {
+
+        t.printStackTrace();
+        httpHeader.setSkipRemainder(true);
+        final HttpTransactionContext context =
+                HttpTransactionContext.get(ctx.getConnection());
+        context.abort(t);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public void onHttpHeadersParsed(HttpHeader httpHeader,
+                                       FilterChainContext ctx) {
+
+        //super.onHttpHeadersParsed(httpHeader, ctx);
+        GrizzlyAsyncHttpProvider.LOGGER.debug("RESPONSE: {}", httpHeader);
+        processKeepAlive(ctx.getConnection(), httpHeader);
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+
+        if (httpHeader.isSkipRemainder()
+                || (context.isEstablishingTunnel()
+                    && context.getStatusHandler() == null)) {
+            return;
+        }
+
+        final AsyncHandler handler = context.getHandler();
+        final List<ResponseFilter> filters = context.getProvider()
+                .getClientConfig().getResponseFilters();
+        final GrizzlyResponseHeaders responseHeaders =
+                new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader,
+                                           context.getRequest().getURI(),
+                                           provider);
+        if (!filters.isEmpty()) {
+            FilterContext fc = new FilterContext.FilterContextBuilder()
+                    .asyncHandler(handler).request(context.getRequest())
+                    .responseHeaders(responseHeaders)
+                    .responseStatus(context.getResponseStatus()).build();
+            try {
+                for (final ResponseFilter f : filters) {
+                    fc = f.filter(fc);
+                }
+            } catch (Exception e) {
+                context.abort(e);
+            }
+            if (fc.replayRequest()) {
+                httpHeader.setSkipRemainder(true);
+                final Request newRequest = fc.getRequest();
+                final AsyncHandler newHandler = fc.getAsyncHandler();
+                try {
+                    final ConnectionManager m =
+                            context.getProvider().getConnectionManager();
+                    final Connection c =
+                            m.obtainConnection(newRequest,
+                                               context.getFuture());
+                    final HttpTransactionContext newContext =
+                            context.copy();
+                    context.setFuture(null);
+                    HttpTransactionContext.set(c, newContext);
+                    context.getProvider().execute(c,
+                                                  newRequest,
+                                                  newHandler,
+                                                  context.getFuture());
+                } catch (Exception e) {
+                    context.abort(e);
+                }
+                return;
+            }
+        }
+        if (context.getStatusHandler() != null && context.getInvocationStatus() == CONTINUE) {
+            final boolean result =
+                    context.getStatusHandler().handleStatus(
+                            ((HttpResponsePacket) httpHeader),
+                            context,
+                            ctx);
+            if (!result) {
+                httpHeader.setSkipRemainder(true);
+                return;
+            }
+        }
+        if (context.isWSRequest()) {
+            try {
+                //in case of DIGEST auth protocol handler is null and just returning here is working
+                if(context.getProtocolHandler() == null)
+                {
+                    return;
+                    //context.protocolHandler = Version.DRAFT17.createHandler(true);
+                    //context.currentState = AsyncHandler.STATE.UPGRADE;
+                }
+
+                context.getProtocolHandler().setConnection(
+                        ctx.getConnection());
+
+                final GrizzlyWebSocketAdapter webSocketAdapter = createWebSocketAdapter(context);
+                context.setWebSocket(webSocketAdapter);
+                SimpleWebSocket ws = webSocketAdapter.getGrizzlyWebSocket();
+                if (context.getCurrentState() == UPGRADE) {
+                    httpHeader.setChunked(false);
+                    ws.onConnect();
+                    WebSocketHolder.set(ctx.getConnection(),
+                                        context.getProtocolHandler(),
+                                        ws);
+                    ((WebSocketUpgradeHandler) context.getHandler()).onSuccess(context.getWebSocket());
+                    final int wsTimeout = context.getProvider().getClientConfig().getWebSocketIdleTimeoutInMs();
+                    IdleTimeoutFilter.setCustomTimeout(ctx.getConnection(),
+                                                       ((wsTimeout <= 0)
+                                                               ? IdleTimeoutFilter.FOREVER
+                                                               : wsTimeout),
+                                                       TimeUnit.MILLISECONDS);
+                    context.result(handler.onCompleted());
+                } else {
+                    httpHeader.setSkipRemainder(true);
+                    ((WebSocketUpgradeHandler) context.getHandler()).
+                            onClose(context.getWebSocket(),
+                                    1002,
+                                    "WebSocket protocol error: unexpected HTTP response status during handshake.");
+                    context.result(null);
+                }
+            } catch (Exception e) {
+                httpHeader.setSkipRemainder(true);
+                context.abort(e);
+            }
+        } else {
+            if (context.getCurrentState() != ABORT) {
+                try {
+                    context.setCurrentState(
+                            handler.onHeadersReceived(responseHeaders));
+                } catch (Exception e) {
+                    httpHeader.setSkipRemainder(true);
+                    context.abort(e);
+                }
+            }
+        }
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+
+        boolean result;
+
+        Utils.removeRequestInFlight(ctx.getConnection());
+
+        if (cleanup != null) {
+            cleanup.cleanup(ctx);
+        }
+
+        if (httpHeader.isSkipRemainder()) {
+            if (Utils.getRequestInFlightCount(ctx.getConnection()) == 0) {
+                cleanup(ctx);
+            }
+            return false;
+        }
+
+        result = false;
+        final HttpResponsePacket response =
+                (HttpResponsePacket) httpHeader;
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        try {
+            if (context.isEstablishingTunnel()
+                    && HttpStatus.OK_200.statusMatches(response.getStatus())) {
+                context.setEstablishingTunnel(false);
+                final Connection c = ctx.getConnection();
+                context.tunnelEstablished(c);
+                context.getProvider().execute(c,
+                                              context.getRequest(),
+                                              context.getHandler(),
+                                              context.getFuture());
+                return result;
+            } else {
+                cleanup(ctx);
+                final AsyncHandler handler = context.getHandler();
+                if (handler != null) {
+                    try {
+                        context.result(handler.onCompleted());
+                    } catch (Exception e) {
+                        context.abort(e);
+                    }
+                } else {
+                    context.done(null);
+                }
+                return result;
+            }
+        } finally {
+            recycleRequestResponsePackets(response);
+        }
+
+    }
+
+
+    // ----------------------------------------------------- Private Methods
+
+    private static void recycleRequestResponsePackets(final HttpResponsePacket response) {
+        HttpRequestPacket request = response.getRequest();
+        request.setExpectContent(false);
+        response.recycle();
+        request.recycle();
+    }
+
+    private static void processKeepAlive(final Connection c,
+                                         final HttpHeader header) {
+        final ProcessingState state = header.getProcessingState();
+        final String connectionHeader = header.getHeader(Header.Connection);
+        if (connectionHeader == null) {
+            state.setKeepAlive(header.getProtocol() == Protocol.HTTP_1_1);
+        } else {
+            if ("close".equals(connectionHeader.toLowerCase())) {
+                ConnectionManager.markConnectionAsDoNotCache(c);
+                state.setKeepAlive(false);
+            } else {
+                state.setKeepAlive(true);
+            }
+        }
+    }
+
+
+    private static GrizzlyWebSocketAdapter createWebSocketAdapter(final HttpTransactionContext context) {
+        SimpleWebSocket ws = new SimpleWebSocket(context.getProtocolHandler());
+        AsyncHttpProviderConfig config = context.getProvider().getClientConfig().getAsyncHttpProviderConfig();
+        boolean bufferFragments = true;
+        if (config instanceof GrizzlyAsyncHttpProviderConfig) {
+            bufferFragments = (Boolean) ((GrizzlyAsyncHttpProviderConfig) config).getProperty(
+                    GrizzlyAsyncHttpProviderConfig.Property.BUFFER_WEBSOCKET_FRAGMENTS);
+        }
+
+        return new GrizzlyWebSocketAdapter(ws, bufferFragments);
+    }
+
+    private static boolean isRedirectAllowed(final HttpTransactionContext ctx) {
+        boolean allowed = ctx.getRequest().isRedirectEnabled();
+        if (ctx.getRequest().isRedirectOverrideSet()) {
+            return allowed;
+        }
+        if (!allowed) {
+            allowed = ctx.isRedirectsAllowed();
+        }
+        return allowed;
+    }
+
+    private static HttpTransactionContext cleanup(final FilterChainContext ctx) {
+
+        final Connection c = ctx.getConnection();
+        final HttpTransactionContext context =
+                HttpTransactionContext.get(c);
+        HttpTransactionContext.set(c, null);
+        if (!Utils.isIgnored(ctx.getConnection())) {
+            final ConnectionManager manager =
+                    context.getProvider().getConnectionManager();
+            //if (!manager.canReturnConnection(c)) {
+            //    context.abort(
+            //            new IOException("Maximum pooled connections exceeded"));
+            //} else {
+                if (!manager.returnConnection(c)) {
+                    ctx.getConnection().close();
+                }
+            //}
+        }
+
+        return context;
+
+    }
+
+
+    private static boolean redirectCountExceeded(final HttpTransactionContext context) {
+
+        return (context.getRedirectCount().get() > context.getMaxRedirectCount());
+
+    }
+
+
+    public static boolean isRedirect(final int status) {
+
+        return HttpStatus.MOVED_PERMANENTLY_301.statusMatches(status)
+                || HttpStatus.FOUND_302.statusMatches(status)
+                || HttpStatus.SEE_OTHER_303.statusMatches(status)
+                || HttpStatus.TEMPORARY_REDIRECT_307.statusMatches(status);
+
+    }
+
+
+    // ----------------------------------------------------- Private Methods
+
+
+    public static Request newRequest(final URI uri,
+                                      final HttpResponsePacket response,
+                                      final HttpTransactionContext ctx,
+                                      boolean asGet) {
+
+        final RequestBuilder builder = new RequestBuilder(ctx.getRequest());
+        if (asGet) {
+            builder.setMethod("GET");
+        }
+        builder.setUrl(uri.toString());
+
+        if (ctx.getProvider().getClientConfig().isRemoveQueryParamOnRedirect()) {
+            builder.setQueryParameters(null);
+        }
+        for (String cookieStr : response.getHeaders().values(Header.Cookie)) {
+            for (Cookie c : CookieDecoder.decode(cookieStr)) {
+                builder.addOrReplaceCookie(c);
+            }
+        }
+        return builder.build();
+
+    }
+
+
+} // END AsyncHttpClientEventFilter
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/FeedableBodyGenerator.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
similarity index 90%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/FeedableBodyGenerator.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
index 4e509964d..ad4febd66 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/FeedableBodyGenerator.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Queue;
@@ -44,6 +44,7 @@ public Body createBody() throws IOException {
         return new EmptyBody();
     }
     
+    @SuppressWarnings("UnusedDeclaration")
     public void feed(final Buffer buffer, final boolean isLast)
             throws IOException {
         queue.offer(new BodyPart(buffer, isLast));
@@ -54,14 +55,15 @@ public void feed(final Buffer buffer, final boolean isLast)
         }
     }
     
-    void initializeAsynchronousTransfer(final FilterChainContext context, 
-            final HttpRequestPacket requestPacket) throws IOException {
+    public void initializeAsynchronousTransfer(final FilterChainContext context,
+            final HttpRequestPacket requestPacket) {
         this.context = context;
         this.requestPacket = requestPacket;
         flushQueue();
     }
 
-    private void flushQueue() throws IOException {
+    @SuppressWarnings("unchecked")
+    private void flushQueue() {
         if (queueSize.get() > 0) {
             synchronized(this) {
                 while(queueSize.get() > 0) {
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
new file mode 100644
index 000000000..b334fb426
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -0,0 +1,630 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.ntlm.NTLMEngine;
+import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
+import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandlerFactory;
+import org.asynchttpclient.providers.grizzly.bodyhandler.ExpectHandler;
+import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientEventFilter;
+import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientFilter;
+import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientTransportFilter;
+import org.asynchttpclient.providers.grizzly.filters.AsyncSpdyClientEventFilter;
+import org.asynchttpclient.providers.grizzly.filters.ClientEncodingFilter;
+import org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.ProxyUtils;
+import org.asynchttpclient.util.SslUtils;
+
+import org.glassfish.grizzly.CompletionHandler;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.WriteResult;
+import org.glassfish.grizzly.filterchain.Filter;
+import org.glassfish.grizzly.filterchain.FilterChain;
+import org.glassfish.grizzly.filterchain.FilterChainBuilder;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.ContentEncoding;
+import org.glassfish.grizzly.http.GZipContentEncoding;
+import org.glassfish.grizzly.http.HttpClientFilter;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.http.Method;
+import org.glassfish.grizzly.npn.ClientSideNegotiator;
+import org.glassfish.grizzly.spdy.NextProtoNegSupport;
+import org.glassfish.grizzly.spdy.SpdyFramingFilter;
+import org.glassfish.grizzly.spdy.SpdyHandlerFilter;
+import org.glassfish.grizzly.spdy.SpdyMode;
+import org.glassfish.grizzly.spdy.SpdySession;
+import org.glassfish.grizzly.ssl.SSLBaseFilter;
+import org.glassfish.grizzly.ssl.SSLConnectionContext;
+import org.glassfish.grizzly.ssl.SSLUtils;
+import org.glassfish.grizzly.http.util.Header;
+import org.glassfish.grizzly.impl.SafeFutureImpl;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransportBuilder;
+import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
+import org.glassfish.grizzly.ssl.SSLFilter;
+import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
+import org.glassfish.grizzly.strategies.WorkerThreadIOStrategy;
+import org.glassfish.grizzly.utils.DelayedExecutor;
+import org.glassfish.grizzly.utils.IdleTimeoutFilter;
+import org.glassfish.grizzly.websockets.WebSocketClientFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.CONNECTION_POOL;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
+
+/**
+ * A Grizzly 2.0-based implementation of {@link AsyncHttpProvider}.
+ *
+ * @author The Grizzly Team
+ * @since 1.7.0
+ */
+@SuppressWarnings("rawtypes")
+public class GrizzlyAsyncHttpProvider implements AsyncHttpProvider {
+
+    public static final Logger LOGGER = LoggerFactory.getLogger(GrizzlyAsyncHttpProvider.class);
+    public final static NTLMEngine NTLM_ENGINE = new NTLMEngine();
+
+    private final BodyHandlerFactory bodyHandlerFactory;
+    private final AsyncHttpClientConfig clientConfig;
+
+    private ConnectionManager connectionManager;
+    private DelayedExecutor.Resolver<Connection> resolver;
+    private DelayedExecutor timeoutExecutor;
+
+    final TCPNIOTransport clientTransport;
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public GrizzlyAsyncHttpProvider(final AsyncHttpClientConfig clientConfig) {
+
+        this.clientConfig = clientConfig;
+        final TCPNIOTransportBuilder builder = TCPNIOTransportBuilder.newInstance();
+        clientTransport = builder.build();
+        initializeTransport(clientConfig);
+        try {
+            clientTransport.start();
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+        }
+        bodyHandlerFactory = new BodyHandlerFactory(this);
+
+    }
+
+
+    // ------------------------------------------ Methods from AsyncHttpProvider
+
+
+    /**
+     * {@inheritDoc}
+     */
+    public <T> ListenableFuture<T> execute(final Request request,
+            final AsyncHandler<T> handler) throws IOException {
+
+        final ProxyServer proxy = ProxyUtils.getProxyServer(clientConfig, request);
+        final GrizzlyResponseFuture<T> future = new GrizzlyResponseFuture<T>(this, request, handler, proxy);
+        future.setDelegate(SafeFutureImpl.<T>create());
+        final CompletionHandler<Connection>  connectHandler = new CompletionHandler<Connection>() {
+            @Override
+            public void cancelled() {
+                future.cancel(true);
+            }
+
+            @Override
+            public void failed(final Throwable throwable) {
+                future.abort(throwable);
+            }
+
+            @Override
+            public void completed(final Connection c) {
+                try {
+                    touchConnection(c, request);
+                    execute(c, request, handler, future);
+                } catch (Exception e) {
+                    failed(e);
+                }
+            }
+
+            @Override
+            public void updated(final Connection c) {
+                // no-op
+            }
+        };
+
+        connectionManager.doTrackedConnection(request, future, connectHandler);
+
+        return future;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void close() {
+
+        try {
+            connectionManager.destroy();
+            clientTransport.stop();
+            final ExecutorService service = clientConfig.executorService();
+            if (service != null) {
+                service.shutdown();
+            }
+            if (timeoutExecutor != null) {
+                timeoutExecutor.stop();
+            }
+        } catch (IOException ignored) { }
+
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    public Response prepareResponse(HttpResponseStatus status,
+                                    HttpResponseHeaders headers,
+                                    List<HttpResponseBodyPart> bodyParts) {
+
+        return new GrizzlyResponse(status,
+                                   headers,
+                                   bodyParts,
+                                   clientConfig.isRfc6265CookieEncoding());
+
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public AsyncHttpClientConfig getClientConfig() {
+        return clientConfig;
+    }
+
+    public ConnectionManager getConnectionManager() {
+        return connectionManager;
+    }
+
+    public DelayedExecutor.Resolver<Connection> getResolver() {
+        return resolver;
+    }
+
+
+    // ------------------------------------------------------- Protected Methods
+
+
+    @SuppressWarnings({"unchecked"})
+    public <T> ListenableFuture<T> execute(final Connection c,
+                                           final Request request,
+                                           final AsyncHandler<T> handler,
+                                           final GrizzlyResponseFuture<T> future) {
+            Utils.addRequestInFlight(c);
+            if (HttpTransactionContext.get(c) == null) {
+                HttpTransactionContext.create(this, future, request, handler, c);
+            }
+            c.write(request, createWriteCompletionHandler(future));
+
+        return future;
+    }
+
+
+    void initializeTransport(final AsyncHttpClientConfig clientConfig) {
+
+        final FilterChainBuilder secure = FilterChainBuilder.stateless();
+        secure.add(new AsyncHttpClientTransportFilter());
+
+        final int timeout = clientConfig.getRequestTimeoutInMs();
+        if (timeout > 0) {
+            int delay = 500;
+            if (timeout < delay) {
+                delay = timeout - 10;
+                if (delay <= 0) {
+                    delay = timeout;
+                }
+            }
+            timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
+            timeoutExecutor.start();
+            final IdleTimeoutFilter.TimeoutResolver timeoutResolver =
+                    new IdleTimeoutFilter.TimeoutResolver() {
+                        @Override
+                        public long getTimeout(FilterChainContext ctx) {
+                            final HttpTransactionContext context =
+                                    HttpTransactionContext.get(ctx.getConnection());
+                            if (context != null) {
+                                if (context.isWSRequest()) {
+                                    return clientConfig.getWebSocketIdleTimeoutInMs();
+                                }
+                                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, context.getRequest());
+                                if (requestTimeout > 0) {
+                                    return requestTimeout;
+                                }
+                            }
+                            return IdleTimeoutFilter.FOREVER;
+                        }
+                    };
+            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor,
+                    timeoutResolver,
+                    new IdleTimeoutFilter.TimeoutHandler() {
+                        public void onTimeout(Connection connection) {
+                            timeout(connection);
+                        }
+                    });
+            secure.add(timeoutFilter);
+            resolver = timeoutFilter.getResolver();
+        }
+
+        SSLContext context = clientConfig.getSSLContext();
+        if (context == null) {
+            try {
+                context = SslUtils.getSSLContext();
+            } catch (Exception e) {
+                throw new IllegalStateException(e);
+            }
+        }
+        final SSLEngineConfigurator configurator =
+                new SSLEngineConfigurator(context,
+                        true,
+                        false,
+                        false);
+        final SwitchingSSLFilter filter = new SwitchingSSLFilter(configurator);
+        secure.add(filter);
+        GrizzlyAsyncHttpProviderConfig providerConfig =
+                        (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
+
+        boolean npnEnabled = NextProtoNegSupport.isEnabled();
+        boolean spdyEnabled = clientConfig.isSpdyEnabled();
+
+        if (spdyEnabled) {
+            // if NPN isn't available, check to see if it has been explicitly
+            // disabled.  If it has, we assume the user knows what they are doing
+            // and we enable SPDY without NPN - this effectively disables standard
+            // HTTP/1.1 support.
+            if (!npnEnabled && providerConfig != null) {
+                if ((Boolean) providerConfig.getProperty(Property.NPN_ENABLED)) {
+                    // NPN hasn't been disabled, so it's most likely a configuration problem.
+                    // Log a warning and disable spdy support.
+                    LOGGER.warn("Next Protocol Negotiation support is not available.  SPDY support has been disabled.");
+                    spdyEnabled = false;
+                }
+            }
+        }
+
+        final AsyncHttpClientEventFilter eventFilter;
+        final EventHandler handler = new EventHandler(this);
+        if (providerConfig != null) {
+            eventFilter =
+                    new AsyncHttpClientEventFilter(handler,
+                                                   (Integer) providerConfig
+                                                           .getProperty(
+                                                                   MAX_HTTP_PACKET_HEADER_SIZE));
+        } else {
+            eventFilter = new AsyncHttpClientEventFilter(handler);
+        }
+        handler.cleanup = eventFilter;
+        ContentEncoding[] encodings = eventFilter.getContentEncodings();
+        if (encodings.length > 0) {
+            for (ContentEncoding encoding : encodings) {
+                eventFilter.removeContentEncoding(encoding);
+            }
+        }
+        if (clientConfig.isCompressionEnabled()) {
+            eventFilter.addContentEncoding(
+                    new GZipContentEncoding(512,
+                                            512,
+                                            new ClientEncodingFilter()));
+        }
+        secure.add(eventFilter);
+        final AsyncHttpClientFilter clientFilter =
+                new AsyncHttpClientFilter(this, clientConfig);
+        secure.add(clientFilter);
+        secure.add(new WebSocketClientFilter());
+
+
+        if (providerConfig != null) {
+            final TransportCustomizer customizer = (TransportCustomizer)
+                    providerConfig.getProperty(Property.TRANSPORT_CUSTOMIZER);
+            if (customizer != null) {
+                customizer.customize(clientTransport, secure);
+            } else {
+                doDefaultTransportConfig();
+            }
+        } else {
+            doDefaultTransportConfig();
+        }
+
+        // FilterChain for the standard HTTP case has been configured, we now
+        // copy it and modify for SPDY purposes.
+        if (spdyEnabled) {
+            FilterChainBuilder spdyFilterChain =
+                    createSpdyFilterChain(secure, npnEnabled);
+            ProtocolNegotiator pn =
+                    new ProtocolNegotiator(spdyFilterChain.build());
+            NextProtoNegSupport.getInstance()
+                    .setClientSideNegotiator(clientTransport, pn);
+        }
+
+        // Don't limit the number of bytes the client can have queued to write.
+        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(-1);
+
+        // Install the HTTP filter chain.
+        //clientTransport.setProcessor(fcb.build());
+        FilterChainBuilder nonSecure = FilterChainBuilder.stateless();
+        nonSecure.addAll(secure);
+        int idx = nonSecure.indexOfType(SSLFilter.class);
+        nonSecure.remove(idx);
+        final ConnectionPool pool;
+        if (providerConfig != null) {
+            pool = (ConnectionPool) providerConfig.getProperty(CONNECTION_POOL);
+        } else {
+            pool = null;
+        }
+        connectionManager = new ConnectionManager(this,
+                                                  pool,
+                                                  secure,
+                                                  nonSecure);
+
+    }
+
+
+    // ------------------------------------------------- Package Private Methods
+
+
+    void touchConnection(final Connection c, final Request request) {
+
+        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, request);
+        if (requestTimeout > 0) {
+            if (resolver != null) {
+                resolver.setTimeoutMillis(c, System.currentTimeMillis() + requestTimeout);
+            }
+        }
+
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb,
+                                                     final boolean npnEnabled) {
+
+        FilterChainBuilder spdyFcb = FilterChainBuilder.stateless();
+        spdyFcb.addAll(fcb);
+        int idx = spdyFcb.indexOfType(SSLFilter.class);
+        Filter f = spdyFcb.get(idx);
+
+
+        // Adjust the SSLFilter to support NPN
+        if (npnEnabled) {
+            SSLBaseFilter sslBaseFilter = (SSLBaseFilter) f;
+            NextProtoNegSupport.getInstance().configure(sslBaseFilter);
+        }
+
+        // Remove the HTTP Client filter - this will be replaced by the
+        // SPDY framing and handler filters.
+        idx = spdyFcb.indexOfType(HttpClientFilter.class);
+        spdyFcb.set(idx, new SpdyFramingFilter());
+        final SpdyMode spdyMode = ((npnEnabled) ? SpdyMode.NPN : SpdyMode.PLAIN);
+        AsyncSpdyClientEventFilter spdyFilter =
+                new AsyncSpdyClientEventFilter(new EventHandler(this),
+                                               spdyMode,
+                                               clientConfig.executorService());
+        spdyFilter.setInitialWindowSize(clientConfig.getSpdyInitialWindowSize());
+        spdyFilter.setMaxConcurrentStreams(clientConfig.getSpdyMaxConcurrentStreams());
+        spdyFcb.add(idx + 1, spdyFilter);
+
+        // Remove the WebSocket filter - not currently supported.
+        idx = spdyFcb.indexOfType(WebSocketClientFilter.class);
+        spdyFcb.remove(idx);
+
+        return spdyFcb;
+    }
+
+
+
+
+    private void doDefaultTransportConfig() {
+        final ExecutorService service = clientConfig.executorService();
+        if (service != null) {
+            clientTransport.setIOStrategy(WorkerThreadIOStrategy.getInstance());
+            clientTransport.setWorkerThreadPool(service);
+        } else {
+            clientTransport.setIOStrategy(SameThreadIOStrategy.getInstance());
+        }
+    }
+
+    private <T> CompletionHandler<WriteResult> createWriteCompletionHandler(final GrizzlyResponseFuture<T> future) {
+        return new CompletionHandler<WriteResult>() {
+
+            public void cancelled() {
+                future.cancel(true);
+            }
+
+            public void failed(Throwable throwable) {
+                future.abort(throwable);
+            }
+
+            public void completed(WriteResult result) {
+            }
+
+            public void updated(WriteResult result) {
+                // no-op
+            }
+
+        };
+    }
+
+
+    void timeout(final Connection c) {
+
+        final HttpTransactionContext context = HttpTransactionContext.get(c);
+        if (context != null) {
+            HttpTransactionContext.set(c, null);
+            context.abort(new TimeoutException("Timeout exceeded"));
+        }
+
+    }
+
+
+    @SuppressWarnings({"unchecked"})
+    public boolean sendRequest(final FilterChainContext ctx,
+                               final Request request,
+                               final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        boolean isWriteComplete = true;
+
+        if (requestHasEntityBody(request)) {
+            final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+            BodyHandler handler = bodyHandlerFactory.getBodyHandler(request);
+            if (requestPacket.getHeaders().contains(Header.Expect)
+                    && requestPacket.getHeaders().getValue(1).equalsIgnoreCase("100-Continue")) {
+                // We have to set the content-length now as the headers will be flushed
+                // before the FileBodyHandler is invoked.  If we don't do it here, and
+                // the user didn't explicitly set the length, then the transfer-encoding
+                // will be chunked and zero-copy file transfer will not occur.
+                final File f = request.getFile();
+                if (f != null) {
+                    requestPacket.setContentLengthLong(f.length());
+                }
+                handler = new ExpectHandler(handler);
+            }
+            context.setBodyHandler(handler);
+            isWriteComplete = handler.doHandle(ctx, request, requestPacket);
+        } else {
+            HttpContent content = HttpContent.builder(requestPacket).last(true).build();
+            ctx.write(content, ctx.getTransportContext().getCompletionHandler());
+        }
+        LOGGER.debug("REQUEST: {}", requestPacket);
+
+        return isWriteComplete;
+    }
+
+
+    public static boolean requestHasEntityBody(final Request request) {
+
+        final String method = request.getMethod();
+        return (Method.POST.matchesMethod(method)
+                || Method.PUT.matchesMethod(method)
+                || Method.PATCH.matchesMethod(method)
+                || Method.DELETE.matchesMethod(method));
+
+    }
+
+
+    // ----------------------------------------------------------- Inner Classes
+
+
+    // ---------------------------------------------------------- Nested Classes
+
+
+    private static final class ProtocolNegotiator implements ClientSideNegotiator {
+
+
+        private static final String SPDY = "spdy/3";
+        private static final String HTTP = "HTTP/1.1";
+
+        private final FilterChain spdyFilterChain;
+        private final SpdyHandlerFilter spdyHandlerFilter;
+
+
+        // -------------------------------------------------------- Constructors
+
+        private ProtocolNegotiator(final FilterChain spdyFilterChain) {
+            this.spdyFilterChain = spdyFilterChain;
+            int idx = spdyFilterChain.indexOfType(SpdyHandlerFilter.class);
+            spdyHandlerFilter = (SpdyHandlerFilter) spdyFilterChain.get(idx);
+        }
+
+
+        // ----------------------------------- Methods from ClientSideNegotiator
+
+
+        @Override
+        public boolean wantNegotiate(SSLEngine engine) {
+            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::wantNegotiate");
+            return true;
+        }
+
+        @Override
+        public String selectProtocol(SSLEngine engine, LinkedHashSet<String> strings) {
+            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selectProtocol: " + strings);
+            final Connection connection = NextProtoNegSupport.getConnection(engine);
+
+            // Give preference to SPDY/3.  If not available, check for HTTP as a
+            // fallback
+            if (strings.contains(SPDY)) {
+                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + SPDY);
+                SSLConnectionContext sslCtx =
+                                        SSLUtils.getSslConnectionContext(connection);
+                                sslCtx.setNewConnectionFilterChain(spdyFilterChain);
+                final SpdySession spdySession =
+                        new SpdySession(connection, false, spdyHandlerFilter);
+                spdySession.setLocalInitialWindowSize(spdyHandlerFilter.getInitialWindowSize());
+                spdySession.setLocalMaxConcurrentStreams(spdyHandlerFilter.getMaxConcurrentStreams());
+
+                SpdySession.bind(connection, spdySession);
+                return SPDY;
+            } else if (strings.contains(HTTP)) {
+                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + HTTP);
+                // Use the default HTTP FilterChain.
+                return HTTP;
+            } else {
+                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting NONE");
+                // no protocol support.  Will close the connection when
+                // onNoDeal is invoked
+                return "";
+            }
+        }
+
+        @Override
+        public void onNoDeal(SSLEngine engine) {
+            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::onNoDeal");
+            final Connection connection = NextProtoNegSupport.getConnection(engine);
+            connection.closeSilently();
+        }
+    }
+
+
+    public static interface Cleanup {
+
+        void cleanup(final FilterChainContext ctx);
+
+    }
+
+}
+
+
+
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
similarity index 81%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
index e79473859..dd1d940e5 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
@@ -11,9 +11,9 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpProviderConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
 import org.glassfish.grizzly.http.HttpCodecFilter;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
 
@@ -24,7 +24,7 @@
 /**
  * {@link AsyncHttpProviderConfig} implementation that allows customization
  * of the Grizzly runtime outside of the scope of what the
- * {@link com.ning.http.client.AsyncHttpClientConfig} offers.
+ * {@link org.asynchttpclient.AsyncHttpClientConfig} offers.
  *
  * @see Property
  * 
@@ -57,7 +57,28 @@
          *
          * @since 1.8
          */
-        MAX_HTTP_PACKET_HEADER_SIZE(Integer.class, HttpCodecFilter.DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
+        MAX_HTTP_PACKET_HEADER_SIZE(Integer.class, HttpCodecFilter.DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE),
+
+        /**
+         * By default, Websocket messages that are fragmented will be buffered.  Once all
+         * fragments have been accumulated, the appropriate onMessage() call back will be
+         * invoked with the complete message.  If this functionality is not desired, set
+         * this property to false.
+         */
+        BUFFER_WEBSOCKET_FRAGMENTS(Boolean.class, true),
+
+        /**
+         * By disabling NPN support, SPDY will be used over secure or non-secure channels,
+         * but no negotiation of the protocol via NPN will occur.  In short, this means
+         * that this instance of AHC will only 'speak' SPDY - HTTP is effectively disabled.
+         */
+        NPN_ENABLED(Boolean.class, true),
+
+
+        /**
+         * Grizzly specific connection pool.
+         */
+        CONNECTION_POOL(ConnectionPool.class, null);
         
         
         final Object defaultValue;
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
similarity index 77%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
index 6bf78717d..25aed3269 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
@@ -11,18 +11,20 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.providers.ResponseBase;
-import com.ning.http.util.AsyncHttpProviderUtils;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.glassfish.grizzly.http.CookiesBuilder.ServerCookiesBuilder;
+
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.providers.ResponseBase;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.http.Cookies;
-import org.glassfish.grizzly.http.CookiesBuilder;
 import org.glassfish.grizzly.utils.Charsets;
 import org.glassfish.grizzly.memory.Buffers;
 import org.glassfish.grizzly.memory.MemoryManager;
@@ -36,7 +38,7 @@
 import java.util.List;
 
 /**
- * {@link com.ning.http.client.HttpResponseBodyPart} implementation using the Grizzly 2.0 HTTP client
+ * {@link org.asynchttpclient.HttpResponseBodyPart} implementation using the Grizzly 2.0 HTTP client
  * codec.
  *
  * @author The Grizzly Team
@@ -44,16 +46,18 @@
  */
 public class GrizzlyResponse extends ResponseBase {
     private final Buffer responseBody;
+    private final Boolean rfc6265Enabled;
 
     // ------------------------------------------------------------ Constructors
 
 
     public GrizzlyResponse(final HttpResponseStatus status,
                            final HttpResponseHeaders headers,
-                           final List<HttpResponseBodyPart> bodyParts) {
+                           final List<HttpResponseBodyPart> bodyParts,
+                           final boolean rfc6265Enabled) {
         super(status, headers, bodyParts);
-
-        if (bodyParts != null && !bodyParts.isEmpty()) {
+        this.rfc6265Enabled = rfc6265Enabled;
+        if (isNonEmpty(bodyParts)) {
             if (bodyParts.size() == 1) {
                 responseBody = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
             } else {
@@ -136,25 +140,33 @@ public String getResponseBodyExcerpt(int maxLength) throws IOException {
      */
     public String getResponseBody() throws IOException {
 
-        return getResponseBody(Charsets.DEFAULT_CHARACTER_ENCODING);
+        return getResponseBody(null);
 
     }
 
+    /**
+     * @return the response body as a Grizzly {@link Buffer}.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public Buffer getResponseBodyAsBuffer() {
+        return responseBody;
+    }
+
     /**
      * {@inheritDoc}
      */
     public List<Cookie> buildCookies() {
 
         List<String> values = headers.getHeaders().get("set-cookie");
-        if (values != null && !values.isEmpty()) {
-            CookiesBuilder.ServerCookiesBuilder builder = new CookiesBuilder.ServerCookiesBuilder(false);
+        if (isNonEmpty(values)) {
+            ServerCookiesBuilder builder = new ServerCookiesBuilder(false, rfc6265Enabled);
             for (String header : values) {
                 builder.parse(header);
             }
             return convertCookies(builder.build());
 
         } else {
-        	return Collections.unmodifiableList(Collections.<Cookie>emptyList());
+            return Collections.unmodifiableList(Collections.<Cookie>emptyList());
         }
     }
 
@@ -169,10 +181,16 @@ public String getResponseBody() throws IOException {
             convertedCookies.add(new Cookie(gCookie.getDomain(),
                                    gCookie.getName(),
                                    gCookie.getValue(),
+                                   gCookie.getValue(),
                                    gCookie.getPath(),
                                    gCookie.getMaxAge(),
                                    gCookie.isSecure(),
-                                   gCookie.getVersion()));
+                                   gCookie.getVersion(),
+                                   gCookie.isHttpOnly(),
+                                   false,
+                                   gCookie.getComment(),
+                                   null,
+                                   Collections.<Integer> emptySet()));
         }
         return Collections.unmodifiableList(convertedCookies);
 
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseBodyPart.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
similarity index 89%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseBodyPart.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
index c41eba9d7..e0a2931ac 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseBodyPart.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
@@ -11,10 +11,10 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseBodyPart;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseBodyPart;
 
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.Connection;
@@ -28,8 +28,6 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider.ConnectionManager.*;
-
 /**
  * {@link HttpResponseBodyPart} implementation using the Grizzly 2.0 HTTP client
  * codec.
@@ -37,7 +35,7 @@
  * @author The Grizzly Team
  * @since 1.7.0
  */
-public class GrizzlyResponseBodyPart extends HttpResponseBodyPart {
+class GrizzlyResponseBodyPart extends HttpResponseBodyPart {
 
     private final HttpContent content;
     private final Connection<?> connection;
@@ -127,7 +125,7 @@ public boolean isLast() {
      */
     @Override
     public void markUnderlyingConnectionAsClosed() {
-        markConnectionAsDoNotCache(connection);
+        ConnectionManager.markConnectionAsDoNotCache(connection);
     }
 
     /**
@@ -135,7 +133,7 @@ public void markUnderlyingConnectionAsClosed() {
      */
     @Override
     public boolean closeUnderlyingConnection() {
-        return !isConnectionCacheable(connection);
+        return !ConnectionManager.isConnectionCacheable(connection);
     }
 
 
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseFuture.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
similarity index 72%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseFuture.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
index efa6c5186..92534f502 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseFuture.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -11,11 +11,12 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.Request;
-import com.ning.http.client.listenable.AbstractListenableFuture;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
 
 import org.glassfish.grizzly.Connection;
 import org.glassfish.grizzly.impl.FutureImpl;
@@ -37,10 +38,11 @@
 public class GrizzlyResponseFuture<V> extends AbstractListenableFuture<V> {
 
     private final AtomicBoolean done = new AtomicBoolean(false);
+    private final AtomicBoolean cancelled = new AtomicBoolean(false);
     private final AsyncHandler handler;
     private final GrizzlyAsyncHttpProvider provider;
     private final Request request;
-
+    private final ProxyServer proxyServer;
     private Connection connection;
 
     FutureImpl<V> delegate;
@@ -49,14 +51,15 @@
     // ------------------------------------------------------------ Constructors
 
 
-    GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider,
+    public GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider,
                           final Request request,
-                          final AsyncHandler handler) {
+                          final AsyncHandler handler,
+                          final ProxyServer proxyServer) {
 
         this.provider = provider;
         this.request = request;
         this.handler = handler;
-
+        this.proxyServer = proxyServer;
     }
 
 
@@ -65,17 +68,25 @@
 
     public void done(Callable callable) {
 
-        done.compareAndSet(false, true);
-        super.done();
+        if (!done.compareAndSet(false, true) || cancelled.get()) {
+            return;
+        }
+        done();
 
     }
 
 
     public void abort(Throwable t) {
 
+        if (done.get() || !cancelled.compareAndSet(false, true)) {
+            return;
+        }
         delegate.failure(t);
         if (handler != null) {
-            handler.onThrowable(t);
+            try {
+                handler.onThrowable(t);
+            } catch (Throwable ignore) {
+            }
         }
         closeConnection();
         done();
@@ -120,7 +131,15 @@ public boolean getAndSetWriteBody(boolean writeBody) {
 
     public boolean cancel(boolean mayInterruptIfRunning) {
 
-        handler.onThrowable(new CancellationException());
+        if (done.get() || !cancelled.compareAndSet(false, true)) {
+            return false;
+        }
+        if (handler != null) {
+            try {
+                handler.onThrowable(new CancellationException());
+            } catch (Throwable ignore) {
+            }
+        }
         done();
         return delegate.cancel(mayInterruptIfRunning);
 
@@ -169,7 +188,7 @@ void setConnection(final Connection connection) {
     }
 
 
-    void setDelegate(final FutureImpl<V> delegate) {
+    public void setDelegate(final FutureImpl<V> delegate) {
 
         this.delegate = delegate;
 
@@ -181,10 +200,13 @@ void setDelegate(final FutureImpl<V> delegate) {
 
     private void closeConnection() {
 
-        if (connection != null && !connection.isOpen()) {
-            connection.close().markForRecycle(true);
+        if (connection != null && connection.isOpen()) {
+            connection.close().recycle(true);
         }
 
     }
 
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
 }
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseHeaders.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
similarity index 65%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseHeaders.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
index 03e175f1a..4352a51a9 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseHeaders.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
@@ -11,11 +11,11 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseHeaders;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
 
 import org.glassfish.grizzly.http.HttpResponsePacket;
 import org.glassfish.grizzly.http.util.MimeHeaders;
@@ -30,12 +30,10 @@
  * @author The Grizzly Team
  * @since 1.7.0
  */
-public class GrizzlyResponseHeaders extends HttpResponseHeaders {
+class GrizzlyResponseHeaders extends HttpResponseHeaders {
 
     private final FluentCaseInsensitiveStringsMap headers =
             new FluentCaseInsensitiveStringsMap();
-    private final HttpResponsePacket response;
-    private volatile boolean initialized;
 
     // ------------------------------------------------------------ Constructors
 
@@ -45,7 +43,12 @@ public GrizzlyResponseHeaders(final HttpResponsePacket response,
                                   final AsyncHttpProvider provider) {
 
         super(uri, provider);
-        this.response = response;
+        final MimeHeaders headersLocal = response.getHeaders();
+        for (String name : headersLocal.names()) {
+            for (String header : headersLocal.values(name)) {
+                headers.add(name, header);
+            }
+        }
 
     }
 
@@ -58,22 +61,12 @@ public GrizzlyResponseHeaders(final HttpResponsePacket response,
      */
     @Override
     public FluentCaseInsensitiveStringsMap getHeaders() {
-        if (!initialized) {
-            synchronized (headers) {
-                if (!initialized) {
-                    initialized = true;
-                    final MimeHeaders headersLocal = response.getHeaders();
-                    for (String name : headersLocal.names()) {
-                        for (String header : headersLocal.values(name)) {
-                            headers.add(name, header);
-                        }
-                    }
-                }
-            }
-        }
         return headers;
     }
 
 
-
+    @Override
+    public String toString() {
+        return getHeaders().toString();
+    }
 }
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseStatus.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
similarity index 70%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseStatus.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
index 2f25d35d6..e4e74e3c9 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponseStatus.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
@@ -11,10 +11,10 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseStatus;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseStatus;
 
 import org.glassfish.grizzly.http.HttpResponsePacket;
 
@@ -29,7 +29,13 @@
  */
 public class GrizzlyResponseStatus extends HttpResponseStatus {
 
-    private final HttpResponsePacket response;
+    private static final String PROTOCOL_NAME = "HTTP";
+    private final int statusCode;
+    private final String statusText;
+    private final int majorVersion;
+    private final int minorVersion;
+    private final String protocolText;
+
 
 
     // ------------------------------------------------------------ Constructors
@@ -40,7 +46,11 @@ public GrizzlyResponseStatus(final HttpResponsePacket response,
                                  final AsyncHttpProvider provider) {
 
         super(uri, provider);
-        this.response = response;
+        statusCode = response.getStatus();
+        statusText = response.getReasonPhrase();
+        majorVersion = response.getProtocol().getMajorVersion();
+        minorVersion = response.getProtocol().getMinorVersion();
+        protocolText = response.getProtocolString();
 
     }
 
@@ -54,7 +64,7 @@ public GrizzlyResponseStatus(final HttpResponsePacket response,
     @Override
     public int getStatusCode() {
 
-        return response.getStatus();
+        return statusCode;
 
     }
 
@@ -65,7 +75,7 @@ public int getStatusCode() {
     @Override
     public String getStatusText() {
 
-        return response.getReasonPhrase();
+        return statusText;
 
     }
 
@@ -76,7 +86,7 @@ public String getStatusText() {
     @Override
     public String getProtocolName() {
 
-        return "http";
+        return PROTOCOL_NAME;
 
     }
 
@@ -87,7 +97,7 @@ public String getProtocolName() {
     @Override
     public int getProtocolMajorVersion() {
 
-        return response.getProtocol().getMajorVersion();
+        return majorVersion;
 
     }
 
@@ -98,7 +108,7 @@ public int getProtocolMajorVersion() {
     @Override
     public int getProtocolMinorVersion() {
 
-        return response.getProtocol().getMinorVersion();
+        return minorVersion;
 
     }
 
@@ -108,7 +118,9 @@ public int getProtocolMinorVersion() {
      */
     @Override
     public String getProtocolText() {
-        return response.getProtocolString();
+
+        return protocolText;
+
     }
 
 }
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java
new file mode 100644
index 000000000..5e726acac
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTransactionContext.java
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
+import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
+import org.asynchttpclient.websocket.WebSocket;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.Grizzly;
+import org.glassfish.grizzly.attributes.Attribute;
+import org.glassfish.grizzly.attributes.AttributeStorage;
+import org.glassfish.grizzly.websockets.HandShake;
+import org.glassfish.grizzly.websockets.ProtocolHandler;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus;
+
+public final class HttpTransactionContext {
+
+    private static final Attribute<HttpTransactionContext> REQUEST_STATE_ATTR =
+                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(HttpTransactionContext.class.getName());
+
+    private final AtomicInteger redirectCount = new AtomicInteger(0);
+
+    private final int maxRedirectCount;
+    private final boolean redirectsAllowed;
+    private final GrizzlyAsyncHttpProvider provider;
+
+    private Request request;
+    private String requestUrl;
+    private final AsyncHandler handler;
+    private BodyHandler bodyHandler;
+    private StatusHandler statusHandler;
+    private InvocationStatus invocationStatus = InvocationStatus.CONTINUE;
+    private GrizzlyResponseStatus responseStatus;
+    private GrizzlyResponseFuture future;
+    private String lastRedirectURI;
+    private final AtomicLong totalBodyWritten = new AtomicLong();
+    private AsyncHandler.STATE currentState;
+
+    private String wsRequestURI;
+    private boolean isWSRequest;
+    private HandShake handshake;
+    private ProtocolHandler protocolHandler;
+    private WebSocket webSocket;
+    private boolean establishingTunnel;
+
+
+    // -------------------------------------------------------- Constructors
+
+
+    private HttpTransactionContext(GrizzlyAsyncHttpProvider provider,
+                           final GrizzlyResponseFuture future,
+                           final Request request,
+                           final AsyncHandler handler) {
+        this.provider = provider;
+
+        this.future = future;
+        this.request = request;
+        this.handler = handler;
+        redirectsAllowed = this.provider.getClientConfig().isRedirectEnabled();
+        maxRedirectCount = this.provider.getClientConfig().getMaxRedirects();
+        this.requestUrl = request.getUrl();
+
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public static void set(final AttributeStorage storage,
+                           final HttpTransactionContext httpTransactionState) {
+
+        if (httpTransactionState == null) {
+            REQUEST_STATE_ATTR.remove(storage);
+        } else {
+            REQUEST_STATE_ATTR.set(storage, httpTransactionState);
+        }
+
+    }
+
+    public static HttpTransactionContext get(final AttributeStorage storage) {
+
+        return REQUEST_STATE_ATTR.get(storage);
+
+    }
+
+
+    public static HttpTransactionContext create(final GrizzlyAsyncHttpProvider provider,
+                                                final GrizzlyResponseFuture future,
+                                                final Request request,
+                                                final AsyncHandler handler,
+                                                final AttributeStorage storage) {
+        final HttpTransactionContext context =
+                new HttpTransactionContext(provider, future, request, handler);
+        set(storage, context);
+        return context;
+    }
+
+
+    public void abort(final Throwable t) {
+        if (future != null) {
+            future.abort(t);
+        }
+    }
+
+    public AtomicInteger getRedirectCount() {
+        return redirectCount;
+    }
+
+    public int getMaxRedirectCount() {
+        return maxRedirectCount;
+    }
+
+    public boolean isRedirectsAllowed() {
+        return redirectsAllowed;
+    }
+
+    public GrizzlyAsyncHttpProvider getProvider() {
+        return provider;
+    }
+
+    public Request getRequest() {
+        return request;
+    }
+
+    public void setRequest(Request request) {
+        this.request = request;
+    }
+
+    public String getRequestUrl() {
+        return requestUrl;
+    }
+
+    public void setRequestUrl(String requestUrl) {
+        this.requestUrl = requestUrl;
+    }
+
+    public AsyncHandler getHandler() {
+        return handler;
+    }
+
+    public BodyHandler getBodyHandler() {
+        return bodyHandler;
+    }
+
+    public void setBodyHandler(BodyHandler bodyHandler) {
+        this.bodyHandler = bodyHandler;
+    }
+
+    public StatusHandler getStatusHandler() {
+        return statusHandler;
+    }
+
+    public void setStatusHandler(StatusHandler statusHandler) {
+        this.statusHandler = statusHandler;
+    }
+
+    public InvocationStatus getInvocationStatus() {
+        return invocationStatus;
+    }
+
+    public void setInvocationStatus(InvocationStatus invocationStatus) {
+        this.invocationStatus = invocationStatus;
+    }
+
+    public GrizzlyResponseStatus getResponseStatus() {
+        return responseStatus;
+    }
+
+    public void setResponseStatus(GrizzlyResponseStatus responseStatus) {
+        this.responseStatus = responseStatus;
+    }
+
+    public GrizzlyResponseFuture getFuture() {
+        return future;
+    }
+
+    public void setFuture(GrizzlyResponseFuture future) {
+        this.future = future;
+    }
+
+    public String getLastRedirectURI() {
+        return lastRedirectURI;
+    }
+
+    public void setLastRedirectURI(String lastRedirectURI) {
+        this.lastRedirectURI = lastRedirectURI;
+    }
+
+    public AtomicLong getTotalBodyWritten() {
+        return totalBodyWritten;
+    }
+
+    public AsyncHandler.STATE getCurrentState() {
+        return currentState;
+    }
+
+    public void setCurrentState(AsyncHandler.STATE currentState) {
+        this.currentState = currentState;
+    }
+
+    public String getWsRequestURI() {
+        return wsRequestURI;
+    }
+
+    public void setWsRequestURI(String wsRequestURI) {
+        this.wsRequestURI = wsRequestURI;
+    }
+
+    public boolean isWSRequest() {
+        return isWSRequest;
+    }
+
+    public void setWSRequest(boolean WSRequest) {
+        isWSRequest = WSRequest;
+    }
+
+    public HandShake getHandshake() {
+        return handshake;
+    }
+
+    public void setHandshake(HandShake handshake) {
+        this.handshake = handshake;
+    }
+
+    public ProtocolHandler getProtocolHandler() {
+        return protocolHandler;
+    }
+
+    public void setProtocolHandler(ProtocolHandler protocolHandler) {
+        this.protocolHandler = protocolHandler;
+    }
+
+    public WebSocket getWebSocket() {
+        return webSocket;
+    }
+
+    public void setWebSocket(WebSocket webSocket) {
+        this.webSocket = webSocket;
+    }
+
+    public boolean isEstablishingTunnel() {
+        return establishingTunnel;
+    }
+
+    public void setEstablishingTunnel(boolean establishingTunnel) {
+        this.establishingTunnel = establishingTunnel;
+    }
+
+
+    // ------------------------------------------------- Package Private Methods
+
+
+    public HttpTransactionContext copy() {
+        final HttpTransactionContext newContext =
+                new HttpTransactionContext(provider,
+                                           future,
+                                           request,
+                                           handler);
+        newContext.invocationStatus = invocationStatus;
+        newContext.bodyHandler = bodyHandler;
+        newContext.currentState = currentState;
+        newContext.statusHandler = statusHandler;
+        newContext.lastRedirectURI = lastRedirectURI;
+        newContext.redirectCount.set(redirectCount.get());
+        return newContext;
+
+    }
+
+    void done(final Callable c) {
+        if (future != null) {
+            future.done(c);
+        }
+    }
+
+    @SuppressWarnings({"unchecked"})
+    void result(Object result) {
+        if (future != null) {
+            future.delegate.result(result);
+            future.done(null);
+        }
+    }
+
+    public boolean isTunnelEstablished(final Connection c) {
+        return c.getAttributes().getAttribute("tunnel-established") != null;
+    }
+
+
+    public void tunnelEstablished(final Connection c) {
+        c.getAttributes().setAttribute("tunnel-established", Boolean.TRUE);
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
new file mode 100644
index 000000000..7d9744ce1
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.providers.grizzly.filters.ProxyFilter;
+import org.asynchttpclient.providers.grizzly.filters.TunnelFilter;
+import org.glassfish.grizzly.Processor;
+import org.glassfish.grizzly.filterchain.FilterChain;
+import org.glassfish.grizzly.filterchain.FilterChainBuilder;
+import org.glassfish.grizzly.http.HttpClientFilter;
+import org.glassfish.grizzly.nio.transport.TCPNIOConnectorHandler;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
+
+import java.net.URI;
+
+
+final class ProxyAwareConnectorHandler extends TCPNIOConnectorHandler {
+
+    private FilterChainBuilder nonSecureTemplate;
+    private FilterChainBuilder secureTemplate;
+    private AsyncHttpClientConfig clientConfig;
+    private URI uri;
+    private ProxyServer proxyServer;
+
+    // ------------------------------------------------------------ Constructors
+
+
+    private ProxyAwareConnectorHandler(final TCPNIOTransport transport) {
+        super(transport);
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public static Builder builder(final TCPNIOTransport transport) {
+        return new ProxyAwareConnectorHandler.Builder(transport);
+    }
+
+
+    // ------------------------------------------- Methods from ConnectorHandler
+
+
+    @Override
+    public Processor getProcessor() {
+        return ((proxyServer != null)
+                    ? createProxyFilterChain()
+                    : createFilterChain());
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private FilterChain createFilterChain() {
+        return Utils.isSecure(uri)
+                   ? secureTemplate.build()
+                   : nonSecureTemplate.build();
+    }
+
+    private FilterChain createProxyFilterChain() {
+        final FilterChainBuilder builder = FilterChainBuilder.stateless();
+        if (Utils.isSecure(uri)) {
+            builder.addAll(secureTemplate);
+            updateSecureFilterChain(builder);
+        } else {
+            builder.addAll(nonSecureTemplate);
+            updateNonSecureFilterChain(builder);
+        }
+        return builder.build();
+    }
+
+    private void updateSecureFilterChain(final FilterChainBuilder builder) {
+        builder.add(1, new TunnelFilter(proxyServer, uri));
+        final int idx = builder.indexOfType(HttpClientFilter.class);
+        assert (idx != -1);
+        builder.add(idx + 1, new ProxyFilter(proxyServer, clientConfig, true));
+    }
+
+    private void updateNonSecureFilterChain(final FilterChainBuilder builder) {
+        final int idx = builder.indexOfType(HttpClientFilter.class);
+        assert (idx != -1);
+        builder.add(idx + 1, new ProxyFilter(proxyServer, clientConfig, false));
+    }
+
+
+    // ---------------------------------------------------------- Nested Classes
+
+
+    public static final class Builder extends TCPNIOConnectorHandler.Builder {
+
+        final ProxyAwareConnectorHandler connectorHandler;
+
+
+        // -------------------------------------------------------- Constructors
+
+
+        private Builder(final TCPNIOTransport transport) {
+            super(transport);
+            connectorHandler = new ProxyAwareConnectorHandler(transport);
+        }
+
+
+        // ----------------------------------------------------- Builder Methods
+
+
+        public Builder setSecureFilterChainTemplate(final FilterChainBuilder secureTemplate) {
+            connectorHandler.secureTemplate = secureTemplate;
+            return this;
+        }
+
+        public Builder setNonSecureFilterChainTemplate(final FilterChainBuilder nonSecureTemplate) {
+            connectorHandler.nonSecureTemplate = nonSecureTemplate;
+            return this;
+        }
+
+        public Builder setAsyncHttpClientConfig(final AsyncHttpClientConfig clientConfig) {
+            connectorHandler.clientConfig = clientConfig;
+            return this;
+        }
+
+        public Builder setURI(final URI uri) {
+            connectorHandler.uri = uri;
+            return this;
+        }
+
+        public Builder setProxyServer(final ProxyServer proxyServer) {
+            connectorHandler.proxyServer = proxyServer;
+            return this;
+        }
+
+        @Override
+        public ProxyAwareConnectorHandler build() {
+            assert(connectorHandler.secureTemplate != null);
+            assert(connectorHandler.nonSecureTemplate != null);
+            assert(connectorHandler.clientConfig != null);
+            assert(connectorHandler.uri != null);
+            return connectorHandler;
+        }
+
+    } // END Builder
+}
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/TransportCustomizer.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
similarity index 97%
rename from providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/TransportCustomizer.java
rename to providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
index 504fcc42d..8d86c4b39 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/TransportCustomizer.java
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
@@ -11,7 +11,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
 import org.glassfish.grizzly.filterchain.FilterChainBuilder;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
new file mode 100644
index 000000000..31b4dd48f
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.Grizzly;
+import org.glassfish.grizzly.attributes.Attribute;
+import org.glassfish.grizzly.attributes.AttributeStorage;
+
+import java.net.URI;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class Utils {
+
+    private static final Attribute<Boolean> IGNORE =
+            Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IGNORE");
+    private static final Attribute<AtomicInteger> REQUEST_IN_FLIGHT =
+                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IN-FLIGHT");
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    private Utils() {}
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public static boolean isSecure(final String uri) {
+        return (uri.startsWith("https:") || uri.startsWith("wss:"));
+    }
+
+    public static boolean isSecure(final URI uri) {
+        final String scheme = uri.getScheme();
+        return ("https".equals(scheme) || "wss".equals(scheme));
+    }
+
+    public static void connectionIgnored(final Connection c, boolean ignored) {
+        if (ignored) {
+            IGNORE.set(c, true);
+        } else {
+            IGNORE.remove(c);
+        }
+    }
+
+    public static boolean isIgnored(final Connection c) {
+        Boolean result = IGNORE.get(c);
+        return (result != null && result);
+    }
+
+    public static void addRequestInFlight(final AttributeStorage storage) {
+        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
+        if (counter == null) {
+            counter = new AtomicInteger(1);
+            REQUEST_IN_FLIGHT.set(storage, counter);
+        } else {
+            counter.incrementAndGet();
+        }
+    }
+
+    public static void removeRequestInFlight(final AttributeStorage storage) {
+        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
+        if (counter != null) {
+            counter.decrementAndGet();
+        }
+    }
+
+    public static int getRequestInFlightCount(final AttributeStorage storage) {
+        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
+        return ((counter != null) ? counter.get() : 0);
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
new file mode 100644
index 000000000..b8f3437c5
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+import org.glassfish.grizzly.memory.MemoryManager;
+
+import java.io.IOException;
+
+public final class BodyGeneratorBodyHandler implements BodyHandler {
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getBodyGenerator() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        final BodyGenerator generator = request.getBodyGenerator();
+        final Body bodyLocal = generator.createBody();
+        final long len = bodyLocal.getContentLength();
+        if (len > 0) {
+            requestPacket.setContentLengthLong(len);
+        } else {
+            requestPacket.setChunked(true);
+        }
+
+        final MemoryManager mm = ctx.getMemoryManager();
+        boolean last = false;
+
+        while (!last) {
+            Buffer buffer = mm.allocate(MAX_CHUNK_SIZE);
+            buffer.allowBufferDispose(true);
+
+            final long readBytes = bodyLocal.read(buffer.toByteBuffer());
+            if (readBytes > 0) {
+                buffer.position((int) readBytes);
+                buffer.trim();
+            } else {
+                buffer.dispose();
+
+                if (readBytes < 0) {
+                    last = true;
+                    buffer = Buffers.EMPTY_BUFFER;
+                } else {
+                    // pass the context to bodyLocal to be able to
+                    // continue body transferring once more data is available
+                    if (generator instanceof FeedableBodyGenerator) {
+                        ((FeedableBodyGenerator) generator).initializeAsynchronousTransfer(ctx, requestPacket);
+                        return false;
+                    } else {
+                        throw new IllegalStateException("BodyGenerator unexpectedly returned 0 bytes available");
+                    }
+                }
+            }
+
+            final HttpContent content =
+                    requestPacket.httpContentBuilder().content(buffer).
+                            last(last).build();
+            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        }
+
+        return true;
+    }
+
+} // END BodyGeneratorBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
new file mode 100644
index 000000000..e476fdd26
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+
+import java.io.IOException;
+
+public interface BodyHandler {
+
+    static int MAX_CHUNK_SIZE = 8192;
+
+    boolean handlesBodyType(final Request request);
+
+    boolean doHandle(final FilterChainContext ctx,
+                     final Request request,
+                     final HttpRequestPacket requestPacket) throws IOException;
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
new file mode 100644
index 000000000..18ad3839e
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+
+public final class BodyHandlerFactory {
+
+    private final BodyHandler[] handlers;
+
+    public BodyHandlerFactory(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        handlers = new BodyHandler[]{
+                new StringBodyHandler(grizzlyAsyncHttpProvider),
+                new ByteArrayBodyHandler(grizzlyAsyncHttpProvider),
+                new ParamsBodyHandler(grizzlyAsyncHttpProvider),
+                new EntityWriterBodyHandler(),
+                new StreamDataBodyHandler(),
+                new PartsBodyHandler(),
+                new FileBodyHandler(),
+                new BodyGeneratorBodyHandler()
+        };
+    }
+
+    public BodyHandler getBodyHandler(final Request request) {
+        for (final BodyHandler h : handlers) {
+            if (h.handlesBodyType(request)) {
+                return h;
+            }
+        }
+        return new NoBodyHandler();
+    }
+
+} // END BodyHandlerFactory
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
new file mode 100644
index 000000000..9ed538e5f
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+import org.glassfish.grizzly.memory.MemoryManager;
+import org.glassfish.grizzly.utils.Charsets;
+
+import java.io.IOException;
+
+public final class ByteArrayBodyHandler implements BodyHandler {
+
+    private final boolean compressionEnabled;
+
+    public ByteArrayBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled();
+    }
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getByteData() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        String charset = request.getBodyEncoding();
+        if (charset == null) {
+            charset = Charsets.ASCII_CHARSET.name();
+        }
+        final byte[] data = new String(request.getByteData(), charset).getBytes(charset);
+        final MemoryManager mm = ctx.getMemoryManager();
+        final Buffer gBuffer = Buffers.wrap(mm, data);
+        if (requestPacket.getContentLength() == -1) {
+                if (!compressionEnabled) {
+                    requestPacket.setContentLengthLong(data.length);
+                }
+            }
+        final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
+        content.setLast(true);
+        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        return true;
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java
new file mode 100644
index 000000000..7b2aad63a
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/EntityWriterBodyHandler.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.MemoryManager;
+import org.glassfish.grizzly.utils.BufferOutputStream;
+
+import java.io.IOException;
+
+public final class EntityWriterBodyHandler implements BodyHandler {
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getEntityWriter() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        final MemoryManager mm = ctx.getMemoryManager();
+        Buffer b = mm.allocate(512);
+        BufferOutputStream o = new BufferOutputStream(mm, b, true);
+        final Request.EntityWriter writer = request.getEntityWriter();
+        writer.writeEntity(o);
+        b = o.getBuffer();
+        b.trim();
+        if (b.hasRemaining()) {
+            final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
+            content.setLast(true);
+            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        }
+
+        return true;
+    }
+
+} // END EntityWriterBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
new file mode 100644
index 000000000..dff737580
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+
+import java.io.IOException;
+
+public final class ExpectHandler implements BodyHandler {
+
+    private final BodyHandler delegate;
+    private Request request;
+    private HttpRequestPacket requestPacket;
+
+    // -------------------------------------------------------- Constructors
+
+
+    public ExpectHandler(final BodyHandler delegate) {
+
+        this.delegate = delegate;
+
+    }
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(Request request) {
+        return delegate.handlesBodyType(request);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(FilterChainContext ctx, Request request, HttpRequestPacket requestPacket) throws IOException {
+        this.request = request;
+        this.requestPacket = requestPacket;
+        ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        return true;
+    }
+
+    public void finish(final FilterChainContext ctx) throws IOException {
+        delegate.doHandle(ctx, request, requestPacket);
+    }
+
+} // END ContinueHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
new file mode 100644
index 000000000..3085f7c14
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.EmptyCompletionHandler;
+import org.glassfish.grizzly.FileTransfer;
+import org.glassfish.grizzly.WriteResult;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+import org.glassfish.grizzly.memory.MemoryManager;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class FileBodyHandler implements BodyHandler {
+
+    private static final boolean SEND_FILE_SUPPORT;
+    static {
+        SEND_FILE_SUPPORT = configSendFileSupport();
+    }
+
+
+    // ------------------------------------------------ Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getFile() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                            final Request request,
+                            final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        final File f = request.getFile();
+        requestPacket.setContentLengthLong(f.length());
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        if (!SEND_FILE_SUPPORT || requestPacket.isSecure()) {
+            final FileInputStream fis = new FileInputStream(request.getFile());
+            final MemoryManager mm = ctx.getMemoryManager();
+            AtomicInteger written = new AtomicInteger();
+            boolean last = false;
+            try {
+                for (byte[] buf = new byte[MAX_CHUNK_SIZE]; !last; ) {
+                    Buffer b = null;
+                    int read;
+                    if ((read = fis.read(buf)) < 0) {
+                        last = true;
+                        b = Buffers.EMPTY_BUFFER;
+                    }
+                    if (b != Buffers.EMPTY_BUFFER) {
+                        written.addAndGet(read);
+                        b = Buffers.wrap(mm, buf, 0, read);
+                    }
+
+                    final HttpContent content =
+                            requestPacket.httpContentBuilder().content(b).
+                                    last(last).build();
+                    ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+                }
+            } finally {
+                try {
+                    fis.close();
+                } catch (IOException ignored) {
+                }
+            }
+        } else {
+            // write the headers
+            ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+            ctx.write(new FileTransfer(f), new EmptyCompletionHandler<WriteResult>() {
+
+                @Override
+                public void updated(WriteResult result) {
+                    final AsyncHandler handler = context.getHandler();
+                    if (handler != null) {
+                        if (TransferCompletionHandler.class.isAssignableFrom(handler.getClass())) {
+                            // WriteResult keeps a track of the total amount written,
+                            // so we need to calculate the delta ourselves.
+                            final long resultTotal = result.getWrittenSize();
+                            final long written = resultTotal - context.getTotalBodyWritten().get();
+                            final long total = context.getTotalBodyWritten().addAndGet(written);
+                            ((TransferCompletionHandler) handler).onContentWriteProgress(
+                                    written,
+                                    total,
+                                    requestPacket.getContentLength());
+                        }
+                    }
+                }
+            });
+        }
+
+        return true;
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private static boolean configSendFileSupport() {
+        return !((System.getProperty("os.name").equalsIgnoreCase("linux")
+                && !linuxSendFileSupported())
+                || System.getProperty("os.name").equalsIgnoreCase("HP-UX"));
+    }
+
+
+    private static boolean linuxSendFileSupported() {
+        final String version = System.getProperty("java.version");
+        if (version.startsWith("1.6")) {
+            int idx = version.indexOf('_');
+            if (idx == -1) {
+                return false;
+            }
+            final int patchRev = Integer.parseInt(version.substring(idx + 1));
+            return (patchRev >= 18);
+        } else {
+            return version.startsWith("1.7") || version.startsWith("1.8");
+        }
+    }
+
+} // END FileBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
new file mode 100644
index 000000000..55eef5fb5
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+
+import java.io.IOException;
+
+public final class NoBodyHandler implements BodyHandler {
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return false;
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        final HttpContent content = requestPacket.httpContentBuilder().content(
+                Buffers.EMPTY_BUFFER).build();
+        content.setLast(true);
+        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        return true;
+    }
+
+} // END NoBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
new file mode 100644
index 000000000..dc5a9d881
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.FluentStringsMap;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+import org.glassfish.grizzly.memory.MemoryManager;
+import org.glassfish.grizzly.utils.Charsets;
+
+import java.io.IOException;
+import java.net.URLEncoder;
+import java.util.List;
+import java.util.Map;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+public final class ParamsBodyHandler implements BodyHandler {
+
+    private final boolean compressionEnabled;
+
+    public ParamsBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled();
+    }
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        final FluentStringsMap params = request.getParams();
+        return isNonEmpty(params);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        if (requestPacket.getContentType() == null) {
+            requestPacket.setContentType("application/x-www-form-urlencoded");
+        }
+        StringBuilder sb = null;
+        String charset = request.getBodyEncoding();
+        if (charset == null) {
+            charset = Charsets.ASCII_CHARSET.name();
+        }
+        final FluentStringsMap params = request.getParams();
+        if (!params.isEmpty()) {
+            for (Map.Entry<String, List<String>> entry : params.entrySet()) {
+                String name = entry.getKey();
+                List<String> values = entry.getValue();
+                if (isNonEmpty(values)) {
+                    if (sb == null) {
+                        sb = new StringBuilder(128);
+                    }
+                    for (String value : values) {
+                        if (sb.length() > 0) {
+                            sb.append('&');
+                        }
+                        sb.append(URLEncoder.encode(name, charset))
+                                .append('=').append(URLEncoder.encode(value, charset));
+                    }
+                }
+            }
+        }
+        if (sb != null) {
+            final byte[] data = sb.toString().getBytes(charset);
+            final MemoryManager mm = ctx.getMemoryManager();
+            final Buffer gBuffer = Buffers.wrap(mm, data);
+            final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
+            if (requestPacket.getContentLength() == -1) {
+                if (!compressionEnabled) {
+                    requestPacket.setContentLengthLong(data.length);
+                }
+            }
+            content.setLast(true);
+            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        }
+        return true;
+    }
+
+} // END ParamsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
new file mode 100644
index 000000000..ba656d0d6
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.multipart.MultipartRequestEntity;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.MemoryManager;
+import org.glassfish.grizzly.utils.BufferOutputStream;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+public final class PartsBodyHandler implements BodyHandler {
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return isNonEmpty(request.getParts());
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        MultipartRequestEntity mre =
+                AsyncHttpProviderUtils.createMultipartRequestEntity(
+                        request.getParts(),
+                        request.getHeaders());
+        requestPacket.setContentLengthLong(mre.getContentLength());
+        requestPacket.setContentType(mre.getContentType());
+        final MemoryManager mm = ctx.getMemoryManager();
+        Buffer b = mm.allocate(512);
+        BufferOutputStream o = new BufferOutputStream(mm, b, true);
+        mre.writeRequest(o);
+        b = o.getBuffer();
+        b.trim();
+        if (b.hasRemaining()) {
+            final HttpContent content = requestPacket.httpContentBuilder().content(b).build();
+            content.setLast(true);
+            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        }
+
+        return true;
+    }
+
+} // END PartsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
new file mode 100644
index 000000000..a9b5948ea
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.MemoryManager;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.LOGGER;
+
+public final class StreamDataBodyHandler implements BodyHandler {
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getStreamData() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        final MemoryManager mm = ctx.getMemoryManager();
+        Buffer buffer = mm.allocate(512);
+        final byte[] b = new byte[512];
+        int read;
+        final InputStream in = request.getStreamData();
+        try {
+            in.reset();
+        } catch (IOException ioe) {
+            if (LOGGER.isDebugEnabled()) {
+                LOGGER.debug(ioe.toString(), ioe);
+            }
+        }
+        if (in.markSupported()) {
+            in.mark(0);
+        }
+
+        while ((read = in.read(b)) != -1) {
+            if (read > buffer.remaining()) {
+                buffer = mm.reallocate(buffer, buffer.capacity() + 512);
+            }
+            buffer.put(b, 0, read);
+        }
+        buffer.trim();
+        if (buffer.hasRemaining()) {
+            final HttpContent content = requestPacket.httpContentBuilder().content(buffer).build();
+            buffer.allowBufferDispose(false);
+            content.setLast(true);
+            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        }
+
+        return true;
+    }
+
+} // END StreamDataBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
new file mode 100644
index 000000000..ab7e42227
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.bodyhandler;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.memory.Buffers;
+import org.glassfish.grizzly.memory.MemoryManager;
+import org.glassfish.grizzly.utils.Charsets;
+
+import java.io.IOException;
+
+public final class StringBodyHandler implements BodyHandler {
+    private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
+
+    public StringBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
+        this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
+    }
+
+
+    // -------------------------------------------- Methods from BodyHandler
+
+
+    public boolean handlesBodyType(final Request request) {
+        return (request.getStringData() != null);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean doHandle(final FilterChainContext ctx,
+                         final Request request,
+                         final HttpRequestPacket requestPacket)
+    throws IOException {
+
+        String charset = request.getBodyEncoding();
+        if (charset == null) {
+            charset = Charsets.ASCII_CHARSET.name();
+        }
+        final byte[] data = request.getStringData().getBytes(charset);
+        final MemoryManager mm = ctx.getMemoryManager();
+        final Buffer gBuffer = Buffers.wrap(mm, data);
+        if (requestPacket.getContentLength() == -1) {
+            if (!grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnabled()) {
+                requestPacket.setContentLengthLong(data.length);
+            }
+        }
+        final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
+        content.setLast(true);
+        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
+        return true;
+    }
+
+} // END StringBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
new file mode 100644
index 000000000..8b2aa0783
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.providers.grizzly.EventHandler;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpClientFilter;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpHeader;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+
+import java.io.IOException;
+
+/**
+ * Extension of the {@link HttpClientFilter} that is responsible for handling
+ * events triggered by the parsing and serialization of HTTP packets.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class AsyncHttpClientEventFilter extends HttpClientFilter
+        implements GrizzlyAsyncHttpProvider.Cleanup {
+
+
+    private final EventHandler eventHandler;
+
+    // -------------------------------------------------------- Constructors
+
+
+    public AsyncHttpClientEventFilter(final EventHandler eventHandler) {
+        this(eventHandler, DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
+    }
+
+
+    public AsyncHttpClientEventFilter(final EventHandler eventHandler,
+                                      final int maxHeaderSize) {
+
+        super(maxHeaderSize);
+        this.eventHandler = eventHandler;
+    }
+
+
+    @Override
+    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
+        eventHandler.exceptionOccurred(ctx, error);
+    }
+
+    @Override
+    protected void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
+        eventHandler.onHttpContentParsed(content, ctx);
+    }
+
+    @Override
+    protected void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onHttpHeadersEncoded(httpHeader, ctx);
+    }
+
+    @Override
+    protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
+        eventHandler.onHttpContentEncoded(content, ctx);
+    }
+
+    @Override
+    protected void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onInitialLineParsed(httpHeader, ctx);
+    }
+
+    @Override
+    protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
+        eventHandler.onHttpHeaderError(httpHeader, ctx, t);
+    }
+
+    @Override
+    protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onHttpHeadersParsed(httpHeader, ctx);
+    }
+
+    @Override
+    protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        return eventHandler.onHttpPacketParsed(httpHeader, ctx);
+    }
+
+    @Override
+    public void cleanup(final FilterChainContext ctx) {
+        clearResponse(ctx.getConnection());
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
new file mode 100644
index 000000000..d48869b7a
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
@@ -0,0 +1,515 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.FluentStringsMap;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.UpgradeHandler;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.asynchttpclient.providers.grizzly.GrizzlyResponseFuture;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.providers.grizzly.Utils;
+import org.asynchttpclient.providers.grizzly.bodyhandler.ExpectHandler;
+import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
+import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
+import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
+import org.glassfish.grizzly.Buffer;
+import org.glassfish.grizzly.Grizzly;
+import org.glassfish.grizzly.attributes.Attribute;
+import org.glassfish.grizzly.filterchain.BaseFilter;
+import org.glassfish.grizzly.filterchain.FilterChain;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.http.Method;
+import org.glassfish.grizzly.http.ProcessingState;
+import org.glassfish.grizzly.http.Protocol;
+import org.glassfish.grizzly.http.util.CookieSerializerUtils;
+import org.glassfish.grizzly.http.util.Header;
+import org.glassfish.grizzly.http.util.MimeHeaders;
+import org.glassfish.grizzly.impl.SafeFutureImpl;
+import org.glassfish.grizzly.ssl.SSLConnectionContext;
+import org.glassfish.grizzly.ssl.SSLUtils;
+import org.glassfish.grizzly.websockets.Version;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URLEncoder;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import static org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter.getHandshakeError;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+/**
+ * This {@link org.glassfish.grizzly.filterchain.Filter} is typically the last
+ * in the {@FilterChain}.  Its primary responsibility is converting the
+ * async-http-client {@link Request} into a Grizzly {@link HttpRequestPacket}.
+ *
+ * @since 1.7
+ * @author The Grizzly Team
+ */
+public final class AsyncHttpClientFilter extends BaseFilter {
+
+    private ConcurrentLinkedQueue<HttpRequestPacketImpl> requestCache
+                    = new ConcurrentLinkedQueue<HttpRequestPacketImpl>();
+
+    private final AsyncHttpClientConfig config;
+    private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
+
+    private static final Attribute<Boolean> PROXY_AUTH_FAILURE =
+           Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(AsyncHttpClientFilter.class.getName() + "-PROXY-AUTH_FAILURE");
+
+    // -------------------------------------------------------- Constructors
+
+
+    public AsyncHttpClientFilter(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider, final AsyncHttpClientConfig config) {
+        this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
+
+        this.config = config;
+
+    }
+
+
+    // --------------------------------------------- Methods from BaseFilter
+
+
+    @Override
+    public NextAction handleWrite(final FilterChainContext ctx)
+    throws IOException {
+
+        Object message = ctx.getMessage();
+        if (message instanceof Request) {
+            ctx.setMessage(null);
+            if (!sendAsGrizzlyRequest((Request) message, ctx)) {
+                return ctx.getSuspendAction();
+            }
+        } else if (message instanceof Buffer) {
+            return ctx.getInvokeAction();
+        }
+
+        return ctx.getStopAction();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public NextAction handleEvent(final FilterChainContext ctx,
+                                  final FilterChainEvent event)
+    throws IOException {
+
+        final Object type = event.type();
+        if (type == ContinueEvent.class) {
+            final ContinueEvent
+                    continueEvent = (ContinueEvent) event;
+            ((ExpectHandler) continueEvent.getContext().getBodyHandler()).finish(ctx);
+        } else if (type == TunnelRequestEvent.class) {
+            // Disable SSL for the time being...
+            ctx.notifyDownstream(new SSLSwitchingEvent(false, ctx.getConnection()));
+            ctx.suspend();
+            TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
+            final ProxyServer proxyServer = tunnelRequestEvent.getProxyServer();
+            final URI requestUri = tunnelRequestEvent.getUri();
+
+            RequestBuilder builder = new RequestBuilder();
+            builder.setMethod(Method.CONNECT.getMethodString());
+            builder.setUrl("http://" + getAuthority(requestUri));
+            Request request = builder.build();
+
+            AsyncHandler handler = new AsyncCompletionHandler() {
+                            @Override
+                            public Object onCompleted(Response response) throws Exception {
+                                if (response.getStatusCode() != 200) {
+                                    PROXY_AUTH_FAILURE.set(ctx.getConnection(), Boolean.TRUE);
+                                }
+                                ctx.notifyDownstream(new SSLSwitchingEvent(true, ctx.getConnection()));
+                                ctx.notifyDownstream(event);
+                                return response;
+                            }
+                        };
+            final GrizzlyResponseFuture future =
+                    new GrizzlyResponseFuture(grizzlyAsyncHttpProvider,
+                                              request,
+                                              handler,
+                                              proxyServer);
+            future.setDelegate(SafeFutureImpl.create());
+
+            grizzlyAsyncHttpProvider.execute(ctx.getConnection(),
+                                             request,
+                                             handler,
+                                             future);
+            return ctx.getSuspendAction();
+        }
+
+        return ctx.getStopAction();
+
+    }
+
+
+    // ----------------------------------------------------- Private Methods
+
+
+    private boolean sendAsGrizzlyRequest(final Request request,
+                                         final FilterChainContext ctx)
+    throws IOException {
+
+        final HttpTransactionContext httpCtx = HttpTransactionContext.get(ctx.getConnection());
+
+        if (checkProxyAuthFailure(ctx, httpCtx)) {
+            return true;
+        }
+
+        final URI uri = httpCtx.getRequest().getURI();
+        boolean secure = Utils.isSecure(uri);
+
+        // If the request is secure, check to see if an error occurred during
+        // the handshake.  We have to do this here, as the error would occur
+        // out of the scope of a HttpTransactionContext so there would be
+        // no good way to communicate the problem to the caller.
+        if (secure && checkHandshakeError(ctx, httpCtx)) {
+            return true;
+        }
+
+        if (isUpgradeRequest(httpCtx.getHandler()) && isWSRequest(httpCtx.getRequestUrl())) {
+            httpCtx.setWSRequest(true);
+            convertToUpgradeRequest(httpCtx);
+        }
+
+        HttpRequestPacket requestPacket = requestCache.poll();
+        if (requestPacket == null) {
+            requestPacket = new HttpRequestPacketImpl();
+        }
+        requestPacket.setMethod(request.getMethod());
+        requestPacket.setProtocol(Protocol.HTTP_1_1);
+
+        // Special handling for CONNECT.
+        if (Method.CONNECT.matchesMethod(request.getMethod())) {
+            final int port = uri.getPort();
+            requestPacket.setRequestURI(uri.getHost() + ':' + (port == -1 ? 443 : port));
+        } else {
+            requestPacket.setRequestURI(uri.getPath());
+        }
+
+        if (GrizzlyAsyncHttpProvider.requestHasEntityBody(request)) {
+            final long contentLength = request.getContentLength();
+            if (contentLength > 0) {
+                requestPacket.setContentLengthLong(contentLength);
+                requestPacket.setChunked(false);
+            } else {
+                requestPacket.setChunked(true);
+            }
+        }
+
+        if (httpCtx.isWSRequest() && !httpCtx.isEstablishingTunnel()) {
+            try {
+                final URI wsURI = new URI(httpCtx.getWsRequestURI());
+                httpCtx.setProtocolHandler(Version.DRAFT17.createHandler(true));
+                httpCtx.setHandshake(
+                        httpCtx.getProtocolHandler().createHandShake(wsURI));
+                requestPacket = (HttpRequestPacket)
+                        httpCtx.getHandshake().composeHeaders().getHttpHeader();
+            } catch (URISyntaxException e) {
+                throw new IllegalArgumentException("Invalid WS URI: " + httpCtx.getWsRequestURI());
+            }
+        }
+
+        requestPacket.setSecure(secure);
+        addQueryString(request, requestPacket);
+        addHostHeader(request, uri, requestPacket);
+        addGeneralHeaders(request, requestPacket);
+        addCookies(request, requestPacket);
+
+        initTransferCompletionHandler(request, httpCtx.getHandler());
+
+        final HttpRequestPacket requestPacketLocal = requestPacket;
+        FilterChainContext sendingCtx = ctx;
+
+        if (secure) {
+            // Check to see if the ProtocolNegotiator has given
+            // us a different FilterChain to use.  If so, we need
+            // use a different FilterChainContext when invoking sendRequest().
+            sendingCtx = checkAndHandleFilterChainUpdate(ctx, sendingCtx);
+        }
+
+        return grizzlyAsyncHttpProvider.sendRequest(sendingCtx,
+                                                    request,
+                                                    requestPacketLocal);
+
+    }
+
+    private static FilterChainContext checkAndHandleFilterChainUpdate(final FilterChainContext ctx,
+                                                                      final FilterChainContext sendingCtx) {
+        FilterChainContext ctxLocal = sendingCtx;
+        SSLConnectionContext sslCtx =
+                SSLUtils.getSslConnectionContext(ctx.getConnection());
+        if (sslCtx != null) {
+            FilterChain fc = sslCtx.getNewConnectionFilterChain();
+
+            if (fc != null) {
+                // Create a new FilterChain context using the new
+                // FilterChain.
+                // TODO:  We need to mark this connection somehow
+                //        as being only suitable for this type of
+                //        request.
+                ctxLocal = obtainProtocolChainContext(ctx, fc);
+            }
+        }
+        return ctxLocal;
+    }
+
+    private static void initTransferCompletionHandler(final Request request,
+                                                      final AsyncHandler h)
+    throws IOException {
+        if (h != null) {
+            if (TransferCompletionHandler.class.isAssignableFrom(h.getClass())) {
+                final FluentCaseInsensitiveStringsMap map =
+                        new FluentCaseInsensitiveStringsMap(
+                                request.getHeaders());
+                TransferCompletionHandler.class.cast(h)
+                        .transferAdapter(new GrizzlyTransferAdapter(map));
+            }
+        }
+    }
+
+    private static boolean checkHandshakeError(final FilterChainContext ctx,
+                                               final HttpTransactionContext httpCtx) {
+            Throwable t = getHandshakeError(ctx.getConnection());
+            if (t != null) {
+                httpCtx.abort(t);
+                return true;
+            }
+        return false;
+    }
+
+    private static boolean checkProxyAuthFailure(final FilterChainContext ctx,
+                                                 final HttpTransactionContext httpCtx) {
+        final Boolean failed = PROXY_AUTH_FAILURE.get(ctx.getConnection());
+        if (failed != null && failed) {
+            httpCtx.abort(new IllegalStateException("Unable to authenticate with proxy"));
+            return true;
+        }
+        return false;
+    }
+
+    private static FilterChainContext obtainProtocolChainContext(
+            final FilterChainContext ctx,
+            final FilterChain completeProtocolFilterChain) {
+
+        final FilterChainContext newFilterChainContext =
+                completeProtocolFilterChain.obtainFilterChainContext(
+                        ctx.getConnection(),
+                        ctx.getStartIdx() + 1,
+                        completeProtocolFilterChain.size(),
+                        ctx.getFilterIdx() + 1);
+
+        newFilterChainContext.setAddressHolder(ctx.getAddressHolder());
+        newFilterChainContext.setMessage(ctx.getMessage());
+        newFilterChainContext.getInternalContext().setIoEvent(
+                ctx.getInternalContext().getIoEvent());
+        ctx.getConnection().setProcessor(completeProtocolFilterChain);
+        return newFilterChainContext;
+    }
+
+    private static void addHostHeader(final Request request,
+                                      final URI uri,
+                                      final HttpRequestPacket requestPacket) {
+        String host = request.getVirtualHost();
+        if (host != null) {
+            requestPacket.addHeader(Header.Host, host);
+        } else {
+            if (uri.getPort() == -1) {
+                requestPacket.addHeader(Header.Host, uri.getHost());
+            } else {
+                requestPacket.addHeader(Header.Host, uri.getHost() + ':' + uri.getPort());
+            }
+        }
+    }
+
+    private static boolean isUpgradeRequest(final AsyncHandler handler) {
+        return (handler instanceof UpgradeHandler);
+    }
+
+    private static boolean isWSRequest(final String requestUri) {
+        return (requestUri.charAt(0) == 'w' && requestUri.charAt(1) == 's');
+    }
+
+    private static void convertToUpgradeRequest(final HttpTransactionContext ctx) {
+        final int colonIdx = ctx.getRequestUrl().indexOf(':');
+
+        if (colonIdx < 2 || colonIdx > 3) {
+            throw new IllegalArgumentException("Invalid websocket URL: " + ctx.getRequestUrl());
+        }
+
+        final StringBuilder sb = new StringBuilder(ctx.getRequestUrl());
+        sb.replace(0, colonIdx, ((colonIdx == 2) ? "http" : "https"));
+        ctx.setWsRequestURI(ctx.getRequestUrl());
+        ctx.setRequestUrl(sb.toString());
+    }
+
+    private void addGeneralHeaders(final Request request,
+                                   final HttpRequestPacket requestPacket) {
+
+        final FluentCaseInsensitiveStringsMap map = request.getHeaders();
+        if (isNonEmpty(map)) {
+            for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
+                final String headerName = entry.getKey();
+                final List<String> headerValues = entry.getValue();
+                if (isNonEmpty(headerValues)) {
+                    for (final String headerValue : headerValues) {
+                        requestPacket.addHeader(headerName, headerValue);
+                    }
+                }
+            }
+        }
+
+        final MimeHeaders headers = requestPacket.getHeaders();
+        if (!headers.contains(Header.Connection)) {
+            //final boolean canCache = context.provider.clientConfig.getAllowPoolingConnection();
+            requestPacket.addHeader(Header.Connection, /*(canCache ? */"keep-alive" /*: "close")*/);
+        }
+
+        if (!headers.contains(Header.Accept)) {
+            requestPacket.addHeader(Header.Accept, "*/*");
+        }
+
+        if (!headers.contains(Header.UserAgent)) {
+            requestPacket.addHeader(Header.UserAgent, config.getUserAgent());
+        }
+
+    }
+
+
+    private void addCookies(final Request request,
+                                   final HttpRequestPacket requestPacket) {
+
+        final Collection<Cookie> cookies = request.getCookies();
+        if (isNonEmpty(cookies)) {
+            StringBuilder sb = new StringBuilder(128);
+            org.glassfish.grizzly.http.Cookie[] gCookies =
+                    new org.glassfish.grizzly.http.Cookie[cookies.size()];
+            convertCookies(cookies, gCookies);
+            CookieSerializerUtils.serializeClientCookies(sb, false, config.isRfc6265CookieEncoding(), gCookies);
+            requestPacket.addHeader(Header.Cookie, sb.toString());
+        }
+
+    }
+
+
+    private static void convertCookies(final Collection<Cookie> cookies,
+                                       final org.glassfish.grizzly.http.Cookie[] gCookies) {
+        int idx = 0;
+        for (final Cookie cookie : cookies) {
+            final org.glassfish.grizzly.http.Cookie gCookie =
+                    new org.glassfish.grizzly.http.Cookie(cookie.getName(), cookie.getValue());
+            gCookie.setDomain(cookie.getDomain());
+            gCookie.setPath(cookie.getPath());
+            gCookie.setVersion(cookie.getVersion());
+            gCookie.setMaxAge(cookie.getMaxAge());
+            gCookie.setSecure(cookie.isSecure());
+            gCookies[idx] = gCookie;
+            idx++;
+        }
+
+    }
+
+
+    private static void addQueryString(final Request request,
+                                       final HttpRequestPacket requestPacket) {
+
+        final FluentStringsMap map = request.getQueryParams();
+        if (isNonEmpty(map)) {
+            StringBuilder sb = new StringBuilder(128);
+            for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
+                final String name = entry.getKey();
+                final List<String> values = entry.getValue();
+                if (isNonEmpty(values)) {
+                    try {
+                        for (int i = 0, len = values.size(); i < len; i++) {
+                            final String value = values.get(i);
+                            if (isNonEmpty(value)) {
+                                sb.append(URLEncoder.encode(name, "UTF-8")).append('=')
+                                    .append(URLEncoder.encode(values.get(i),
+                                                              "UTF-8")).append('&');
+                            } else {
+                                sb.append(URLEncoder.encode(name, "UTF-8")).append('&');
+                            }
+                        }
+                    } catch (UnsupportedEncodingException ignored) {
+                    }
+                }
+            }
+            sb.setLength(sb.length() - 1);
+            String queryString = sb.toString();
+
+            requestPacket.setQueryString(queryString);
+        }
+
+    }
+
+    public static final class GrizzlyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
+
+
+        // -------------------------------------------------------- Constructors
+
+
+        public GrizzlyTransferAdapter(FluentCaseInsensitiveStringsMap headers) throws IOException {
+            super(headers);
+        }
+
+
+        // ---------------------------------------- Methods from TransferAdapter
+
+
+        @Override
+        public void getBytes(byte[] bytes) {
+            // TODO implement
+        }
+
+    } // END GrizzlyTransferAdapter
+
+
+    class HttpRequestPacketImpl extends HttpRequestPacket {
+
+        private ProcessingState processingState = new ProcessingState();
+
+        // -------------------------------------- Methods from HttpRequestPacketImpl
+
+
+        @Override
+        public ProcessingState getProcessingState() {
+            return processingState;
+        }
+
+        @Override
+        public void recycle() {
+            super.recycle();
+            processingState.recycle();
+            requestCache.add(this);
+        }
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java
new file mode 100644
index 000000000..8de7d9155
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientTransportFilter.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.glassfish.grizzly.CompletionHandler;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.filterchain.TransportFilter;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * Custom {@link TransportFilter} implementation to capture and handle low-level
+ * exceptions.
+ *
+ * @since 1.7
+ * @author The Grizzly Team
+ */
+public final class AsyncHttpClientTransportFilter extends TransportFilter {
+
+
+    // ----------------------------------------------------- Methods from Filter
+
+
+    @Override
+    public NextAction handleRead(FilterChainContext ctx) throws IOException {
+        final HttpTransactionContext context =
+                HttpTransactionContext.get(ctx.getConnection());
+        if (context == null) {
+            return super.handleRead(ctx);
+        }
+        ctx.getTransportContext().setCompletionHandler(new CompletionHandler() {
+            @Override
+            public void cancelled() {
+
+            }
+
+            @Override
+            public void failed(Throwable throwable) {
+                if (throwable instanceof EOFException) {
+                    context.abort(new IOException("Remotely Closed"));
+                }
+            }
+
+            @Override
+            public void completed(Object result) {
+            }
+
+            @Override
+            public void updated(Object result) {
+            }
+        });
+        return super.handleRead(ctx);
+    }
+
+    @Override
+    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
+        final HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        if (context != null) {
+            context.abort(error.getCause());
+        }
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
new file mode 100644
index 000000000..e4741c4bb
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.providers.grizzly.EventHandler;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpContent;
+import org.glassfish.grizzly.http.HttpHeader;
+import org.glassfish.grizzly.spdy.SpdyHandlerFilter;
+import org.glassfish.grizzly.spdy.SpdyMode;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Extension of the {@link SpdyHandlerFilter} that is responsible for handling
+ * events triggered by the parsing and serialization of HTTP packets.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class AsyncSpdyClientEventFilter extends SpdyHandlerFilter
+        implements GrizzlyAsyncHttpProvider.Cleanup {
+
+
+    private final EventHandler eventHandler;
+
+    // -------------------------------------------------------- Constructors
+
+
+    public AsyncSpdyClientEventFilter(final EventHandler eventHandler,
+                                      SpdyMode mode,
+                                      ExecutorService threadPool) {
+        super(mode, threadPool);
+        this.eventHandler = eventHandler;
+    }
+
+    @Override
+    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
+        eventHandler.exceptionOccurred(ctx, error);
+    }
+
+    @Override
+    protected void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
+        eventHandler.onHttpContentParsed(content, ctx);
+    }
+
+    @Override
+    protected void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onHttpHeadersEncoded(httpHeader, ctx);
+    }
+
+    @Override
+    protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
+        eventHandler.onHttpContentEncoded(content, ctx);
+    }
+
+    @Override
+    protected void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onInitialLineParsed(httpHeader, ctx);
+    }
+
+    @Override
+    protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
+        eventHandler.onHttpHeaderError(httpHeader, ctx, t);
+    }
+
+    @Override
+    protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        eventHandler.onHttpHeadersParsed(httpHeader, ctx);
+    }
+
+    @Override
+    protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
+        return eventHandler.onHttpPacketParsed(httpHeader, ctx);
+    }
+
+    @Override
+    public void cleanup(FilterChainContext ctx) {
+
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
new file mode 100644
index 000000000..095d6c64b
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.glassfish.grizzly.http.EncodingFilter;
+import org.glassfish.grizzly.http.HttpHeader;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.util.DataChunk;
+import org.glassfish.grizzly.http.util.Header;
+
+/**
+ * {@link EncodingFilter} to enable gzip encoding.
+ *
+ * @since 1.7
+ * @author The Grizzly Team
+ */
+public final class ClientEncodingFilter implements EncodingFilter {
+
+
+    // --------------------------------------------- Methods from EncodingFilter
+
+
+    public boolean applyEncoding(HttpHeader httpPacket) {
+
+       httpPacket.addHeader(Header.AcceptEncoding, "gzip");
+       return true;
+
+    }
+
+
+    public boolean applyDecoding(HttpHeader httpPacket) {
+
+        final HttpResponsePacket httpResponse = (HttpResponsePacket) httpPacket;
+        final DataChunk bc = httpResponse.getHeaders().getValue(Header.ContentEncoding);
+        return bc != null && bc.indexOf("gzip", 0) != -1;
+
+    }
+
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
new file mode 100644
index 000000000..9f479db7f
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.glassfish.grizzly.filterchain.BaseFilter;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.http.HttpRequestPacket;
+import org.glassfish.grizzly.http.util.Header;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
+import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
+
+/**
+ * This Filter will be placed in the FilterChain when a request is being
+ * proxied.  It's main responsibility is to adjust the incoming request
+ * as appropriate for a proxy to properly handle it.
+ *
+ * @since 2.0.0
+ * @author The Grizzly Team
+ */
+public final class ProxyFilter extends BaseFilter {
+
+    private final ProxyServer proxyServer;
+    private final AsyncHttpClientConfig config;
+    private final Boolean secure;
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public ProxyFilter(final ProxyServer proxyServer,
+                       final AsyncHttpClientConfig config,
+                       boolean secure) {
+        this.proxyServer = proxyServer;
+        this.config = config;
+        this.secure = secure;
+    }
+
+
+    // ----------------------------------------------------- Methods from Filter
+
+
+    @Override
+    public NextAction handleWrite(FilterChainContext ctx)
+    throws IOException {
+        org.glassfish.grizzly.http.HttpContent content = ctx.getMessage();
+        HttpRequestPacket request = (HttpRequestPacket) content.getHttpHeader();
+        HttpTransactionContext context = HttpTransactionContext.get(ctx.getConnection());
+        assert(context != null);
+        Request req = context.getRequest();
+        if (!secure) {
+            request.setRequestURI(req.getURI().toString());
+        }
+        addProxyHeaders(getRealm(req), request);
+        return ctx.getInvokeAction();
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private void addProxyHeaders(final Realm realm,
+                                 final HttpRequestPacket request) {
+        if (!request.getHeaders().contains(Header.ProxyConnection)) {
+            request.setHeader(Header.ProxyConnection, "keep-alive");
+        }
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+            final String authHeaderValue = generateAuthHeader(realm);
+            if (authHeaderValue != null) {
+                request.setHeader(Header.ProxyAuthorization, authHeaderValue);
+            }
+        }
+    }
+
+    private Realm getRealm(final Request request) {
+        Realm realm = request.getRealm();
+        if (realm == null) {
+            realm = config.getRealm();
+        }
+        return realm;
+    }
+
+    private String generateAuthHeader(final Realm realm) {
+        try {
+            switch (realm.getAuthScheme()) {
+                case BASIC:
+                    return computeBasicAuthentication(realm);
+                case DIGEST:
+                    return computeDigestAuthentication(proxyServer);
+                case NTLM:
+                     return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
+                default:
+                    return null;
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
new file mode 100644
index 000000000..a5700b10a
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.EmptyCompletionHandler;
+import org.glassfish.grizzly.Grizzly;
+import org.glassfish.grizzly.IOEvent;
+import org.glassfish.grizzly.attributes.Attribute;
+import org.glassfish.grizzly.filterchain.FilterChain;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+import org.glassfish.grizzly.filterchain.NextAction;
+import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
+import org.glassfish.grizzly.ssl.SSLFilter;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLHandshakeException;
+import java.io.IOException;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+/**
+ * SSL Filter that may be present within the FilterChain and may be
+ * enabled/disabled by sending the appropriate {@link SSLSwitchingEvent}.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class SwitchingSSLFilter extends SSLFilter {
+
+    private static final Attribute<Boolean> CONNECTION_IS_SECURE =
+        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class.getName());
+    private static final Attribute<Throwable> HANDSHAKE_ERROR =
+        Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class.getName() + "-HANDSHAKE-ERROR");
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public SwitchingSSLFilter(final SSLEngineConfigurator clientConfig) {
+
+        super(null, clientConfig);
+        addHandshakeListener(new ProtocolHandshakeListener());
+    }
+
+
+    // -------------------------------------------------- Methods from SSLFilter
+
+
+    @Override
+    protected void notifyHandshakeFailed(Connection connection, Throwable t) {
+        setError(connection, t);
+    }
+
+    @Override
+    public NextAction handleConnect(final FilterChainContext ctx) throws IOException {
+        // Suspend further handleConnect processing.  We do this to ensure that
+        // the SSL handshake has been completed before returning the connection
+        // for use in processing user requests.  Additionally, this allows us
+        // to determine if a connection is SPDY or HTTP as early as possible.
+        ctx.suspend();
+        final Connection c = ctx.getConnection();
+        handshake(ctx.getConnection(),
+                  new EmptyCompletionHandler<SSLEngine>() {
+                      @Override
+                      public void completed(SSLEngine result) {
+                          // Handshake was successful.  Resume the handleConnect
+                          // processing.  We pass in Invoke Action so the filter
+                          // chain will call handleConnect on the next filter.
+                          ctx.resume(ctx.getInvokeAction());
+                      }
+
+                      @Override
+                      public void cancelled() {
+                          // Handshake was cancelled.  Stop the handleConnect
+                          // processing.  The exception will be checked and
+                          // passed to the user later.
+                          setError(c, new SSLHandshakeException(
+                                  "Handshake canceled."));
+                          ctx.resume(ctx.getStopAction());
+                      }
+
+                      @Override
+                      public void failed(Throwable throwable) {
+                          // Handshake failed.  Stop the handleConnect
+                          // processing.  The exception will be checked and
+                          // passed to the user later.
+                          setError(c, throwable);
+                          ctx.resume(ctx.getStopAction());
+                      }
+                  });
+
+        // This typically isn't advised, however, we need to be able to
+        // read the response from the proxy and OP_READ isn't typically
+        // enabled on the connection until all of the handleConnect()
+        // processing is complete.
+        enableRead(c);
+
+        // Tell the FilterChain that we're suspending further handleConnect
+        // processing.
+        return ctx.getSuspendAction();
+    }
+
+    @Override
+    public NextAction handleEvent(final FilterChainContext ctx,
+                                  final FilterChainEvent event) throws IOException {
+
+        if (event.type() == SSLSwitchingEvent.class) {
+            final SSLSwitchingEvent se = (SSLSwitchingEvent) event;
+            setSecureStatus(se.getConnection(), se.isSecure());
+            return ctx.getStopAction();
+        }
+        return ctx.getInvokeAction();
+
+    }
+
+    @Override
+    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
+
+        if (isSecure(ctx.getConnection())) {
+            return super.handleRead(ctx);
+        }
+        return ctx.getInvokeAction();
+
+    }
+
+    @Override
+    public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
+
+        if (isSecure(ctx.getConnection())) {
+            return super.handleWrite(ctx);
+        }
+        return ctx.getInvokeAction();
+
+    }
+
+    @Override
+    public void onFilterChainChanged(final FilterChain filterChain) {
+        // no-op
+    }
+
+
+    public static Throwable getHandshakeError(final Connection c) {
+        return HANDSHAKE_ERROR.remove(c);
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private static boolean isSecure(final Connection c) {
+        Boolean secStatus = CONNECTION_IS_SECURE.get(c);
+        return (secStatus == null ? true : secStatus);
+    }
+
+    private static void setSecureStatus(final Connection c, final boolean secure) {
+        CONNECTION_IS_SECURE.set(c, secure);
+    }
+
+    private static void setError(final Connection c, Throwable t) {
+        HANDSHAKE_ERROR.set(c, t);
+    }
+
+    private static void enableRead(final Connection c) throws IOException {
+        c.enableIOEvent(IOEvent.READ);
+    }
+
+
+    // ---------------------------------------------------------- Nested Classes
+
+
+    private static interface HandshakeCompleteListener {
+            void complete();
+    }
+
+    private static final class ProtocolHandshakeListener implements HandshakeListener {
+
+
+        static final ConcurrentHashMap<Connection,HandshakeCompleteListener> listeners =
+                new ConcurrentHashMap<Connection,HandshakeCompleteListener>();
+
+
+        // --------------------------------------- Method from HandshakeListener
+
+
+        @Override
+        public void onStart(Connection connection) {
+            // no-op
+        }
+
+        @Override
+        public void onComplete(Connection connection) {
+            final HandshakeCompleteListener listener = listeners.get(connection);
+            if (listener != null) {
+                removeListener(connection);
+                listener.complete();
+            }
+        }
+
+
+        // --------------------------------------------- Package Private Methods
+
+
+        public static void addListener(final Connection c,
+                                       final HandshakeCompleteListener listener) {
+            listeners.putIfAbsent(c, listener);
+        }
+
+        static void removeListener(final Connection c) {
+            listeners.remove(c);
+        }
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
new file mode 100644
index 000000000..4e4bd57bb
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters;
+
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.providers.grizzly.Utils;
+import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
+import org.glassfish.grizzly.IOEvent;
+import org.glassfish.grizzly.filterchain.BaseFilter;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+import org.glassfish.grizzly.filterchain.NextAction;
+
+import java.io.IOException;
+import java.net.URI;
+
+/**
+ * This <code>Filter</code> is responsible for HTTP CONNECT
+ * tunnelling when a connection should be secure and required to
+ * go through a proxy.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class TunnelFilter extends BaseFilter {
+
+    private final ProxyServer proxyServer;
+    private final URI uri;
+
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public TunnelFilter(final ProxyServer proxyServer, final URI uri) {
+        this.proxyServer = proxyServer;
+        this.uri = uri;
+    }
+
+
+    // ----------------------------------------------------- Methods from Filter
+
+
+    @Override
+    public NextAction handleConnect(FilterChainContext ctx)
+    throws IOException {
+        // We suspend the FilterChainContext here to prevent
+        // notification of other filters of the connection event.
+        // This allows us to control when the connection is returned
+        // to the user - we ensure that the tunnel is properly established
+        // before the user request is sent.
+        ctx.suspend();
+
+        // This connection is special and shouldn't be tracked.
+        Utils.connectionIgnored(ctx.getConnection(), true);
+
+        // This event will be handled by the AsyncHttpClientFilter.
+        // It will send the CONNECT request and process the response.
+        // When tunnel is complete, the AsyncHttpClientFilter will
+        // send this event back to this filter in order to notify
+        // it that the request processing is complete.
+        final TunnelRequestEvent tunnelRequestEvent =
+                new TunnelRequestEvent(ctx, proxyServer, uri);
+        ctx.notifyUpstream(tunnelRequestEvent);
+
+        // This typically isn't advised, however, we need to be able to
+        // read the response from the proxy and OP_READ isn't typically
+        // enabled on the connection until all of the handleConnect()
+        // processing is complete.
+        ctx.getConnection().enableIOEvent(IOEvent.READ);
+
+        // Tell the FilterChain that we're suspending further handleConnect
+        // processing.
+        return ctx.getSuspendAction();
+    }
+
+    @Override
+    public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event)
+    throws IOException {
+        if (event.type() == TunnelRequestEvent.class) {
+            TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
+
+            // Clear ignore status.  Any further use of the connection will
+            // be bound by normal AHC connection processing.
+            Utils.connectionIgnored(ctx.getConnection(), false);
+
+            // Obtain the context that was previously suspended and resume.
+            // We pass in Invoke Action so the filter chain will call
+            // handleConnect on the next filter.
+            FilterChainContext suspendedContext =
+                    tunnelRequestEvent.getSuspendedContext();
+            suspendedContext.resume(ctx.getInvokeAction());
+
+            // Stop further event processing.
+            ctx.getStopAction();
+        }
+        return ctx.getInvokeAction();
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
new file mode 100644
index 000000000..247bed46f
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters.events;
+
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+
+/**
+ * {@link FilterChainEvent} to trigger HTTP 100-Continue processing.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class ContinueEvent implements FilterChainEvent {
+
+    private final HttpTransactionContext context;
+
+
+    // -------------------------------------------------------- Constructors
+
+
+    public ContinueEvent(final HttpTransactionContext context) {
+
+        this.context = context;
+
+    }
+
+
+    // --------------------------------------- Methods from FilterChainEvent
+
+
+    @Override
+    public Object type() {
+        return ContinueEvent.class;
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public HttpTransactionContext getContext() {
+        return context;
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
new file mode 100644
index 000000000..84ae75f26
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.filters.events;
+
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+
+import java.util.concurrent.Callable;
+
+/**
+ * {@link FilterChainEvent} to dynamically enable/disable the SSLFilter on
+ * a per-connection basis.
+ *
+ * @since 2.0
+ * @author The Grizzly Team
+ */
+public final class SSLSwitchingEvent implements FilterChainEvent {
+
+    private final boolean secure;
+    private final Connection connection;
+
+    // ------------------------------------------------------------ Constructors
+
+
+    public SSLSwitchingEvent(final boolean secure, final Connection c) {
+
+        this.secure = secure;
+        connection = c;
+
+    }
+
+    // ------------------------------------------- Methods from FilterChainEvent
+
+
+    @Override
+    public Object type() {
+        return SSLSwitchingEvent.class;
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public boolean isSecure() {
+        return secure;
+    }
+
+    public Connection getConnection() {
+        return connection;
+    }
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
new file mode 100644
index 000000000..fc0285c96
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.grizzly.filters.events;
+
+import org.asynchttpclient.ProxyServer;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.filterchain.FilterChainEvent;
+
+import java.net.URI;
+
+/**
+ * {@link FilterChainEvent} to initiate CONNECT tunnelling with a proxy server.
+ *
+ * @since 2.0
+ * @author The Grizzly Team.
+ */
+public final class TunnelRequestEvent implements FilterChainEvent {
+
+
+    private final FilterChainContext suspendedContext;
+    private final ProxyServer proxyServer;
+    private final URI uri;
+
+
+    // ------------------------------------------------------------ Constructors
+
+    public TunnelRequestEvent(final FilterChainContext suspendedContext,
+                              final ProxyServer proxyServer,
+                              final URI uri) {
+        this.suspendedContext = suspendedContext;
+        this.proxyServer = proxyServer;
+        this.uri = uri;
+    }
+
+
+    // ------------------------------------------- Methods from FilterChainEvent
+
+
+    @Override
+    public Object type() {
+        return TunnelRequestEvent.class;
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public FilterChainContext getSuspendedContext() {
+        return suspendedContext;
+    }
+
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
+    public URI getUri() {
+        return uri;
+    }
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
new file mode 100644
index 000000000..0660e27d1
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.statushandler;
+
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.ConnectionManager;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.util.Header;
+import org.glassfish.grizzly.http.util.HttpStatus;
+
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.STOP;
+
+public final class AuthorizationHandler implements StatusHandler {
+
+    public static final AuthorizationHandler INSTANCE =
+            new AuthorizationHandler();
+
+    // ---------------------------------------------- Methods from StatusHandler
+
+
+    public boolean handlesStatus(int statusCode) {
+        return (HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean handleStatus(final HttpResponsePacket responsePacket,
+                                final HttpTransactionContext httpTransactionContext,
+                                final FilterChainContext ctx) {
+
+        final String auth = responsePacket.getHeader(Header.WWWAuthenticate);
+        if (auth == null) {
+            throw new IllegalStateException("401 response received, but no WWW-Authenticate header was present");
+        }
+
+        Realm realm = httpTransactionContext.getRequest().getRealm();
+        if (realm == null) {
+            realm = httpTransactionContext.getProvider().getClientConfig().getRealm();
+        }
+        if (realm == null) {
+            httpTransactionContext.setInvocationStatus(STOP);
+            return true;
+        }
+
+        responsePacket.setSkipRemainder(true); // ignore the remainder of the response
+
+        final Request req = httpTransactionContext.getRequest();
+        realm = new Realm.RealmBuilder().clone(realm)
+                        .setScheme(realm.getAuthScheme())
+                        .setUri(req.getURI().getPath())
+                        .setMethodName(req.getMethod())
+                        .setUsePreemptiveAuth(true)
+                        .parseWWWAuthenticateHeader(auth)
+                        .build();
+        if (auth.toLowerCase().startsWith("basic")) {
+            req.getHeaders().remove(Header.Authorization.toString());
+            try {
+                req.getHeaders().add(Header.Authorization.toString(),
+                                     AuthenticatorUtils.computeBasicAuthentication(
+                                             realm));
+            } catch (UnsupportedEncodingException ignored) {
+            }
+        } else if (auth.toLowerCase().startsWith("digest")) {
+            req.getHeaders().remove(Header.Authorization.toString());
+            try {
+                req.getHeaders().add(Header.Authorization.toString(),
+                                     AuthenticatorUtils.computeDigestAuthentication(realm));
+            } catch (NoSuchAlgorithmException e) {
+                throw new IllegalStateException("Digest authentication not supported", e);
+            } catch (UnsupportedEncodingException e) {
+                throw new IllegalStateException("Unsupported encoding.", e);
+            }
+        } else {
+            throw new IllegalStateException("Unsupported authorization method: " + auth);
+        }
+
+
+        try {
+            final Connection c = getConnectionForNextRequest(ctx,
+                                                             req,
+                                                             responsePacket,
+                                                             httpTransactionContext);
+            final HttpTransactionContext newContext =
+                    httpTransactionContext.copy();
+            httpTransactionContext.setFuture(null);
+            HttpTransactionContext.set(c, newContext);
+            newContext.setInvocationStatus(STOP);
+            httpTransactionContext.getProvider().execute(c,
+                                                         req,
+                                                         httpTransactionContext.getHandler(),
+                                                         httpTransactionContext.getFuture());
+            return false;
+        } catch (Exception e) {
+            httpTransactionContext.abort(e);
+        }
+        httpTransactionContext.setInvocationStatus(STOP);
+        return false;
+    }
+
+
+    // --------------------------------------------------------- Private Methods
+
+
+    private Connection getConnectionForNextRequest(final FilterChainContext ctx,
+                                                   final Request request,
+                                                   final HttpResponsePacket response,
+                                                   final HttpTransactionContext httpCtx)
+    throws Exception {
+        if (response.getProcessingState().isKeepAlive()) {
+            return ctx.getConnection();
+        } else {
+            final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
+            return m.obtainConnection(request, httpCtx.getFuture());
+        }
+    }
+
+} // END AuthorizationHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
new file mode 100644
index 000000000..f2a156592
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.statushandler;
+
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.ConnectionManager;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.Base64;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.util.Header;
+import org.glassfish.grizzly.http.util.HttpStatus;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+import org.slf4j.LoggerFactory;
+
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+
+public final class ProxyAuthorizationHandler implements StatusHandler {
+
+    public static final ProxyAuthorizationHandler INSTANCE =
+            new ProxyAuthorizationHandler();
+
+
+    // ---------------------------------------------- Methods from StatusHandler
+
+
+    public boolean handlesStatus(int statusCode) {
+        return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407
+                .statusMatches(statusCode));
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean handleStatus(final HttpResponsePacket responsePacket,
+                                final HttpTransactionContext httpTransactionContext,
+                                final FilterChainContext ctx) {
+
+        final String proxyAuth =
+                responsePacket.getHeader(Header.ProxyAuthenticate);
+        if (proxyAuth == null) {
+            throw new IllegalStateException(
+                    "407 response received, but no Proxy Authenticate header was present");
+        }
+
+        final Request req = httpTransactionContext.getRequest();
+        ProxyServer proxyServer = httpTransactionContext.getProvider()
+                .getClientConfig()
+                .getProxyServer();
+        String principal = proxyServer.getPrincipal();
+        String password = proxyServer.getPassword();
+        Realm realm = new Realm.RealmBuilder().setPrincipal(principal)
+                .setPassword(password)
+                .setUri("/")
+                .setMethodName("CONNECT")
+                .setUsePreemptiveAuth(true)
+                .parseProxyAuthenticateHeader(proxyAuth)
+                .build();
+        if (proxyAuth.toLowerCase().startsWith("basic")) {
+            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
+            req.getHeaders().remove(Header.ProxyAuthorization.toString());
+            try {
+                req.getHeaders().add(Header.ProxyAuthorization.toString(),
+                                     AuthenticatorUtils.computeBasicAuthentication(
+                                             realm));
+            } catch (UnsupportedEncodingException ignored) {
+            }
+        } else if (proxyAuth.toLowerCase().startsWith("digest")) {
+            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
+            req.getHeaders().remove(Header.ProxyAuthorization.toString());
+            try {
+                req.getHeaders().add(Header.ProxyAuthorization.toString(),
+                                     AuthenticatorUtils.computeDigestAuthentication(
+                                             realm));
+            } catch (NoSuchAlgorithmException e) {
+                throw new IllegalStateException(
+                        "Digest authentication not supported", e);
+            } catch (UnsupportedEncodingException e) {
+                throw new IllegalStateException("Unsupported encoding.", e);
+            }
+        } else if (proxyAuth.toLowerCase().startsWith("ntlm")) {
+
+            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
+            req.getHeaders().remove(Header.ProxyAuthorization.toString());
+
+            String msg;
+            try {
+                if (isNTLMFirstHandShake(proxyAuth)) {
+                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE
+                            .generateType1Msg(proxyServer.getNtlmDomain(), "");
+                } else {
+                    String serverChallenge =
+                            proxyAuth.trim().substring("NTLM ".length());
+                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE
+                            .generateType3Msg(principal, password,
+                                              proxyServer.getNtlmDomain(),
+                                              proxyServer.getHost(),
+                                              serverChallenge);
+                }
+
+                req.getHeaders()
+                        .add(Header.ProxyAuthorization.toString(),
+                             "NTLM " + msg);
+            } catch (Exception e1) {
+                e1.printStackTrace();
+            }
+        } else if (proxyAuth.toLowerCase().startsWith("negotiate")) {
+            //this is for kerberos
+            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
+            req.getHeaders().remove(Header.ProxyAuthorization.toString());
+        } else {
+            throw new IllegalStateException(
+                    "Unsupported authorization method: " + proxyAuth);
+        }
+
+        InvocationStatus tempInvocationStatus = InvocationStatus.STOP;
+
+        try {
+            if (isNTLMFirstHandShake(proxyAuth)) {
+                tempInvocationStatus = InvocationStatus.CONTINUE;
+            }
+            if (proxyAuth.toLowerCase().startsWith("negotiate")) {
+                final Connection c = getConnectionForNextRequest(ctx,
+                                                                 req,
+                                                                 responsePacket,
+                                                                 httpTransactionContext);
+                final HttpTransactionContext newContext =
+                        httpTransactionContext.copy();
+                httpTransactionContext.setFuture(null);
+                HttpTransactionContext.set(c, newContext);
+
+                newContext.setInvocationStatus(tempInvocationStatus);
+
+                String challengeHeader;
+                String server = proxyServer.getHost();
+
+                challengeHeader = GSSSPNEGOWrapper.generateToken(server);
+
+                req.getHeaders()
+                        .add(Header.ProxyAuthorization.toString(),
+                             "Negotiate " + challengeHeader);
+
+
+                return executeRequest(httpTransactionContext, req, c);
+            } else if (isNTLMSecondHandShake(proxyAuth)) {
+                final Connection c = ctx.getConnection();
+                final HttpTransactionContext newContext =
+                        httpTransactionContext.copy();
+
+                httpTransactionContext.setFuture(null);
+                HttpTransactionContext.set(c, newContext);
+
+                newContext.setInvocationStatus(tempInvocationStatus);
+                httpTransactionContext.setEstablishingTunnel(true);
+
+                return executeRequest(httpTransactionContext, req, c);
+
+            } else {
+                final Connection c = getConnectionForNextRequest(ctx,
+                                                                 req,
+                                                                 responsePacket,
+                                                                 httpTransactionContext);
+                final HttpTransactionContext newContext =
+                        httpTransactionContext.copy();
+                httpTransactionContext.setFuture(null);
+                HttpTransactionContext.set(c, newContext);
+
+                newContext.setInvocationStatus(tempInvocationStatus);
+
+                //NTLM needs the same connection to be used for exchange of tokens
+                return executeRequest(httpTransactionContext, req, c);
+            }
+        } catch (Exception e) {
+            httpTransactionContext.abort(e);
+        }
+        httpTransactionContext.setInvocationStatus(tempInvocationStatus);
+        return false;
+    }
+
+    private boolean executeRequest(
+            final HttpTransactionContext httpTransactionContext,
+            final Request req, final Connection c) {
+        httpTransactionContext.getProvider().execute(c,
+                                                         req,
+                                                         httpTransactionContext.getHandler(),
+                                                         httpTransactionContext.getFuture());
+            return false;
+    }
+
+    public static boolean isNTLMSecondHandShake(final String proxyAuth) {
+        return (proxyAuth != null && proxyAuth.toLowerCase()
+                .startsWith("ntlm") && !proxyAuth.equalsIgnoreCase("ntlm"));
+    }
+
+    private static boolean isNTLMFirstHandShake(final String proxy_auth) {
+        return (proxy_auth.equalsIgnoreCase("ntlm"));
+    }
+
+    private Connection getConnectionForNextRequest(final FilterChainContext ctx,
+                                                   final Request request,
+                                                   final HttpResponsePacket response,
+                                                   final HttpTransactionContext httpCtx)
+    throws Exception {
+        if (response.getProcessingState().isKeepAlive()) {
+            return ctx.getConnection();
+        } else {
+            final ConnectionManager m =
+                    httpCtx.getProvider().getConnectionManager();
+            return m.obtainConnection(request, httpCtx.getFuture());
+        }
+    }
+
+
+    private static final class GSSSPNEGOWrapper {
+        private final static org.slf4j.Logger LOGGER = LoggerFactory.getLogger(
+                GSSSPNEGOWrapper.class);
+        private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+
+        static GSSManager getManager() {
+            return GSSManager.getInstance();
+        }
+
+        static byte[] generateGSSToken(
+                final byte[] input, final Oid oid, final String authServer)
+        throws GSSException {
+            byte[] token = input;
+            if (token == null) {
+                token = new byte[0];
+            }
+            GSSManager manager = getManager();
+            GSSName serverName = manager.createName("HTTP@" + authServer,
+                                                    GSSName.NT_HOSTBASED_SERVICE);
+            GSSContext gssContext = manager.createContext(
+                    serverName.canonicalize(oid), oid, null,
+                    GSSContext.DEFAULT_LIFETIME);
+            gssContext.requestMutualAuth(true);
+            gssContext.requestCredDeleg(true);
+            return gssContext.initSecContext(token, 0, token.length);
+        }
+
+        public static String generateToken(String authServer) {
+            String returnVal = "";
+            Oid oid;
+            try {
+                oid = new Oid(KERBEROS_OID);
+                byte[] token = GSSSPNEGOWrapper.generateGSSToken(null, oid,
+                                                                 authServer);
+                returnVal = Base64.encode(token);
+            } catch (GSSException e) {
+                LOGGER.warn(e.toString(), e);
+            }
+
+            return returnVal;
+        }
+    }
+} // END AuthorizationHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
new file mode 100644
index 000000000..b9e2d6519
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.statushandler;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.providers.grizzly.ConnectionManager;
+import org.asynchttpclient.providers.grizzly.EventHandler;
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.glassfish.grizzly.Connection;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+import org.glassfish.grizzly.http.util.Header;
+
+import java.net.URI;
+
+import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
+
+public final class RedirectHandler implements StatusHandler {
+
+    public static final RedirectHandler INSTANCE = new RedirectHandler();
+
+
+    // ------------------------------------------ Methods from StatusHandler
+
+
+    public boolean handlesStatus(int statusCode) {
+        return (EventHandler.isRedirect(statusCode));
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public boolean handleStatus(final HttpResponsePacket responsePacket,
+                                final HttpTransactionContext httpTransactionContext,
+                                final FilterChainContext ctx) {
+
+        final String redirectURL = responsePacket.getHeader(Header.Location);
+        if (redirectURL == null) {
+            throw new IllegalStateException("redirect received, but no location header was present");
+        }
+
+        URI orig;
+        if (httpTransactionContext.getLastRedirectURI() == null) {
+            orig = httpTransactionContext.getRequest().getURI();
+        } else {
+            orig = AsyncHttpProviderUtils.getRedirectUri(
+                    httpTransactionContext.getRequest().getURI(),
+                    httpTransactionContext.getLastRedirectURI());
+        }
+        httpTransactionContext.setLastRedirectURI(redirectURL);
+        Request requestToSend;
+        URI uri = AsyncHttpProviderUtils.getRedirectUri(orig, redirectURL);
+        if (!uri.toString().equalsIgnoreCase(orig.toString())) {
+            requestToSend = EventHandler
+                    .newRequest(uri,
+                                responsePacket,
+                                httpTransactionContext,
+                                sendAsGet(
+                                        responsePacket,
+                                        httpTransactionContext));
+        } else {
+            httpTransactionContext.setStatusHandler(null);
+            httpTransactionContext.setInvocationStatus(CONTINUE);
+                try {
+                    httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
+                } catch (Exception e) {
+                    httpTransactionContext.abort(e);
+                }
+            return true;
+        }
+
+        final ConnectionManager m = httpTransactionContext.getProvider().getConnectionManager();
+        try {
+            final Connection c = m.obtainConnection(requestToSend,
+                                                    httpTransactionContext.getFuture());
+            final HttpTransactionContext newContext =
+                    httpTransactionContext.copy();
+            httpTransactionContext.setFuture(null);
+            newContext.setInvocationStatus(CONTINUE);
+            newContext.setRequest(requestToSend);
+            newContext.setRequestUrl(requestToSend.getUrl());
+            HttpTransactionContext.set(c, newContext);
+            httpTransactionContext.getProvider().execute(c,
+                                                         requestToSend,
+                                                         newContext.getHandler(),
+                                                         newContext.getFuture());
+            return false;
+        } catch (Exception e) {
+            httpTransactionContext.abort(e);
+        }
+
+        httpTransactionContext.setInvocationStatus(CONTINUE);
+        return true;
+
+    }
+
+
+    // ------------------------------------------------- Private Methods
+
+    private boolean sendAsGet(final HttpResponsePacket response,
+                              final HttpTransactionContext ctx) {
+        final int statusCode = response.getStatus();
+        return !(statusCode < 302 || statusCode > 303)
+                  && !(statusCode == 302
+                     && ctx.getProvider().getClientConfig().isStrict302Handling());
+    }
+
+} // END RedirectHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
new file mode 100644
index 000000000..5ec587a42
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.statushandler;
+
+import org.asynchttpclient.providers.grizzly.HttpTransactionContext;
+import org.glassfish.grizzly.filterchain.FilterChainContext;
+import org.glassfish.grizzly.http.HttpResponsePacket;
+
+public interface StatusHandler {
+
+    public enum InvocationStatus {
+        CONTINUE,
+        STOP
+    }
+
+    boolean handleStatus(final HttpResponsePacket httpResponse,
+                         final HttpTransactionContext httpTransactionContext,
+                         final FilterChainContext ctx);
+
+    boolean handlesStatus(final int statusCode);
+
+}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
new file mode 100644
index 000000000..1f245645a
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.websocket;
+
+import org.asynchttpclient.websocket.WebSocketByteListener;
+import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketPingListener;
+import org.asynchttpclient.websocket.WebSocketPongListener;
+import org.asynchttpclient.websocket.WebSocketTextListener;
+import org.glassfish.grizzly.websockets.DataFrame;
+import org.glassfish.grizzly.websockets.draft06.ClosingFrame;
+
+import java.io.ByteArrayOutputStream;
+
+final class AHCWebSocketListenerAdapter implements org.glassfish.grizzly.websockets.WebSocketListener {
+
+    private final WebSocketListener ahcListener;
+    private final GrizzlyWebSocketAdapter webSocket;
+    private final StringBuilder stringBuffer;
+    private final ByteArrayOutputStream byteArrayOutputStream;
+
+    // -------------------------------------------------------- Constructors
+
+
+    public AHCWebSocketListenerAdapter(final WebSocketListener ahcListener,
+                                       final GrizzlyWebSocketAdapter webSocket) {
+        this.ahcListener = ahcListener;
+        this.webSocket = webSocket;
+        if (webSocket.bufferFragments) {
+            stringBuffer = new StringBuilder();
+            byteArrayOutputStream = new ByteArrayOutputStream();
+        } else {
+            stringBuffer = null;
+            byteArrayOutputStream = null;
+        }
+    }
+
+
+    // ------------------------------ Methods from Grizzly WebSocketListener
+
+
+    @Override
+    public void onClose(org.glassfish.grizzly.websockets.WebSocket gWebSocket, DataFrame dataFrame) {
+        try {
+            if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(ahcListener.getClass())) {
+                ClosingFrame cf = ClosingFrame.class.cast(dataFrame);
+                WebSocketCloseCodeReasonListener.class.cast(ahcListener).onClose(webSocket, cf.getCode(), cf.getReason());
+            } else {
+                ahcListener.onClose(webSocket);
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onConnect(org.glassfish.grizzly.websockets.WebSocket gWebSocket) {
+        try {
+            ahcListener.onOpen(webSocket);
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, String s) {
+        try {
+            if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
+                WebSocketTextListener.class.cast(ahcListener).onMessage(s);
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
+        try {
+            if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
+                WebSocketByteListener.class.cast(ahcListener).onMessage(bytes);
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onPing(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
+        try {
+            if (WebSocketPingListener.class.isAssignableFrom(ahcListener.getClass())) {
+                WebSocketPingListener.class.cast(ahcListener).onPing(bytes);
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onPong(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
+        try {
+            if (WebSocketPongListener.class.isAssignableFrom(ahcListener.getClass())) {
+                WebSocketPongListener.class.cast(ahcListener).onPong(bytes);
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, String s, boolean last) {
+        try {
+            if (this.webSocket.bufferFragments) {
+                synchronized (this.webSocket) {
+                    stringBuffer.append(s);
+                    if (last) {
+                        if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
+                            final String message = stringBuffer.toString();
+                            stringBuffer.setLength(0);
+                            WebSocketTextListener.class.cast(ahcListener).onMessage(message);
+                        }
+                    }
+                }
+            } else {
+                if (WebSocketTextListener.class.isAssignableFrom(ahcListener.getClass())) {
+                    WebSocketTextListener.class.cast(ahcListener).onFragment(s, last);
+                }
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes, boolean last) {
+        try {
+            if (this.webSocket.bufferFragments) {
+                synchronized (this.webSocket) {
+                    byteArrayOutputStream.write(bytes);
+                    if (last) {
+                        if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
+                            final byte[] bytesLocal = byteArrayOutputStream.toByteArray();
+                            byteArrayOutputStream.reset();
+                            WebSocketByteListener.class.cast(ahcListener).onMessage(bytesLocal);
+                        }
+                    }
+                }
+            } else {
+                if (WebSocketByteListener.class.isAssignableFrom(ahcListener.getClass())) {
+                    WebSocketByteListener.class.cast(ahcListener).onFragment(bytes, last);
+                }
+            }
+        } catch (Throwable e) {
+            ahcListener.onError(e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        AHCWebSocketListenerAdapter that = (AHCWebSocketListenerAdapter) o;
+
+        if (ahcListener != null ? !ahcListener.equals(that.ahcListener) : that.ahcListener != null)
+            return false;
+        //noinspection RedundantIfStatement
+        if (webSocket != null ? !webSocket.equals(that.webSocket) : that.webSocket != null)
+            return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = ahcListener != null ? ahcListener.hashCode() : 0;
+        result = 31 * result + (webSocket != null ? webSocket.hashCode() : 0);
+        return result;
+    }
+} // END AHCWebSocketListenerAdapter
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
new file mode 100644
index 000000000..aea9a4ee9
--- /dev/null
+++ b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly.websocket;
+
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.glassfish.grizzly.websockets.SimpleWebSocket;
+
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+
+public final class GrizzlyWebSocketAdapter implements WebSocket {
+
+    private final SimpleWebSocket gWebSocket;
+    final boolean bufferFragments;
+
+    // -------------------------------------------------------- Constructors
+
+
+    public GrizzlyWebSocketAdapter(final SimpleWebSocket gWebSocket,
+                                   final boolean bufferFragments) {
+        this.gWebSocket = gWebSocket;
+        this.bufferFragments = bufferFragments;
+    }
+
+
+    // ---------------------------------------------- Methods from AHC WebSocket
+
+
+    @Override
+    public WebSocket sendMessage(byte[] message) {
+        gWebSocket.send(message);
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, boolean last) {
+        if (isNonEmpty(fragment)) {
+            gWebSocket.stream(last, fragment, 0, fragment.length);
+        }
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
+        if (isNonEmpty(fragment)) {
+            gWebSocket.stream(last, fragment, offset, len);
+        }
+        return this;
+    }
+
+    @Override
+    public WebSocket sendTextMessage(String message) {
+        gWebSocket.send(message);
+        return this;
+    }
+
+    @Override
+    public WebSocket streamText(String fragment, boolean last) {
+        gWebSocket.stream(last, fragment);
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPing(byte[] payload) {
+        gWebSocket.sendPing(payload);
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPong(byte[] payload) {
+        gWebSocket.sendPong(payload);
+        return this;
+    }
+
+    @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        gWebSocket.add(new AHCWebSocketListenerAdapter(l, this));
+        return this;
+    }
+
+    @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        gWebSocket.remove(new AHCWebSocketListenerAdapter(l, this));
+        return this;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return gWebSocket.isConnected();
+    }
+
+    @Override
+    public void close() {
+        gWebSocket.close();
+    }
+
+
+    // ---------------------------------------------------------- Public Methods
+
+
+    public SimpleWebSocket getGrizzlyWebSocket() {
+        return gWebSocket;
+    }
+
+} // END GrizzlyWebSocketAdapter
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionPoolTest.java b/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionPoolTest.java
deleted file mode 100644
index 4c34cb8bb..000000000
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionPoolTest.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package com.ning.http.client.providers.grizzly;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Response;
-import com.ning.http.client.async.ConnectionPoolTest;
-import org.glassfish.grizzly.Connection;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.testng.Assert.*;
-
-public class GrizzlyConnectionPoolTest extends ConnectionPoolTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
-    }
-
-    @Override
-    @Test
-    public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 20; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-
-                if (i < 5) {
-                    client.prepareGet(url).execute().get();
-                } else {
-                    client.prepareGet(url).execute();
-                }
-            } catch (Exception ex) {
-                exception = ex;
-                break;
-            }
-        }
-        assertNotNull(exception);
-        assertNotNull(exception.getMessage());
-
-    }
-
-    @Override
-    public void testValidConnectionsPool() {
-        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
-
-            public boolean offer(String key, Connection connection) {
-                return true;
-            }
-
-            public Connection poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Connection connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return true;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
-        try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
-        }
-        assertNull(exception);
-        client.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testInvalidConnectionsPool() {
-
-        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
-
-            public boolean offer(String key, Connection connection) {
-                return false;
-            }
-
-            public Connection poll(String connection) {
-                return null;
-            }
-
-            public boolean removeAll(Connection connection) {
-                return false;
-            }
-
-            public boolean canCacheConnection() {
-                return false;
-            }
-
-            public void destroy() {
-
-            }
-        };
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
-        try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
-        }
-        assertNotNull(exception);
-        client.close();
-    }
-
-    @Override
-    @Test
-    public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-
-        // twice
-        Exception exception = null;
-        try {
-            c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            fail("Should throw exception. Too many connections issued.");
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
-        }
-        assertNotNull(exception);
-        c.close();
-    }
-
-
-    @Override
-    @Test
-    public void win7DisconnectTest() throws Throwable {
-        final AtomicInteger count = new AtomicInteger(0);
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-
-                        count.incrementAndGet();
-                        StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-                        IOException t = new IOException();
-                        t.setStackTrace(new StackTraceElement[]{e});
-                        throw t;
-                    }
-                };
-
-        try {
-            client.prepareGet(getTargetUrl()).execute(handler).get();
-            fail("Must have received an exception");
-        } catch (ExecutionException ex) {
-            assertNotNull(ex);
-            assertNotNull(ex.getCause());
-            assertEquals(ex.getCause().getClass(), IOException.class);
-            assertEquals(count.get(), 1);
-        }
-        client.close();
-    }
-
-}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTunnelingTest.java b/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTunnelingTest.java
deleted file mode 100644
index 2029b2b4c..000000000
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTunnelingTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package com.ning.http.client.providers.grizzly;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProxyTunnellingTest;
-
-public class GrizzlyProxyTunnelingTest extends ProxyTunnellingTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
-    }
-
-}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncProviderBasicTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
similarity index 77%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
index bef44f90c..e393235e0 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
@@ -11,28 +11,27 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.async.AsyncProvidersBasicTest;
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.AsyncProvidersBasicTest;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.grizzly.TransportCustomizer;
 import org.glassfish.grizzly.filterchain.FilterChainBuilder;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
 import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
 import org.testng.annotations.Test;
 
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
 
 public class GrizzlyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Override
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
index e660fa744..3e2c4953f 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AsyncStreamHandlerTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamHandlerTest;
 
 public class GrizzlyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
index 23edd588a..9b705611a 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AsyncStreamLifecycleTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamLifecycleTest;
 
 public class GrizzlyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAuthTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAuthTimeoutTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
index b71e0a54a..81a62f933 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyAuthTimeoutTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
@@ -11,21 +11,18 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AuthTimeoutTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AuthTimeoutTest;
 
 public class GrizzlyAuthTimeoutTest extends AuthTimeoutTest {
 
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicAuthTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
index cd194f46f..06bd657f2 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicAuthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
@@ -11,21 +11,18 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BasicAuthTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicAuthTest;
 
 public class GrizzlyBasicAuthTest extends BasicAuthTest {
 
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicHttpsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
similarity index 73%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicHttpsTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
index 7fe5f20c4..b8e290246 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBasicHttpsTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BasicHttpsTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicHttpsTest;
 
 public class GrizzlyBasicHttpsTest extends BasicHttpsTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Override
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyChunkTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyChunkTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
index 7eee2c22b..2fa8d6ddb 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyChunkTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BodyChunkTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyChunkTest;
 
 public class GrizzlyBodyChunkTest extends BodyChunkTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
index e00242053..92a236599 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
@@ -11,19 +11,16 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BodyDeferringAsyncHandlerTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
 
 public class GrizzlyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyByteBufferCapacityTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
similarity index 72%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyByteBufferCapacityTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
index d7397a686..3d43f261b 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyByteBufferCapacityTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
@@ -11,21 +11,18 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ByteBufferCapacityTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ByteBufferCapacityTest;
 import org.testng.annotations.Test;
 
 public class GrizzlyByteBufferCapacityTest extends ByteBufferCapacityTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Test(groups = {"standalone", "default_provider"}, enabled=false)
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyChunkingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyChunkingTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
index f8fac4459..904d17d50 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyChunkingTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ChunkingTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ChunkingTest;
 
 public class GrizzlyChunkingTest extends ChunkingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyComplexClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyComplexClientTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
index 9eea58292..8ef3813c5 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyComplexClientTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ComplexClientTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ComplexClientTest;
 
 public class GrizzlyComplexClientTest extends ComplexClientTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
new file mode 100644
index 000000000..5ed9e95bb
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.ConnectionPoolTest;
+import org.glassfish.grizzly.Connection;
+import org.testng.annotations.Test;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.testng.Assert.*;
+
+public class GrizzlyConnectionPoolTest extends ConnectionPoolTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return GrizzlyProviderUtil.grizzlyProvider(config);
+    }
+
+    @Override
+    @Test(enabled=false)
+    public void testMaxTotalConnectionsException() {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 20; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+
+                    if (i < 5) {
+                        client.prepareGet(url).execute().get();
+                    } else {
+                        client.prepareGet(url).execute();
+                    }
+                } catch (Exception ex) {
+                    exception = ex;
+                    break;
+                }
+            }
+            assertNotNull(exception);
+            assertNotNull(exception.getMessage());
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    public void testValidConnectionsPool() {
+        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
+
+            public boolean offer(String key, Connection connection) {
+                return true;
+            }
+
+            public Connection poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Connection connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return true;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        try {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, enabled=false)
+    public void testInvalidConnectionsPool() {
+
+        ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
+
+            public boolean offer(String key, Connection connection) {
+                return false;
+            }
+
+            public Connection poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Connection connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return false;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        try {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    @Test
+    public void multipleMaxConnectionOpenTest() throws Throwable {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
+
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+
+            assertEquals(response.getResponseBody(), body);
+
+            // twice
+            Exception exception = null;
+            try {
+                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                fail("Should throw exception. Too many connections issued.");
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+        } finally {
+            c.close();
+        }
+    }
+}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyDigestAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyDigestAuthTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
index 74f09dcbe..f6e343593 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyDigestAuthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.DigestAuthTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.DigestAuthTest;
 
 public class GrizzlyDigestAuthTest extends DigestAuthTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyEmptyBodyTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyEmptyBodyTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
index 77a925056..161eeb260 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyEmptyBodyTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.EmptyBodyTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.EmptyBodyTest;
 
 public class GrizzlyEmptyBodyTest extends EmptyBodyTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyErrorResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyErrorResponseTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
index 0ae9beb70..c8946c34b 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyErrorResponseTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ErrorResponseTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ErrorResponseTest;
 
 public class GrizzlyErrorResponseTest extends ErrorResponseTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyExpectContinue100Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyExpectContinue100Test.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
index f8a8a66bc..b58e1a702 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyExpectContinue100Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.Expect100ContinueTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Expect100ContinueTest;
 
 public class GrizzlyExpectContinue100Test extends Expect100ContinueTest{
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFilterTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFilterTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
index 424dded0d..fd138b590 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFilterTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.FilterTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FilterTest;
 
 public class GrizzlyFilterTest extends FilterTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFollowingThreadTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFollowingThreadTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
index 981aa3599..2e602fa67 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyFollowingThreadTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.FollowingThreadTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FollowingThreadTest;
 
 public class GrizzlyFollowingThreadTest extends FollowingThreadTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHead302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHead302Test.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
index 9a875bc5c..d9975af03 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHead302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.Head302Test;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Head302Test;
 
 public class GrizzlyHead302Test extends Head302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
index ea96de47d..6ac2d1083 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.HttpToHttpsRedirectTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.HttpToHttpsRedirectTest;
 
 public class GrizzlyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyIdleStateHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyIdleStateHandlerTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
index a05c56e23..395c489b3 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyIdleStateHandlerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.IdleStateHandlerTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.IdleStateHandlerTest;
 
 public class GrizzlyIdleStateHandlerTest extends IdleStateHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyInputStreamTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyInputStreamTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
index 4f3f5f3a8..b71ade1df 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyInputStreamTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.InputStreamTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.InputStreamTest;
 
 public class GrizzlyInputStreamTest extends InputStreamTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyListenableFutureTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyListenableFutureTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
index ac589af94..bdfec6d84 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyListenableFutureTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ListenableFutureTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ListenableFutureTest;
 
 public class GrizzlyListenableFutureTest extends ListenableFutureTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
similarity index 66%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
index f3280bd33..70872b6a6 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
@@ -11,20 +11,23 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MaxConnectionsInThreads;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxConnectionsInThreads;
+import org.testng.annotations.Test;
 
 public class GrizzlyMaxConnectionsInThreadsTest extends MaxConnectionsInThreads {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
+    @Override
+    @Test(enabled=false)
+    public void testMaxConnectionsWithinThreads() {
+        super.testMaxConnectionsWithinThreads();
+    }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxTotalConnectionTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
index de2261707..f5593bd81 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
@@ -11,19 +11,16 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MaxTotalConnectionTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxTotalConnectionTest;
 
 public class GrizzlyMaxTotalConnectionTest extends MaxTotalConnectionTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMultipleHeaderTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMultipleHeaderTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
index 34915238c..e0ceb7ac7 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyMultipleHeaderTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MultipleHeaderTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MultipleHeaderTest;
 
 public class GrizzlyMultipleHeaderTest extends MultipleHeaderTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNoNullResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNoNullResponseTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
index f46ae7fe2..cb38a7a42 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNoNullResponseTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.NoNullResponseTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NoNullResponseTest;
 
 public class GrizzlyNoNullResponseTest extends NoNullResponseTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
index db3bae924..08a2c5171 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.NonAsciiContentLengthTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NonAsciiContentLengthTest;
 
 public class GrizzlyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyParamEncodingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyParamEncodingTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
index 54adef05a..dad25f32c 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyParamEncodingTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ParamEncodingTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ParamEncodingTest;
 
 public class GrizzlyParamEncodingTest extends ParamEncodingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestRelative302Test.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
index 09f4e0596..0ae732dd2 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestRelative302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PerRequestRelative302Test;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestRelative302Test;
 
 public class GrizzlyPerRequestRelative302Test extends PerRequestRelative302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
similarity index 65%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
index a0b433d77..34f049e4e 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
@@ -11,25 +11,24 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PerRequestTimeoutTest;
+import static org.testng.Assert.assertEquals;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestTimeoutTest;
 
 public class GrizzlyPerRequestTimeoutTest extends PerRequestTimeoutTest {
 
     @Override
-    protected String getExpectedTimeoutMessage() {
-        return "Timeout exceeded";
+    protected void checkTimeoutMessage(String message) {
+        assertEquals("Timeout exceeded", message);
     }
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostRedirectGetTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostRedirectGetTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java
index c74918f40..aeab91c4c 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostRedirectGetTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java
@@ -11,19 +11,16 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PostRedirectGetTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostRedirectGetTest;
 
 public class GrizzlyPostRedirectGetTest extends PostRedirectGetTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostWithQSTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostWithQSTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
index 9405d06a3..975f6e0b3 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPostWithQSTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PostWithQSTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostWithQSTest;
 
 public class GrizzlyPostWithQSTest extends PostWithQSTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
new file mode 100644
index 000000000..67021c923
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+
+public class GrizzlyProviderUtil {
+
+    public static AsyncHttpClient grizzlyProvider(AsyncHttpClientConfig config) {
+        if (config == null) {
+            config = new AsyncHttpClientConfig.Builder().build();
+        }
+        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+    }
+}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
index 2a46f1a59..ed024c917 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyProxyTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProxyTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTest;
 
 public class GrizzlyProxyTest extends ProxyTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
new file mode 100644
index 000000000..eb6f39cd2
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTunnellingTest;
+
+public class GrizzlyProxyTunnelingTest extends ProxyTunnellingTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return GrizzlyProviderUtil.grizzlyProvider(config);
+    }
+
+}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPutLargeFileTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPutLargeFileTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
index 249582521..89a52e4f6 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyPutLargeFileTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PutLargeFileTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PutLargeFileTest;
 
 public class GrizzlyPutLargeFileTest extends PutLargeFileTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyQueryParametersTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyQueryParametersTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
index fe0f07e49..5c57f8323 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyQueryParametersTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.QueryParametersTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.QueryParametersTest;
 
 public class GrizzlyQueryParametersTest extends QueryParametersTest{
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRC10KTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRC10KTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java
index db40c23e0..ef43002b5 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRC10KTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java
@@ -11,19 +11,16 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.RC10KTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RC10KTest;
 
 public class GrizzlyRC10KTest extends RC10KTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
similarity index 74%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
index 1fa638186..c68810799 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
@@ -11,26 +11,25 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.async.RedirectConnectionUsageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.RedirectConnectionUsageTest;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
+import org.asynchttpclient.providers.grizzly.TransportCustomizer;
 import org.glassfish.grizzly.filterchain.FilterChainBuilder;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
 import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
 
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
 
 public class GrizzlyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Override
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRelative302Test.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
index 840f370c8..915755024 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRelative302Test.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.Relative302Test;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Relative302Test;
 
 public class GrizzlyRelative302Test extends Relative302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRemoteSiteTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRemoteSiteTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
index 8e81e3d3b..3b0126d93 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRemoteSiteTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.RemoteSiteTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RemoteSiteTest;
 
 public class GrizzlyRemoteSiteTest extends RemoteSiteTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRetryRequestTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRetryRequestTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
index 9acea4b78..37cb4fe2e 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyRetryRequestTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.RetryRequestTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RetryRequestTest;
 
 public class GrizzlyRetryRequestTest extends RetryRequestTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
index 5cd94e47f..6a6d3041f 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.SimpleAsyncHttpClientTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
 
 public class GrizzlySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyTransferListenerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyTransferListenerTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
index ec8fefc08..59e24152c 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/GrizzlyTransferListenerTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
@@ -11,20 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly;
+package org.asynchttpclient.providers.grizzly;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.TransferListenerTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.TransferListenerTest;
 
 public class GrizzlyTransferListenerTest extends TransferListenerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
new file mode 100644
index 000000000..3698d8e18
--- /dev/null
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.grizzly;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
+
+public class GrizzlyUnexpectingTimeoutTest extends AbstractBasicTest {
+
+    private static final String MSG = "Unauthorized without WWW-Authenticate header";
+
+    protected String getExpectedTimeoutMessage() {
+        return "401 response received, but no WWW-Authenticate header was present";
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return GrizzlyProviderUtil.grizzlyProvider(config);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new ExpectExceptionHandler();
+    }
+
+    private class ExpectExceptionHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                    } catch (IOException e) {
+                        log.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void unexpectingTimeoutTest() throws IOException {
+        final AtomicInteger counts = new AtomicInteger();
+        final int timeout = 100;
+
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(timeout).build());
+        try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    counts.incrementAndGet();
+                    return response;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    counts.incrementAndGet();
+                    super.onThrowable(t);
+                }
+            });
+            // currently, an exception is expected
+            // because the grizzly provider would throw IllegalStateException if WWW-Authenticate header doesn't exist with 401 response status.
+            try {
+                Response response = responseFuture.get();
+                assertNull(response);
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
+            } catch (ExecutionException e) {
+                assertFalse(e.getCause() instanceof TimeoutException);
+                assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
+            }
+            // wait for timeout again.
+            try {
+                Thread.sleep(timeout * 2);
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
+            }
+            // the result should be either onCompleted or onThrowable.
+            assertEquals(1, counts.get(), "result should be one");
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyByteMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
similarity index 68%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyByteMessageTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
index 7733969ce..516e49928 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyByteMessageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
@@ -10,21 +10,19 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.grizzly.websocket;
+package org.asynchttpclient.providers.grizzly.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import com.ning.http.client.websocket.ByteMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.websocket.ByteMessageTest;
 import org.testng.annotations.Test;
 
 public class GrizzlyByteMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Test(timeOut = 60000)
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
similarity index 69%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
index cd4d190cb..9844fb439 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
@@ -11,22 +11,19 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly.websocket;
+package org.asynchttpclient.providers.grizzly.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import com.ning.http.client.websocket.CloseCodeReasonMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
 import org.testng.annotations.Test;
 
 public class GrizzlyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Override
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
similarity index 64%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyRedirectTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
index b88787a94..8600b57bb 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyRedirectTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
@@ -11,20 +11,19 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.grizzly.websocket;
+package org.asynchttpclient.providers.grizzly.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import com.ning.http.client.websocket.RedirectTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.websocket.RedirectTest;
 
 public class GrizzlyRedirectTest extends RedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyTextMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
similarity index 70%
rename from providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyTextMessageTest.java
rename to providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
index 7ddb49277..cf7db9228 100644
--- a/providers/grizzly/src/test/java/com/ning/http/client/providers/grizzly/websocket/GrizzlyTextMessageTest.java
+++ b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
@@ -10,21 +10,20 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.grizzly.websocket;
+package org.asynchttpclient.providers.grizzly.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import com.ning.http.client.websocket.ByteMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
+import org.asynchttpclient.websocket.ByteMessageTest;
 import org.testng.annotations.Test;
 
 public class GrizzlyTextMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return GrizzlyProviderUtil.grizzlyProvider(config);
     }
 
     @Test(timeOut = 60000)
diff --git a/providers/netty-4/pom.xml b/providers/netty-4/pom.xml
new file mode 100644
index 000000000..5aefababc
--- /dev/null
+++ b/providers/netty-4/pom.xml
@@ -0,0 +1,24 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.asynchttpclient</groupId>
+        <artifactId>async-http-client-providers-parent</artifactId>
+        <version>2.0.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <artifactId>async-http-client-netty-4-provider</artifactId>
+    <name>Asynchronous Http Client Netty 4 Provider</name>
+    <description>
+        The Async Http Client Netty 4 Provider.
+    </description>
+
+    <dependencies>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+            <version>4.0.0.Beta3</version>
+        </dependency>
+    </dependencies>
+
+</project>
\ No newline at end of file
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java
new file mode 100644
index 000000000..d9704ca7a
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyChunkedInput.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.Body;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.stream.ChunkedInput;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
+ */
+class BodyChunkedInput
+        implements ChunkedInput<ByteBuf> {
+
+    private final Body body;
+
+    private final int chunkSize = 1024 * 8;
+
+    private ByteBuffer nextChunk;
+
+    private static final ByteBuffer EOF = ByteBuffer.allocate(0);
+
+    private boolean endOfInput = false;
+
+    public BodyChunkedInput(Body body) {
+        if (body == null) {
+            throw new IllegalArgumentException("no body specified");
+        }
+        this.body = body;
+    }
+
+    private ByteBuffer peekNextChunk()
+            throws IOException {
+
+        if (nextChunk == null) {
+            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
+            long length = body.read(buffer);
+            if (length < 0) {
+                // Negative means this is finished
+                buffer.flip();
+                nextChunk = buffer;
+                endOfInput = true;
+            } else if (length == 0) {
+                // Zero means we didn't get anything this time, but may get next time
+                buffer.flip();
+                nextChunk = null;
+            } else {
+                buffer.flip();
+                nextChunk = buffer;
+            }
+        }
+        return nextChunk;
+    }
+
+    /**
+     * Having no next chunk does not necessarily means end of input, other chunks may arrive later
+     */
+    public boolean hasNextChunk() throws Exception {
+        return peekNextChunk() != null;
+    }
+
+    @Override
+    public boolean readChunk(ByteBuf b) throws Exception {
+        ByteBuffer buffer = peekNextChunk();
+        if (buffer == null || buffer == EOF) {
+            return false;
+        }
+        nextChunk = null;
+
+        b.writeBytes(buffer);
+        return true;
+    }
+
+    public boolean isEndOfInput() throws Exception {
+        return endOfInput;
+    }
+
+    public void close() throws Exception {
+        body.close();
+    }
+
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java
new file mode 100644
index 000000000..f5da85db3
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/BodyFileRegion.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.RandomAccessBody;
+import io.netty.buffer.AbstractReferenceCounted;
+import io.netty.buffer.ReferenceCounted;
+import io.netty.channel.FileRegion;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+/**
+ * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
+ */
+class BodyFileRegion
+        extends AbstractReferenceCounted
+        implements FileRegion {
+
+    private final RandomAccessBody body;
+
+    public BodyFileRegion(RandomAccessBody body) {
+        if (body == null) {
+            throw new IllegalArgumentException("no body specified");
+        }
+        this.body = body;
+    }
+
+    public long position() {
+        return 0;
+    }
+
+    public long count() {
+        return body.getContentLength();
+    }
+
+    public long transferTo(WritableByteChannel target, long position)
+            throws IOException {
+        return body.transferTo(position, Long.MAX_VALUE, target);
+    }
+
+    public void deallocate() {
+        try {
+            body.close();
+        } catch (IOException e) {
+            // we tried
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java
similarity index 97%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java
rename to providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java
index 36c4d6f90..cd7568498 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/FeedableBodyGenerator.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty_4;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -18,8 +18,8 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
 
 /**
  * {@link BodyGenerator} which may return just part of the payload at the time
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java
similarity index 76%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
rename to providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java
index 5d7b01644..9026fe3a3 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright 2010-2013 Ning, Inc.
  *
  * Ning licenses this file to you under the Apache License, version 2.0
  * (the "License"); you may not use this file except in compliance with the
@@ -13,95 +13,96 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHandler.STATE;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.ConnectionPoolKeyStrategy;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProgressAsyncHandler;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.RandomAccessBody;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.ntlm.NTLMEngine;
-import com.ning.http.client.ntlm.NTLMEngineException;
-import com.ning.http.client.providers.netty.FeedableBodyGenerator.FeedListener;
-import com.ning.http.client.providers.netty.spnego.SpnegoEngine;
-import com.ning.http.client.websocket.WebSocketUpgradeHandler;
-import com.ning.http.multipart.MultipartBody;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.client.providers.netty.util.CleanupChannelGroup;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
-import com.ning.http.util.UTF8UrlEncoder;
-import org.jboss.netty.bootstrap.ClientBootstrap;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.buffer.ChannelBufferOutputStream;
-import org.jboss.netty.buffer.ChannelBuffers;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureProgressListener;
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelPipeline;
-import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.ChannelStateEvent;
-import org.jboss.netty.channel.DefaultChannelFuture;
-import org.jboss.netty.channel.ExceptionEvent;
-import org.jboss.netty.channel.FileRegion;
-import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
-import org.jboss.netty.channel.group.ChannelGroup;
-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.oio.OioClientSocketChannelFactory;
-import org.jboss.netty.handler.codec.http.CookieEncoder;
-import org.jboss.netty.handler.codec.http.DefaultCookie;
-import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
-import org.jboss.netty.handler.codec.http.HttpChunk;
-import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.HttpClientCodec;
-import org.jboss.netty.handler.codec.http.HttpContentCompressor;
-import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
-import org.jboss.netty.handler.codec.http.HttpHeaders;
-import org.jboss.netty.handler.codec.http.HttpMethod;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpRequestEncoder;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-import org.jboss.netty.handler.codec.http.HttpResponseDecoder;
-import org.jboss.netty.handler.codec.http.HttpVersion;
-import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
-import org.jboss.netty.handler.ssl.SslHandler;
-import org.jboss.netty.handler.stream.ChunkedFile;
-import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.STATE;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.ProgressAsyncHandler;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.RandomAccessBody;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.ntlm.NTLMEngine;
+import org.asynchttpclient.ntlm.NTLMEngineException;
+import org.asynchttpclient.providers.netty_4.FeedableBodyGenerator.FeedListener;
+import org.asynchttpclient.providers.netty_4.spnego.SpnegoEngine;
+import org.asynchttpclient.providers.netty_4.spnego.SpnegoEngine;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.asynchttpclient.multipart.MultipartBody;
+import org.asynchttpclient.multipart.MultipartRequestEntity;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.providers.netty_4.util.CleanupChannelGroup;
+import org.asynchttpclient.util.ProxyUtils;
+import org.asynchttpclient.util.SslUtils;
+import org.asynchttpclient.util.UTF8UrlEncoder;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.AbstractReferenceCounted;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.FileRegion;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.oio.OioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.channel.socket.oio.OioSocketChannel;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.DefaultCookie;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContentCompressor;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpRequestEncoder;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseDecoder;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import io.netty.handler.codec.http.websocketx.WebSocketFrame;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.stream.ChunkedFile;
+import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.util.AttributeKey;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -114,6 +115,7 @@
 import java.net.InetSocketAddress;
 import java.net.MalformedURLException;
 import java.net.URI;
+import java.lang.reflect.Field;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.FileChannel;
 import java.nio.channels.WritableByteChannel;
@@ -121,13 +123,13 @@
 import java.security.GeneralSecurityException;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.Semaphore;
@@ -135,10 +137,11 @@
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-import static org.jboss.netty.channel.Channels.pipeline;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
 
-public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
+
+public class NettyAsyncHttpProvider extends ChannelInboundMessageHandlerAdapter<Object> implements AsyncHttpProvider {
     private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
     private final static String HTTP_HANDLER = "httpHandler";
     protected final static String SSL_HANDLER = "sslHandler";
@@ -149,15 +152,17 @@
 
     private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
     private final static Charset UTF8 = Charset.forName("UTF-8");
+    public final static AttributeKey<Object> DEFAULT_ATTRIBUTE = new AttributeKey<Object>("default");
 
-    private final ClientBootstrap plainBootstrap;
-    private final ClientBootstrap secureBootstrap;
-    private final ClientBootstrap webSocketBootstrap;
-    private final ClientBootstrap secureWebSocketBootstrap;
+    private final Bootstrap plainBootstrap;
+    private final Bootstrap secureBootstrap;
+    private final Bootstrap webSocketBootstrap;
+    private final Bootstrap secureWebSocketBootstrap;
+    private /* final */ EventLoopGroup eventLoop;
     private final static int MAX_BUFFERED_BYTES = 8192;
     private final AsyncHttpClientConfig config;
     private final AtomicBoolean isClose = new AtomicBoolean(false);
-    private final ClientSocketChannelFactory socketChannelFactory;
+    private final Class<? extends SocketChannel> socketChannelFactory;
     private final boolean allowReleaseSocketChannelFactory;
 
     private final ChannelGroup openChannels = new
@@ -192,35 +197,38 @@ public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
             asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
         }
 
-        if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO) != null) {
-            socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
+        if (asyncHttpProviderConfig.isUseBlockingIO()) {
+            socketChannelFactory = OioSocketChannel.class;
             this.allowReleaseSocketChannelFactory = true;
         } else {
             // check if external NioClientSocketChannelFactory is defined
-            Object oo = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.SOCKET_CHANNEL_FACTORY);
-            if (oo != null && NioClientSocketChannelFactory.class.isAssignableFrom(oo.getClass())) {
-            	this.socketChannelFactory = NioClientSocketChannelFactory.class.cast(oo);
+            Class<? extends SocketChannel> scf = asyncHttpProviderConfig.getSocketChannel();
+            if (scf != null) {
+            	this.socketChannelFactory = scf;
 
             	// cannot allow releasing shared channel factory
             	this.allowReleaseSocketChannelFactory = false;
             } else {
-                ExecutorService e = null;
-                Object o = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE);
-                if (o != null && ExecutorService.class.isAssignableFrom(o.getClass())) {
-                    e = ExecutorService.class.cast(o);
-                } else {
-            		e = Executors.newCachedThreadPool();
-            	}
+                socketChannelFactory = NioSocketChannel.class;
+                eventLoop = asyncHttpProviderConfig.getEventLoopGroup();
+                if (eventLoop == null) {
+                    if (socketChannelFactory == OioSocketChannel.class) {
+                        eventLoop = new OioEventLoopGroup();
+                    } else if (socketChannelFactory == NioSocketChannel.class) {
+                        eventLoop = new NioEventLoopGroup();
+                    } else {
+                        throw new IllegalArgumentException("No set event loop compatbile with socket channel " + scf);
+                    }
+                }
             	int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
             	log.debug("Number of application's worker threads is {}", numWorkers);
-            	socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
             	this.allowReleaseSocketChannelFactory = true;
             }
         }
-        plainBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureBootstrap = new ClientBootstrap(socketChannelFactory);
-        webSocketBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureWebSocketBootstrap = new ClientBootstrap(socketChannelFactory);
+        plainBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);
+        secureBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
+        webSocketBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
+        secureWebSocketBootstrap = new Bootstrap().channel(socketChannelFactory).group(eventLoop);;
         configureNetty();
 
         this.config = config;
@@ -253,45 +261,67 @@ public String toString() {
     }
 
     void configureNetty() {
+        Map<String, ChannelOption<Object>> optionMap = new HashMap<String, ChannelOption<Object>>();
+        for (Field field : ChannelOption.class.getDeclaredFields()) {
+            if (field.getType().isAssignableFrom(ChannelOption.class)) {
+                field.setAccessible(true);
+                try {
+                    optionMap.put(field.getName(), (ChannelOption<Object>) field.get(null));
+                } catch (IllegalAccessException ex) {
+                    throw new Error(ex);
+                }
+            }
+        }
+
         if (asyncHttpProviderConfig != null) {
             for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                plainBootstrap.setOption(entry.getKey(), entry.getValue());
+                ChannelOption<Object> key = optionMap.get(entry.getKey());
+                Object value = entry.getValue();
+                plainBootstrap.option(key, value);
+                webSocketBootstrap.option(key, value);
+                secureBootstrap.option(key, value);
+                secureWebSocketBootstrap.option(key, value);
             }
         }
 
-        plainBootstrap.setPipelineFactory(createPlainPipelineFactory());
-        DefaultChannelFuture.setUseDeadLockChecker(false);
+        plainBootstrap.handler(createPlainPipelineFactory());
+        // DefaultChannelFuture.setUseDeadLockChecker(false);
 
         if (asyncHttpProviderConfig != null) {
-            Object value = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT);
-            if (value != null && Boolean.class.isAssignableFrom(value.getClass())) {
-                executeConnectAsync = Boolean.class.cast(value);
-            } else if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.DISABLE_NESTED_REQUEST) != null) {
-                DefaultChannelFuture.setUseDeadLockChecker(true);
+            executeConnectAsync = asyncHttpProviderConfig.isAsyncConnect();
+            if (!executeConnectAsync) {
+                // DefaultChannelFuture.setUseDeadLockChecker(true);
             }
         }
 
-        webSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
+        webSocketBootstrap.handler(new ChannelInitializer() {
             /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline();
                 pipeline.addLast("ws-decoder", new HttpResponseDecoder());
                 pipeline.addLast("ws-encoder", new HttpRequestEncoder());
                 pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
             }
         });
     }
 
-    protected ChannelPipelineFactory createPlainPipelineFactory() {
-    	return new ChannelPipelineFactory() {
+    protected HttpClientCodec newHttpClientCodec() {
+        if (asyncHttpProviderConfig != null) {
+            return new HttpClientCodec(asyncHttpProviderConfig.getMaxInitialLineLength(), asyncHttpProviderConfig.getMaxHeaderSize(), asyncHttpProviderConfig.getMaxChunkSize(), false);
+
+        } else {
+            return new HttpClientCodec();
+        }
+    }
+
+    protected ChannelInitializer createPlainPipelineFactory() {
+        return new ChannelInitializer() {
 
             /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline();
 
-                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
 
                 if (config.getRequestCompressionLevel() > 0) {
                     pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
@@ -302,18 +332,16 @@ public ChannelPipeline getPipeline() throws Exception {
                 }
                 pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
                 pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
             }
         };
     }
 
     void constructSSLPipeline(final NettyConnectListener<?> cl) {
 
-        secureBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
+        secureBootstrap.handler(new ChannelInitializer() {
             /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline();
 
                 try {
                     pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
@@ -321,22 +349,21 @@ public ChannelPipeline getPipeline() throws Exception {
                     abort(cl.future(), ex);
                 }
 
-                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
 
                 if (config.isCompressionEnabled()) {
                     pipeline.addLast("inflater", new HttpContentDecompressor());
                 }
                 pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
                 pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
             }
         });
 
-        secureWebSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+        secureWebSocketBootstrap.handler(new ChannelInitializer() {
 
             /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
+            protected void initChannel(Channel ch) throws Exception {
+                ChannelPipeline pipeline = ch.pipeline();
 
                 try {
                     pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
@@ -347,17 +374,8 @@ public ChannelPipeline getPipeline() throws Exception {
                 pipeline.addLast("ws-decoder", new HttpResponseDecoder());
                 pipeline.addLast("ws-encoder", new HttpRequestEncoder());
                 pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-
-                return pipeline;
             }
         });
-
-        if (asyncHttpProviderConfig != null) {
-            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                secureBootstrap.setOption(entry.getKey(), entry.getValue());
-                secureWebSocketBootstrap.setOption(entry.getKey(), entry.getValue());
-            }
-        }
     }
 
     private Channel lookupInCache(URI uri, ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
@@ -388,12 +406,12 @@ private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException
 
     private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
 
-        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            channel.getPipeline().remove(SSL_HANDLER);
-        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+        if (channel.pipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+            channel.pipeline().remove(SSL_HANDLER);
+        } else if (channel.pipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
             return channel;
-        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+        } else if (channel.pipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
+            channel.pipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
         }
         return channel;
     }
@@ -407,7 +425,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
              * If the channel is dead because it was pooled and the remote server decided to close it,
              * we just let it go and the closeChannel do it's work.
              */
-            if (!channel.isOpen() || !channel.isConnected()) {
+            if (!channel.isOpen() || !channel.isActive()) {
                 return;
             }
 
@@ -427,9 +445,9 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                     }
                     long length = body.getContentLength();
                     if (length >= 0) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, length);
+                        nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, length);
                     } else {
-                        nettyRequest.setHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+                        nettyRequest.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
                     }
                 } else {
                     body = null;
@@ -439,8 +457,8 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
             if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
 
                 FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-                for (String s : future.getNettyRequest().getHeaderNames()) {
-                    for (String header : future.getNettyRequest().getHeaders(s)) {
+                for (String s : future.getNettyRequest().headers().names()) {
+                    for (String header : future.getNettyRequest().headers().getAll(s)) {
                         h.add(s, header);
                     }
                 }
@@ -476,7 +494,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                             fileLength = raf.length();
 
                             ChannelFuture writeFuture;
-                            if (channel.getPipeline().get(SslHandler.class) != null) {
+                            if (channel.pipeline().get(SslHandler.class) != null) {
                                 writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
                             } else {
                                 final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
@@ -497,13 +515,13 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                          * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
                          */
                         if (future.getRequest().getParts() != null) {
-                            String boundary = future.getNettyRequest().getHeader("Content-Type");
-                            String length = future.getNettyRequest().getHeader("Content-Length");
+                            String boundary = future.getNettyRequest().headers().get("Content-Type");
+                            String length = future.getNettyRequest().headers().get("Content-Length");
                             body = new MultipartBody(future.getRequest().getParts(), boundary, length);
                         }
 
                         ChannelFuture writeFuture;
-                        if (channel.getPipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
+                        if (channel.pipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
                             BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
                             writeFuture = channel.write(bodyFileRegion);
                         } else {
@@ -512,7 +530,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                                 if (bg instanceof FeedableBodyGenerator) {
                                     ((FeedableBodyGenerator)bg).setListener(new FeedListener() {
                                         @Override public void onContentAdded() {
-                                            channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                                            channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
                                         }
                                     });
                                 }
@@ -543,10 +561,10 @@ public void operationComplete(ChannelFuture cf) {
 
         try {
             future.touch();
-            int delay = requestTimeout(config, future.getRequest().getPerRequestConfig());
-            if (delay != -1 && !future.isDone() && !future.isCancelled()) {
+            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, future.getRequest());
+            if (requestTimeout != -1 && !future.isDone() && !future.isCancelled()) {
                 ReaperFuture reaperFuture = new ReaperFuture(future);
-                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, delay, TimeUnit.MILLISECONDS);
+                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, requestTimeout, TimeUnit.MILLISECONDS);
                 reaperFuture.setScheduledFuture(scheduledFuture);
                 future.setReaperFuture(reaperFuture);
             }
@@ -556,18 +574,14 @@ public void operationComplete(ChannelFuture cf) {
 
     }
 
-    private static boolean isProxyServer(AsyncHttpClientConfig config, Request request) {
-        return request.getProxyServer() != null || config.getProxyServer() != null;
-    }
-
     protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
-                                                    boolean allowConnect, ChannelBuffer buffer) throws IOException {
+                                                    boolean allowConnect, ByteBuf buffer, ProxyServer proxyServer) throws IOException {
 
         String method = request.getMethod();
-        if (allowConnect && (isProxyServer(config, request) && isSecure(uri))) {
+        if (allowConnect && proxyServer != null && isSecure(uri)) {
             method = HttpMethod.CONNECT.toString();
         }
-        return construct(config, request, new HttpMethod(method), uri, buffer);
+        return construct(config, request, new HttpMethod(method), uri, buffer, proxyServer);
     }
 
     private static SpnegoEngine getSpnegoEngine() {
@@ -580,7 +594,8 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                                          Request request,
                                          HttpMethod m,
                                          URI uri,
-                                         ChannelBuffer buffer) throws IOException {
+                                         ByteBuf buffer,
+                                         ProxyServer proxyServer) throws IOException {
 
         String host = AsyncHttpProviderUtils.getHost(uri);
         boolean webSocket = isWebSocket(uri);
@@ -589,38 +604,36 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
             host = request.getVirtualHost();
         }
 
-        HttpRequest nettyRequest;
+        FullHttpRequest nettyRequest;
         if (m.equals(HttpMethod.CONNECT)) {
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
+            nettyRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
         } else {
-            StringBuilder path = null;
-            if (isProxyServer(config, request))
-                path = new StringBuilder(uri.toString());
-            else {
-                path = new StringBuilder(uri.getRawPath());
-                if (uri.getQuery() != null) {
-                    path.append("?").append(uri.getRawQuery());
-                }
-            }
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path.toString());
+            String path = null;
+            if (proxyServer != null && !(isSecure(uri) && config.isUseRelativeURIsWithSSLProxies()))
+                path = uri.toString();
+            else if (uri.getRawQuery() != null)
+                path = uri.getRawPath() + "?" + uri.getRawQuery();
+            else
+                path = uri.getRawPath();
+            nettyRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, m, path);
         }
 
         if (webSocket) {
-            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
-            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
-            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":"
+            nettyRequest.headers().add(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
+            nettyRequest.headers().add(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
+            nettyRequest.headers().add("Origin", "http://" + uri.getHost() + ":"
                     + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
-            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
-            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
+            nettyRequest.headers().add(WEBSOCKET_KEY, WebSocketUtil.getKey());
+            nettyRequest.headers().add("Sec-WebSocket-Version", "13");
         }
 
         if (host != null) {
             if (uri.getPort() == -1) {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+                nettyRequest.headers().set(HttpHeaders.Names.HOST, host);
             } else if (request.getVirtualHost() != null) {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+                nettyRequest.headers().set(HttpHeaders.Names.HOST, host);
             } else {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+                nettyRequest.headers().set(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
             }
         } else {
             host = "127.0.0.1";
@@ -632,22 +645,21 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                 for (String name : h.keySet()) {
                     if (!"host".equalsIgnoreCase(name)) {
                         for (String value : h.get(name)) {
-                            nettyRequest.addHeader(name, value);
+                            nettyRequest.headers().add(name, value);
                         }
                     }
                 }
             }
 
             if (config.isCompressionEnabled()) {
-                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+                nettyRequest.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
             }
         } else {
             List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-            if (auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM")) {
-                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
+            if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM")) {
+                nettyRequest.headers().add(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
             }
         }
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
         Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
 
         if (realm != null && realm.getUsePreemptiveAuth()) {
@@ -664,13 +676,13 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
 
             switch (realm.getAuthScheme()) {
                 case BASIC:
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                    nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION,
                             AuthenticatorUtils.computeBasicAuthentication(realm));
                     break;
                 case DIGEST:
-                    if (realm.getNonce() != null && !realm.getNonce().equals("")) {
+                    if (isNonEmpty(realm.getNonce())) {
                         try {
-                            nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                            nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION,
                                     AuthenticatorUtils.computeDigestAuthentication(realm));
                         } catch (NoSuchAlgorithmException e) {
                             throw new SecurityException(e);
@@ -680,7 +692,7 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                 case NTLM:
                     try {
                         String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
-                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
+                        nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
                     } catch (NTLMEngineException e) {
                         IOException ie = new IOException();
                         ie.initCause(e);
@@ -698,34 +710,33 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                         ie.initCause(e);
                         throw ie;
                     }
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+                    nettyRequest.headers().set(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
                     break;
                 case NONE:
                     break;
                 default:
-                    throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
+                    throw new IllegalStateException("Invalid Authentication " + realm);
             }
         }
 
         if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
-            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, "keep-alive");
+            nettyRequest.headers().set(HttpHeaders.Names.CONNECTION, AsyncHttpProviderUtils.keepAliveHeaderValue(config));
         }
 
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
-        if (!avoidProxy) {
+        if (proxyServer != null) {
             if (!request.getHeaders().containsKey("Proxy-Connection")) {
-                nettyRequest.setHeader("Proxy-Connection", "keep-alive");
+                nettyRequest.headers().set("Proxy-Connection", AsyncHttpProviderUtils.keepAliveHeaderValue(config));
             }
 
             if (proxyServer.getPrincipal() != null) {
-                if (proxyServer.getNtlmDomain() != null && proxyServer.getNtlmDomain().length() > 0) {
+                if (isNonEmpty(proxyServer.getNtlmDomain())) {
 
                     List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-                    if (!(auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM"))) {
+                    if (!(isNonEmpty(auth) && auth.get(0).startsWith("NTLM"))) {
                         try {
                             String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
                                     proxyServer.getHost());
-                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
+                            nettyRequest.headers().set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
                         } catch (NTLMEngineException e) {
                             IOException ie = new IOException();
                             ie.initCause(e);
@@ -733,7 +744,7 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                         }
                     }
                 } else {
-                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION,
+                    nettyRequest.headers().set(HttpHeaders.Names.PROXY_AUTHORIZATION,
                             AuthenticatorUtils.computeBasicAuthentication(proxyServer));
                 }
             }
@@ -741,21 +752,21 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
 
         // Add default accept headers.
         if (request.getHeaders().getFirstValue("Accept") == null) {
-            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
+            nettyRequest.headers().set(HttpHeaders.Names.ACCEPT, "*/*");
         }
 
         if (request.getHeaders().getFirstValue("User-Agent") != null) {
-            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
+            nettyRequest.headers().set("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
         } else if (config.getUserAgent() != null) {
-            nettyRequest.setHeader("User-Agent", config.getUserAgent());
+            nettyRequest.headers().set("User-Agent", config.getUserAgent());
         } else {
-            nettyRequest.setHeader("User-Agent",
+            nettyRequest.headers().set("User-Agent",
                          AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class,
                                                                    config));
         }
 
         if (!m.equals(HttpMethod.CONNECT)) {
-            if (request.getCookies() != null && !request.getCookies().isEmpty()) {
+            if (isNonEmpty(request.getCookies())) {
                 CookieEncoder httpCookieEncoder = new CookieEncoder(false);
                 Iterator<Cookie> ic = request.getCookies().iterator();
                 Cookie c;
@@ -768,7 +779,7 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                     cookie.setDomain(c.getDomain());
                     httpCookieEncoder.addCookie(cookie);
                 }
-                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
+                nettyRequest.headers().set(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
             }
 
             String reqType = request.getMethod();
@@ -778,21 +789,21 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
 
                 // We already have processed the body.
                 if (buffer != null && buffer.writerIndex() != 0) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
                     nettyRequest.setContent(buffer);
                 } else if (request.getByteData() != null) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
+                    nettyRequest.setContent(Unpooled.wrappedBuffer(request.getByteData()));
                 } else if (request.getStringData() != null) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
+                    nettyRequest.setContent(Unpooled.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
                 } else if (request.getStreamData() != null) {
                     int[] lengthWrapper = new int[1];
                     byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
                     int length = lengthWrapper[0];
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
-                } else if (request.getParams() != null && !request.getParams().isEmpty()) {
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+                    nettyRequest.setContent(Unpooled.wrappedBuffer(bytes, 0, length));
+                } else if (isNonEmpty(request.getParams())) {
                     StringBuilder sb = new StringBuilder();
                     for (final Entry<String, List<String>> paramEntry : request.getParams()) {
                         final String key = paramEntry.getKey();
@@ -805,11 +816,11 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                             UTF8UrlEncoder.appendEncoded(sb, value);
                         }
                     }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
+                    nettyRequest.setContent(Unpooled.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
 
                     if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
+                        nettyRequest.headers().set(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
                     }
 
                 } else if (request.getParts() != null) {
@@ -821,16 +832,16 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
 
                     MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
 
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
 
                     /**
                      * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
                      */
 
                     if (isSecure(uri)) {
-                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                        mre.writeRequest(new ChannelBufferOutputStream(b));
+                        ByteBuf b = Unpooled.buffer(lenght);
+                        mre.writeRequest(new ByteBufOutputStream(b));
                         nettyRequest.setContent(b);
                     }
                 } else if (request.getEntityWriter() != null) {
@@ -840,16 +851,16 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                         lenght = MAX_BUFFERED_BYTES;
                     }
 
-                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
+                    ByteBuf b = Unpooled.buffer(lenght);
+                    request.getEntityWriter().writeEntity(new ByteBufOutputStream(b));
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
                     nettyRequest.setContent(b);
                 } else if (request.getFile() != null) {
                     File file = request.getFile();
                     if (!file.isFile()) {
                         throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
                     }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
+                    nettyRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());
                 }
             }
         }
@@ -863,9 +874,9 @@ public void close() {
             openChannels.close();
 
             for (Channel channel : openChannels) {
-                ChannelHandlerContext ctx = channel.getPipeline().getContext(NettyAsyncHttpProvider.class);
-                if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+                ChannelHandlerContext ctx = channel.pipeline().context(NettyAsyncHttpProvider.class);
+                if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof NettyResponseFuture<?>) {
+                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
                     future.setReaperFuture(null);
                 }
             }
@@ -873,11 +884,7 @@ public void close() {
             config.executorService().shutdown();
             config.reaper().shutdown();
             if (this.allowReleaseSocketChannelFactory) {
-            	socketChannelFactory.releaseExternalResources();
-                plainBootstrap.releaseExternalResources();
-                secureBootstrap.releaseExternalResources();
-                webSocketBootstrap.releaseExternalResources();
-                secureWebSocketBootstrap.releaseExternalResources();
+            	eventLoop.shutdown();
             }
         } catch (Throwable t) {
             log.warn("Unexpected error on close", t);
@@ -913,45 +920,46 @@ public Response prepareResponse(final HttpResponseStatus status,
             throw new IOException("WebSocket method must be a GET");
         }
 
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-        String requestUrl;
+        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
+        boolean useProxy = proxyServer != null;
+        URI uri;
         if (useRawUrl) {
-            requestUrl = request.getRawUrl();
+            uri = request.getRawURI();
         } else {
-            requestUrl = request.getUrl();
+            uri = request.getURI();
         }
-        URI uri = AsyncHttpProviderUtils.createUri(requestUrl);
         Channel channel = null;
 
         if (useCache) {
             if (f != null && f.reuseChannel() && f.channel() != null) {
                 channel = f.channel();
             } else {
-                channel = lookupInCache(uri, request.getConnectionPoolKeyStrategy());
+                URI connectionKeyUri = useProxy? proxyServer.getURI() : uri;
+                channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
             }
         }
 
-        ChannelBuffer bufferedBytes = null;
+        ByteBuf bufferedBytes = null;
         if (f != null && f.getRequest().getFile() == null &&
-                !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
-            bufferedBytes = f.getNettyRequest().getContent();
+                !f.getNettyRequest().getMethod().name().equals(HttpMethod.CONNECT.name())) {
+            bufferedBytes = f.getNettyRequest().data();
         }
 
-        boolean useSSl = isSecure(uri) && proxyServer == null;
-        if (channel != null && channel.isOpen() && channel.isConnected()) {
-            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes);
+        boolean useSSl = isSecure(uri) && !useProxy;
+        if (channel != null && channel.isOpen() && channel.isActive()) {
+            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes, proxyServer);
 
             if (f == null) {
-                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this);
+                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this, proxyServer);
             } else {
-                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes);
+                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes, proxyServer);
                 f.setNettyRequest(nettyRequest);
             }
             f.setState(NettyResponseFuture.STATE.POOLED);
             f.attachChannel(channel, false);
 
             log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
+            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(DEFAULT_ATTRIBUTE).set(f);
 
             try {
                 writeRequest(channel, config, f, nettyRequest);
@@ -976,7 +984,7 @@ public Response prepareResponse(final HttpResponseStatus status,
 
         // Do not throw an exception when we need an extra connection for a redirect.
         if (!reclaimCache && !connectionsPool.canCacheConnection()) {
-            IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
+            IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
             try {
                 asyncHandler.onThrowable(ex);
             } catch (Throwable t) {
@@ -990,7 +998,7 @@ public Response prepareResponse(final HttpResponseStatus status,
         if (trackConnections) {
             if (!reclaimCache) {
                 if (!freeConnections.tryAcquire()) {
-                    IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
+                    IOException ex = new IOException("Too many connections " +  config.getMaxTotalConnections());
                     try {
                         asyncHandler.onThrowable(ex);
                     } catch (Throwable t) {
@@ -1011,13 +1019,8 @@ public Response prepareResponse(final HttpResponseStatus status,
         }
 
         ChannelFuture channelFuture;
-        ClientBootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
-        bootstrap.setOption("connectTimeoutMillis", config.getConnectionTimeoutInMs());
-
-        // Do no enable this with win.
-        if (System.getProperty("os.name").toLowerCase().indexOf("win") == -1) {
-            bootstrap.setOption("reuseAddress", asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.REUSE_ADDRESS));
-        }
+        Bootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
+        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectionTimeoutInMs());
 
         try {
             InetSocketAddress remoteAddress;
@@ -1080,47 +1083,36 @@ public Response prepareResponse(final HttpResponseStatus status,
         log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
 
         if (!c.future().isCancelled() || !c.future().isDone()) {
-            openChannels.add(channelFuture.getChannel());
-            c.future().attachChannel(channelFuture.getChannel(), false);
+            openChannels.add(channelFuture.channel());
+            c.future().attachChannel(channelFuture.channel(), false);
         }
         return c.future();
     }
 
-    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
-        int result;
-        if (perRequestConfig != null) {
-            int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
-            result = (prRequestTimeout != 0 ? prRequestTimeout : config.getRequestTimeoutInMs());
-        } else {
-            result = config.getRequestTimeoutInMs();
-        }
-        return result;
-    }
-
     private void closeChannel(final ChannelHandlerContext ctx) {
-        connectionsPool.removeAll(ctx.getChannel());
+        connectionsPool.removeAll(ctx.channel());
         finishChannel(ctx);
     }
 
     private void finishChannel(final ChannelHandlerContext ctx) {
-        ctx.setAttachment(new DiscardEvent());
+        ctx.attr(DEFAULT_ATTRIBUTE).set(new DiscardEvent());
 
         // The channel may have already been removed if a timeout occurred, and this method may be called just after.
-        if (ctx.getChannel() == null) {
+        if (ctx.channel() == null) {
             return;
         }
 
-        log.debug("Closing Channel {} ", ctx.getChannel());
+        log.debug("Closing Channel {} ", ctx.channel());
 
 
         try {
-            ctx.getChannel().close();
+            ctx.channel().close();
         } catch (Throwable t) {
             log.debug("Error closing a connection", t);
         }
 
-        if (ctx.getChannel() != null) {
-            openChannels.remove(ctx.getChannel());
+        if (ctx.channel() != null) {
+            openChannels.remove(ctx.channel());
         }
 
     }
@@ -1171,7 +1163,7 @@ private Realm kerberosChallenge(List<String> proxyAuth,
                                     Realm realm,
                                     NettyResponseFuture<?> future) throws NTLMEngineException {
 
-        URI uri = URI.create(request.getUrl());
+        URI uri = request.getURI();
         String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
         String server = proxyServer == null ? host : proxyServer.getHost();
         try {
@@ -1185,7 +1177,7 @@ private Realm kerberosChallenge(List<String> proxyAuth,
             } else {
                 realmBuilder = new Realm.RealmBuilder();
             }
-            return realmBuilder.setUri(uri.getPath())
+            return realmBuilder.setUri(uri.getRawPath())
                     .setMethodName(request.getMethod())
                     .setScheme(Realm.AuthScheme.KERBEROS)
                     .build();
@@ -1216,9 +1208,10 @@ private Realm ntlmChallenge(List<String> wwwAuth,
         if (realm != null && !realm.isNtlmMessageType2Received()) {
             String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
 
+            URI uri = request.getURI();
             headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
             newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setUri(uri.getRawPath())
                     .setMethodName(request.getMethod())
                     .setNtlmMessageType2Received(true)
                     .build();
@@ -1244,7 +1237,7 @@ private Realm ntlmChallenge(List<String> wwwAuth,
                 authScheme = Realm.AuthScheme.NTLM;
             }
             newRealm = realmBuilder.setScheme(authScheme)
-                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setUri(request.getURI().getPath())
                     .setMethodName(request.getMethod())
                     .build();
         }
@@ -1278,17 +1271,22 @@ private Realm ntlmProxyChallenge(List<String> wwwAuth,
             realmBuilder = new Realm.RealmBuilder();
         }
         newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
-                .setUri(URI.create(request.getUrl()).getPath())
+                .setUri(request.getURI().getPath())
                 .setMethodName(request.getMethod())
                 .build();
 
         return newRealm;
     }
+    
+    private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
+        URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
+        return future.getConnectionPoolKeyStrategy().getKey(uri);
+    }
 
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final boolean keepAlive, final URI uri) {
+    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
         ctx.setAttachment(new AsyncCallable(future) {
             public Object call() throws Exception {
-                if (keepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(future.getConnectionPoolKeyStrategy().getKey(uri), ctx.getChannel())) {
+                if (future.isKeepAlive() && ctx.channel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.channel())) {
                     return null;
                 }
 
@@ -1298,7 +1296,7 @@ public Object call() throws Exception {
 
             @Override
             public String toString() {
-                return String.format("Draining task for channel %s", ctx.getChannel());
+                return "Draining task for channel " + ctx.channel();
             }
         });
     }
@@ -1324,7 +1322,7 @@ private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc
         future.touch();
 
         log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+        drainChannel(ctx, future);
         nextRequest(newRequest, future);
         return;
     }
@@ -1350,7 +1348,7 @@ private void nextRequest(final Request request, final NettyResponseFuture<?> fut
     private void abort(NettyResponseFuture<?> future, Throwable t) {
         Channel channel = future.channel();
         if (channel != null && openChannels.contains(channel)) {
-            closeChannel(channel.getPipeline().getContext(NettyAsyncHttpProvider.class));
+            closeChannel(channel.pipeline().context(NettyAsyncHttpProvider.class));
             openChannels.remove(channel);
         }
 
@@ -1369,14 +1367,14 @@ private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOExceptio
 
         if (isSecure(scheme)) {
             if (p.get(SSL_HANDLER) == null) {
-                p.addFirst(HTTP_HANDLER, new HttpClientCodec());
+                p.addFirst(HTTP_HANDLER, newHttpClientCodec());
                 p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
             } else {
-                p.addAfter(SSL_HANDLER, HTTP_HANDLER, new HttpClientCodec());
+                p.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
             }
 
         } else {
-            p.addFirst(HTTP_HANDLER, new HttpClientCodec());
+            p.addFirst(HTTP_HANDLER, newHttpClientCodec());
         }
     }
 
@@ -1475,17 +1473,16 @@ private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandle
             log.debug(t.getMessage(), t);
         }
 
-        if (!future.getKeepAlive() || !ctx.getChannel().isReadable()) {
+        if (!future.isKeepAlive() || !ctx.channel().isReadable()) {
             closeChannel(ctx);
         }
     }
 
     private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
-        if (lastValidChunk && future.getKeepAlive()) {
-            drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+        if (lastValidChunk && future.isKeepAlive()) {
+            drainChannel(ctx, future);
         } else {
-            if (future.getKeepAlive() && ctx.getChannel().isReadable() &&
-                    connectionsPool.offer(future.getConnectionPoolKeyStrategy().getKey(future.getURI()), ctx.getChannel())) {
+            if (future.isKeepAlive() && ctx.channel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.close())) {
                 markAsDone(future, ctx);
                 return;
             }
@@ -1516,9 +1513,9 @@ private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable e)
             throws Exception {
-        Channel channel = e.getChannel();
+        Channel channel = ctx.channel();
         Throwable cause = e.getCause();
         NettyResponseFuture<?> future = null;
 
@@ -1541,8 +1538,8 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                 return;
             }
 
-            if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                future = (NettyResponseFuture<?>) ctx.getAttachment();
+            if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
                 future.attachChannel(null, false);
                 future.touch();
 
@@ -1560,7 +1557,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                     } else {
                         // Close the channel so the recovering can occurs.
                         try {
-                            ctx.getChannel().close();
+                            ctx.channel().close();
                         } catch (Throwable t) {
                             ; // Swallow.
                         }
@@ -1572,8 +1569,8 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                     log.debug("Trying to recover from dead Channel: {}", channel);
                     return;
                 }
-            } else if (ctx.getAttachment() instanceof AsyncCallable) {
-                future = ((AsyncCallable) ctx.getAttachment()).future();
+            } else if (ctx.attr(DEFAULT_ATTRIBUTE).get() instanceof AsyncCallable) {
+                future = ((AsyncCallable) ctx.attr(DEFAULT_ATTRIBUTE).get()).future();
             }
         } catch (Throwable t) {
             cause = t;
@@ -1588,7 +1585,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
             }
         }
 
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+        Protocol p = (ctx.pipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
         p.onError(ctx, e);
 
         closeChannel(ctx);
@@ -1665,12 +1662,12 @@ protected static boolean abortOnWriteCloseException(Throwable cause) {
 
     private final static int computeAndSetContentLength(Request request, HttpRequest r) {
         int length = (int) request.getContentLength();
-        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
-            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
+        if (length == -1 && r.headers().get(HttpHeaders.Names.CONTENT_LENGTH) != null) {
+            length = Integer.valueOf(r.headers().get(HttpHeaders.Names.CONTENT_LENGTH));
         }
 
         if (length >= 0) {
-            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+            r.headers().set(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
         }
         return length;
     }
@@ -1678,12 +1675,13 @@ private final static int computeAndSetContentLength(Request request, HttpRequest
     public static <T> NettyResponseFuture<T> newFuture(URI uri,
                                                        Request request,
                                                        AsyncHandler<T> asyncHandler,
-                                                       HttpRequest nettyRequest,
+                                                       FullHttpRequest nettyRequest,
                                                        AsyncHttpClientConfig config,
-                                                       NettyAsyncHttpProvider provider) {
+                                                       NettyAsyncHttpProvider provider,
+                                                       ProxyServer proxyServer) {
 
-        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest,
-                requestTimeout(config, request.getPerRequestConfig()), config.getIdleConnectionTimeoutInMs(), provider, request.getConnectionPoolKeyStrategy());
+        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
+        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest, requestTimeout, config.getIdleConnectionTimeoutInMs(), provider, request.getConnectionPoolKeyStrategy(), proxyServer);
 
         if (request.getHeaders().getFirstValue("Expect") != null
                 && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
@@ -1695,10 +1693,10 @@ private final static int computeAndSetContentLength(Request request, HttpRequest
     private class ProgressListener implements ChannelFutureProgressListener {
 
         private final boolean notifyHeaders;
-        private final AsyncHandler asyncHandler;
+        private final AsyncHandler<?> asyncHandler;
         private final NettyResponseFuture<?> future;
 
-        public ProgressListener(boolean notifyHeaders, AsyncHandler asyncHandler, NettyResponseFuture<?> future) {
+        public ProgressListener(boolean notifyHeaders, AsyncHandler<?> asyncHandler, NettyResponseFuture<?> future) {
             this.notifyHeaders = notifyHeaders;
             this.asyncHandler = asyncHandler;
             this.future = future;
@@ -1707,13 +1705,13 @@ public ProgressListener(boolean notifyHeaders, AsyncHandler asyncHandler, NettyR
         public void operationComplete(ChannelFuture cf) {
             // The write operation failed. If the channel was cached, it means it got asynchronously closed.
             // Let's retry a second time.
-            Throwable cause = cf.getCause();
+            Throwable cause = cf.cause();
             if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
 
                 if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
                     log.debug(cause.getMessage(), cause);
                     try {
-                        cf.getChannel().close();
+                        cf.channel().close();
                     } catch (RuntimeException ex) {
                         log.debug(ex.getMessage(), ex);
                     }
@@ -1725,11 +1723,11 @@ public void operationComplete(ChannelFuture cf) {
                         || abortOnWriteCloseException(cause)) {
 
                     if (log.isDebugEnabled()) {
-                        log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
+                        log.debug(cf.cause() == null ? "" : cf.cause().getMessage(), cf.cause());
                     }
 
                     try {
-                        cf.getChannel().close();
+                        cf.channel().close();
                     } catch (RuntimeException ex) {
                         log.debug(ex.getMessage(), ex);
                     }
@@ -1834,13 +1832,9 @@ public synchronized void run() {
                     && !nettyResponseFuture.isDone() && !nettyResponseFuture.isCancelled()) {
                 log.debug("Request Timeout expired for {}\n", nettyResponseFuture);
 
-                int requestTimeout = config.getRequestTimeoutInMs();
-                PerRequestConfig p = nettyResponseFuture.getRequest().getPerRequestConfig();
-                if (p != null && p.getRequestTimeoutInMs() != -1) {
-                    requestTimeout = p.getRequestTimeoutInMs();
-                }
+                int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, nettyResponseFuture.getRequest());
 
-                abort(nettyResponseFuture, new TimeoutException(String.format("No response received after %s", requestTimeout)));
+                abort(nettyResponseFuture, new TimeoutException("No response received after " + requestTimeout));
 
                 nettyResponseFuture = null;
             }
@@ -1884,7 +1878,7 @@ protected Boolean initialValue() {
         }
     }
 
-    public static class OptimizedFileRegion implements FileRegion {
+    public static class OptimizedFileRegion extends AbstractReferenceCounted implements FileRegion {
 
         private final FileChannel file;
         private final RandomAccessFile raf;
@@ -1899,11 +1893,11 @@ public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
             this.count = count;
         }
 
-        public long getPosition() {
+        public long position() {
             return position;
         }
 
-        public long getCount() {
+        public long count() {
             return count;
         }
 
@@ -1921,12 +1915,12 @@ public long transferTo(WritableByteChannel target, long position) throws IOExcep
             long bw = file.transferTo(this.position + position, count, target);
             byteWritten += bw;
             if (byteWritten == raf.length()) {
-                releaseExternalResources();
+                deallocate();
             }
             return bw;
         }
 
-        public void releaseExternalResources() {
+        public void deallocate() {
             try {
                 file.close();
             } catch (IOException e) {
@@ -1943,11 +1937,11 @@ public void releaseExternalResources() {
 
     private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
 
-        private final ChannelBuffer content;
+        private final ByteBuf content;
         private final FileInputStream file;
         private int byteRead = 0;
 
-        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ChannelBuffer content, File file) throws IOException {
+        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ByteBuf content, File file) throws IOException {
             super(headers);
             this.content = content;
             if (file != null) {
@@ -2010,7 +2004,7 @@ private boolean redirect(Request request,
                              HttpResponse response,
                              final ChannelHandlerContext ctx) throws Exception {
 
-        int statusCode = response.getStatus().getCode();
+        int statusCode = response.getStatus().code();
         boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
         if (redirectEnabled && (statusCode == 302
                 || statusCode == 301
@@ -2021,7 +2015,7 @@ private boolean redirect(Request request,
                 // We must allow 401 handling again.
                 future.getAndSetAuth(false);
 
-                String location = response.getHeader(HttpHeaders.Names.LOCATION);
+                String location = response.headers().get(HttpHeaders.Names.LOCATION);
                 URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
                 boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
                 if (!uri.toString().equals(future.getURI().toString())) {
@@ -2034,8 +2028,8 @@ private boolean redirect(Request request,
                             && config.isStrict302Handling())) {
                         nBuilder.setMethod("GET");
                     }
-                    final URI initialConnectionUri = future.getURI();
-                    final boolean initialConnectionKeepAlive = future.getKeepAlive();
+                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                    final String initialPoolKey = getPoolKey(future);
                     future.setURI(uri);
                     String newUrl = uri.toString();
                     if (request.getUrl().startsWith(WEBSOCKET)) {
@@ -2043,21 +2037,19 @@ private boolean redirect(Request request,
                     }
 
                     log.debug("Redirecting to {}", newUrl);
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE)) {
+                    for (String cookieStr : future.getHttpResponse().headers().getAll(HttpHeaders.Names.SET_COOKIE)) {
                         Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
                         nBuilder.addOrReplaceCookie(c);
                     }
 
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE2)) {
+                    for (String cookieStr : future.getHttpResponse().headers().getAll(HttpHeaders.Names.SET_COOKIE2)) {
                         Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
                         nBuilder.addOrReplaceCookie(c);
                     }
 
-                    final String connectionPoolKey = future.getConnectionPoolKeyStrategy().getKey(initialConnectionUri);
                     AsyncCallable ac = new AsyncCallable(future) {
                         public Object call() throws Exception {
-                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() &&
-                                    connectionsPool.offer(connectionPoolKey, ctx.getChannel())) {
+                            if (initialConnectionKeepAlive && ctx.channel().isReadable() && connectionsPool.offer(initialPoolKey, ctx.channel())) {
                                 return null;
                             }
                             finishChannel(ctx);
@@ -2067,7 +2059,7 @@ public Object call() throws Exception {
 
                     if (response.isChunked()) {
                         // We must make sure there is no bytes left before executing the next request.
-                        ctx.setAttachment(ac);
+                        ctx.attr(DEFAULT_ATTRIBUTE).set(ac);
                     } else {
                         ac.call();
                     }
@@ -2081,10 +2073,10 @@ public Object call() throws Exception {
         return false;
     }
 
-    private final class HttpProtocol implements Protocol {
+    private final class HttpProtocol implements Protocol<HttpObject> {
         // @Override
-        public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws Exception {
-            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+        public void handle(final ChannelHandlerContext ctx, final HttpObject e) throws Exception {
+            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.attr(DEFAULT_ATTRIBUTE).get();
             future.touch();
 
             // The connect timeout occured.
@@ -2096,22 +2088,23 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
             HttpRequest nettyRequest = future.getNettyRequest();
             AsyncHandler handler = future.getAsyncHandler();
             Request request = future.getRequest();
+            ProxyServer proxyServer = future.getProxyServer();
             HttpResponse response = null;
             try {
-                if (e.getMessage() instanceof HttpResponse) {
-                    response = (HttpResponse) e.getMessage();
+                if (e instanceof FullHttpResponse) {
+                    response = (FullHttpResponse) e;
 
                     log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
 
                     // Required if there is some trailing headers.
                     future.setHttpResponse(response);
 
-                    int statusCode = response.getStatus().getCode();
+                    int statusCode = response.getStatus().code();
 
-                    String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
+                    String ka = response.headers().get(HttpHeaders.Names.CONNECTION);
                     future.setKeepAlive(ka == null || ! ka.toLowerCase().equals("close"));
 
-                    List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
+                    List<String> wwwAuth = getAuthorizationToken(response.headers(), HttpHeaders.Names.WWW_AUTHENTICATE);
                     Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
 
                     HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
@@ -2145,7 +2138,6 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                     }
 
                     Realm newRealm = null;
-                    ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
                     final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
                     final RequestBuilder builder = new RequestBuilder(future.getRequest());
 
@@ -2167,15 +2159,8 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                             newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
                             if (newRealm == null) return;
                         } else {
-                            Realm.RealmBuilder realmBuilder;
-                            if (realm != null) {
-                                realmBuilder = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                                ;
-                            } else {
-                                realmBuilder = new Realm.RealmBuilder();
-                            }
-                            newRealm = realmBuilder
-                                    .setUri(URI.create(request.getUrl()).getPath())
+                            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
+                                    .setUri(request.getURI().getPath())
                                     .setMethodName(request.getMethod())
                                     .setUsePreemptiveAuth(true)
                                     .parseWWWAuthenticateHeader(wwwAuth.get(0))
@@ -2188,15 +2173,15 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                         log.debug("Sending authentication to {}", request.getUrl());
                         AsyncCallable ac = new AsyncCallable(future) {
                             public Object call() throws Exception {
-                                drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
-                                nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
+                                drainChannel(ctx, future);
+                                nextRequest(builder.headers().sets(headers).setRealm(nr).build(), future);
                                 return null;
                             }
                         };
 
-                        if (future.getKeepAlive() && response.isChunked()) {
+                        if (future.isKeepAlive() && response.isChunked()) {
                             // We must make sure there is no bytes left before executing the next request.
-                            ctx.setAttachment(ac);
+                            ctx.attr(DEFAULT_ATTRIBUTE).set(ac);
                         } else {
                             ac.call();
                         }
@@ -2206,11 +2191,11 @@ public Object call() throws Exception {
                     if (statusCode == 100) {
                         future.getAndSetWriteHeaders(false);
                         future.getAndSetWriteBody(true);
-                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
+                        writeRequest(ctx.c, config, future, nettyRequest);
                         return;
                     }
 
-                    List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
+                    List<String> proxyAuth = getAuthorizationToken(response.headers(), HttpHeaders.Names.PROXY_AUTHENTICATE);
                     if (statusCode == 407
                             && realm != null
                             && proxyAuth.size() > 0
@@ -2230,7 +2215,7 @@ public Object call() throws Exception {
                             newRealm = future.getRequest().getRealm();
                         }
 
-                        Request req = builder.setHeaders(headers).setRealm(newRealm).build();
+                        Request req = builder.headers().sets(headers).setRealm(newRealm).build();
                         future.setReuseChannel(true);
                         future.setConnectAllowed(true);
                         nextRequest(req, future);
@@ -2242,13 +2227,13 @@ public Object call() throws Exception {
 
                         log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
 
-                        if (future.getKeepAlive()) {
-                            future.attachChannel(ctx.getChannel(), true);
+                        if (future.isKeepAlive()) {
+                            future.attachChannel(ctx.channel(), true);
                         }
 
                         try {
                             log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
-                            upgradeProtocol(ctx.getChannel().getPipeline(), URI.create(request.getUrl()).getScheme());
+                            upgradeProtocol(ctx.channel().pipeline(), request.getURI().getScheme());
                         } catch (Throwable ex) {
                             abort(future, ex);
                         }
@@ -2278,11 +2263,11 @@ public Object call() throws Exception {
                     if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
                         updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
                         markAsDone(future, ctx);
-                        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+                        drainChannel(ctx, future);
                     }
 
-                } else if (e.getMessage() instanceof HttpChunk) {
-                    HttpChunk chunk = (HttpChunk) e.getMessage();
+                } else if (e.getMessage() instanceof HttpContent) {
+                    HttpContent chunk = (HttpContent) e.getMessage();
 
                     if (handler != null) {
                         if (chunk.isLast() || updateBodyAndInterrupt(future, handler,
@@ -2326,18 +2311,15 @@ public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
     }
 
     private final class WebSocketProtocol implements Protocol {
-        private static final byte OPCODE_CONT = 0x0;
         private static final byte OPCODE_TEXT = 0x1;
         private static final byte OPCODE_BINARY = 0x2;
         private static final byte OPCODE_UNKNOWN = -1;
 
-    	   protected ChannelBuffer byteBuffer = null;
-    	   protected StringBuilder textBuffer = null;
     	   protected byte pendingOpcode = OPCODE_UNKNOWN;
  
         // @Override
         public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-            NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
+            NettyResponseFuture<?> future = NettyResponseFuture.class.cast(ctx.getAttachment());
             WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
             Request request = future.getRequest();
 
@@ -2346,7 +2328,7 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
 
                 HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
                 HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder()
+                FilterContext fc = new FilterContext.FilterContextBuilder()
                         .asyncHandler(h)
                         .request(request)
                         .responseStatus(s)
@@ -2443,7 +2425,7 @@ public void setContent(ChannelBuffer content) {
                 };
 
                 if (frame.getBinaryData() != null) {
-                    webSocketChunk.setContent(ChannelBuffers.wrappedBuffer(frame.getBinaryData()));
+                    webSocketChunk.setContent(Unpooled.wrappedBuffer(frame.getBinaryData()));
                     ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
                     h.onBodyPartReceived(rp);
 
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java
new file mode 100644
index 000000000..86beea686
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyAsyncHttpProviderConfig.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+
+/**
+ * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
+ */
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProviderConfig.class);
+
+    /**
+     * Use Netty's blocking IO stategy.
+     */
+    private boolean useBlockingIO;
+
+    /**
+     * Allow configuring the Netty's event loop.
+     */
+    private EventLoopGroup eventLoopGroup;
+
+    /**
+     * Allow configuring the Netty's used socket channel.
+     */
+    private Class<? extends SocketChannel> socketChannel;
+
+    /**
+     * Execute the connect operation asynchronously.
+     */
+    private boolean asyncConnect;
+
+    /**
+     * HttpClientCodec's maxInitialLineLength
+     */
+    private int maxInitialLineLength = 4096;
+
+    /**
+     * HttpClientCodec's maxHeaderSize
+     */
+    private int maxHeaderSize = 8192;
+
+    /**
+     * HttpClientCodec's maxChunkSize
+     */
+    private int maxChunkSize = 8192;
+
+    /**
+     * Use direct {@link java.nio.ByteBuffer}
+     */
+    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
+
+    /**
+     * Allow nested request from any {@link org.asynchttpclient.AsyncHandler}
+     */
+    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
+
+    /**
+     * See {@link java.net.Socket#setReuseAddress(boolean)}
+     */
+    public final static String REUSE_ADDRESS = ChannelOption.SO_REUSEADDR.name();
+
+    private final Map<String, Object> properties = new HashMap<String, Object>();
+
+    public NettyAsyncHttpProviderConfig() {
+        properties.put(REUSE_ADDRESS, Boolean.FALSE);
+    }
+
+    /**
+     * Add a property that will be used when the AsyncHttpClient initialize its {@link org.asynchttpclient.AsyncHttpProvider}
+     * 
+     * @param name
+     *            the name of the property
+     * @param value
+     *            the value of the property
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+
+        if (name.equals(REUSE_ADDRESS) && value == Boolean.TRUE && System.getProperty("os.name").toLowerCase().contains("win")) {
+            LOGGER.warn("Can't enable {} on Windows", REUSE_ADDRESS);
+        } else {
+            properties.put(name, value);
+        }
+
+        return this;
+    }
+
+    /**
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public Object getProperty(String name) {
+        return properties.get(name);
+    }
+
+    /**
+     * Remove the value associated with the property's name
+     * 
+     * @param name
+     * @return true if removed
+     */
+    public Object removeProperty(String name) {
+        return properties.remove(name);
+    }
+
+    /**
+     * Return the curent entry set.
+     * 
+     * @return a the curent entry set.
+     */
+    public Set<Map.Entry<String, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+
+    public boolean isUseBlockingIO() {
+        return useBlockingIO;
+    }
+
+    public void setUseBlockingIO(boolean useBlockingIO) {
+        this.useBlockingIO = useBlockingIO;
+    }
+
+    public Class<? extends SocketChannel> getSocketChannel() {
+        return socketChannel;
+    }
+
+    public void setSocketChannel(Class<? extends SocketChannel> socketChannel) {
+        this.socketChannel = socketChannel;
+    }
+
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
+
+    public void setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+        this.eventLoopGroup = eventLoopGroup;
+    }
+
+    public boolean isAsyncConnect() {
+        return asyncConnect;
+    }
+
+    public void setAsyncConnect(boolean asyncConnect) {
+        this.asyncConnect = asyncConnect;
+    }
+
+    public int getMaxInitialLineLength() {
+        return maxInitialLineLength;
+    }
+
+    public void setMaxInitialLineLength(int maxInitialLineLength) {
+        this.maxInitialLineLength = maxInitialLineLength;
+    }
+
+    public int getMaxHeaderSize() {
+        return maxHeaderSize;
+    }
+
+    public void setMaxHeaderSize(int maxHeaderSize) {
+        this.maxHeaderSize = maxHeaderSize;
+    }
+
+    public int getMaxChunkSize() {
+        return maxChunkSize;
+    }
+
+    public void setMaxChunkSize(int maxChunkSize) {
+        this.maxChunkSize = maxChunkSize;
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java
new file mode 100644
index 000000000..6a634de9e
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectListener.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.HostnameVerifier;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.ssl.SslHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.util.ProxyUtils;
+
+
+/**
+ * Non Blocking connect.
+ */
+final class NettyConnectListener<T> implements ChannelFutureListener {
+    private final static Logger logger = LoggerFactory.getLogger(NettyConnectListener.class);
+    private final AsyncHttpClientConfig config;
+    private final NettyResponseFuture<T> future;
+    private final HttpRequest nettyRequest;
+    private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
+
+    private NettyConnectListener(AsyncHttpClientConfig config,
+                                 NettyResponseFuture<T> future,
+                                 HttpRequest nettyRequest) {
+        this.config = config;
+        this.future = future;
+        this.nettyRequest = nettyRequest;
+    }
+
+    public NettyResponseFuture<T> future() {
+        return future;
+    }
+
+    public final void operationComplete(ChannelFuture f) throws Exception {
+        if (f.isSuccess()) {
+            Channel channel = f.channel();
+            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(future);
+            SslHandler sslHandler = (SslHandler) channel.pipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
+            if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
+                ((SslHandler) channel.pipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
+                return;
+            }
+
+            HostnameVerifier v = config.getHostnameVerifier();
+            if (sslHandler != null) {
+                if (!v.verify(future.getURI().getHost(), sslHandler.engine().getSession())) {
+                	ConnectException exception = new ConnectException("HostnameVerifier exception.");
+                	future.abort(exception);
+                	throw exception;
+                }
+            }
+
+            future.provider().writeRequest(f.channel(), config, future, nettyRequest);
+        } else {
+            Throwable cause = f.cause();
+
+            logger.debug("Trying to recover a dead cached channel {} with a retry value of {} ", f.channel(), future.canRetry());
+            if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
+                    || ClosedChannelException.class.isAssignableFrom(cause.getClass())
+                    || future.getState() != NettyResponseFuture.STATE.NEW)) {
+
+                logger.debug("Retrying {} ", nettyRequest);
+                if (future.provider().remotelyClosed(f.channel(), future)) {
+                    return;
+                }
+            }
+
+            logger.debug("Failed to recover from exception: {} with channel {}", cause, f.channel());
+
+            boolean printCause = f.cause() != null && cause.getMessage() != null;
+            ConnectException e = new ConnectException(printCause ? cause.getMessage() + " to " + future.getURI().toString() : future.getURI().toString());
+            if (cause != null) {
+                e.initCause(cause);
+            }
+            future.abort(e);
+        }
+    }
+
+    public static class Builder<T> {
+        private final AsyncHttpClientConfig config;
+
+        private final Request request;
+        private final AsyncHandler<T> asyncHandler;
+        private NettyResponseFuture<T> future;
+        private final NettyAsyncHttpProvider provider;
+        private final ByteBuf buffer;
+
+        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
+                       NettyAsyncHttpProvider provider, ByteBuf buffer) {
+
+            this.config = config;
+            this.request = request;
+            this.asyncHandler = asyncHandler;
+            this.future = null;
+            this.provider = provider;
+            this.buffer = buffer;
+        }
+
+        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
+                       NettyResponseFuture<T> future, NettyAsyncHttpProvider provider, ByteBuf buffer) {
+
+            this.config = config;
+            this.request = request;
+            this.asyncHandler = asyncHandler;
+            this.future = future;
+            this.provider = provider;
+            this.buffer = buffer;
+        }
+
+        public NettyConnectListener<T> build(final URI uri) throws IOException {
+            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
+            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer, proxyServer);
+            if (future == null) {
+                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider, proxyServer);
+            } else {
+                future.setNettyRequest(nettyRequest);
+                future.setRequest(request);
+            }
+            return new NettyConnectListener<T>(config, future, nettyRequest);
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java
similarity index 87%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
rename to providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java
index b09a22462..6b21e4911 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyConnectionsPool.java
@@ -10,10 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty_4;
 
-import com.ning.http.client.ConnectionsPool;
-import org.jboss.netty.channel.Channel;
+import org.asynchttpclient.ConnectionsPool;
+import io.netty.channel.Channel;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -27,7 +27,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * A simple implementation of {@link com.ning.http.client.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ * A simple implementation of {@link org.asynchttpclient.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
 public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
 
@@ -111,17 +111,17 @@ public void run() {
                 long endConcurrentLoop = System.currentTimeMillis();
 
                 for (IdleChannel idleChannel : channelsInTimeout) {
-                    Object attachment = idleChannel.channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+                    Object attachment = idleChannel.channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).get();
                     if (attachment != null) {
                         if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
                             NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
 
-                            if (!future.isDone() && !future.isCancelled()) {
-                                log.debug("Future not in appropriate state %s\n", future);
-                                continue;
-                            }
+                        if (!future.isDone() && !future.isCancelled()) {
+                            log.debug("Future not in appropriate state %s\n", future);
+                            continue;
                         }
                     }
+                    }
 
                     if (remove(idleChannel)) {
                         log.debug("Closing Idle Channel {}", idleChannel.channel);
@@ -129,9 +129,14 @@ public void run() {
                     }
                 }
 
-                if (log.isTraceEnabled())
+                if (log.isTraceEnabled()) {
+                    int openChannels = 0;
+                    for (ConcurrentLinkedQueue<IdleChannel> hostChannels: connectionsPool.values()) {
+                        openChannels += hostChannels.size();
+                    }
                     log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
-                        connectionsPool.size(), channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
+                            openChannels, channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
+                }
             } catch (Throwable t) {
                 log.error("uncaught exception!", t);
             }
@@ -158,7 +163,7 @@ else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeI
         }
 
         log.debug("Adding uri: {} for channel {}", uri, channel);
-        channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+        channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
 
         ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
         if (idleConnectionForHost == null) {
@@ -209,7 +214,7 @@ public Channel poll(String uri) {
 
                 if (idleChannel == null) {
                     poolEmpty = true;
-                } else if (!idleChannel.channel.isConnected() || !idleChannel.channel.isOpen()) {
+                } else if (!idleChannel.channel.isActive() || !idleChannel.channel.isOpen()) {
                     idleChannel = null;
                     log.trace("Channel not connected or not opened!");
                 }
@@ -269,7 +274,7 @@ public void destroy() {
 
     private void close(Channel channel) {
         try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
             channel2CreationDate.remove(channel);
             channel.close();
         } catch (Throwable t) {
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java
similarity index 51%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java
rename to providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java
index dd2b2a0de..9e9ea53d2 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponse.java
@@ -13,23 +13,30 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty_4;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.providers.ResponseBase;
-import com.ning.http.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.providers.ResponseBase;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.Unpooled;
+
 /**
- * Wrapper around the {@link com.ning.http.client.Response} API.
+ * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
 public class NettyResponse extends ResponseBase {
 
@@ -65,4 +72,49 @@ public String getResponseBodyExcerpt(int maxLength, String charset) throws IOExc
         }
         return Collections.unmodifiableList(cookies);
     }
+
+    /* @Override */
+    public byte[] getResponseBodyAsBytes() throws IOException {
+        return getResponseBodyAsByteBuffer().array();
+    }
+
+    /* @Override */
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return getResponseBodyAsByteBuf().nioBuffer();
+    }
+
+    /* @Override */
+    public String getResponseBody() throws IOException {
+        return getResponseBody(null);
+    }
+
+    /* @Override */
+    public String getResponseBody(String charset) throws IOException {
+        return getResponseBodyAsByteBuf().toString(Charset.forName(calculateCharset(charset)));
+    }
+
+    /* @Override */
+    public InputStream getResponseBodyAsStream() throws IOException {
+        return new ByteBufInputStream(getResponseBodyAsByteBuf());
+    }
+
+    public ByteBuf getResponseBodyAsByteBuf() throws IOException {
+        ByteBuf b = null;
+        switch (bodyParts.size()) {
+        case 0:
+            b = Unpooled.EMPTY_BUFFER;
+            break;
+        case 1:
+            b = ResponseBodyPart.class.cast(bodyParts.get(0)).getChannelBuffer();
+            break;
+        default:
+            ByteBuf[] channelBuffers = new ByteBuf[bodyParts.size()];
+            for (int i = 0; i < bodyParts.size(); i++) {
+                channelBuffers[i] = ResponseBodyPart.class.cast(bodyParts.get(i)).getChannelBuffer();
+            }
+            b = Unpooled.wrappedBuffer(channelBuffers);
+        }
+
+        return b;
+    }
 }
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java
old mode 100755
new mode 100644
similarity index 90%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
rename to providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java
index f77c3b335..6f5b2861c
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyResponseFuture.java
@@ -13,15 +13,17 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.ConnectionPoolKeyStrategy;
-import com.ning.http.client.Request;
-import com.ning.http.client.listenable.AbstractListenableFuture;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpResponse;
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -47,7 +49,7 @@
 public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
 
     private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
-    public final static String MAX_RETRY = "com.ning.http.client.providers.netty.maxRetry";
+    public final static String MAX_RETRY = "org.asynchttpclient.providers.netty.maxRetry";
 
     enum STATE {
         NEW,
@@ -63,7 +65,7 @@
     private final int responseTimeoutInMs;
     private final int idleConnectionTimeoutInMs;
     private Request request;
-    private HttpRequest nettyRequest;
+    private FullHttpRequest nettyRequest;
     private final AtomicReference<V> content = new AtomicReference<V>();
     private URI uri;
     private boolean keepAlive = true;
@@ -87,15 +89,17 @@
     private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
     private boolean allowConnect = false;
     private final ConnectionPoolKeyStrategy connectionPoolKeyStrategy;
+    private final ProxyServer proxyServer;
     
     public NettyResponseFuture(URI uri,
                                Request request,
                                AsyncHandler<V> asyncHandler,
-                               HttpRequest nettyRequest,
+                               FullHttpRequest nettyRequest,
                                int responseTimeoutInMs,
                                int idleConnectionTimeoutInMs,
                                NettyAsyncHttpProvider asyncHttpProvider,
-                               ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
+                               ConnectionPoolKeyStrategy connectionPoolKeyStrategy,
+                               ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
         this.responseTimeoutInMs = responseTimeoutInMs;
@@ -105,6 +109,7 @@ public NettyResponseFuture(URI uri,
         this.uri = uri;
         this.asyncHttpProvider = asyncHttpProvider;
         this.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
+        this.proxyServer = proxyServer;
 
         if (System.getProperty(MAX_RETRY) != null) {
             maxRetry = Integer.valueOf(System.getProperty(MAX_RETRY));
@@ -127,6 +132,10 @@ public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
 		return connectionPoolKeyStrategy;
 	}
 
+	public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -157,7 +166,7 @@ public boolean cancel(boolean force) {
         if (isCancelled.get()) return false;
 
         try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
             channel.close();
         } catch (Throwable t) {
             // Ignore
@@ -221,7 +230,7 @@ public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException,
             if (expired) {
                 isCancelled.set(true);
                 try {
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+                    channel.pipeline().context(NettyAsyncHttpProvider.class).attr(NettyAsyncHttpProvider.DEFAULT_ATTRIBUTE).set(new NettyAsyncHttpProvider.DiscardEvent());
                     channel.close();
                 } catch (Throwable t) {
                     // Ignore
@@ -278,6 +287,9 @@ V getContent() throws ExecutionException {
     }
 
     public final void done(Callable callable) {
+
+        Throwable exception = null;
+
         try {
             cancelReaper();
 
@@ -290,16 +302,21 @@ public final void done(Callable callable) {
                 try {
                     callable.call();
                 } catch (Exception ex) {
-                    throw new RuntimeException(ex);
+                    exception = ex;
                 }
             }
         } catch (ExecutionException t) {
             return;
         } catch (RuntimeException t) {
-            exEx.compareAndSet(null, new ExecutionException(t));
+            exception = t.getCause() != null ? t.getCause() : t;
+
         } finally {
             latch.countDown();
         }
+
+        if (exception != null)
+            exEx.compareAndSet(null, new ExecutionException(exception));
+
         super.done();
     }
 
@@ -330,7 +347,7 @@ protected final Request getRequest() {
         return request;
     }
 
-    public final HttpRequest getNettyRequest() {
+    public final FullHttpRequest getNettyRequest() {
         return nettyRequest;
     }
 
@@ -342,7 +359,7 @@ protected final void setNettyRequest(HttpRequest nettyRequest) {
         return asyncHandler;
     }
 
-    protected final boolean getKeepAlive() {
+    protected final boolean isKeepAlive() {
         return keepAlive;
     }
 
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java
new file mode 100644
index 000000000..b88593056
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/NettyWebSocket.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketByteListener;
+import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketTextListener;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import java.io.ByteArrayOutputStream;
+
+import static io.netty.buffer.Unpooled.wrappedBuffer;
+
+public class NettyWebSocket implements WebSocket {
+    private final static Logger logger = LoggerFactory.getLogger(NettyWebSocket.class);
+
+    private final Channel channel;
+    private final ConcurrentLinkedQueue<WebSocketListener> listeners = new ConcurrentLinkedQueue<WebSocketListener>();
+
+    private StringBuilder textBuffer;
+    private ByteArrayOutputStream byteBuffer;
+    private int maxBufferSize = 128000000;
+
+    public NettyWebSocket(Channel channel) {
+        this.channel = channel;
+    }
+
+    // @Override
+    public WebSocket sendMessage(byte[] message) {
+        channel.write(new BinaryWebSocketFrame(wrappedBuffer(message)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket stream(byte[] fragment, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket sendTextMessage(String message) {
+        channel.write(new TextWebSocketFrame(message));
+        return this;
+    }
+
+    // @Override
+    public WebSocket streamText(String fragment, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket sendPing(byte[] payload) {
+        channel.write(new PingWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket sendPong(byte[] payload) {
+        channel.write(new PongWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        listeners.add(l);
+        return this;
+    }
+
+    // @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        listeners.remove(l);
+        return this;
+    }
+
+    public int getMaxBufferSize() {
+    	return maxBufferSize;
+    }
+    
+    public void setMaxBufferSize(int bufferSize) {
+    	maxBufferSize = bufferSize;
+    	
+    	if(maxBufferSize < 8192)
+    		maxBufferSize = 8192;
+    }
+    
+    // @Override
+    public boolean isOpen() {
+        return channel.isOpen();
+    }
+
+    // @Override
+    public void close() {
+        onClose();
+        listeners.clear();
+        channel.close();
+    }
+
+    protected void onBinaryFragment(byte[] message, boolean last) {
+        for (WebSocketListener l : listeners) {
+            if (WebSocketByteListener.class.isAssignableFrom(l.getClass())) {
+                try {
+                	WebSocketByteListener.class.cast(l).onFragment(message,last);
+                	
+                	if(byteBuffer == null) {
+                		byteBuffer = new ByteArrayOutputStream();
+                	}
+                	
+                	byteBuffer.write(message);
+                	
+                	if(byteBuffer.size() > maxBufferSize) {
+                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
+                        l.onError(e);
+                		this.close();
+                		return;
+                	}
+                	
+
+                	if(last) {
+                    	WebSocketByteListener.class.cast(l).onMessage(byteBuffer.toByteArray());
+                    	byteBuffer = null;
+                    	textBuffer = null;
+                	}
+                } catch (Exception ex) {
+                    l.onError(ex);
+                }
+            }
+        }
+    }
+
+    protected void onTextFragment(String message, boolean last) {
+        for (WebSocketListener l : listeners) {
+            if (WebSocketTextListener.class.isAssignableFrom(l.getClass())) {
+                try {
+                    WebSocketTextListener.class.cast(l).onFragment(message,last);
+                    
+                	if(textBuffer == null) {
+                		textBuffer = new StringBuilder();
+                	}
+                	
+                	textBuffer.append(message);
+                	
+                	if(textBuffer.length() > maxBufferSize) {
+                		Exception e = new Exception("Exceeded Netty Web Socket maximum buffer size of " + getMaxBufferSize());
+                        l.onError(e);
+                		this.close();
+                		return;
+                	}
+                	
+                	if(last) {
+                    	WebSocketTextListener.class.cast(l).onMessage(textBuffer.toString());
+                    	byteBuffer = null;
+                    	textBuffer = null;
+                	}
+                } catch (Exception ex) {
+                    l.onError(ex);
+                }
+            }
+        }
+    }
+
+    protected void onError(Throwable t) {
+        for (WebSocketListener l : listeners) {
+            try {
+                l.onError(t);
+            } catch (Throwable t2) {
+                logger.error("", t2);
+            }
+
+        }
+    }
+
+    protected void onClose() {
+        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
+    }
+
+    protected void onClose(int code, String reason) {
+        for (WebSocketListener l : listeners) {
+            try {
+                if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(l.getClass())) {
+                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
+                }
+                l.onClose(this);
+            } catch (Throwable t) {
+                l.onError(t);
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "NettyWebSocket{" +
+                "channel=" + channel +
+                '}';
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java
new file mode 100644
index 000000000..c83043148
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/Protocol.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import io.netty.channel.ChannelHandlerContext;
+
+public interface Protocol<T> {
+
+    void handle(ChannelHandlerContext ctx, T message) throws Exception;
+
+    void onError(ChannelHandlerContext ctx, Throwable error);
+
+    void onClose(ChannelHandlerContext ctx);
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java
new file mode 100644
index 000000000..43ced26de
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseBodyPart.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseBodyPart;
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A callback class used when an HTTP response body is received.
+ */
+public class ResponseBodyPart extends HttpResponseBodyPart {
+
+    private final HttpContent chunk;
+    private final FullHttpResponse response;
+    private final AtomicReference<byte[]> bytes = new AtomicReference<byte[]>(null);
+    private final boolean isLast;
+    private boolean closeConnection = false;
+
+    /**
+     * Constructor used for non-chunked GET requests and HEAD requests.
+     */
+    public ResponseBodyPart(URI uri, FullHttpResponse response, AsyncHttpProvider provider, boolean last) {
+        this(uri, response, provider, null, last);
+    }
+
+    public ResponseBodyPart(URI uri, FullHttpResponse response, AsyncHttpProvider provider, HttpContent chunk, boolean last) {
+        super(uri, provider);
+        this.chunk = chunk;
+        this.response = response;
+        isLast = last;
+    }
+    
+    /**
+     * Return the response body's part bytes received.
+     *
+     * @return the response body's part bytes received.
+     */
+    @Override
+    public byte[] getBodyPartBytes() {
+        byte[] bp = bytes.get();
+        if (bp != null) {
+            return bp;
+        }
+
+        ByteBuf b = getChannelBuffer();
+        byte[] rb = b.nioBuffer().array();
+        bytes.set(rb);
+        return rb;
+    }
+
+    @Override
+    public InputStream readBodyPartBytes() {
+        return new ByteArrayInputStream(getBodyPartBytes());
+    }
+
+    @Override
+    public int length() {
+        ByteBuf b = (chunk != null) ? chunk.data() : response.data();
+        return b.readableBytes();
+    }
+    
+    @Override
+    public int writeTo(OutputStream outputStream) throws IOException {
+        ByteBuf b = getChannelBuffer();
+        int available = b.readableBytes();
+        if (available > 0) {
+            b.getBytes(b.readerIndex(), outputStream, available);
+        }
+        return available;
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        return ByteBuffer.wrap(getBodyPartBytes());
+    }
+
+    public ByteBuf getChannelBuffer() {
+        return chunk != null ? chunk.data() : response.data();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isLast() {
+        return isLast;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void markUnderlyingConnectionAsClosed() {
+        closeConnection = true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean closeUnderlyingConnection() {
+        return closeConnection;
+    }
+
+    protected HttpContent chunk() {
+        return chunk;
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java
new file mode 100644
index 000000000..3ee78ae74
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseHeaders.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
+
+import java.net.URI;
+
+/**
+ * A class that represent the HTTP headers.
+ */
+public class ResponseHeaders extends HttpResponseHeaders {
+
+    private final LastHttpContent trailingHeaders;
+    private final HttpResponse response;
+    private final FluentCaseInsensitiveStringsMap headers;
+
+    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider) {
+        super(uri, provider, false);
+        this.trailingHeaders = null;
+        this.response = response;
+        headers = computerHeaders();
+    }
+
+    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider, LastHttpContent traillingHeaders) {
+        super(uri, provider, true);
+        this.trailingHeaders = traillingHeaders;
+        this.response = response;
+        headers = computerHeaders();
+    }
+
+    private FluentCaseInsensitiveStringsMap computerHeaders() {
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (String s : response.headers().names()) {
+            for (String header : response.headers().getAll(s)) {
+                h.add(s, header);
+            }
+        }
+
+        if (trailingHeaders != null) {
+            for (final String s : trailingHeaders.trailingHeaders().names()) {
+                for (String header : response.headers().getAll(s)) {
+                    h.add(s, header);
+                }
+            }
+        }
+
+        return h;
+    }
+
+    /**
+     * Return the HTTP header
+     *
+     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
+     */
+    @Override
+    public FluentCaseInsensitiveStringsMap getHeaders() {
+        return headers;
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java
new file mode 100644
index 000000000..0f9ae49d2
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/ResponseStatus.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.net.URI;
+
+/**
+ * A class that represent the HTTP response' status line (code + text)
+ */
+public class ResponseStatus extends HttpResponseStatus {
+
+    private final HttpResponse response;
+
+    public ResponseStatus(URI uri, HttpResponse response, AsyncHttpProvider provider) {
+        super(uri, provider);
+        this.response = response;
+    }
+
+    /**
+     * Return the response status code
+     *
+     * @return the response status code
+     */
+    public int getStatusCode() {
+        return response.getStatus().code();
+    }
+
+    /**
+     * Return the response status text
+     *
+     * @return the response status text
+     */
+    public String getStatusText() {
+        return response.getStatus().reasonPhrase();
+    }
+
+    @Override
+    public String getProtocolName() {
+        return response.getProtocolVersion().protocolName();
+    }
+
+    @Override
+    public int getProtocolMajorVersion() {
+        return response.getProtocolVersion().majorVersion();
+    }
+
+    @Override
+    public int getProtocolMinorVersion() {
+        return response.getProtocolVersion().minorVersion();
+    }
+
+    @Override
+    public String getProtocolText() {
+        return response.getProtocolVersion().text();
+    }
+
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java
new file mode 100644
index 000000000..b4ffdeb54
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/WebSocketUtil.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty_4;
+
+import org.asynchttpclient.util.Base64;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public final class WebSocketUtil {
+    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+    public static String getKey() {
+        byte[] nonce = createRandomBytes(16);
+        return base64Encode(nonce);
+    }
+
+    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
+        String acceptSeed = key + MAGIC_GUID;
+        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
+        return base64Encode(sha1);
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("MD5 not supported on this platform");
+        }
+    }
+
+    public static byte[] sha1(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("SHA-1 not supported on this platform");
+        }
+    }
+
+    public static String base64Encode(byte[] bytes) {
+        return Base64.encode(bytes);
+    }
+
+    public static byte[] createRandomBytes(int size) {
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size; i++) {
+            bytes[i] = (byte) createRandomNumber(0, 255);
+        }
+
+        return bytes;
+    }
+
+    public static int createRandomNumber(int min, int max) {
+        return (int) (Math.random() * max + min);
+    }
+
+}
+
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java
new file mode 100644
index 000000000..a712421cc
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoEngine.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * ====================================================================
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package org.asynchttpclient.providers.netty_4.spnego;
+
+import org.asynchttpclient.util.Base64;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+
+/**
+ * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
+ * scheme.
+ *
+ * @since 4.1
+ */
+public class SpnegoEngine {
+    private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
+    private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+
+    private final Logger log = LoggerFactory.getLogger(getClass());
+
+    private final SpnegoTokenGenerator spnegoGenerator;
+
+    public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
+        this.spnegoGenerator = spnegoGenerator;
+    }
+
+    public SpnegoEngine() {
+        this(null);
+    }
+
+    public String generateToken(String server) throws Throwable {
+        GSSContext gssContext = null;
+        byte[] token = null; // base64 decoded challenge
+        Oid negotiationOid = null;
+
+        try {
+            log.debug("init {}", server);
+            /* Using the SPNEGO OID is the correct method.
+             * Kerberos v5 works for IIS but not JBoss. Unwrapping
+             * the initial token when using SPNEGO OID looks like what is
+             * described here...
+             *
+             * http://msdn.microsoft.com/en-us/library/ms995330.aspx
+             *
+             * Another helpful URL...
+             *
+             * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
+             *
+             * Unfortunately SPNEGO is JRE >=1.6.
+             */
+
+            /** Try SPNEGO by default, fall back to Kerberos later if error */
+            negotiationOid = new Oid(SPNEGO_OID);
+
+            boolean tryKerberos = false;
+            try {
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(
+                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            } catch (GSSException ex) {
+                log.error("generateToken", ex);
+                // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
+                // Rethrow any other exception.
+                if (ex.getMajor() == GSSException.BAD_MECH) {
+                    log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
+                    tryKerberos = true;
+                } else {
+                    throw ex;
+                }
+
+            }
+            if (tryKerberos) {
+                /* Kerberos v5 GSS-API mechanism defined in RFC 1964.*/
+                log.debug("Using Kerberos MECH {}", KERBEROS_OID);
+                negotiationOid = new Oid(KERBEROS_OID);
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(
+                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            }
+
+            // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
+            if (token == null) {
+                token = new byte[0];
+            }
+
+            token = gssContext.initSecContext(token, 0, token.length);
+            if (token == null) {
+                throw new Exception("GSS security context initialization failed");
+            }
+
+            /*
+             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish?
+             * seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
+             */
+            if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
+                token = spnegoGenerator.generateSpnegoDERObject(token);
+            }
+
+            gssContext.dispose();
+
+            String tokenstr = new String(Base64.encode(token));
+            log.debug("Sending response '{}' back to the server", tokenstr);
+
+            return tokenstr;
+        } catch (GSSException gsse) {
+            log.error("generateToken", gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL
+                    || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
+                throw new Exception(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.NO_CRED)
+                throw new Exception(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN
+                    || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
+                    || gsse.getMajor() == GSSException.OLD_TOKEN)
+                throw new Exception(gsse.getMessage(), gsse);
+            // other error
+            throw new Exception(gsse.getMessage());
+        } catch (IOException ex) {
+            throw new Exception(ex.getMessage());
+        }
+    }
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java
new file mode 100644
index 000000000..bc989540d
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/spnego/SpnegoTokenGenerator.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * ====================================================================
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package org.asynchttpclient.providers.netty_4.spnego;
+
+import java.io.IOException;
+
+/**
+ * Abstract SPNEGO token generator. Implementations should take an Kerberos ticket and transform
+ * into a SPNEGO token.
+ * <p/>
+ * Implementations of this interface are expected to be thread-safe.
+ *
+ * @since 4.1
+ */
+public interface SpnegoTokenGenerator {
+
+    byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
+
+}
diff --git a/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java
new file mode 100644
index 000000000..74c2ec952
--- /dev/null
+++ b/providers/netty-4/src/main/java/org/asynchttpclient/providers/netty_4/util/CleanupChannelGroup.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * Copyright 2010 Bruno de Carvalho
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.asynchttpclient.providers.netty_4.util;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.group.ChannelGroupFuture;
+import io.netty.channel.group.DefaultChannelGroup;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
+ * supposed to be called once.
+ *
+ * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
+ */
+public class CleanupChannelGroup extends DefaultChannelGroup {
+
+    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
+
+    // internal vars --------------------------------------------------------------------------------------------------
+
+    private final AtomicBoolean closed;
+    private final ReentrantReadWriteLock lock;
+
+    // constructors ---------------------------------------------------------------------------------------------------
+
+    public CleanupChannelGroup() {
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    public CleanupChannelGroup(String name) {
+        super(name);
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    // DefaultChannelGroup --------------------------------------------------------------------------------------------
+
+    @Override
+    public ChannelGroupFuture close() {
+        this.lock.writeLock().lock();
+        try {
+            if (!this.closed.getAndSet(true)) {
+                // First time close() is called.
+                return super.close();
+            } else {
+                Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
+                logger.debug("CleanupChannelGroup Already closed");
+                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public boolean add(Channel channel) {
+        // Synchronization must occur to avoid add() and close() overlap (thus potentially leaving one channel open).
+        // This could also be done by synchronizing the method itself but using a read lock here (rather than a
+        // synchronized() block) allows multiple concurrent calls to add().
+        this.lock.readLock().lock();
+        try {
+            if (this.closed.get()) {
+                // Immediately close channel, as close() was already called.
+                channel.close();
+                return false;
+            }
+
+            return super.add(channel);
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
new file mode 100644
index 000000000..51739b168
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
+import static org.testng.Assert.assertEquals;
+
+import java.util.concurrent.Executors;
+
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
+
+public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
+
+    @Test
+    public void bossThreadPoolExecutor() throws Throwable {
+        NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
+        conf.setBossExecutorService(Executors.newSingleThreadExecutor());
+
+        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
+        AsyncHttpClient c = getAsyncHttpClient(cf);
+        try {
+            Response r = c.prepareGet(getTargetUrl()).execute().get();
+            assertEquals(r.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
new file mode 100644
index 000000000..41aea3c95
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.AsyncProvidersBasicTest;
+
+@Test
+public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    protected AsyncHttpProviderConfig getProviderConfig() {
+        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
+        config.addProperty("tcpNoDelay", true);
+        return config;
+    }
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderPipelineTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
similarity index 69%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderPipelineTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
index 7024c9c48..806c3a7ea 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderPipelineTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
@@ -11,8 +11,9 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
+import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProvider;
 import static org.testng.Assert.assertEquals;
 
 import java.util.concurrent.CountDownLatch;
@@ -25,15 +26,14 @@
 import org.jboss.netty.channel.SimpleChannelHandler;
 import org.jboss.netty.handler.codec.http.HttpMessage;
 import org.testng.Assert;
-import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.async.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
 
 public class NettyAsyncProviderPipelineTest extends AbstractBasicTest {
 
@@ -42,35 +42,37 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return new AsyncHttpClient(new CopyEncodingNettyAsyncHttpProvider(config), config);
     }
 
-    @Test(groups = {"standalone", "netty_provider"})
+    @Test(groups = { "standalone", "netty_provider" })
     public void asyncPipelineTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setCompressionEnabled(true).build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
-                } finally {
-                    l.countDown();
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            p.close();
         }
-        p.close();
     }
 
     private static class CopyEncodingNettyAsyncHttpProvider extends NettyAsyncHttpProvider {
         public CopyEncodingNettyAsyncHttpProvider(AsyncHttpClientConfig config) {
             super(config);
         }
+
         protected ChannelPipelineFactory createPlainPipelineFactory() {
             final ChannelPipelineFactory pipelineFactory = super.createPlainPipelineFactory();
             return new ChannelPipelineFactory() {
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
similarity index 91%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncResponseTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
index c49eee8dc..441048134 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncResponseTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
@@ -11,11 +11,13 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseHeaders;
+import org.asynchttpclient.providers.netty_4.ResponseStatus;
+import org.asynchttpclient.providers.netty_4.NettyResponse;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
 import org.testng.annotations.Test;
 
 import java.text.SimpleDateFormat;
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamHandlerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamHandlerTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
index 284ca9bd9..1c1bea893 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamHandlerTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AsyncStreamHandlerTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamHandlerTest;
 
 public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamLifecycleTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamLifecycleTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
index 169863f3f..9760aa429 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncStreamLifecycleTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AsyncStreamLifecycleTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamLifecycleTest;
 
 public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAuthTimeoutTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAuthTimeoutTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
index 567ee39dc..61a633e00 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAuthTimeoutTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
@@ -10,18 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AuthTimeoutTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AuthTimeoutTest;
 
 public class NettyAuthTimeoutTest extends AuthTimeoutTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicAuthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
similarity index 73%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicAuthTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
index 9f78d99d3..f8c7d3662 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicAuthTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
@@ -10,27 +10,28 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BasicAuthTest;
-import com.ning.http.client.async.ProviderUtil;
-import org.testng.annotations.Test;
+package org.asynchttpclient.providers.netty;
 
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeoutException;
 
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicAuthTest;
+
+@Test
 public class NettyBasicAuthTest extends BasicAuthTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Override
     @Test
     public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        super.redirectAndBasicAuthTest();    //To change body of overridden methods use File | Settings | File Templates.
+        super.redirectAndBasicAuthTest(); // To change body of overridden methods use File | Settings | File Templates.
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicHttpsTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicHttpsTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
index 665fa4601..5790fd96b 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBasicHttpsTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BasicHttpsTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicHttpsTest;
 
 public class NettyBasicHttpsTest extends BasicHttpsTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyChunkTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyChunkTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
index cce596998..e8dacd968 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyBodyChunkTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.BodyChunkTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyChunkTest;
 
 public class NettyBodyChunkTest extends BodyChunkTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
new file mode 100644
index 000000000..01e8daba4
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
+
+public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyByteBufferCapacityTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyByteBufferCapacityTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
index 7f52d7955..8cabb0c63 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyByteBufferCapacityTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ByteBufferCapacityTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ByteBufferCapacityTest;
 
 public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
new file mode 100644
index 000000000..7783e21d5
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
@@ -0,0 +1,12 @@
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ChunkingTest;
+
+public class NettyChunkingTest extends ChunkingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyComplexClientTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyComplexClientTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
index 934b82545..7cb83020d 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyComplexClientTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ComplexClientTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ComplexClientTest;
 
 public class NettyComplexClientTest extends ComplexClientTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyConnectionPoolTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
similarity index 63%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyConnectionPoolTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
index 97505a912..945761d5e 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyConnectionPoolTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
@@ -10,26 +10,26 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.async.ConnectionPoolTest;
-import com.ning.http.client.async.ProviderUtil;
-import org.jboss.netty.channel.Channel;
-
-import java.util.concurrent.TimeUnit;
+package org.asynchttpclient.providers.netty;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 
+import java.util.concurrent.TimeUnit;
+
+import org.jboss.netty.channel.Channel;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.async.ConnectionPoolTest;
+
 public class NettyConnectionPoolTest extends ConnectionPoolTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Override
@@ -57,22 +57,20 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertEquals(exception.getMessage(), "Too many connections -1");
+        } finally {
+            client.close();
         }
-        assertNotNull(exception);
-        assertEquals(exception.getMessage(), "Too many connections -1");
-        client.close();
     }
 
     @Override
@@ -100,20 +98,18 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
         }
-        assertNull(exception);
-        client.close();
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyDigestAuthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyDigestAuthTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
index 9cf9fa79d..205fb73a1 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyDigestAuthTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.DigestAuthTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.DigestAuthTest;
 
 public class NettyDigestAuthTest extends DigestAuthTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyEmptyBodyTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyEmptyBodyTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
index 9e1cd09d4..8cdbe19e6 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyEmptyBodyTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.EmptyBodyTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.EmptyBodyTest;
 
 public class NettyEmptyBodyTest extends EmptyBodyTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyErrorResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyErrorResponseTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
index 1836e8b5d..ee34de01f 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyErrorResponseTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ErrorResponseTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ErrorResponseTest;
 
 public class NettyErrorResponseTest extends ErrorResponseTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyExpect100ContinueTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyExpect100ContinueTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
index 9cb548555..ce9759922 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyExpect100ContinueTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.Expect100ContinueTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Expect100ContinueTest;
 
 public class NettyExpect100ContinueTest extends Expect100ContinueTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilePartLargeFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilePartLargeFileTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
index aef426f8f..8b9adcbd6 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilePartLargeFileTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.FilePartLargeFileTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FilePartLargeFileTest;
 
 public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilterTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilterTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
index 515862db8..d1c6fd0eb 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFilterTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.FilterTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FilterTest;
 
 public class NettyFilterTest extends FilterTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFollowingThreadTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFollowingThreadTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
index faa1d7cef..c3e2c8b75 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyFollowingThreadTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
@@ -10,18 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.FollowingThreadTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FollowingThreadTest;
 
 public class NettyFollowingThreadTest extends FollowingThreadTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
-
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHead302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHead302Test.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
index 4ab927e4f..8fc323e3b 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHead302Test.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.Head302Test;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Head302Test;
 
 public class NettyHead302Test extends Head302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHostnameVerifierTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHostnameVerifierTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
index fa52d4e2b..004a2eb43 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHostnameVerifierTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.HostnameVerifierTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.HostnameVerifierTest;
 
 public class NettyHostnameVerifierTest extends HostnameVerifierTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHttpToHttpsRedirectTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHttpToHttpsRedirectTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
index 6ccfbc22e..ec739b406 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyHttpToHttpsRedirectTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.HttpToHttpsRedirectTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.HttpToHttpsRedirectTest;
 
 public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyIdleStateHandlerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyIdleStateHandlerTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
index 04480e9c6..26dc2a2db 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyIdleStateHandlerTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.IdleStateHandlerTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.IdleStateHandlerTest;
 
 public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyInputStreamTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyInputStreamTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
index ea8dc48ac..5854ddc98 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyInputStreamTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.InputStreamTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.InputStreamTest;
 
 public class NettyInputStreamTest extends InputStreamTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyListenableFutureTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyListenableFutureTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
index 4e078caf7..723fc12d5 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyListenableFutureTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
@@ -10,18 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ListenableFutureTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ListenableFutureTest;
 
 public class NettyListenableFutureTest extends ListenableFutureTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxConnectionsInThreads.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
similarity index 73%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxConnectionsInThreads.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
index b9444c5b8..0e24c3d55 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxConnectionsInThreads.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
@@ -9,16 +9,15 @@
  *   http://www.apache.org/licenses/LICENSE-2.0.html
  * You may elect to redistribute this code under either of these licenses.
  *******************************************************************************/
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MaxConnectionsInThreads;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxConnectionsInThreads;
 
 public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxTotalConnectionTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxTotalConnectionTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
index 0fc74fb3f..15e0892a6 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMaxTotalConnectionTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MaxTotalConnectionTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxTotalConnectionTest;
 
 public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipartUploadTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
similarity index 75%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipartUploadTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
index ae77c2d31..fdbfb52d1 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipartUploadTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
@@ -10,12 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MultipartUploadTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MultipartUploadTest;
 
 /**
  * @author dominict
@@ -24,8 +23,7 @@
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
-
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipleHeaderTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipleHeaderTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
index 345ad73e0..2198b1b1f 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyMultipleHeaderTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.MultipleHeaderTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MultipleHeaderTest;
 
 public class NettyMultipleHeaderTest extends MultipleHeaderTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNoNullResponseTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNoNullResponseTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
index b1766aa48..d6b012226 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNoNullResponseTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.NoNullResponseTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NoNullResponseTest;
 
 public class NettyNoNullResponseTest extends NoNullResponseTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
new file mode 100644
index 000000000..50fca62df
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NonAsciiContentLengthTest;
+
+public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyParamEncodingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyParamEncodingTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
index 6bda57840..d633d3797 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyParamEncodingTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ParamEncodingTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ParamEncodingTest;
 
 public class NettyParamEncodingTest extends ParamEncodingTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestRelative302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestRelative302Test.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
index b9fbf6865..b0fabf1ef 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestRelative302Test.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PerRequestRelative302Test;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestRelative302Test;
 
 public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestTimeoutTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestTimeoutTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
index 236bb9002..637a7ec36 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPerRequestTimeoutTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PerRequestTimeoutTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestTimeoutTest;
 
 public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostRedirectGetTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostRedirectGetTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
index c414e5752..979c761bd 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostRedirectGetTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
@@ -11,18 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PostRedirectGetTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostRedirectGetTest;
 
 public class NettyPostRedirectGetTest extends PostRedirectGetTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostWithQSTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostWithQSTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
index caf7330c7..c244b89c0 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPostWithQSTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.PostWithQSTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostWithQSTest;
 
 public class NettyPostWithQSTest extends PostWithQSTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
new file mode 100644
index 000000000..499e0025c
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class NettyProviderUtil {
+
+    public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
+        // FIXME why do tests fail with this set up? Seems like we have a race condition
+        // if (config == null) {
+        // config = new AsyncHttpClientConfig.Builder().build();
+        // }
+        // return new AsyncHttpClient(new NettyAsyncHttpProvider(config), config);
+
+        if (config == null) {
+            return new AsyncHttpClient();
+        } else {
+            return new AsyncHttpClient(config);
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
index 3f17d942b..7c381c111 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
@@ -10,20 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.ProxyTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTest;
 
 public class NettyProxyTest extends ProxyTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
-
-
-
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTunnellingTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTunnellingTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
index ebbf5a77c..a862e9ee8 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyProxyTunnellingTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.ProxyTunnellingTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTunnellingTest;
 
 public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPutLargeFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPutLargeFileTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
index e452dbfe9..550847c06 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyPutLargeFileTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.PutLargeFileTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PutLargeFileTest;
 
 public class NettyPutLargeFileTest extends PutLargeFileTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyQueryParametersTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyQueryParametersTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
index c253dc0ee..7a38145ef 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyQueryParametersTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.QueryParametersTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.QueryParametersTest;
 
 public class NettyQueryParametersTest extends QueryParametersTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRC10KTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRC10KTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
index fa16414f4..17f26efbb 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRC10KTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.RC10KTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RC10KTest;
 
 public class NettyRC10KTest extends RC10KTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRedirectConnectionUsageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
similarity index 65%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRedirectConnectionUsageTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
index 411669af8..33810c3d3 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRedirectConnectionUsageTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
@@ -10,26 +10,25 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.RedirectConnectionUsageTest;
+import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.RedirectConnectionUsageTest;
 
 public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Override
     protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = 
-                new NettyAsyncHttpProviderConfig();
+        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
         if (System.getProperty("blockingio") != null) {
-            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+            config.setUseBlockingIO(true);
         }
         return config;
     }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRelative302Test.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRelative302Test.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
index e40a064ac..22fca88ad 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRelative302Test.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
@@ -10,17 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.Relative302Test;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Relative302Test;
 
 public class NettyRelative302Test extends Relative302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRemoteSiteTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
similarity index 72%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRemoteSiteTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
index f1c3928d3..94c6f0d7a 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRemoteSiteTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
@@ -13,18 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.RemoteSiteTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RemoteSiteTest;
 
 public class NettyRemoteSiteTest extends RemoteSiteTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
-
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
similarity index 52%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
index 066990482..f0685b456 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
@@ -10,27 +10,34 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
+
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-import com.ning.http.client.*;
-import com.ning.http.client.async.AbstractBasicTest;
-import com.ning.http.client.async.ProviderUtil;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.*;
-
-import static org.testng.Assert.*;
-import static org.testng.Assert.fail;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
 
 public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
     private static final String MSG = "Enough is enough.";
@@ -38,7 +45,7 @@
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Override
@@ -69,68 +76,61 @@ public void run() {
         }
     }
 
-    @Test(groups = {"standalone", "netty_provider"})
+    @Test(groups = { "standalone", "netty_provider" })
     public void testRequestTimeout() throws IOException {
         final Semaphore requestThrottle = new Semaphore(1);
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setCompressionEnabled(true)
-                .setAllowPoolingConnection(true)
-                .setMaximumConnectionsTotal(1).build());
-
-        final CountDownLatch latch = new CountDownLatch(2);
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
 
-        final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
-        for(int i=0;i<2;i++) {
-            final int threadNumber = i;
-            new Thread(new Runnable() {
+            final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
+            for (int i = 0; i < 2; i++) {
+                new Thread(new Runnable() {
 
-                public void run() {
-                    try {
-                        requestThrottle.acquire();
-                        PerRequestConfig requestConfig = new PerRequestConfig();
-                        requestConfig.setRequestTimeoutInMs(SLEEPTIME_MS/2);
-                        Future<Response> responseFuture = null;
+                    public void run() {
                         try {
-                             responseFuture =
-                                    client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute(new AsyncCompletionHandler<Response>() {
-
-                                        @Override
-                                        public Response onCompleted(Response response) throws Exception {
-                                            requestThrottle.release();
-                                            return response;
-                                        }
-
-                                        @Override
-                                        public void onThrowable(Throwable t) {
-                                            requestThrottle.release();
-                                        }
-                                    });
-                        } catch(Exception e) {
-                            tooManyConnections.add(e);
+                            requestThrottle.acquire();
+                            Future<Response> responseFuture = null;
+                            try {
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2).execute(new AsyncCompletionHandler<Response>() {
+
+                                    @Override
+                                    public Response onCompleted(Response response) throws Exception {
+                                        requestThrottle.release();
+                                        return response;
+                                    }
+
+                                    @Override
+                                    public void onThrowable(Throwable t) {
+                                        requestThrottle.release();
+                                    }
+                                });
+                            } catch (Exception e) {
+                                tooManyConnections.add(e);
+                            }
+
+                            if (responseFuture != null)
+                                responseFuture.get();
+                        } catch (Exception e) {
+                        } finally {
+                            latch.countDown();
                         }
 
-                        if(responseFuture!=null)
-                            responseFuture.get();
-                    } catch (Exception e) {
-                    } finally {
-                        latch.countDown();
                     }
+                }).start();
 
-                }
-            }).start();
+            }
 
+            try {
+                latch.await(30, TimeUnit.SECONDS);
+            } catch (Exception e) {
+                fail("failed to wait for requests to complete");
+            }
 
+            assertTrue(tooManyConnections.size() == 0, "Should not have any connection errors where too many connections have been attempted");
+        } finally {
+            client.close();
         }
-
-        try {
-            latch.await(30,TimeUnit.SECONDS);
-        } catch (Exception e) {
-            fail("failed to wait for requests to complete");
-        }
-
-        assertTrue(tooManyConnections.size()==0,"Should not have any connection errors where too many connections have been attempted");
-
-        client.close();
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRetryRequestTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
similarity index 72%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRetryRequestTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
index 4ce24d43b..d00acde3c 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRetryRequestTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
@@ -14,16 +14,15 @@
  * under the License.
  */
 
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.RetryRequestTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RetryRequestTest;
 
 public class NettyRetryRequestTest extends RetryRequestTest{
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettySimpleAsyncHttpClientTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
similarity index 77%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettySimpleAsyncHttpClientTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
index 2173bc046..27834862d 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettySimpleAsyncHttpClientTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.SimpleAsyncHttpClientTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
 
 public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
 
     /**
-     * Not Used with {@link com.ning.http.client.SimpleAsyncHttpClient}
+     * Not Used with {@link org.asynchttpclient.SimpleAsyncHttpClient}
      * @param config
      * @return
      */
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyTransferListenerTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyTransferListenerTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
index e1e0361a2..504607b65 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyTransferListenerTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.TransferListenerTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.TransferListenerTest;
 
 public class NettyTransferListenerTest extends TransferListenerTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyWebDavBasicTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyWebDavBasicTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
index 16825ffc0..e3f938171 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyWebDavBasicTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.WebDavBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.WebDavBasicTest;
 
 public class NettyWebDavBasicTest extends WebDavBasicTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyZeroCopyFileTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
similarity index 74%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyZeroCopyFileTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
index bd7a593b8..3e98117d0 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyZeroCopyFileTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
@@ -10,16 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.ZeroCopyFileTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ZeroCopyFileTest;
 
 public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/RetryNonBlockingIssue.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
similarity index 94%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/RetryNonBlockingIssue.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
index 1f58881fb..0b781e7c6 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/RetryNonBlockingIssue.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
@@ -10,14 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.providers.netty.NettyAsyncHttpProviderConfig;
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.providers.netty_4.NettyAsyncHttpProviderConfig;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.nio.SelectChannelConnector;
@@ -112,7 +113,7 @@ public void stop() {
         builder.addQueryParameter("maxRequests", "" + requests);
         builder.addQueryParameter("id", id);
         builder.setUrl(servletEndpointUri.toString());
-        com.ning.http.client.Request r = builder.build();
+        Request r = builder.build();
         return fetcher.executeRequest(r);
 
     }
@@ -185,7 +186,7 @@ public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedEx
 
             NettyAsyncHttpProviderConfig config = new
                     NettyAsyncHttpProviderConfig();
-            config.addProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT, "true");
+            config.setAsyncConnect(true);
 
             bc.setAsyncHttpClientProviderConfig(config);
             c = new AsyncHttpClient(bc.build());
@@ -230,7 +231,7 @@ public void testRetryBlocking() throws IOException, InterruptedException,
 
             NettyAsyncHttpProviderConfig config = new
                     NettyAsyncHttpProviderConfig();
-            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+            config.setUseBlockingIO(true);
 
             bc.setAsyncHttpClientProviderConfig(config);
             c = new AsyncHttpClient(bc.build());
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
new file mode 100644
index 000000000..95b8d4cd5
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.ByteMessageTest;
+
+public class NettyByteMessageTest extends ByteMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
new file mode 100644
index 000000000..39feea565
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.netty.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
+
+public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyRedirectTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
similarity index 69%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyRedirectTest.java
rename to providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
index 16bde5818..63b875480 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyRedirectTest.java
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
@@ -10,18 +10,19 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty.websocket;
+package org.asynchttpclient.providers.netty.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.websocket.RedirectTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.RedirectTest;
 
 public class NettyRedirectTest extends RedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
diff --git a/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
new file mode 100644
index 000000000..7543bb701
--- /dev/null
+++ b/providers/netty-4/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.TextMessageTest;
+
+public class NettyTextMessageTest extends TextMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty-4/src/test/resources/300k.png b/providers/netty-4/src/test/resources/300k.png
new file mode 100644
index 000000000..bff4a8598
Binary files /dev/null and b/providers/netty-4/src/test/resources/300k.png differ
diff --git a/providers/netty-4/src/test/resources/SimpleTextFile.txt b/providers/netty-4/src/test/resources/SimpleTextFile.txt
new file mode 100644
index 000000000..088788f82
--- /dev/null
+++ b/providers/netty-4/src/test/resources/SimpleTextFile.txt
@@ -0,0 +1 @@
+This is a simple test file
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/client.keystore b/providers/netty-4/src/test/resources/client.keystore
new file mode 100644
index 000000000..eaf8339f4
Binary files /dev/null and b/providers/netty-4/src/test/resources/client.keystore differ
diff --git a/providers/netty-4/src/test/resources/gzip.txt.gz b/providers/netty-4/src/test/resources/gzip.txt.gz
new file mode 100644
index 000000000..80aeb98d2
Binary files /dev/null and b/providers/netty-4/src/test/resources/gzip.txt.gz differ
diff --git a/providers/netty-4/src/test/resources/logback-test.xml b/providers/netty-4/src/test/resources/logback-test.xml
new file mode 100644
index 000000000..4acf27871
--- /dev/null
+++ b/providers/netty-4/src/test/resources/logback-test.xml
@@ -0,0 +1,13 @@
+<configuration>
+    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
+        <layout class="ch.qos.logback.classic.PatternLayout">
+            <Pattern>%d [%thread] %level %logger - %m%n</Pattern>
+        </layout>
+    </appender>
+
+    <logger name="org.eclipse" level="INFO"/>
+
+    <root level="debug">
+        <appender-ref ref="CONSOLE"/>
+    </root>
+</configuration>
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/realm.properties b/providers/netty-4/src/test/resources/realm.properties
new file mode 100644
index 000000000..bc9faad66
--- /dev/null
+++ b/providers/netty-4/src/test/resources/realm.properties
@@ -0,0 +1 @@
+user=admin, admin
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/ssltest-cacerts.jks b/providers/netty-4/src/test/resources/ssltest-cacerts.jks
new file mode 100644
index 000000000..9c1ffbe49
Binary files /dev/null and b/providers/netty-4/src/test/resources/ssltest-cacerts.jks differ
diff --git a/providers/netty-4/src/test/resources/ssltest-keystore.jks b/providers/netty-4/src/test/resources/ssltest-keystore.jks
new file mode 100644
index 000000000..a95b7c5f4
Binary files /dev/null and b/providers/netty-4/src/test/resources/ssltest-keystore.jks differ
diff --git a/providers/netty-4/src/test/resources/textfile.txt b/providers/netty-4/src/test/resources/textfile.txt
new file mode 100644
index 000000000..87daee60a
--- /dev/null
+++ b/providers/netty-4/src/test/resources/textfile.txt
@@ -0,0 +1 @@
+filecontent: hello
\ No newline at end of file
diff --git a/providers/netty-4/src/test/resources/textfile2.txt b/providers/netty-4/src/test/resources/textfile2.txt
new file mode 100644
index 000000000..6a91fe609
--- /dev/null
+++ b/providers/netty-4/src/test/resources/textfile2.txt
@@ -0,0 +1 @@
+filecontent: hello2
\ No newline at end of file
diff --git a/providers/netty/pom.xml b/providers/netty/pom.xml
index eda60306e..0fcfd6850 100644
--- a/providers/netty/pom.xml
+++ b/providers/netty/pom.xml
@@ -2,16 +2,13 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
-        <groupId>com.ning</groupId>
+        <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-providers-parent</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
+        <version>2.0.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
     <artifactId>async-http-client-netty-provider</artifactId>
     <name>Asynchronous Http Client Netty Provider</name>
-    <version>1.8.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
     <description>
         The Async Http Client Netty Provider.
     </description>
@@ -20,25 +17,7 @@
         <dependency>
             <groupId>io.netty</groupId>
             <artifactId>netty</artifactId>
-            <version>3.4.4.Final</version>
-            <exclusions>
-                <exclusion>
-                    <groupId>javax.servlet</groupId>
-                    <artifactId>servlet-api</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>commons-logging</groupId>
-                    <artifactId>commons-logging</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-api</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>log4j</groupId>
-                    <artifactId>log4j</artifactId>
-                </exclusion>
-            </exclusions>
+            <version>3.6.6.Final</version>
         </dependency>
     </dependencies>
 
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderConfig.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderConfig.java
deleted file mode 100644
index 7ecbb5e97..000000000
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpProviderConfig;
-
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
- */
-public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
-
-    /**
-     * Use Netty's blocking IO stategy.
-     */
-    public final static String USE_BLOCKING_IO = "useBlockingIO";
-
-    /**
-     * Use direct {@link java.nio.ByteBuffer}
-     */
-    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
-
-    /**
-     * Execute the connect operation asynchronously.
-     */
-    public final static String EXECUTE_ASYNC_CONNECT = "asyncConnect";
-
-    /**
-     * Allow nested request from any {@link com.ning.http.client.AsyncHandler}
-     */
-    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
-
-    /**
-     * Allow configuring the Netty's boss executor service.
-     */
-    public final static String BOSS_EXECUTOR_SERVICE = "bossExecutorService";
-    
-    /**
-     * Allow configuring the Netty's socket channel factory.
-     */
-    public final static String SOCKET_CHANNEL_FACTORY = "socketChannelFactory";
-
-    /**
-     * See {@link java.net.Socket#setReuseAddress(boolean)}
-     */
-    public final static String REUSE_ADDRESS = "reuseAddress";
-
-    private final ConcurrentHashMap<String, Object> properties = new ConcurrentHashMap<String, Object>();
-
-    public NettyAsyncHttpProviderConfig() {
-        properties.put(REUSE_ADDRESS, "false");
-    }
-
-    /**
-     * Add a property that will be used when the AsyncHttpClient initialize its {@link com.ning.http.client.AsyncHttpProvider}
-     *
-     * @param name  the name of the property
-     * @param value the value of the property
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
-        properties.put(name, value);
-        return this;
-    }
-
-    /**
-     * Return the value associated with the property's name
-     *
-     * @param name
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public Object getProperty(String name) {
-        return properties.get(name);
-    }
-
-    /**
-     * Remove the value associated with the property's name
-     *
-     * @param name
-     * @return true if removed
-     */
-    public Object removeProperty(String name) {
-        return properties.remove(name);
-    }
-
-    /**
-     * Return the curent entry set.
-     *
-     * @return a the curent entry set.
-     */
-    public Set<Map.Entry<String, Object>> propertiesSet() {
-        return properties.entrySet();
-    }
-}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java
similarity index 97%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java
index 102f6d84f..1c9e49776 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyChunkedInput.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.Body;
+import org.asynchttpclient.Body;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.handler.stream.ChunkedInput;
 
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyFileRegion.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java
similarity index 94%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyFileRegion.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java
index 9679ba43f..68a271a4d 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyFileRegion.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/BodyFileRegion.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.RandomAccessBody;
+import org.asynchttpclient.RandomAccessBody;
 import org.jboss.netty.channel.FileRegion;
 
 import java.io.IOException;
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java
new file mode 100644
index 000000000..2c121c46b
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/FeedableBodyGenerator.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+
+/**
+ * {@link BodyGenerator} which may return just part of the payload at the time
+ * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
+ * for finishing payload transferring asynchronously.
+ */
+public class FeedableBodyGenerator implements BodyGenerator {
+    private final static byte[] END_PADDING = "\r\n".getBytes();
+    private final static byte[] ZERO = "0".getBytes();
+    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
+    private final AtomicInteger queueSize = new AtomicInteger();
+    private FeedListener listener;
+
+    @Override
+    public Body createBody() throws IOException {
+        return new PushBody();
+    }
+
+    public void feed(final ByteBuffer buffer, final boolean isLast) throws IOException {
+        queue.offer(new BodyPart(buffer, isLast));
+        queueSize.incrementAndGet();
+        if (listener != null) {
+            listener.onContentAdded();
+        }
+    }
+
+    public static interface FeedListener {
+        public void onContentAdded();
+    }
+
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+
+    private final class PushBody implements Body {
+        private final int ONGOING = 0;
+        private final int CLOSING = 1;
+        private final int FINISHED = 2;
+
+        private int finishState = 0;
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+
+        @Override
+        public long read(final ByteBuffer buffer) throws IOException {
+            BodyPart nextPart = queue.peek();
+            if (nextPart == null) {
+                // Nothing in the queue
+                switch (finishState) {
+                case ONGOING:
+                    return 0;
+                case CLOSING:
+                    buffer.put(ZERO);
+                    buffer.put(END_PADDING);
+                    finishState = FINISHED;
+                    return buffer.position();
+                case FINISHED:
+                    buffer.put(END_PADDING);
+                    return -1;
+                }
+            }
+            int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
+            int size = Math.min(nextPart.buffer.remaining(), capacity);
+            buffer.put(Integer.toHexString(size).getBytes());
+            buffer.put(END_PADDING);
+            for (int i=0; i < size; i++) {
+              buffer.put(nextPart.buffer.get());
+            }
+            buffer.put(END_PADDING);
+            if (!nextPart.buffer.hasRemaining()) {
+                if (nextPart.isLast) {
+                    finishState = CLOSING;
+                }
+                queue.remove();
+            }
+            return size;
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+
+    }
+
+    private final static class BodyPart {
+        private final boolean isLast;
+        private final ByteBuffer buffer;
+
+        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
+            this.buffer = buffer;
+            this.isLast = isLast;
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
new file mode 100644
index 000000000..f2bdb14c1
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
@@ -0,0 +1,2403 @@
+/*
+ * Copyright 2010-2013 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.STATE;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.Body;
+import org.asynchttpclient.BodyGenerator;
+import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.MaxRedirectException;
+import org.asynchttpclient.ProgressAsyncHandler;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.RandomAccessBody;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.multipart.MultipartBody;
+import org.asynchttpclient.multipart.MultipartRequestEntity;
+import org.asynchttpclient.ntlm.NTLMEngine;
+import org.asynchttpclient.ntlm.NTLMEngineException;
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieEncoder;
+import org.asynchttpclient.providers.netty.FeedableBodyGenerator.FeedListener;
+import org.asynchttpclient.providers.netty.spnego.SpnegoEngine;
+import org.asynchttpclient.providers.netty.util.CleanupChannelGroup;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.ProxyUtils;
+import org.asynchttpclient.util.SslUtils;
+import org.asynchttpclient.util.UTF8UrlEncoder;
+import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBufferOutputStream;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureProgressListener;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelPipelineFactory;
+import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.DefaultChannelFuture;
+import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.FileRegion;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.oio.OioClientSocketChannelFactory;
+import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.HttpClientCodec;
+import org.jboss.netty.handler.codec.http.HttpContentCompressor;
+import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.jboss.netty.handler.stream.ChunkedFile;
+import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.net.ssl.SSLEngine;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import static org.asynchttpclient.util.MiscUtil.isNonEmpty;
+import static org.jboss.netty.channel.Channels.pipeline;
+
+public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
+    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
+    private final static String HTTP_HANDLER = "httpHandler";
+    protected final static String SSL_HANDLER = "sslHandler";
+    private final static String HTTPS = "https";
+    private final static String HTTP = "http";
+    private static final String WEBSOCKET = "ws";
+    private static final String WEBSOCKET_SSL = "wss";
+
+    private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
+    private final static Charset UTF8 = Charset.forName("UTF-8");
+
+    private final ClientBootstrap plainBootstrap;
+    private final ClientBootstrap secureBootstrap;
+    private final ClientBootstrap webSocketBootstrap;
+    private final ClientBootstrap secureWebSocketBootstrap;
+    private final static int MAX_BUFFERED_BYTES = 8192;
+    private final AsyncHttpClientConfig config;
+    private final AtomicBoolean isClose = new AtomicBoolean(false);
+    private final ClientSocketChannelFactory socketChannelFactory;
+    private final boolean allowReleaseSocketChannelFactory;
+
+    private final ChannelGroup openChannels = new CleanupChannelGroup("asyncHttpClient") {
+        @Override
+        public boolean remove(Object o) {
+            boolean removed = super.remove(o);
+            if (removed && trackConnections) {
+                freeConnections.release();
+            }
+            return removed;
+        }
+    };
+    private final ConnectionsPool<String, Channel> connectionsPool;
+    private Semaphore freeConnections = null;
+    private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
+    private boolean executeConnectAsync = true;
+    public static final ThreadLocal<Boolean> IN_IO_THREAD = new ThreadLocalBoolean();
+    private final boolean trackConnections;
+    private final boolean useRawUrl;
+    private final static NTLMEngine ntlmEngine = new NTLMEngine();
+    private static SpnegoEngine spnegoEngine = null;
+    private final Protocol httpProtocol = new HttpProtocol();
+    private final Protocol webSocketProtocol = new WebSocketProtocol();
+
+    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
+
+        if (config.getAsyncHttpProviderConfig() != null && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
+            asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
+        } else {
+            asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
+        }
+
+        if (asyncHttpProviderConfig.isUseBlockingIO()) {
+            socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
+            this.allowReleaseSocketChannelFactory = true;
+        } else {
+            // check if external NioClientSocketChannelFactory is defined
+            NioClientSocketChannelFactory scf = asyncHttpProviderConfig.getSocketChannelFactory();
+            if (scf != null) {
+                this.socketChannelFactory = scf;
+
+                // cannot allow releasing shared channel factory
+                this.allowReleaseSocketChannelFactory = false;
+            } else {
+                ExecutorService e = asyncHttpProviderConfig.getBossExecutorService();
+                if (e == null) {
+                    e = Executors.newCachedThreadPool();
+                }
+                int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
+                log.debug("Number of application's worker threads is {}", numWorkers);
+                socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
+                this.allowReleaseSocketChannelFactory = true;
+            }
+        }
+        plainBootstrap = new ClientBootstrap(socketChannelFactory);
+        secureBootstrap = new ClientBootstrap(socketChannelFactory);
+        webSocketBootstrap = new ClientBootstrap(socketChannelFactory);
+        secureWebSocketBootstrap = new ClientBootstrap(socketChannelFactory);
+        configureNetty();
+
+        this.config = config;
+
+        // This is dangerous as we can't catch a wrong typed ConnectionsPool
+        ConnectionsPool<String, Channel> cp = (ConnectionsPool<String, Channel>) config.getConnectionsPool();
+        if (cp == null && config.getAllowPoolingConnection()) {
+            cp = new NettyConnectionsPool(this);
+        } else if (cp == null) {
+            cp = new NonConnectionsPool();
+        }
+        this.connectionsPool = cp;
+
+        if (config.getMaxTotalConnections() != -1) {
+            trackConnections = true;
+            freeConnections = new Semaphore(config.getMaxTotalConnections());
+        } else {
+            trackConnections = false;
+        }
+
+        useRawUrl = config.isUseRawUrl();
+    }
+
+    @Override
+    public String toString() {
+        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s", config.getMaxTotalConnections() - freeConnections.availablePermits(), openChannels.toString(), connectionsPool.toString());
+    }
+
+    void configureNetty() {
+        if (asyncHttpProviderConfig != null) {
+            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
+                String key = entry.getKey();
+                Object value = entry.getValue();
+                plainBootstrap.setOption(key, value);
+                webSocketBootstrap.setOption(key, value);
+                secureBootstrap.setOption(key, value);
+                secureWebSocketBootstrap.setOption(key, value);
+            }
+        }
+
+        plainBootstrap.setPipelineFactory(createPlainPipelineFactory());
+        DefaultChannelFuture.setUseDeadLockChecker(false);
+
+        if (asyncHttpProviderConfig != null) {
+            executeConnectAsync = config.isAsyncConnectMode();
+            if (!executeConnectAsync) {
+                DefaultChannelFuture.setUseDeadLockChecker(true);
+            }
+        }
+
+        webSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+                pipeline.addLast("http-decoder", new HttpResponseDecoder());
+                pipeline.addLast("http-encoder", new HttpRequestEncoder());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        });
+    }
+
+    protected HttpClientCodec newHttpClientCodec() {
+        if (asyncHttpProviderConfig != null) {
+            return new HttpClientCodec(asyncHttpProviderConfig.getMaxInitialLineLength(), asyncHttpProviderConfig.getMaxHeaderSize(), asyncHttpProviderConfig.getMaxChunkSize(), false);
+
+        } else {
+            return new HttpClientCodec();
+        }
+    }
+
+    protected ChannelPipelineFactory createPlainPipelineFactory() {
+        return new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
+
+                if (config.getRequestCompressionLevel() > 0) {
+                    pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
+                }
+
+                if (config.isCompressionEnabled()) {
+                    pipeline.addLast("inflater", new HttpContentDecompressor());
+                }
+                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        };
+    }
+
+    void constructSSLPipeline(final NettyConnectListener<?> cl) {
+
+        secureBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                try {
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                } catch (Throwable ex) {
+                    abort(cl.future(), ex);
+                }
+
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
+
+                if (config.isCompressionEnabled()) {
+                    pipeline.addLast("inflater", new HttpContentDecompressor());
+                }
+                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        });
+
+        secureWebSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                try {
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                } catch (Throwable ex) {
+                    abort(cl.future(), ex);
+                }
+
+                pipeline.addLast("http-decoder", new HttpResponseDecoder());
+                pipeline.addLast("http-encoder", new HttpRequestEncoder());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+
+                return pipeline;
+            }
+        });
+    }
+
+    private Channel lookupInCache(URI uri, ConnectionPoolKeyStrategy connectionPoolKeyStrategy) {
+        final Channel channel = connectionsPool.poll(connectionPoolKeyStrategy.getKey(uri));
+
+        if (channel != null) {
+            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+
+            try {
+                // Always make sure the channel who got cached support the proper protocol. It could
+                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
+                // https.
+                return verifyChannelPipeline(channel, uri.getScheme());
+            } catch (Exception ex) {
+                log.debug(ex.getMessage(), ex);
+            }
+        }
+        return null;
+    }
+
+    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
+        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
+        if (sslEngine == null) {
+            sslEngine = SslUtils.getSSLEngine();
+        }
+        return sslEngine;
+    }
+
+    private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
+
+        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+            channel.getPipeline().remove(SSL_HANDLER);
+        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+            return channel;
+        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
+            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+        }
+        return channel;
+    }
+
+    protected final <T> void writeRequest(final Channel channel, final AsyncHttpClientConfig config, final NettyResponseFuture<T> future, final HttpRequest nettyRequest) {
+        try {
+            /**
+             * If the channel is dead because it was pooled and the remote server decided to close it, we just let it go and the closeChannel do it's work.
+             */
+            if (!channel.isOpen() || !channel.isConnected()) {
+                return;
+            }
+
+            Body body = null;
+            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+                BodyGenerator bg = future.getRequest().getBodyGenerator();
+                if (bg != null) {
+                    // Netty issue with chunking.
+                    if (InputStreamBodyGenerator.class.isAssignableFrom(bg.getClass())) {
+                        InputStreamBodyGenerator.class.cast(bg).patchNettyChunkingIssue(true);
+                    }
+
+                    try {
+                        body = bg.createBody();
+                    } catch (IOException ex) {
+                        throw new IllegalStateException(ex);
+                    }
+                    long length = body.getContentLength();
+                    if (length >= 0) {
+                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, length);
+                    } else {
+                        nettyRequest.setHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+                    }
+                } else {
+                    body = null;
+                }
+            }
+
+            if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
+
+                FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+                for (String s : future.getNettyRequest().getHeaderNames()) {
+                    for (String header : future.getNettyRequest().getHeaders(s)) {
+                        h.add(s, header);
+                    }
+                }
+
+                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
+            }
+
+            // Leave it to true.
+            if (future.getAndSetWriteHeaders(true)) {
+                try {
+                    channel.write(nettyRequest).addListener(new ProgressListener(true, future.getAsyncHandler(), future));
+                } catch (Throwable cause) {
+                    log.debug(cause.getMessage(), cause);
+                    try {
+                        channel.close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                }
+            }
+
+            if (future.getAndSetWriteBody(true)) {
+                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+
+                    if (future.getRequest().getFile() != null) {
+                        final File file = future.getRequest().getFile();
+                        long fileLength = 0;
+                        final RandomAccessFile raf = new RandomAccessFile(file, "r");
+
+                        try {
+                            fileLength = raf.length();
+
+                            ChannelFuture writeFuture;
+                            if (channel.getPipeline().get(SslHandler.class) != null) {
+                                writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
+                            } else {
+                                final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
+                                writeFuture = channel.write(region);
+                            }
+                            writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
+                                public void operationComplete(ChannelFuture cf) {
+                                    try {
+                                        raf.close();
+                                    } catch (IOException e) {
+                                        log.warn("Failed to close request body: {}", e.getMessage(), e);
+                                    }
+                                    super.operationComplete(cf);
+                                }
+                            });
+                        } catch (IOException ex) {
+                            if (raf != null) {
+                                try {
+                                    raf.close();
+                                } catch (IOException e) {
+                                }
+                            }
+                            throw ex;
+                        }
+                    } else if (body != null || future.getRequest().getParts() != null) {
+                        /**
+                         * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
+                         */
+                        if (future.getRequest().getParts() != null) {
+                            String contentType = future.getNettyRequest().getHeader("Content-Type");
+                            String length = future.getNettyRequest().getHeader("Content-Length");
+                            body = new MultipartBody(future.getRequest().getParts(), contentType, length);
+                        }
+
+                        ChannelFuture writeFuture;
+                        if (channel.getPipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
+                            BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
+                            writeFuture = channel.write(bodyFileRegion);
+                        } else {
+                            BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
+                            BodyGenerator bg = future.getRequest().getBodyGenerator();
+                            if (bg instanceof FeedableBodyGenerator) {
+                                ((FeedableBodyGenerator) bg).setListener(new FeedListener() {
+                                    @Override
+                                    public void onContentAdded() {
+                                        channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                                    }
+                                });
+                            }
+                            writeFuture = channel.write(bodyChunkedInput);
+                        }
+
+                        final Body b = body;
+                        writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
+                            public void operationComplete(ChannelFuture cf) {
+                                try {
+                                    b.close();
+                                } catch (IOException e) {
+                                    log.warn("Failed to close request body: {}", e.getMessage(), e);
+                                }
+                                super.operationComplete(cf);
+                            }
+                        });
+                    }
+                }
+            }
+        } catch (Throwable ioe) {
+            try {
+                channel.close();
+            } catch (RuntimeException ex) {
+                log.debug(ex.getMessage(), ex);
+            }
+        }
+
+        try {
+            future.touch();
+            int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, future.getRequest());
+            int schedulePeriod = requestTimeout != -1 ? (config.getIdleConnectionTimeoutInMs() != -1 ? Math.min(requestTimeout, config.getIdleConnectionTimeoutInMs()) : requestTimeout) : config.getIdleConnectionTimeoutInMs();
+
+            if (schedulePeriod != -1 && !future.isDone() && !future.isCancelled()) {
+                ReaperFuture reaperFuture = new ReaperFuture(future);
+                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, schedulePeriod, TimeUnit.MILLISECONDS);
+                reaperFuture.setScheduledFuture(scheduledFuture);
+                future.setReaperFuture(reaperFuture);
+            }
+        } catch (RejectedExecutionException ex) {
+            abort(future, ex);
+        }
+
+    }
+
+    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri, boolean allowConnect, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
+
+        String method = request.getMethod();
+        if (allowConnect && proxyServer != null && isSecure(uri)) {
+            method = HttpMethod.CONNECT.toString();
+        }
+        return construct(config, request, new HttpMethod(method), uri, buffer, proxyServer);
+    }
+
+    private static SpnegoEngine getSpnegoEngine() {
+        if (spnegoEngine == null)
+            spnegoEngine = new SpnegoEngine();
+        return spnegoEngine;
+    }
+
+    private static HttpRequest construct(AsyncHttpClientConfig config, Request request, HttpMethod m, URI uri, ChannelBuffer buffer, ProxyServer proxyServer) throws IOException {
+
+        String host = null;
+        boolean webSocket = isWebSocket(uri);
+
+        if (request.getVirtualHost() != null) {
+            host = request.getVirtualHost();
+        } else {
+            AsyncHttpProviderUtils.getHost(uri);
+    	}
+
+        HttpRequest nettyRequest;
+        if (m.equals(HttpMethod.CONNECT)) {
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
+        } else {
+            String path = null;
+            if (proxyServer != null && !(isSecure(uri) && config.isUseRelativeURIsWithSSLProxies()))
+                path = uri.toString();
+            else if (uri.getRawQuery() != null)
+                path = uri.getRawPath() + "?" + uri.getRawQuery();
+            else
+                path = uri.getRawPath();
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path);
+        }
+
+        if (webSocket) {
+            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
+            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
+            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
+            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
+            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
+        }
+
+        if (host != null) {
+            if (request.getVirtualHost() != null || uri.getPort() == -1) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+            }
+        } else {
+            host = "127.0.0.1";
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            for (Entry<String, List<String>> header : request.getHeaders()) {
+                String name = header.getKey();
+                if (!HttpHeaders.Names.HOST.equalsIgnoreCase(name)) {
+                    for (String value : header.getValue()) {
+                        nettyRequest.addHeader(name, value);
+                    }
+                }
+            }
+
+            if (config.isCompressionEnabled()) {
+                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+            }
+        } else {
+            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+            if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM")) {
+                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
+            }
+        }
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+
+            String domain = realm.getNtlmDomain();
+            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
+                domain = proxyServer.getNtlmDomain();
+            }
+
+            String authHost = realm.getNtlmHost();
+            if (proxyServer != null && proxyServer.getHost() != null) {
+                host = proxyServer.getHost();
+            }
+
+            switch (realm.getAuthScheme()) {
+            case BASIC:
+                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(realm));
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce())) {
+                    try {
+                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, AuthenticatorUtils.computeDigestAuthentication(realm));
+                    } catch (NoSuchAlgorithmException e) {
+                        throw new SecurityException(e);
+                    }
+                }
+                break;
+            case NTLM:
+                try {
+                    String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
+                } catch (NTLMEngineException e) {
+                    IOException ie = new IOException();
+                    ie.initCause(e);
+                    throw ie;
+                }
+                break;
+            case KERBEROS:
+            case SPNEGO:
+                String challengeHeader = null;
+                String server = proxyServer == null ? host : proxyServer.getHost();
+                try {
+                    challengeHeader = getSpnegoEngine().generateToken(server);
+                } catch (Throwable e) {
+                    IOException ie = new IOException();
+                    ie.initCause(e);
+                    throw ie;
+                }
+                nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+                break;
+            case NONE:
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication " + realm);
+            }
+        }
+
+        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
+            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, AsyncHttpProviderUtils.keepAliveHeaderValue(config));
+        }
+
+        if (proxyServer != null) {
+            if (!request.getHeaders().containsKey("Proxy-Connection")) {
+                nettyRequest.setHeader("Proxy-Connection", AsyncHttpProviderUtils.keepAliveHeaderValue(config));
+            }
+
+            if (proxyServer.getPrincipal() != null) {
+                if (isNonEmpty(proxyServer.getNtlmDomain())) {
+
+                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+                    if (!(isNonEmpty(auth) && auth.get(0).startsWith("NTLM"))) {
+                        try {
+                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(), proxyServer.getHost());
+                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
+                        } catch (NTLMEngineException e) {
+                            IOException ie = new IOException();
+                            ie.initCause(e);
+                            throw ie;
+                        }
+                    }
+                } else {
+                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, AuthenticatorUtils.computeBasicAuthentication(proxyServer));
+                }
+            }
+        }
+
+        // Add default accept headers.
+        if (request.getHeaders().getFirstValue("Accept") == null) {
+            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
+        }
+
+        if (request.getHeaders().getFirstValue("User-Agent") != null) {
+            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
+        } else if (config.getUserAgent() != null) {
+            nettyRequest.setHeader("User-Agent", config.getUserAgent());
+        } else {
+            nettyRequest.setHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class, config));
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            if (isNonEmpty(request.getCookies())) {
+                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, CookieEncoder.encodeClientSide(request.getCookies(), config.isRfc6265CookieEncoding()));
+            }
+
+            String reqType = request.getMethod();
+            if (!"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
+
+                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
+
+                // We already have processed the body.
+                if (buffer != null && buffer.writerIndex() != 0) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
+                    nettyRequest.setContent(buffer);
+                } else if (request.getByteData() != null) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
+                } else if (request.getStringData() != null) {
+                    byte[] bytes = request.getStringData().getBytes(bodyCharset);
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(bytes.length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes));
+                } else if (request.getStreamData() != null) {
+                    int[] lengthWrapper = new int[1];
+                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
+                    int length = lengthWrapper[0];
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
+                } else if (isNonEmpty(request.getParams())) {
+                    StringBuilder sb = new StringBuilder();
+                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
+                        final String key = paramEntry.getKey();
+                        for (final String value : paramEntry.getValue()) {
+                            if (sb.length() > 0) {
+                                sb.append("&");
+                            }
+                            UTF8UrlEncoder.appendEncoded(sb, key);
+                            sb.append("=");
+                            UTF8UrlEncoder.appendEncoded(sb, value);
+                        }
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
+
+                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
+                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
+                    }
+
+                } else if (request.getParts() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getHeaders());
+
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
+
+                    /**
+                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
+                     */
+
+                    if (isSecure(uri)) {
+                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                        mre.writeRequest(new ChannelBufferOutputStream(b));
+                        nettyRequest.setContent(b);
+                    }
+                } else if (request.getEntityWriter() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
+                    nettyRequest.setContent(b);
+                } else if (request.getFile() != null) {
+                    File file = request.getFile();
+                    if (!file.isFile()) {
+                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
+                }
+            }
+        }
+        return nettyRequest;
+    }
+
+    public void close() {
+        isClose.set(true);
+        try {
+            connectionsPool.destroy();
+            openChannels.close();
+
+            for (Channel channel : openChannels) {
+                ChannelHandlerContext ctx = channel.getPipeline().getContext(NettyAsyncHttpProvider.class);
+                if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+                    future.setReaperFuture(null);
+                }
+            }
+
+            config.executorService().shutdown();
+            config.reaper().shutdown();
+            if (this.allowReleaseSocketChannelFactory) {
+                socketChannelFactory.releaseExternalResources();
+                plainBootstrap.releaseExternalResources();
+                secureBootstrap.releaseExternalResources();
+                webSocketBootstrap.releaseExternalResources();
+                secureWebSocketBootstrap.releaseExternalResources();
+            }
+        } catch (Throwable t) {
+            log.warn("Unexpected error on close", t);
+        }
+    }
+
+    /* @Override */
+
+    public Response prepareResponse(final HttpResponseStatus status, final HttpResponseHeaders headers, final List<HttpResponseBodyPart> bodyParts) {
+        return new NettyResponse(status, headers, bodyParts);
+    }
+
+    /* @Override */
+
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
+        return doConnect(request, asyncHandler, null, true, executeConnectAsync, false);
+    }
+
+    private <T> void execute(final Request request, final NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
+        doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
+    }
+
+    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
+
+        if (isClose.get()) {
+            throw new IOException("Closed");
+        }
+
+        if (request.getUrl().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler)) {
+            throw new IOException("WebSocket method must be a GET");
+        }
+
+        ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
+        boolean useProxy = proxyServer != null;
+        URI uri;
+        if (useRawUrl) {
+            uri = request.getRawURI();
+        } else {
+            uri = request.getURI();
+        }
+        Channel channel = null;
+
+        if (useCache) {
+            if (f != null && f.reuseChannel() && f.channel() != null) {
+                channel = f.channel();
+            } else {
+                URI connectionKeyUri = useProxy ? proxyServer.getURI() : uri;
+                channel = lookupInCache(connectionKeyUri, request.getConnectionPoolKeyStrategy());
+            }
+        }
+
+        ChannelBuffer bufferedBytes = null;
+        if (f != null && f.getRequest().getFile() == null && !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
+            bufferedBytes = f.getNettyRequest().getContent();
+        }
+
+        boolean useSSl = isSecure(uri) && !useProxy;
+        if (channel != null && channel.isOpen() && channel.isConnected()) {
+            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes, proxyServer);
+
+            if (f == null) {
+                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this, proxyServer);
+            } else {
+                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes, proxyServer);
+                f.setNettyRequest(nettyRequest);
+            }
+            f.setState(NettyResponseFuture.STATE.POOLED);
+            f.attachChannel(channel, false);
+
+            log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
+
+            try {
+                writeRequest(channel, config, f, nettyRequest);
+            } catch (Exception ex) {
+                log.debug("writeRequest failure", ex);
+                if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
+                    log.debug("SSLEngine failure", ex);
+                    f = null;
+                } else {
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        log.warn("doConnect.writeRequest()", t);
+                    }
+                    IOException ioe = new IOException(ex.getMessage());
+                    ioe.initCause(ex);
+                    throw ioe;
+                }
+            }
+            return f;
+        }
+
+        // Do not throw an exception when we need an extra connection for a redirect.
+        if (!reclaimCache && !connectionsPool.canCacheConnection()) {
+            IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
+            try {
+                asyncHandler.onThrowable(ex);
+            } catch (Throwable t) {
+                log.warn("!connectionsPool.canCacheConnection()", t);
+            }
+            throw ex;
+        }
+
+        boolean acquiredConnection = false;
+
+        if (trackConnections) {
+            if (!reclaimCache) {
+                if (!freeConnections.tryAcquire()) {
+                    IOException ex = new IOException("Too many connections " + config.getMaxTotalConnections());
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        log.warn("!connectionsPool.canCacheConnection()", t);
+                    }
+                    throw ex;
+                } else {
+                    acquiredConnection = true;
+                }
+            }
+        }
+
+        NettyConnectListener<T> c = new NettyConnectListener.Builder<T>(config, request, asyncHandler, f, this, bufferedBytes).build(uri);
+        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
+
+        if (useSSl) {
+            constructSSLPipeline(c);
+        }
+
+        ChannelFuture channelFuture;
+        ClientBootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
+        bootstrap.setOption("connectTimeoutMillis", config.getConnectionTimeoutInMs());
+
+        try {
+            InetSocketAddress remoteAddress;
+            if (request.getInetAddress() != null) {
+                remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
+            } else if (proxyServer == null || avoidProxy) {
+                remoteAddress = new InetSocketAddress(AsyncHttpProviderUtils.getHost(uri), AsyncHttpProviderUtils.getPort(uri));
+            } else {
+                remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
+            }
+
+            if (request.getLocalAddress() != null) {
+                channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
+            } else {
+                channelFuture = bootstrap.connect(remoteAddress);
+            }
+
+        } catch (Throwable t) {
+            if (acquiredConnection) {
+                freeConnections.release();
+            }
+            abort(c.future(), t.getCause() == null ? t : t.getCause());
+            return c.future();
+        }
+
+        boolean directInvokation = true;
+        if (IN_IO_THREAD.get() && DefaultChannelFuture.isUseDeadLockChecker()) {
+            directInvokation = false;
+        }
+
+        if (directInvokation && !asyncConnect && request.getFile() == null) {
+            int timeOut = config.getConnectionTimeoutInMs() > 0 ? config.getConnectionTimeoutInMs() : Integer.MAX_VALUE;
+            if (!channelFuture.awaitUninterruptibly(timeOut, TimeUnit.MILLISECONDS)) {
+                if (acquiredConnection) {
+                    freeConnections.release();
+                }
+                channelFuture.cancel();
+                abort(c.future(), new ConnectException(String.format("Connect operation to %s timeout %s", uri, timeOut)));
+            }
+
+            try {
+                c.operationComplete(channelFuture);
+            } catch (Exception e) {
+                if (acquiredConnection) {
+                    freeConnections.release();
+                }
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e);
+                try {
+                    asyncHandler.onThrowable(ioe);
+                } catch (Throwable t) {
+                    log.warn("c.operationComplete()", t);
+                }
+                throw ioe;
+            }
+        } else {
+            channelFuture.addListener(c);
+        }
+
+        log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
+
+        if (!c.future().isCancelled() || !c.future().isDone()) {
+            openChannels.add(channelFuture.getChannel());
+            c.future().attachChannel(channelFuture.getChannel(), false);
+        }
+        return c.future();
+    }
+
+    private void closeChannel(final ChannelHandlerContext ctx) {
+        connectionsPool.removeAll(ctx.getChannel());
+        finishChannel(ctx);
+    }
+
+    private void finishChannel(final ChannelHandlerContext ctx) {
+        ctx.setAttachment(new DiscardEvent());
+
+        // The channel may have already been removed if a timeout occurred, and this method may be called just after.
+        if (ctx.getChannel() == null) {
+            return;
+        }
+
+        log.debug("Closing Channel {} ", ctx.getChannel());
+
+        try {
+            ctx.getChannel().close();
+        } catch (Throwable t) {
+            log.debug("Error closing a connection", t);
+        }
+
+        if (ctx.getChannel() != null) {
+            openChannels.remove(ctx.getChannel());
+        }
+
+    }
+
+    @Override
+    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+        // call super to reset the read timeout
+        super.messageReceived(ctx, e);
+        IN_IO_THREAD.set(Boolean.TRUE);
+        if (ctx.getAttachment() == null) {
+            log.debug("ChannelHandlerContext wasn't having any attachment");
+        }
+
+        if (ctx.getAttachment() instanceof DiscardEvent) {
+            return;
+        } else if (ctx.getAttachment() instanceof AsyncCallable) {
+            if (e.getMessage() instanceof HttpChunk) {
+                HttpChunk chunk = (HttpChunk) e.getMessage();
+                if (chunk.isLast()) {
+                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+                    ac.call();
+                } else {
+                    return;
+                }
+            } else {
+                AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+                ac.call();
+            }
+            ctx.setAttachment(new DiscardEvent());
+            return;
+        } else if (!(ctx.getAttachment() instanceof NettyResponseFuture<?>)) {
+            try {
+                ctx.getChannel().close();
+            } catch (Throwable t) {
+                log.trace("Closing an orphan channel {}", ctx.getChannel());
+            }
+            return;
+        }
+
+        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+        p.handle(ctx, e);
+    }
+
+    private Realm kerberosChallenge(List<String> proxyAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
+
+        URI uri = request.getURI();
+        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
+        String server = proxyServer == null ? host : proxyServer.getHost();
+        try {
+            String challengeHeader = getSpnegoEngine().generateToken(server);
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            Realm.RealmBuilder realmBuilder;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+            }
+            return realmBuilder.setUri(uri.getRawPath()).setMethodName(request.getMethod()).setScheme(Realm.AuthScheme.KERBEROS).build();
+        } catch (Throwable throwable) {
+            if (proxyAuth.contains("NTLM")) {
+                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+            }
+            abort(future, throwable);
+            return null;
+        }
+    }
+
+    private Realm ntlmChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
+
+        boolean useRealm = (proxyServer == null && realm != null);
+
+        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
+        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
+        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
+        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
+
+        Realm newRealm;
+        if (realm != null && !realm.isNtlmMessageType2Received()) {
+            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
+
+            URI uri = request.getURI();
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(uri.getRawPath()).setMethodName(request.getMethod()).setNtlmMessageType2Received(true).build();
+            future.getAndSetAuth(false);
+        } else {
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+
+            if (wwwAuth.get(0).startsWith("NTLM ")) {
+                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+                String challengeHeader = ntlmEngine.generateType3Msg(principal, password, ntlmDomain, ntlmHost, serverChallenge);
+
+                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            }
+
+            Realm.RealmBuilder realmBuilder;
+            Realm.AuthScheme authScheme;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+                authScheme = realm.getAuthScheme();
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+                authScheme = Realm.AuthScheme.NTLM;
+            }
+            newRealm = realmBuilder.setScheme(authScheme).setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
+        }
+
+        return newRealm;
+    }
+
+    private Realm ntlmProxyChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm, NettyResponseFuture<?> future) throws NTLMEngineException {
+        future.getAndSetAuth(false);
+        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
+
+        if (wwwAuth.get(0).startsWith("NTLM ")) {
+            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getNtlmDomain(), proxyServer.getHost(), serverChallenge);
+            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+        }
+        Realm newRealm;
+        Realm.RealmBuilder realmBuilder;
+        if (realm != null) {
+            realmBuilder = new Realm.RealmBuilder().clone(realm);
+        } else {
+            realmBuilder = new Realm.RealmBuilder();
+        }
+        newRealm = realmBuilder// .setScheme(realm.getAuthScheme())
+                .setUri(request.getURI().getPath()).setMethodName(request.getMethod()).build();
+
+        return newRealm;
+    }
+
+    private String getPoolKey(NettyResponseFuture<?> future) throws MalformedURLException {
+        URI uri = future.getProxyServer() != null ? future.getProxyServer().getURI() : future.getURI();
+        return future.getConnectionPoolKeyStrategy().getKey(uri);
+    }
+
+    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future) {
+        ctx.setAttachment(new AsyncCallable(future) {
+            public Object call() throws Exception {
+                if (future.isKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
+                    return null;
+                }
+
+                finishChannel(ctx);
+                return null;
+            }
+
+            @Override
+            public String toString() {
+                return "Draining task for channel " + ctx.getChannel();
+            }
+        });
+    }
+
+    private FilterContext handleIoException(FilterContext fc, NettyResponseFuture<?> future) {
+        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                if (fc == null) {
+                    throw new NullPointerException("FilterContext is null");
+                }
+            } catch (FilterException efe) {
+                abort(future, efe);
+            }
+        }
+        return fc;
+    }
+
+    private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, HttpResponse response, ChannelHandlerContext ctx) throws IOException {
+        final Request newRequest = fc.getRequest();
+        future.setAsyncHandler(fc.getAsyncHandler());
+        future.setState(NettyResponseFuture.STATE.NEW);
+        future.touch();
+
+        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+        drainChannel(ctx, future);
+        nextRequest(newRequest, future);
+        return;
+    }
+
+    private List<String> getAuthorizationToken(List<Entry<String, String>> list, String headerAuth) {
+        ArrayList<String> l = new ArrayList<String>();
+        for (Entry<String, String> e : list) {
+            if (e.getKey().equalsIgnoreCase(headerAuth)) {
+                l.add(e.getValue().trim());
+            }
+        }
+        return l;
+    }
+
+    private void nextRequest(final Request request, final NettyResponseFuture<?> future) throws IOException {
+        nextRequest(request, future, true);
+    }
+
+    private void nextRequest(final Request request, final NettyResponseFuture<?> future, final boolean useCache) throws IOException {
+        execute(request, future, useCache, true, true);
+    }
+
+    private void abort(NettyResponseFuture<?> future, Throwable t) {
+        Channel channel = future.channel();
+        if (channel != null && openChannels.contains(channel)) {
+            closeChannel(channel.getPipeline().getContext(NettyAsyncHttpProvider.class));
+            openChannels.remove(channel);
+        }
+
+        if (!future.isCancelled() && !future.isDone()) {
+            log.debug("Aborting Future {}\n", future);
+            log.debug(t.getMessage(), t);
+        }
+
+        future.abort(t);
+    }
+
+    private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOException, GeneralSecurityException {
+        if (p.get(HTTP_HANDLER) != null) {
+            p.remove(HTTP_HANDLER);
+        }
+
+        if (isSecure(scheme)) {
+            if (p.get(SSL_HANDLER) == null) {
+                p.addFirst(HTTP_HANDLER, newHttpClientCodec());
+                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+            } else {
+                p.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
+            }
+
+        } else {
+            p.addFirst(HTTP_HANDLER, newHttpClientCodec());
+        }
+    }
+
+    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
+
+        if (isClose.get()) {
+            return;
+        }
+
+        connectionsPool.removeAll(ctx.getChannel());
+        try {
+            super.channelClosed(ctx, e);
+        } catch (Exception ex) {
+            log.trace("super.channelClosed", ex);
+        }
+
+        log.debug("Channel Closed: {} with attachment {}", e.getChannel(), ctx.getAttachment());
+
+        if (ctx.getAttachment() instanceof AsyncCallable) {
+            AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+            ctx.setAttachment(ac.future());
+            ac.call();
+            return;
+        }
+
+        if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+            future.touch();
+
+            if (config.getIOExceptionFilters().size() > 0) {
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                fc = handleIoException(fc, future);
+
+                if (fc.replayRequest() && !future.cannotBeReplay()) {
+                    replayRequest(future, fc, null, ctx);
+                    return;
+                }
+            }
+
+            Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+            p.onClose(ctx, e);
+
+            if (future != null && !future.isDone() && !future.isCancelled()) {
+                if (!remotelyClosed(ctx.getChannel(), future)) {
+                    abort(future, new IOException("Remotely Closed " + ctx.getChannel()));
+                }
+            } else {
+                closeChannel(ctx);
+            }
+        }
+    }
+
+    protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future) {
+
+        if (isClose.get()) {
+            return false;
+        }
+
+        connectionsPool.removeAll(channel);
+
+        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null && NettyResponseFuture.class.isAssignableFrom(channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
+            future = (NettyResponseFuture<?>) channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+        }
+
+        if (future == null || future.cannotBeReplay()) {
+            log.debug("Unable to recover future {}\n", future);
+            return false;
+        }
+
+        future.setState(NettyResponseFuture.STATE.RECONNECTED);
+        future.getAndSetStatusReceived(false);
+
+        log.debug("Trying to recover request {}\n", future.getNettyRequest());
+
+        try {
+            nextRequest(future.getRequest(), future);
+            return true;
+        } catch (IOException iox) {
+            future.setState(NettyResponseFuture.STATE.CLOSED);
+            future.abort(iox);
+            log.error("Remotely Closed, unable to recover", iox);
+        }
+        return false;
+    }
+
+    private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx) throws MalformedURLException {
+        // We need to make sure everything is OK before adding the connection back to the pool.
+        try {
+            future.done(null);
+        } catch (Throwable t) {
+            // Never propagate exception once we know we are done.
+            log.debug(t.getMessage(), t);
+        }
+
+        if (!future.isKeepAlive() || !ctx.getChannel().isReadable()) {
+            closeChannel(ctx);
+        }
+    }
+
+    private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
+        if (lastValidChunk && future.isKeepAlive()) {
+            drainChannel(ctx, future);
+        } else {
+            if (future.isKeepAlive() && ctx.getChannel().isReadable() && connectionsPool.offer(getPoolKey(future), ctx.getChannel())) {
+                markAsDone(future, ctx);
+                return;
+            }
+            finishChannel(ctx);
+        }
+        markAsDone(future, ctx);
+    }
+
+    private final boolean updateStatusAndInterrupt(AsyncHandler<?> handler, HttpResponseStatus c) throws Exception {
+        return handler.onStatusReceived(c) != STATE.CONTINUE;
+    }
+
+    private final boolean updateHeadersAndInterrupt(AsyncHandler<?> handler, HttpResponseHeaders c) throws Exception {
+        return handler.onHeadersReceived(c) != STATE.CONTINUE;
+    }
+
+    private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart c) throws Exception {
+        boolean state = handler.onBodyPartReceived(c) != STATE.CONTINUE;
+        if (c.closeUnderlyingConnection()) {
+            future.setKeepAlive(false);
+        }
+        return state;
+    }
+
+    // Simple marker for stopping publishing bytes.
+
+    final static class DiscardEvent {
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
+        Channel channel = e.getChannel();
+        Throwable cause = e.getCause();
+        NettyResponseFuture<?> future = null;
+
+        /**
+         * Issue 81 if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) { return; }
+         */
+        if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
+            return;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Unexpected I/O exception on channel {}", channel, cause);
+        }
+
+        try {
+
+            if (cause != null && ClosedChannelException.class.isAssignableFrom(cause.getClass())) {
+                return;
+            }
+
+            if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) ctx.getAttachment();
+                future.attachChannel(null, false);
+                future.touch();
+
+                if (IOException.class.isAssignableFrom(cause.getClass())) {
+
+                    if (config.getIOExceptionFilters().size() > 0) {
+                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                        fc = handleIoException(fc, future);
+
+                        if (fc.replayRequest()) {
+                            replayRequest(future, fc, null, ctx);
+                            return;
+                        }
+                    } else {
+                        // Close the channel so the recovering can occurs.
+                        try {
+                            ctx.getChannel().close();
+                        } catch (Throwable t) {
+                            ; // Swallow.
+                        }
+                        return;
+                    }
+                }
+
+                if (abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
+                    log.debug("Trying to recover from dead Channel: {}", channel);
+                    return;
+                }
+            } else if (ctx.getAttachment() instanceof AsyncCallable) {
+                future = ((AsyncCallable) ctx.getAttachment()).future();
+            }
+        } catch (Throwable t) {
+            cause = t;
+        }
+
+        if (future != null) {
+            try {
+                log.debug("Was unable to recover Future: {}", future);
+                abort(future, cause);
+            } catch (Throwable t) {
+                log.error(t.getMessage(), t);
+            }
+        }
+
+        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+        p.onError(ctx, e);
+
+        closeChannel(ctx);
+        ctx.sendUpstream(e);
+    }
+
+    protected static boolean abortOnConnectCloseException(Throwable cause) {
+        try {
+            for (StackTraceElement element : cause.getStackTrace()) {
+                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl") && element.getMethodName().equals("checkConnect")) {
+                    return true;
+                }
+            }
+
+            if (cause.getCause() != null) {
+                return abortOnConnectCloseException(cause.getCause());
+            }
+
+        } catch (Throwable t) {
+        }
+        return false;
+    }
+
+    protected static boolean abortOnDisconnectException(Throwable cause) {
+        try {
+            for (StackTraceElement element : cause.getStackTrace()) {
+                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler") && element.getMethodName().equals("channelDisconnected")) {
+                    return true;
+                }
+            }
+
+            if (cause.getCause() != null) {
+                return abortOnConnectCloseException(cause.getCause());
+            }
+
+        } catch (Throwable t) {
+        }
+        return false;
+    }
+
+    protected static boolean abortOnReadCloseException(Throwable cause) {
+
+        for (StackTraceElement element : cause.getStackTrace()) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("read")) {
+                return true;
+            }
+        }
+
+        if (cause.getCause() != null) {
+            return abortOnReadCloseException(cause.getCause());
+        }
+
+        return false;
+    }
+
+    protected static boolean abortOnWriteCloseException(Throwable cause) {
+
+        for (StackTraceElement element : cause.getStackTrace()) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher") && element.getMethodName().equals("write")) {
+                return true;
+            }
+        }
+
+        if (cause.getCause() != null) {
+            return abortOnReadCloseException(cause.getCause());
+        }
+
+        return false;
+    }
+
+    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
+        int length = (int) request.getContentLength();
+        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
+            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
+        }
+
+        if (length >= 0) {
+            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+        }
+        return length;
+    }
+
+    public static <T> NettyResponseFuture<T> newFuture(URI uri, Request request, AsyncHandler<T> asyncHandler, HttpRequest nettyRequest, AsyncHttpClientConfig config, NettyAsyncHttpProvider provider, ProxyServer proxyServer) {
+
+        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(config, request);
+        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri,//
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                requestTimeout,//
+                config.getIdleConnectionTimeoutInMs(),//
+                provider,//
+                request.getConnectionPoolKeyStrategy(),//
+                proxyServer);
+
+        if (request.getHeaders().getFirstValue("Expect") != null && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
+            f.getAndSetWriteBody(false);
+        }
+        return f;
+    }
+
+    private class ProgressListener implements ChannelFutureProgressListener {
+
+        private final boolean notifyHeaders;
+        private final AsyncHandler<?> asyncHandler;
+        private final NettyResponseFuture<?> future;
+
+        public ProgressListener(boolean notifyHeaders, AsyncHandler<?> asyncHandler, NettyResponseFuture<?> future) {
+            this.notifyHeaders = notifyHeaders;
+            this.asyncHandler = asyncHandler;
+            this.future = future;
+        }
+
+        public void operationComplete(ChannelFuture cf) {
+            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+            // Let's retry a second time.
+            Throwable cause = cf.getCause();
+            if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
+
+                if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
+                    log.debug(cause.getMessage(), cause);
+                    try {
+                        cf.getChannel().close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                }
+
+                if (ClosedChannelException.class.isAssignableFrom(cause.getClass()) || abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
+
+                    if (log.isDebugEnabled()) {
+                        log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
+                    }
+
+                    try {
+                        cf.getChannel().close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                } else {
+                    future.abort(cause);
+                }
+                return;
+            }
+            future.touch();
+
+            /**
+             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization, causing unpredictable behavior.
+             */
+            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
+            boolean startPublishing = future.isInAuth() || realm == null || realm.getUsePreemptiveAuth() == true;
+
+            if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+                if (notifyHeaders) {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
+                } else {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
+                }
+            }
+        }
+
+        public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
+            future.touch();
+            if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+                ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
+            }
+        }
+    }
+
+    /**
+     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future this wrapper will release the references to the channel and the
+     * nettyResponseFuture immediately. Otherwise, the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
+     */
+    private final class ReaperFuture implements Future, Runnable {
+        private Future scheduledFuture;
+        private NettyResponseFuture<?> nettyResponseFuture;
+
+        public ReaperFuture(NettyResponseFuture<?> nettyResponseFuture) {
+            this.nettyResponseFuture = nettyResponseFuture;
+        }
+
+        public void setScheduledFuture(Future scheduledFuture) {
+            this.scheduledFuture = scheduledFuture;
+        }
+
+        /**
+         * @Override
+         */
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            nettyResponseFuture = null;
+            return scheduledFuture.cancel(mayInterruptIfRunning);
+        }
+
+        /**
+         * @Override
+         */
+        public Object get() throws InterruptedException, ExecutionException {
+            return scheduledFuture.get();
+        }
+
+        /**
+         * @Override
+         */
+        public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            return scheduledFuture.get(timeout, unit);
+        }
+
+        /**
+         * @Override
+         */
+        public boolean isCancelled() {
+            return scheduledFuture.isCancelled();
+        }
+
+        /**
+         * @Override
+         */
+        public boolean isDone() {
+            return scheduledFuture.isDone();
+        }
+
+        private void expire(String message) {
+            log.debug("{} for {}", message, nettyResponseFuture);
+            abort(nettyResponseFuture, new TimeoutException(message));
+            nettyResponseFuture = null;
+        }
+
+        /**
+         * @Override
+         */
+        public synchronized void run() {
+            if (isClose.get()) {
+                cancel(true);
+                return;
+            }
+
+            boolean futureDone = nettyResponseFuture.isDone();
+            boolean futureCanceled = nettyResponseFuture.isCancelled();
+
+            if (nettyResponseFuture != null && !futureDone && !futureCanceled) {
+                long now = millisTime();
+                if (nettyResponseFuture.hasRequestTimedOut(now)) {
+                    long age = now - nettyResponseFuture.getStart();
+                    expire("Request reached time out of " + nettyResponseFuture.getRequestTimeoutInMs() + " ms after " + age + " ms");
+                } else if (nettyResponseFuture.hasConnectionIdleTimedOut(now)) {
+                    long age = now - nettyResponseFuture.getStart();
+                    expire("Request reached idle time out of " + nettyResponseFuture.getIdleConnectionTimeoutInMs() + " ms after " + age + " ms");
+                }
+
+            } else if (nettyResponseFuture == null || futureDone || futureCanceled) {
+                cancel(true);
+            }
+        }
+    }
+
+    private abstract class AsyncCallable implements Callable<Object> {
+
+        private final NettyResponseFuture<?> future;
+
+        public AsyncCallable(NettyResponseFuture<?> future) {
+            this.future = future;
+        }
+
+        abstract public Object call() throws Exception;
+
+        public NettyResponseFuture<?> future() {
+            return future;
+        }
+    }
+
+    public static class ThreadLocalBoolean extends ThreadLocal<Boolean> {
+
+        private final boolean defaultValue;
+
+        public ThreadLocalBoolean() {
+            this(false);
+        }
+
+        public ThreadLocalBoolean(boolean defaultValue) {
+            this.defaultValue = defaultValue;
+        }
+
+        @Override
+        protected Boolean initialValue() {
+            return defaultValue ? Boolean.TRUE : Boolean.FALSE;
+        }
+    }
+
+    public static class OptimizedFileRegion implements FileRegion {
+
+        private final FileChannel file;
+        private final RandomAccessFile raf;
+        private final long position;
+        private final long count;
+        private long byteWritten;
+
+        public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
+            this.raf = raf;
+            this.file = raf.getChannel();
+            this.position = position;
+            this.count = count;
+        }
+
+        public long getPosition() {
+            return position;
+        }
+
+        public long getCount() {
+            return count;
+        }
+
+        public long transferTo(WritableByteChannel target, long position) throws IOException {
+            long count = this.count - position;
+            if (count < 0 || position < 0) {
+                throw new IllegalArgumentException("position out of range: " + position + " (expected: 0 - " + (this.count - 1) + ")");
+            }
+            if (count == 0) {
+                return 0L;
+            }
+
+            long bw = file.transferTo(this.position + position, count, target);
+            byteWritten += bw;
+            if (byteWritten == raf.length()) {
+                releaseExternalResources();
+            }
+            return bw;
+        }
+
+        public void releaseExternalResources() {
+            try {
+                file.close();
+            } catch (IOException e) {
+                log.warn("Failed to close a file.", e);
+            }
+
+            try {
+                raf.close();
+            } catch (IOException e) {
+                log.warn("Failed to close a file.", e);
+            }
+        }
+    }
+
+    private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
+
+        private final ChannelBuffer content;
+        private final FileInputStream file;
+        private int byteRead = 0;
+
+        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ChannelBuffer content, File file) throws IOException {
+            super(headers);
+            this.content = content;
+            if (file != null) {
+                this.file = new FileInputStream(file);
+            } else {
+                this.file = null;
+            }
+        }
+
+        @Override
+        public void getBytes(byte[] bytes) {
+            if (content.writableBytes() != 0) {
+                content.getBytes(byteRead, bytes);
+                byteRead += bytes.length;
+            } else if (file != null) {
+                try {
+                    byteRead += file.read(bytes);
+                } catch (IOException e) {
+                    log.error(e.getMessage(), e);
+                }
+            }
+        }
+    }
+
+    protected AsyncHttpClientConfig getConfig() {
+        return config;
+    }
+
+    private static class NonConnectionsPool implements ConnectionsPool<String, Channel> {
+
+        public boolean offer(String uri, Channel connection) {
+            return false;
+        }
+
+        public Channel poll(String uri) {
+            return null;
+        }
+
+        public boolean removeAll(Channel connection) {
+            return false;
+        }
+
+        public boolean canCacheConnection() {
+            return true;
+        }
+
+        public void destroy() {
+        }
+    }
+
+    private static final boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        if (request.getMethod() != "GET" || !WebSocketUpgradeHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean redirect(Request request, NettyResponseFuture<?> future, HttpResponse response, final ChannelHandlerContext ctx) throws Exception {
+
+        int statusCode = response.getStatus().getCode();
+        boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
+        if (redirectEnabled && (statusCode == 302 || statusCode == 301 || statusCode == 303 || statusCode == 307)) {
+
+            if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
+                // We must allow 401 handling again.
+                future.getAndSetAuth(false);
+
+                String location = response.getHeader(HttpHeaders.Names.LOCATION);
+                URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
+                boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
+                if (!uri.toString().equals(future.getURI().toString())) {
+                    final RequestBuilder nBuilder = stripQueryString ? new RequestBuilder(future.getRequest()).setQueryParameters(null) : new RequestBuilder(future.getRequest());
+
+                    if (!(statusCode < 302 || statusCode > 303) && !(statusCode == 302 && config.isStrict302Handling())) {
+                        nBuilder.setMethod("GET");
+                    }
+                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                    final String initialPoolKey = getPoolKey(future);
+                    future.setURI(uri);
+                    String newUrl = uri.toString();
+                    if (request.getUrl().startsWith(WEBSOCKET)) {
+                        newUrl = newUrl.replace(HTTP, WEBSOCKET);
+                    }
+
+                    log.debug("Redirecting to {}", newUrl);
+                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE)) {
+                        for (Cookie c : CookieDecoder.decode(cookieStr)) {
+                            nBuilder.addOrReplaceCookie(c);
+                        }
+                    }
+
+                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE2)) {
+                        for (Cookie c : CookieDecoder.decode(cookieStr)) {
+                            nBuilder.addOrReplaceCookie(c);
+                        }
+                    }
+
+                    AsyncCallable ac = new AsyncCallable(future) {
+                        public Object call() throws Exception {
+                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(initialPoolKey, ctx.getChannel())) {
+                                return null;
+                            }
+                            finishChannel(ctx);
+                            return null;
+                        }
+                    };
+
+                    if (response.isChunked()) {
+                        // We must make sure there is no bytes left before executing the next request.
+                        ctx.setAttachment(ac);
+                    } else {
+                        ac.call();
+                    }
+                    nextRequest(nBuilder.setUrl(newUrl).build(), future);
+                    return true;
+                }
+            } else {
+                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+            }
+        }
+        return false;
+    }
+
+    private final class HttpProtocol implements Protocol {
+        // @Override
+        public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws Exception {
+            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+            future.touch();
+
+            // The connect timeout occured.
+            if (future.isCancelled() || future.isDone()) {
+                finishChannel(ctx);
+                return;
+            }
+
+            HttpRequest nettyRequest = future.getNettyRequest();
+            AsyncHandler handler = future.getAsyncHandler();
+            Request request = future.getRequest();
+            ProxyServer proxyServer = future.getProxyServer();
+            HttpResponse response = null;
+            try {
+                if (e.getMessage() instanceof HttpResponse) {
+                    response = (HttpResponse) e.getMessage();
+
+                    log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
+
+                    // Required if there is some trailing headers.
+                    future.setHttpResponse(response);
+
+                    int statusCode = response.getStatus().getCode();
+
+                    String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
+                    future.setKeepAlive(ka == null || !ka.toLowerCase().equals("close"));
+
+                    List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
+                    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+                    HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                    HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
+                    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(request).responseStatus(status).responseHeaders(responseHeaders).build();
+
+                    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                        try {
+                            fc = asyncFilter.filter(fc);
+                            if (fc == null) {
+                                throw new NullPointerException("FilterContext is null");
+                            }
+                        } catch (FilterException efe) {
+                            abort(future, efe);
+                        }
+                    }
+
+                    // The handler may have been wrapped.
+                    handler = fc.getAsyncHandler();
+                    future.setAsyncHandler(handler);
+
+                    // The request has changed
+                    if (fc.replayRequest()) {
+                        replayRequest(future, fc, response, ctx);
+                        return;
+                    }
+
+                    Realm newRealm = null;
+                    final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
+                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
+
+                    // if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
+                    // builder.setUrl(future.getURI().toString());
+                    // }
+
+                    if (statusCode == 401 && realm != null && wwwAuth.size() > 0 && !future.getAndSetAuth(true)) {
+
+                        future.setState(NettyResponseFuture.STATE.NEW);
+                        // NTLM
+                        if (!wwwAuth.contains("Kerberos") && (wwwAuth.contains("NTLM") || (wwwAuth.contains("Negotiate")))) {
+                            newRealm = ntlmChallenge(wwwAuth, request, proxyServer, headers, realm, future);
+                            // SPNEGO KERBEROS
+                        } else if (wwwAuth.contains("Negotiate")) {
+                            newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
+                            if (newRealm == null)
+                                return;
+                        } else {
+                            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(request.getURI().getPath()).setMethodName(request.getMethod()).setUsePreemptiveAuth(true).parseWWWAuthenticateHeader(wwwAuth.get(0)).build();
+                        }
+
+                        final Realm nr = new Realm.RealmBuilder().clone(newRealm).setUri(URI.create(request.getUrl()).getPath()).build();
+
+                        log.debug("Sending authentication to {}", request.getUrl());
+                        AsyncCallable ac = new AsyncCallable(future) {
+                            public Object call() throws Exception {
+                                drainChannel(ctx, future);
+                                nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
+                                return null;
+                            }
+                        };
+
+                        if (future.isKeepAlive() && response.isChunked()) {
+                            // We must make sure there is no bytes left before executing the next request.
+                            ctx.setAttachment(ac);
+                        } else {
+                            ac.call();
+                        }
+                        return;
+                    }
+
+                    if (statusCode == 100) {
+                        future.getAndSetWriteHeaders(false);
+                        future.getAndSetWriteBody(true);
+                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
+                        return;
+                    }
+
+                    List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
+                    if (statusCode == 407 && realm != null && proxyAuth.size() > 0 && !future.getAndSetAuth(true)) {
+
+                        log.debug("Sending proxy authentication to {}", request.getUrl());
+
+                        future.setState(NettyResponseFuture.STATE.NEW);
+
+                        if (!proxyAuth.contains("Kerberos") && (proxyAuth.get(0).contains("NTLM") || (proxyAuth.contains("Negotiate")))) {
+                            newRealm = ntlmProxyChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+                            // SPNEGO KERBEROS
+                        } else if (proxyAuth.contains("Negotiate")) {
+                            newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+                            if (newRealm == null)
+                                return;
+                        } else {
+                            newRealm = future.getRequest().getRealm();
+                        }
+
+                        Request req = builder.setHeaders(headers).setRealm(newRealm).build();
+                        future.setReuseChannel(true);
+                        future.setConnectAllowed(true);
+                        nextRequest(req, future);
+                        return;
+                    }
+
+                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT) && statusCode == 200) {
+
+                        log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
+
+                        if (future.isKeepAlive()) {
+                            future.attachChannel(ctx.getChannel(), true);
+                        }
+
+                        try {
+                            log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
+                            upgradeProtocol(ctx.getChannel().getPipeline(), request.getURI().getScheme());
+                        } catch (Throwable ex) {
+                            abort(future, ex);
+                        }
+                        Request req = builder.build();
+                        future.setReuseChannel(true);
+                        future.setConnectAllowed(false);
+                        nextRequest(req, future);
+                        return;
+                    }
+
+                    if (redirect(request, future, response, ctx))
+                        return;
+
+                    if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
+                        finishUpdate(future, ctx, response.isChunked());
+                        return;
+                    } else if (updateHeadersAndInterrupt(handler, responseHeaders)) {
+                        finishUpdate(future, ctx, response.isChunked());
+                        return;
+                    } else if (!response.isChunked()) {
+                        if (response.getContent().readableBytes() != 0) {
+                            updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
+                        }
+                        finishUpdate(future, ctx, false);
+                        return;
+                    }
+
+                    if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
+                        updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
+                        markAsDone(future, ctx);
+                        drainChannel(ctx, future);
+                    }
+
+                } else if (e.getMessage() instanceof HttpChunk) {
+                    HttpChunk chunk = (HttpChunk) e.getMessage();
+
+                    if (handler != null) {
+                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
+                            if (chunk instanceof DefaultHttpChunkTrailer) {
+                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(), future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
+                            }
+                            finishUpdate(future, ctx, !chunk.isLast());
+                        }
+                    }
+                }
+            } catch (Exception t) {
+                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
+                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(IOException.class.cast(t)).build();
+                    fc = handleIoException(fc, future);
+
+                    if (fc.replayRequest()) {
+                        replayRequest(future, fc, response, ctx);
+                        return;
+                    }
+                }
+
+                try {
+                    abort(future, t);
+                } finally {
+                    finishUpdate(future, ctx, false);
+                    throw t;
+                }
+            }
+        }
+
+        // @Override
+        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
+        }
+
+        // @Override
+        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
+        }
+    }
+
+    private final class WebSocketProtocol implements Protocol {
+        private static final byte OPCODE_CONT = 0x0;
+        private static final byte OPCODE_TEXT = 0x1;
+        private static final byte OPCODE_BINARY = 0x2;
+        private static final byte OPCODE_UNKNOWN = -1;
+        protected byte pendingOpcode = OPCODE_UNKNOWN;
+
+        // We don't need to synchronize as replacing the "ws-decoder" will process using the same thread.
+        private void invokeOnSucces(ChannelHandlerContext ctx, WebSocketUpgradeHandler h) {
+            if (!h.touchSuccess()) {
+                try {
+                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
+                } catch (Exception ex) {
+                    NettyAsyncHttpProvider.this.log.warn("onSuccess unexexpected exception", ex);
+                }
+            }
+        }
+
+        // @Override
+        public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+            NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
+            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+            Request request = future.getRequest();
+
+            if (e.getMessage() instanceof HttpResponse) {
+                HttpResponse response = (HttpResponse) e.getMessage();
+
+                HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(h).request(request).responseStatus(s).responseHeaders(responseHeaders).build();
+                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                    try {
+                        fc = asyncFilter.filter(fc);
+                        if (fc == null) {
+                            throw new NullPointerException("FilterContext is null");
+                        }
+                    } catch (FilterException efe) {
+                        abort(future, efe);
+                    }
+
+                }
+
+                // The handler may have been wrapped.
+                future.setAsyncHandler(fc.getAsyncHandler());
+
+                // The request has changed
+                if (fc.replayRequest()) {
+                    replayRequest(future, fc, response, ctx);
+                    return;
+                }
+
+                future.setHttpResponse(response);
+                if (redirect(request, future, response, ctx))
+                    return;
+
+                final org.jboss.netty.handler.codec.http.HttpResponseStatus status = new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
+
+                final boolean validStatus = response.getStatus().equals(status);
+                final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
+                String c = response.getHeader(HttpHeaders.Names.CONNECTION);
+                if (c == null) {
+                    c = response.getHeader("connection");
+                }
+
+                final boolean validConnection = c == null ? false : c.equalsIgnoreCase(HttpHeaders.Values.UPGRADE);
+
+                s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                final boolean statusReceived = h.onStatusReceived(s) == STATE.UPGRADE;
+
+                final boolean headerOK = h.onHeadersReceived(responseHeaders) == STATE.CONTINUE;
+                if (!headerOK || !validStatus || !validUpgrade || !validConnection || !statusReceived) {
+                    abort(future, new IOException("Invalid handshake response"));
+                    return;
+                }
+
+                String accept = response.getHeader("Sec-WebSocket-Accept");
+                String key = WebSocketUtil.getAcceptKey(future.getNettyRequest().getHeader(WEBSOCKET_KEY));
+                if (accept == null || !accept.equals(key)) {
+                    throw new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key));
+                }
+
+                ctx.getPipeline().replace("http-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
+                ctx.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder", new WebSocket08FrameDecoder(false, false));
+
+                invokeOnSucces(ctx, h);
+                future.done(null);
+            } else if (e.getMessage() instanceof WebSocketFrame) {
+
+                invokeOnSucces(ctx, h);
+
+                final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
+
+                if (frame instanceof TextWebSocketFrame) {
+                    pendingOpcode = OPCODE_TEXT;
+                } else if (frame instanceof BinaryWebSocketFrame) {
+                    pendingOpcode = OPCODE_BINARY;
+                }
+
+                HttpChunk webSocketChunk = new HttpChunk() {
+                    private ChannelBuffer content;
+
+                    // @Override
+                    public boolean isLast() {
+                        return false;
+                    }
+
+                    // @Override
+                    public ChannelBuffer getContent() {
+                        return content;
+                    }
+
+                    // @Override
+                    public void setContent(ChannelBuffer content) {
+                        this.content = content;
+                    }
+                };
+
+                if (frame.getBinaryData() != null) {
+                    webSocketChunk.setContent(ChannelBuffers.wrappedBuffer(frame.getBinaryData()));
+                    ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
+                    h.onBodyPartReceived(rp);
+
+                    NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+
+                    if (webSocket != null) {
+                        if (pendingOpcode == OPCODE_BINARY) {
+                            webSocket.onBinaryFragment(rp.getBodyPartBytes(), frame.isFinalFragment());
+                        } else {
+                            webSocket.onTextFragment(frame.getBinaryData().toString(UTF8), frame.isFinalFragment());
+                        }
+
+                        if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
+                            try {
+                                ctx.setAttachment(DiscardEvent.class);
+                                webSocket.onClose(CloseWebSocketFrame.class.cast(frame).getStatusCode(), CloseWebSocketFrame.class.cast(frame).getReasonText());
+                            } catch (Throwable t) {
+                                // Swallow any exception that may comes from a Netty version released before 3.4.0
+                                log.trace("", t);
+                            }
+                        }
+                    } else {
+                        log.debug("UpgradeHandler returned a null NettyWebSocket ");
+                    }
+                }
+            } else {
+                log.error("Invalid attachment {}", ctx.getAttachment());
+            }
+        }
+
+        // @Override
+        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
+            try {
+                log.warn("onError {}", e);
+                if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
+                    return;
+                }
+
+                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
+                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
+
+                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+                if (webSocket != null) {
+                    webSocket.onError(e.getCause());
+                    webSocket.close();
+                }
+            } catch (Throwable t) {
+                log.error("onError", t);
+            }
+        }
+
+        // @Override
+        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
+            log.trace("onClose {}", e);
+            if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
+                return;
+            }
+
+            try {
+                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
+                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
+                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+
+                if (ctx.getAttachment() == null || !DiscardEvent.class.isAssignableFrom(ctx.getAttachment().getClass()))
+                    webSocket.close(1006, "Connection was closed abnormally (that is, with no close frame being sent).");
+            } catch (Throwable t) {
+                log.error("onError", t);
+            }
+        }
+    }
+
+    private static boolean isWebSocket(URI uri) {
+        return WEBSOCKET.equalsIgnoreCase(uri.getScheme()) || WEBSOCKET_SSL.equalsIgnoreCase(uri.getScheme());
+    }
+
+    private static boolean isSecure(String scheme) {
+        return HTTPS.equalsIgnoreCase(scheme) || WEBSOCKET_SSL.equalsIgnoreCase(scheme);
+    }
+
+    private static boolean isSecure(URI uri) {
+        return isSecure(uri.getScheme());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
new file mode 100644
index 000000000..f338d570c
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.asynchttpclient.providers.netty;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.asynchttpclient.AsyncHttpProviderConfig;
+
+/**
+ * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
+ */
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProviderConfig.class);
+
+    /**
+     * Use Netty's blocking IO stategy.
+     */
+    private boolean useBlockingIO;
+
+    /**
+     * Allow configuring the Netty's socket channel factory.
+     */
+    private NioClientSocketChannelFactory socketChannelFactory;
+
+    /**
+     * Allow configuring the Netty's boss executor service.
+     */
+    private ExecutorService bossExecutorService;
+
+    /**
+     * HttpClientCodec's maxInitialLineLength
+     */
+    private int maxInitialLineLength = 4096;
+
+    /**
+     * HttpClientCodec's maxHeaderSize
+     */
+    private int maxHeaderSize = 8192;
+
+    /**
+     * HttpClientCodec's maxChunkSize
+     */
+    private int maxChunkSize = 8192;
+
+    /**
+     * Use direct {@link java.nio.ByteBuffer}
+     */
+    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
+
+    /**
+     * Allow nested request from any {@link org.asynchttpclient.AsyncHandler}
+     */
+    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
+
+    /**
+     * See {@link java.net.Socket#setReuseAddress(boolean)}
+     */
+    public final static String REUSE_ADDRESS = "reuseAddress";
+
+    private final Map<String, Object> properties = new HashMap<String, Object>();
+
+    public NettyAsyncHttpProviderConfig() {
+        properties.put(REUSE_ADDRESS, Boolean.FALSE);
+    }
+
+    /**
+     * Add a property that will be used when the AsyncHttpClient initialize its {@link org.asynchttpclient.AsyncHttpProvider}
+     * 
+     * @param name
+     *            the name of the property
+     * @param value
+     *            the value of the property
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+
+        if (name.equals(REUSE_ADDRESS) && value == Boolean.TRUE && System.getProperty("os.name").toLowerCase().contains("win")) {
+            LOGGER.warn("Can't enable {} on Windows", REUSE_ADDRESS);
+        } else {
+            properties.put(name, value);
+        }
+
+        return this;
+    }
+
+    /**
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public Object getProperty(String name) {
+        return properties.get(name);
+    }
+
+    /**
+     * Remove the value associated with the property's name
+     * 
+     * @param name
+     * @return true if removed
+     */
+    public Object removeProperty(String name) {
+        return properties.remove(name);
+    }
+
+    /**
+     * Return the curent entry set.
+     * 
+     * @return a the curent entry set.
+     */
+    public Set<Map.Entry<String, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+
+    public boolean isUseBlockingIO() {
+        return useBlockingIO;
+    }
+
+    public void setUseBlockingIO(boolean useBlockingIO) {
+        this.useBlockingIO = useBlockingIO;
+    }
+
+    public NioClientSocketChannelFactory getSocketChannelFactory() {
+        return socketChannelFactory;
+    }
+
+    public void setSocketChannelFactory(NioClientSocketChannelFactory socketChannelFactory) {
+        this.socketChannelFactory = socketChannelFactory;
+    }
+
+    public ExecutorService getBossExecutorService() {
+        return bossExecutorService;
+    }
+
+    public void setBossExecutorService(ExecutorService bossExecutorService) {
+        this.bossExecutorService = bossExecutorService;
+    }
+
+    public int getMaxInitialLineLength() {
+        return maxInitialLineLength;
+    }
+
+    public void setMaxInitialLineLength(int maxInitialLineLength) {
+        this.maxInitialLineLength = maxInitialLineLength;
+    }
+
+    public int getMaxHeaderSize() {
+        return maxHeaderSize;
+    }
+
+    public void setMaxHeaderSize(int maxHeaderSize) {
+        this.maxHeaderSize = maxHeaderSize;
+    }
+
+    public int getMaxChunkSize() {
+        return maxChunkSize;
+    }
+
+    public void setMaxChunkSize(int maxChunkSize) {
+        this.maxChunkSize = maxChunkSize;
+    }
+}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java
similarity index 92%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java
index 2c34c9297..5e3a7cfa6 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectListener.java
@@ -14,11 +14,16 @@
  * under the License.
  *
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.HostnameVerifier;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Request;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFuture;
@@ -28,12 +33,11 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.HostnameVerifier;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.util.concurrent.atomic.AtomicBoolean;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.util.ProxyUtils;
 
 
 /**
@@ -135,9 +139,10 @@ public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> as
         }
 
         public NettyConnectListener<T> build(final URI uri) throws IOException {
-            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer);
+            ProxyServer proxyServer = ProxyUtils.getProxyServer(config, request);
+            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer, proxyServer);
             if (future == null) {
-                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider);
+                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider, proxyServer);
             } else {
                 future.setNettyRequest(nettyRequest);
                 future.setRequest(request);
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java
new file mode 100644
index 000000000..5afd504df
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyConnectionsPool.java
@@ -0,0 +1,293 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import org.asynchttpclient.ConnectionsPool;
+import org.jboss.netty.channel.Channel;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * A simple implementation of {@link org.asynchttpclient.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ */
+public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
+
+    private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
+    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
+    private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
+    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final Timer idleConnectionDetector = new Timer(true);
+    private final boolean sslConnectionPoolEnabled;
+    private final int maxTotalConnections;
+    private final int maxConnectionPerHost;
+    private final int maxConnectionLifeTimeInMs;
+    private final long maxIdleTime;
+
+    public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
+        this(provider.getConfig().getMaxTotalConnections(), provider.getConfig().getMaxConnectionPerHost(), provider.getConfig().getIdleConnectionInPoolTimeoutInMs(), provider.getConfig().isSslConnectionPoolEnabled(), provider.getConfig().getMaxConnectionLifeTimeInMs());
+    }
+
+    public NettyConnectionsPool(int maxTotalConnections, int maxConnectionPerHost, long maxIdleTime, boolean sslConnectionPoolEnabled, int maxConnectionLifeTimeInMs) {
+        this.maxTotalConnections = maxTotalConnections;
+        this.maxConnectionPerHost = maxConnectionPerHost;
+        this.sslConnectionPoolEnabled = sslConnectionPoolEnabled;
+        this.maxIdleTime = maxIdleTime;
+        this.maxConnectionLifeTimeInMs = maxConnectionLifeTimeInMs;
+        this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
+    }
+
+    private static class IdleChannel {
+        final String uri;
+        final Channel channel;
+        final long start;
+
+        IdleChannel(String uri, Channel channel) {
+            this.uri = uri;
+            this.channel = channel;
+            this.start = millisTime();
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof IdleChannel)) return false;
+
+            IdleChannel that = (IdleChannel) o;
+
+            if (channel != null ? !channel.equals(that.channel) : that.channel != null) return false;
+
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            return channel != null ? channel.hashCode() : 0;
+        }
+    }
+
+    private class IdleChannelDetector extends TimerTask {
+        @Override
+        public void run() {
+            try {
+                if (isClosed.get()) return;
+
+                if (log.isDebugEnabled()) {
+                    Set<String> keys = connectionsPool.keySet();
+
+                    for (String s : keys) {
+                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
+                    }
+                }
+
+                List<IdleChannel> channelsInTimeout = new ArrayList<IdleChannel>();
+                long currentTime = millisTime();
+
+                for (IdleChannel idleChannel : channel2IdleChannel.values()) {
+                    long age = currentTime - idleChannel.start;
+                    if (age > maxIdleTime) {
+
+                        log.debug("Adding Candidate Idle Channel {}", idleChannel.channel);
+
+                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
+                        channelsInTimeout.add(idleChannel);
+                    }
+                }
+                long endConcurrentLoop = millisTime();
+
+                for (IdleChannel idleChannel : channelsInTimeout) {
+                    Object attachment = idleChannel.channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+                    if (attachment != null) {
+                        if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
+                            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
+
+                            if (!future.isDone() && !future.isCancelled()) {
+                                log.debug("Future not in appropriate state %s\n", future);
+                                continue;
+                            }
+                        }
+                    }
+
+                    if (remove(idleChannel)) {
+                        log.debug("Closing Idle Channel {}", idleChannel.channel);
+                        close(idleChannel.channel);
+                    }
+                }
+
+                if (log.isTraceEnabled()) {
+                    int openChannels = 0;
+                    for (ConcurrentLinkedQueue<IdleChannel> hostChannels: connectionsPool.values()) {
+                        openChannels += hostChannels.size();
+                    }
+                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
+                            openChannels, channelsInTimeout.size(), endConcurrentLoop - currentTime, millisTime() - endConcurrentLoop));
+                }
+            } catch (Throwable t) {
+                log.error("uncaught exception!", t);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean offer(String uri, Channel channel) {
+        if (isClosed.get()) return false;
+
+        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
+            return false;
+        }
+
+        Long createTime = channel2CreationDate.get(channel);
+        if (createTime == null){
+           channel2CreationDate.putIfAbsent(channel, millisTime());
+        }
+        else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < millisTime() ) {
+           log.debug("Channel {} expired", channel);
+           return false;
+        }
+
+        log.debug("Adding uri: {} for channel {}", uri, channel);
+        channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+
+        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        if (idleConnectionForHost == null) {
+            ConcurrentLinkedQueue<IdleChannel> newPool = new ConcurrentLinkedQueue<IdleChannel>();
+            idleConnectionForHost = connectionsPool.putIfAbsent(uri, newPool);
+            if (idleConnectionForHost == null) idleConnectionForHost = newPool;
+        }
+
+        boolean added;
+        int size = idleConnectionForHost.size();
+        if (maxConnectionPerHost == -1 || size < maxConnectionPerHost) {
+            IdleChannel idleChannel = new IdleChannel(uri, channel);
+            synchronized (idleConnectionForHost) {
+                added = idleConnectionForHost.add(idleChannel);
+
+                if (channel2IdleChannel.put(channel, idleChannel) != null) {
+                    log.error("Channel {} already exists in the connections pool!", channel);
+                }
+            }
+        } else {
+            log.debug("Maximum number of requests per host reached {} for {}", maxConnectionPerHost, uri);
+            added = false;
+        }
+        return added;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Channel poll(String uri) {
+        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
+            return null;
+        }
+
+        IdleChannel idleChannel = null;
+        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        if (idleConnectionForHost != null) {
+            boolean poolEmpty = false;
+            while (!poolEmpty && idleChannel == null) {
+                if (idleConnectionForHost.size() > 0) {
+                    synchronized (idleConnectionForHost) {
+                        idleChannel = idleConnectionForHost.poll();
+                        if (idleChannel != null) {
+                            channel2IdleChannel.remove(idleChannel.channel);
+                        }
+                    }
+                }
+
+                if (idleChannel == null) {
+                    poolEmpty = true;
+                } else if (!idleChannel.channel.isConnected() || !idleChannel.channel.isOpen()) {
+                    idleChannel = null;
+                    log.trace("Channel not connected or not opened!");
+                }
+            }
+        }
+        return idleChannel != null ? idleChannel.channel : null;
+    }
+
+    private boolean remove(IdleChannel pooledChannel) {
+        if (pooledChannel == null || isClosed.get()) return false;
+
+        boolean isRemoved = false;
+        ConcurrentLinkedQueue<IdleChannel> pooledConnectionForHost = connectionsPool.get(pooledChannel.uri);
+        if (pooledConnectionForHost != null) {
+            isRemoved = pooledConnectionForHost.remove(pooledChannel);
+        }
+        isRemoved |= channel2IdleChannel.remove(pooledChannel.channel) != null;
+        return isRemoved;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean removeAll(Channel channel) {
+        channel2CreationDate.remove(channel);
+        return !isClosed.get() && remove(channel2IdleChannel.get(channel));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean canCacheConnection() {
+        if (!isClosed.get() && maxTotalConnections != -1 && channel2IdleChannel.size() >= maxTotalConnections) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void destroy() {
+        if (isClosed.getAndSet(true)) return;
+
+        // stop timer
+        idleConnectionDetector.cancel();
+        idleConnectionDetector.purge();
+
+        for (Channel channel : channel2IdleChannel.keySet()) {
+            close(channel);
+        }
+        connectionsPool.clear();
+        channel2IdleChannel.clear();
+        channel2CreationDate.clear();
+    }
+
+    private void close(Channel channel) {
+        try {
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel2CreationDate.remove(channel);
+            channel.close();
+        } catch (Throwable t) {
+            // noop
+        }
+    }
+
+    public final String toString() {
+        return String.format("NettyConnectionPool: {pool-size: %d}", channel2IdleChannel.size());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java
new file mode 100644
index 000000000..81b520fbc
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponse.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBufferInputStream;
+import org.jboss.netty.buffer.ChannelBuffers;
+
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.providers.ResponseBase;
+import org.asynchttpclient.providers.netty.util.ChannelBufferUtil;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+import org.asynchttpclient.org.jboss.netty.handler.codec.http.CookieDecoder;
+
+/**
+ * Wrapper around the {@link org.asynchttpclient.Response} API.
+ */
+public class NettyResponse extends ResponseBase {
+
+    public NettyResponse(HttpResponseStatus status,
+                         HttpResponseHeaders headers,
+                         List<HttpResponseBodyPart> bodyParts) {
+        super(status, headers, bodyParts);
+    }
+
+    /* @Override */
+    public String getResponseBodyExcerpt(int maxLength) throws IOException {
+        return getResponseBodyExcerpt(maxLength, null);
+    }
+
+    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
+        // should be fine; except that it may split multi-byte chars (last char may become '?')
+        charset = calculateCharset(charset);
+        byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
+        return new String(b, charset);
+    }
+    
+    protected List<Cookie> buildCookies() {
+    	List<Cookie> cookies = new ArrayList<Cookie>();
+        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
+                // TODO: ask for parsed header
+                List<String> v = header.getValue();
+                for (String value : v) {
+                    cookies.addAll(CookieDecoder.decode(value));
+                }
+            }
+        }
+        return Collections.unmodifiableList(cookies);
+    }
+
+    /* @Override */
+    public byte[] getResponseBodyAsBytes() throws IOException {
+        return ChannelBufferUtil.channelBuffer2bytes(getResponseBodyAsChannelBuffer());
+    }
+
+    /* @Override */
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return getResponseBodyAsChannelBuffer().toByteBuffer();
+    }
+
+    /* @Override */
+    public String getResponseBody() throws IOException {
+        return getResponseBody(null);
+    }
+
+    /* @Override */
+    public String getResponseBody(String charset) throws IOException {
+        return getResponseBodyAsChannelBuffer().toString(Charset.forName(calculateCharset(charset)));
+    }
+
+    /* @Override */
+    public InputStream getResponseBodyAsStream() throws IOException {
+        return new ChannelBufferInputStream(getResponseBodyAsChannelBuffer());
+    }
+
+    public ChannelBuffer getResponseBodyAsChannelBuffer() throws IOException {
+        ChannelBuffer b = null;
+        switch (bodyParts.size()) {
+        case 0:
+            b = ChannelBuffers.EMPTY_BUFFER;
+            break;
+        case 1:
+            b = ResponseBodyPart.class.cast(bodyParts.get(0)).getChannelBuffer();
+            break;
+        default:
+            ChannelBuffer[] channelBuffers = new ChannelBuffer[bodyParts.size()];
+            for (int i = 0; i < bodyParts.size(); i++) {
+                channelBuffers[i] = ResponseBodyPart.class.cast(bodyParts.get(i)).getChannelBuffer();
+            }
+            b = ChannelBuffers.wrappedBuffer(channelBuffers);
+        }
+
+        return b;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java
new file mode 100755
index 000000000..ca7773af7
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyResponseFuture.java
@@ -0,0 +1,528 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import static org.asynchttpclient.util.DateUtil.millisTime;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.ConnectionPoolKeyStrategy;
+import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.listenable.AbstractListenableFuture;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
+ * 
+ * @param <V>
+ */
+public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+
+    private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
+    public final static String MAX_RETRY = "org.asynchttpclient.providers.netty.maxRetry";
+
+    enum STATE {
+        NEW, POOLED, RECONNECTED, CLOSED,
+    }
+
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final AtomicBoolean isDone = new AtomicBoolean(false);
+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
+    private AsyncHandler<V> asyncHandler;
+    private final int requestTimeoutInMs;
+    private final int idleConnectionTimeoutInMs;
+    private Request request;
+    private HttpRequest nettyRequest;
+    private final AtomicReference<V> content = new AtomicReference<V>();
+    private URI uri;
+    private boolean keepAlive = true;
+    private HttpResponse httpResponse;
+    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
+    private final AtomicInteger redirectCount = new AtomicInteger();
+    private volatile Future<?> reaperFuture;
+    private final AtomicBoolean inAuth = new AtomicBoolean(false);
+    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
+    private final AtomicLong touch = new AtomicLong(millisTime());
+    private final long start = millisTime();
+    private final NettyAsyncHttpProvider asyncHttpProvider;
+    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
+    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
+    private Channel channel;
+    private boolean reuseChannel = false;
+    private final AtomicInteger currentRetry = new AtomicInteger(0);
+    private final int maxRetry;
+    private boolean writeHeaders;
+    private boolean writeBody;
+    private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
+    private boolean allowConnect = false;
+    private final ConnectionPoolKeyStrategy connectionPoolKeyStrategy;
+    private final ProxyServer proxyServer;
+
+    public NettyResponseFuture(URI uri,//
+            Request request,//
+            AsyncHandler<V> asyncHandler,//
+            HttpRequest nettyRequest,//
+            int requestTimeoutInMs,//
+            int idleConnectionTimeoutInMs,//
+            NettyAsyncHttpProvider asyncHttpProvider,//
+            ConnectionPoolKeyStrategy connectionPoolKeyStrategy,//
+            ProxyServer proxyServer) {
+
+        this.asyncHandler = asyncHandler;
+        this.requestTimeoutInMs = requestTimeoutInMs;
+        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
+        this.request = request;
+        this.nettyRequest = nettyRequest;
+        this.uri = uri;
+        this.asyncHttpProvider = asyncHttpProvider;
+        this.connectionPoolKeyStrategy = connectionPoolKeyStrategy;
+        this.proxyServer = proxyServer;
+
+        if (System.getProperty(MAX_RETRY) != null) {
+            maxRetry = Integer.valueOf(System.getProperty(MAX_RETRY));
+        } else {
+            maxRetry = asyncHttpProvider.getConfig().getMaxRequestRetry();
+        }
+        writeHeaders = true;
+        writeBody = true;
+    }
+
+    protected URI getURI() throws MalformedURLException {
+        return uri;
+    }
+
+    protected void setURI(URI uri) {
+        this.uri = uri;
+    }
+
+    public ConnectionPoolKeyStrategy getConnectionPoolKeyStrategy() {
+        return connectionPoolKeyStrategy;
+    }
+
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean isDone() {
+        return isDone.get();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean isCancelled() {
+        return isCancelled.get();
+    }
+
+    void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+        this.asyncHandler = asyncHandler;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean cancel(boolean force) {
+        cancelReaper();
+
+        if (isCancelled.get())
+            return false;
+
+        try {
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel.close();
+        } catch (Throwable t) {
+            // Ignore
+        }
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(new CancellationException());
+            } catch (Throwable t) {
+                logger.warn("cancel", t);
+            }
+        }
+        latch.countDown();
+        isCancelled.set(true);
+        super.done();
+        return true;
+    }
+
+    /**
+     * Is the Future still valid
+     * 
+     * @return <code>true</code> if response has expired and should be terminated.
+     */
+    public boolean hasExpired() {
+        long now = millisTime();
+        return hasConnectionIdleTimedOut(now) || hasRequestTimedOut(now);
+    }
+
+    public boolean hasConnectionIdleTimedOut(long now) {
+        return idleConnectionTimeoutInMs != -1 && (now - touch.get()) >= idleConnectionTimeoutInMs;
+    }
+
+    public boolean hasRequestTimedOut(long now) {
+        return requestTimeoutInMs != -1 && (now - start) >= requestTimeoutInMs;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public V get() throws InterruptedException, ExecutionException {
+        try {
+            return get(requestTimeoutInMs, TimeUnit.MILLISECONDS);
+        } catch (TimeoutException e) {
+            cancelReaper();
+            throw new ExecutionException(e);
+        }
+    }
+
+    void cancelReaper() {
+        if (reaperFuture != null) {
+            reaperFuture.cancel(false);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+        if (!isDone() && !isCancelled()) {
+            boolean expired = false;
+            if (l == -1) {
+                latch.await();
+            } else {
+                expired = !latch.await(l, tu);
+            }
+
+            if (expired) {
+                isCancelled.set(true);
+                try {
+                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+                    channel.close();
+                } catch (Throwable t) {
+                    // Ignore
+                }
+                TimeoutException te = new TimeoutException(String.format("No response received after %s %s", l, tu.name().toLowerCase()));
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(te);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        cancelReaper();
+                        throw new ExecutionException(te);
+                    }
+                }
+            }
+            isDone.set(true);
+
+            ExecutionException e = exEx.getAndSet(null);
+            if (e != null) {
+                throw e;
+            }
+        }
+        return getContent();
+    }
+
+    V getContent() throws ExecutionException {
+        ExecutionException e = exEx.getAndSet(null);
+        if (e != null) {
+            throw e;
+        }
+
+        V update = content.get();
+        // No more retry
+        currentRetry.set(maxRetry);
+        if (exEx.get() == null && !contentProcessed.getAndSet(true)) {
+            try {
+                update = asyncHandler.onCompleted();
+            } catch (Throwable ex) {
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        cancelReaper();
+                        throw new RuntimeException(ex);
+                    }
+                }
+            }
+            content.compareAndSet(null, update);
+        }
+        return update;
+    }
+
+    public final void done(Callable callable) {
+
+        Throwable exception = null;
+
+        try {
+            cancelReaper();
+
+            if (exEx.get() != null) {
+                return;
+            }
+            getContent();
+            isDone.set(true);
+            if (callable != null) {
+                try {
+                    callable.call();
+                } catch (Exception ex) {
+                    exception = ex;
+                }
+            }
+        } catch (ExecutionException t) {
+            return;
+        } catch (RuntimeException t) {
+            exception = t.getCause() != null ? t.getCause() : t;
+
+        } finally {
+            latch.countDown();
+        }
+
+        if (exception != null)
+            exEx.compareAndSet(null, new ExecutionException(exception));
+
+        super.done();
+    }
+
+    public final void abort(final Throwable t) {
+        cancelReaper();
+
+        if (isDone.get() || isCancelled.get())
+            return;
+
+        exEx.compareAndSet(null, new ExecutionException(t));
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                logger.debug("asyncHandler.onThrowable", te);
+            } finally {
+                isCancelled.set(true);
+            }
+        }
+        latch.countDown();
+        super.done();
+    }
+
+    public void content(V v) {
+        content.set(v);
+    }
+
+    protected final Request getRequest() {
+        return request;
+    }
+
+    public final HttpRequest getNettyRequest() {
+        return nettyRequest;
+    }
+
+    protected final void setNettyRequest(HttpRequest nettyRequest) {
+        this.nettyRequest = nettyRequest;
+    }
+
+    protected final AsyncHandler<V> getAsyncHandler() {
+        return asyncHandler;
+    }
+
+    protected final boolean isKeepAlive() {
+        return keepAlive;
+    }
+
+    protected final void setKeepAlive(final boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
+
+    protected final HttpResponse getHttpResponse() {
+        return httpResponse;
+    }
+
+    protected final void setHttpResponse(final HttpResponse httpResponse) {
+        this.httpResponse = httpResponse;
+    }
+
+    protected int incrementAndGetCurrentRedirectCount() {
+        return redirectCount.incrementAndGet();
+    }
+
+    protected void setReaperFuture(Future<?> reaperFuture) {
+        cancelReaper();
+        this.reaperFuture = reaperFuture;
+    }
+
+    protected boolean isInAuth() {
+        return inAuth.get();
+    }
+
+    protected boolean getAndSetAuth(boolean inDigestAuth) {
+        return inAuth.getAndSet(inDigestAuth);
+    }
+
+    protected STATE getState() {
+        return state.get();
+    }
+
+    protected void setState(STATE state) {
+        this.state.set(state);
+    }
+
+    public boolean getAndSetStatusReceived(boolean sr) {
+        return statusReceived.getAndSet(sr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public void touch() {
+        touch.set(millisTime());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
+        boolean b = this.writeHeaders;
+        this.writeHeaders = writeHeaders;
+        return b;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean getAndSetWriteBody(boolean writeBody) {
+        boolean b = this.writeBody;
+        this.writeBody = writeBody;
+        return b;
+    }
+
+    protected NettyAsyncHttpProvider provider() {
+        return asyncHttpProvider;
+    }
+
+    protected void attachChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setReuseChannel(boolean reuseChannel) {
+        this.reuseChannel = reuseChannel;
+    }
+
+    public boolean isConnectAllowed() {
+        return allowConnect;
+    }
+
+    public void setConnectAllowed(boolean allowConnect) {
+        this.allowConnect = allowConnect;
+    }
+
+    protected void attachChannel(Channel channel, boolean reuseChannel) {
+        this.channel = channel;
+        this.reuseChannel = reuseChannel;
+    }
+
+    protected Channel channel() {
+        return channel;
+    }
+
+    protected boolean reuseChannel() {
+        return reuseChannel;
+    }
+
+    protected boolean canRetry() {
+        if (currentRetry.incrementAndGet() > maxRetry) {
+            return false;
+        }
+        return true;
+    }
+
+    public void setRequest(Request request) {
+        this.request = request;
+    }
+
+    /**
+     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can recover from that exception.
+     * 
+     * @return true if that {@link Future} cannot be recovered.
+     */
+    public boolean cannotBeReplay() {
+        return isDone() || !canRetry() || isCancelled() || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0) || isInAuth();
+    }
+
+    public long getStart() {
+        return start;
+    }
+
+    public long getRequestTimeoutInMs() {
+        return requestTimeoutInMs;
+    }
+
+    public long getIdleConnectionTimeoutInMs() {
+        return idleConnectionTimeoutInMs;
+    }
+
+    @Override
+    public String toString() {
+        return "NettyResponseFuture{" + //
+                "currentRetry=" + currentRetry + //
+                ",\n\tisDone=" + isDone + //
+                ",\n\tisCancelled=" + isCancelled + //
+                ",\n\tasyncHandler=" + asyncHandler + //
+                ",\n\trequestTimeoutInMs=" + requestTimeoutInMs + //
+                ",\n\tnettyRequest=" + nettyRequest + //
+                ",\n\tcontent=" + content + //
+                ",\n\turi=" + uri + //
+                ",\n\tkeepAlive=" + keepAlive + //
+                ",\n\thttpResponse=" + httpResponse + //
+                ",\n\texEx=" + exEx + //
+                ",\n\tredirectCount=" + redirectCount + //
+                ",\n\treaperFuture=" + reaperFuture + //
+                ",\n\tinAuth=" + inAuth + //
+                ",\n\tstatusReceived=" + statusReceived + //
+                ",\n\ttouch=" + touch + //
+                '}';
+    }
+
+}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyWebSocket.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java
similarity index 90%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyWebSocket.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java
index 3e0f7947e..8ae4f1ee0 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyWebSocket.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyWebSocket.java
@@ -10,24 +10,24 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.websocket.WebSocket;
-import com.ning.http.client.websocket.WebSocketByteListener;
-import com.ning.http.client.websocket.WebSocketCloseCodeReasonListener;
-import com.ning.http.client.websocket.WebSocketListener;
-import com.ning.http.client.websocket.WebSocketTextListener;
+import org.asynchttpclient.websocket.WebSocket;
+import org.asynchttpclient.websocket.WebSocketByteListener;
+import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.websocket.WebSocketListener;
+import org.asynchttpclient.websocket.WebSocketTextListener;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import org.jboss.netty.handler.codec.http.websocketx.PingWebSocketFrame;
 import org.jboss.netty.handler.codec.http.websocketx.PongWebSocketFrame;
 import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.concurrent.ConcurrentLinkedQueue;
-
 import java.io.ByteArrayOutputStream;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import static org.jboss.netty.buffer.ChannelBuffers.wrappedBuffer;
 
@@ -116,7 +116,18 @@ public boolean isOpen() {
     public void close() {
         onClose();
         listeners.clear();
-        channel.close();
+        try {
+            channel.write(new CloseWebSocketFrame());
+            channel.getCloseFuture().awaitUninterruptibly();
+        } finally {
+            channel.close();
+        }
+    }
+
+    // @Override
+    public void close(int statusCode, String reason) {
+        onClose(statusCode, reason);
+        listeners.clear();
     }
 
     protected void onBinaryFragment(byte[] message, boolean last) {
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/Protocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java
similarity index 96%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/Protocol.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java
index 3e8e9862c..f9d6f39ef 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/Protocol.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Protocol.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
 import org.jboss.netty.channel.ChannelHandlerContext;
 import org.jboss.netty.channel.ChannelStateEvent;
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseBodyPart.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java
similarity index 84%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseBodyPart.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java
index 9984f1a2c..b8d6411d8 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseBodyPart.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseBodyPart.java
@@ -13,13 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseBodyPart;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.handler.codec.http.HttpChunk;
-import org.jboss.netty.handler.codec.http.HttpResponse;
+package org.asynchttpclient.providers.netty;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -29,12 +23,18 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.providers.netty.util.ChannelBufferUtil;
+
 /**
  * A callback class used when an HTTP response body is received.
  */
 public class ResponseBodyPart extends HttpResponseBodyPart {
-    // Empty arrays are immutable, can freely reuse
-    private final static byte[] NO_BYTES = new byte[0];
 
     private final HttpChunk chunk;
     private final HttpResponse response;
@@ -68,11 +68,8 @@ public ResponseBodyPart(URI uri, HttpResponse response, AsyncHttpProvider provid
             return bp;
         }
 
-        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
-        int available = b.readableBytes();
-
-        final byte[] rb = (available == 0) ? NO_BYTES : new byte[available];
-        b.getBytes(b.readerIndex(), rb, 0, available);
+        byte[] rb = ChannelBufferUtil.channelBuffer2bytes(getChannelBuffer());
+        bytes.set(rb);
         return rb;
     }
 
@@ -89,7 +86,7 @@ public int length() {
     
     @Override
     public int writeTo(OutputStream outputStream) throws IOException {
-        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
+        ChannelBuffer b = getChannelBuffer();
         int available = b.readableBytes();
         if (available > 0) {
             b.getBytes(b.readerIndex(), outputStream, available);
@@ -102,6 +99,10 @@ public ByteBuffer getBodyByteBuffer() {
         return ByteBuffer.wrap(getBodyPartBytes());
     }
 
+    public ChannelBuffer getChannelBuffer() {
+        return chunk != null ? chunk.getContent() : response.getContent();
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseHeaders.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java
similarity index 72%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseHeaders.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java
index 0db2b3233..971eadbf7 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseHeaders.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseHeaders.java
@@ -13,15 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseHeaders;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
 import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
 import org.jboss.netty.handler.codec.http.HttpResponse;
 
 import java.net.URI;
+import java.util.Map;
 
 /**
  * A class that represent the HTTP headers.
@@ -48,17 +49,13 @@ public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provide
 
     private FluentCaseInsensitiveStringsMap computerHeaders() {
         FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        for (String s : response.getHeaderNames()) {
-            for (String header : response.getHeaders(s)) {
-                h.add(s, header);
-            }
+        for (Map.Entry<String, String> header: response.getHeaders()) {
+            h.add(header.getKey(), header.getValue());
         }
 
-        if (trailingHeaders != null && trailingHeaders.getHeaderNames().size() > 0) {
-            for (final String s : trailingHeaders.getHeaderNames()) {
-                for (String header : response.getHeaders(s)) {
-                    h.add(s, header);
-                }
+        if (trailingHeaders != null) {
+            for (Map.Entry<String, String> header:  trailingHeaders.getHeaders()) {
+                h.add(header.getKey(), header.getValue());
             }
         }
 
@@ -68,7 +65,7 @@ private FluentCaseInsensitiveStringsMap computerHeaders() {
     /**
      * Return the HTTP header
      *
-     * @return an {@link com.ning.http.client.FluentCaseInsensitiveStringsMap}
+     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
      */
     @Override
     public FluentCaseInsensitiveStringsMap getHeaders() {
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseStatus.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java
similarity index 93%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseStatus.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java
index 12024ecaa..4cec5faf8 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/ResponseStatus.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ResponseStatus.java
@@ -14,10 +14,10 @@
  * under the License.
  *
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.HttpResponseStatus;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.HttpResponseStatus;
 import org.jboss.netty.handler.codec.http.HttpResponse;
 
 import java.net.URI;
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/WebSocketUtil.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java
similarity index 96%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/WebSocketUtil.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java
index 5e20a499c..8aabcc954 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/WebSocketUtil.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/WebSocketUtil.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.util.Base64;
+import org.asynchttpclient.util.Base64;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoEngine.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java
similarity index 98%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoEngine.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java
index 201061c31..b0d653391 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoEngine.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoEngine.java
@@ -35,9 +35,9 @@
  * <http://www.apache.org/>.
  */
 
-package com.ning.http.client.providers.netty.spnego;
+package org.asynchttpclient.providers.netty.spnego;
 
-import com.ning.http.util.Base64;
+import org.asynchttpclient.util.Base64;
 import org.ietf.jgss.GSSContext;
 import org.ietf.jgss.GSSException;
 import org.ietf.jgss.GSSManager;
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoTokenGenerator.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java
similarity index 97%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoTokenGenerator.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java
index 1eca8af21..20d6dcc1a 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/spnego/SpnegoTokenGenerator.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/spnego/SpnegoTokenGenerator.java
@@ -36,7 +36,7 @@
  *
  */
 
-package com.ning.http.client.providers.netty.spnego;
+package org.asynchttpclient.providers.netty.spnego;
 
 import java.io.IOException;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java
new file mode 100644
index 000000000..e577d5473
--- /dev/null
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ChannelBufferUtil.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty.util;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+
+public class ChannelBufferUtil {
+
+    public static byte[] channelBuffer2bytes(ChannelBuffer b) {
+        int readable = b.readableBytes();
+        int readerIndex = b.readerIndex();
+        if (b.hasArray()) {
+            byte[] array = b.array();
+            if (b.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        b.getBytes(readerIndex, array);
+        return array;
+    }
+}
\ No newline at end of file
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/util/CleanupChannelGroup.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java
similarity index 98%
rename from providers/netty/src/main/java/com/ning/http/client/providers/netty/util/CleanupChannelGroup.java
rename to providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java
index c09f28084..486c61ef3 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/util/CleanupChannelGroup.java
+++ b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/CleanupChannelGroup.java
@@ -26,7 +26,7 @@
  * limitations under the License.
  */
 
-package com.ning.http.client.providers.netty.util;
+package org.asynchttpclient.providers.netty.util;
 
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFuture;
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java
deleted file mode 100644
index f52a7a45f..000000000
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ChunkingTest;
-import com.ning.http.client.async.ProviderUtil;
-
-public class NettyChunkingTest extends ChunkingTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
-    }
-}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNonAsciiContentLengthTest.java b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNonAsciiContentLengthTest.java
deleted file mode 100644
index 10f229522..000000000
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyNonAsciiContentLengthTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package com.ning.http.client.providers.netty;
-
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.NonAsciiContentLengthTest;
-import com.ning.http.client.async.ProviderUtil;
-
-public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
-
-    @Override
-	public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-		return ProviderUtil.nettyProvider(config);
-	}
-}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
similarity index 68%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
index 87d47a663..54262deaa 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncHttpProviderTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
@@ -10,36 +10,39 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Response;
-import com.ning.http.client.async.AbstractBasicTest;
-import com.ning.http.client.async.ProviderUtil;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
 
 import java.util.concurrent.Executors;
 
-import static org.testng.Assert.assertEquals;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
 
 public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
 
     @Test
     public void bossThreadPoolExecutor() throws Throwable {
         NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
-        conf.addProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE, Executors.newSingleThreadExecutor());
+        conf.setBossExecutorService(Executors.newSingleThreadExecutor());
 
         AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
         AsyncHttpClient c = getAsyncHttpClient(cf);
-
-        Response r = c.prepareGet(getTargetUrl()).execute().get();
-        assertEquals(r.getStatusCode(), 200);
+        try {
+            Response r = c.prepareGet(getTargetUrl()).execute().get();
+            assertEquals(r.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderBasicTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
similarity index 66%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderBasicTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
index 54cf25301..d422b202a 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyAsyncProviderBasicTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
@@ -10,25 +10,27 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty;
+package org.asynchttpclient.providers.netty;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.async.AsyncProvidersBasicTest;
-import com.ning.http.client.async.ProviderUtil;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.testng.annotations.Test;
 
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.AsyncProvidersBasicTest;
+
+@Test
 public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
     @Override
     protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = 
-                new NettyAsyncHttpProviderConfig();
+        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
         config.addProperty("tcpNoDelay", true);
         return config;
     }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
new file mode 100644
index 000000000..a8902eb65
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.netty;
+
+import static org.testng.Assert.assertEquals;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProvider;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelPipelineFactory;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelHandler;
+import org.jboss.netty.handler.codec.http.HttpMessage;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
+
+public class NettyAsyncProviderPipelineTest extends AbstractBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return new AsyncHttpClient(new CopyEncodingNettyAsyncHttpProvider(config), config);
+    }
+
+    @Test(groups = { "standalone", "netty_provider" })
+    public void asyncPipelineTest() throws Throwable {
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            p.close();
+        }
+    }
+
+    private static class CopyEncodingNettyAsyncHttpProvider extends
+            NettyAsyncHttpProvider {
+        public CopyEncodingNettyAsyncHttpProvider(AsyncHttpClientConfig config) {
+            super(config);
+        }
+
+        protected ChannelPipelineFactory createPlainPipelineFactory() {
+            final ChannelPipelineFactory pipelineFactory = super.createPlainPipelineFactory();
+            return new ChannelPipelineFactory() {
+                public ChannelPipeline getPipeline() throws Exception {
+                    ChannelPipeline pipeline = pipelineFactory.getPipeline();
+                    pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+                    return pipeline;
+                }
+            };
+        }
+    }
+
+    private static class CopyEncodingHandler extends SimpleChannelHandler {
+        @Override
+        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
+            Object msg = e.getMessage();
+            if (msg instanceof HttpMessage) {
+                HttpMessage m = (HttpMessage) msg;
+                // for test there is no Content-Encoding header so just hard coding value
+                // for verification
+                m.setHeader("X-Original-Content-Encoding", "<original encoding>");
+            }
+            ctx.sendUpstream(e);
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
new file mode 100644
index 000000000..812a04e0f
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.Cookie;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.providers.netty.NettyResponse;
+import org.asynchttpclient.providers.netty.ResponseStatus;
+import org.testng.annotations.Test;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+/**
+ * @author Benjamin Hanzelmann
+ */
+public class NettyAsyncResponseTest {
+
+    @Test(groups = "standalone")
+    public void testCookieParseExpires() {
+        // e.g. "Sun, 06-Feb-2012 03:45:24 GMT";
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
+        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
+
+        Date date = new Date(System.currentTimeMillis() + 60000); // sdf.parse( dateString );
+        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
+
+        NettyResponse
+                response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertTrue(cookie.getMaxAge() > 55 && cookie.getMaxAge() < 61, "");
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseMaxAge() {
+        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), 60);
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseWeirdExpiresValue() {
+        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), 60);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
new file mode 100644
index 000000000..1c1bea893
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamHandlerTest;
+
+public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
new file mode 100644
index 000000000..9760aa429
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AsyncStreamLifecycleTest;
+
+public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
new file mode 100644
index 000000000..61a633e00
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.AuthTimeoutTest;
+
+public class NettyAuthTimeoutTest extends AuthTimeoutTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
new file mode 100644
index 000000000..f8c7d3662
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicAuthTest;
+
+@Test
+public class NettyBasicAuthTest extends BasicAuthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    @Test
+    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
+        super.redirectAndBasicAuthTest(); // To change body of overridden methods use File | Settings | File Templates.
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
new file mode 100644
index 000000000..5790fd96b
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BasicHttpsTest;
+
+public class NettyBasicHttpsTest extends BasicHttpsTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
new file mode 100644
index 000000000..e8dacd968
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyChunkTest;
+
+public class NettyBodyChunkTest extends BodyChunkTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
new file mode 100644
index 000000000..01e8daba4
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
+
+public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
new file mode 100644
index 000000000..8cabb0c63
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ByteBufferCapacityTest;
+
+public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
new file mode 100644
index 000000000..7783e21d5
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
@@ -0,0 +1,12 @@
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ChunkingTest;
+
+public class NettyChunkingTest extends ChunkingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
new file mode 100644
index 000000000..7cb83020d
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ComplexClientTest;
+
+public class NettyComplexClientTest extends ComplexClientTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
new file mode 100644
index 000000000..945761d5e
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+
+import java.util.concurrent.TimeUnit;
+
+import org.jboss.netty.channel.Channel;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ConnectionsPool;
+import org.asynchttpclient.async.ConnectionPoolTest;
+
+public class NettyConnectionPoolTest extends ConnectionPoolTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public void testInvalidConnectionsPool() {
+        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
+
+            public boolean offer(String key, Channel connection) {
+                return false;
+            }
+
+            public Channel poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Channel connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return false;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        try {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertEquals(exception.getMessage(), "Too many connections -1");
+        } finally {
+            client.close();
+        }
+    }
+
+    @Override
+    public void testValidConnectionsPool() {
+        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
+
+            public boolean offer(String key, Channel connection) {
+                return true;
+            }
+
+            public Channel poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Channel connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return true;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
+        try {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
new file mode 100644
index 000000000..205fb73a1
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.DigestAuthTest;
+
+public class NettyDigestAuthTest extends DigestAuthTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
new file mode 100644
index 000000000..8cdbe19e6
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.EmptyBodyTest;
+
+public class NettyEmptyBodyTest extends EmptyBodyTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
new file mode 100644
index 000000000..ee34de01f
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ErrorResponseTest;
+
+public class NettyErrorResponseTest extends ErrorResponseTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
new file mode 100644
index 000000000..ce9759922
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Expect100ContinueTest;
+
+public class NettyExpect100ContinueTest extends Expect100ContinueTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
new file mode 100644
index 000000000..8b9adcbd6
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FilePartLargeFileTest;
+
+public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
new file mode 100644
index 000000000..d1c6fd0eb
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FilterTest;
+
+public class NettyFilterTest extends FilterTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
new file mode 100644
index 000000000..c3e2c8b75
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.FollowingThreadTest;
+
+public class NettyFollowingThreadTest extends FollowingThreadTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
new file mode 100644
index 000000000..8fc323e3b
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Head302Test;
+
+public class NettyHead302Test extends Head302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
new file mode 100644
index 000000000..004a2eb43
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.HostnameVerifierTest;
+
+public class NettyHostnameVerifierTest extends HostnameVerifierTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
new file mode 100644
index 000000000..ec739b406
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.HttpToHttpsRedirectTest;
+
+public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
new file mode 100644
index 000000000..26dc2a2db
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.IdleStateHandlerTest;
+
+public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
new file mode 100644
index 000000000..5854ddc98
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.InputStreamTest;
+
+public class NettyInputStreamTest extends InputStreamTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
new file mode 100644
index 000000000..723fc12d5
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ListenableFutureTest;
+
+public class NettyListenableFutureTest extends ListenableFutureTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
new file mode 100644
index 000000000..0e24c3d55
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright (c) 2010-2012 Sonatype, Inc.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * and Apache License v2.0 which accompanies this distribution.
+ * The Eclipse Public License is available at
+ *   http://www.eclipse.org/legal/epl-v10.html
+ * The Apache License v2.0 is available at
+ *   http://www.apache.org/licenses/LICENSE-2.0.html
+ * You may elect to redistribute this code under either of these licenses.
+ *******************************************************************************/
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxConnectionsInThreads;
+
+public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
new file mode 100644
index 000000000..15e0892a6
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MaxTotalConnectionTest;
+
+public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
new file mode 100644
index 000000000..fdbfb52d1
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MultipartUploadTest;
+
+/**
+ * @author dominict
+ */
+public class NettyMultipartUploadTest extends MultipartUploadTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
new file mode 100644
index 000000000..2198b1b1f
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.MultipleHeaderTest;
+
+public class NettyMultipleHeaderTest extends MultipleHeaderTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
new file mode 100644
index 000000000..d6b012226
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NoNullResponseTest;
+
+public class NettyNoNullResponseTest extends NoNullResponseTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
new file mode 100644
index 000000000..50fca62df
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.NonAsciiContentLengthTest;
+
+public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
new file mode 100644
index 000000000..d633d3797
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ParamEncodingTest;
+
+public class NettyParamEncodingTest extends ParamEncodingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
new file mode 100644
index 000000000..b0fabf1ef
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestRelative302Test;
+
+public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
new file mode 100644
index 000000000..c4692cb47
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import static org.testng.Assert.assertTrue;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PerRequestTimeoutTest;
+
+public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
+    
+    @Override
+    protected void checkTimeoutMessage(String message) {
+        assertTrue(message
+                .startsWith("Request reached time out of 100 ms after "));
+    }
+    
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
new file mode 100644
index 000000000..979c761bd
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostRedirectGetTest;
+
+public class NettyPostRedirectGetTest extends PostRedirectGetTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
new file mode 100644
index 000000000..c244b89c0
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PostWithQSTest;
+
+public class NettyPostWithQSTest extends PostWithQSTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
new file mode 100644
index 000000000..499e0025c
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class NettyProviderUtil {
+
+    public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
+        // FIXME why do tests fail with this set up? Seems like we have a race condition
+        // if (config == null) {
+        // config = new AsyncHttpClientConfig.Builder().build();
+        // }
+        // return new AsyncHttpClient(new NettyAsyncHttpProvider(config), config);
+
+        if (config == null) {
+            return new AsyncHttpClient();
+        } else {
+            return new AsyncHttpClient(config);
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
new file mode 100644
index 000000000..7c381c111
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTest;
+
+public class NettyProxyTest extends ProxyTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
new file mode 100644
index 000000000..a862e9ee8
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ProxyTunnellingTest;
+
+public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
new file mode 100644
index 000000000..550847c06
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.PutLargeFileTest;
+
+public class NettyPutLargeFileTest extends PutLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
new file mode 100644
index 000000000..7a38145ef
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.QueryParametersTest;
+
+public class NettyQueryParametersTest extends QueryParametersTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
new file mode 100644
index 000000000..17f26efbb
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RC10KTest;
+
+public class NettyRC10KTest extends RC10KTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
new file mode 100644
index 000000000..e376f9a41
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.async.RedirectConnectionUsageTest;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+
+public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    protected AsyncHttpProviderConfig getProviderConfig() {
+        final NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
+        if (System.getProperty("blockingio") != null) {
+            config.setUseBlockingIO(true);
+        }
+        return config;
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
new file mode 100644
index 000000000..22fca88ad
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.Relative302Test;
+
+public class NettyRelative302Test extends Relative302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
new file mode 100644
index 000000000..94c6f0d7a
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RemoteSiteTest;
+
+public class NettyRemoteSiteTest extends RemoteSiteTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
new file mode 100644
index 000000000..f0685b456
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.async.AbstractBasicTest;
+
+public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
+    private static final String MSG = "Enough is enough.";
+    private static final int SLEEPTIME_MS = 1000;
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
+    }
+
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(SLEEPTIME_MS);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        log.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        log.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
+
+    @Test(groups = { "standalone", "netty_provider" })
+    public void testRequestTimeout() throws IOException {
+        final Semaphore requestThrottle = new Semaphore(1);
+
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+
+            final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
+            for (int i = 0; i < 2; i++) {
+                new Thread(new Runnable() {
+
+                    public void run() {
+                        try {
+                            requestThrottle.acquire();
+                            Future<Response> responseFuture = null;
+                            try {
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2).execute(new AsyncCompletionHandler<Response>() {
+
+                                    @Override
+                                    public Response onCompleted(Response response) throws Exception {
+                                        requestThrottle.release();
+                                        return response;
+                                    }
+
+                                    @Override
+                                    public void onThrowable(Throwable t) {
+                                        requestThrottle.release();
+                                    }
+                                });
+                            } catch (Exception e) {
+                                tooManyConnections.add(e);
+                            }
+
+                            if (responseFuture != null)
+                                responseFuture.get();
+                        } catch (Exception e) {
+                        } finally {
+                            latch.countDown();
+                        }
+
+                    }
+                }).start();
+
+            }
+
+            try {
+                latch.await(30, TimeUnit.SECONDS);
+            } catch (Exception e) {
+                fail("failed to wait for requests to complete");
+            }
+
+            assertTrue(tooManyConnections.size() == 0, "Should not have any connection errors where too many connections have been attempted");
+        } finally {
+            client.close();
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
new file mode 100644
index 000000000..d00acde3c
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.RetryRequestTest;
+
+public class NettyRetryRequestTest extends RetryRequestTest{
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
new file mode 100644
index 000000000..27834862d
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
+
+public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
+
+    /**
+     * Not Used with {@link org.asynchttpclient.SimpleAsyncHttpClient}
+     * @param config
+     * @return
+     */
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return null;
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
new file mode 100644
index 000000000..504607b65
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.TransferListenerTest;
+
+public class NettyTransferListenerTest extends TransferListenerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
new file mode 100644
index 000000000..e3f938171
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.WebDavBasicTest;
+
+public class NettyWebDavBasicTest extends WebDavBasicTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
new file mode 100644
index 000000000..3e98117d0
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.async.ZeroCopyFileTest;
+
+public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
new file mode 100644
index 000000000..f99aeade6
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.Request;
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+
+import static org.testng.Assert.assertTrue;
+
+
+public class RetryNonBlockingIssue {
+
+    private URI servletEndpointUri;
+
+    private Server server;
+
+    private int port1;
+
+    public static int findFreePort() throws IOException {
+        ServerSocket socket = null;
+
+        try {
+            // 0 is open a socket on any free port
+            socket = new ServerSocket(0);
+            return socket.getLocalPort();
+        } finally {
+            if (socket != null) {
+                socket.close();
+            }
+        }
+    }
+
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        server = new Server();
+
+        port1 = findFreePort();
+
+        Connector listener = new SelectChannelConnector();
+        listener.setHost("127.0.0.1");
+        listener.setPort(port1);
+
+        server.addConnector(listener);
+
+
+        ServletContextHandler context = new
+                ServletContextHandler(ServletContextHandler.SESSIONS);
+
+        context.setContextPath("/");
+        server.setHandler(context);
+        context.addServlet(new ServletHolder(new
+                MockExceptionServlet()), "/*");
+
+        server.start();
+
+        servletEndpointUri = new URI("http://127.0.0.1:" + port1 + "/");
+    }
+
+    @AfterMethod
+    public void stop() {
+
+        try {
+            if (server != null) server.stop();
+        } catch (Exception e) {
+        }
+
+
+    }
+
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient
+            fetcher, int requests, String action, String id) throws IOException {
+        RequestBuilder builder = new RequestBuilder("GET");
+        builder.addQueryParameter(action, "1");
+
+        builder.addQueryParameter("maxRequests", "" + requests);
+        builder.addQueryParameter("id", id);
+        builder.setUrl(servletEndpointUri.toString());
+        Request r = builder.build();
+        return fetcher.executeRequest(r);
+
+    }
+
+    /**
+     * Tests that a head request can be made
+     *
+     * @throws IOException
+     * @throws ExecutionException
+     * @throws InterruptedException
+     */
+    @Test
+    public void testRetryNonBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(60000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @Test
+    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(60000);
+            bc.setRequestTimeoutInMs(30000);
+            bc.setAsyncConnectMode(true);
+
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @Test
+    public void testRetryBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(30000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+            config.setUseBlockingIO(true);
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    public class MockExceptionServlet extends HttpServlet {
+
+        private Map<String, Integer> requests = new
+                ConcurrentHashMap<String, Integer>();
+
+        private synchronized int increment(String id) {
+            int val = 0;
+            if (requests.containsKey(id)) {
+                Integer i = requests.get(id);
+                val = i + 1;
+                requests.put(id, val);
+            } else {
+                requests.put(id, 1);
+                val = 1;
+            }
+            System.out.println("REQUESTS: " + requests);
+            return val;
+        }
+
+        public void service(HttpServletRequest req, HttpServletResponse res)
+                throws ServletException, IOException {
+            String maxRequests = req.getParameter("maxRequests");
+            int max = 0;
+            try {
+                max = Integer.parseInt(maxRequests);
+            }
+            catch (NumberFormatException e) {
+                max = 3;
+            }
+            String id = req.getParameter("id");
+            int requestNo = increment(id);
+            String servlet = req.getParameter("servlet");
+            String io = req.getParameter("io");
+            String error = req.getParameter("500");
+
+
+            if (requestNo >= max) {
+                res.setHeader("Success-On-Attempt", "" + requestNo);
+                res.setHeader("id", id);
+                if (servlet != null && servlet.trim().length() > 0)
+                    res.setHeader("type", "servlet");
+                if (error != null && error.trim().length() > 0)
+                    res.setHeader("type", "500");
+                if (io != null && io.trim().length() > 0)
+                    res.setHeader("type", "io");
+                res.setStatus(200);
+                res.setContentLength(0);
+                return;
+            }
+
+
+            res.setStatus(200);
+            res.setContentLength(100);
+            res.setContentType("application/octet-stream");
+
+            res.flushBuffer();
+
+            if (servlet != null && servlet.trim().length() > 0)
+                throw new ServletException("Servlet Exception");
+
+            if (io != null && io.trim().length() > 0)
+                throw new IOException("IO Exception");
+
+            if (error != null && error.trim().length() > 0)
+                res.sendError(500, "servlet process was 500");
+        }
+
+    }
+}
+
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyByteMessageTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
similarity index 72%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyByteMessageTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
index 7e0032449..695db23d5 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyByteMessageTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty.websocket;
+package org.asynchttpclient.providers.netty.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.websocket.ByteMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.ByteMessageTest;
 
 public class NettyByteMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
similarity index 72%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
index b67a88011..2dc624466 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
@@ -11,18 +11,18 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package com.ning.http.client.providers.netty.websocket;
+package org.asynchttpclient.providers.netty.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.websocket.CloseCodeReasonMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
 
 public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
new file mode 100644
index 000000000..63b875480
--- /dev/null
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.providers.netty.websocket;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.RedirectTest;
+
+public class NettyRedirectTest extends RedirectTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyTextMessageTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
similarity index 72%
rename from providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyTextMessageTest.java
rename to providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
index 091eb703c..c1286255a 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/websocket/NettyTextMessageTest.java
+++ b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package com.ning.http.client.providers.netty.websocket;
+package org.asynchttpclient.providers.netty.websocket;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.websocket.TextMessageTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.providers.netty.NettyProviderUtil;
+import org.asynchttpclient.websocket.TextMessageTest;
 
 public class NettyTextMessageTest extends TextMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/pom.xml b/providers/pom.xml
index a33f23dc5..64f8d2376 100644
--- a/providers/pom.xml
+++ b/providers/pom.xml
@@ -2,15 +2,13 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
-        <groupId>com.ning</groupId>
+        <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
+        <version>2.0.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
     <artifactId>async-http-client-providers-parent</artifactId>
     <name>Asynchronous Http Client Providers Parent</name>
-    <version>1.8.0-SNAPSHOT</version>
     <packaging>pom</packaging>
     <description>
         The Async Http Client providers library parent.
@@ -46,23 +44,25 @@
     </build>
 
     <modules>
-        <module>apache</module>
         <module>grizzly</module>
         <module>netty</module>
+        <!--
+        <module>netty-4</module>
+        -->
     </modules>
 
     <dependencies>
         <dependency>
-            <groupId>com.ning</groupId>
+            <groupId>org.asynchttpclient</groupId>
             <artifactId>async-http-client-api</artifactId>
             <version>${project.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.ning</groupId>
+            <groupId>org.asynchttpclient</groupId>
             <artifactId>async-http-client-api</artifactId>
             <version>${project.version}</version>
             <scope>test</scope>
             <classifier>tests</classifier>
         </dependency>
     </dependencies>
-</project>
\ No newline at end of file
+</project>
diff --git a/site/pom.xml b/site/pom.xml
index 49f9d7dbb..b6e29bd13 100644
--- a/site/pom.xml
+++ b/site/pom.xml
@@ -1,14 +1,14 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
-        <groupId>com.ning</groupId>
+        <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>1.8.0-SNAPSHOT</version>
+        <version>2.0.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.ning</groupId>
+    <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-site</artifactId>
     <name>Asynchronous Http Client Project Site</name>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <packaging>pom</packaging>
     <description>
         The Async Http Client site.
diff --git a/site/src/site/apt/ssl.apt b/site/src/site/apt/ssl.apt
index 9c7e5db94..aeb3e958a 100644
--- a/site/src/site/apt/ssl.apt
+++ b/site/src/site/apt/ssl.apt
@@ -35,6 +35,6 @@ SecureRandom secureRandom = new SecureRandom();
 SSLContext sslContext = SSLContext.getInstance("TLS");
 sslContext.init(keyManagers, trustManagers, secureRandom);
 Builder builder = new AsyncHttpClientConfig.Builder();
-builder.setSSLContext(myOwnThreadPool);
+builder.setSSLContext(sslContext);
 AsyncHttpClient client = new AsyncHttpClient(builder.build());
 +-----+
