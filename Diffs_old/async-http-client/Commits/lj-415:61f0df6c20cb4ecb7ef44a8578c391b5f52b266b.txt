diff --git a/MIGRATION.md b/MIGRATION.md
index 43781ca2c..05c976a07 100644
--- a/MIGRATION.md
+++ b/MIGRATION.md
@@ -19,7 +19,7 @@ AsyncHttpClient v1.9 is a preview of v2, so it comes with some breaking changes.
   * `allowPoolingConnection` becomes `allowPoolingConnections`
   * `allowSslConnectionPool` becomes `allowPoolingSslConnections`
   * `connectionTimeout` becomes `connectTimeout`
-  * `compressionEnabled` becomes `compressionEnforced` (default true) so it's always enabled and can honor user defined Accept-Encoding
+  * `compressionEnabled` becomes `compressionEnforced`. Default false, so AHC only honors user defined Accept-Encoding.
   * `requestCompressionLevel` was dropped, as it wasn't working
   * `SSLEngineFactory` was moved to Netty config as only Netty honors it
   * `useRawUrl` becomes `disableUrlEncodingForBoundedRequests`, as it's only honored by bound requests
diff --git a/client/pom.xml b/client/pom.xml
index de02a2b15..f9cb9edf6 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.0-SNAPSHOT</version>
+		<version>2.0.0-RC4-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index ad85a6189..51fb30a59 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -11,14 +11,13 @@
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.netty.EagerNettyResponseBodyPart;
-import org.asynchttpclient.netty.LazyNettyResponseBodyPart;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.EagerResponseBodyPart;
+import org.asynchttpclient.netty.LazyResponseBodyPart;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 
@@ -30,64 +29,51 @@
     String getAhcVersion();
 
     /**
-     * Return the name of {@link AsyncHttpClient}, which is used for thread
-     * naming and debugging.
+     * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
      *
      * @return the name.
      */
     String getThreadPoolName();
 
     /**
-     * Return the maximum number of connections an {@link AsyncHttpClient} can
-     * handle.
+     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections an {@link AsyncHttpClient} can
-     *         handle.
+     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
      */
     int getMaxConnections();
 
     /**
-     * Return the maximum number of connections per hosts an
-     * {@link AsyncHttpClient} can handle.
+     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections per host an
-     *         {@link AsyncHttpClient} can handle.
+     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
      */
     int getMaxConnectionsPerHost();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
-     * wait when connecting to a remote host
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
-     *         wait when connecting to a remote host
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      */
     int getConnectTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
-     * stay idle.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
-     *         stay idle.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      */
     int getReadTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
-     * keep connection in pool.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
-     *         keep connection in pool.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
      */
     int getPooledConnectionIdleTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits
-     * until the response is completed.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits
-     *         until the response is completed.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
      */
     int getRequestTimeout();
 
@@ -127,13 +113,10 @@
     boolean isCompressionEnforced();
 
     /**
-     * Return the {@link java.util.concurrent.ThreadFactory} an
-     * {@link AsyncHttpClient} use for handling asynchronous response.
+     * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
      *
-     * @return the {@link java.util.concurrent.ThreadFactory} an
-     *         {@link AsyncHttpClient} use for handling asynchronous response.
-     *         If no {@link ThreadFactory} has been explicitly provided, this
-     *         method will return <code>null</code>
+     * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
+     *         provided, this method will return <code>null</code>
      */
     ThreadFactory getThreadFactory();
 
@@ -180,11 +163,9 @@
     List<IOExceptionFilter> getIoExceptionFilters();
 
     /**
-     * Return the number of time the library will retry when an
-     * {@link java.io.IOException} is throw by the remote server
+     * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
      *
-     * @return the number of time the library will retry when an
-     *         {@link java.io.IOException} is throw by the remote server
+     * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
      */
     int getMaxRequestRetry();
 
@@ -194,28 +175,22 @@
     boolean isDisableUrlEncodingForBoundRequests();
 
     /**
-     * In the case of a POST/Redirect/Get scenario where the server uses a 302
-     * for the redirect, should AHC respond to the redirect with a GET or
-     * whatever the original method was. Unless configured otherwise, for a 302,
-     * AHC, will use a GET for this case.
+     * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
+     * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
      *
-     * @return <code>true</code> if string 302 handling is to be used, otherwise
-     *         <code>false</code>.
+     * @return <code>true</code> if string 302 handling is to be used, otherwise <code>false</code>.
      */
     boolean isStrict302Handling();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
-     * keep connection in the pool, or -1 to keep connection while possible.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
-     *         keep connection in the pool, or -1 to keep connection while
-     *         possible.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      */
     int getConnectionTtl();
 
     boolean isUseOpenSsl();
-    
+
     boolean isAcceptAnyCertificate();
 
     /**
@@ -280,6 +255,10 @@
 
     KeepAliveStrategy getKeepAliveStrategy();
 
+    boolean isValidateResponseHeaders();
+
+    boolean isUsePooledMemory();
+
     interface AdditionalChannelInitializer {
 
         void initChannel(Channel channel) throws Exception;
@@ -289,19 +268,19 @@
 
         EAGER {
             @Override
-            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new EagerNettyResponseBodyPart(buf, last);
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new EagerResponseBodyPart(buf, last);
             }
         },
 
         LAZY {
 
             @Override
-            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new LazyNettyResponseBodyPart(buf, last);
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new LazyResponseBodyPart(buf, last);
             }
         };
 
-        public abstract NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+        public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
index c18f79758..e4ad98879 100644
--- a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -12,11 +12,15 @@
  */
 package org.asynchttpclient;
 
-
 public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
 
     private final AsyncHttpClient client;
 
+    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
+        super(method, isDisableUrlEncoding, validateHeaders);
+        this.client = client;
+    }
+
     public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
         super(method, isDisableUrlEncoding);
         this.client = client;
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 9e12bf695..ba72e0b30 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -22,12 +22,12 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 787d0b1e6..76102eacb 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -31,18 +31,17 @@
 import java.util.Properties;
 import java.util.concurrent.ThreadFactory;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
 /**
- * Configuration class to use with a {@link AsyncHttpClient}. System property
- * can be also used to configure this object default behavior by doing: <br>
+ * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this object default behavior by doing: <br>
  * -Dorg.asynchttpclient.nameOfTheProperty
  * 
  * @see AsyncHttpClientConfig for documentation
@@ -73,6 +72,7 @@
     private final boolean disableZeroCopy;
     private final boolean keepEncodingHeader;
     private final ProxyServerSelector proxyServerSelector;
+    private final boolean validateResponseHeaders;
 
     // timeouts
     private final int connectTimeout;
@@ -117,6 +117,7 @@
     private final Map<ChannelOption<Object>, Object> channelOptions;
     private final EventLoopGroup eventLoopGroup;
     private final boolean useNativeTransport;
+    private final boolean usePooledMemory;
     private final Timer nettyTimer;
     private final ThreadFactory threadFactory;
     private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
@@ -136,6 +137,7 @@ private DefaultAsyncHttpClientConfig(//
             boolean disableZeroCopy,//
             boolean keepEncodingHeader,//
             ProxyServerSelector proxyServerSelector,//
+            boolean validateResponseHeaders,//
 
             // timeouts
             int connectTimeout,//
@@ -180,6 +182,7 @@ private DefaultAsyncHttpClientConfig(//
             Map<ChannelOption<Object>, Object> channelOptions,//
             EventLoopGroup eventLoopGroup,//
             boolean useNativeTransport,//
+            boolean usePooledMemory,//
             Timer nettyTimer,//
             ThreadFactory threadFactory,//
             AdditionalChannelInitializer httpAdditionalChannelInitializer,//
@@ -198,6 +201,7 @@ private DefaultAsyncHttpClientConfig(//
         this.disableZeroCopy = disableZeroCopy;
         this.keepEncodingHeader = keepEncodingHeader;
         this.proxyServerSelector = proxyServerSelector;
+        this.validateResponseHeaders = validateResponseHeaders;
 
         // timeouts
         this.connectTimeout = connectTimeout;
@@ -242,6 +246,7 @@ private DefaultAsyncHttpClientConfig(//
         this.channelOptions = channelOptions;
         this.eventLoopGroup = eventLoopGroup;
         this.useNativeTransport = useNativeTransport;
+        this.usePooledMemory = usePooledMemory;
         this.nettyTimer = nettyTimer;
         this.threadFactory = threadFactory;
         this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
@@ -373,12 +378,17 @@ public KeepAliveStrategy getKeepAliveStrategy() {
         return keepAliveStrategy;
     }
 
+    @Override
+    public boolean isValidateResponseHeaders() {
+        return validateResponseHeaders;
+    }
+
     // ssl
     @Override
     public boolean isUseOpenSsl() {
         return useOpenSsl;
     }
-    
+
     @Override
     public boolean isAcceptAnyCertificate() {
         return acceptAnyCertificate;
@@ -486,6 +496,11 @@ public boolean isUseNativeTransport() {
         return useNativeTransport;
     }
 
+    @Override
+    public boolean isUsePooledMemory() {
+        return usePooledMemory;
+    }
+
     @Override
     public Timer getNettyTimer() {
         return nettyTimer;
@@ -530,6 +545,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private ProxyServerSelector proxyServerSelector;
         private boolean useProxySelector = defaultUseProxySelector();
         private boolean useProxyProperties = defaultUseProxyProperties();
+        private boolean validateResponseHeaders = defaultValidateResponseHeaders();
 
         // timeouts
         private int connectTimeout = defaultConnectTimeout();
@@ -572,6 +588,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
         private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
         private boolean useNativeTransport = defaultUseNativeTransport();
+        private boolean usePooledMemory = defaultUsePooledMemory();
         private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
         private EventLoopGroup eventLoopGroup;
         private Timer nettyTimer;
@@ -639,6 +656,7 @@ public Builder(AsyncHttpClientConfig config) {
             channelOptions.putAll(config.getChannelOptions());
             eventLoopGroup = config.getEventLoopGroup();
             useNativeTransport = config.isUseNativeTransport();
+            usePooledMemory = config.isUsePooledMemory();
             nettyTimer = config.getNettyTimer();
             threadFactory = config.getThreadFactory();
             httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
@@ -676,7 +694,7 @@ public Builder setRealm(Realm realm) {
             this.realm = realm;
             return this;
         }
-        
+
         public Builder setRealm(Realm.Builder realmBuilder) {
             this.realm = realmBuilder.build();
             return this;
@@ -707,11 +725,16 @@ public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
             return this;
         }
 
+        public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
+            this.validateResponseHeaders = validateResponseHeaders;
+            return this;
+        }
+
         public Builder setProxyServer(ProxyServer proxyServer) {
             this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
             return this;
         }
-        
+
         public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
             this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServerBuilder.build());
             return this;
@@ -918,6 +941,11 @@ public Builder setUseNativeTransport(boolean useNativeTransport) {
             return this;
         }
 
+        public Builder setUsePooledMemory(boolean usePooledMemory) {
+            this.usePooledMemory = usePooledMemory;
+            return this;
+        }
+
         public Builder setNettyTimer(Timer nettyTimer) {
             this.nettyTimer = nettyTimer;
             return this;
@@ -970,6 +998,7 @@ public DefaultAsyncHttpClientConfig build() {
                     disableZeroCopy, //
                     keepEncodingHeader, //
                     resolveProxyServerSelector(), //
+                    validateResponseHeaders, //
                     connectTimeout, //
                     requestTimeout, //
                     readTimeout, //
@@ -1004,6 +1033,7 @@ public DefaultAsyncHttpClientConfig build() {
                     channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
                     eventLoopGroup, //
                     useNativeTransport, //
+                    usePooledMemory, //
                     nettyTimer, //
                     threadFactory, //
                     httpAdditionalChannelInitializer, //
diff --git a/client/src/main/java/org/asynchttpclient/DefaultRequest.java b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
index 6c9111deb..652debabb 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultRequest.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
@@ -26,7 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -59,7 +59,7 @@
     private final int requestTimeout;
     private final long rangeOffset;
     private final Charset charset;
-    private final ConnectionPoolPartitioning connectionPoolPartitioning;
+    private final ChannelPoolPartitioning channelPoolPartitioning;
     private final NameResolver nameResolver;
     // lazily loaded
     private List<Param> queryParams;
@@ -87,7 +87,7 @@ public DefaultRequest(String method,//
             int requestTimeout,//
             long rangeOffset,//
             Charset charset,//
-            ConnectionPoolPartitioning connectionPoolPartitioning,//
+            ChannelPoolPartitioning channelPoolPartitioning,//
             NameResolver nameResolver) {
         this.method = method;
         this.uri = uri;
@@ -112,7 +112,7 @@ public DefaultRequest(String method,//
         this.requestTimeout = requestTimeout;
         this.rangeOffset = rangeOffset;
         this.charset = charset;
-        this.connectionPoolPartitioning = connectionPoolPartitioning;
+        this.channelPoolPartitioning = channelPoolPartitioning;
         this.nameResolver = nameResolver;
     }
 
@@ -237,8 +237,8 @@ public Charset getCharset() {
     }
 
     @Override
-    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
-        return connectionPoolPartitioning;
+    public ChannelPoolPartitioning getChannelPoolPartitioning() {
+        return channelPoolPartitioning;
     }
 
     @Override
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 257f67caa..ca678f3c1 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -13,7 +13,7 @@
  */
 package org.asynchttpclient;
 
-import io.netty.handler.codec.http.HttpMethod;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
 
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.proxy.ProxyServer;
@@ -35,35 +35,35 @@ public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
 
     // /////////// Request ////////////////
     public static RequestBuilder get(String url) {
-        return request(HttpMethod.GET.name(), url);
+        return request(GET, url);
     }
 
     public static RequestBuilder put(String url) {
-        return request(HttpMethod.PUT.name(), url);
+        return request(PUT, url);
     }
 
     public static RequestBuilder post(String url) {
-        return request(HttpMethod.POST.name(), url);
+        return request(POST, url);
     }
 
     public static RequestBuilder delete(String url) {
-        return request(HttpMethod.DELETE.name(), url);
+        return request(DELETE, url);
     }
 
     public static RequestBuilder head(String url) {
-        return request(HttpMethod.HEAD.name(), url);
+        return request(HEAD, url);
     }
 
     public static RequestBuilder options(String url) {
-        return request(HttpMethod.OPTIONS.name(), url);
+        return request(OPTIONS, url);
     }
 
     public static RequestBuilder path(String url) {
-        return request(HttpMethod.PATCH.name(), url);
+        return request(PATCH, url);
     }
 
     public static RequestBuilder trace(String url) {
-        return request(HttpMethod.TRACE.name(), url);
+        return request(TRACE, url);
     }
 
     public static RequestBuilder request(String method, String url) {
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 530e70537..4e4258251 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -20,26 +20,34 @@
 /**
  * A callback class used when an HTTP response body is received.
  */
-public interface HttpResponseBodyPart {
+public abstract class HttpResponseBodyPart {
+
+    private final boolean last;
+
+    public HttpResponseBodyPart(boolean last) {
+        this.last = last;
+    }
 
     /**
      * @return length of this part in bytes
      */
-    int length();
+    public abstract int length();
 
     /**
      * @return  the response body's part bytes received.
      */
-    byte[] getBodyPartBytes();
+    public abstract byte[] getBodyPartBytes();
 
     /**
      * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
      * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
      */
-    ByteBuffer getBodyByteBuffer();
+    public abstract ByteBuffer getBodyByteBuffer();
 
     /**
      * @return true if this is the last part.
      */
-    boolean isLast();
+    public boolean isLast() {
+        return last;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java b/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
index 743eaae9a..c1ed4bc11 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
@@ -17,35 +17,28 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 
-
 /**
  * A class that represent the HTTP headers.
  */
-public abstract class HttpResponseHeaders {
+public class HttpResponseHeaders {
 
-    private final boolean traillingHeaders;
+    private final HttpHeaders headers;
+    private final boolean trailling;
 
-    public HttpResponseHeaders() {
-        this.traillingHeaders = false;
+    public HttpResponseHeaders(HttpHeaders headers) {
+        this(headers, false);
     }
 
-    public HttpResponseHeaders(boolean traillingHeaders) {
-        this.traillingHeaders = traillingHeaders;
+    public HttpResponseHeaders(HttpHeaders headers, boolean trailling) {
+        this.headers = headers;
+        this.trailling = trailling;
     }
 
-    /**
-     * Return the HTTP header
-     *
-     * @return an {@link HttpHeaders}
-     */
-    abstract public HttpHeaders getHeaders();
+    public HttpHeaders getHeaders() {
+        return headers;
+    }
 
-    /**
-     * Return true is headers has been received after the response body.
-     *
-     * @return true is headers has been received after the response body.
-     */
-    public boolean isTraillingHeadersReceived() {
-        return traillingHeaders;
+    public boolean isTrailling() {
+        return trailling;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index 04c244adb..722f5c0a2 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -17,7 +17,6 @@
 package org.asynchttpclient;
 
 import java.net.SocketAddress;
-import java.util.List;
 
 import org.asynchttpclient.uri.Uri;
 
@@ -43,15 +42,6 @@ public final Uri getUri() {
         return uri;
     }
 
-    /**
-     * Prepare a {@link Response}
-     * 
-     * @param headers {@link HttpResponseHeaders}
-     * @param bodyParts list of {@link HttpResponseBodyPart}
-     * @return a {@link Response}
-     */
-    public abstract Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts);
-
     /**
      * Return the response status code
      * 
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index db5db23e2..6be3f91a5 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -101,7 +101,6 @@ public String getPassword() {
     }
 
     public AuthScheme getScheme() {
-
         return scheme;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/Request.java b/client/src/main/java/org/asynchttpclient/Request.java
index ee7824f6a..227c45609 100644
--- a/client/src/main/java/org/asynchttpclient/Request.java
+++ b/client/src/main/java/org/asynchttpclient/Request.java
@@ -23,10 +23,9 @@
 import java.net.InetAddress;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import java.util.Collection;
 import java.util.List;
 
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -74,11 +73,11 @@
     HttpHeaders getHeaders();
 
     /**
-     * Return Coookie.
+     * Return cookies.
      *
      * @return an unmodifiable Collection of Cookies
      */
-    Collection<Cookie> getCookies();
+    List<Cookie> getCookies();
 
     /**
      * Return the current request's body as a byte array
@@ -203,7 +202,7 @@
      */
     Charset getCharset();
 
-    ConnectionPoolPartitioning getConnectionPoolPartitioning();
+    ChannelPoolPartitioning getChannelPoolPartitioning();
 
     NameResolver getNameResolver();
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilder.java b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
index 2c4599d80..bd9bbb61c 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -15,26 +15,35 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+
 /**
- * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware
- * that it holds a reference on the Request instance it builds, so modifying the
- * builder will modify the request even after it has been built.
+ * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds, so modifying the builder will modify the
+ * request even after it has been built.
  */
 public class RequestBuilder extends RequestBuilderBase<RequestBuilder> {
 
     public RequestBuilder() {
-        this("GET");
+        this(GET);
     }
 
     public RequestBuilder(String method) {
-        super(method, false);
+        this(method, false);
     }
 
     public RequestBuilder(String method, boolean disableUrlEncoding) {
         super(method, disableUrlEncoding);
     }
 
+    public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(method, disableUrlEncoding, validateHeaders);
+    }
+
     public RequestBuilder(Request prototype) {
         super(prototype);
     }
+
+    public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(prototype, disableUrlEncoding, validateHeaders);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index 2db75c57f..e9e92facb 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -31,7 +31,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -66,7 +66,7 @@
     protected Uri uri;
     protected InetAddress address;
     protected InetAddress localAddress;
-    protected HttpHeaders headers = new DefaultHttpHeaders();
+    protected HttpHeaders headers;
     protected ArrayList<Cookie> cookies;
     protected byte[] byteData;
     protected List<byte[]> compositeByteData;
@@ -85,24 +85,30 @@
     protected int requestTimeout;
     protected long rangeOffset;
     protected Charset charset;
-    protected ConnectionPoolPartitioning connectionPoolPartitioning = ConnectionPoolPartitioning.PerHostConnectionPoolPartitioning.INSTANCE;
+    protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
     protected NameResolver nameResolver = JdkNameResolver.INSTANCE;
 
     protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
+        this(method, disableUrlEncoding, true);
+    }
+
+    protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
         this.method = method;
         this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+        this.headers = new DefaultHttpHeaders(validateHeaders);
     }
 
     protected RequestBuilderBase(Request prototype) {
-        this(prototype, false);
+        this(prototype, false, false);
     }
 
-    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding) {
+    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
         this.method = prototype.getMethod();
         this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
         this.uri = prototype.getUri();
         this.address = prototype.getAddress();
         this.localAddress = prototype.getLocalAddress();
+        this.headers = new DefaultHttpHeaders(validateHeaders);
         this.headers.add(prototype.getHeaders());
         if (isNonEmpty(prototype.getCookies())) {
             this.cookies = new ArrayList<>(prototype.getCookies());
@@ -128,7 +134,7 @@ protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding) {
         this.requestTimeout = prototype.getRequestTimeout();
         this.rangeOffset = prototype.getRangeOffset();
         this.charset = prototype.getCharset();
-        this.connectionPoolPartitioning = prototype.getConnectionPoolPartitioning();
+        this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
         this.nameResolver = prototype.getNameResolver();
     }
 
@@ -177,12 +183,15 @@ public T addHeader(CharSequence name, String value) {
     }
 
     public T setHeaders(HttpHeaders headers) {
-        this.headers = headers == null ? new DefaultHttpHeaders() : headers;
+        if (headers == null)
+            this.headers.clear();
+        else
+            this.headers = headers;
         return asDerivedType();
     }
 
     public T setHeaders(Map<String, Collection<String>> headers) {
-        this.headers = new DefaultHttpHeaders();
+        this.headers.clear();
         if (headers != null) {
             for (Map.Entry<String, Collection<String>> entry : headers.entrySet()) {
                 String headerName = entry.getKey();
@@ -376,7 +385,7 @@ public T setProxyServer(ProxyServer proxyServer) {
         this.proxyServer = proxyServer;
         return asDerivedType();
     }
-    
+
     public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
         this.proxyServer = proxyServerBuilder.build();
         return asDerivedType();
@@ -412,8 +421,8 @@ public T setCharset(Charset charset) {
         return asDerivedType();
     }
 
-    public T setConnectionPoolPartitioning(ConnectionPoolPartitioning connectionPoolPartitioning) {
-        this.connectionPoolPartitioning = connectionPoolPartitioning;
+    public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
+        this.channelPoolPartitioning = channelPoolPartitioning;
         return asDerivedType();
     }
 
@@ -467,7 +476,7 @@ public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
         rb.requestTimeout = this.requestTimeout;
         rb.rangeOffset = this.rangeOffset;
         rb.charset = this.charset;
-        rb.connectionPoolPartitioning = this.connectionPoolPartitioning;
+        rb.channelPoolPartitioning = this.channelPoolPartitioning;
         rb.nameResolver = this.nameResolver;
         Request unsignedRequest = rb.build();
         signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
@@ -529,12 +538,12 @@ public Request build() {
         Uri finalUri = rb.computeUri();
         Charset finalCharset = rb.computeCharset();
         long finalContentLength = rb.computeRequestContentLength();
-        
+
         // make copies of mutable internal collections
         List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
         List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
         List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
-        
+
         return new DefaultRequest(rb.method,//
                 finalUri,//
                 rb.address,//
@@ -558,7 +567,7 @@ public Request build() {
                 rb.requestTimeout,//
                 rb.rangeOffset,//
                 finalCharset,//
-                rb.connectionPoolPartitioning,//
+                rb.channelPoolPartitioning,//
                 rb.nameResolver);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Response.java b/client/src/main/java/org/asynchttpclient/Response.java
index 6422e1f08..50fe390da 100644
--- a/client/src/main/java/org/asynchttpclient/Response.java
+++ b/client/src/main/java/org/asynchttpclient/Response.java
@@ -17,6 +17,7 @@
 package org.asynchttpclient;
 
 import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.netty.NettyResponse;
 import org.asynchttpclient.uri.Uri;
 
 import io.netty.handler.codec.http.HttpHeaders;
@@ -70,8 +71,7 @@
     /**
      * Return the entire response body as a String.
      * 
-     * @param charset
-     *            the charset to use when decoding the stream
+     * @param charset the charset to use when decoding the stream
      * @return the entire response body as a String.
      */
     String getResponseBody(Charset charset);
@@ -158,19 +158,17 @@
     /**
      * Get remote address client initiated request to.
      * 
-     * @return remote address client initiated request to, may be {@code null}
-     *         if asynchronous provider is unable to provide the remote address
+     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
      */
     SocketAddress getRemoteAddress();
 
     /**
      * Get local address client initiated request from.
      * 
-     * @return local address client initiated request from, may be {@code null}
-     *         if asynchronous provider is unable to provide the local address
+     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
      */
     SocketAddress getLocalAddress();
-    
+
     class ResponseBuilder {
         private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>();
         private HttpResponseStatus status;
@@ -182,13 +180,12 @@ public ResponseBuilder accumulate(HttpResponseStatus status) {
         }
 
         public ResponseBuilder accumulate(HttpResponseHeaders headers) {
-            this.headers = headers;
+            this.headers = this.headers == null ? headers : new HttpResponseHeaders(this.headers.getHeaders().add(headers.getHeaders()), true);
             return this;
         }
 
         /**
-         * @param bodyPart
-         *            a body part (possibly empty, but will be filtered out)
+         * @param bodyPart a body part (possibly empty, but will be filtered out)
          * @return this
          */
         public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
@@ -203,7 +200,7 @@ public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
          * @return a {@link Response} instance
          */
         public Response build() {
-            return status == null ? null : status.prepareResponse(headers, bodyParts);
+            return status == null ? null : new NettyResponse(status, headers, bodyParts);
         }
 
         /**
diff --git a/client/src/main/java/org/asynchttpclient/ResponseBase.java b/client/src/main/java/org/asynchttpclient/ResponseBase.java
deleted file mode 100644
index 2672e2f85..000000000
--- a/client/src/main/java/org/asynchttpclient/ResponseBase.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.asynchttpclient;
-
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.net.SocketAddress;
-import java.nio.charset.Charset;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
-
-public abstract class ResponseBase implements Response {
-
-    protected final List<HttpResponseBodyPart> bodyParts;
-    protected final HttpResponseHeaders headers;
-    protected final HttpResponseStatus status;
-    private List<Cookie> cookies;
-
-    protected ResponseBase(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        this.bodyParts = bodyParts;
-        this.headers = headers;
-        this.status = status;
-    }
-
-    protected abstract List<Cookie> buildCookies();
-
-    protected Charset calculateCharset(Charset charset) {
-
-        if (charset == null) {
-            String contentType = getContentType();
-            if (contentType != null)
-                charset = parseCharset(contentType); // parseCharset can return
-                                                     // null
-        }
-        return charset != null ? charset : DEFAULT_CHARSET;
-    }
-
-    @Override
-    public final int getStatusCode() {
-        return status.getStatusCode();
-    }
-
-    @Override
-    public final String getStatusText() {
-        return status.getStatusText();
-    }
-
-    @Override
-    public final Uri getUri() {
-        return status.getUri();
-    }
-
-    @Override
-    public SocketAddress getRemoteAddress() {
-        return status.getRemoteAddress();
-    }
-
-    @Override
-    public SocketAddress getLocalAddress() {
-        return status.getLocalAddress();
-    }
-
-    @Override
-    public final String getContentType() {
-        return headers != null ? getHeader("Content-Type") : null;
-    }
-
-    @Override
-    public final String getHeader(String name) {
-        return headers != null ? getHeaders().get(name) : null;
-    }
-
-    @Override
-    public final List<String> getHeaders(String name) {
-        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
-    }
-
-    @Override
-    public final HttpHeaders getHeaders() {
-        return headers != null ? headers.getHeaders() : HttpHeaders.EMPTY_HEADERS;
-    }
-
-    @Override
-    public final boolean isRedirected() {
-        switch (status.getStatusCode()) {
-        case 301:
-        case 302:
-        case 303:
-        case 307:
-        case 308:
-            return true;
-        default:
-            return false;
-        }
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-
-        if (headers == null) {
-            return Collections.emptyList();
-        }
-
-        if (cookies == null) {
-            cookies = buildCookies();
-        }
-        return cookies;
-
-    }
-
-    @Override
-    public boolean hasResponseStatus() {
-        return status != null;
-    }
-
-    @Override
-    public boolean hasResponseHeaders() {
-        return headers != null && !headers.getHeaders().isEmpty();
-    }
-
-    @Override
-    public boolean hasResponseBody() {
-        return isNonEmpty(bodyParts);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(getClass().getSimpleName()).append(" {\n")//
-        .append("\tstatusCode=").append(getStatusCode()).append("\n")//
-        .append("\theaders=\n");
-        
-        for (Map.Entry<String, String> header: getHeaders()) {
-            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
-        }
-        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
-                .append("}").toString();
-        return sb.toString();
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
similarity index 97%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
index 348dd2e4d..f8cea67fe 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.channel;
 
 import io.netty.channel.Channel;
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
similarity index 94%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
index ea39a8ef9..4abc3c602 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.channel;
 
 public interface ChannelPoolPartitionSelector {
 
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
similarity index 93%
rename from client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
index 7687ae83d..20d9e8c30 100644
--- a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.channel.pool;
+package org.asynchttpclient.channel;
 
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.HttpUtils;
 
-public interface ConnectionPoolPartitioning {
+public interface ChannelPoolPartitioning {
 
     class ProxyPartitionKey {
         private final String proxyHost;
@@ -44,7 +44,7 @@ public String toString() {
 
     Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
 
-    enum PerHostConnectionPoolPartitioning implements ConnectionPoolPartitioning {
+    enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
 
         INSTANCE;
 
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
similarity index 98%
rename from client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
rename to client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
index 1c498ddb8..2e2dc6e76 100644
--- a/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.channel.pool;
+package org.asynchttpclient.channel;
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
 import static io.netty.handler.codec.http.HttpHeaders.Values.*;
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
similarity index 91%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
rename to client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
index ea38e4637..56c217dd5 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
@@ -11,9 +11,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.channel;
 
-import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.channel.ChannelPoolPartitionSelector;
 
 import io.netty.channel.Channel;
 
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index 9830912d8..6d3f966ec 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -79,6 +79,10 @@ public static boolean defaultUseProxyProperties() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties");
     }
 
+    public static boolean defaultValidateResponseHeaders() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "validateResponseHeaders");
+    }
+
     public static boolean defaultStrict302Handling() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
     }
@@ -158,4 +162,8 @@ public static int defaultShutdownTimeout() {
     public static boolean defaultUseNativeTransport() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
     }
+
+    public static boolean defaultUsePooledMemory() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "usePooledMemory");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
index ab657edf1..74896bca5 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -12,20 +12,63 @@
  */
 package org.asynchttpclient.cookie;
 
-import org.asynchttpclient.util.StringUtils;
-
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Comparator;
+
+import org.asynchttpclient.util.StringUtils;
 
 public final class CookieEncoder {
 
+    /**
+     * Sort cookies into decreasing order of path length, breaking ties by sorting into increasing chronological order of creation time, as recommended by RFC 6265.
+     */
+    private static final Comparator<Cookie> COOKIE_COMPARATOR = new Comparator<Cookie>() {
+        @Override
+        public int compare(Cookie c1, Cookie c2) {
+            String path1 = c1.getPath();
+            String path2 = c2.getPath();
+            // Cookies with unspecified path default to the path of the request. We don't
+            // know the request path here, but we assume that the length of an unspecified
+            // path is longer than any specified path (i.e. pathless cookies come first),
+            // because setting cookies with a path longer than the request path is of
+            // limited use.
+            int len1 = path1 == null ? Integer.MAX_VALUE : path1.length();
+            int len2 = path2 == null ? Integer.MAX_VALUE : path2.length();
+            int diff = len2 - len1;
+            if (diff != 0) {
+                return diff;
+            }
+            // Rely on Java's sort stability to retain creation order in cases where
+            // cookies have same path length.
+            return -1;
+        }
+    };
+
     private CookieEncoder() {
     }
 
     public static String encode(Collection<Cookie> cookies) {
         StringBuilder sb = StringUtils.stringBuilder();
 
-        for (Cookie cookie : cookies) {
-            add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+        if (cookies.isEmpty()) {
+            return "";
+
+        } else if (cookies.size() == 1) {
+            Cookie cookie = cookies.iterator().next();
+            if (cookie != null) {
+                add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+            }
+
+        } else {
+            Cookie[] cookiesSorted = cookies.toArray(new Cookie[cookies.size()]);
+            Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);
+            for (int i = 0; i < cookiesSorted.length; i++) {
+                Cookie cookie = cookiesSorted[i];
+                if (cookie != null) {
+                    add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+                }
+            }
         }
 
         if (sb.length() > 0) {
diff --git a/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
new file mode 100644
index 000000000..93bbf7fad
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
+
+@SuppressWarnings("serial")
+public final class ChannelClosedException extends IOException {
+
+    public static final ChannelClosedException INSTANCE = trimStackTrace(new ChannelClosedException());
+
+    private ChannelClosedException() {
+        super("Channel closed");
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
new file mode 100644
index 000000000..2209fb2ef
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
+
+@SuppressWarnings("serial")
+public class PoolAlreadyClosedException extends IOException {
+
+    public static final PoolAlreadyClosedException INSTANCE = trimStackTrace(new PoolAlreadyClosedException());
+
+    private PoolAlreadyClosedException() {
+        super("Pool is already closed");
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
new file mode 100644
index 000000000..a3df8ef19
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
+
+@SuppressWarnings("serial")
+public final class RemotelyClosedException extends IOException {
+
+    public static final RemotelyClosedException INSTANCE = trimStackTrace(new RemotelyClosedException());
+    
+    public RemotelyClosedException() {
+        super("Remotely closed");
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
new file mode 100644
index 000000000..2685e3a95
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+@SuppressWarnings("serial")
+public class TooManyConnectionsException extends IOException {
+
+    public TooManyConnectionsException(int max) {
+        super("Too many connections: " + max);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
new file mode 100644
index 000000000..a08a22ee3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+@SuppressWarnings("serial")
+public class TooManyConnectionsPerHostException extends IOException {
+
+    public TooManyConnectionsPerHostException(int max) {
+        super("Too many connections: " + max);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
index fb36ddf3f..167b4003d 100644
--- a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
@@ -29,27 +29,27 @@
     // ////////// DNS /////////////////
 
     /**
-     * Notify the callback before DNS resolution
+     * Notify the callback before hostname resolution
      * 
      * @param name the name to be resolved
      */
-    void onDnsResolution(String name);
+    void onHostnameResolutionAttempt(String name);
 
     /**
-     * Notify the callback after DNS resolution was successful.
+     * Notify the callback after hostname resolution was successful.
      * 
      * @param name the name to be resolved
      * @param addresses the resolved addresses
      */
-    void onDnsResolutionSuccess(String name, List<InetSocketAddress> addresses);
+    void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses);
 
     /**
-     * Notify the callback after DNS resolution failed.
+     * Notify the callback after hostname resolution failed.
      * 
      * @param name the name to be resolved
      * @param cause the failure cause
      */
-    void onDnsResolutionFailure(String name, Throwable cause);
+    void onHostnameResolutionFailure(String name, Throwable cause);
 
     // ////////////// TCP CONNECT ////////
 
@@ -60,7 +60,7 @@
      * 
      * @param remoteAddress the address we try to connect to
      */
-    void onTcpConnect(InetSocketAddress remoteAddress);
+    void onTcpConnectAttempt(InetSocketAddress remoteAddress);
 
     /**
      * Notify the callback after a successful connect
@@ -85,7 +85,7 @@
     /**
      * Notify the callback before TLS handshake
      */
-    void onTlsHandshake();
+    void onTlsHandshakeAttempt();
 
     /**
      * Notify the callback after the TLS was successful
@@ -104,7 +104,7 @@
     /**
      * Notify the callback when trying to fetch a connection from the pool.
      */
-    void onConnectionPool();
+    void onConnectionPoolAttempt();
 
     /**
      * Notify the callback when a new connection was successfully fetched from the pool.
diff --git a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
index a46cf09aa..6c173d4a3 100644
--- a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
@@ -24,19 +24,19 @@
 public abstract class ExtendedAsyncHandler<T> implements AsyncHandler<T>, AsyncHandlerExtensions {
 
     @Override
-    public void onDnsResolution(String name) {
+    public void onHostnameResolutionAttempt(String name) {
     }
 
     @Override
-    public void onDnsResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
     }
 
     @Override
-    public void onDnsResolutionFailure(String name, Throwable cause) {
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
     }
 
     @Override
-    public void onTcpConnect(InetSocketAddress address) {
+    public void onTcpConnectAttempt(InetSocketAddress address) {
     }
 
     @Override
@@ -48,7 +48,7 @@ public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause
     }
 
     @Override
-    public void onTlsHandshake() {
+    public void onTlsHandshakeAttempt() {
     }
 
     @Override
@@ -60,7 +60,7 @@ public void onTlsHandshakeFailure(Throwable cause) {
     }
 
     @Override
-    public void onConnectionPool() {
+    public void onConnectionPoolAttempt() {
     }
 
     @Override
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
similarity index 85%
rename from client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index 384b99d26..f8020d260 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,20 +12,22 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
+import static org.asynchttpclient.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.HttpResponseBodyPart;
+
 /**
  * A callback class used when an HTTP response body is received.
  * Bytes are eagerly fetched from the ByteBuf
  */
-public class EagerNettyResponseBodyPart extends NettyResponseBodyPart {
+public class EagerResponseBodyPart extends HttpResponseBodyPart {
 
     private final byte[] bytes;
 
-    public EagerNettyResponseBodyPart(ByteBuf buf, boolean last) {
+    public EagerResponseBodyPart(ByteBuf buf, boolean last) {
         super(last);
         bytes = byteBuf2Bytes(buf);
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
similarity index 86%
rename from client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index b9b30ed36..02159fb85 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -16,16 +16,17 @@
 
 import java.nio.ByteBuffer;
 
-import org.asynchttpclient.netty.util.ByteBufUtils;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.util.ByteBufUtils;
 
 /**
  * A callback class used when an HTTP response body is received.
  */
-public class LazyNettyResponseBodyPart extends NettyResponseBodyPart {
+public class LazyResponseBodyPart extends HttpResponseBodyPart {
 
     private final ByteBuf buf;
 
-    public LazyNettyResponseBodyPart(ByteBuf buf, boolean last) {
+    public LazyResponseBodyPart(ByteBuf buf, boolean last) {
         super(last);
         this.buf = buf;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
index 935839c24..2e7e788f2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -13,41 +13,53 @@
  */
 package org.asynchttpclient.netty;
 
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static org.asynchttpclient.util.HttpUtils.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.ResponseBase;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
-public class NettyResponse extends ResponseBase {
+public class NettyResponse implements Response {
+
+    private final List<HttpResponseBodyPart> bodyParts;
+    private final HttpResponseHeaders headers;
+    private final HttpResponseStatus status;
+    private List<Cookie> cookies;
 
     public NettyResponse(HttpResponseStatus status,//
             HttpResponseHeaders headers,//
             List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
+        this.bodyParts = bodyParts;
+        this.headers = headers;
+        this.status = status;
     }
 
-    protected List<Cookie> buildCookies() {
+    private List<Cookie> buildCookies() {
 
-        List<String> setCookieHeaders = headers.getHeaders().getAll(HttpHeaders.Names.SET_COOKIE2);
+        List<String> setCookieHeaders = headers.getHeaders().getAll(SET_COOKIE2);
 
         if (!isNonEmpty(setCookieHeaders)) {
-            setCookieHeaders = headers.getHeaders().getAll(HttpHeaders.Names.SET_COOKIE);
+            setCookieHeaders = headers.getHeaders().getAll(SET_COOKIE);
         }
 
         if (isNonEmpty(setCookieHeaders)) {
@@ -63,6 +75,94 @@ public NettyResponse(HttpResponseStatus status,//
         return Collections.emptyList();
     }
 
+    @Override
+    public final int getStatusCode() {
+        return status.getStatusCode();
+    }
+
+    @Override
+    public final String getStatusText() {
+        return status.getStatusText();
+    }
+
+    @Override
+    public final Uri getUri() {
+        return status.getUri();
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return status.getRemoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return status.getLocalAddress();
+    }
+
+    @Override
+    public final String getContentType() {
+        return headers != null ? getHeader(CONTENT_TYPE) : null;
+    }
+
+    @Override
+    public final String getHeader(String name) {
+        return headers != null ? getHeaders().get(name) : null;
+    }
+
+    @Override
+    public final List<String> getHeaders(String name) {
+        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
+    }
+
+    @Override
+    public final HttpHeaders getHeaders() {
+        return headers != null ? headers.getHeaders() : HttpHeaders.EMPTY_HEADERS;
+    }
+
+    @Override
+    public final boolean isRedirected() {
+        switch (status.getStatusCode()) {
+        case 301:
+        case 302:
+        case 303:
+        case 307:
+        case 308:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+
+        if (headers == null) {
+            return Collections.emptyList();
+        }
+
+        if (cookies == null) {
+            cookies = buildCookies();
+        }
+        return cookies;
+
+    }
+
+    @Override
+    public boolean hasResponseStatus() {
+        return status != null;
+    }
+
+    @Override
+    public boolean hasResponseHeaders() {
+        return headers != null && !headers.getHeaders().isEmpty();
+    }
+
+    @Override
+    public boolean hasResponseBody() {
+        return isNonEmpty(bodyParts);
+    }
+
     @Override
     public byte[] getResponseBodyAsBytes() {
         return getResponseBodyAsByteBuffer().array();
@@ -87,13 +187,39 @@ public String getResponseBody() {
         return getResponseBody(null);
     }
 
+    private Charset computeCharset(Charset charset) {
+
+        if (charset == null) {
+            String contentType = getContentType();
+            if (contentType != null)
+                charset = parseCharset(contentType); // parseCharset can return
+                                                     // null
+        }
+        return charset != null ? charset : DEFAULT_CHARSET;
+    }
+
     @Override
     public String getResponseBody(Charset charset) {
-        return new String(getResponseBodyAsBytes(), calculateCharset(charset));
+        return new String(getResponseBodyAsBytes(), computeCharset(charset));
     }
 
     @Override
     public InputStream getResponseBodyAsStream() {
         return new ByteArrayInputStream(getResponseBodyAsBytes());
     }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(getClass().getSimpleName()).append(" {\n")//
+                .append("\tstatusCode=").append(getStatusCode()).append("\n")//
+                .append("\theaders=\n");
+
+        for (Map.Entry<String, String> header : getHeaders()) {
+            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
+        }
+        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
+                .append("}").toString();
+        return sb.toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 65c300996..cded6d631 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -16,9 +16,7 @@
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import static org.asynchttpclient.util.MiscUtils.getCause;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpHeaders;
 
-import java.net.SocketAddress;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
@@ -35,7 +33,7 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.future.AbstractListenableFuture;
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
@@ -56,7 +54,7 @@
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
 
     private final long start = millisTime();
-    private final ConnectionPoolPartitioning connectionPoolPartitioning;
+    private final ChannelPoolPartitioning connectionPoolPartitioning;
     private final ProxyServer proxyServer;
     private final int maxRetry;
     private final CountDownLatch latch = new CountDownLatch(1);
@@ -84,7 +82,6 @@
     private Request targetRequest;
     private Request currentRequest;
     private NettyRequest nettyRequest;
-    private HttpHeaders httpHeaders;
     private AsyncHandler<V> asyncHandler;
     private boolean streamWasAlreadyConsumed;
     private boolean reuseChannel;
@@ -98,7 +95,7 @@ public NettyResponseFuture(Request originalRequest,//
             AsyncHandler<V> asyncHandler,//
             NettyRequest nettyRequest,//
             int maxRetry,//
-            ConnectionPoolPartitioning connectionPoolPartitioning,//
+            ChannelPoolPartitioning connectionPoolPartitioning,//
             ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
@@ -274,7 +271,7 @@ public Uri getUri() {
         return targetRequest.getUri();
     }
 
-    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
+    public ChannelPoolPartitioning getConnectionPoolPartitioning() {
         return connectionPoolPartitioning;
     }
 
@@ -321,14 +318,6 @@ public final void setKeepAlive(final boolean keepAlive) {
         this.keepAlive = keepAlive;
     }
 
-    public final HttpHeaders getHttpHeaders() {
-        return httpHeaders;
-    }
-
-    public final void setHttpHeaders(HttpHeaders httpHeaders) {
-        this.httpHeaders = httpHeaders;
-    }
-
     public int incrementAndGetCurrentRedirectCount() {
         return redirectCount.incrementAndGet();
     }
@@ -420,10 +409,6 @@ public boolean canRetry() {
         return maxRetry > 0 && currentRetry.incrementAndGet() <= maxRetry;
     }
 
-    public SocketAddress getChannelRemoteAddress() {
-        return channel != null ? channel.remoteAddress() : null;
-    }
-
     public void setTargetRequest(Request targetRequest) {
         this.targetRequest = targetRequest;
     }
@@ -477,7 +462,6 @@ public String toString() {
                 ",\n\tcontent=" + content + //
                 ",\n\turi=" + getUri() + //
                 ",\n\tkeepAlive=" + keepAlive + //
-                ",\n\thttpHeaders=" + httpHeaders + //
                 ",\n\texEx=" + exEx + //
                 ",\n\tredirectCount=" + redirectCount + //
                 ",\n\ttimeoutsHolder=" + timeoutsHolder + //
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
deleted file mode 100755
index 878580774..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty;
-
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.Map;
-
-import org.asynchttpclient.HttpResponseHeaders;
-
-/**
- * A class that represent the HTTP headers.
- */
-public class NettyResponseHeaders extends HttpResponseHeaders {
-
-    private final HttpHeaders responseHeaders;
-    private final HttpHeaders trailingHeaders;
-    private final HttpHeaders headers;
-
-    public NettyResponseHeaders(HttpHeaders responseHeaders) {
-        this(responseHeaders, null);
-    }
-
-    public NettyResponseHeaders(HttpHeaders responseHeaders, HttpHeaders traillingHeaders) {
-        super(traillingHeaders != null);
-        this.responseHeaders = responseHeaders;
-        this.trailingHeaders = traillingHeaders;
-        headers = computerHeaders();
-    }
-
-    private HttpHeaders computerHeaders() {
-        HttpHeaders h = new DefaultHttpHeaders();
-        for (Map.Entry<String, String> header : responseHeaders) {
-            h.add(header.getKey(), header.getValue());
-        }
-
-        if (trailingHeaders != null) {
-            for (Map.Entry<String, String> header : trailingHeaders) {
-                h.add(header.getKey(), header.getValue());
-            }
-        }
-
-        return h;
-    }
-
-    @Override
-    public HttpHeaders getHeaders() {
-        return headers;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
index b593868b3..1dde7159a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -17,13 +17,9 @@
 import io.netty.handler.codec.http.HttpResponse;
 
 import java.net.SocketAddress;
-import java.util.List;
 
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -47,11 +43,6 @@ public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse r
         }
     }
 
-    @Override
-    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(this, headers, bodyParts);
-    }
-
     /**
      * Return the response status code
      * 
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleGenericFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
similarity index 85%
rename from client/src/main/java/org/asynchttpclient/netty/SimpleGenericFutureListener.java
rename to client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
index 74f255005..f10f9ff4c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/SimpleGenericFutureListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
@@ -14,14 +14,14 @@
 package org.asynchttpclient.netty;
 
 import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.FutureListener;
 
-public abstract class SimpleGenericFutureListener<V> implements GenericFutureListener<Future<V>> {
+public abstract class SimpleFutureListener<V> implements FutureListener<V> {
 
     @Override
     public final void operationComplete(Future<V> future) throws Exception {
         if (future.isSuccess()) {
-            onSuccess(future.get());
+            onSuccess(future.getNow());
         } else {
             onFailure(future.cause());
         }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 20b9abb97..45af97ea0 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -13,9 +13,10 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.util.MiscUtils.buildStaticIOException;
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
@@ -34,11 +35,12 @@
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.util.Timer;
 import io.netty.util.concurrent.DefaultThreadFactory;
-import io.netty.util.concurrent.GenericFutureListener;
-import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
 
 import java.io.IOException;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
@@ -49,13 +51,15 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.SslEngineFactory;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.channel.NoopChannelPool;
+import org.asynchttpclient.exception.PoolAlreadyClosedException;
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.netty.channel.pool.DefaultChannelPool;
-import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
 import org.asynchttpclient.netty.handler.HttpProtocol;
 import org.asynchttpclient.netty.handler.WebSocketProtocol;
@@ -85,22 +89,19 @@
     private final SslEngineFactory sslEngineFactory;
     private final EventLoopGroup eventLoopGroup;
     private final boolean allowReleaseEventLoopGroup;
-    private final Class<? extends Channel> socketChannelClass;
     private final Bootstrap httpBootstrap;
     private final Bootstrap wsBootstrap;
     private final long handshakeTimeout;
     private final IOException tooManyConnections;
     private final IOException tooManyConnectionsPerHost;
-    private final IOException poolAlreadyClosed;
 
     private final ChannelPool channelPool;
     private final boolean maxTotalConnectionsEnabled;
     private final Semaphore freeChannels;
     private final ChannelGroup openChannels;
     private final boolean maxConnectionsPerHostEnabled;
-    private final ConcurrentHashMapV8<Object, Semaphore> freeChannelsPerHost;
-    private final ConcurrentHashMapV8<Channel, Object> channelId2PartitionKey;
-    private final ConcurrentHashMapV8.Fun<Object, Semaphore> semaphoreComputer;
+    private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();
 
     private AsyncHttpClientHandler wsHandler;
 
@@ -123,9 +124,8 @@ public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
         }
         this.channelPool = channelPool;
 
-        tooManyConnections = buildStaticIOException("Too many connections " + config.getMaxConnections());
-        tooManyConnectionsPerHost = buildStaticIOException("Too many connections per host " + config.getMaxConnectionsPerHost());
-        poolAlreadyClosed = buildStaticIOException("Pool is already closed");
+        tooManyConnections = trimStackTrace(new TooManyConnectionsException(config.getMaxConnections()));
+        tooManyConnectionsPerHost = trimStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));
         maxTotalConnectionsEnabled = config.getMaxConnections() > 0;
         maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
 
@@ -155,26 +155,12 @@ public boolean remove(Object o) {
             freeChannels = null;
         }
 
-        if (maxConnectionsPerHostEnabled) {
-            freeChannelsPerHost = new ConcurrentHashMapV8<>();
-            channelId2PartitionKey = new ConcurrentHashMapV8<>();
-            semaphoreComputer = new ConcurrentHashMapV8.Fun<Object, Semaphore>() {
-                @Override
-                public Semaphore apply(Object partitionKey) {
-                    return new Semaphore(config.getMaxConnectionsPerHost());
-                }
-            };
-        } else {
-            freeChannelsPerHost = null;
-            channelId2PartitionKey = null;
-            semaphoreComputer = null;
-        }
-
         handshakeTimeout = config.getHandshakeTimeout();
 
         // check if external EventLoopGroup is defined
         ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
         allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
+        Class<? extends Channel> socketChannelClass;
         if (allowReleaseEventLoopGroup) {
             if (config.isUseNativeTransport()) {
                 eventLoopGroup = newEpollEventLoopGroup(threadFactory);
@@ -197,23 +183,30 @@ public Semaphore apply(Object partitionKey) {
             }
         }
 
-        httpBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
-        wsBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
+        httpBootstrap = newBootstrap(socketChannelClass, eventLoopGroup, config);
+        wsBootstrap = newBootstrap(socketChannelClass, eventLoopGroup, config);
 
-        // default to PooledByteBufAllocator
-        httpBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
-        wsBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+        // for reactive streams
+        httpBootstrap.option(ChannelOption.AUTO_READ, false);
+    }
+
+    private Bootstrap newBootstrap(Class<? extends Channel> socketChannelClass, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
+        @SuppressWarnings("deprecation")
+        Bootstrap bootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup)//
+                // default to PooledByteBufAllocator
+                .option(ChannelOption.ALLOCATOR, config.isUsePooledMemory() ? PooledByteBufAllocator.DEFAULT : UnpooledByteBufAllocator.DEFAULT)//
+                .option(ChannelOption.TCP_NODELAY, true)//
+                .option(ChannelOption.AUTO_CLOSE, false);
 
         if (config.getConnectTimeout() > 0) {
-            httpBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
-            wsBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
         }
+
         for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
-            ChannelOption<Object> key = entry.getKey();
-            Object value = entry.getValue();
-            httpBootstrap.option(key, value);
-            wsBootstrap.option(key, value);
+            bootstrap.option(entry.getKey(), entry.getValue());
         }
+
+        return bootstrap;
     }
 
     private EventLoopGroup newEpollEventLoopGroup(ThreadFactory threadFactory) {
@@ -254,8 +247,6 @@ protected void initChannel(Channel ch) throws Exception {
                         .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
                         .addLast(AHC_HTTP_HANDLER, httpHandler);
 
-                ch.config().setOption(ChannelOption.AUTO_READ, false);
-
                 if (config.getHttpAdditionalChannelInitializer() != null)
                     config.getHttpAdditionalChannelInitializer().initChannel(ch);
             }
@@ -302,7 +293,7 @@ public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> async
         }
     }
 
-    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
+    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
         Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
         return channelPool.poll(partitionKey);
     }
@@ -316,7 +307,7 @@ private boolean tryAcquireGlobal() {
     }
 
     private Semaphore getFreeConnectionsForHost(Object partitionKey) {
-        return freeChannelsPerHost.computeIfAbsent(partitionKey, semaphoreComputer);
+        return freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new Semaphore(config.getMaxConnectionsPerHost()));
     }
 
     private boolean tryAcquirePerHost(Object partitionKey) {
@@ -325,7 +316,7 @@ private boolean tryAcquirePerHost(Object partitionKey) {
 
     public void preemptChannel(Object partitionKey) throws IOException {
         if (!channelPool.isOpen())
-            throw poolAlreadyClosed;
+            throw PoolAlreadyClosedException.INSTANCE;
         if (!tryAcquireGlobal())
             throw tooManyConnections;
         if (!tryAcquirePerHost(partitionKey)) {
@@ -352,14 +343,13 @@ private void doClose() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     public void close() {
         if (allowReleaseEventLoopGroup) {
-            io.netty.util.concurrent.Future whenEventLoopGroupClosed = eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(),
-                    TimeUnit.MILLISECONDS);
-
-            whenEventLoopGroupClosed.addListener((GenericFutureListener<?>) new GenericFutureListener<io.netty.util.concurrent.Future<?>>() {
-                public void operationComplete(io.netty.util.concurrent.Future<?> future) throws Exception {
-                    doClose();
-                };
-            });
+            eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)//
+                    .addListener(new FutureListener() {
+                        @Override
+                        public void operationComplete(Future future) throws Exception {
+                            doClose();
+                        }
+                    });
         } else
             doClose();
     }
@@ -367,8 +357,8 @@ public void operationComplete(io.netty.util.concurrent.Future<?> future) throws
     public void closeChannel(Channel channel) {
 
         LOGGER.debug("Closing Channel {} ", channel);
-        removeAll(channel);
         Channels.setDiscard(channel);
+        removeAll(channel);
         Channels.silentlyCloseChannel(channel);
         openChannels.remove(channel);
     }
@@ -392,7 +382,8 @@ private HttpClientCodec newHttpClientCodec() {
                 config.getHttpClientCodecMaxInitialLineLength(),//
                 config.getHttpClientCodecMaxHeaderSize(),//
                 config.getHttpClientCodecMaxChunkSize(),//
-                false);
+                false,//
+                config.isValidateResponseHeaders());
     }
 
     private SslHandler createSslHandler(String peerHost, int peerPort) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
similarity index 98%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
rename to client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 08f8cf7ab..494ec6fef 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.netty.channel;
 
 import static org.asynchttpclient.util.Assertions.*;
 import static org.asynchttpclient.util.DateUtils.millisTime;
@@ -30,8 +30,9 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.ChannelPoolPartitionSelector;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.Channels;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 144df04a3..c347edc95 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -24,7 +24,7 @@
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.SimpleChannelFutureListener;
-import org.asynchttpclient.netty.SimpleGenericFutureListener;
+import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.uri.Uri;
@@ -90,9 +90,9 @@ public void onSuccess(Channel channel) throws Exception {
             final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
 
             if (asyncHandlerExtensions != null)
-                asyncHandlerExtensions.onTlsHandshake();
+                asyncHandlerExtensions.onTlsHandshakeAttempt();
 
-            sslHandler.handshakeFuture().addListener(new SimpleGenericFutureListener<Channel>() {
+            sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
 
                 @Override
                 protected void onSuccess(Channel value) throws Exception {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index f0e73795c..b21a569ba 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -13,7 +13,6 @@
  */
 package org.asynchttpclient.netty.handler;
 
-import static org.asynchttpclient.util.HttpUtils.CHANNEL_CLOSED_EXCEPTION;
 import static org.asynchttpclient.util.MiscUtils.getCause;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -29,9 +28,10 @@
 import java.nio.channels.ClosedChannelException;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.exception.ChannelClosedException;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.DiscardEvent;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
@@ -89,7 +89,7 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
                     ByteBuf content = ((HttpContent) msg).content();
                     // Republish as a HttpResponseBodyPart
                     if (content.readableBytes() > 0) {
-                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
+                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
                         ctx.fireChannelRead(part);
                     }
                     if (msg instanceof LastHttpContent) {
@@ -148,7 +148,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             NettyResponseFuture<?> future = NettyResponseFuture.class.cast(attribute);
             future.touch();
 
-            if (!config.getIoExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+            if (!config.getIoExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
                 return;
 
             protocol.onClose(future);
@@ -186,7 +186,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
                     // FIXME why drop the original exception and throw a new
                     // one?
                     if (!config.getIoExceptionFilters().isEmpty()) {
-                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
                             // Close the channel so the recovering can occurs.
                             Channels.silentlyCloseChannel(channel);
                         return;
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
index e3751df3b..e43fcc02e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
@@ -13,9 +13,10 @@
  */
 package org.asynchttpclient.netty.handler;
 
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
 import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
@@ -32,15 +33,15 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
 import org.asynchttpclient.netty.Callback;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.NettyResponseHeaders;
 import org.asynchttpclient.netty.NettyResponseStatus;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.ChannelState;
@@ -148,7 +149,7 @@ private void finishUpdate(final NettyResponseFuture<?> future, Channel channel,
         }
     }
 
-    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
+    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart bodyPart) throws Exception {
         boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
         if (interrupt)
             future.setKeepAlive(false);
@@ -156,20 +157,17 @@ private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandl
     }
 
     private boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
-        if (statusCode == CONTINUE.code()) {
-            future.setHeadersAlreadyWrittenOnContinue(true);
-            future.setDontWriteBodyBecauseExpectContinue(false);
-            // directly send the body
-            Channels.setAttribute(channel, new Callback(future) {
-                @Override
-                public void call() throws IOException {
-                    Channels.setAttribute(channel, future);
-                    requestSender.writeRequest(future, channel);
-                }
-            });
-            return true;
-        }
-        return false;
+        future.setHeadersAlreadyWrittenOnContinue(true);
+        future.setDontWriteBodyBecauseExpectContinue(false);
+        // directly send the body
+        Channels.setAttribute(channel, new Callback(future) {
+            @Override
+            public void call() throws IOException {
+                Channels.setAttribute(channel, future);
+                requestSender.writeRequest(future, channel);
+            }
+        });
+        return true;
     }
 
     private boolean exitAfterHandling401(//
@@ -179,10 +177,8 @@ private boolean exitAfterHandling401(//
             final Request request,//
             int statusCode,//
             Realm realm,//
-            ProxyServer proxyServer) {
-
-        if (statusCode != UNAUTHORIZED.code())
-            return false;
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
 
         if (realm == null) {
             logger.info("Can't handle 401 as there's no realm");
@@ -203,7 +199,7 @@ private boolean exitAfterHandling401(//
 
         // FIXME what's this???
         future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
 
         switch (realm.getScheme()) {
         case BASIC:
@@ -291,7 +287,11 @@ private boolean exitAfterHandling401(//
         final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
 
         logger.debug("Sending authentication to {}", request.getUri());
-        if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
+        if (future.isKeepAlive()//
+                && HttpHeaders.isKeepAlive(httpRequest)//
+                && HttpHeaders.isKeepAlive(response)//
+                && !HttpHeaders.isTransferEncodingChunked(httpRequest)//
+                && !HttpHeaders.isTransferEncodingChunked(response)) {
             future.setReuseChannel(true);
             requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
         } else {
@@ -308,10 +308,8 @@ private boolean exitAfterHandling407(//
             HttpResponse response,//
             Request request,//
             int statusCode,//
-            ProxyServer proxyServer) {
-
-        if (statusCode != PROXY_AUTHENTICATION_REQUIRED.code())
-            return false;
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
 
         if (future.getInProxyAuth().getAndSet(true)) {
             logger.info("Can't handle 407 as auth was already performed");
@@ -334,7 +332,7 @@ private boolean exitAfterHandling407(//
 
         // FIXME what's this???
         future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
 
         switch (proxyRealm.getScheme()) {
         case BASIC:
@@ -420,12 +418,18 @@ private boolean exitAfterHandling407(//
 
         RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
         if (future.getCurrentRequest().getUri().isSecured()) {
-            nextRequestBuilder.setMethod(HttpMethod.CONNECT.name());
+            nextRequestBuilder.setMethod(CONNECT);
         }
         final Request nextRequest = nextRequestBuilder.build();
 
         logger.debug("Sending proxy authentication to {}", request.getUri());
-        if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
+        if (future.isKeepAlive()//
+                && HttpHeaders.isKeepAlive(httpRequest)//
+                && HttpHeaders.isKeepAlive(response)//
+                // support broken Proxy-Connection
+                && !response.headers().contains("Proxy-Connection", HttpHeaders.Values.CLOSE, true)//
+                && !HttpHeaders.isTransferEncodingChunked(httpRequest)//
+                && !HttpHeaders.isTransferEncodingChunked(response)) {
             future.setConnectAllowed(true);
             future.setReuseChannel(true);
             requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
@@ -445,83 +449,97 @@ private boolean exitAfterHandlingConnect(//
             int statusCode,//
             HttpRequest httpRequest) throws IOException {
 
-        if (statusCode == OK.code() && httpRequest.getMethod() == HttpMethod.CONNECT) {
+        if (future.isKeepAlive())
+            future.attachChannel(channel, true);
 
-            if (future.isKeepAlive())
-                future.attachChannel(channel, true);
+        Uri requestUri = request.getUri();
+        logger.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
 
-            Uri requestUri = request.getUri();
-            logger.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
+        channelManager.upgradeProtocol(channel.pipeline(), requestUri);
+        future.setReuseChannel(true);
+        future.setConnectAllowed(false);
+        requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
 
-            channelManager.upgradeProtocol(channel.pipeline(), requestUri);
-            future.setReuseChannel(true);
-            future.setConnectAllowed(false);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
+        return true;
+    }
 
-            return true;
-        }
+    private boolean exitAfterHandler(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status,
+            HttpRequest httpRequest, HttpResponseHeaders responseHeaders) throws IOException, Exception {
 
-        return false;
+        boolean exit = exitAfterHandlingStatus(channel, future, response, handler, status, httpRequest) || //
+                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders, httpRequest) || //
+                exitAfterHandlingReactiveStreams(channel, future, response, handler, httpRequest);
+
+        if (exit)
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(httpRequest) || HttpHeaders.isTransferEncodingChunked(response));
+
+        return exit;
     }
 
-    private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status)
-            throws IOException, Exception {
-        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE) {
-            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-            return true;
-        }
-        return false;
+    private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status,
+            HttpRequest httpRequest) throws IOException, Exception {
+        return !future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE;
     }
 
-    private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseHeaders responseHeaders)
-            throws IOException, Exception {
-        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE) {
-            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-            return true;
-        }
-        return false;
+    private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, HttpResponseHeaders responseHeaders,
+            HttpRequest httpRequest) throws IOException, Exception {
+        return !response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE;
     }
 
-    private boolean exitAfterHandlingReactiveStreams(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler) throws IOException {
+    private boolean exitAfterHandlingReactiveStreams(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, HttpRequest httpRequest)
+            throws IOException {
         if (handler instanceof StreamedAsyncHandler) {
             StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
             StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
+            // FIXME do we really need to pass the event loop?
+            // FIXME move this to ChannelManager
             channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
             Channels.setAttribute(channel, publisher);
-            if (streamedAsyncHandler.onStream(publisher) != State.CONTINUE) {
-                finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-                return true;
-            }
+            return streamedAsyncHandler.onStream(publisher) != State.CONTINUE;
         }
         return false;
     }
 
-    private boolean handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+    private boolean exitAfterSpecialCases(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future) throws Exception {
 
         HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
         ProxyServer proxyServer = future.getProxyServer();
-        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+        int statusCode = response.getStatus().code();
+        Request request = future.getCurrentRequest();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        if (statusCode == UNAUTHORIZED_401) {
+            return exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer, httpRequest);
+
+        } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
+            return exitAfterHandling407(channel, future, response, request, statusCode, proxyServer, httpRequest);
+
+        } else if (statusCode == CONTINUE_100) {
+            return exitAfterHandling100(channel, future, statusCode);
+
+        } else if (REDIRECT_STATUSES.contains(statusCode)) {
+            return exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
+
+        } else if (httpRequest.getMethod() == HttpMethod.CONNECT && statusCode == OK_200) {
+            return exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest);
 
-        // store the original headers so we can re-send all them to
-        // the handler in case of trailing headers
-        future.setHttpHeaders(response.headers());
+        }
+        return false;
+    }
+
+    private boolean handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
 
         future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
 
         NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
-        int statusCode = response.getStatus().code();
-        Request request = future.getCurrentRequest();
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(response.headers());
 
         return exitAfterProcessingFilters(channel, future, handler, status, responseHeaders) || //
-                exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer) || //
-                exitAfterHandling407(channel, future, response, request, statusCode, proxyServer) || //
-                exitAfterHandling100(channel, future, statusCode) || //
-                exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm) || //
-                exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest) || //
-                exitAfterHandlingStatus(channel, future, response, handler, status) || //
-                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders) || exitAfterHandlingReactiveStreams(channel, future, response, handler);
+                exitAfterSpecialCases(response, channel, future) || //
+                exitAfterHandler(channel, future, response, handler, status, httpRequest, responseHeaders);
     }
 
     private void handleChunk(HttpContent chunk,//
@@ -537,14 +555,13 @@ private void handleChunk(HttpContent chunk,//
             LastHttpContent lastChunk = (LastHttpContent) chunk;
             HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
             if (!trailingHeaders.isEmpty()) {
-                NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), trailingHeaders);
-                interrupt = handler.onHeadersReceived(responseHeaders) != State.CONTINUE;
+                interrupt = handler.onHeadersReceived(new HttpResponseHeaders(trailingHeaders, true)) != State.CONTINUE;
             }
         }
 
         ByteBuf buf = chunk.content();
         if (!interrupt && !(handler instanceof StreamedAsyncHandler) && (buf.readableBytes() > 0 || last)) {
-            NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
+            HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
             interrupt = updateBodyAndInterrupt(future, handler, part);
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
index ad8030591..e00e34668 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
@@ -14,12 +14,12 @@
 package org.asynchttpclient.netty.handler;
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
 import static org.asynchttpclient.util.HttpUtils.*;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponse;
 
 import java.util.HashSet;
@@ -61,10 +61,10 @@
 
     public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
     static {
-        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.code());
-        REDIRECT_STATUSES.add(FOUND.code());
-        REDIRECT_STATUSES.add(SEE_OTHER.code());
-        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
+        REDIRECT_STATUSES.add(FOUND_302);
+        REDIRECT_STATUSES.add(SEE_OTHER_303);
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
     }
 
     public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
@@ -83,12 +83,15 @@ public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, Net
 
     public abstract void onClose(NettyResponseFuture<?> future);
 
-    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean switchToGet) {
+    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
 
         HttpHeaders headers = request.getHeaders()//
                 .remove(HttpHeaders.Names.HOST)//
-                .remove(HttpHeaders.Names.CONTENT_LENGTH)//
-                .remove(HttpHeaders.Names.CONTENT_TYPE);
+                .remove(HttpHeaders.Names.CONTENT_LENGTH);
+
+        if (!keepBody) {
+            headers.remove(HttpHeaders.Names.CONTENT_TYPE);
+        }
 
         if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
             headers.remove(AUTHORIZATION)//
@@ -105,7 +108,7 @@ protected boolean exitAfterHandlingRedirect(//
             int statusCode,//
             Realm realm) throws Exception {
 
-        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
+        if (followRedirect(config, request)) {
             if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
                 throw maxRedirectException;
 
@@ -115,12 +118,12 @@ protected boolean exitAfterHandlingRedirect(//
                 future.getInProxyAuth().set(false);
 
                 String originalMethod = request.getMethod();
-                boolean switchToGet = !originalMethod.equals(HttpMethod.GET.name()) && (statusCode == 301 || statusCode == 303 || (statusCode == 302 && !config.isStrict302Handling()));
-                boolean keepBody = statusCode == 307 || (statusCode == 302 && config.isStrict302Handling());
+                boolean switchToGet = !originalMethod.equals(GET) && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
+                boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || (statusCode == FOUND_302 && config.isStrict302Handling());
 
-                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? HttpMethod.GET.name() : originalMethod)//
+                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)//
                         .setCookies(request.getCookies())//
-                        .setConnectionPoolPartitioning(request.getConnectionPoolPartitioning())//
+                        .setChannelPoolPartitioning(request.getChannelPoolPartitioning())//
                         .setFollowRedirect(true)//
                         .setLocalAddress(request.getLocalAddress())//
                         .setNameResolver(request.getNameResolver())//
@@ -142,7 +145,7 @@ else if (request.getBodyGenerator() != null)
                         requestBuilder.setBody(request.getBodyGenerator());
                 }
 
-                requestBuilder.setHeaders(propagatedHeaders(request, realm, switchToGet));
+                requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
 
                 // in case of a redirect from HTTP to HTTPS, future
                 // attributes might change
@@ -161,8 +164,6 @@ else if (request.getBodyGenerator() != null)
                         requestBuilder.addOrReplaceCookie(c);
                 }
 
-                requestBuilder.setHeaders(propagatedHeaders(future.getCurrentRequest(), realm, switchToGet));
-
                 boolean sameBase = isSameBase(request.getUri(), newUri);
 
                 if (sameBase) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
index 32bfae054..7c6d0a9a4 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
@@ -31,14 +32,13 @@
 
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.netty.Callback;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.NettyResponseHeaders;
 import org.asynchttpclient.netty.NettyResponseStatus;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
@@ -70,31 +70,22 @@ private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
 
         private final Channel channel;
         private final HttpResponse response;
+        private final  WebSocketUpgradeHandler handler;
+        private final  HttpResponseStatus status;
+        private final  HttpResponseHeaders responseHeaders;
         
-        public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpResponse response) {
+        public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpResponse response, WebSocketUpgradeHandler handler, HttpResponseStatus status, HttpResponseHeaders responseHeaders) {
             super(future);
             this.channel = channel;
             this.response = response;
+            this.handler = handler;
+            this.status = status;
+            this.responseHeaders = responseHeaders;
         }
         
         @Override
         public void call() throws Exception {
             
-            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-            Request request = future.getCurrentRequest();
-            
-            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
-            HttpResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
-            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-            if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
-                return;
-            }
-
-            future.setHttpHeaders(response.headers());
-            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code(), realm))
-                return;
-
             boolean validStatus = response.getStatus().equals(SWITCHING_PROTOCOLS);
             boolean validUpgrade = response.headers().get(HttpHeaders.Names.UPGRADE) != null;
             String connection = response.headers().get(HttpHeaders.Names.CONNECTION);
@@ -139,7 +130,26 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
 
         if (e instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) e;
-            Channels.setAttribute(channel, new UpgradeCallback(future, channel, response));
+            if (logger.isDebugEnabled()) {
+                HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+                logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+            }
+            
+            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
+            HttpResponseHeaders responseHeaders = new HttpResponseHeaders(response.headers());
+            
+            Request request = future.getCurrentRequest();
+            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+            if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+                return;
+            }
+
+            if (REDIRECT_STATUSES.contains(status.getStatusCode()) && exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code(), realm))
+                return;
+            
+            Channels.setAttribute(channel, new UpgradeCallback(future, channel, response, handler, status, responseHeaders));
 
         } else if (e instanceof WebSocketFrame) {
 
@@ -156,7 +166,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
                 } else {
                     ByteBuf buf = frame.content();
                     if (buf != null && buf.readableBytes() > 0) {
-                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
+                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
                         handler.onBodyPartReceived(part);
 
                         if (frame instanceof BinaryWebSocketFrame) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 3eb0f0ba3..e1af223d4 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -48,7 +48,7 @@ public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> con
         final InetSocketAddress remoteAddress = remoteAddresses.get(i);
         
         if (asyncHandlerExtensions != null)
-            asyncHandlerExtensions.onTcpConnect(remoteAddress);
+            asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);
 
         final ChannelFuture future = localAddress != null ? bootstrap.connect(remoteAddress, localAddress) : bootstrap.connect(remoteAddress);
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 736490a19..195d3a94a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -67,7 +67,7 @@
 public final class NettyRequestFactory {
 
     public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
-    
+
     private final AsyncHttpClientConfig config;
 
     public NettyRequestFactory(AsyncHttpClientConfig config) {
@@ -141,9 +141,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
         boolean connect = method == HttpMethod.CONNECT;
 
-        boolean allowConnectionPooling = config.isKeepAlive();
-
-        HttpVersion httpVersion = !allowConnectionPooling || (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
+        HttpVersion httpVersion = (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
         String requestUri = requestUri(uri, proxyServer, connect);
 
         NettyBody body = body(request, connect);
@@ -170,7 +168,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         if (connect) {
             // assign proxy-auth as configured on request
             headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
-        
+
         } else {
             // assign headers as configured on request
             headers.set(request.getHeaders());
@@ -201,7 +199,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
                     .set(SEC_WEBSOCKET_VERSION, "13");
 
         } else if (!headers.contains(CONNECTION)) {
-            String connectionHeaderValue = connectionHeader(allowConnectionPooling, httpVersion == HttpVersion.HTTP_1_1);
+            String connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
             if (connectionHeaderValue != null)
                 headers.set(CONNECTION, connectionHeaderValue);
         }
@@ -223,7 +221,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
 
         return nettyRequest;
     }
-    
+
     private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
         if (connect)
             // proxy tunnelling, connect need host and explicit port
@@ -243,12 +241,11 @@ else if (proxyServer != null)
         }
     }
 
-    private String connectionHeader(boolean allowConnectionPooling, boolean http11) {
-        if (allowConnectionPooling)
-            return HttpHeaders.Values.KEEP_ALIVE;
-        else if (http11)
-            return HttpHeaders.Values.CLOSE;
-        else
-            return null;
+    private String connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
+        if (httpVersion.isKeepAliveDefault()) {
+            return keepAlive ? null : HttpHeaders.Values.CLOSE;
+        } else {
+            return keepAlive ? HttpHeaders.Values.KEEP_ALIVE : null;
+        }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 03c590328..38a8ae1ba 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -15,11 +15,14 @@
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+import static org.asynchttpclient.util.HttpUtils.requestTimeout;
 import static org.asynchttpclient.util.MiscUtils.getCause;
 import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelProgressivePromise;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
@@ -40,6 +43,7 @@
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
@@ -47,7 +51,7 @@
 import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.SimpleGenericFutureListener;
+import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
@@ -56,7 +60,7 @@
 import org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.resolver.RequestNameResolver;
+import org.asynchttpclient.resolver.RequestHostnameResolver;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.slf4j.Logger;
@@ -112,7 +116,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
         return future != null //
                 && future.getNettyRequest() != null //
                 && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT //
-                && !request.getMethod().equals(HttpMethod.CONNECT.name());
+                && !request.getMethod().equals(CONNECT);
     }
 
     /**
@@ -270,8 +274,8 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
             return future;
         }
 
-        RequestNameResolver.INSTANCE.resolve(request, proxy, asyncHandler)//
-                .addListener(new SimpleGenericFutureListener<List<InetSocketAddress>>() {
+        RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)//
+                .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
 
                     @Override
                     protected void onSuccess(List<InetSocketAddress> addresses) {
@@ -298,7 +302,7 @@ protected void onFailure(Throwable cause) {
                 asyncHandler,//
                 nettyRequest,//
                 config.getMaxRequestRetry(),//
-                request.getConnectionPoolPartitioning(),//
+                request.getChannelPoolPartitioning(),//
                 proxyServer);
 
         String expectHeader = request.getHeaders().get(HttpHeaders.Names.EXPECT);
@@ -323,14 +327,18 @@ protected void onFailure(Throwable cause) {
             if (handler instanceof TransferCompletionHandler)
                 configureTransferAdapter(handler, httpRequest);
 
+            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
+
             if (!future.isHeadersAlreadyWrittenOnContinue()) {
                 if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
                     AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRequestSend(nettyRequest);
 
-                channel.writeAndFlush(httpRequest, channel.newProgressivePromise()).addListener(new ProgressListener(future.getAsyncHandler(), future, true, 0L));
+                ChannelProgressivePromise promise = channel.newProgressivePromise();
+                ChannelFuture f = writeBody ? channel.write(httpRequest, promise) : channel.writeAndFlush(httpRequest, promise);
+                f.addListener(new ProgressListener(future.getAsyncHandler(), future, true, 0L));
             }
 
-            if (!future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null)
+            if (writeBody)
                 nettyRequest.getBody().write(channel, future);
 
             // don't bother scheduling timeouts if channel became invalid
@@ -344,7 +352,7 @@ protected void onFailure(Throwable cause) {
     }
 
     private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
-        HttpHeaders h = new DefaultHttpHeaders().set(httpRequest.headers());
+        HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
         TransferCompletionHandler.class.cast(handler).headers(h);
     }
 
@@ -387,9 +395,8 @@ public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
     public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
         if (future.isDone())
             channelManager.closeChannel(channel);
-
         else if (!retry(future))
-            abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+            abort(channel, future, RemotelyClosedException.INSTANCE);
     }
 
     public boolean retry(NettyResponseFuture<?> future) {
@@ -398,6 +405,7 @@ public boolean retry(NettyResponseFuture<?> future) {
             return false;
 
         if (future.canBeReplayed()) {
+            // FIXME should we set future.setReuseChannel(false); ?
             future.setChannelState(ChannelState.RECONNECTED);
             future.getAndSetStatusReceived(false);
 
@@ -443,6 +451,8 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
     }
 
     public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
+        // remove attribute in case the channel gets closed so it doesn't try to recover the previous future
+        Channels.setAttribute(future.channel(), null);
         sendRequest(request, future.getAsyncHandler(), future, true);
     }
 
@@ -452,7 +462,7 @@ private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHand
         if (asyncHandler instanceof WebSocketUpgradeHandler) {
             if (!isWs)
                 throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
-            else if (!request.getMethod().equals(HttpMethod.GET.name()))
+            else if (!request.getMethod().equals(GET))
                 throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET: " + request.getMethod());
         } else if (isWs) {
             throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
@@ -462,11 +472,11 @@ else if (!request.getMethod().equals(HttpMethod.GET.name()))
     private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPool();
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPoolAttempt();
 
         Uri uri = request.getUri();
         String virtualHost = request.getVirtualHost();
-        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getConnectionPoolPartitioning());
+        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
 
         if (channel != null) {
             LOGGER.debug("Using polled Channel {}\n for uri {}\n", channel, uri);
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index 63cdb68e4..e29af4215 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -50,16 +50,16 @@ public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
         ByteBuf buffer = ctx.alloc().buffer(chunkSize);
         Body.BodyState state = body.transferTo(buffer);
         switch (state) {
-            case STOP:
-                endOfInput = true;
-                return buffer;
-            case SUSPEND:
-                //this will suspend the stream in ChunkedWriteHandler
-                return null;
-            case CONTINUE:
-                return buffer;
-            default:
-                throw new IllegalStateException("Unknown state: " + state);
+        case STOP:
+            endOfInput = true;
+            return buffer;
+        case SUSPEND:
+            // this will suspend the stream in ChunkedWriteHandler
+            return null;
+        case CONTINUE:
+            return buffer;
+        default:
+            throw new IllegalStateException("Unknown state: " + state);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 98fba0f01..4f85296a5 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -29,8 +29,8 @@
 import org.asynchttpclient.request.body.Body;
 import org.asynchttpclient.request.body.RandomAccessBody;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.FeedListener;
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
-import org.asynchttpclient.request.body.generator.FeedableBodyGenerator.FeedListener;
 import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
 
 public class NettyBodyBody implements NettyBody {
@@ -55,7 +55,7 @@ public long getContentLength() {
     @Override
     public String getContentType() {
         return null;
-    };
+    }
 
     @Override
     public void write(final Channel channel, NettyResponseFuture<?> future) throws IOException {
@@ -69,10 +69,11 @@ public void write(final Channel channel, NettyResponseFuture<?> future) throws I
 
             BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
             if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
+                final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
                 FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
                     @Override
                     public void onContentAdded() {
-                        channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                        chunkedWriteHandler.resumeTransfer();
                     }
                     @Override
                     public void onError(Throwable t) {}
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
index 6e5b190f3..aa05d0262 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
@@ -32,5 +32,4 @@ public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int
         configureSslEngine(sslEngine, config);
         return sslEngine;
     }
-
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 715afadf6..a35a69574 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -52,7 +52,7 @@ public void run(Timeout timeout) throws Exception {
 
         if (durationBeforeCurrentReadTimeout <= 0L) {
             // idleConnectTimeout reached
-            String message = "Read timeout to " + remoteAddress + " of " + readTimeout + " ms";
+            String message = "Read timeout to " + remoteAddress + " after " + readTimeout + " ms";
             long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
             expire(message, durationSinceLastTouch);
             // cancel request timeout sibling
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index 42ba4f16b..8ebdbd053 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -43,7 +43,7 @@ public void run(Timeout timeout) throws Exception {
         if (nettyResponseFuture.isDone())
             return;
 
-        String message = "Request timed out to " + remoteAddress + " of " + requestTimeout + " ms";
+        String message = "Request timeout to " + remoteAddress + " after " + requestTimeout + "ms";
         long age = millisTime() - nettyResponseFuture.getStart();
         expire(message, age);
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index 1c411a7fa..f3b5d59b8 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.netty.timeout;
 
+import io.netty.channel.Channel;
 import io.netty.util.TimerTask;
 
 import java.net.SocketAddress;
@@ -39,8 +40,9 @@ public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequest
         this.requestSender = requestSender;
         this.timeoutsHolder = timeoutsHolder;
         // saving remote address as the channel might be removed from the future when an exception occurs
-        SocketAddress sa = nettyResponseFuture.getChannelRemoteAddress();
-        remoteAddress = sa != null ? sa.toString() : "not-connected";
+        Channel channel = nettyResponseFuture.channel();
+        SocketAddress sa = channel == null ? null : channel.remoteAddress();
+        remoteAddress = sa == null ? "not-connected" : sa.toString();
     }
 
     protected void expire(String message, long time) {
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
index 4d45f7485..31e81f209 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
@@ -795,7 +795,7 @@ protected int getPreambleLength() {
         }
 
         /** Get the message length */
-        protected int getMessageLength() {
+        protected final int getMessageLength() {
             return currentOutputPosition;
         }
 
@@ -808,7 +808,7 @@ protected byte readByte(final int position) throws NtlmEngineException {
         }
 
         /** Read a bunch of bytes from a position in the message buffer */
-        protected void readBytes(final byte[] buffer, final int position) throws NtlmEngineException {
+        protected final void readBytes(final byte[] buffer, final int position) throws NtlmEngineException {
             if (messageContents.length < position + buffer.length) {
                 throw new NtlmEngineException("NTLM: Message too short");
             }
@@ -821,12 +821,12 @@ protected int readUShort(final int position) throws NtlmEngineException {
         }
 
         /** Read a ulong from a position within the message buffer */
-        protected int readULong(final int position) throws NtlmEngineException {
+        protected final int readULong(final int position) throws NtlmEngineException {
             return NtlmEngine.readULong(messageContents, position);
         }
 
         /** Read a security buffer from a position within the message buffer */
-        protected byte[] readSecurityBuffer(final int position) throws NtlmEngineException {
+        protected final byte[] readSecurityBuffer(final int position) throws NtlmEngineException {
             return NtlmEngine.readSecurityBuffer(messageContents, position);
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index a8a4f06fe..c4dc4f513 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -71,9 +71,8 @@ public Realm getRealm() {
     }
 
     /**
-     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to
-     * target host. If <code>null</code> proxy is passed in, this method returns true -- since there is NO proxy, we
-     * should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
+     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to target host. If <code>null</code> proxy is passed in, this method
+     * returns true -- since there is NO proxy, we should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
      * 
      * @param hostname the hostname
      * @return true if we have to ignore proxy use (obeying non-proxy hosts settings), false otherwise.
@@ -90,21 +89,19 @@ public boolean isIgnoredForHost(String hostname) {
 
         return false;
     }
-    
+
     private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
 
         if (nonProxyHost.length() > 1) {
             if (nonProxyHost.charAt(0) == '*') {
-                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1,
-                        nonProxyHost.length() - 1);
+                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1, nonProxyHost.length() - 1);
             } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
                 return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
         }
 
         return nonProxyHost.equalsIgnoreCase(targetHost);
     }
-    
-    
+
     public static class Builder {
 
         private String host;
@@ -130,13 +127,18 @@ public Builder setRealm(Realm realm) {
             return this;
         }
 
+        public Builder setRealm(Realm.Builder realm) {
+            this.realm = realm.build();
+            return this;
+        }
+
         public Builder setNonProxyHost(String nonProxyHost) {
             if (nonProxyHosts == null)
                 nonProxyHosts = new ArrayList<String>(1);
             nonProxyHosts.add(nonProxyHost);
             return this;
         }
-        
+
         public Builder setNonProxyHosts(List<String> nonProxyHosts) {
             this.nonProxyHosts = nonProxyHosts;
             return this;
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
new file mode 100644
index 000000000..1707132cc
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.nio.ByteBuffer;
+
+public final class BodyChunk {
+    public final boolean last;
+    public final ByteBuffer buffer;
+
+    public BodyChunk(final ByteBuffer buffer, final boolean last) {
+        this.buffer = buffer;
+        this.last = last;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
new file mode 100644
index 000000000..ff6ca2627
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+public final class BoundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<BlockingQueue<BodyChunk>> {
+
+    public BoundedQueueFeedableBodyGenerator(int capacity) {
+        super(new ArrayBlockingQueue<>(capacity, true));
+    }
+
+    @Override
+    protected boolean offer(BodyChunk chunk) throws InterruptedException {
+        return queue.offer(chunk);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
new file mode 100644
index 000000000..63c0c0262
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+public interface FeedListener {
+    void onContentAdded();
+
+    void onError(Throwable t);
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
index 1921b1b5b..5eea210b4 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -17,15 +17,11 @@
 
 /**
  * {@link BodyGenerator} which may return just part of the payload at the time handler is requesting it.
- * If it happens, PartialBodyGenerator becomes responsible for finishing payload transferring asynchronously.
+ * If it happens, client becomes responsible for providing the rest of the chunks.
  */
 public interface FeedableBodyGenerator extends BodyGenerator {
-    void feed(ByteBuffer buffer, boolean isLast);
 
-    void setListener(FeedListener listener);
+    boolean feed(ByteBuffer buffer, boolean isLast) throws Exception;
 
-    interface FeedListener {
-        void onContentAdded();
-        void onError(Throwable t);
-    }
+    void setListener(FeedListener listener);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
new file mode 100644
index 000000000..c61ce5411
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import io.netty.buffer.ByteBuf;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+
+import org.asynchttpclient.request.body.Body;
+
+public final class PushBody implements Body {
+
+    private final Queue<BodyChunk> queue;
+    private BodyState state = BodyState.CONTINUE;
+
+    public PushBody(Queue<BodyChunk> queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public BodyState transferTo(final ByteBuf target) throws IOException {
+        switch (state) {
+        case CONTINUE:
+            return readNextChunk(target);
+        case STOP:
+            return BodyState.STOP;
+        default:
+            throw new IllegalStateException("Illegal process state.");
+        }
+    }
+
+    private BodyState readNextChunk(ByteBuf target) throws IOException {
+        BodyState res = BodyState.SUSPEND;
+        while (target.isWritable() && state != BodyState.STOP) {
+            BodyChunk nextChunk = queue.peek();
+            if (nextChunk == null) {
+                // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+                return res;
+            } else if (!nextChunk.buffer.hasRemaining() && !nextChunk.last) {
+                // skip empty buffers
+                queue.remove();
+            } else {
+                res = BodyState.CONTINUE;
+                readChunk(target, nextChunk);
+            }
+        }
+        return res;
+    }
+
+    private void readChunk(ByteBuf target, BodyChunk part) {
+        move(target, part.buffer);
+
+        if (!part.buffer.hasRemaining()) {
+            if (part.last) {
+                state = BodyState.STOP;
+            }
+            queue.remove();
+        }
+    }
+
+    private void move(ByteBuf target, ByteBuffer source) {
+        int size = Math.min(target.writableBytes(), source.remaining());
+        if (size > 0) {
+            ByteBuffer slice = source.slice();
+            slice.limit(size);
+            target.writeBytes(slice);
+            source.position(source.position() + size);
+        }
+    }
+
+    @Override
+    public void close() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
new file mode 100644
index 000000000..06acfcbf4
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.nio.ByteBuffer;
+import java.util.Queue;
+
+import org.asynchttpclient.request.body.Body;
+
+public abstract class QueueBasedFeedableBodyGenerator<T extends Queue<BodyChunk>> implements FeedableBodyGenerator {
+
+    protected final T queue;
+    private FeedListener listener;
+
+    public QueueBasedFeedableBodyGenerator(T queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public Body createBody() {
+        return new PushBody(queue);
+    }
+
+    protected abstract boolean offer(BodyChunk chunk) throws Exception;
+
+    @Override
+    public boolean feed(final ByteBuffer buffer, final boolean isLast) throws Exception {
+        boolean offered = offer(new BodyChunk(buffer, isLast));
+        if (offered && listener != null) {
+            listener.onContentAdded();
+        }
+        return offered;
+    }
+
+    @Override
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
index efddc0b73..b168cbf6b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -35,7 +35,7 @@
 
     public ReactiveStreamsBodyGenerator(Publisher<ByteBuffer> publisher) {
         this.publisher = publisher;
-        this.feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+        this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
     }
 
     public Publisher<ByteBuffer> getPublisher() {
@@ -43,8 +43,8 @@ public ReactiveStreamsBodyGenerator(Publisher<ByteBuffer> publisher) {
     }
 
     @Override
-    public void feed(ByteBuffer buffer, boolean isLast) {
-        feedableBodyGenerator.feed(buffer, isLast);
+    public boolean feed(ByteBuffer buffer, boolean isLast) throws Exception {
+        return feedableBodyGenerator.feed(buffer, isLast);
     }
 
     @Override
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
deleted file mode 100755
index 279b2771c..000000000
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.request.body.generator;
-
-import io.netty.buffer.ByteBuf;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import org.asynchttpclient.request.body.Body;
-
-public final class SimpleFeedableBodyGenerator implements FeedableBodyGenerator, BodyGenerator {
-    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<>();
-    private FeedListener listener;
-
-    @Override
-    public Body createBody() {
-        return new PushBody();
-    }
-
-    @Override
-    public void feed(final ByteBuffer buffer, final boolean isLast) {
-        queue.offer(new BodyPart(buffer, isLast));
-        if (listener != null) {
-            listener.onContentAdded();
-        }
-    }
-
-    @Override
-    public void setListener(FeedListener listener) {
-        this.listener = listener;
-    }
-
-    public final class PushBody implements Body {
-
-        private BodyState state = BodyState.CONTINUE;
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-
-        @Override
-        public BodyState transferTo(final ByteBuf target) throws IOException {
-            switch (state) {
-                case CONTINUE:
-                    return readNextPart(target);
-                case STOP:
-                    return BodyState.STOP;
-                default:
-                    throw new IllegalStateException("Illegal process state.");
-            }
-        }
-
-        private BodyState readNextPart(ByteBuf target) throws IOException {
-            BodyState res = BodyState.SUSPEND;
-            while (target.isWritable() && state != BodyState.STOP) {
-                BodyPart nextPart = queue.peek();
-                if (nextPart == null) {
-                    // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
-                    return res;
-                } else if (!nextPart.buffer.hasRemaining() && !nextPart.isLast) {
-                    // skip empty buffers
-                    queue.remove();
-                } else {
-                    res = BodyState.CONTINUE;
-                    readBodyPart(target, nextPart);
-                }
-            }
-            return res;
-        }
-
-        private void readBodyPart(ByteBuf target, BodyPart part) {
-            move(target, part.buffer);
-
-            if (!part.buffer.hasRemaining()) {
-                if (part.isLast) {
-                    state = BodyState.STOP;
-                }
-                queue.remove();
-            }
-        }
-
-        @Override
-        public void close() {
-        }
-    }
-
-    private void move(ByteBuf target, ByteBuffer source) {
-        int size = Math.min(target.writableBytes(), source.remaining());
-        if (size > 0) {
-            ByteBuffer slice = source.slice();
-            slice.limit(size);
-            target.writeBytes(slice);
-            source.position(source.position() + size);
-        }
-    }
-
-    private final class BodyPart {
-        private final boolean isLast;
-        private final ByteBuffer buffer;
-
-        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
-            this.buffer = buffer;
-            this.isLast = isLast;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
similarity index 63%
rename from client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
index 9c375b328..d76ae9d03 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
@@ -11,26 +11,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty;
+package org.asynchttpclient.request.body.generator;
 
-import org.asynchttpclient.HttpResponseBodyPart;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
-/**
- * A callback class used when an HTTP response body is received.
- */
-public abstract class NettyResponseBodyPart implements HttpResponseBodyPart {
-
-    private final boolean last;
+public final class UnboundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<ConcurrentLinkedQueue<BodyChunk>> {
 
-    public NettyResponseBodyPart(boolean last) {
-        this.last = last;
+    public UnboundedQueueFeedableBodyGenerator() {
+        super(new ConcurrentLinkedQueue<>());
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public boolean isLast() {
-        return last;
+    protected boolean offer(BodyChunk chunk) throws Exception {
+        return queue.offer(chunk);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
index 069e8189b..ea731a09d 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
@@ -48,7 +48,7 @@ public FileLikePart(String name, String contentType, Charset charset, String con
                 transfertEncoding == null ? DEFAULT_TRANSFER_ENCODING : transfertEncoding);
     }
 
-    public void setFileName(String fileName) {
+    public final void setFileName(String fileName) {
         this.fileName = fileName;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestNameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
similarity index 71%
rename from client/src/main/java/org/asynchttpclient/resolver/RequestNameResolver.java
rename to client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
index 2850fea36..d33cdeab1 100644
--- a/client/src/main/java/org/asynchttpclient/resolver/RequestNameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -25,11 +25,11 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.netty.SimpleGenericFutureListener;
+import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 
-public enum RequestNameResolver {
+public enum RequestHostnameResolver {
 
     INSTANCE;
 
@@ -58,30 +58,32 @@
         }
 
         if (asyncHandlerExtensions != null)
-            asyncHandlerExtensions.onDnsResolution(name);
+            asyncHandlerExtensions.onHostnameResolutionAttempt(name);
 
         final Future<List<InetSocketAddress>> whenResolved = request.getNameResolver().resolve(name, port);
 
         if (asyncHandlerExtensions == null)
             return whenResolved;
 
-        Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
-
-        whenResolved.addListener(new SimpleGenericFutureListener<List<InetSocketAddress>>() {
-
-            @Override
-            protected void onSuccess(List<InetSocketAddress> addresses) throws Exception {
-                asyncHandlerExtensions.onDnsResolutionSuccess(name, addresses);
-                promise.setSuccess(addresses);
-            }
-
-            @Override
-            protected void onFailure(Throwable t) throws Exception {
-                asyncHandlerExtensions.onDnsResolutionFailure(name, t);
-                promise.setFailure(t);
-            }
-        });
-
-        return promise;
+        else {
+            Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+            
+            whenResolved.addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
+                
+                @Override
+                protected void onSuccess(List<InetSocketAddress> addresses) throws Exception {
+                    asyncHandlerExtensions.onHostnameResolutionSuccess(name, addresses);
+                    promise.setSuccess(addresses);
+                }
+                
+                @Override
+                protected void onFailure(Throwable t) throws Exception {
+                    asyncHandlerExtensions.onHostnameResolutionFailure(name, t);
+                    promise.setFailure(t);
+                }
+            });
+            
+            return promise;
+        }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/uri/UriParser.java b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
index 947c129b8..e8418b9bd 100644
--- a/client/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -13,6 +13,7 @@
 package org.asynchttpclient.uri;
 
 import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 final class UriParser {
 
@@ -85,7 +86,7 @@ private boolean overrideWithContext(Uri context, String originalUrl) {
 
             // see RFC2396 5.2.3
             String contextPath = context.getPath();
-            if (isNotEmpty(contextPath) && contextPath.charAt(0) == '/')
+            if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/')
               scheme = null;
 
             if (scheme == null) {
@@ -280,7 +281,7 @@ private void parseAuthority() {
                 throw new IllegalArgumentException("Invalid port number :" + port);
 
             // see RFC2396 5.2.4: ignore context path if authority is defined
-            if (isNotEmpty(authority))
+            if (isNonEmpty(authority))
                 path = "";
         }
     }
@@ -294,7 +295,7 @@ private void computeRegularPath() {
         if (urlWithoutQuery.charAt(start) == '/')
             path = urlWithoutQuery.substring(start, end);
 
-        else if (isNotEmpty(path))
+        else if (isNonEmpty(path))
             handleRelativePath();
 
         else {
@@ -336,8 +337,4 @@ public void parse(Uri context, final String originalUrl) {
         parseAuthority();
         computePath(queryOnly);
     }
-
-    private static boolean isNotEmpty(String string) {
-        return string != null && string.length() > 0;
-    }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
similarity index 99%
rename from client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
rename to client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
index d341d9f8e..3ebebc85f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.util;
+package org.asynchttpclient.util;
 
 import io.netty.buffer.ByteBuf;
 
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
new file mode 100644
index 000000000..09bcd9945
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -0,0 +1,54 @@
+package org.asynchttpclient.util;
+
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+public final class HttpConstants {
+
+    public static final class Methods {
+        public static final String CONNECT = HttpMethod.CONNECT.name();
+        public static final String DELETE = HttpMethod.DELETE.name();
+        public static final String GET = HttpMethod.GET.name();
+        public static final String HEAD = HttpMethod.HEAD.name();
+        public static final String OPTIONS = HttpMethod.OPTIONS.name();
+        public static final String PATCH = HttpMethod.PATCH.name();
+        public static final String POST = HttpMethod.POST.name();
+        public static final String PUT = HttpMethod.PUT.name();
+        public static final String TRACE = HttpMethod.TRACE.name();
+
+        private Methods() {
+        }
+    }
+
+    public static final class ResponseStatusCodes {
+        public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
+        public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
+        public static final int OK_200 = HttpResponseStatus.OK.code();
+        public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
+        public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
+        public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
+        public static final int NOT_MODIFIED_304 = HttpResponseStatus.NOT_MODIFIED.code();
+        public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
+        public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
+        public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
+
+        private ResponseStatusCodes() {
+        }
+    }
+
+    private HttpConstants() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index f9434c0b3..aae8a44bc 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -13,9 +13,8 @@
 package org.asynchttpclient.util;
 
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static org.asynchttpclient.util.MiscUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.List;
@@ -30,9 +29,6 @@
  */
 public class HttpUtils {
 
-    public static final IOException REMOTELY_CLOSED_EXCEPTION = buildStaticIOException("Remotely closed");
-    public static final IOException CHANNEL_CLOSED_EXCEPTION = buildStaticIOException("Channel closed");
-
     public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
     public static final void validateSupportedScheme(Uri uri) {
@@ -43,12 +39,12 @@ public static final void validateSupportedScheme(Uri uri) {
     }
 
     public final static String getBaseUrl(Uri uri) {
-        return uri.getScheme() + "://" + getAuthority(uri);
+        // getAuthority duplicate but we don't want to re-concatenate
+        return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
     }
 
     public final static String getAuthority(Uri uri) {
-        int port = uri.getPort() != -1 ? uri.getPort() : uri.getExplicitPort();
-        return uri.getHost() + ":" + port;
+        return uri.getHost() + ":" + uri.getExplicitPort();
     }
 
     public final static boolean isSameBase(Uri uri1, Uri uri2) {
diff --git a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
index 21bf01dc6..843ce5fec 100644
--- a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -59,10 +59,9 @@ public static void closeSilently(Closeable closeable) {
             }
     }
 
-    public static IOException buildStaticIOException(String message) {
-        IOException ioe = new IOException(message);
-        ioe.setStackTrace(new StackTraceElement[] {});
-        return ioe;
+    public static <T extends Exception> T trimStackTrace(T e) {
+        e.setStackTrace(new StackTraceElement[] {});
+        return e;
     }
 
     public static Throwable getCause(Throwable t) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/util/Utf8Reader.java b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
similarity index 99%
rename from client/src/main/java/org/asynchttpclient/netty/util/Utf8Reader.java
rename to client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
index 668afd528..34c495adc 100644
--- a/client/src/main/java/org/asynchttpclient/netty/util/Utf8Reader.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.util;
+package org.asynchttpclient.util;
 
 import io.netty.buffer.AbstractByteBuf;
 import io.netty.buffer.ByteBuf;
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index 37d9dcf8e..ceffb2747 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -13,13 +13,9 @@
 
 package org.asynchttpclient.webdav;
 
-import io.netty.handler.codec.http.HttpHeaders;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -32,9 +28,7 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.netty.NettyResponse;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -51,16 +45,16 @@
 public abstract class WebDavCompletionHandlerBase<T> implements AsyncHandler<T> {
     private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
 
-    private final List<HttpResponseBodyPart> bodies = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
     private HttpResponseStatus status;
     private HttpResponseHeaders headers;
+    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
 
     /**
      * {@inheritDoc}
      */
     @Override
     public final State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        bodies.add(content);
+        bodyParts.add(content);
         return State.CONTINUE;
     }
 
@@ -82,18 +76,50 @@ public final State onHeadersReceived(final HttpResponseHeaders headers) throws E
         return State.CONTINUE;
     }
 
+    private Document readXMLResponse(InputStream stream) {
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        Document document = null;
+        try {
+            document = factory.newDocumentBuilder().parse(stream);
+            parse(document);
+        } catch (SAXException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (IOException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (ParserConfigurationException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        }
+        return document;
+    }
+
+    private void parse(Document document) {
+        Element element = document.getDocumentElement();
+        NodeList statusNode = element.getElementsByTagName("status");
+        for (int i = 0; i < statusNode.getLength(); i++) {
+            Node node = statusNode.item(i);
+
+            String value = node.getFirstChild().getNodeValue();
+            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
+            String statusText = value.substring(value.lastIndexOf(" "));
+            status = new HttpStatusWrapper(status, statusText, statusCode);
+        }
+    }
+    
     /**
      * {@inheritDoc}
      */
     @Override
     public final T onCompleted() throws Exception {
         if (status != null) {
-            Response response = status.prepareResponse(headers, bodies);
             Document document = null;
             if (status.getStatusCode() == 207) {
-                document = readXMLResponse(response.getResponseBodyAsStream());
+                document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
             }
-            return onCompleted(new WebDavResponse(status.prepareResponse(headers, bodies), document));
+            // recompute response as readXMLResponse->parse might have updated it
+            return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
         } else {
             throw new IllegalStateException("Status is null");
         }
@@ -131,109 +157,6 @@ public HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int stat
             this.statusCode = statusCode;
         }
 
-        @Override
-        public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-            final Response wrappedResponse = wrapped.prepareResponse(headers, bodyParts);
-
-            return new Response() {
-
-                @Override
-                public int getStatusCode() {
-                    return statusCode;
-                }
-
-                @Override
-                public String getStatusText() {
-                    return statusText;
-                }
-
-                @Override
-                public byte[] getResponseBodyAsBytes() {
-                    return wrappedResponse.getResponseBodyAsBytes();
-                }
-
-                @Override
-                public ByteBuffer getResponseBodyAsByteBuffer() {
-                    return wrappedResponse.getResponseBodyAsByteBuffer();
-                }
-
-                @Override
-                public InputStream getResponseBodyAsStream() {
-                    return wrappedResponse.getResponseBodyAsStream();
-                }
-
-                @Override
-                public String getResponseBody(Charset charset) {
-                    return wrappedResponse.getResponseBody(charset);
-                }
-
-                @Override
-                public String getResponseBody() {
-                    return wrappedResponse.getResponseBody();
-                }
-
-                @Override
-                public Uri getUri() {
-                    return wrappedResponse.getUri();
-                }
-
-                @Override
-                public String getContentType() {
-                    return wrappedResponse.getContentType();
-                }
-
-                @Override
-                public String getHeader(String name) {
-                    return wrappedResponse.getHeader(name);
-                }
-
-                @Override
-                public List<String> getHeaders(String name) {
-                    return wrappedResponse.getHeaders(name);
-                }
-
-                @Override
-                public HttpHeaders getHeaders() {
-                    return wrappedResponse.getHeaders();
-                }
-
-                @Override
-                public boolean isRedirected() {
-                    return wrappedResponse.isRedirected();
-                }
-
-                @Override
-                public List<Cookie> getCookies() {
-                    return wrappedResponse.getCookies();
-                }
-
-                @Override
-                public boolean hasResponseStatus() {
-                    return wrappedResponse.hasResponseStatus();
-                }
-
-                @Override
-                public boolean hasResponseHeaders() {
-                    return wrappedResponse.hasResponseHeaders();
-                }
-
-                @Override
-                public boolean hasResponseBody() {
-                    return wrappedResponse.hasResponseBody();
-                }
-
-                @Override
-                public SocketAddress getRemoteAddress() {
-                    return wrappedResponse.getRemoteAddress();
-                }
-
-                @Override
-                public SocketAddress getLocalAddress() {
-                    return wrappedResponse.getLocalAddress();
-                }
-            };
-        }
-
         @Override
         public int getStatusCode() {
             return (statusText == null ? wrapped.getStatusCode() : statusCode);
@@ -274,36 +197,4 @@ public SocketAddress getLocalAddress() {
             return wrapped.getLocalAddress();
         }
     }
-
-    private Document readXMLResponse(InputStream stream) {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        Document document = null;
-        try {
-            document = factory.newDocumentBuilder().parse(stream);
-            parse(document);
-        } catch (SAXException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (IOException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (ParserConfigurationException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        }
-        return document;
-    }
-
-    private void parse(Document document) {
-        Element element = document.getDocumentElement();
-        NodeList statusNode = element.getElementsByTagName("status");
-        for (int i = 0; i < statusNode.getLength(); i++) {
-            Node node = statusNode.item(i);
-
-            String value = node.getFirstChild().getNodeValue();
-            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
-            String statusText = value.substring(value.lastIndexOf(" "));
-            status = new HttpStatusWrapper(status, statusText, statusCode);
-        }
-    }
 }
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/ahc-default.properties
index 67961dee5..5559b196e 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/ahc-default.properties
@@ -9,10 +9,11 @@ org.asynchttpclient.connectionTtl=-1
 org.asynchttpclient.followRedirect=false
 org.asynchttpclient.maxRedirects=5
 org.asynchttpclient.compressionEnforced=false
-org.asynchttpclient.userAgent=NING/1.0
+org.asynchttpclient.userAgent=AHC/2.0
 org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
 org.asynchttpclient.useProxySelector=false
 org.asynchttpclient.useProxyProperties=false
+org.asynchttpclient.validateResponseHeaders=true
 org.asynchttpclient.strict302Handling=false
 org.asynchttpclient.keepAlive=true
 org.asynchttpclient.requestCompressionLevel=-1
@@ -35,3 +36,4 @@ org.asynchttpclient.keepEncodingHeader=false
 org.asynchttpclient.shutdownQuietPeriod=2000
 org.asynchttpclient.shutdownTimeout=15000
 org.asynchttpclient.useNativeTransport=false
+org.asynchttpclient.usePooledMemory=true
diff --git a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
index b6a155c5a..aaea8f804 100644
--- a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
@@ -59,11 +59,11 @@ public void tearDownGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 
     protected String getTargetUrl2() {
-        return String.format("https://127.0.0.1:%d/foo/test", port2);
+        return String.format("https://localhost:%d/foo/test", port2);
     }
 
     public AbstractHandler configureHandler() throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index 00adc4a2e..e5c6ca8d3 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -63,7 +63,7 @@ public void testDefaultCompressionEnforced() {
     }
 
     public void testDefaultUserAgent() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "NING/1.0");
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.0");
         testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 992530e4d..1a108044c 100644
--- a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -16,6 +16,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -26,7 +27,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -69,7 +70,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             OutputStream out = response.getOutputStream();
             if (request.getHeader("X-Content") != null) {
                 String content = request.getHeader("X-Content");
-                response.setHeader("Content-Length", String.valueOf(content.getBytes(UTF_8).length));
+                response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(content.getBytes(UTF_8).length));
                 out.write(content.substring(1).getBytes(UTF_8));
             } else {
                 response.setStatus(200);
@@ -168,11 +169,7 @@ public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
     }
 
     protected void inspectException(Throwable t) {
-        assertNotNull(t.getCause());
-        assertEquals(t.getCause().getClass(), IOException.class);
-        if (t.getCause() != HttpUtils.REMOTELY_CLOSED_EXCEPTION) {
-            fail();
-        }
+        assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
     }
 
     private AsyncHttpClient newClient() {
@@ -189,7 +186,7 @@ private Realm realm(boolean preemptive) {
 
     @Override
     protected String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/";
+        return "http://localhost:" + port1 + "/";
     }
 
     @Override
diff --git a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
index b0b0f7c37..b3f8fafad 100644
--- a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -19,6 +19,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -81,16 +82,16 @@ public void tearDownGlobal() throws Exception {
 
     @Override
     protected String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/";
+        return "http://localhost:" + port1 + "/";
     }
 
     @Override
     protected String getTargetUrl2() {
-        return "http://127.0.0.1:" + port2 + "/uff";
+        return "http://localhost:" + port2 + "/uff";
     }
 
     protected String getTargetUrlNoAuth() {
-        return "http://127.0.0.1:" + portNoAuth + "/";
+        return "http://localhost:" + portNoAuth + "/";
     }
 
     @Override
@@ -116,7 +117,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
                 LOGGER.info("got redirected" + request.getRequestURI());
                 response.setStatus(200);
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
+                response.addHeader("X-" + HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getContentLength()));
                 byte[] b = "content".getBytes(UTF_8);
                 response.setContentLength(b.length);
                 response.getOutputStream().write(b);
@@ -136,7 +137,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
             } else {
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
+                response.addHeader("X-" + HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getContentLength()));
                 response.setStatus(200);
 
                 int size = 10 * 1024;
@@ -173,7 +174,7 @@ public void basicAuthTest() throws IOException, ExecutionException, TimeoutExcep
     }
 
     @Test(groups = "standalone")
-    public void redirectAndDigestAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
+    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
             Future<Response> f = client.prepareGet(getTargetUrl2())//
                     .setRealm(basicAuthRealm(USER, ADMIN).build())//
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index d5b0ff392..fef1f9d5c 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -643,7 +643,7 @@ public Response onCompleted(Response response) throws Exception {
 
     @Test(groups = "standalone")
     public void asyncDoPostProxyTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port2).build()))) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
             HttpHeaders h = new DefaultHttpHeaders();
             h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
             StringBuilder sb = new StringBuilder();
@@ -664,7 +664,7 @@ public void onThrowable(Throwable t) {
             }).get();
 
             assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Connection"), "keep-alive");
+            assertEquals(response.getHeader("X-" + HttpHeaders.Names.CONTENT_TYPE), HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
         }
     }
 
@@ -686,7 +686,7 @@ public void asyncRequestVirtualServerPOSTTest() throws Exception {
             if (response.getHeader("X-Host").startsWith("localhost")) {
                 assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
             } else {
-                assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
+                assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
             }
         }
     }
@@ -848,7 +848,7 @@ public void asyncConnectInvalidFuture() throws Exception {
             final AtomicInteger count = new AtomicInteger();
             for (int i = 0; i < 20; i++) {
                 try {
-                    Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    Response response = client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
                         @Override
                         public void onThrowable(Throwable t) {
                             count.incrementAndGet();
@@ -871,7 +871,7 @@ public void asyncConnectInvalidPortFuture() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             int dummyPort = findFreePort();
             try {
-                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                Response response = client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
                         t.printStackTrace();
@@ -894,7 +894,7 @@ public void asyncConnectInvalidPort() throws Exception {
             int port = findFreePort();
 
             try {
-                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                Response response = client.preparePost(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
                         t.printStackTrace();
@@ -913,7 +913,7 @@ public void asyncConnectInvalidHandlerPort() throws Exception {
             final CountDownLatch l = new CountDownLatch(1);
             int port = findFreePort();
 
-            client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+            client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                 @Override
                 public void onThrowable(Throwable t) {
                     try {
@@ -963,7 +963,7 @@ public void asyncConnectInvalidFuturePort() throws Exception {
             int port = findFreePort();
 
             try {
-                Response response = client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                Response response = client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
                         called.set(true);
@@ -1363,7 +1363,7 @@ public void getShouldAllowBody() throws IOException {
     @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
     public void invalidUri() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            client.prepareGet(String.format("http:127.0.0.1:%d/foo/test", port1)).build();
+            client.prepareGet(String.format("http:localhost:%d/foo/test", port1)).build();
         }
     }
 
@@ -1387,7 +1387,7 @@ public void mirrorByteTest() throws Exception {
 
     @Test(groups = "standalone")
     public void testNewConnectionEventsFired() throws Exception {
-        Request request = get("http://127.0.0.1:" + port1 + "/Test").build();
+        Request request = get("http://localhost:" + port1 + "/Test").build();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             EventCollectingHandler handler = new EventCollectingHandler();
@@ -1396,8 +1396,8 @@ public void testNewConnectionEventsFired() throws Exception {
 
             Object[] expectedEvents = new Object[] {//
             CONNECTION_POOL_EVENT,//
-                    DNS_RESOLUTION_EVENT,//
-                    DNS_RESOLUTION_SUCCESS_EVENT,//
+                    HOSTNAME_RESOLUTION_EVENT,//
+                    HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
                     CONNECTION_OPEN_EVENT,//
                     CONNECTION_SUCCESS_EVENT,//
                     REQUEST_SEND_EVENT,//
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 96102895d..c9d6440cb 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -31,14 +31,14 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.testng.annotations.Test;
 
 public class BasicHttpsTest extends AbstractBasicHttpsTest {
 
     protected String getTargetUrl() {
-        return String.format("https://127.0.0.1:%d/foo/test", port1);
+        return String.format("https://localhost:%d/foo/test", port1);
     }
 
     @Test(groups = "standalone")
@@ -138,8 +138,8 @@ public void testNormalEventsFired() throws Exception {
 
             Object[] expectedEvents = new Object[] { //
             CONNECTION_POOL_EVENT,//
-                    DNS_RESOLUTION_EVENT,//
-                    DNS_RESOLUTION_SUCCESS_EVENT,//
+                    HOSTNAME_RESOLUTION_EVENT,//
+                    HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
                     CONNECTION_OPEN_EVENT,//
                     CONNECTION_SUCCESS_EVENT,//
                     TLS_HANDSHAKE_EVENT,//
diff --git a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 8aecbe521..487faa8de 100644
--- a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
+++ b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -92,6 +92,6 @@ public State onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
     }
 
     public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
index 82d135dfe..64ba61992 100644
--- a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
+++ b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -45,7 +45,7 @@ public void multipleRequestsTest() throws Exception {
     public void urlWithoutSlashTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String body = "hello there";
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
         }
     }
diff --git a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
index b224bf324..b0c09e7aa 100644
--- a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -62,7 +62,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
                     .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
@@ -75,7 +75,7 @@ public void digestAuthTest() throws IOException, ExecutionException, TimeoutExce
     @Test(groups = "standalone")
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
                     .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
@@ -88,7 +88,7 @@ public void digestAuthTestWithoutScheme() throws IOException, ExecutionException
     @Test(groups = "standalone")
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm("fake", ADMIN).build())//
                     .execute();
             Response resp = f.get(20, TimeUnit.SECONDS);
diff --git a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index 3af1b6d59..c271f401d 100644
--- a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -63,7 +63,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void testQueryParameters() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 400);
diff --git a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index 69e0f44df..0ea397c33 100644
--- a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
+++ b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -18,6 +18,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.util.concurrent.Future;
@@ -61,7 +62,10 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void Expect100Continue() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(SIMPLE_TEXT_FILE).execute();
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")//
+                    .setHeader(HttpHeaders.Names.EXPECT, HttpHeaders.Values.CONTINUE)//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
diff --git a/client/src/test/java/org/asynchttpclient/Head302Test.java b/client/src/test/java/org/asynchttpclient/Head302Test.java
index 675d1d8ea..86c4a4076 100644
--- a/client/src/test/java/org/asynchttpclient/Head302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Head302Test.java
@@ -66,7 +66,7 @@ public AbstractHandler configureHandler() throws Exception {
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = head("http://127.0.0.1:" + port1 + "/Test").build();
+            Request request = head("http://localhost:" + port1 + "/Test").build();
 
             client.executeRequest(request, new AsyncCompletionHandlerBase() {
                 @Override
diff --git a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index a6731b761..22ff7a38d 100644
--- a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -58,7 +58,7 @@ public void testParameters() throws IOException, ExecutionException, TimeoutExce
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addFormParam("test", value).execute();
+            Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
             Response resp = f.get(10, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 2c97f1caa..df46cb0aa 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -132,7 +132,7 @@ public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
         try (AsyncHttpClient c = asyncHttpClient()) {
             // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 936f3347d..155ef642d 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -44,9 +44,9 @@
     private static final String MSG = "Enough is enough.";
 
     private void checkTimeoutMessage(String message) {
-        assertTrue(message.startsWith("Request timed out"), "error message indicates reason of error");
-        assertTrue(message.contains("127.0.0.1"), "error message contains remote ip address");
-        assertTrue(message.contains("of 100 ms"), "error message contains timeout configuration value");
+        assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
+        assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
+        assertTrue(message.contains("after 100ms"), "error message contains timeout configuration value but got: " + message);
     }
 
     @Override
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
index 6074b1386..ff6bf5525 100644
--- a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
@@ -70,7 +70,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
     @Test(groups = "standalone")
     public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -80,11 +80,11 @@ public void postWithQS() throws IOException, ExecutionException, TimeoutExceptio
     @Test(groups = "standalone")
     public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=")) {
                         throw new IOException(status.getUri().toUrl());
                     }
                     return super.onStatusReceived(status);
@@ -100,11 +100,11 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
     @Test(groups = "standalone")
     public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
@@ -120,11 +120,11 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
     @Test(groups = "standalone")
     public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
diff --git a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
index 5e61810d5..8b3429f2c 100644
--- a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
+++ b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -70,7 +70,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -97,7 +97,7 @@ public void testUrlRequestParametersEncoding() throws IOException, ExecutionExce
     public void urlWithColonTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String query = "test:colon:";
-            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
             assertEquals(response.getHeader("q"), query);
         }
diff --git a/client/src/test/java/org/asynchttpclient/RC10KTest.java b/client/src/test/java/org/asynchttpclient/RC10KTest.java
index ec745b463..f85bb3f59 100644
--- a/client/src/test/java/org/asynchttpclient/RC10KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC10KTest.java
@@ -96,7 +96,7 @@ public void rc10kProblem() throws IOException, ExecutionException, TimeoutExcept
             List<Future<Integer>> resps = new ArrayList<>(C10K);
             int i = 0;
             while (i < C10K) {
-                resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+                resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
             }
             i = 0;
             for (Future<Integer> fResp : resps) {
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index 602d8b0e5..d406748bb 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -2,6 +2,7 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
@@ -16,10 +17,18 @@
 import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
 public class RedirectBodyTest extends AbstractBasicTest {
 
+    private String receivedContentType;
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        receivedContentType = null;
+    }
+
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
@@ -41,6 +50,7 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
                         IOUtils.read(request.getInputStream(), buffer);
                         httpResponse.getOutputStream().write(buffer);
                     }
+                    receivedContentType = request.getContentType();
                 }
                 httpResponse.getOutputStream().flush();
                 httpResponse.getOutputStream().close();
@@ -60,9 +70,11 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
     public void regular301LosesBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
         }
     }
 
@@ -70,9 +82,11 @@ public void regular301LosesBody() throws Exception {
     public void regular302LosesBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
         }
     }
 
@@ -80,9 +94,11 @@ public void regular302LosesBody() throws Exception {
     public void regular302StrictKeepsBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
         }
     }
 
@@ -90,9 +106,11 @@ public void regular302StrictKeepsBody() throws Exception {
     public void regular307KeepsBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index e34647d76..584140cc9 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -100,7 +100,7 @@ public void redirected302InvalidTest() throws Exception {
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
index 55bc31e6d..8c35ea220 100644
--- a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -18,6 +18,7 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.InputStream;
 import java.net.URLEncoder;
@@ -142,10 +143,10 @@ public void invalidStreamTest2() throws Exception {
     @Test(groups = "online")
     public void asyncFullBodyProperlyRead() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
+            Response r = client.prepareGet("http://www.typesafe.com/").execute().get();
 
             InputStream stream = r.getResponseBodyAsStream();
-            int contentLength = Integer.valueOf(r.getHeader("Content-Length"));
+            int contentLength = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
 
             assertEquals(contentLength, IOUtils.toByteArray(stream).length);
         }
diff --git a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
index a4bad984a..826ee9b42 100644
--- a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
+++ b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -22,7 +22,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -60,7 +60,7 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/", port1);
+        return String.format("http://localhost:%d/", port1);
     }
 
     @Override
@@ -74,11 +74,7 @@ public void testMaxRetry() throws Exception {
             ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
             fail();
         } catch (Exception t) {
-            assertNotNull(t.getCause());
-            assertEquals(t.getCause().getClass(), IOException.class);
-            if (t.getCause() != HttpUtils.REMOTELY_CLOSED_EXCEPTION) {
-                fail();
-            }
+            assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
index 69aa1ee81..f3b68cd30 100644
--- a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
+++ b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -47,7 +47,7 @@
     public void testThreadName() throws Exception {
         String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
         try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
             f.get(3, TimeUnit.SECONDS);
 
             // We cannot assert that all threads are created with specified name,
diff --git a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
similarity index 94%
rename from client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
rename to client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
index 1cb37464d..5fbf469e6 100644
--- a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.channel.pool;
+package org.asynchttpclient.channel;
 
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.EventCollectingHandler.*;
@@ -37,6 +37,7 @@
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.exception.TooManyConnectionsException;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.testng.annotations.Test;
 
@@ -61,8 +62,8 @@ public void testMaxTotalConnections() throws Exception {
         }
     }
 
-    @Test(groups = "standalone")
-    public void testMaxTotalConnectionsException() throws IOException {
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void testMaxTotalConnectionsException() throws Throwable {
         try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
             String url = getTargetUrl();
 
@@ -83,8 +84,7 @@ public void testMaxTotalConnectionsException() throws IOException {
             }
 
             assertNotNull(exception);
-            assertNotNull(exception.getCause());
-            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
+            throw exception.getCause();
         }
     }
 
@@ -124,8 +124,8 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = "standalone")
-    public void multipleMaxConnectionOpenTest() throws Exception {
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void multipleMaxConnectionOpenTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
             String body = "hello there";
 
@@ -137,15 +137,14 @@ public void multipleMaxConnectionOpenTest() throws Exception {
             // twice
             Exception exception = null;
             try {
-                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
                 fail("Should throw exception. Too many connections issued.");
             } catch (Exception ex) {
                 ex.printStackTrace();
                 exception = ex;
             }
             assertNotNull(exception);
-            assertNotNull(exception.getCause());
-            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
+            throw exception.getCause();
         }
     }
 
@@ -262,7 +261,7 @@ public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
 
     @Test(groups = "standalone")
     public void testPooledEventsFired() throws Exception {
-        RequestBuilder request = get("http://127.0.0.1:" + port1 + "/Test");
+        RequestBuilder request = get("http://localhost:" + port1 + "/Test");
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             EventCollectingHandler firstHandler = new EventCollectingHandler();
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index ee768bcbb..e036e1c8a 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -132,7 +132,7 @@ public void setUpGlobal() throws Exception {
     }
 
     public String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/timeout/";
+        return "http://localhost:" + port1 + "/timeout/";
     }
 
     @SuppressWarnings("serial")
diff --git a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
index b94b3998e..a8ff8f354 100644
--- a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
+++ b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -60,7 +60,7 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 
     @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index f591e033e..0b1cbade9 100644
--- a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -112,7 +112,7 @@ public AsyncHttpClientConfig getAsyncHttpClientConfig() {
     @Test(groups = "standalone")
     public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredSimple");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
@@ -136,7 +136,7 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
     @Test(groups = "standalone", enabled = false)
     public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
 
             CountingOutputStream cos = new CountingOutputStream();
@@ -166,7 +166,7 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
     @Test(groups = "standalone")
     public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredInputStreamTrick");
 
             PipedOutputStream pos = new PipedOutputStream();
             PipedInputStream pis = new PipedInputStream(pos);
@@ -199,7 +199,7 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
     @Test(groups = "standalone")
     public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
             PipedOutputStream pos = new PipedOutputStream();
             PipedInputStream pis = new PipedInputStream(pos);
@@ -233,7 +233,7 @@ public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionE
     public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         int newPortWithoutAnyoneListening = findFreePort();
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 39061e10b..646a8326c 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -38,12 +38,8 @@ public void testCookieParseExpires() {
         Date date = new Date(System.currentTimeMillis() + 60000);
         final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
@@ -55,12 +51,9 @@ public HttpHeaders getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseMaxAge() {
         final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
@@ -71,12 +64,8 @@ public HttpHeaders getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseWeirdExpiresValue() {
         final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
diff --git a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index b09357987..f7b2c4b20 100644
--- a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -58,7 +58,7 @@ public void setUpGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/", port1);
+        return String.format("http://localhost:%d/", port1);
     }
 
     private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
diff --git a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
similarity index 94%
rename from client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
rename to client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
index 0b129b087..413efc72e 100644
--- a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.reactivestreams;
+package org.asynchttpclient.netty.handler;
 
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
@@ -127,25 +127,25 @@ public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<Htt
             this.replaying = replaying;
         }
         @Override
-        public void onDnsResolution(String name) {}
+        public void onHostnameResolutionAttempt(String name) {}
         @Override
-        public void onDnsResolutionSuccess(String name, List<InetSocketAddress> addresses) {}
+        public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {}
         @Override
-        public void onDnsResolutionFailure(String name, Throwable cause) {}
+        public void onHostnameResolutionFailure(String name, Throwable cause) {}
         @Override
-        public void onTcpConnect(InetSocketAddress address) {}
+        public void onTcpConnectAttempt(InetSocketAddress address) {}
         @Override
         public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {}
         @Override
         public void onTcpConnectFailure(InetSocketAddress address, Throwable cause) {}
         @Override
-        public void onTlsHandshake() {}
+        public void onTlsHandshakeAttempt() {}
         @Override
         public void onTlsHandshakeSuccess() {}
         @Override
         public void onTlsHandshakeFailure(Throwable cause) {}
         @Override
-        public void onConnectionPool() {}
+        public void onConnectionPoolAttempt() {}
         @Override
         public void onConnectionPooled(Channel connection) {}
         @Override
diff --git a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
index 1426e153c..73e84bf42 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
@@ -15,11 +15,6 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
@@ -68,35 +63,33 @@ public void tearDownGlobal() throws Exception {
     }
 
     @Test(groups = "standalone")
-    public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testRequestProxy() throws Exception {
 
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
             Response r = asyncHttpClient.executeRequest(rb.build()).get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 
     @Test(groups = "standalone")
-    public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testConfigProxy() throws Exception {
         AsyncHttpClientConfig config = config()//
                 .setFollowRedirect(true)//
-                .setProxyServer(proxyServer("127.0.0.1", port1).build())//
+                .setProxyServer(proxyServer("localhost", port1).build())//
                 .setAcceptAnyCertificate(true)//
                 .build();
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
             Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 
     @Test(groups = "standalone")
-    public void testPooledConnectionsWithProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testPooledConnectionsWithProxy() throws Exception {
 
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true).setKeepAlive(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
 
             Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
             assertEquals(r1.getStatusCode(), 200);
diff --git a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
index 98d36f397..3462be244 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
@@ -106,6 +106,6 @@ private ProxyServer ntlmProxy() throws UnknownHostException {
                 .setNtlmDomain("Ursa-Minor")//
                 .setNtlmHost("LightCity")//
                 .build();
-        return proxyServer("127.0.0.1", port2).setRealm(realm).build();
+        return proxyServer("localhost", port2).setRealm(realm).build();
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index 71b421aa1..f33037cbb 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -56,7 +56,7 @@
     public static class ProxyHandler extends AbstractHandler {
         public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
-                response.addHeader("target", r.getUri().getPath());
+                response.addHeader("target", r.getHttpURI().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
             } else {
                 // this handler is to handle POST request
@@ -74,8 +74,8 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -85,8 +85,8 @@ public void testRequestLevelProxy() throws IOException, ExecutionException, Time
 
     @Test(groups = "standalone")
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1)))) {
-            String target = "http://127.0.0.1:1234/";
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
+            String target = "http://localhost:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
@@ -97,9 +97,9 @@ public void testGlobalProxy() throws IOException, ExecutionException, TimeoutExc
 
     @Test(groups = "standalone")
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1 - 1)))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -129,11 +129,11 @@ public void testNonProxyHost() {
     @Test(groups = "standalone")
     public void testNonProxyHostsRequestOverridesConfig() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        ProxyServer configProxy = proxyServer("127.0.0.1", port1 - 1).build();
-        ProxyServer requestProxy = proxyServer("127.0.0.1", port1).setNonProxyHost("127.0.0.1").build();
+        ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
+        ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
-            String target = "http://127.0.0.1:1234/";
+            String target = "http://localhost:1234/";
             client.prepareGet(target).setProxyServer(requestProxy).execute().get();
             assertFalse(true);
         } catch (Throwable e) {
@@ -145,9 +145,9 @@ public void testNonProxyHostsRequestOverridesConfig() throws IOException, Execut
     @Test(groups = "standalone")
     public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        ProxyServer proxy = proxyServer("127.0.0.1", port1 - 1).setNonProxyHost("127.0.0.1").build();
+        ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:" + port1 + "/";
+            String target = "http://localhost:" + port1 + "/";
             Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
@@ -176,15 +176,15 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedtarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedtarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedtarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedtarget).execute();
             try {
                 resp = f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -201,13 +201,13 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
         originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
         System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
         System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
+            String target = "http://localhost:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
@@ -220,7 +220,7 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         }
     }
 
-     @Test(groups = "standalone", enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -232,15 +232,15 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 resp = f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -263,8 +263,8 @@ public void testWildcardNonProxyHosts() throws IOException, ExecutionException,
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -293,15 +293,15 @@ public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
         });
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
index fb8479112..1a10e2896 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
@@ -43,7 +43,7 @@ public static void start(int port) throws Exception {
                 .childHandler(new HttpStaticFileServerInitializer());
 
         b.bind(port).sync().channel();
-        LOGGER.info("Open your web browser and navigate to " + ("http") + "://127.0.0.1:" + port + '/');
+        LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
     }
 
     public static void shutdown() {
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index 6bee45f3e..f36894f61 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -49,7 +49,7 @@ public void tearDown() throws Exception {
     @Test(groups = "standalone")
     public void streamedResponseLargeFileTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            String largeFileName = "http://127.0.0.1:" + serverPort + "/" + largeFile.getName();
+            String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
             ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
             byte[] result = future.get().getBytes();
             assertEquals(result.length, largeFile.length());
@@ -59,7 +59,7 @@ public void streamedResponseLargeFileTest() throws Throwable {
     @Test(groups = "standalone")
     public void streamedResponseSmallFileTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            String smallFileName = "http://127.0.0.1:" + serverPort + "/" + smallFile.getName();
+            String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
             ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
             byte[] result = future.get().getBytes();
             LOGGER.debug("Result file size: " + result.length);
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
index e9fb7dd25..adc76b0d6 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -32,7 +32,7 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
 import org.testng.annotations.Test;
 
 public class ChunkingTest extends AbstractBasicTest {
@@ -74,7 +74,7 @@ public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable
     public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
 
-            final FeedableBodyGenerator feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+            final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
             Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
 
             ListenableFuture<Response> responseFuture = c.executeRequest(r);
@@ -85,7 +85,7 @@ public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
         }
     }
 
-    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws IOException {
+    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
         try (InputStream inputStream = is) {
             byte[] buffer = new byte[512];
             for (int i = 0; (i = inputStream.read(buffer)) > -1;) {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index 08579f49d..a6d51010e 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -71,7 +71,7 @@ public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutEx
             final AtomicBoolean headerSent = new AtomicBoolean(false);
             final AtomicBoolean operationCompleted = new AtomicBoolean(false);
 
-            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
+            Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
 
                 public State onHeadersWritten() {
                     headerSent.set(true);
@@ -99,7 +99,7 @@ public Response onCompleted(Response response) throws Exception {
     @Test(groups = "standalone")
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -118,7 +118,7 @@ public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutEx
         tmp.deleteOnExit();
         try (AsyncHttpClient client = asyncHttpClient()) {
             try (FileOutputStream stream = new FileOutputStream(tmp)) {
-                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                     public void onThrowable(Throwable t) {
                     }
 
@@ -151,7 +151,7 @@ public void zeroCopyFileWithBodyManipulationTest() throws IOException, Execution
         tmp.deleteOnExit();
         try (AsyncHttpClient client = asyncHttpClient()) {
             try (FileOutputStream stream = new FileOutputStream(tmp)) {
-                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                     public void onThrowable(Throwable t) {
                     }
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
index f20799fe4..332e8b7a7 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -28,12 +28,12 @@
 
 public class FeedableBodyGeneratorTest {
 
-    private SimpleFeedableBodyGenerator feedableBodyGenerator;
+    private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
     private TestFeedListener listener;
 
     @BeforeMethod
     public void setUp() throws Exception {
-        feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+        feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
         listener = new TestFeedListener();
         feedableBodyGenerator.setListener(listener);
     }
@@ -73,7 +73,7 @@ public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
         return readBytes;
     }
 
-    private static class TestFeedListener implements SimpleFeedableBodyGenerator.FeedListener {
+    private static class TestFeedListener implements FeedListener {
 
         private int calls;
 
diff --git a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
index 4d532a510..3d33cbdbb 100644
--- a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -37,9 +37,9 @@
     public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
     public static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
     public static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-    public static final String DNS_RESOLUTION_EVENT = "DnsResolution";
-    public static final String DNS_RESOLUTION_SUCCESS_EVENT = "DnsResolutionSuccess";
-    public static final String DNS_RESOLUTION_FAILURE_EVENT = "DnsResolutionFailure";
+    public static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+    public static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+    public static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
     public static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
     public static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
     public static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
@@ -95,7 +95,7 @@ public State onContentWritten() {
     }
 
     @Override
-    public void onTcpConnect(InetSocketAddress address) {
+    public void onTcpConnectAttempt(InetSocketAddress address) {
         firedEvents.add(CONNECTION_OPEN_EVENT);
     }
 
@@ -110,22 +110,22 @@ public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
     }
 
     @Override
-    public void onDnsResolution(String name) {
-        firedEvents.add(DNS_RESOLUTION_EVENT);
+    public void onHostnameResolutionAttempt(String name) {
+        firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
     }
 
     @Override
-    public void onDnsResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-        firedEvents.add(DNS_RESOLUTION_SUCCESS_EVENT);
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+        firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
     }
 
     @Override
-    public void onDnsResolutionFailure(String name, Throwable cause) {
-        firedEvents.add(DNS_RESOLUTION_FAILURE_EVENT);
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+        firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
     }
 
     @Override
-    public void onTlsHandshake() {
+    public void onTlsHandshakeAttempt() {
         firedEvents.add(TLS_HANDSHAKE_EVENT);
     }
 
@@ -140,7 +140,7 @@ public void onTlsHandshakeFailure(Throwable cause) {
     }
 
     @Override
-    public void onConnectionPool() {
+    public void onConnectionPoolAttempt() {
         firedEvents.add(CONNECTION_POOL_EVENT);
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index c43e0ba26..22061ee11 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -176,7 +176,6 @@ public static Server newJettyHttpServer(int port) {
     public static void addHttpConnector(Server server, int port) {
         ServerConnector connector = new ServerConnector(server);
         connector.setPort(port);
-
         server.addConnector(connector);
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
index 3df819975..cd87c7126 100644
--- a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
@@ -50,9 +50,9 @@ public void setUpGlobal() throws Exception {
         embedded.setCatalinaHome(path);
 
         Engine engine = embedded.createEngine();
-        engine.setDefaultHost("127.0.0.1");
+        engine.setDefaultHost("localhost");
 
-        Host host = embedded.createHost("127.0.0.1", path);
+        Host host = embedded.createHost("localhost", path);
         engine.addChild(host);
 
         Context c = embedded.createContext("/", path);
@@ -68,7 +68,7 @@ public void setUpGlobal() throws Exception {
         c.addChild(w);
         host.addChild(c);
 
-        Connector connector = embedded.createConnector("127.0.0.1", port1, Http11NioProtocol.class.getName());
+        Connector connector = embedded.createConnector("localhost", port1, Http11NioProtocol.class.getName());
         connector.setContainer(host);
         embedded.addEngine(engine);
         embedded.addConnector(connector);
@@ -81,7 +81,7 @@ public void tearDownGlobal() throws InterruptedException, Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%s/folder1", port1);
+        return String.format("http://localhost:%s/folder1", port1);
     }
 
     @AfterMethod(alwaysRun = true)
@@ -127,11 +127,11 @@ public void propFindWebDavTest() throws InterruptedException, IOException, Execu
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
-            Request putRequest = put(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
+            Request putRequest = put(String.format("http://localhost:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
             response = c.executeRequest(putRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
-            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://localhost:%s/folder1/Test.txt", port1)).build();
             response = c.executeRequest(propFindRequest).get();
 
             assertEquals(response.getStatusCode(), 207);
diff --git a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
index 2c74a0dfa..6f7709d0d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
@@ -38,7 +38,7 @@ public void tearDownGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("ws://127.0.0.1:%d/", port1);
+        return String.format("ws://localhost:%d/", port1);
     }
 
     public abstract WebSocketHandler getWebSocketHandler();
diff --git a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index b6f2adad8..13a32318c 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -80,10 +80,10 @@ private void runTest(boolean secure) throws Exception {
 
         setUpServers(secure);
 
-        String targetUrl = String.format("%s://127.0.0.1:%d/", secure ? "wss" : "ws", port2);
+        String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
 
         // CONNECT happens over HTTP, not HTTPS
-        ProxyServer ps = proxyServer("127.0.0.1", port1).build();
+        ProxyServer ps = proxyServer("localhost", port1).build();
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setAcceptAnyCertificate(true))) {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<String> text = new AtomicReference<>("");
diff --git a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index 81f8e3359..addc2575d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -104,6 +104,6 @@ public void onError(Throwable t) {
     }
 
     private String getRedirectURL() {
-        return String.format("ws://127.0.0.1:%d/", port2);
+        return String.format("ws://localhost:%d/", port2);
     }
 }
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index da1c721a8..54e980244 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC4-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 196cb4b59..163373f96 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.0-RC4-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index 96c98b4a3..e6e9b1219 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC4-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index b7c94e460..44a8640f5 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.0.0-SNAPSHOT</version>
+		<version>2.0.0-RC4-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 5a71e766d..c0cb8d77b 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC4-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 8aecdbd3c..bea0b8b2a 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC4-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
index 9adb88d1e..129f581ad 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
@@ -2,7 +2,6 @@
 
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
-import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
@@ -52,7 +51,7 @@ public void tearDownGlobal() throws Exception {
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setProxyHost("127.0.0.1")//
+                .setProxyHost("localhost")//
                 .setProxyPort(port1)//
                 .setFollowRedirect(true)//
                 .setUrl(getTargetUrl2())//
@@ -62,7 +61,6 @@ public void testSimpleAHCConfigProxy() throws IOException, InterruptedException,
             Response r = client.get().get();
 
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 }
diff --git a/pom.xml b/pom.xml
index f9c980cbe..e4b74d603 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.0.0-SNAPSHOT</version>
+	<version>2.0.0-RC4-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -382,7 +382,7 @@
 		<logback.version>1.1.3</logback.version>
 		<log4j.version>1.2.17</log4j.version>
 		<testng.version>6.9.9</testng.version>
-		<jetty.version>9.2.13.v20150730</jetty.version>
+		<jetty.version>9.3.6.v20151106</jetty.version>
 		<tomcat.version>6.0.29</tomcat.version>
 		<commons-io.version>2.4</commons-io.version>
 		<commons-fileupload.version>1.3</commons-fileupload.version>
