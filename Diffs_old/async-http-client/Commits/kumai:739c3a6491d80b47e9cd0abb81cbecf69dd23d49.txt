diff --git a/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java b/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
index 9ea1de660..8e155f8b5 100644
--- a/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
+++ b/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
@@ -16,68 +16,61 @@
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.handler.stream.ChunkedInput;
 
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
  * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
  */
-class BodyChunkedInput
-        implements ChunkedInput {
+class BodyChunkedInput implements ChunkedInput {
 
-    private final Body body;
-
-    private final int chunkSize = 1024 * 8;
+    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
 
-    private ByteBuffer nextChunk;
+    private final Body body;
+    private final int contentLength;
+    private final int chunkSize;
 
-    private static final ByteBuffer EOF = ByteBuffer.allocate(0);
+    private boolean endOfInput;
 
     public BodyChunkedInput(Body body) {
         if (body == null) {
             throw new IllegalArgumentException("no body specified");
         }
         this.body = body;
+        contentLength = (int) body.getContentLength();
+        if (contentLength <= 0)
+            chunkSize = DEFAULT_CHUNK_SIZE;
+        else
+            chunkSize = Math.min(contentLength, DEFAULT_CHUNK_SIZE);
     }
 
-    private ByteBuffer peekNextChuck()
-            throws IOException {
+    public boolean hasNextChunk() throws Exception {
+        // unused
+        throw new UnsupportedOperationException();
+    }
 
-        if (nextChunk == null) {
+    public Object nextChunk() throws Exception {
+        if (endOfInput) {
+            return null;
+        } else {
             ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-            if (body.read(buffer) < 0) {
-                nextChunk = EOF;
+            long r = body.read(buffer);
+            if (r < 0L) {
+                endOfInput = true;
+                return null;
             } else {
+                endOfInput = r == contentLength || r < chunkSize;
                 buffer.flip();
-                nextChunk = buffer;
+                return ChannelBuffers.wrappedBuffer(buffer);
             }
         }
-        return nextChunk;
-    }
-
-    public boolean hasNextChunk()
-            throws Exception {
-        return !isEndOfInput();
-    }
-
-    public Object nextChunk()
-            throws Exception {
-        ByteBuffer buffer = peekNextChuck();
-        if (buffer == EOF) {
-            return null;
-        }
-        nextChunk = null;
-        return ChannelBuffers.wrappedBuffer(buffer);
     }
 
-    public boolean isEndOfInput()
-            throws Exception {
-        return peekNextChuck() == EOF;
+    public boolean isEndOfInput() throws Exception {
+        // called by ChunkedWriteHandler AFTER nextChunk
+        return endOfInput;
     }
 
-    public void close()
-            throws Exception {
+    public void close() throws Exception {
         body.close();
     }
-
 }
