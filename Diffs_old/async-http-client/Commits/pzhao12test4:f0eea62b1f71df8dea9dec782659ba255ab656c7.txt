diff --git a/.travis.yml b/.travis.yml
index bb8adf60b..710d8d39c 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,28 +1,47 @@
-language: java
-jdk:
-  - oraclejdk8
-
-before_script:
-  - travis/before_script.sh
-
-script: 
-  - mvn test -Ptest-output
-  - find $HOME/.m2 -name "_remote.repositories" | xargs rm
-  - find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
-  
-# If building master, Publish to Sonatype
-after_success: 
-  - travis/after_success.sh
-
-sudo: false
-
-# https://github.com/travis-ci/travis-ci/issues/3259
 addons:
   apt:
     packages:
-      - oracle-java8-installer
-
-# Cache settings
+    - oracle-java8-installer
+after_success:
+- travis/after_success.sh
+before_cache:
+- rm -rf $HOME/CACHE; find $TRAVIS_BUILD_DIR -name .starts | while read line; do du
+  -sh $line;         DIR=$(dirname $HOME/CACHE$line); mkdir -p $DIR; cp -r $line $DIR;
+  done
+- find $TRAVIS_BUILD_DIR -name jdeps-cache | while read line; do du -sh $line;         DIR=$(dirname
+  $HOME/CACHE$line); mkdir -p $DIR; cp -r $line $DIR; done
+- echo CACHESIZE $(du -sk $HOME/CACHE)
+before_install:
+- find $HOME/CACHE -name jdeps-cache | while read line; do du -sh $line;         DIR=$(dirname
+  ${line#$HOME/CACHE}); if [[ -d ${DIR#jdeps-cache/} ]]; then cp -r $line $DIR; fi;
+  done
+- find $HOME/CACHE -name .starts | while read line; do du -sh $line;         DIR=$(dirname
+  ${line#$HOME/CACHE}); if [[ -d ${DIR#.starts/} ]]; then cp -r $line $DIR; fi; done
+before_script:
+- find $TRAVIS_BUILD_DIR -name .starts | while read line; do rm -rf $line; done
+- find $TRAVIS_BUILD_DIR -name jdeps-cache | while read line; do rm -rf $line; done
+- find $HOME/CACHE -name jdeps-cache | while read line; do du -sh $line;         DIR=$(dirname
+  ${line#$HOME/CACHE}); if [[ -d ${DIR#jdeps-cache/} ]]; then cp -r $line $DIR; fi;
+  done
+- find $HOME/CACHE -name .starts | while read line; do du -sh $line;         DIR=$(dirname
+  ${line#$HOME/CACHE}); if [[ -d ${DIR#.starts/} ]]; then cp -r $line $DIR; fi; done
+- travis/before_script.sh
 cache:
   directories:
-    - $HOME/.m2/repository
+  - $HOME/.m2/repository
+  - $HOME/CACHE
+jdk:
+- oraclejdk8
+language: java
+script:
+- touch NOW
+- echo GIBSTUDYSTART $(date)
+- mvn test -Ptest-output
+- find $HOME/.m2 -name "_remote.repositories" | xargs rm
+- find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
+- echo GIBSTUDYEND $(date)
+- cd $TRAVIS_BUILD_DIR
+- if [ "$TRAVIS_OS_NAME" == "osx" ];        then echo TESTNUM $(find . -name TEST-*.xml
+  -newer NOW | wc -l);        else echo TESTNUM $(find -name TEST-*.xml -newer NOW
+  | wc -l);        fi
+sudo: false
diff --git a/README.md b/README.md
index ea82bb06b..a8919ee79 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,20 @@
-# Async Http Client [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/)
+Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter) [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client)
+---------------------------------------------------
 
-Follow [@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on Twitter.
+[Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/)
 
-The AsyncHttpClient (AHC) library allows Java applications to easily execute HTTP requests and asynchronously process HTTP responses.
-The library also supports the WebSocket Protocol.
+[Getting](https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/) [started](https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/), and use [WebSockets](http://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/)
 
-It's built on top of [Netty](https://github.com/netty/netty). I's currently compiled on Java 8 but runs on Java 9 too.
+The Async Http Client library's purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
+The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
+
+It's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
+
+Latest `version`: [![Maven](https://img.shields.io/maven-central/v/org.asynchttpclient/async-http-client.svg)](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.asynchttpclient%22%20AND%20a%3A%22async-http-client%22)
 
 ## Installation
 
-Binaries are deployed on Maven central:
+First, in order to add it to your Maven project, simply download from Maven central or add this dependency:
 
 ```xml
 <dependency>
@@ -19,197 +24,168 @@ Binaries are deployed on Maven central:
 </dependency>
 ```
 
-## Basics
-
-Feel free to check the [Javadoc](http://www.javadoc.io/doc/org.asynchttpclient/async-http-client/) or the code for more information.
+## Usage
 
-### Dsl
-
-Import the Dsl helpers to use convenient methods to bootstrap components:
+Then in your code you can simply do
 
 ```java
-import static org.asynchttpclient.Dsl.*;
-```
-
-### Client
-
-```java
-import static org.asynchttpclient.Dsl.*;
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
 
-AsyncHttpClient asyncHttpClient = asyncHttpClient();
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+Future<Response> f = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+Response r = f.get();
 ```
 
-AsyncHttpClient instances must be closed (call the `close` method) once you're done with them, typically when shutting down your application.
-If you don't, you'll experience threads hanging and resource leaks.
-
-AsyncHttpClient instances are intended to be global resources that share the same lifecycle as the application.
-Typically, AHC will usually underperform if you create a new client for each request, as it will create new threads and connection pools for each.
-It's possible to create shared resources (EventLoop and Timer) beforehand and pass them to multiple client instances in the config. You'll then be responsible for closing those shared resources.
+Note that in this case all the content must be read fully in memory, even if you used `getResponseBodyAsStream()` method on returned `Response` object.
 
-## Configuration
-
-Finally, you can also configure the AsyncHttpClient instance via its AsyncHttpClientConfig object:
+You can also accomplish asynchronous (non-blocking) operation without using a Future if you want to receive and process the response in your handler:
 
 ```java
-import static org.asynchttpclient.Dsl.*;
-
-AsyncHttpClient c = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", 38080)));
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
+
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+asyncHttpClient.prepareGet("http://www.example.com/").execute(new AsyncCompletionHandler<Response>(){
+    
+    @Override
+    public Response onCompleted(Response response) throws Exception{
+        // Do something with the Response
+        // ...
+        return response;
+    }
+    
+    @Override
+    public void onThrowable(Throwable t){
+        // Something wrong happened.
+    }
+});
 ```
 
-## HTTP
-
-### Sending Requests
-
-### Basics
+(this will also fully read `Response` in memory before calling `onCompleted`)
 
-AHC provides 2 APIs for defining requests: bound and unbound.
-`AsyncHttpClient` and Dls` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
+Alternatively you may use continuations (through Java 8 class `CompletableFuture<T>`) to accomplish asynchronous (non-blocking) solution. The equivalent continuation approach to the previous example is:
 
 ```java
-import org.asynchttpclient.*;
+import static org.asynchttpclient.Dsl.*;
 
-// bound
-Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
+import org.asynchttpclient.*;
+import java.util.concurrent.CompletableFuture;
 
-// unbound
-Request request = get("http://www.example.com/");
-Future<Response> whenResponse = asyncHttpClient.executeRequest("http://www.example.com/").execute();
+AsyncHttpClient asyncHttpClient = asyncHttpClient();
+CompletableFuture<Response> promise = asyncHttpClient
+            .prepareGet("http://www.example.com/")
+            .execute()
+            .toCompletableFuture()
+            .exceptionally(t -> { /* Something wrong happened... */  } )
+            .thenApply(resp -> { /*  Do something with the Response */ return resp; });
+promise.join(); // wait for completion
 ```
 
-#### Setting Request Body
-
-Use the `setBody` method to add a body to the request.
-
-This body can be of type:
-* `java.io.File`
-* `byte[]`
-* `List<byte[]>`
-* `String`
-* `java.nio.ByteBuffer`
-* `java.io.InputStream`
-* `Publisher<io.netty.bufferByteBuf>`
-* `org.asynchttpclient.request.body.generator.BodyGenerator`
-
-`BodyGenerator` is a generic abstraction that let you create request bodies on the fly.
-Have a look at `FeedableBodyGenerator` if you're looking for a way to pass requests chunks on the fly. 
-
-#### Multipart
-
-Use the `addBodyPart` method to add a multipart part to the request.
-
-This part can be of type:
-* `ByteArrayPart`
-* `FilePart`
-* `StringPart`
-
-### Dealing with Responses
-
-#### Blocking on the Future
+You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
 
-`execute` methods return a `java.util.concurrent.Future`. You can simply both the calling thread to get the response.
+You can also mix Future with AsyncHandler to only retrieve part of the asynchronous response
 
 ```java
-Future<Response> whenResponse = asyncHttpClient.prepareGet("http://www.example.com/").execute();
-Response response = whenResponse.get();
-```
-
-This is useful for debugging but you'll most likely hurt performance or create bugs when running such code on production.
-The point of using a non blocking client is to *NOT BLOCK* the calling thread!
-
-### Setting callbacks on the ListenableFuture
-
-`execute` methods actually return a `org.asynchttpclient.ListenableFuture` similar to Guava's.
-You can configure listeners to be notified of the Future's completion. 
+import org.asynchttpclient.*;
+import java.util.concurrent.Future;
+
+AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient();
+Future<Integer> f = asyncHttpClient.prepareGet("http://www.example.com/").execute(
+   new AsyncCompletionHandler<Integer>(){
+    
+    @Override
+    public Integer onCompleted(Response response) throws Exception{
+        // Do something with the Response
+        return response.getStatusCode();
+    }
+    
+    @Override
+    public void onThrowable(Throwable t){
+        // Something wrong happened.
+    }
+});
 
-```java
-ListenableFuture<Response> whenResponse = ???;
-Runnable callback = () -> {
-	try  {
-		Response response = whenResponse.get();
-		System.out.println(response);
-	} catch (InterruptedException | ExecutionException e) {
-		e.printStackTrace();
-	}
-};
-java.util.concurrent.Executor executor = ???;
-whenResponse.addListener(() -> ???, executor);
+int statusCode = f.get();
 ```
 
-If the `executor` parameter is null, callback will be executed in the IO thread.
-You *MUST NEVER PERFORM BLOCKING* operations in there, typically sending another request and block on a future.
+which is something you want to do for large responses: this way you can process content as soon as it becomes available, piece by piece, without having to buffer it all in memory.
 
-#### Using custom AsyncHandlers
-
-`execute` methods can take an `org.asynchttpclient.AsyncHandler` to be notified on the different events, such as receiving the status, the headers and body chunks.
-When you don't specify one, AHC will use a `org.asynchttpclient.AsyncCompletionHandler`;
-
-`AsyncHandler` methods can let you abort processing early (return `AsyncHandler.State.ABORT`) and can let you return a computation result from `onCompleted` that will be used as the Future's result.
-See `AsyncCompletionHandler` implementation as an example.
-
-The below sample just capture the response status and skips processing the response body chunks.
-
-Note that returning `ABORT` closed the underlying connection.
+ You have full control on the Response life cycle, so you can decide at any moment to stop processing what the server is sending back:
 
 ```java
 import static org.asynchttpclient.Dsl.*;
+
 import org.asynchttpclient.*;
-import io.netty.handler.codec.http.HttpHeaders;
-
-Future<Integer> f = asyncHttpClient.prepareGet("http://www.example.com/")
-.execute(new AsyncHandler<Integer>() {
-	private Integer status;
-	@Override
-	public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-		status = responseStatus.getStatusCode();
-		return State.ABORT;
-	}
-	@Override
-	public State onHeadersReceived(HttpHeaders headers) throws Exception {
-		return State.ABORT;
-	}
-	@Override
-	public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-		return State.ABORT;
-	}
-	@Override
-	public Integer onCompleted() throws Exception {
-		return status;
-	}
-	@Override
-	public void onThrowable(Throwable t) {
-	}
+import java.util.concurrent.Future;
+
+AsyncHttpClient c = asyncHttpClient();
+Future<String> f = c.prepareGet("http://www.example.com/").execute(new AsyncHandler<String>() {
+    private ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+
+    @Override
+    public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
+        int statusCode = status.getStatusCode();
+        // The Status have been read
+        // If you don't want to read the headers,body or stop processing the response
+        if (statusCode >= 500) {
+            return STATE.ABORT;
+        }
+    }
+
+    @Override
+    public STATE onHeadersReceived(HttpResponseHeaders h) throws Exception {
+        Headers headers = h.getHeaders();
+         // The headers have been read
+         // If you don't want to read the body, or stop processing the response
+         return STATE.ABORT;
+    }
+
+    @Override
+    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+         bytes.write(bodyPart.getBodyPartBytes());
+         return STATE.CONTINUE;
+    }
+
+    @Override
+    public String onCompleted() throws Exception {
+         // Will be invoked once the response has been fully read or a ResponseComplete exception
+         // has been thrown.
+         // NOTE: should probably use Content-Encoding from headers
+         return bytes.toString("UTF-8");
+    }
+
+    @Override
+    public void onThrowable(Throwable t) {
+    }
 });
 
-Integer statusCode = f.get();
+String bodyResponse = f.get();
 ```
 
-#### Using Continuations
+## Configuration
 
-`ListenableFuture` has a `toCompletableFuture` that returns a `CompletableFuture`.
-Beware that canceling this `CompletableFuture` won't properly cancel the ongoing request.
-There's a very good chance we'll return a `CompletionStage` instead in the next release.
+Finally, you can also configure the AsyncHttpClient via its AsyncHttpClientConfig object:
 
 ```java
-CompletableFuture<Response> promise = asyncHttpClient
-            .prepareGet("http://www.example.com/")
-            .execute()
-            .toCompletableFuture()
-            .exceptionally(t -> { /* Something wrong happened... */  } )
-            .thenApply(resp -> { /*  Do something with the Response */ return resp; });
-promise.join(); // wait for completion
-```
+AsyncHttpClientConfig cf = new DefaultAsyncHttpClientConfig.Builder()
+    .setProxyServer(new ProxyServer.Builder("127.0.0.1", 38080)).build();
 
-You may get the complete maven project for this simple demo from [org.asynchttpclient.example](https://github.com/AsyncHttpClient/async-http-client/tree/master/example/src/main/java/org/asynchttpclient/example)
+AsyncHttpClient c = new DefaultAsyncHttpClient(cf);
+```
 
 ## WebSocket
 
-Async Http Client also supports WebSocket.
-You need to pass a `WebSocketUpgradeHandler` where you would register a `WebSocketListener`.
+Async Http Client also support WebSocket by simply doing:
 
 ```java
-WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
+WebSocket websocket = c.prepareGet(getTargetUrl())
       .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(
-          new WebSocketListener() {
+          new WebSocketTextListener() {
+
+          @Override
+          public void onMessage(String message) {
+          }
 
           @Override
           public void onOpen(WebSocket websocket) {
@@ -218,11 +194,7 @@ WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
 
           @Override
           public void onClose(WebSocket websocket) {
-          }
-          
-    		  @Override
-          public void onTextFrame(String payload, boolean finalFragment, int rsv) {
-          	System.out.println(payload);
+              latch.countDown();
           }
 
           @Override
@@ -231,41 +203,6 @@ WebSocket websocket = c.prepareGet("ws://demos.kaazing.com/echo")
       }).build()).get();
 ```
 
-## Reactive Streams
-
-AsyncHttpClient has build in support for reactive streams.
-
-You can pass a request body as a `Publisher<ByteBuf>` or a `ReactiveStreamsBodyGenerator`.
-
-You can also pass a `StreamedAsyncHandler<T>` whose `onStream` method will be notified with a `Publisher<HttpResponseBodyPart>`.
-
-See tests in package `org.asynchttpclient.reactivestreams` for examples.
-
-## WebDAV
-
-AsyncHttpClient has build in support for the WebDAV protocol.
-The API can be used the same way normal HTTP request are made:
-
-```java
-Request mkcolRequest = new RequestBuilder("MKCOL").setUrl("http://host:port/folder1").build();
-Response response = c.executeRequest(mkcolRequest).get();
-```
-or
-
-```java
-Request propFindRequest = new RequestBuilder("PROPFIND").setUrl("http://host:port).build();
-Response response = c.executeRequest(propFindRequest, new AsyncHandler(){...}).get();
-```
-
-## More
-
-You can find more information on Jean-François Arcand's blog.  Jean-François is the original author of this library.
-Code is sometimes not up-to-date but gives a pretty good idea of advanced features.
-
-* https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/
-* https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/
-* https://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/
-
 ## User Group
 
 Keep up to date on the library development by joining the Asynchronous HTTP Client discussion group
diff --git a/client/pom.xml b/client/pom.xml
index 4d87b8d4f..ee1eb829f 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.1.0-RC2-SNAPSHOT</version>
+		<version>2.1.0-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index 3a21c8c05..5cb8530f8 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -23,106 +23,90 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)}
- * convenience method which gets called when the {@link Response} processing is
- * finished. This class also implement the {@link ProgressAsyncHandler}
- * callback, all doing nothing except returning
- * {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
+ * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)} convenience method which gets called when the {@link Response} processing is finished. This class also
+ * implement the {@link ProgressAsyncHandler} callback, all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
  *
- * @param <T>
- *            Type of the value that will be returned by the associated
- *            {@link java.util.concurrent.Future}
+ * @param <T> Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
  */
 public abstract class AsyncCompletionHandler<T> implements AsyncHandler<T>, ProgressAsyncHandler<T> {
 
-	private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
-	private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
+    private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-	@Override
-	public State onStatusReceived(HttpResponseStatus status) throws Exception {
-		builder.reset();
-		builder.accumulate(status);
-		return State.CONTINUE;
-	}
+    @Override
+    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+        builder.accumulate(content);
+        return State.CONTINUE;
+    }
 
-	@Override
-	public State onHeadersReceived(HttpHeaders headers) throws Exception {
-		builder.accumulate(headers);
-		return State.CONTINUE;
-	}
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+        builder.reset();
+        builder.accumulate(status);
+        return State.CONTINUE;
+    }
 
-	@Override
-	public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-		builder.accumulate(content);
-		return State.CONTINUE;
-	}
+    @Override
+    public State onHeadersReceived(HttpHeaders headers) throws Exception {
+        builder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
-	@Override
-	public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
-		builder.accumulate(headers);
-		return State.CONTINUE;
-	}
+    @Override
+    public State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
+        builder.accumulate(headers);
+        return State.CONTINUE;
+    }
 
-	@Override
-	public final T onCompleted() throws Exception {
-		return onCompleted(builder.build());
-	}
+    @Override
+    public final T onCompleted() throws Exception {
+        return onCompleted(builder.build());
+    }
 
-	@Override
-	public void onThrowable(Throwable t) {
-		LOGGER.debug(t.getMessage(), t);
-	}
+    @Override
+    public void onThrowable(Throwable t) {
+        LOGGER.debug(t.getMessage(), t);
+    }
 
-	/**
-	 * Invoked once the HTTP response processing is finished.
-	 *
-	 * @param response
-	 *            The {@link Response}
-	 * @return T Value that will be returned by the associated
-	 *         {@link java.util.concurrent.Future}
-	 * @throws Exception
-	 *             if something wrong happens
-	 */
-	abstract public T onCompleted(Response response) throws Exception;
+    /**
+     * Invoked once the HTTP response processing is finished.
+     *
+     * @param response The {@link Response}
+     * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @throws Exception if something wrong happens
+     */
+    abstract public T onCompleted(Response response) throws Exception;
 
-	/**
-	 * Invoked when the HTTP headers have been fully written on the I/O socket.
-	 *
-	 * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-	 *         or ABORT the current processing.
-	 */
-	@Override
-	public State onHeadersWritten() {
-		return State.CONTINUE;
-	}
+    /**
+     * Invoked when the HTTP headers have been fully written on the I/O socket.
+     *
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onHeadersWritten() {
+        return State.CONTINUE;
+    }
 
-	/**
-	 * Invoked when the content (a {@link java.io.File}, {@link String} or
-	 * {@link java.io.InputStream} has been fully written on the I/O socket.
-	 *
-	 * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-	 *         or ABORT the current processing.
-	 */
-	@Override
-	public State onContentWritten() {
-		return State.CONTINUE;
-	}
+    /**
+     * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.InputStream} has been fully written on the I/O socket.
+     *
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onContentWritten() {
+        return State.CONTINUE;
+    }
 
-	/**
-	 * Invoked when the I/O operation associated with the {@link Request} body as
-	 * been progressed.
-	 *
-	 * @param amount
-	 *            The amount of bytes to transfer
-	 * @param current
-	 *            The amount of bytes transferred
-	 * @param total
-	 *            The total number of bytes transferred
-	 * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE
-	 *         or ABORT the current processing.
-	 */
-	@Override
-	public State onContentWriteProgress(long amount, long current, long total) {
-		return State.CONTINUE;
-	}
+    /**
+     * Invoked when the I/O operation associated with the {@link Request} body as been progressed.
+     *
+     * @param amount The amount of bytes to transfer
+     * @param current The amount of bytes transferred
+     * @param total The total number of bytes transferred
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
+     */
+    @Override
+    public State onContentWriteProgress(long amount, long current, long total) {
+        return State.CONTINUE;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHandler.java b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
index ab7efd2cf..0bade6f47 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -15,12 +15,6 @@
  */
 package org.asynchttpclient;
 
-import java.net.InetSocketAddress;
-import java.util.List;
-
-import org.asynchttpclient.netty.request.NettyRequest;
-
-import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 
 
@@ -69,6 +63,25 @@
          */
         CONTINUE
     }
+
+    /**
+     * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
+     * produced by implementation of onXXXReceived method invocation.
+     *
+     * @param t a {@link Throwable}
+     */
+    void onThrowable(Throwable t);
+
+    /**
+     * Invoked as soon as some response body part are received. Could be invoked many times.
+     * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
+     *
+     * @param bodyPart response's body part.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
+     * @throws Exception if something wrong happens
+     */
+    State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
+
     /**
      * Invoked as soon as the HTTP status line has been received
      *
@@ -87,16 +100,6 @@
      */
     State onHeadersReceived(HttpHeaders headers) throws Exception;
     
-    /**
-     * Invoked as soon as some response body part are received. Could be invoked many times.
-     * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
-     *
-     * @param bodyPart response's body part.
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
-     * @throws Exception if something wrong happens
-     */
-    State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
-    
     /**
      * Invoked when trailing headers have been received. 
      * @param headers the trailing HTTP headers.
@@ -106,14 +109,6 @@
     default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
         return State.CONTINUE;
     }
-    
-    /**
-     * Invoked when an unexpected exception occurs during the processing of the response. The exception may have been
-     * produced by implementation of onXXXReceived method invocation.
-     *
-     * @param t a {@link Throwable}
-     */
-    void onThrowable(Throwable t);
 
     /**
      * Invoked once the HTTP response processing is finished.
@@ -124,127 +119,4 @@ default State onTrailingHeadersReceived(HttpHeaders headers) throws Exception {
      * @throws Exception if something wrong happens
      */
     T onCompleted() throws Exception;
-    
-    // ////////// DNS /////////////////
-
-    /**
-     * Notify the callback before hostname resolution
-     * 
-     * @param name the name to be resolved
-     */
-    default void onHostnameResolutionAttempt(String name) {
-    }
-
-    /**
-     * Notify the callback after hostname resolution was successful.
-     * 
-     * @param name the name to be resolved
-     * @param addresses the resolved addresses
-     */
-    default void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
-    }
-
-    /**
-     * Notify the callback after hostname resolution failed.
-     * 
-     * @param name the name to be resolved
-     * @param cause the failure cause
-     */
-    default void onHostnameResolutionFailure(String name, Throwable cause) {
-    }
-
-    // ////////////// TCP CONNECT ////////
-
-    /**
-     * Notify the callback when trying to open a new connection.
-     * 
-     * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
-     * 
-     * @param remoteAddress the address we try to connect to
-     */
-    default void onTcpConnectAttempt(InetSocketAddress remoteAddress) {
-    }
-
-    /**
-     * Notify the callback after a successful connect
-     * 
-     * @param remoteAddress the address we try to connect to
-     * @param connection the connection
-     */
-    default void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
-    }
-
-    /**
-     * Notify the callback after a failed connect.
-     * 
-     * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
-     * 
-     * @param remoteAddress the address we try to connect to
-     * @param cause the cause of the failure
-     */
-    default void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
-    }
-
-    // ////////////// TLS ///////////////
-
-    /**
-     * Notify the callback before TLS handshake
-     */
-    default void onTlsHandshakeAttempt() {
-    }
-
-    /**
-     * Notify the callback after the TLS was successful
-     */
-    default void onTlsHandshakeSuccess() {
-    }
-
-    /**
-     * Notify the callback after the TLS failed
-     * 
-     * @param cause the cause of the failure
-     */
-    default void onTlsHandshakeFailure(Throwable cause) {
-    }
-
-    // /////////// POOLING /////////////
-
-    /**
-     * Notify the callback when trying to fetch a connection from the pool.
-     */
-    default void onConnectionPoolAttempt() {
-    }
-
-    /**
-     * Notify the callback when a new connection was successfully fetched from the pool.
-     * 
-     * @param connection the connection
-     */
-    default void onConnectionPooled(Channel connection) {
-    }
-
-    /**
-     * Notify the callback when trying to offer a connection to the pool.
-     * 
-     * @param connection the connection
-     */
-    default void onConnectionOffer(Channel connection) {
-    }
-
-    // //////////// SENDING //////////////
-
-    /**
-     * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
-     * retry, it will be notified multiple times.
-     * 
-     * @param request the real request object as passed to the provider
-     */
-    default void onRequestSend(NettyRequest request) {
-    }
-
-    /**
-     * Notify the callback every time a request is being retried.
-     */
-    default void onRetry() {
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index bfb1466d1..d1395bc00 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -13,10 +13,17 @@
  */
 package org.asynchttpclient;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.ssl.SslContext;
+import io.netty.util.Timer;
+
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
-import java.util.function.Consumer;
 
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.KeepAliveStrategy;
@@ -28,14 +35,6 @@
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.handler.ssl.SslContext;
-import io.netty.util.Timer;
-
 public interface AsyncHttpClientConfig {
 
     /**
@@ -273,9 +272,9 @@
 
     boolean isUseNativeTransport();
 
-    Consumer<Channel> getHttpAdditionalChannelInitializer();
+    AdditionalChannelInitializer getHttpAdditionalChannelInitializer();
 
-    Consumer<Channel> getWsAdditionalChannelInitializer();
+    AdditionalChannelInitializer getWsAdditionalChannelInitializer();
 
     ResponseBodyPartFactory getResponseBodyPartFactory();
 
@@ -303,6 +302,11 @@
 
     int getIoThreadsCount();
 
+    interface AdditionalChannelInitializer {
+
+        void initChannel(Channel channel) throws Exception;
+    }
+
     enum ResponseBodyPartFactory {
 
         EAGER {
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index bd90c0e46..bded469db 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -17,6 +17,9 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import io.netty.channel.EventLoopGroup;
+import io.netty.util.HashedWheelTimer;
+import io.netty.util.Timer;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Predicate;
@@ -27,14 +30,11 @@
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ConnectionSemaphore;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.HashedWheelTimer;
-import io.netty.util.Timer;
-
 /**
  * Default and threadsafe implementation of {@link AsyncHttpClient}.
  */
@@ -42,9 +42,9 @@
 
     private final static Logger LOGGER = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
     private final AsyncHttpClientConfig config;
-    private final boolean noRequestFilters;
     private final AtomicBoolean closed = new AtomicBoolean(false);
     private final ChannelManager channelManager;
+    private final ConnectionSemaphore connectionSemaphore;
     private final NettyRequestSender requestSender;
     private final boolean allowStopNettyTimer;
     private final Timer nettyTimer;
@@ -52,6 +52,8 @@
     /**
      * Default signature calculator to use for all requests constructed by this
      * client instance.
+     *
+     * @since 1.1
      */
     protected SignatureCalculator signatureCalculator;
 
@@ -79,12 +81,13 @@ public DefaultAsyncHttpClient() {
     public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
 
         this.config = config;
-        this.noRequestFilters = config.getRequestFilters().isEmpty();
+
         allowStopNettyTimer = config.getNettyTimer() == null;
         nettyTimer = allowStopNettyTimer ? newNettyTimer() : config.getNettyTimer();
 
         channelManager = new ChannelManager(config, nettyTimer);
-        requestSender = new NettyRequestSender(config, channelManager, nettyTimer, new AsyncHttpClientState(closed));
+        connectionSemaphore = new ConnectionSemaphore(config);
+        requestSender = new NettyRequestSender(config, channelManager, connectionSemaphore, nettyTimer, new AsyncHttpClientState(closed));
         channelManager.configureBootstraps(requestSender);
     }
 
@@ -180,8 +183,10 @@ public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
 
     @Override
     public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
-        if (noRequestFilters) {
+
+        if (config.getRequestFilters().isEmpty()) {
             return execute(request, handler);
+
         } else {
             FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
             try {
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 4fe13015c..2010c4594 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -16,12 +16,21 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.ssl.SslContext;
+import io.netty.util.Timer;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.*;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
 import java.util.concurrent.ThreadFactory;
-import java.util.function.Consumer;
 
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
@@ -33,13 +42,6 @@
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.handler.ssl.SslContext;
-import io.netty.util.Timer;
-
 /**
  * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this object default behavior by doing: <br>
  * -Dorg.asynchttpclient.nameOfTheProperty
@@ -130,8 +132,8 @@
     private final int soRcvBuf;
     private final Timer nettyTimer;
     private final ThreadFactory threadFactory;
-    private final Consumer<Channel> httpAdditionalChannelInitializer;
-    private final Consumer<Channel> wsAdditionalChannelInitializer;
+    private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
+    private final AdditionalChannelInitializer wsAdditionalChannelInitializer;
     private final ResponseBodyPartFactory responseBodyPartFactory;
     private final int ioThreadsCount;
 
@@ -208,8 +210,8 @@ private DefaultAsyncHttpClientConfig(//
             ByteBufAllocator allocator,//
             Timer nettyTimer,//
             ThreadFactory threadFactory,//
-            Consumer<Channel> httpAdditionalChannelInitializer,//
-            Consumer<Channel> wsAdditionalChannelInitializer,//
+            AdditionalChannelInitializer httpAdditionalChannelInitializer,//
+            AdditionalChannelInitializer wsAdditionalChannelInitializer,//
             ResponseBodyPartFactory responseBodyPartFactory,//
             int ioThreadsCount) {
 
@@ -600,12 +602,12 @@ public ThreadFactory getThreadFactory() {
     }
 
     @Override
-    public Consumer<Channel> getHttpAdditionalChannelInitializer() {
+    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
         return httpAdditionalChannelInitializer;
     }
 
     @Override
-    public Consumer<Channel> getWsAdditionalChannelInitializer() {
+    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
         return wsAdditionalChannelInitializer;
     }
 
@@ -698,8 +700,8 @@ public int getIoThreadsCount() {
         private EventLoopGroup eventLoopGroup;
         private Timer nettyTimer;
         private ThreadFactory threadFactory;
-        private Consumer<Channel> httpAdditionalChannelInitializer;
-        private Consumer<Channel> wsAdditionalChannelInitializer;
+        private AdditionalChannelInitializer httpAdditionalChannelInitializer;
+        private AdditionalChannelInitializer wsAdditionalChannelInitializer;
         private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
         private int ioThreadsCount = defaultIoThreadsCount();
 
@@ -1115,12 +1117,12 @@ public Builder setThreadFactory(ThreadFactory threadFactory) {
             return this;
         }
 
-        public Builder setHttpAdditionalChannelInitializer(Consumer<Channel> httpAdditionalChannelInitializer) {
+        public Builder setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
             this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
             return this;
         }
 
-        public Builder setWsAdditionalChannelInitializer(Consumer<Channel> wsAdditionalChannelInitializer) {
+        public Builder setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
             this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
             return this;
         }
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 442922165..a80da0ed6 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -18,12 +18,12 @@
 
 import static java.nio.charset.StandardCharsets.*;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledMd5MessageDigest;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.asynchttpclient.util.StringUtils.*;
 
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.ThreadLocalRandom;
 
 import org.asynchttpclient.uri.Uri;
@@ -32,475 +32,486 @@
 import org.asynchttpclient.util.StringUtils;
 
 /**
- * This class is required when authentication is needed. The class support
- * BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
+ * This class is required when authentication is needed. The class support BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
  */
 public class Realm {
 
-	private static final String DEFAULT_NC = "00000001";
-	// MD5("")
-	private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
-
-	private final String principal;
-	private final String password;
-	private final AuthScheme scheme;
-	private final String realmName;
-	private final String nonce;
-	private final String algorithm;
-	private final String response;
-	private final String opaque;
-	private final String qop;
-	private final String nc;
-	private final String cnonce;
-	private final Uri uri;
-	private final boolean usePreemptiveAuth;
-	private final Charset charset;
-	private final String ntlmHost;
-	private final String ntlmDomain;
-	private final boolean useAbsoluteURI;
-	private final boolean omitQuery;
-
-	public enum AuthScheme {
-		BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
-	}
-
-	private Realm(AuthScheme scheme, //
-			String principal, //
-			String password, //
-			String realmName, //
-			String nonce, //
-			String algorithm, //
-			String response, //
-			String opaque, //
-			String qop, //
-			String nc, //
-			String cnonce, //
-			Uri uri, //
-			boolean usePreemptiveAuth, //
-			Charset charset, //
-			String ntlmDomain, //
-			String ntlmHost, //
-			boolean useAbsoluteURI, //
-			boolean omitQuery) {
-
-		this.scheme = assertNotNull(scheme, "scheme");
-		this.principal = assertNotNull(principal, "principal");
-		this.password = assertNotNull(password, "password");
-		this.realmName = realmName;
-		this.nonce = nonce;
-		this.algorithm = algorithm;
-		this.response = response;
-		this.opaque = opaque;
-		this.qop = qop;
-		this.nc = nc;
-		this.cnonce = cnonce;
-		this.uri = uri;
-		this.usePreemptiveAuth = usePreemptiveAuth;
-		this.charset = charset;
-		this.ntlmDomain = ntlmDomain;
-		this.ntlmHost = ntlmHost;
-		this.useAbsoluteURI = useAbsoluteURI;
-		this.omitQuery = omitQuery;
-	}
-
-	public String getPrincipal() {
-		return principal;
-	}
-
-	public String getPassword() {
-		return password;
-	}
-
-	public AuthScheme getScheme() {
-		return scheme;
-	}
-
-	public String getRealmName() {
-		return realmName;
-	}
-
-	public String getNonce() {
-		return nonce;
-	}
-
-	public String getAlgorithm() {
-		return algorithm;
-	}
-
-	public String getResponse() {
-		return response;
-	}
-
-	public String getOpaque() {
-		return opaque;
-	}
-
-	public String getQop() {
-		return qop;
-	}
-
-	public String getNc() {
-		return nc;
-	}
-
-	public String getCnonce() {
-		return cnonce;
-	}
-
-	public Uri getUri() {
-		return uri;
-	}
-
-	public Charset getCharset() {
-		return charset;
-	}
-
-	/**
-	 * Return true is preemptive authentication is enabled
-	 * 
-	 * @return true is preemptive authentication is enabled
-	 */
-	public boolean isUsePreemptiveAuth() {
-		return usePreemptiveAuth;
-	}
-
-	/**
-	 * Return the NTLM domain to use. This value should map the JDK
-	 * 
-	 * @return the NTLM domain
-	 */
-	public String getNtlmDomain() {
-		return ntlmDomain;
-	}
-
-	/**
-	 * Return the NTLM host.
-	 * 
-	 * @return the NTLM host
-	 */
-	public String getNtlmHost() {
-		return ntlmHost;
-	}
-
-	public boolean isUseAbsoluteURI() {
-		return useAbsoluteURI;
-	}
-
-	public boolean isOmitQuery() {
-		return omitQuery;
-	}
-
-	@Override
-	public String toString() {
-		return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\''
-				+ ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm + '\'' + ", response='" + response + '\''
-				+ ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
-				+ ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
-	}
-
-	/**
-	 * A builder for {@link Realm}
-	 */
-	public static class Builder {
-
-		private final String principal;
-		private final String password;
-		private AuthScheme scheme;
-		private String realmName;
-		private String nonce;
-		private String algorithm;
-		private String response;
-		private String opaque;
-		private String qop;
-		private String nc = DEFAULT_NC;
-		private String cnonce;
-		private Uri uri;
-		private String methodName = "GET";
-		private boolean usePreemptive;
-		private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
-		private Charset charset = UTF_8;
-		private String ntlmHost = "localhost";
-		private boolean useAbsoluteURI = false;
-		private boolean omitQuery;
-
-		public Builder(String principal, String password) {
-			this.principal = principal;
-			this.password = password;
-		}
-
-		public Builder setNtlmDomain(String ntlmDomain) {
-			this.ntlmDomain = ntlmDomain;
-			return this;
-		}
-
-		public Builder setNtlmHost(String host) {
-			this.ntlmHost = host;
-			return this;
-		}
-
-		public Builder setScheme(AuthScheme scheme) {
-			this.scheme = scheme;
-			return this;
-		}
-
-		public Builder setRealmName(String realmName) {
-			this.realmName = realmName;
-			return this;
-		}
-
-		public Builder setNonce(String nonce) {
-			this.nonce = nonce;
-			return this;
-		}
-
-		public Builder setAlgorithm(String algorithm) {
-			this.algorithm = algorithm;
-			return this;
-		}
-
-		public Builder setResponse(String response) {
-			this.response = response;
-			return this;
-		}
-
-		public Builder setOpaque(String opaque) {
-			this.opaque = opaque;
-			return this;
-		}
-
-		public Builder setQop(String qop) {
-			if (isNonEmpty(qop)) {
-				this.qop = qop;
-			}
-			return this;
-		}
-
-		public Builder setNc(String nc) {
-			this.nc = nc;
-			return this;
-		}
-
-		public Builder setUri(Uri uri) {
-			this.uri = uri;
-			return this;
-		}
-
-		public Builder setMethodName(String methodName) {
-			this.methodName = methodName;
-			return this;
-		}
-
-		public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
-			this.usePreemptive = usePreemptiveAuth;
-			return this;
-		}
-
-		public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
-			this.useAbsoluteURI = useAbsoluteURI;
-			return this;
-		}
-
-		public Builder setOmitQuery(boolean omitQuery) {
-			this.omitQuery = omitQuery;
-			return this;
-		}
-
-		public Builder setCharset(Charset charset) {
-			this.charset = charset;
-			return this;
-		}
-
-		private String parseRawQop(String rawQop) {
-			String[] rawServerSupportedQops = rawQop.split(",");
-			String[] serverSupportedQops = new String[rawServerSupportedQops.length];
-			for (int i = 0; i < rawServerSupportedQops.length; i++) {
-				serverSupportedQops[i] = rawServerSupportedQops[i].trim();
-			}
-
-			// prefer auth over auth-int
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth"))
-					return rawServerSupportedQop;
-			}
-
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth-int"))
-					return rawServerSupportedQop;
-			}
-
-			return null;
-		}
-
-		public Builder parseWWWAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-
-			// FIXME qop is different with proxy?
-			String rawQop = match(headerLine, "qop");
-			if (rawQop != null) {
-				setQop(parseRawQop(rawQop));
-			}
-
-			return this;
-		}
-
-		public Builder parseProxyAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-			// FIXME qop is different with proxy?
-			setQop(match(headerLine, "qop"));
-
-			return this;
-		}
-
-		private void newCnonce(MessageDigest md) {
-			byte[] b = new byte[8];
-			ThreadLocalRandom.current().nextBytes(b);
-			b = md.digest(b);
-			cnonce = toHexString(b);
-		}
-
-		/**
-		 * TODO: A Pattern/Matcher may be better.
-		 */
-		private String match(String headerLine, String token) {
-			if (headerLine == null) {
-				return null;
-			}
-
-			int match = headerLine.indexOf(token);
-			if (match <= 0)
-				return null;
-
-			// = to skip
-			match += token.length() + 1;
-			int trailingComa = headerLine.indexOf(",", match);
-			String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
-			value = value.length() > 0 && value.charAt(value.length() - 1) == '"'
-					? value.substring(0, value.length() - 1)
-					: value;
-			return value.charAt(0) == '"' ? value.substring(1) : value;
-		}
-
-		private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
-			md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
-			sb.setLength(0);
-			return md.digest();
-		}
-
-		private byte[] ha1(StringBuilder sb, MessageDigest md) {
-			// if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":"
-			// passwd
-			// if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":"
-			// passwd ) ":" nonce-value ":" cnonce-value
-
-			sb.append(principal).append(':').append(realmName).append(':').append(password);
-			byte[] core = md5FromRecycledStringBuilder(sb, md);
-
-			if (algorithm == null || algorithm.equals("MD5")) {
-				// A1 = username ":" realm-value ":" passwd
-				return core;
-			} else if ("MD5-sess".equals(algorithm)) {
-				// A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
-				appendBase16(sb, core);
-				sb.append(':').append(nonce).append(':').append(cnonce);
-				return md5FromRecycledStringBuilder(sb, md);
-			}
-
-			throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
-		}
-
-		private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
-
-			// if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
-			// if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
-			sb.append(methodName).append(':').append(digestUri);
-			if ("auth-int".equals(qop)) {
-				// when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
-				// but we don't have the request body here
-				// we would need a new API
-				sb.append(':').append(EMPTY_ENTITY_MD5);
-
-			} else if (qop != null && !qop.equals("auth")) {
-				throw new UnsupportedOperationException("Digest qop not supported: " + qop);
-			}
-
-			return md5FromRecycledStringBuilder(sb, md);
-		}
-
-		private void appendMiddlePart(StringBuilder sb) {
-			// request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
-			sb.append(':').append(nonce).append(':');
-			if ("auth".equals(qop) || "auth-int".equals(qop)) {
-				sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
-			}
-		}
-
-		private void newResponse(MessageDigest md) {
-			// when using preemptive auth, the request uri is missing
-			if (uri != null) {
-				// BEWARE: compute first as it uses the cached StringBuilder
-				String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
-
-				StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-
-				// WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
-				byte[] ha1 = ha1(sb, md);
-				byte[] ha2 = ha2(sb, digestUri, md);
-
-				appendBase16(sb, ha1);
-				appendMiddlePart(sb);
-				appendBase16(sb, ha2);
-
-				byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
-				response = toHexString(responseDigest);
-			}
-		}
-
-		/**
-		 * Build a {@link Realm}
-		 * 
-		 * @return a {@link Realm}
-		 */
-		public Realm build() {
-
-			// Avoid generating
-			if (isNonEmpty(nonce)) {
-				MessageDigest md = pooledMd5MessageDigest();
-				newCnonce(md);
-				newResponse(md);
-			}
-
-			return new Realm(scheme, //
-					principal, //
-					password, //
-					realmName, //
-					nonce, //
-					algorithm, //
-					response, //
-					opaque, //
-					qop, //
-					nc, //
-					cnonce, //
-					uri, //
-					usePreemptive, //
-					charset, //
-					ntlmDomain, //
-					ntlmHost, //
-					useAbsoluteURI, //
-					omitQuery);
-		}
-	}
+    private static final String DEFAULT_NC = "00000001";
+    // MD5("")
+    private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
+
+    private final String principal;
+    private final String password;
+    private final AuthScheme scheme;
+    private final String realmName;
+    private final String nonce;
+    private final String algorithm;
+    private final String response;
+    private final String opaque;
+    private final String qop;
+    private final String nc;
+    private final String cnonce;
+    private final Uri uri;
+    private final boolean usePreemptiveAuth;
+    private final Charset charset;
+    private final String ntlmHost;
+    private final String ntlmDomain;
+    private final boolean useAbsoluteURI;
+    private final boolean omitQuery;
+
+    public enum AuthScheme {
+        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
+    }
+
+    private Realm(AuthScheme scheme,//
+            String principal,//
+            String password,//
+            String realmName,//
+            String nonce,//
+            String algorithm,//
+            String response,//
+            String opaque,//
+            String qop,//
+            String nc,//
+            String cnonce,//
+            Uri uri,//
+            boolean usePreemptiveAuth,//
+            Charset charset,//
+            String ntlmDomain,//
+            String ntlmHost,//
+            boolean useAbsoluteURI,//
+            boolean omitQuery) {
+
+        this.scheme = assertNotNull(scheme, "scheme");
+        this.principal = assertNotNull(principal, "principal");
+        this.password = assertNotNull(password, "password");
+        this.realmName = realmName;
+        this.nonce = nonce;
+        this.algorithm = algorithm;
+        this.response = response;
+        this.opaque = opaque;
+        this.qop = qop;
+        this.nc = nc;
+        this.cnonce = cnonce;
+        this.uri = uri;
+        this.usePreemptiveAuth = usePreemptiveAuth;
+        this.charset = charset;
+        this.ntlmDomain = ntlmDomain;
+        this.ntlmHost = ntlmHost;
+        this.useAbsoluteURI = useAbsoluteURI;
+        this.omitQuery = omitQuery;
+    }
+
+    public String getPrincipal() {
+        return principal;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    public AuthScheme getScheme() {
+        return scheme;
+    }
+
+    public String getRealmName() {
+        return realmName;
+    }
+
+    public String getNonce() {
+        return nonce;
+    }
+
+    public String getAlgorithm() {
+        return algorithm;
+    }
+
+    public String getResponse() {
+        return response;
+    }
+
+    public String getOpaque() {
+        return opaque;
+    }
+
+    public String getQop() {
+        return qop;
+    }
+
+    public String getNc() {
+        return nc;
+    }
+
+    public String getCnonce() {
+        return cnonce;
+    }
+
+    public Uri getUri() {
+        return uri;
+    }
+
+    public Charset getCharset() {
+        return charset;
+    }
+
+    /**
+     * Return true is preemptive authentication is enabled
+     * 
+     * @return true is preemptive authentication is enabled
+     */
+    public boolean isUsePreemptiveAuth() {
+        return usePreemptiveAuth;
+    }
+
+    /**
+     * Return the NTLM domain to use. This value should map the JDK
+     * 
+     * @return the NTLM domain
+     */
+    public String getNtlmDomain() {
+        return ntlmDomain;
+    }
+
+    /**
+     * Return the NTLM host.
+     * 
+     * @return the NTLM host
+     */
+    public String getNtlmHost() {
+        return ntlmHost;
+    }
+
+    public boolean isUseAbsoluteURI() {
+        return useAbsoluteURI;
+    }
+
+    public boolean isOmitQuery() {
+        return omitQuery;
+    }
+
+    @Override
+    public String toString() {
+        return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\'' + ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm
+                + '\'' + ", response='" + response + '\'' + ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
+                + ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
+    }
+
+    /**
+     * A builder for {@link Realm}
+     */
+    public static class Builder {
+
+        private static final ThreadLocal<MessageDigest> DIGEST_TL = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("MD5");
+                } catch (NoSuchAlgorithmException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+
+        private static MessageDigest getMessageDigest() {
+            MessageDigest md = DIGEST_TL.get();
+            md.reset();
+            return md;
+        }
+
+        private final String principal;
+        private final String password;
+        private AuthScheme scheme;
+        private String realmName;
+        private String nonce;
+        private String algorithm;
+        private String response;
+        private String opaque;
+        private String qop;
+        private String nc = DEFAULT_NC;
+        private String cnonce;
+        private Uri uri;
+        private String methodName = "GET";
+        private boolean usePreemptive;
+        private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
+        private Charset charset = UTF_8;
+        private String ntlmHost = "localhost";
+        private boolean useAbsoluteURI = false;
+        private boolean omitQuery;
+
+        public Builder(String principal, String password) {
+            this.principal = principal;
+            this.password = password;
+        }
+
+        public Builder setNtlmDomain(String ntlmDomain) {
+            this.ntlmDomain = ntlmDomain;
+            return this;
+        }
+
+        public Builder setNtlmHost(String host) {
+            this.ntlmHost = host;
+            return this;
+        }
+
+        public Builder setScheme(AuthScheme scheme) {
+            this.scheme = scheme;
+            return this;
+        }
+
+        public Builder setRealmName(String realmName) {
+            this.realmName = realmName;
+            return this;
+        }
+
+        public Builder setNonce(String nonce) {
+            this.nonce = nonce;
+            return this;
+        }
+
+        public Builder setAlgorithm(String algorithm) {
+            this.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder setResponse(String response) {
+            this.response = response;
+            return this;
+        }
+
+        public Builder setOpaque(String opaque) {
+            this.opaque = opaque;
+            return this;
+        }
+
+        public Builder setQop(String qop) {
+            if (isNonEmpty(qop)) {
+                this.qop = qop;
+            }
+            return this;
+        }
+
+        public Builder setNc(String nc) {
+            this.nc = nc;
+            return this;
+        }
+
+        public Builder setUri(Uri uri) {
+            this.uri = uri;
+            return this;
+        }
+
+        public Builder setMethodName(String methodName) {
+            this.methodName = methodName;
+            return this;
+        }
+
+        public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
+            this.usePreemptive = usePreemptiveAuth;
+            return this;
+        }
+
+        public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
+            this.useAbsoluteURI = useAbsoluteURI;
+            return this;
+        }
+
+        public Builder setOmitQuery(boolean omitQuery) {
+            this.omitQuery = omitQuery;
+            return this;
+        }
+
+        public Builder setCharset(Charset charset) {
+            this.charset = charset;
+            return this;
+        }
+
+        private String parseRawQop(String rawQop) {
+            String[] rawServerSupportedQops = rawQop.split(",");
+            String[] serverSupportedQops = new String[rawServerSupportedQops.length];
+            for (int i = 0; i < rawServerSupportedQops.length; i++) {
+                serverSupportedQops[i] = rawServerSupportedQops[i].trim();
+            }
+
+            // prefer auth over auth-int
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth"))
+                    return rawServerSupportedQop;
+            }
+
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth-int"))
+                    return rawServerSupportedQop;
+            }
+
+            return null;
+        }
+
+        public Builder parseWWWAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+
+            // FIXME qop is different with proxy?
+            String rawQop = match(headerLine, "qop");
+            if (rawQop != null) {
+                setQop(parseRawQop(rawQop));
+            }
+
+            return this;
+        }
+
+        public Builder parseProxyAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+            // FIXME qop is different with proxy?
+            setQop(match(headerLine, "qop"));
+
+            return this;
+        }
+
+        private void newCnonce(MessageDigest md) {
+            byte[] b = new byte[8];
+            ThreadLocalRandom.current().nextBytes(b);
+            b = md.digest(b);
+            cnonce = toHexString(b);
+        }
+
+        /**
+         * TODO: A Pattern/Matcher may be better.
+         */
+        private String match(String headerLine, String token) {
+            if (headerLine == null) {
+                return null;
+            }
+
+            int match = headerLine.indexOf(token);
+            if (match <= 0)
+                return null;
+
+            // = to skip
+            match += token.length() + 1;
+            int trailingComa = headerLine.indexOf(",", match);
+            String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
+            value = value.length() > 0 && value.charAt(value.length() - 1) == '"' ? value.substring(0, value.length() - 1) : value;
+            return value.charAt(0) == '"' ? value.substring(1) : value;
+        }
+
+        private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
+            md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
+            sb.setLength(0);
+            return md.digest();
+        }
+
+        private byte[] ha1(StringBuilder sb, MessageDigest md) {
+            // if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":" passwd
+            // if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":" passwd ) ":" nonce-value ":" cnonce-value
+
+            sb.append(principal).append(':').append(realmName).append(':').append(password);
+            byte[] core = md5FromRecycledStringBuilder(sb, md);
+
+            if (algorithm == null || algorithm.equals("MD5")) {
+                // A1 = username ":" realm-value ":" passwd
+                return core;
+            } else if ("MD5-sess".equals(algorithm)) {
+                // A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
+                appendBase16(sb, core);
+                sb.append(':').append(nonce).append(':').append(cnonce);
+                return md5FromRecycledStringBuilder(sb, md);
+            }
+
+            throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+        }
+
+        private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
+
+            // if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
+            // if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
+            sb.append(methodName).append(':').append(digestUri);
+            if ("auth-int".equals(qop)) {
+                // when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
+                // but we don't have the request body here
+                // we would need a new API
+                sb.append(':').append(EMPTY_ENTITY_MD5);
+
+            } else if (qop != null && !qop.equals("auth")) {
+                throw new UnsupportedOperationException("Digest qop not supported: " + qop);
+            }
+
+            return md5FromRecycledStringBuilder(sb, md);
+        }
+
+        private void appendMiddlePart(StringBuilder sb) {
+            // request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
+            sb.append(':').append(nonce).append(':');
+            if ("auth".equals(qop) || "auth-int".equals(qop)) {
+                sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
+            }
+        }
+
+        private void newResponse(MessageDigest md) {
+            // when using preemptive auth, the request uri is missing
+            if (uri != null) {
+                // BEWARE: compute first as it uses the cached StringBuilder
+                String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
+
+                StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+
+                // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
+                byte[] ha1 = ha1(sb, md);
+                byte[] ha2 = ha2(sb, digestUri, md);
+
+                appendBase16(sb, ha1);
+                appendMiddlePart(sb);
+                appendBase16(sb, ha2);
+
+                byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
+                response = toHexString(responseDigest);
+            }
+        }
+
+        /**
+         * Build a {@link Realm}
+         * 
+         * @return a {@link Realm}
+         */
+        public Realm build() {
+
+            // Avoid generating
+            if (isNonEmpty(nonce)) {
+                MessageDigest md = getMessageDigest();
+                newCnonce(md);
+                newResponse(md);
+            }
+
+            return new Realm(scheme,//
+                    principal,//
+                    password,//
+                    realmName,//
+                    nonce, //
+                    algorithm, //
+                    response,//
+                    opaque, //
+                    qop, //
+                    nc, //
+                    cnonce, //
+                    uri, //
+                    usePreemptive, //
+                    charset, //
+                    ntlmDomain,//
+                    ntlmHost, //
+                    useAbsoluteURI, //
+                    omitQuery);
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
new file mode 100644
index 000000000..167b4003d
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import io.netty.channel.Channel;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+/**
+ * This interface hosts new low level callback methods on {@link AsyncHandler}.
+ * 
+ */
+public interface AsyncHandlerExtensions {
+
+    // ////////// DNS /////////////////
+
+    /**
+     * Notify the callback before hostname resolution
+     * 
+     * @param name the name to be resolved
+     */
+    void onHostnameResolutionAttempt(String name);
+
+    /**
+     * Notify the callback after hostname resolution was successful.
+     * 
+     * @param name the name to be resolved
+     * @param addresses the resolved addresses
+     */
+    void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses);
+
+    /**
+     * Notify the callback after hostname resolution failed.
+     * 
+     * @param name the name to be resolved
+     * @param cause the failure cause
+     */
+    void onHostnameResolutionFailure(String name, Throwable cause);
+
+    // ////////////// TCP CONNECT ////////
+
+    /**
+     * Notify the callback when trying to open a new connection.
+     * 
+     * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
+     * 
+     * @param remoteAddress the address we try to connect to
+     */
+    void onTcpConnectAttempt(InetSocketAddress remoteAddress);
+
+    /**
+     * Notify the callback after a successful connect
+     * 
+     * @param remoteAddress the address we try to connect to
+     * @param connection the connection
+     */
+    void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection);
+
+    /**
+     * Notify the callback after a failed connect.
+     * 
+     * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
+     * 
+     * @param remoteAddress the address we try to connect to
+     * @param cause the cause of the failure
+     */
+    void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause);
+
+    // ////////////// TLS ///////////////
+
+    /**
+     * Notify the callback before TLS handshake
+     */
+    void onTlsHandshakeAttempt();
+
+    /**
+     * Notify the callback after the TLS was successful
+     */
+    void onTlsHandshakeSuccess();
+
+    /**
+     * Notify the callback after the TLS failed
+     * 
+     * @param cause the cause of the failure
+     */
+    void onTlsHandshakeFailure(Throwable cause);
+
+    // /////////// POOLING /////////////
+
+    /**
+     * Notify the callback when trying to fetch a connection from the pool.
+     */
+    void onConnectionPoolAttempt();
+
+    /**
+     * Notify the callback when a new connection was successfully fetched from the pool.
+     * 
+     * @param connection the connection
+     */
+    void onConnectionPooled(Channel connection);
+
+    /**
+     * Notify the callback when trying to offer a connection to the pool.
+     * 
+     * @param connection the connection
+     */
+    void onConnectionOffer(Channel connection);
+
+    // //////////// SENDING //////////////
+
+    /**
+     * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
+     * retry, it will be notified multiple times.
+     * 
+     * @param request the real request object as passed to the provider
+     */
+    void onRequestSend(NettyRequest request);
+
+    /**
+     * Notify the callback every time a request is being retried.
+     */
+    void onRetry();
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
new file mode 100644
index 000000000..3d6f7d37f
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHandler;
+
+public final class AsyncHandlerExtensionsUtils {
+
+    public static AsyncHandlerExtensions toAsyncHandlerExtensions(AsyncHandler<?> asyncHandler) {
+        return asyncHandler instanceof AsyncHandlerExtensions ? (AsyncHandlerExtensions) asyncHandler : null;
+    }
+
+    private AsyncHandlerExtensionsUtils() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
new file mode 100644
index 000000000..6c173d4a3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import io.netty.channel.Channel;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+public abstract class ExtendedAsyncHandler<T> implements AsyncHandler<T>, AsyncHandlerExtensions {
+
+    @Override
+    public void onHostnameResolutionAttempt(String name) {
+    }
+
+    @Override
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    }
+
+    @Override
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+    }
+
+    @Override
+    public void onTcpConnectAttempt(InetSocketAddress address) {
+    }
+
+    @Override
+    public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+    }
+
+    @Override
+    public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+    }
+
+    @Override
+    public void onTlsHandshakeAttempt() {
+    }
+
+    @Override
+    public void onTlsHandshakeSuccess() {
+    }
+
+    @Override
+    public void onTlsHandshakeFailure(Throwable cause) {
+    }
+
+    @Override
+    public void onConnectionPoolAttempt() {
+    }
+
+    @Override
+    public void onConnectionPooled(Channel connection) {
+    }
+
+    @Override
+    public void onConnectionOffer(Channel connection) {
+    }
+
+    @Override
+    public void onRequestSend(NettyRequest request) {
+    }
+
+    @Override
+    public void onRetry() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 9208dc7d9..9a96ddfd1 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -43,46 +43,18 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * A {@link Future} that can be used to track when an asynchronous HTTP request
- * has been fully processed.
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
  * 
- * @param <V>
- *            the result type
+ * @param <V> the result type
  */
 public final class NettyResponseFuture<V> implements ListenableFuture<V> {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
 
     @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "redirectCount");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> REDIRECT_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "redirectCount");
     @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "currentRetry");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_DONE_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "isDone");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IS_CANCELLED_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "isCancelled");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_AUTH_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "inAuth");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> IN_PROXY_AUTH_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "inProxyAuth");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CONTENT_PROCESSED_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "contentProcessed");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> ON_THROWABLE_CALLED_FIELD = AtomicIntegerFieldUpdater
-            .newUpdater(NettyResponseFuture.class, "onThrowableCalled");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> TIMEOUTS_HOLDER_FIELD = AtomicReferenceFieldUpdater
-            .newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> PARTITION_KEY_LOCK_FIELD = AtomicReferenceFieldUpdater
-            .newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> CURRENT_RETRY_UPDATER = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "currentRetry");
 
     private final long start = unpreciseMillisTime();
     private final ChannelPoolPartitioning connectionPoolPartitioning;
@@ -107,6 +79,23 @@
     // partition key, when != null used to release lock in ChannelManager
     private volatile Object partitionKeyLock;
 
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isDoneField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isDone");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> isCancelledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "isCancelled");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inAuth");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> inProxyAuthField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "inProxyAuth");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> contentProcessedField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "contentProcessed");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> onThrowableCalledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "onThrowableCalled");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> timeoutsHolderField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> partitionKeyLockField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
+
     // volatile where we need CAS ops
     private volatile int redirectCount = 0;
     private volatile int currentRetry = 0;
@@ -131,12 +120,12 @@
     private Realm proxyRealm;
     public Throwable pendingException;
 
-    public NettyResponseFuture(Request originalRequest, //
-            AsyncHandler<V> asyncHandler, //
-            NettyRequest nettyRequest, //
-            int maxRetry, //
-            ChannelPoolPartitioning connectionPoolPartitioning, //
-            ConnectionSemaphore connectionSemaphore, //
+    public NettyResponseFuture(Request originalRequest,//
+            AsyncHandler<V> asyncHandler,//
+            NettyRequest nettyRequest,//
+            int maxRetry,//
+            ChannelPoolPartitioning connectionPoolPartitioning,//
+            ConnectionSemaphore connectionSemaphore,//
             ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
@@ -149,10 +138,6 @@ public NettyResponseFuture(Request originalRequest, //
     }
 
     private void releasePartitionKeyLock() {
-        if (connectionSemaphore == null) {
-            return;
-        }
-
         Object partitionKey = takePartitionKeyLock();
         if (partitionKey != null) {
             connectionSemaphore.releaseChannelLock(partitionKey);
@@ -167,7 +152,7 @@ public Object takePartitionKeyLock() {
             return null;
         }
 
-        return PARTITION_KEY_LOCK_FIELD.getAndSet(this, null);
+        return partitionKeyLockField.getAndSet(this, null);
     }
 
     // java.util.concurrent.Future
@@ -187,7 +172,7 @@ public boolean cancel(boolean force) {
         releasePartitionKeyLock();
         cancelTimeouts();
 
-        if (IS_CANCELLED_FIELD.getAndSet(this, 1) != 0)
+        if (isCancelledField.getAndSet(this, 1) != 0)
             return false;
 
         // cancel could happen before channel was attached
@@ -196,7 +181,7 @@ public boolean cancel(boolean force) {
             Channels.silentlyCloseChannel(channel);
         }
 
-        if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
+        if (onThrowableCalledField.getAndSet(this, 1) == 0) {
             try {
                 asyncHandler.onThrowable(new CancellationException());
             } catch (Throwable t) {
@@ -229,11 +214,11 @@ private V getContent() throws ExecutionException {
 
         // No more retry
         CURRENT_RETRY_UPDATER.set(this, maxRetry);
-        if (CONTENT_PROCESSED_FIELD.getAndSet(this, 1) == 0) {
+        if (contentProcessedField.getAndSet(this, 1) == 0) {
             try {
                 future.complete(asyncHandler.onCompleted());
             } catch (Throwable ex) {
-                if (ON_THROWABLE_CALLED_FIELD.getAndSet(this, 1) == 0) {
+                if (onThrowableCalledField.getAndSet(this, 1) == 0) {
                     try {
                         try {
                             asyncHandler.onThrowable(ex);
@@ -257,7 +242,7 @@ private boolean terminateAndExit() {
         cancelTimeouts();
         this.channel = null;
         this.reuseChannel = false;
-        return IS_DONE_FIELD.getAndSet(this, 1) != 0 || isCancelled != 0;
+        return isDoneField.getAndSet(this, 1) != 0 || isCancelled != 0;
     }
 
     public final void done() {
@@ -284,7 +269,7 @@ public final void abort(final Throwable t) {
 
         future.completeExceptionally(t);
 
-        if (ON_THROWABLE_CALLED_FIELD.compareAndSet(this, 0, 1)) {
+        if (onThrowableCalledField.compareAndSet(this, 0, 1)) {
             try {
                 asyncHandler.onThrowable(t);
             } catch (Throwable te) {
@@ -331,7 +316,7 @@ public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
     }
 
     public void cancelTimeouts() {
-        TimeoutsHolder ref = TIMEOUTS_HOLDER_FIELD.getAndSet(this, null);
+        TimeoutsHolder ref = timeoutsHolderField.getAndSet(this, null);
         if (ref != null) {
             ref.cancel();
         }
@@ -370,11 +355,11 @@ public int incrementAndGetCurrentRedirectCount() {
     }
 
     public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
-        TIMEOUTS_HOLDER_FIELD.set(this, timeoutsHolder);
+        timeoutsHolderField.set(this, timeoutsHolder);
     }
 
     public TimeoutsHolder getTimeoutsHolder() {
-        return TIMEOUTS_HOLDER_FIELD.get(this);
+        return timeoutsHolderField.get(this);
     }
 
     public boolean isInAuth() {
@@ -386,7 +371,7 @@ public void setInAuth(boolean inAuth) {
     }
 
     public boolean isAndSetInAuth(boolean set) {
-        return IN_AUTH_FIELD.getAndSet(this, set ? 1 : 0) != 0;
+        return inAuthField.getAndSet(this, set ? 1 : 0) != 0;
     }
 
     public boolean isInProxyAuth() {
@@ -398,7 +383,7 @@ public void setInProxyAuth(boolean inProxyAuth) {
     }
 
     public boolean isAndSetInProxyAuth(boolean inProxyAuth) {
-        return IN_PROXY_AUTH_FIELD.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
+        return inProxyAuthField.getAndSet(this, inProxyAuth ? 1 : 0) != 0;
     }
 
     public ChannelState getChannelState() {
@@ -481,15 +466,13 @@ public void setCurrentRequest(Request currentRequest) {
     }
 
     /**
-     * Return true if the {@link Future} can be recovered. There is some scenario
-     * where a connection can be closed by an unexpected IOException, and in some
-     * situation we can recover from that exception.
+     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can
+     * recover from that exception.
      * 
      * @return true if that {@link Future} cannot be recovered.
      */
     public boolean isReplayPossible() {
-        return !isDone() && !(Channels.isChannelActive(channel) && !getUri().getScheme().equalsIgnoreCase("https"))
-                && inAuth == 0 && inProxyAuth == 0;
+        return !isDone() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && inAuth == 0 && inProxyAuth == 0;
     }
 
     public long getStart() {
@@ -497,18 +480,17 @@ public long getStart() {
     }
 
     public Object getPartitionKey() {
-        return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(),
-                proxyServer);
+        return connectionPoolPartitioning.getPartitionKey(targetRequest.getUri(), targetRequest.getVirtualHost(), proxyServer);
     }
 
     public void acquirePartitionLockLazily() throws IOException {
-        if (connectionSemaphore == null || partitionKeyLock != null) {
+        if (partitionKeyLock != null) {
             return;
         }
 
         Object partitionKey = getPartitionKey();
         connectionSemaphore.acquireChannelLock(partitionKey);
-        Object prevKey = PARTITION_KEY_LOCK_FIELD.getAndSet(this, partitionKey);
+        Object prevKey = partitionKeyLockField.getAndSet(this, partitionKey);
         if (prevKey != null) {
             // self-check
 
@@ -552,7 +534,7 @@ public String toString() {
                 ",\n\turi=" + getUri() + //
                 ",\n\tkeepAlive=" + keepAlive + //
                 ",\n\tredirectCount=" + redirectCount + //
-                ",\n\ttimeoutsHolder=" + TIMEOUTS_HOLDER_FIELD.get(this) + //
+                ",\n\ttimeoutsHolder=" + timeoutsHolderField.get(this) + //
                 ",\n\tinAuth=" + inAuth + //
                 ",\n\tstatusReceived=" + statusReceived + //
                 ",\n\ttouch=" + touch + //
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 8b05729e8..0a6b0caad 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -13,6 +13,8 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
@@ -57,6 +59,7 @@
 import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.channel.NoopChannelPool;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
@@ -229,7 +232,7 @@ protected void initChannel(Channel ch) throws Exception {
                 }
 
                 if (config.getHttpAdditionalChannelInitializer() != null)
-                    config.getHttpAdditionalChannelInitializer().accept(ch);
+                    config.getHttpAdditionalChannelInitializer().initChannel(ch);
             }
         });
 
@@ -246,7 +249,7 @@ protected void initChannel(Channel ch) throws Exception {
                 }
 
                 if (config.getWsAdditionalChannelInitializer() != null)
-                    config.getWsAdditionalChannelInitializer().accept(ch);
+                    config.getWsAdditionalChannelInitializer().initChannel(ch);
             }
         });
     }
@@ -268,10 +271,13 @@ public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> async
             LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
             Channels.setDiscard(channel);
 
-            try {
-                asyncHandler.onConnectionOffer(channel);
-            } catch (Exception e) {
-                LOGGER.error("onConnectionOffer crashed", e);
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onConnectionOffer(channel);
+                } catch (Exception e) {
+                    LOGGER.error("onConnectionOffer crashed", e);
+                }
             }
 
             if (!channelPool.offer(channel, partitionKey)) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 0a17854fd..3bd1b82c2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -43,7 +43,7 @@ public static void setDiscard(Channel channel) {
         setAttribute(channel, DiscardEvent.DISCARD);
     }
 
-    public static boolean isChannelActive(Channel channel) {
+    public static boolean isChannelValid(Channel channel) {
         return channel != null && channel.isActive();
     }
     
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
index 09c693502..cde61c57c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
@@ -29,10 +29,6 @@
  */
 public class ConnectionSemaphore {
 
-    public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
-        return config.getMaxConnections() > 0 || config.getMaxConnectionsPerHost() > 0 ? new ConnectionSemaphore(config) : null;
-    }
-
     private final int maxTotalConnections;
     private final NonBlockingSemaphoreLike freeChannels;
     private final int maxConnectionsPerHost;
@@ -41,7 +37,7 @@ public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig c
     private final IOException tooManyConnections;
     private final IOException tooManyConnectionsPerHost;
 
-    private ConnectionSemaphore(AsyncHttpClientConfig config) {
+    public ConnectionSemaphore(AsyncHttpClientConfig config) {
         tooManyConnections = unknownStackTrace(new TooManyConnectionsException(config.getMaxConnections()), ConnectionSemaphore.class, "acquireChannelLock");
         tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()), ConnectionSemaphore.class, "acquireChannelLock");
         maxTotalConnections = config.getMaxConnections();
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index f90dd29ed..96075ec7b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -15,6 +15,11 @@
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
+import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -22,7 +27,6 @@
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -32,12 +36,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelId;
-import io.netty.util.Timeout;
-import io.netty.util.Timer;
-import io.netty.util.TimerTask;
-
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
@@ -108,13 +106,9 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
     }
 
     private static final class IdleChannel {
-        
-        private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
-        
         final Channel channel;
         final long start;
-        @SuppressWarnings("unused")
-        private volatile int owned = 0;
+        final AtomicBoolean owned = new AtomicBoolean(false);
 
         IdleChannel(Channel channel, long start) {
             this.channel = assertNotNull(channel, "channel");
@@ -122,7 +116,7 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
         }
 
         public boolean takeOwnership() {
-            return ownedField.getAndSet(this, 1) == 0;
+            return owned.compareAndSet(false, true);
         }
 
         public Channel getChannel() {
@@ -149,6 +143,10 @@ private boolean isTtlExpired(Channel channel, long now) {
         return creation != null && now - creation.creationTime >= connectionTtl;
     }
 
+    private boolean isRemotelyClosed(Channel channel) {
+        return !channel.isActive();
+    }
+
     private final class IdleChannelDetector implements TimerTask {
 
         private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
@@ -160,7 +158,7 @@ private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
             List<IdleChannel> idleTimeoutChannels = null;
             for (IdleChannel idleChannel : partition) {
                 boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);
-                boolean isRemotelyClosed = !Channels.isChannelActive(idleChannel.channel);
+                boolean isRemotelyClosed = isRemotelyClosed(idleChannel.channel);
                 boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);
                 if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {
                     LOGGER.debug("Adding Candidate expired Channel {} isIdleTimeoutExpired={} isRemotelyClosed={} isTtlExpired={}", idleChannel.channel, isIdleTimeoutExpired, isRemotelyClosed, isTtlExpired);
@@ -297,9 +295,9 @@ public Channel poll(Object partitionKey) {
                 if (idleChannel == null)
                     // pool is empty
                     break;
-                else if (!Channels.isChannelActive(idleChannel.channel)) {
+                else if (isRemotelyClosed(idleChannel.channel)) {
                     idleChannel = null;
-                    LOGGER.trace("Channel is inactive, probably remotely closed!");
+                    LOGGER.trace("Channel not connected or not opened, probably remotely closed!");
                 } else if (!idleChannel.takeOwnership()) {
                     idleChannel = null;
                     LOGGER.trace("Couldn't take ownership of channel, probably in the process of being expired!");
@@ -314,7 +312,7 @@ else if (!Channels.isChannelActive(idleChannel.channel)) {
      */
     public boolean removeAll(Channel channel) {
         ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channel.id()) : null;
-        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(new IdleChannel(channel, Long.MIN_VALUE));
+        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
     }
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 687097560..86bcc043f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -13,13 +13,19 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import static org.asynchttpclient.util.HttpUtils.getBaseUrl;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.ssl.SslHandler;
 
 import java.net.ConnectException;
 import java.net.InetSocketAddress;
 
-import org.asynchttpclient.AsyncHandler;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.future.StackTraceInspector;
@@ -29,12 +35,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
-
 /**
  * Non Blocking connect.
  */
@@ -89,7 +89,7 @@ private void writeRequest(Channel channel) {
 
     public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
 
-        if (connectionSemaphore != null) {
+        {
             // transfer lock from future to channel
             Object partitionKeyLock = future.takePartitionKeyLock();
 
@@ -126,37 +126,43 @@ public void operationComplete(Future<? super Void> future) throws Exception {
                 return;
             }
 
-            final AsyncHandler<?> asyncHandler = future.getAsyncHandler();
-            
-            try {
-                asyncHandler.onTlsHandshakeAttempt();
-            } catch (Exception e) {
-                LOGGER.error("onTlsHandshakeAttempt crashed", e);
-                onFailure(channel, e);
-                return;
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onTlsHandshakeAttempt();
+                } catch (Exception e) {
+                    LOGGER.error("onTlsHandshakeAttempt crashed", e);
+                    onFailure(channel, e);
+                    return;
+                }
             }
 
             sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
                 @Override
                 protected void onSuccess(Channel value) throws Exception {
-                    try {
-                        asyncHandler.onTlsHandshakeSuccess();
-                    } catch (Exception e) {
-                        LOGGER.error("onTlsHandshakeSuccess crashed", e);
-                        NettyConnectListener.this.onFailure(channel, e);
-                        return;
+                    if (asyncHandlerExtensions != null) {
+                        try {
+                            asyncHandlerExtensions.onTlsHandshakeSuccess();
+                        } catch (Exception e) {
+                            LOGGER.error("onTlsHandshakeSuccess crashed", e);
+                            NettyConnectListener.this.onFailure(channel, e);
+                            return;
+                        }
                     }
                     writeRequest(channel);
                 }
 
                 @Override
                 protected void onFailure(Throwable cause) throws Exception {
-                    try {
-                        asyncHandler.onTlsHandshakeFailure(cause);
-                    } catch (Exception e) {
-                        LOGGER.error("onTlsHandshakeFailure crashed", e);
-                        NettyConnectListener.this.onFailure(channel, e);
-                        return;
+                    if (asyncHandlerExtensions != null) {
+                        try {
+                            asyncHandlerExtensions.onTlsHandshakeFailure(cause);
+                        } catch (Exception e) {
+                            LOGGER.error("onTlsHandshakeFailure crashed", e);
+                            NettyConnectListener.this.onFailure(channel, e);
+                            return;
+                        }
                     }
                     NettyConnectListener.this.onFailure(channel, cause);
                 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index c3c5e4861..0829722a9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -226,13 +226,15 @@ private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
         return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
     }
     
-    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean close) throws IOException {
+    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean keepAlive, boolean expectOtherChunks) throws IOException {
         future.cancelTimeouts();
         
-        if (close) {
+        if (!keepAlive) {
             channelManager.closeChannel(channel);
+        } else if (expectOtherChunks) {
+            channelManager.drainChannelAndOffer(channel, future);
         } else {
-            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), true, future.getPartitionKey());
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
         }
 
         try {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 1edc5b562..906d0a3fd 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -45,7 +45,7 @@ public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager,
 
     private boolean abortAfterHandlingStatus(//
             AsyncHandler<?> handler,//
-            NettyResponseStatus status) throws Exception {
+            NettyResponseStatus status) throws IOException, Exception {
         return handler.onStatusReceived(status) == State.ABORT;
     }
 
@@ -87,7 +87,7 @@ private void handleHttpResponse(final HttpResponse response, final Channel chann
                     abortAfterHandlingReactiveStreams(channel, future, handler);
 
             if (abort) {
-                finishUpdate(future, channel, true);
+                finishUpdate(future, channel, false, true);
             }
         }
     }
@@ -116,8 +116,8 @@ private void handleChunk(HttpContent chunk,//
         }
 
         if (abort || last) {
-            boolean close = abort || !future.isKeepAlive();
-            finishUpdate(future, channel, close);
+            boolean keepAlive = !abort && future.isKeepAlive();
+            finishUpdate(future, channel, keepAlive, !last);
         }
     }
 
@@ -168,7 +168,7 @@ private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwabl
         } catch (Exception abortException) {
             logger.debug("Abort failed", abortException);
         } finally {
-            finishUpdate(future, channel, true);
+            finishUpdate(future, channel, false, false);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
index 0b5d8ce55..9357ae08f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
@@ -42,15 +42,16 @@ public StreamedResponsePublisher(EventExecutor executor, ChannelManager channelM
     protected void cancelled() {
         logger.debug("Subscriber cancelled, ignoring the rest of the body");
 
+        // The subscriber cancelled early, we need to drain the remaining elements from the stream
+        channelManager.drainChannelAndOffer(channel, future);
+        channel.pipeline().remove(StreamedResponsePublisher.class);
+
         try {
             future.done();
         } catch (Exception t) {
             // Never propagate exception once we know we are done.
             logger.debug(t.getMessage(), t);
         }
-
-        // The subscriber cancelled early - this channel is dead and should be closed.
-        channelManager.closeChannel(channel);
     }
 
     NettyResponseFuture<?> future() {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 637ff2181..42f6d792e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -87,7 +87,7 @@ private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgr
         try {
             handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
         } finally {
-            finishUpdate(future, channel, true);
+            finishUpdate(future, channel, false, false);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index 90d9d7612..907de704f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -146,6 +146,7 @@ else if (request.getBodyGenerator() != null)
                 LOGGER.debug("Sending redirect to {}", newUri);
 
                 if (future.isKeepAlive() && !HttpUtil.isTransferEncodingChunked(response)) {
+
                     if (sameBase) {
                         future.setReuseChannel(true);
                         // we can't directly send the next request because we still have to received LastContent
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 6b661f8c1..1bccecec4 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -12,6 +12,7 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 
@@ -23,6 +24,7 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpClientState;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.SimpleChannelFutureListener;
 import org.asynchttpclient.netty.channel.NettyConnectListener;
 import org.slf4j.Logger;
@@ -32,7 +34,7 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyChannelConnector.class);
 
-    private final AsyncHandler<?> asyncHandler;
+    private final AsyncHandlerExtensions asyncHandlerExtensions;
     private final InetSocketAddress localAddress;
     private final List<InetSocketAddress> remoteAddresses;
     private final AsyncHttpClientState clientState;
@@ -45,7 +47,7 @@ public NettyChannelConnector(InetAddress localAddress,//
             AsyncHttpClientConfig config) {
         this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
         this.remoteAddresses = remoteAddresses;
-        this.asyncHandler = asyncHandler;
+        this.asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
         this.clientState = clientState;
     }
 
@@ -57,12 +59,14 @@ private boolean pickNextRemoteAddress() {
     public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
         final InetSocketAddress remoteAddress = remoteAddresses.get(i);
 
-        try {
-            asyncHandler.onTcpConnectAttempt(remoteAddress);
-        } catch (Exception e) {
-            LOGGER.error("onTcpConnectAttempt crashed", e);
-            connectListener.onFailure(null, e);
-            return;
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);
+            } catch (Exception e) {
+                LOGGER.error("onTcpConnectAttempt crashed", e);
+                connectListener.onFailure(null, e);
+                return;
+            }
         }
 
         try {
@@ -82,24 +86,28 @@ private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connect
                 .addListener(new SimpleChannelFutureListener() {
                     @Override
                     public void onSuccess(Channel channel) {
-                        try {
-                            asyncHandler.onTcpConnectSuccess(remoteAddress, channel);
-                        } catch (Exception e) {
-                            LOGGER.error("onTcpConnectSuccess crashed", e);
-                            connectListener.onFailure(channel, e);
-                            return;
+                        if (asyncHandlerExtensions != null) {
+                            try {
+                                asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);
+                            } catch (Exception e) {
+                                LOGGER.error("onTcpConnectSuccess crashed", e);
+                                connectListener.onFailure(channel, e);
+                                return;
+                            }
                         }
                         connectListener.onSuccess(channel, remoteAddress);
                     }
 
                     @Override
                     public void onFailure(Channel channel, Throwable t) {
-                        try {
-                            asyncHandler.onTcpConnectFailure(remoteAddress, t);
-                        } catch (Exception e) {
-                            LOGGER.error("onTcpConnectFailure crashed", e);
-                            connectListener.onFailure(channel, e);
-                            return;
+                        if (asyncHandlerExtensions != null) {
+                            try {
+                                asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);
+                            } catch (Exception e) {
+                                LOGGER.error("onTcpConnectFailure crashed", e);
+                                connectListener.onFailure(channel, e);
+                                return;
+                            }
                         }
                         boolean retry = pickNextRemoteAddress();
                         if (retry) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 788823fd9..a26f4fc06 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -17,7 +17,7 @@
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
 import static org.asynchttpclient.util.HttpUtils.*;
 import static org.asynchttpclient.util.MiscUtils.*;
-import static org.asynchttpclient.ws.WebSocketUtils.getWebSocketKey;
+import static org.asynchttpclient.ws.WebSocketUtils.getKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -123,10 +123,10 @@ public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthori
             headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
     }
 
-    public NettyRequest newNettyRequest(Request request, boolean performConnectRequest, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
+    public NettyRequest newNettyRequest(Request request, boolean forceConnect, ProxyServer proxyServer, Realm realm, Realm proxyRealm) {
 
         Uri uri = request.getUri();
-        HttpMethod method = performConnectRequest ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
         boolean connect = method == HttpMethod.CONNECT;
 
         HttpVersion httpVersion = HttpVersion.HTTP_1_1;
@@ -194,7 +194,7 @@ public NettyRequest newNettyRequest(Request request, boolean performConnectReque
         if (!connect && uri.isWebSocket()) {
             headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)//
                     .set(CONNECTION, HttpHeaderValues.UPGRADE)//
-                    .set(SEC_WEBSOCKET_KEY, getWebSocketKey())//
+                    .set(SEC_WEBSOCKET_KEY, getKey())//
                     .set(SEC_WEBSOCKET_VERSION, "13");
 
             if (!headers.contains(ORIGIN)) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 6a3f8ab31..6e3e0e0f6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -15,6 +15,7 @@
 
 import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;
 import static java.util.Collections.singletonList;
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
 import static org.asynchttpclient.util.HttpConstants.Methods.*;
@@ -52,6 +53,7 @@
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.OnLastHttpContentCallback;
@@ -80,47 +82,42 @@
     private final AsyncHttpClientState clientState;
     private final NettyRequestFactory requestFactory;
 
-    public NettyRequestSender(AsyncHttpClientConfig config, //
-            ChannelManager channelManager, //
-            Timer nettyTimer, //
+    public NettyRequestSender(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            ConnectionSemaphore connectionSemaphore,//
+            Timer nettyTimer,//
             AsyncHttpClientState clientState) {
         this.config = config;
         this.channelManager = channelManager;
-        this.connectionSemaphore = ConnectionSemaphore.newConnectionSemaphore(config);
+        this.connectionSemaphore = connectionSemaphore;
         this.nettyTimer = nettyTimer;
         this.clientState = clientState;
         requestFactory = new NettyRequestFactory(config);
     }
 
-    public <T> ListenableFuture<T> sendRequest(final Request request, //
-            final AsyncHandler<T> asyncHandler, //
-            NettyResponseFuture<T> future, //
+    public <T> ListenableFuture<T> sendRequest(final Request request,//
+            final AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
             boolean performingNextRequest) {
 
-        if (isClosed()) {
+        if (isClosed())
             throw new IllegalStateException("Closed");
-        }
 
         validateWebSocketRequest(request, asyncHandler);
 
         ProxyServer proxyServer = getProxyServer(config, request);
 
-        // WebSockets use connect tunneling to work with proxies
-        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket())
-                && !isConnectDone(request, future)) {
-            // Proxy with HTTPS or WebSocket: CONNECT for sure
-            if (future != null && future.isConnectAllowed()) {
-                // Perform CONNECT
-                return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, true);
-            } else {
-                // CONNECT will depend if we can pool or connection or if we have to open a new
-                // one
-                return sendRequestThroughSslProxy(request, asyncHandler, future, proxyServer);
-            }
-        } else {
+        // websockets use connect tunnelling to work with proxies
+        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))
+            if (future != null && future.isConnectAllowed())
+                // SSL proxy or websocket: CONNECT for sure
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, true);
+            else
+                // CONNECT will depend if we can pool or connection or if we have to open a new one
+                return sendRequestThroughSslProxy(request, asyncHandler, future, performingNextRequest, proxyServer);
+        else
             // no CONNECT for sure
-            return sendRequestWithCertainForceConnect(request, asyncHandler, future, proxyServer, false);
-        }
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);
     }
 
     private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
@@ -131,66 +128,60 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
     }
 
     /**
-     * We know for sure if we have to force to connect or not, so we can build the
-     * HttpRequest right away This reduces the probability of having a pooled
-     * channel closed by the server by the time we build the request
+     * We know for sure if we have to force to connect or not, so we can build the HttpRequest right away This reduces the probability of having a pooled channel closed by the
+     * server by the time we build the request
      */
     private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
-            Request request, //
-            AsyncHandler<T> asyncHandler, //
-            NettyResponseFuture<T> future, //
-            ProxyServer proxyServer, //
-            boolean performConnectRequest) {
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean performingNextRequest,//
+            ProxyServer proxyServer,//
+            boolean forceConnect) {
 
-        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer,
-                performConnectRequest);
+        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
 
         Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
 
-        return Channels.isChannelActive(channel)
-                ? sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel)
-                : sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
+        if (Channels.isChannelValid(channel))
+            return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
+        else
+            return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
     /**
-     * Using CONNECT depends on wither we can fetch a valid channel or not Loop
-     * until we get a valid channel from the pool and it's still valid once the
-     * request is built @
+     * Using CONNECT depends on wither we can fetch a valid channel or not Loop until we get a valid channel from the pool and it's still valid once the request is built @
      */
+    @SuppressWarnings("unused")
     private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
-            Request request, //
-            AsyncHandler<T> asyncHandler, //
-            NettyResponseFuture<T> future, //
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean performingNextRequest,//
             ProxyServer proxyServer) {
 
         NettyResponseFuture<T> newFuture = null;
         for (int i = 0; i < 3; i++) {
             Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
+            if (Channels.isChannelValid(channel))
+                if (newFuture == null)
+                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
 
-            if (channel == null) {
+            if (Channels.isChannelValid(channel))
+                // if the channel is still active, we can use it, otherwise try
+                // gain
+                return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
+            else
                 // pool is empty
                 break;
-            }
-
-            if (newFuture == null) {
-                newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
-            }
-
-            if (Channels.isChannelActive(channel)) {
-                // if the channel is still active, we can use it,
-                // otherwise, channel was closed by the time we computed the request, try again
-                return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
-            }
         }
 
-        // couldn't poll an active channel
         newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
-        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);
+        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);
     }
 
-    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request,
-            final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture, ProxyServer proxy,
-            boolean performConnectRequest) {
+    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
+            ProxyServer proxy, boolean forceConnect) {
 
         Realm realm = null;
         if (originalFuture != null) {
@@ -209,8 +200,7 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
             proxyRealm = proxy.getRealm();
         }
 
-        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, performConnectRequest, proxy, realm,
-                proxyRealm);
+        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, forceConnect, proxy, realm, proxyRealm);
 
         if (originalFuture == null) {
             NettyResponseFuture<T> future = newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
@@ -224,24 +214,25 @@ private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
         }
     }
 
-    private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer,
-            AsyncHandler<?> asyncHandler) {
-        if (future != null && future.isReuseChannel() && Channels.isChannelActive(future.channel())) {
+    private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+        if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel())) {
             return future.channel();
         } else {
             return pollPooledChannel(request, proxyServer, asyncHandler);
         }
     }
 
-    private <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy,
-            NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
+    private <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
 
-        try {
-            asyncHandler.onConnectionPooled(channel);
-        } catch (Exception e) {
-            LOGGER.error("onConnectionPooled crashed", e);
-            abort(channel, future, e);
-            return future;
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onConnectionPooled(channel);
+            } catch (Exception e) {
+                LOGGER.error("onConnectionPooled crashed", e);
+                abort(channel, future, e);
+                return future;
+            }
         }
 
         SocketAddress channelRemoteAddress = channel.remoteAddress();
@@ -259,11 +250,10 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         }
 
         // channelInactive might be called between isChannelValid and writeRequest
-        // so if we don't store the Future now, channelInactive won't perform
-        // handleUnexpectedClosedChannel
+        // so if we don't store the Future now, channelInactive won't perform handleUnexpectedClosedChannel
         Channels.setAttribute(channel, future);
 
-        if (Channels.isChannelActive(channel)) {
+        if (Channels.isChannelValid(channel)) {
             writeRequest(future, channel);
         } else {
             // bad luck, the channel was closed in-between
@@ -276,10 +266,11 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
     }
 
     private <T> ListenableFuture<T> sendRequestWithNewChannel(//
-            Request request, //
-            ProxyServer proxy, //
-            NettyResponseFuture<T> future, //
-            AsyncHandler<T> asyncHandler) {
+            Request request,//
+            ProxyServer proxy,//
+            NettyResponseFuture<T> future,//
+            AsyncHandler<T> asyncHandler,//
+            boolean performingNextRequest) {
 
         // some headers are only set when performing the first request
         HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
@@ -289,8 +280,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
 
         future.setInAuth(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
-        future.setInProxyAuth(
-                proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
+        future.setInProxyAuth(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
 
         // Do not throw an exception when we need an extra connection for a redirect
         // FIXME why? This violate the max connection per host handling, right?
@@ -317,10 +307,8 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
 
                     @Override
                     protected void onSuccess(List<InetSocketAddress> addresses) {
-                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future,
-                                NettyRequestSender.this, channelManager, connectionSemaphore, partitionKey);
-                        NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(),
-                                addresses, asyncHandler, clientState, config);
+                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, connectionSemaphore, partitionKey);
+                        NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);
                         if (!future.isDone()) {
                             connector.connect(bootstrap, connectListener);
                         }
@@ -334,12 +322,13 @@ protected void onFailure(Throwable cause) {
 
         return future;
     }
-
-    private <T> Future<List<InetSocketAddress>> resolveAddresses(Request request, //
-            ProxyServer proxy, //
-            NettyResponseFuture<T> future, //
+    
+    private <T> Future<List<InetSocketAddress>> resolveAddresses(
+            Request request,//
+            ProxyServer proxy,//
+            NettyResponseFuture<T> future,//
             AsyncHandler<T> asyncHandler) {
-
+        
         Uri uri = request.getUri();
         final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
@@ -347,34 +336,33 @@ protected void onFailure(Throwable cause) {
             int port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
             InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(proxy.getHost(), port);
             scheduleRequestTimeout(future, unresolvedRemoteAddress);
-            return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
-
+            return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
+            
         } else {
             int port = uri.getExplicitPort();
-
+            
             if (request.getAddress() != null) {
                 // bypass resolution
                 InetSocketAddress inetSocketAddress = new InetSocketAddress(request.getAddress(), port);
                 return promise.setSuccess(singletonList(inetSocketAddress));
-
+                
             } else {
                 InetSocketAddress unresolvedRemoteAddress = InetSocketAddress.createUnresolved(uri.getHost(), port);
                 scheduleRequestTimeout(future, unresolvedRemoteAddress);
-                return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, asyncHandler);
+                return RequestHostnameResolver.INSTANCE.resolve(request.getNameResolver(), unresolvedRemoteAddress, toAsyncHandlerExtensions(asyncHandler));
             }
         }
     }
 
-    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler,
-            NettyRequest nettyRequest, ProxyServer proxyServer) {
+    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
 
         NettyResponseFuture<T> future = new NettyResponseFuture<>(//
-                request, //
-                asyncHandler, //
-                nettyRequest, //
-                config.getMaxRequestRetry(), //
-                request.getChannelPoolPartitioning(), //
-                connectionSemaphore, //
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                config.getMaxRequestRetry(),//
+                request.getChannelPoolPartitioning(),//
+                connectionSemaphore,//
                 proxyServer);
 
         String expectHeader = request.getHeaders().get(EXPECT);
@@ -387,29 +375,30 @@ protected void onFailure(Throwable cause) {
 
         NettyRequest nettyRequest = future.getNettyRequest();
         HttpRequest httpRequest = nettyRequest.getHttpRequest();
-        AsyncHandler<T> asyncHandler = future.getAsyncHandler();
+        AsyncHandler<T> handler = future.getAsyncHandler();
 
-        // if the channel is dead because it was pooled and the remote server decided to
-        // close it,
+        // if the channel is dead because it was pooled and the remote server decided to close it,
         // we just let it go and the channelInactive do its work
-        if (!Channels.isChannelActive(channel))
+        if (!Channels.isChannelValid(channel))
             return;
 
         try {
-            if (asyncHandler instanceof TransferCompletionHandler) {
-                configureTransferAdapter(asyncHandler, httpRequest);
+            if (handler instanceof TransferCompletionHandler) {
+                configureTransferAdapter(handler, httpRequest);
             }
 
-            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue()
-                    && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
+            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue() && httpRequest.method() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
 
             if (!future.isHeadersAlreadyWrittenOnContinue()) {
-                try {
-                    asyncHandler.onRequestSend(nettyRequest);
-                } catch (Exception e) {
-                    LOGGER.error("onRequestSend crashed", e);
-                    abort(channel, future, e);
-                    return;
+                final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(handler);
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onRequestSend(nettyRequest);
+                    } catch (Exception e) {
+                        LOGGER.error("onRequestSend crashed", e);
+                        abort(channel, future, e);
+                        return;
+                    }
                 }
 
                 // if the request has a body, we want to track progress
@@ -430,7 +419,7 @@ protected void onFailure(Throwable cause) {
                 nettyRequest.getBody().write(channel, future);
 
             // don't bother scheduling read timeout if channel became invalid
-            if (Channels.isChannelActive(channel)) {
+            if (Channels.isChannelValid(channel)) {
                 scheduleReadTimeout(future);
             }
 
@@ -445,19 +434,16 @@ private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpR
         TransferCompletionHandler.class.cast(handler).headers(h);
     }
 
-    private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture,
-            InetSocketAddress originalRemoteAddress) {
+    private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture, InetSocketAddress originalRemoteAddress) {
         nettyResponseFuture.touch();
-        TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config,
-                originalRemoteAddress);
+        TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config, originalRemoteAddress);
         nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
     }
 
     private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
         TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
         if (timeoutsHolder != null) {
-            // on very fast requests, it's entirely possible that the response has already
-            // been completed
+            // on very fast requests, it's entirely possible that the response has already been completed
             // by the time we try to schedule the read timeout
             nettyResponseFuture.touch();
             timeoutsHolder.startReadTimeout();
@@ -485,8 +471,7 @@ public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?
             } else if (future.incrementRetryAndCheck() && retry(future)) {
                 future.pendingException = null;
             } else {
-                abort(channel, future,
-                        future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
+                abort(channel, future, future.pendingException != null ? future.pendingException : RemotelyClosedException.INSTANCE);
             }
         }
     }
@@ -501,12 +486,15 @@ public boolean retry(NettyResponseFuture<?> future) {
             future.setChannelState(ChannelState.RECONNECTED);
 
             LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
-            try {
-                future.getAsyncHandler().onRetry();
-            } catch (Exception e) {
-                LOGGER.error("onRetry crashed", e);
-                abort(future.channel(), future, e);
-                return false;
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+            if (asyncHandlerExtensions != null) {
+                try {
+                    asyncHandlerExtensions.onRetry();
+                } catch (Exception e) {
+                    LOGGER.error("onRetry crashed", e);
+                    abort(future.channel(), future, e);
+                    return false;
+                }
             }
 
             try {
@@ -523,14 +511,12 @@ public boolean retry(NettyResponseFuture<?> future) {
         }
     }
 
-    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e,
-            Channel channel) {
+    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) {
 
         boolean replayed = false;
 
         @SuppressWarnings({ "unchecked", "rawtypes" })
-        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                .request(future.getCurrentRequest()).ioException(e).build();
+        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getCurrentRequest()).ioException(e).build();
         for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
             try {
                 fc = asyncFilter.filter(fc);
@@ -541,7 +527,6 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
         }
 
         if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
-            future.setKeepAlive(false);
             replayRequest(future, fc, channel);
             replayed = true;
         }
@@ -557,11 +542,9 @@ private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHand
         boolean isWs = uri.isWebSocket();
         if (asyncHandler instanceof WebSocketUpgradeHandler) {
             if (!isWs) {
-                throw new IllegalArgumentException(
-                        "WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
             } else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT)) {
-                throw new IllegalArgumentException(
-                        "WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
             }
         } else if (isWs) {
             throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
@@ -569,10 +552,14 @@ private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHand
     }
 
     private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
-        try {
-            asyncHandler.onConnectionPoolAttempt();
-        } catch (Exception e) {
-            LOGGER.error("onConnectionPoolAttempt crashed", e);
+
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onConnectionPoolAttempt();
+            } catch (Exception e) {
+                LOGGER.error("onConnectionPoolAttempt crashed", e);
+            }
         }
 
         Uri uri = request.getUri();
@@ -594,12 +581,15 @@ public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc,
         future.touch();
 
         LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        try {
-            future.getAsyncHandler().onRetry();
-        } catch (Exception e) {
-            LOGGER.error("onRetry crashed", e);
-            abort(channel, future, e);
-            return;
+        final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onRetry();
+            } catch (Exception e) {
+                LOGGER.error("onRetry crashed", e);
+                abort(channel, future, e);
+                return;
+            }
         }
 
         channelManager.drainChannelAndOffer(channel, future);
@@ -610,8 +600,7 @@ public boolean isClosed() {
         return clientState.isClosed();
     }
 
-    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future,
-            Request nextRequest) {
+    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
         Channels.setAttribute(channel, new OnLastHttpContentCallback(future) {
             @Override
             public void call() {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
index 26ed0667c..9002e600e 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -32,109 +32,96 @@
 
 public class NettyReactiveStreamsBody implements NettyBody {
 
-	private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
-	private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
-
-	private final Publisher<ByteBuf> publisher;
-
-	private final long contentLength;
-
-	public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
-		this.publisher = publisher;
-		this.contentLength = contentLength;
-	}
-
-	@Override
-	public long getContentLength() {
-		return contentLength;
-	}
-
-	@Override
-	public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-		if (future.isStreamConsumed()) {
-			LOGGER.warn("Stream has already been consumed and cannot be reset");
-		} else {
-			future.setStreamConsumed(true);
-			NettySubscriber subscriber = new NettySubscriber(channel, future);
-			channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
-			publisher.subscribe(new SubscriberAdapter(subscriber));
-			subscriber.delayedStart();
-		}
-	}
-
-	private static class SubscriberAdapter implements Subscriber<ByteBuf> {
-		private final Subscriber<HttpContent> subscriber;
-
-		public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
-			this.subscriber = subscriber;
-		}
-
-		@Override
-		public void onSubscribe(Subscription s) {
-			subscriber.onSubscribe(s);
-		}
-
-		@Override
-		public void onNext(ByteBuf buffer) {
-			HttpContent content = new DefaultHttpContent(buffer);
-			subscriber.onNext(content);
-		}
-
-		@Override
-		public void onError(Throwable t) {
-			subscriber.onError(t);
-		}
-
-		@Override
-		public void onComplete() {
-			subscriber.onComplete();
-		}
-	}
-
-	private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
-		private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
-
-		private final Channel channel;
-		private final NettyResponseFuture<?> future;
-
-		public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
-			super(channel.eventLoop());
-			this.channel = channel;
-			this.future = future;
-		}
-
-		@Override
-		protected void complete() {
-			channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
-					.addListener(future -> removeFromPipeline()));
-		}
-
-		private volatile Subscription deferredSubscription;
-
-		@Override
-		public void onSubscribe(Subscription subscription) {
-			deferredSubscription = subscription;
-		}
-		
-		public void delayedStart() {
-			super.onSubscribe(deferredSubscription);
-		}
-
-		@Override
-		protected void error(Throwable error) {
-			if (error == null)
-				throw null;
-			removeFromPipeline();
-			future.abort(error);
-		}
-
-		private void removeFromPipeline() {
-			try {
-				channel.pipeline().remove(this);
-				LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
-			} catch (NoSuchElementException e) {
-				LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
-			}
-		}
-	}
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
+    private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
+
+    private final Publisher<ByteBuf> publisher;
+
+    private final long contentLength;
+
+    public NettyReactiveStreamsBody(Publisher<ByteBuf> publisher, long contentLength) {
+        this.publisher = publisher;
+        this.contentLength = contentLength;
+    }
+
+    @Override
+    public long getContentLength() {
+        return contentLength;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        if (future.isStreamConsumed()) {
+            LOGGER.warn("Stream has already been consumed and cannot be reset");
+        } else {
+            future.setStreamConsumed(true);
+            NettySubscriber subscriber = new NettySubscriber(channel, future);
+            channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
+            publisher.subscribe(new SubscriberAdapter(subscriber));
+        }
+    }
+
+    private static class SubscriberAdapter implements Subscriber<ByteBuf> {
+        private final Subscriber<HttpContent> subscriber;
+
+        public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
+            this.subscriber = subscriber;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            subscriber.onSubscribe(s);
+        }
+
+        @Override
+        public void onNext(ByteBuf buffer) {
+            HttpContent content = new DefaultHttpContent(buffer);
+            subscriber.onNext(content);
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            subscriber.onError(t);
+        }
+
+        @Override
+        public void onComplete() {
+            subscriber.onComplete();
+        }
+    }
+
+    private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
+        private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
+
+        private final Channel channel;
+        private final NettyResponseFuture<?> future;
+
+        public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
+            super(channel.eventLoop());
+            this.channel = channel;
+            this.future = future;
+        }
+
+        @Override
+        protected void complete() {
+            channel.eventLoop().execute(() -> channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(future -> removeFromPipeline()));
+        }
+
+        @Override
+        protected void error(Throwable error) {
+            if (error == null)
+                throw null;
+            removeFromPipeline();
+            future.abort(error);
+        }
+
+        private void removeFromPipeline() {
+            try {
+                channel.pipeline().remove(this);
+                LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
+            } catch (NoSuchElementException e) {
+                LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
+            }
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
index 007778cf6..70ebc4185 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
@@ -31,7 +31,6 @@
     private final long length;
     private long position = 0L;
 
-    @SuppressWarnings("resource")
     public FileMultipartPart(FilePart part, byte[] boundary) {
         super(part, boundary);
         try {
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
index 3edd37a38..ebeff4975 100644
--- a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -13,37 +13,39 @@
  */
 package org.asynchttpclient.resolver;
 
+import io.netty.resolver.NameResolver;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.ImmediateEventExecutor;
+import io.netty.util.concurrent.Promise;
+
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.SimpleFutureListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.resolver.NameResolver;
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.ImmediateEventExecutor;
-import io.netty.util.concurrent.Promise;
-
 public enum RequestHostnameResolver {
 
     INSTANCE;
 
-    public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandler<?> asyncHandler) {
+    public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandlerExtensions asyncHandlerExtensions) {
 
         final String hostname = unresolvedAddress.getHostName();
         final int port = unresolvedAddress.getPort();
         final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
-        try {
-            asyncHandler.onHostnameResolutionAttempt(hostname);
-        } catch (Exception e) {
-            LOGGER.error("onHostnameResolutionAttempt crashed", e);
-            promise.tryFailure(e);
-            return promise;
+        if (asyncHandlerExtensions != null) {
+            try {
+                asyncHandlerExtensions.onHostnameResolutionAttempt(hostname);
+            } catch (Exception e) {
+                LOGGER.error("onHostnameResolutionAttempt crashed", e);
+                promise.tryFailure(e);
+                return promise;
+            }
         }
 
         final Future<List<InetAddress>> whenResolved = nameResolver.resolveAll(hostname);
@@ -56,24 +58,28 @@ protected void onSuccess(List<InetAddress> value) throws Exception {
                 for (InetAddress a : value) {
                     socketAddresses.add(new InetSocketAddress(a, port));
                 }
-                try {
-                    asyncHandler.onHostnameResolutionSuccess(hostname, socketAddresses);
-                } catch (Exception e) {
-                    LOGGER.error("onHostnameResolutionSuccess crashed", e);
-                    promise.tryFailure(e);
-                    return;
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onHostnameResolutionSuccess(hostname, socketAddresses);
+                    } catch (Exception e) {
+                        LOGGER.error("onHostnameResolutionSuccess crashed", e);
+                        promise.tryFailure(e);
+                        return;
+                    }
                 }
                 promise.trySuccess(socketAddresses);
             }
 
             @Override
             protected void onFailure(Throwable t) throws Exception {
-                try {
-                    asyncHandler.onHostnameResolutionFailure(hostname, t);
-                } catch (Exception e) {
-                    LOGGER.error("onHostnameResolutionFailure crashed", e);
-                    promise.tryFailure(e);
-                    return;
+                if (asyncHandlerExtensions != null) {
+                    try {
+                        asyncHandlerExtensions.onHostnameResolutionFailure(hostname, t);
+                    } catch (Exception e) {
+                        LOGGER.error("onHostnameResolutionFailure crashed", e);
+                        promise.tryFailure(e);
+                        return;
+                    }
                 }
                 promise.tryFailure(t);
             }
diff --git a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java b/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
deleted file mode 100644
index 17a7e62d1..000000000
--- a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public final class MessageDigestUtils {
-
-	private static final ThreadLocal<MessageDigest> MD5_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("MD5");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("MD5 not supported on this platform");
-		}
-	});
-
-	private static final ThreadLocal<MessageDigest> SHA1_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("SHA1");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("SHA1 not supported on this platform");
-		}
-	});
-
-	public static MessageDigest pooledMd5MessageDigest() {
-		MessageDigest md = MD5_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
-
-	public static MessageDigest pooledSha1MessageDigest() {
-		MessageDigest md = SHA1_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
-}
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index 0a6438660..489e130c9 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -14,25 +14,57 @@
 package org.asynchttpclient.ws;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledSha1MessageDigest;
 
-import org.asynchttpclient.util.Base64;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 
-import io.netty.util.internal.ThreadLocalRandom;
+import org.asynchttpclient.util.Base64;
 
 public final class WebSocketUtils {
-	public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
-
-	public static String getWebSocketKey() {
-		byte[] nonce = new byte[16];
-		ThreadLocalRandom random = ThreadLocalRandom.current();
-		for (int i = 0; i < nonce.length; i++) {
-			nonce[i] = (byte) random.nextInt(256);
-		}
-		return Base64.encode(nonce);
-	}
-
-	public static String getAcceptKey(String key) {
-		return Base64.encode(pooledSha1MessageDigest().digest((key + MAGIC_GUID).getBytes(US_ASCII)));
-	}
+    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+    public static String getKey() {
+        byte[] nonce = createRandomBytes(16);
+        return Base64.encode(nonce);
+    }
+
+    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
+        String acceptSeed = key + MAGIC_GUID;
+        byte[] sha1 = sha1(acceptSeed.getBytes(US_ASCII));
+        return Base64.encode(sha1);
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("MD5 not supported on this platform");
+        }
+    }
+
+    public static byte[] sha1(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("SHA-1 not supported on this platform");
+        }
+    }
+
+    public static byte[] createRandomBytes(int size) {
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size; i++) {
+            bytes[i] = (byte) createRandomNumber(0, 255);
+        }
+
+        return bytes;
+    }
+
+    public static int createRandomNumber(int min, int max) {
+        return (int) (Math.random() * max + min);
+    }
+
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index 2cd0282b3..d3c27d564 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -17,6 +17,7 @@
 
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -28,18 +29,17 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.Test;
 
-import io.netty.handler.codec.http.HttpHeaders;
-
 /**
  * Tests default asynchronous life cycle.
  * 
@@ -61,7 +61,8 @@ public AbstractHandler configureHandler() throws Exception {
             public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
                 resp.setContentType("text/plain;charset=utf-8");
                 resp.setStatus(200);
-                final AsyncContext asyncContext = request.startAsync();
+                final Continuation continuation = ContinuationSupport.getContinuation(req);
+                continuation.suspend();
                 final PrintWriter writer = resp.getWriter();
                 executorService.submit(new Runnable() {
                     public void run() {
@@ -85,7 +86,7 @@ public void run() {
                         logger.info("Delivering part2.");
                         writer.write("part2");
                         writer.flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     }
                 });
                 request.setHandled(true);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 7b878ec13..f8b783d37 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -25,11 +25,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -59,7 +60,8 @@ public AbstractHandler configureHandler() throws Exception {
     private class SlowHandler extends AbstractHandler {
         public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
             new Thread(new Runnable() {
                 public void run() {
                     try {
@@ -79,7 +81,7 @@ public void run() {
                         Thread.sleep(3000);
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     } catch (InterruptedException e) {
                         logger.error(e.getMessage(), e);
                     } catch (IOException e) {
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
new file mode 100644
index 000000000..60f369d55
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * This program is licensed to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.cookie.Cookie;
+import io.netty.handler.codec.http.cookie.DefaultCookie;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.io.IOUtils;
+import org.testng.annotations.Test;
+
+/**
+ * Unit tests for remote site. <br>
+ * see http://github.com/MSch/ning-async-http-client-bug/tree/master
+ * 
+ * @author Martin Schurrer
+ */
+public class RemoteSiteTest extends AbstractBasicTest {
+
+    public static final String URL = "http://google.com?q=";
+    public static final String REQUEST_PARAM = "github github \n" + "github";
+
+    @Test(groups = "online")
+    public void testGoogleCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testWwwMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testUpdateMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void testGoogleComWithTimeout() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncStatusHEADContentLenghtTest() throws Exception {
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true))) {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            p.executeRequest(head("http://www.google.com/"), new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        return response;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            }).get();
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void invalidStreamTest2() throws Exception {
+        AsyncHttpClientConfig config = config()//
+                .setRequestTimeout(10000)//
+                .setFollowRedirect(true)//
+                .setKeepAlive(false)//
+                .setMaxRedirects(6)//
+                .build();
+
+        try (AsyncHttpClient c = asyncHttpClient(config)) {
+            Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
+            if (response != null) {
+                System.out.println(response);
+            }
+        } catch (Throwable t) {
+            t.printStackTrace();
+            assertNotNull(t.getCause());
+            assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncFullBodyProperlyRead() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Response r = client.prepareGet("http://www.typesafe.com/").execute().get();
+
+            InputStream stream = r.getResponseBodyAsStream();
+            int contentLength = Integer.valueOf(r.getHeader(CONTENT_LENGTH));
+
+            assertEquals(contentLength, IOUtils.toByteArray(stream).length);
+        }
+    }
+
+    // FIXME Get a 302 in France...
+    @Test(groups = "online", enabled = false)
+    public void testUrlRequestParametersEncoding() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
+            logger.info(String.format("Executing request [%s] ...", requestUrl2));
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void stripQueryStringTest() throws Exception {
+
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online")
+    public void evilCookieTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Cookie cookie = new DefaultCookie("evilcookie", "test");
+            cookie.setDomain(".google.com");
+            cookie.setPath("/");
+
+            RequestBuilder builder = get("http://localhost")//
+                    .setFollowRedirect(true)//
+                    .setUrl("http://www.google.com/")//
+                    .addHeader("Content-Type", "text/plain")//
+                    .addCookie(cookie);
+
+            Response response = c.executeRequest(builder.build()).get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void testAHC62Com() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    builder.accumulate(bodyPart);
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return State.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getResponseBody().length() >= 3870);
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
index 988ed576a..ac51e2a23 100644
--- a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
@@ -14,61 +14,62 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.http.HttpMessage;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-import java.util.function.Consumer;
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.handler.codec.http.HttpMessage;
-
 public class EventPipelineTest extends AbstractBasicTest {
 
-	@Test(groups = "standalone")
-	public void asyncPipelineTest() throws Exception {
+    @Test(groups = "standalone")
+    public void asyncPipelineTest() throws Exception {
 
-		Consumer<Channel> httpAdditionalPipelineInitializer = channel -> channel.pipeline().addBefore("inflater",
-				"copyEncodingHeader", new CopyEncodingHandler());
+        AsyncHttpClientConfig.AdditionalChannelInitializer httpAdditionalPipelineInitializer = new AsyncHttpClientConfig.AdditionalChannelInitializer() {
+            public void initChannel(Channel channel) throws Exception {
+                channel.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+            }
+        };
 
-		try (AsyncHttpClient p = asyncHttpClient(
-				config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
-			final CountDownLatch l = new CountDownLatch(1);
-			p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
-				@Override
-				public Response onCompleted(Response response) throws Exception {
-					try {
-						assertEquals(response.getStatusCode(), 200);
-						assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
-					} finally {
-						l.countDown();
-					}
-					return response;
-				}
-			}).get();
-			if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-				fail("Timeout out");
-			}
-		}
-	}
+        try (AsyncHttpClient p = asyncHttpClient(config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
+            final CountDownLatch l = new CountDownLatch(1);
+            p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
+        }
+    }
 
-	private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
-		@Override
-		public void channelRead(ChannelHandlerContext ctx, Object e) {
-			if (e instanceof HttpMessage) {
-				HttpMessage m = (HttpMessage) e;
-				// for test there is no Content-Encoding header so just hard
-				// coding value
-				// for verification
-				m.headers().set("X-Original-Content-Encoding", "<original encoding>");
-			}
-			ctx.fireChannelRead(e);
-		}
-	}
+    private static class CopyEncodingHandler extends ChannelInboundHandlerAdapter {
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object e) {
+            if (e instanceof HttpMessage) {
+                HttpMessage m = (HttpMessage) e;
+                // for test there is no Content-Encoding header so just hard
+                // coding value
+                // for verification
+                m.headers().set("X-Original-Content-Encoding", "<original encoding>");
+            }
+            ctx.fireChannelRead(e);
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index cec2b0ef5..b58644a00 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -24,7 +24,6 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -33,6 +32,8 @@
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -50,14 +51,15 @@ public AbstractHandler configureHandler() throws Exception {
         public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
                 throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
             new Thread(new Runnable() {
                 public void run() {
                     try {
                         Thread.sleep(SLEEPTIME_MS);
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     } catch (InterruptedException e) {
                         logger.error(e.getMessage(), e);
                     } catch (IOException e) {
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
index 2415d61b8..cc3626360 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/FailingReactiveStreamsTest.java
@@ -20,13 +20,17 @@
 import io.netty.channel.ChannelFutureListener;
 
 import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.handler.StreamedResponsePublisher;
+import org.asynchttpclient.netty.request.NettyRequest;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleStreamedAsyncHandler;
 import org.asynchttpclient.reactivestreams.ReactiveStreamsTest.SimpleSubscriber;
 import org.reactivestreams.Publisher;
@@ -115,7 +119,7 @@ public void onNext(HttpResponseBodyPart t) {
         }
     }
 
-    private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler {
+    private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler implements AsyncHandlerExtensions {
         private final CountDownLatch replaying;
 
         public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
@@ -123,6 +127,58 @@ public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<Htt
             this.replaying = replaying;
         }
 
+        @Override
+        public void onHostnameResolutionAttempt(String name) {
+        }
+
+        @Override
+        public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+        }
+
+        @Override
+        public void onHostnameResolutionFailure(String name, Throwable cause) {
+        }
+
+        @Override
+        public void onTcpConnectAttempt(InetSocketAddress address) {
+        }
+
+        @Override
+        public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
+        }
+
+        @Override
+        public void onTcpConnectFailure(InetSocketAddress address, Throwable cause) {
+        }
+
+        @Override
+        public void onTlsHandshakeAttempt() {
+        }
+
+        @Override
+        public void onTlsHandshakeSuccess() {
+        }
+
+        @Override
+        public void onTlsHandshakeFailure(Throwable cause) {
+        }
+
+        @Override
+        public void onConnectionPoolAttempt() {
+        }
+
+        @Override
+        public void onConnectionPooled(Channel connection) {
+        }
+
+        @Override
+        public void onConnectionOffer(Channel connection) {
+        }
+
+        @Override
+        public void onRequestSend(NettyRequest request) {
+        }
+
         @Override
         public void onRetry() {
             replaying.countDown();
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index eaefdfc30..c54b89180 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -14,7 +14,7 @@
 
 import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
 import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
@@ -63,479 +63,470 @@
 
 public class ReactiveStreamsTest {
 
-	private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
-
-	public static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
-		return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
-	}
-
-	private Tomcat tomcat;
-	private int port1;
-
-	@SuppressWarnings("serial")
-	@BeforeClass(alwaysRun = true)
-	public void setUpGlobal() throws Exception {
-
-		String path = new File(".").getAbsolutePath() + "/target";
-
-		tomcat = new Tomcat();
-		tomcat.setHostname("localhost");
-		tomcat.setPort(0);
-		tomcat.setBaseDir(path);
-		Context ctx = tomcat.addContext("", path);
-
-		Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
-
-			@Override
-			public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-					throws ServletException, IOException {
-				LOGGER.debug("Echo received request {} on path {}", httpRequest,
-						httpRequest.getServletContext().getContextPath());
-
-				if (httpRequest.getHeader("X-HEAD") != null) {
-					httpResponse.setContentLength(1);
-				}
-
-				if (httpRequest.getHeader("X-ISO") != null) {
-					httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
-				} else {
-					httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-				}
-
-				if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
-					httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
-				}
-
-				Enumeration<String> e = httpRequest.getHeaderNames();
-				String headerName;
-				while (e.hasMoreElements()) {
-					headerName = e.nextElement();
-					if (headerName.startsWith("LockThread")) {
-						final int sleepTime = httpRequest.getIntHeader(headerName);
-						try {
-							Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
-						} catch (InterruptedException ex) {
-						}
-					}
-
-					if (headerName.startsWith("X-redirect")) {
-						httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
-						return;
-					}
-					httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
-				}
-
-				String pathInfo = httpRequest.getPathInfo();
-				if (pathInfo != null)
-					httpResponse.addHeader("X-pathInfo", pathInfo);
-
-				String queryString = httpRequest.getQueryString();
-				if (queryString != null)
-					httpResponse.addHeader("X-queryString", queryString);
-
-				httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-				Cookie[] cs = httpRequest.getCookies();
-				if (cs != null) {
-					for (Cookie c : cs) {
-						httpResponse.addCookie(c);
-					}
-				}
-
-				Enumeration<String> i = httpRequest.getParameterNames();
-				if (i.hasMoreElements()) {
-					StringBuilder requestBody = new StringBuilder();
-					while (i.hasMoreElements()) {
-						headerName = i.nextElement();
-						httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
-						requestBody.append(headerName);
-						requestBody.append("_");
-					}
-
-					if (requestBody.length() > 0) {
-						String body = requestBody.toString();
-						httpResponse.getOutputStream().write(body.getBytes());
-					}
-				}
-
-				final AsyncContext context = httpRequest.startAsync();
-				final ServletInputStream input = httpRequest.getInputStream();
-				final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-
-				input.setReadListener(new ReadListener() {
-
-					byte[] buffer = new byte[5 * 1024];
-
-					@Override
-					public void onError(Throwable t) {
-						t.printStackTrace();
-						httpResponse
-								.setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
-						context.complete();
-					}
-
-					@Override
-					public void onDataAvailable() throws IOException {
-						int len = -1;
-						while (input.isReady() && (len = input.read(buffer)) != -1) {
-							baos.write(buffer, 0, len);
-						}
-					}
-
-					@Override
-					public void onAllDataRead() throws IOException {
-						byte[] requestBodyBytes = baos.toByteArray();
-						int total = requestBodyBytes.length;
-
-						httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
-						String md5 = TestUtils.md5(requestBodyBytes, 0, total);
-						httpResponse.addHeader(CONTENT_MD5.toString(), md5);
-
-						httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
-						context.complete();
-					}
-				});
-			}
-		});
-		wrapper.setAsyncSupported(true);
-		ctx.addServletMappingDecoded("/*", "webdav");
-		tomcat.start();
-		port1 = tomcat.getConnector().getLocalPort();
-	}
-
-	@AfterClass(alwaysRun = true)
-	public void tearDownGlobal() throws InterruptedException, Exception {
-		tomcat.stop();
-	}
-
-	private String getTargetUrl() {
-		return String.format("http://localhost:%d/foo/test", port1);
-	}
-
-	@Test(groups = "standalone")
-	public void testStreamingPutImage() throws Exception {
-		try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-			Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342))
-					.execute().get();
-			assertEquals(response.getStatusCode(), 200);
-			assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-		}
-	}
-
-	@Test(groups = "standalone")
-	public void testConnectionDoesNotGetClosed() throws Exception {
-		// test that we can stream the same request multiple times
-		try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-			BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())//
-					.setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))//
-					.setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)//
-					.setHeader("X-" + CONTENT_MD5, LARGE_IMAGE_BYTES_MD5);
-
-			Response response = requestBuilder.execute().get();
-			assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
-
-			byte[] responseBody = response.getResponseBodyAsBytes();
-			responseBody = response.getResponseBodyAsBytes();
-			assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-					LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-			assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-			assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
-			assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
-
-			response = requestBuilder.execute().get();
-			assertEquals(response.getStatusCode(), 200);
-			responseBody = response.getResponseBodyAsBytes();
-			assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-					LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
-
-			try {
-				assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-				assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
-				assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
-			} catch (AssertionError e) {
-				e.printStackTrace();
-				for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
-					assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
-				}
-				throw e;
-			}
-		}
-	}
-
-	public static void main(String[] args) throws Exception {
-		ReactiveStreamsTest test = new ReactiveStreamsTest();
-		test.setUpGlobal();
-		try {
-			for (int i = 0; i < 1000; i++) {
-				test.testConnectionDoesNotGetClosed();
-			}
-		} finally {
-			test.tearDownGlobal();
-		}
-	}
-
-	@Test(groups = "standalone", expectedExceptions = ExecutionException.class)
-	public void testFailingStream() throws Exception {
-		try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
-			Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
-			client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
-		}
-	}
-
-	@SuppressWarnings("serial")
-	private class FailedStream extends RuntimeException {
-	}
-
-	@Test(groups = "standalone")
-	public void streamedResponseTest() throws Throwable {
-		try (AsyncHttpClient c = asyncHttpClient()) {
-
-			SimpleSubscriber<HttpResponseBodyPart> subscriber = new SimpleSubscriber<>();
-			ListenableFuture<Void> future = c.preparePost(getTargetUrl())
-					.setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
-
-			// block
-			future.get();
-			assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
-
-			// Run it again to check that the pipeline is in a good state
-			subscriber = new SimpleSubscriber<>();
-			future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
-
-			future.get();
-			assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
-
-			// Make sure a regular request still works
-			assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
-
-		}
-	}
-
-	@Test(groups = "standalone")
-	public void cancelStreamedResponseTest() throws Throwable {
-		try (AsyncHttpClient c = asyncHttpClient()) {
-
-			// Cancel immediately
-			c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0))
-					.get();
-
-			// Cancel after 1 element
-			c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1))
-					.get();
-
-			// Cancel after 10 elements
-			c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10))
-					.get();
-
-			// Make sure a regular request works
-			assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
-		}
-	}
-
-	static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<Void> {
-		private final Subscriber<HttpResponseBodyPart> subscriber;
-
-		public SimpleStreamedAsyncHandler(Subscriber<HttpResponseBodyPart> subscriber) {
-			this.subscriber = subscriber;
-		}
-
-		@Override
-		public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-			publisher.subscribe(subscriber);
-			return State.CONTINUE;
-		}
-
-		@Override
-		public void onThrowable(Throwable t) {
-			throw new AssertionError(t);
-		}
-
-		@Override
-		public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-			throw new AssertionError("Should not have received body part");
-		}
-
-		@Override
-		public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-			return State.CONTINUE;
-		}
-
-		@Override
-		public State onHeadersReceived(HttpHeaders headers) throws Exception {
-			return State.CONTINUE;
-		}
-
-		@Override
-		public Void onCompleted() throws Exception {
-			return null;
-		}
-	}
-
-	/**
-	 * Simple subscriber that requests and buffers one element at a time.
-	 */
-	static class SimpleSubscriber<T> implements Subscriber<T> {
-		private volatile Subscription subscription;
-		private volatile Throwable error;
-		private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
-		private final CountDownLatch latch = new CountDownLatch(1);
-
-		@Override
-		public void onSubscribe(Subscription subscription) {
-			this.subscription = subscription;
-			subscription.request(1);
-		}
-
-		@Override
-		public void onNext(T t) {
-			elements.add(t);
-			subscription.request(1);
-		}
-
-		@Override
-		public void onError(Throwable error) {
-			this.error = error;
-			latch.countDown();
-		}
-
-		@Override
-		public void onComplete() {
-			latch.countDown();
-		}
-
-		public List<T> getElements() throws Throwable {
-			latch.await();
-			if (error != null) {
-				throw error;
-			} else {
-				return elements;
-			}
-		}
-	}
-
-	static byte[] getBytes(List<HttpResponseBodyPart> bodyParts) throws IOException {
-		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-		for (HttpResponseBodyPart part : bodyParts) {
-			bytes.write(part.getBodyPartBytes());
-		}
-		return bytes.toByteArray();
-	}
-
-	static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
-		private final int cancelAfter;
-
-		public CancellingStreamedAsyncProvider(int cancelAfter) {
-			this.cancelAfter = cancelAfter;
-		}
-
-		@Override
-		public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-			publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
-			return State.CONTINUE;
-		}
-
-		@Override
-		public void onThrowable(Throwable t) {
-			throw new AssertionError(t);
-		}
-
-		@Override
-		public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-			throw new AssertionError("Should not have received body part");
-		}
-
-		@Override
-		public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-			return State.CONTINUE;
-		}
-
-		@Override
-		public State onHeadersReceived(HttpHeaders headers) throws Exception {
-			return State.CONTINUE;
-		}
-
-		@Override
-		public CancellingStreamedAsyncProvider onCompleted() throws Exception {
-			return this;
-		}
-	}
-
-	/**
-	 * Simple subscriber that cancels after receiving n elements.
-	 */
-	static class CancellingSubscriber<T> implements Subscriber<T> {
-		private final int cancelAfter;
-
-		public CancellingSubscriber(int cancelAfter) {
-			this.cancelAfter = cancelAfter;
-		}
-
-		private volatile Subscription subscription;
-		private volatile int count;
-
-		@Override
-		public void onSubscribe(Subscription subscription) {
-			this.subscription = subscription;
-			if (cancelAfter == 0) {
-				subscription.cancel();
-			} else {
-				subscription.request(1);
-			}
-		}
-
-		@Override
-		public void onNext(T t) {
-			count++;
-			if (count == cancelAfter) {
-				subscription.cancel();
-			} else {
-				subscription.request(1);
-			}
-		}
-
-		@Override
-		public void onError(Throwable error) {
-		}
-
-		@Override
-		public void onComplete() {
-		}
-	}
-
-	static class ByteBufIterable implements Iterable<ByteBuf> {
-		private final byte[] payload;
-		private final int chunkSize;
-
-		public ByteBufIterable(byte[] payload, int chunkSize) {
-			this.payload = payload;
-			this.chunkSize = chunkSize;
-		}
-
-		@Override
-		public Iterator<ByteBuf> iterator() {
-			return new Iterator<ByteBuf>() {
-				private int currentIndex = 0;
-
-				@Override
-				public boolean hasNext() {
-					return currentIndex != payload.length;
-				}
-
-				@Override
-				public ByteBuf next() {
-					int thisCurrentIndex = currentIndex;
-					int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
-					currentIndex += length;
-					return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
-				}
-
-				@Override
-				public void remove() {
-					throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
-				}
-			};
-		}
-	}
+    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsTest.class);
+
+    public static Publisher<ByteBuf> createPublisher(final byte[] bytes, final int chunkSize) {
+        return Flowable.fromIterable(new ByteBufIterable(bytes, chunkSize));
+    }
+
+    private Tomcat tomcat;
+    private int port1;
+
+    @SuppressWarnings("serial")
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+
+        String path = new File(".").getAbsolutePath() + "/target";
+
+        tomcat = new Tomcat();
+        tomcat.setHostname("localhost");
+        tomcat.setPort(0);
+        tomcat.setBaseDir(path);
+        Context ctx = tomcat.addContext("", path);
+
+        Wrapper wrapper = Tomcat.addServlet(ctx, "webdav", new HttpServlet() {
+
+            @Override
+            public void service(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
+                LOGGER.debug("Echo received request {} on path {}", httpRequest, httpRequest.getServletContext().getContextPath());
+
+                if (httpRequest.getHeader("X-HEAD") != null) {
+                    httpResponse.setContentLength(1);
+                }
+
+                if (httpRequest.getHeader("X-ISO") != null) {
+                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET);
+                } else {
+                    httpResponse.setContentType(TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                }
+
+                if (httpRequest.getMethod().equalsIgnoreCase("OPTIONS")) {
+                    httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+                }
+
+                Enumeration<String> e = httpRequest.getHeaderNames();
+                String headerName;
+                while (e.hasMoreElements()) {
+                    headerName = e.nextElement();
+                    if (headerName.startsWith("LockThread")) {
+                        final int sleepTime = httpRequest.getIntHeader(headerName);
+                        try {
+                            Thread.sleep(sleepTime == -1 ? 40 : sleepTime * 1000);
+                        } catch (InterruptedException ex) {
+                        }
+                    }
+
+                    if (headerName.startsWith("X-redirect")) {
+                        httpResponse.sendRedirect(httpRequest.getHeader("X-redirect"));
+                        return;
+                    }
+                    httpResponse.addHeader("X-" + headerName, httpRequest.getHeader(headerName));
+                }
+
+                String pathInfo = httpRequest.getPathInfo();
+                if (pathInfo != null)
+                    httpResponse.addHeader("X-pathInfo", pathInfo);
+
+                String queryString = httpRequest.getQueryString();
+                if (queryString != null)
+                    httpResponse.addHeader("X-queryString", queryString);
+
+                httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
+
+                Cookie[] cs = httpRequest.getCookies();
+                if (cs != null) {
+                    for (Cookie c : cs) {
+                        httpResponse.addCookie(c);
+                    }
+                }
+
+                Enumeration<String> i = httpRequest.getParameterNames();
+                if (i.hasMoreElements()) {
+                    StringBuilder requestBody = new StringBuilder();
+                    while (i.hasMoreElements()) {
+                        headerName = i.nextElement();
+                        httpResponse.addHeader("X-" + headerName, httpRequest.getParameter(headerName));
+                        requestBody.append(headerName);
+                        requestBody.append("_");
+                    }
+
+                    if (requestBody.length() > 0) {
+                        String body = requestBody.toString();
+                        httpResponse.getOutputStream().write(body.getBytes());
+                    }
+                }
+
+                final AsyncContext context = httpRequest.startAsync();
+                final ServletInputStream input = httpRequest.getInputStream();
+                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+                input.setReadListener(new ReadListener() {
+
+                    byte[] buffer = new byte[5 * 1024];
+
+                    @Override
+                    public void onError(Throwable t) {
+                        t.printStackTrace();
+                        httpResponse.setStatus(io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
+                        context.complete();
+                    }
+
+                    @Override
+                    public void onDataAvailable() throws IOException {
+                        int len = -1;
+                        while (input.isReady() && (len = input.read(buffer)) != -1) {
+                            baos.write(buffer, 0, len);
+                        }
+                    }
+
+                    @Override
+                    public void onAllDataRead() throws IOException {
+                        byte[] requestBodyBytes = baos.toByteArray();
+                        int total = requestBodyBytes.length;
+
+                        httpResponse.addIntHeader("X-" + CONTENT_LENGTH, total);
+                        String md5 = TestUtils.md5(requestBodyBytes, 0, total);
+                        httpResponse.addHeader(CONTENT_MD5.toString(), md5);
+
+                        httpResponse.getOutputStream().write(requestBodyBytes, 0, total);
+                        context.complete();
+                    }
+                });
+            }
+        });
+        wrapper.setAsyncSupported(true);
+        ctx.addServletMappingDecoded("/*", "webdav");
+        tomcat.start();
+        port1 = tomcat.getConnector().getLocalPort();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void tearDownGlobal() throws InterruptedException, Exception {
+        tomcat.stop();
+    }
+
+    private String getTargetUrl() {
+        return String.format("http://localhost:%d/foo/test", port1);
+    }
+
+    @Test(groups = "standalone")
+    public void testStreamingPutImage() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Response response = client.preparePut(getTargetUrl()).setBody(createPublisher(LARGE_IMAGE_BYTES, 2342)).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testConnectionDoesNotGetClosed() throws Exception {
+        // test that we can stream the same request multiple times
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            String expectedMd5 = TestUtils.md5(LARGE_IMAGE_BYTES);
+            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())//
+                    .setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))//
+                    .setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)//
+                    .setHeader("X-" + CONTENT_MD5, expectedMd5);
+
+            Response response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200, "HTTP response was invalid on first request.");
+
+            byte[] responseBody = response.getResponseBodyAsBytes();
+            responseBody = response.getResponseBodyAsBytes();
+            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+            assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
+            assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
+            assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes are not equal on first attempt");
+
+            response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            responseBody = response.getResponseBodyAsBytes();
+            assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(), LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
+            assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+
+            try {
+                assertEquals(response.getHeader(CONTENT_MD5), expectedMd5, "Server side payload MD5 invalid");
+                assertEquals(TestUtils.md5(responseBody), expectedMd5, "Client side payload MD5 invalid");
+                assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
+            } catch (AssertionError e) {
+                e.printStackTrace();
+                for (int i = 0; i < LARGE_IMAGE_BYTES.length; i++) {
+                    assertEquals(responseBody[i], LARGE_IMAGE_BYTES[i], "Invalid response byte at position " + i);
+                }
+                throw e;
+            }
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+        ReactiveStreamsTest test = new ReactiveStreamsTest();
+        test.setUpGlobal();
+        try {
+            for (int i = 0; i < 1000; i++) {
+                test.testConnectionDoesNotGetClosed();
+            }
+        } finally {
+            test.tearDownGlobal();
+        }
+    }
+
+    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
+    public void testFailingStream() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Publisher<ByteBuf> failingPublisher = Flowable.error(new FailedStream());
+            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    private class FailedStream extends RuntimeException {
+    }
+
+    @Test(groups = "standalone")
+    public void streamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
+
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+
+            // Run it again to check that the pipeline is in a good state
+            future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
+
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+
+            // Make sure a regular request still works
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void cancelStreamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+
+            // Cancel immediately
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0)).get();
+
+            // Cancel after 1 element
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1)).get();
+
+            // Cancel after 10 elements
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10)).get();
+
+            // Make sure a regular request works
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
+        }
+    }
+
+    static class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
+        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+
+        public SimpleStreamedAsyncHandler() {
+            this(new SimpleSubscriber<>());
+        }
+
+        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            this.subscriber = subscriber;
+        }
+
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(subscriber);
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+            return this;
+        }
+
+        public byte[] getBytes() throws Throwable {
+            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            for (HttpResponseBodyPart part : bodyParts) {
+                bytes.write(part.getBodyPartBytes());
+            }
+            return bytes.toByteArray();
+        }
+    }
+
+    /**
+     * Simple subscriber that requests and buffers one element at a time.
+     */
+    static class SimpleSubscriber<T> implements Subscriber<T> {
+        private volatile Subscription subscription;
+        private volatile Throwable error;
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
+        private final CountDownLatch latch = new CountDownLatch(1);
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            subscription.request(1);
+        }
+
+        @Override
+        public void onNext(T t) {
+            elements.add(t);
+            subscription.request(1);
+        }
+
+        @Override
+        public void onError(Throwable error) {
+            this.error = error;
+            latch.countDown();
+        }
+
+        @Override
+        public void onComplete() {
+            latch.countDown();
+        }
+
+        public List<T> getElements() throws Throwable {
+            latch.await();
+            if (error != null) {
+                throw error;
+            } else {
+                return elements;
+            }
+        }
+    }
+
+    static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
+        private final int cancelAfter;
+
+        public CancellingStreamedAsyncProvider(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
+
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public CancellingStreamedAsyncProvider onCompleted() throws Exception {
+            return this;
+        }
+    }
+
+    /**
+     * Simple subscriber that cancels after receiving n elements.
+     */
+    static class CancellingSubscriber<T> implements Subscriber<T> {
+        private final int cancelAfter;
+
+        public CancellingSubscriber(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
+
+        private volatile Subscription subscription;
+        private volatile int count;
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            if (cancelAfter == 0) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
+        }
+
+        @Override
+        public void onNext(T t) {
+            count++;
+            if (count == cancelAfter) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
+        }
+
+        @Override
+        public void onError(Throwable error) {
+        }
+
+        @Override
+        public void onComplete() {
+        }
+    }
+
+    static class ByteBufIterable implements Iterable<ByteBuf> {
+        private final byte[] payload;
+        private final int chunkSize;
+
+        public ByteBufIterable(byte[] payload, int chunkSize) {
+            this.payload = payload;
+            this.chunkSize = chunkSize;
+        }
+
+        @Override
+        public Iterator<ByteBuf> iterator() {
+            return new Iterator<ByteBuf>() {
+                private int currentIndex = 0;
+
+                @Override
+                public boolean hasNext() {
+                    return currentIndex != payload.length;
+                }
+
+                @Override
+                public ByteBuf next() {
+                    int thisCurrentIndex = currentIndex;
+                    int length = Math.min(chunkSize, payload.length - thisCurrentIndex);
+                    currentIndex += length;
+                    return Unpooled.wrappedBuffer(payload, thisCurrentIndex, length);
+                }
+
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
+                }
+            };
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
index ecb24ab4e..297fd9d24 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
@@ -13,19 +13,19 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpHeaderValues.*;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
 
 import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Function;
 
-import org.asynchttpclient.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BasicAuthTest;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -37,6 +37,7 @@
     @BeforeClass(alwaysRun = true)
     @Override
     public void setUpGlobal() throws Exception {
+
         server = new Server();
         ServerConnector connector1 = addHttpConnector(server);
         addBasicAuthHandler(server, configureHandler());
@@ -50,56 +51,31 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicAuthTest.SimpleHandler();
     }
 
-    private void expectBrokenPipe(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
+    @Test(groups = "standalone", enabled = false)
+    public void testNoRealm() throws Exception {
         File file = createTempFile(1024 * 1024);
 
-        Throwable cause = null;
         try (AsyncHttpClient client = asyncHttpClient()) {
-            try {
-                for (int i = 0; i < 20 && cause == null; i++) {
-                    f.apply(client.preparePut(getTargetUrl())//
-                            .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                            .execute().get();
-                }
-            } catch (ExecutionException e) {
-                cause = e.getCause();
+            for (int i = 0; i < 20; i++) {
+                Response response = client.preparePut(getTargetUrl())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
+                assertEquals(response.getStatusCode(), 401);
             }
         }
-
-        assertTrue(cause instanceof IOException, "Expected an IOException");
     }
 
-    @Test(groups = "standalone")
-    public void noRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb);
-    }
-
-    @Test(groups = "standalone")
-    public void unauthorizedNonPreemptiveRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)));
-    }
-
-    private void expectSuccess(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
+    @Test(groups = "standalone", enabled = false)
+    public void testAuthorizedRealm() throws Exception {
         File file = createTempFile(1024 * 1024);
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             for (int i = 0; i < 20; i++) {
-                Response response = f.apply(client.preparePut(getTargetUrl())//
-                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                        .execute().get();
+                Response response = client.preparePut(getTargetUrl())//
+                        .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
                 assertEquals(response.getStatusCode(), 200);
                 assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
             }
         }
     }
-
-    @Test(groups = "standalone")
-    public void authorizedPreemptiveRealmWorks() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true)));
-    }
-
-    @Test(groups = "standalone")
-    public void authorizedNonPreemptiveRealmWorksWithExpectContinue() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)).setHeader(EXPECT, CONTINUE));
-    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
index 87b57bc83..b7b9890ce 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -193,7 +193,7 @@ public void testVisitPostContents() {
 
     @Test
     public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
-        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"), UTF_8);
+        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"));
 
         List<Part> parts = new ArrayList<>();
         parts.add(new StringPart("test_sample_message.eml", text));
diff --git a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
index 12ddac8e3..0e0b594ed 100644
--- a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -25,10 +25,11 @@
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.request.NettyRequest;
 import org.testng.Assert;
 
-public class EventCollectingHandler extends AsyncCompletionHandlerBase {
+public class EventCollectingHandler extends AsyncCompletionHandlerBase implements AsyncHandlerExtensions {
 
     public static final String COMPLETED_EVENT = "Completed";
     public static final String STATUS_RECEIVED_EVENT = "StatusReceived";
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index 4b14c5cfa..90e4341ff 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -61,7 +61,6 @@
 import org.asynchttpclient.SslEngineFactory;
 import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
 import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.MessageDigestUtils;
 import org.eclipse.jetty.security.ConstraintMapping;
 import org.eclipse.jetty.security.ConstraintSecurityHandler;
 import org.eclipse.jetty.security.HashLoginService;
@@ -90,7 +89,6 @@
     public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
     public static final File LARGE_IMAGE_FILE;
     public static final byte[] LARGE_IMAGE_BYTES;
-    public static final String LARGE_IMAGE_BYTES_MD5;
     public static final File SIMPLE_TEXT_FILE;
     public static final String SIMPLE_TEXT_FILE_STRING;
     private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
@@ -101,7 +99,6 @@
             TMP_DIR.deleteOnExit();
             LARGE_IMAGE_FILE = resourceAsFile("300k.png");
             LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
-            LARGE_IMAGE_BYTES_MD5 = TestUtils.md5(LARGE_IMAGE_BYTES);
             SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
             SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
         } catch (Exception e) {
@@ -376,7 +373,7 @@ public static String md5(byte[] bytes) {
 
     public static String md5(byte[] bytes, int offset, int len) {
         try {
-            MessageDigest md = MessageDigestUtils.pooledMd5MessageDigest();
+            MessageDigest md = MessageDigest.getInstance("MD5");
             md.update(bytes, offset, len);
             return Base64.encode(md.digest());
         } catch (Exception e) {
diff --git a/example/pom.xml b/example/pom.xml
index f1a77a693..1e1eacaee 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-example</artifactId>
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 8340a2062..76c56ec76 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index f21dd5e0f..1734d2b3d 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.1.0-RC2-SNAPSHOT</version>
+    <version>2.1.0-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index 67e675dc6..63af14a83 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 24b509f7a..49d0318db 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.1.0-RC2-SNAPSHOT</version>
+		<version>2.1.0-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 2db2b541a..941208730 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -21,6 +21,7 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
index b000c0bb1..f59bf0698 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientImplException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
index b93086d4e..60fa3170d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 3695b20fe..f252a8e8d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
index 2493f6302..a918bffdc 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
index 6a88d03be..bf2b166d0 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
index b7be92d8f..e546c6899 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
index 43817f491..713887c98 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
index 6e1f62805..1aca098e8 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
index aeab35c86..b3d853de3 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
index 115916e09..0e61c109f 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
index 358f81a38..b9410737d 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClientRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index 29dc040de..edba32b80 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
 
     <artifactId>async-http-client-extras-retrofit2</artifactId>
@@ -13,7 +13,7 @@
 
     <properties>
       <retrofit2.version>2.3.0</retrofit2.version>
-      <lombok.version>1.16.18</lombok.version>
+      <lombok.version>1.16.16</lombok.version>
     </properties>
 
     <dependencies>
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index db48db58b..7c77178cc 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
index b97993dc5..9497d0f81 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -31,7 +31,7 @@ public void testToObservableNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -51,7 +51,7 @@ public void testToObservableError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io/ttfn"));
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io/ttfn"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -71,7 +71,7 @@ public void testObserveNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -91,7 +91,7 @@ public void testObserveError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io/ttfn"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io/ttfn"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -111,7 +111,7 @@ public void testObserveMultiple() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
             Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
             Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
             Observable<Response> all = Observable.merge(o1, o2, o3);
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 265ac8e6e..434e67a95 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava2</artifactId>
     <name>Asynchronous Http Client RxJava2 Extras</name>
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 0f5fe4db9..5d4306d00 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.1.0-RC2-SNAPSHOT</version>
+        <version>2.1.0-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
index 38650f739..29815a010 100644
--- a/netty-utils/pom.xml
+++ b/netty-utils/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.1.0-RC2-SNAPSHOT</version>
+		<version>2.1.0-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-netty-utils</artifactId>
diff --git a/pom.xml b/pom.xml
index 113ddbe77..09fe5a23b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="UTF-8"?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
 	<parent>
 		<groupId>org.sonatype.oss</groupId>
@@ -9,7 +8,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.1.0-RC2-SNAPSHOT</version>
+	<version>2.1.0-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -62,6 +61,7 @@
 		</resources>
 		<extensions>
 			<!-- Enabling the use of SSH -->
+
 			<extension>
 				<groupId>org.apache.maven.wagon</groupId>
 				<artifactId>wagon-ssh-external</artifactId>
@@ -151,7 +151,21 @@
 					</execution>
 				</executions>
 			</plugin>
-		</plugins>
+		<plugin>
+                <groupId>edu.illinois</groupId>
+                <artifactId>starts-maven-plugin</artifactId>
+                <version>1.3</version>
+                <executions>
+                    <execution>
+                        <id>starts</id>
+                        <phase>test-compile</phase>
+                        <goals>
+                            <goal>starts</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
 		<pluginManagement>
 			<plugins>
 				<plugin>
@@ -382,19 +396,20 @@
 		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
-		<netty.version>4.1.18.Final</netty.version>
+		<netty.version>4.1.15.Final</netty.version>
 		<slf4j.version>1.7.25</slf4j.version>
-		<reactive-streams.version>1.0.1</reactive-streams.version>
+		<reactive-streams.version>1.0.0</reactive-streams.version>
 		<netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
-		<rxjava.version>1.3.4</rxjava.version>
-		<rxjava2.version>2.1.7</rxjava2.version>
+		<rxjava.version>1.3.0</rxjava.version>
+		<rxjava2.version>2.1.3</rxjava2.version>
 		<logback.version>1.2.3</logback.version>
-		<testng.version>6.13.1</testng.version>
-		<jetty.version>9.4.7.v20170914</jetty.version>
-		<tomcat.version>9.0.2</tomcat.version>
-		<commons-io.version>2.6</commons-io.version>
+		<testng.version>6.11</testng.version>
+		<jetty.version>9.4.6.v20170531</jetty.version>
+		<tomcat.version>8.5.20</tomcat.version>
+		<commons-io.version>2.5</commons-io.version>
 		<commons-fileupload.version>1.3.3</commons-fileupload.version>
 		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
 		<powermock.version>1.6.6</powermock.version>
 	</properties>
 </project>
+
