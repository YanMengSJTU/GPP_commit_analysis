diff --git a/.gitignore b/.gitignore
index 6f4c9fc7f..b02378759 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,6 +15,6 @@ nbproject
 .DS_Store
 target
 test-output
-/META-INF/MANIFEST.MF
+MANIFEST.MF
 work
 atlassian-ide-plugin.xml
diff --git a/README.md b/README.md
index baa828959..96d38b6bb 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ Async Http Client library purpose is to allow Java applications to easily execut
          <dependency>
              <groupId>com.ning</groupId>
              <artifactId>async-http-client</artifactId>
-             <version>1.7.5</version>
+             <version>1.7.8</version>
          </dependency>
 ```
 
@@ -25,7 +25,7 @@ Then in your code you can simply do ([Javadoc](http://sonatype.github.com/async-
     import java.util.concurrent.Future;
 
     AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-    Future<Response> f = asyncHttpClient.prepareGet("http://www.ning.com/ ").execute();
+    Future<Response> f = asyncHttpClient.prepareGet("http://www.ning.com/").execute();
     Response r = f.get();
 ```
 
@@ -38,7 +38,7 @@ You can also accomplish asynchronous (non-blocking) operation without using a Fu
     import java.util.concurrent.Future;
 
     AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-    asyncHttpClient.prepareGet("http://www.ning.com/ ").execute(new AsyncCompletionHandler<Response>(){
+    asyncHttpClient.prepareGet("http://www.ning.com/").execute(new AsyncCompletionHandler<Response>(){
         
         @Override
         public Response onCompleted(Response response) throws Exception{
@@ -63,7 +63,7 @@ You can also mix Future with AsyncHandler to only retrieve part of the asynchron
     import java.util.concurrent.Future;
 
     AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-    Future<Integer> f = asyncHttpClient.prepareGet("http://www.ning.com/ ").execute(
+    Future<Integer> f = asyncHttpClient.prepareGet("http://www.ning.com/").execute(
        new AsyncCompletionHandler<Integer>(){
         
         @Override
@@ -90,7 +90,7 @@ which is something you want to do for large responses: this way you can process
       import java.util.concurrent.Future;
 
       AsyncHttpClient c = new AsyncHttpClient();
-      Future<String> f = c.prepareGet("http://www.ning.com/ ").execute(new AsyncHandler<String>() {
+      Future<String> f = c.prepareGet("http://www.ning.com/").execute(new AsyncHandler<String>() {
           private ByteArrayOutputStream bytes = new ByteArrayOutputStream();
 
           @Override
@@ -114,7 +114,7 @@ which is something you want to do for large responses: this way you can process
           @Override
           public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
                bytes.write(bodyPart.getBodyPartBytes());
-               return STATE.CONTINUE
+               return STATE.CONTINUE;
           }
 
           @Override
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClient.java b/api/src/main/java/com/ning/http/client/AsyncHttpClient.java
index e6d97de16..d4d4e3157 100755
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClient.java
+++ b/api/src/main/java/com/ning/http/client/AsyncHttpClient.java
@@ -523,6 +523,28 @@ public BoundRequestBuilder prepareDelete(String url) {
         return requestBuilder("DELETE", url);
     }
 
+    /**
+     * Prepare an HTTP client PATCH request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public BoundRequestBuilder preparePatch(String url) {
+        return requestBuilder("PATCH", url);
+    }
+
+    /**
+     * Prepare an HTTP client TRACE request.
+     *
+     * @param url A well formed URL.
+     * @return {@link RequestBuilder}
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public BoundRequestBuilder prepareTrace(String url) {
+        return requestBuilder("TRACE", url);
+    }
+
     /**
      * Construct a {@link RequestBuilder} using a {@link Request}
      *
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java b/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
index b3fb5bac1..677b2c4aa 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
+++ b/api/src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
@@ -24,10 +24,13 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
+import java.io.IOException;
+import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Properties;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
@@ -52,6 +55,27 @@
 public class AsyncHttpClientConfig {
 
     protected final static String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
+    public final static String AHC_VERSION;
+
+    static {
+        InputStream is = null;
+        Properties prop = new Properties();
+        try {
+            is = AsyncHttpClientConfig.class.getResourceAsStream("version.properties");
+            prop.load(is);
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (IOException ignored) {
+
+                }
+            }
+        }
+        AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
+    }
 
     protected int maxTotalConnections;
     protected int maxConnectionPerHost;
@@ -84,6 +108,7 @@
     protected HostnameVerifier hostnameVerifier;
     protected int ioThreadMultiplier;
     protected boolean strict302Handling;
+    protected int maxConnectionLifeTimeInMs;
 
     protected AsyncHttpClientConfig() {
     }
@@ -95,6 +120,7 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   int idleConnectionInPoolTimeoutInMs,
                                   int idleConnectionTimeoutInMs,
                                   int requestTimeoutInMs,
+                                  int connectionMaxLifeTimeInMs,
                                   boolean redirectEnabled,
                                   int maxDefaultRedirects,
                                   boolean compressionEnabled,
@@ -126,6 +152,7 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.idleConnectionInPoolTimeoutInMs = idleConnectionInPoolTimeoutInMs;
         this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
         this.requestTimeoutInMs = requestTimeoutInMs;
+        this.maxConnectionLifeTimeInMs = connectionMaxLifeTimeInMs;
         this.redirectEnabled = redirectEnabled;
         this.maxDefaultRedirects = maxDefaultRedirects;
         this.compressionEnabled = compressionEnabled;
@@ -476,6 +503,15 @@ public boolean isStrict302Handling() {
         return strict302Handling;
     }
 
+    /**
+     * Return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     *
+     * @return the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     */
+    public int getMaxConnectionLifeTimeInMs() {
+        return maxConnectionLifeTimeInMs;
+    }
+
     /**
      * Builder for an {@link AsyncHttpClient}
      */
@@ -487,10 +523,11 @@ public boolean isStrict302Handling() {
         private int defaultIdleConnectionInPoolTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionInPoolTimeoutInMS", 60 * 1000);
         private int defaultIdleConnectionTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultIdleConnectionTimeoutInMS", 60 * 1000);
         private int defaultRequestTimeoutInMs = Integer.getInteger(ASYNC_CLIENT + "defaultRequestTimeoutInMS", 60 * 1000);
+        private int defaultMaxConnectionLifeTimeInMs = Integer.getInteger(ASYNC_CLIENT + "defaultMaxConnectionLifeTimeInMs", -1);
         private boolean redirectEnabled = Boolean.getBoolean(ASYNC_CLIENT + "defaultRedirectsEnabled");
         private int maxDefaultRedirects = Integer.getInteger(ASYNC_CLIENT + "defaultMaxRedirects", 5);
         private boolean compressionEnabled = Boolean.getBoolean(ASYNC_CLIENT + "compressionEnabled");
-        private String userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "NING/1.0");
+        private String userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "AsyncHttpClient/" + AHC_VERSION);
         private boolean useProxyProperties = Boolean.getBoolean(ASYNC_CLIENT + "useProxyProperties");
         private boolean allowPoolingConnection = true;
         private ScheduledExecutorService reaper = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
@@ -867,9 +904,9 @@ public Builder setRequestCompressionLevel(int requestCompressionLevel) {
         }
 
         /**
-         * Set the number of time a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
+         * Set the number of times a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
          *
-         * @param maxRequestRetry the number of time a request will be retried
+         * @param maxRequestRetry the number of times a request will be retried
          * @return this
          */
         public Builder setMaxRequestRetry(int maxRequestRetry) {
@@ -956,6 +993,17 @@ public Builder setStrict302Handling(final boolean strict302Handling) {
             return this;
         }
 
+        /**
+         * Set the maximum time in millisecond connection can be added to the pool for further reuse
+         *
+         * @param maxConnectionLifeTimeInMs the maximum time in millisecond connection can be added to the pool for further reuse
+         * @return a {@link Builder}
+         */
+        public Builder setMaxConnectionLifeTimeInMs(int maxConnectionLifeTimeInMs) {
+           this.defaultMaxConnectionLifeTimeInMs = maxConnectionLifeTimeInMs;
+           return this;
+        }
+
         /**
          * Create a config builder with values taken from the given prototype configuration.
          *
@@ -969,6 +1017,7 @@ public Builder(AsyncHttpClientConfig prototype) {
             defaultIdleConnectionInPoolTimeoutInMs = prototype.getIdleConnectionInPoolTimeoutInMs();
             defaultIdleConnectionTimeoutInMs = prototype.getIdleConnectionTimeoutInMs();
             defaultMaxConnectionPerHost = prototype.getMaxConnectionPerHost();
+            defaultMaxConnectionLifeTimeInMs = prototype.getMaxConnectionLifeTimeInMs();
             maxDefaultRedirects = prototype.getMaxRedirects();
             defaultMaxTotalConnections = prototype.getMaxTotalConnections();
             proxyServer = prototype.getProxyServer();
@@ -1022,6 +1071,7 @@ public AsyncHttpClientConfig build() {
                     defaultIdleConnectionInPoolTimeoutInMs,
                     defaultIdleConnectionTimeoutInMs,
                     defaultRequestTimeoutInMs,
+                    defaultMaxConnectionLifeTimeInMs,
                     redirectEnabled,
                     maxDefaultRedirects,
                     compressionEnabled,
diff --git a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java b/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
index 0924d4d76..0aaf12361 100644
--- a/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
+++ b/api/src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
@@ -53,7 +53,7 @@ void configureDefaults() {
         redirectEnabled = Boolean.getBoolean(ASYNC_CLIENT + "defaultRedirectsEnabled");
         maxDefaultRedirects = Integer.getInteger(ASYNC_CLIENT + "defaultMaxRedirects", 5);
         compressionEnabled = Boolean.getBoolean(ASYNC_CLIENT + "compressionEnabled");
-        userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "NING/1.0");
+        userAgent = System.getProperty(ASYNC_CLIENT + "userAgent", "AsyncHttpClient/" + AHC_VERSION);
 
         boolean useProxyProperties = Boolean.getBoolean(ASYNC_CLIENT + "useProxyProperties");
         if (useProxyProperties) {
diff --git a/api/src/main/java/com/ning/http/client/RequestBuilderBase.java b/api/src/main/java/com/ning/http/client/RequestBuilderBase.java
index 9cc5ec40e..85b88e538 100644
--- a/api/src/main/java/com/ning/http/client/RequestBuilderBase.java
+++ b/api/src/main/java/com/ning/http/client/RequestBuilderBase.java
@@ -75,8 +75,9 @@ public RequestImpl(boolean useRawUrl) {
         public RequestImpl(Request prototype) {
             if (prototype != null) {
                 this.method = prototype.getMethod();
-                int pos = prototype.getUrl().indexOf("?");
-                this.url = pos > 0 ? prototype.getUrl().substring(0, pos) : prototype.getUrl();
+                String prototypeUrl = prototype.getUrl();
+                int pos = prototypeUrl.indexOf("?");
+                this.url = pos > 0 ? prototypeUrl.substring(0, pos) : prototypeUrl;
                 this.address = prototype.getInetAddress();
                 this.localAddress = prototype.getLocalAddress();
                 this.headers = new FluentCaseInsensitiveStringsMap(prototype.getHeaders());
@@ -292,11 +293,23 @@ public String toString() {
 
             sb.append("\t");
             sb.append(method);
-            for (String name : headers.keySet()) {
-                sb.append("\t");
-                sb.append(name);
-                sb.append(":");
-                sb.append(headers.getJoinedValue(name, ", "));
+            sb.append("\theaders:");
+            if (headers != null) {
+                for (String name : headers.keySet()) {
+                    sb.append("\t");
+                    sb.append(name);
+                    sb.append(":");
+                    sb.append(headers.getJoinedValue(name, ", "));
+                }
+            }
+            sb.append("\tparams:");
+            if (params != null) {
+                for (String name : params.keySet()) {
+                    sb.append("\t");
+                    sb.append(name);
+                    sb.append(":");
+                    sb.append(params.getJoinedValue(name, ", "));
+                }
             }
 
             return sb.toString();
@@ -446,8 +459,8 @@ private void resetMultipartData() {
     }
 
     private void checkIfBodyAllowed() {
-        if ("GET".equals(request.method) || "HEAD".equals(request.method)) {
-            throw new IllegalArgumentException("Can NOT set Body on HTTP Request Method GET nor HEAD.");
+        if ("HEAD".equals(request.method)) {
+            throw new IllegalArgumentException("Can NOT set Body on HTTP Request Method HEAD.");
         }
     }
 
diff --git a/api/src/main/java/com/ning/http/client/providers/ResponseBase.java b/api/src/main/java/com/ning/http/client/providers/ResponseBase.java
index 713c6a0a6..1f98acf53 100644
--- a/api/src/main/java/com/ning/http/client/providers/ResponseBase.java
+++ b/api/src/main/java/com/ning/http/client/providers/ResponseBase.java
@@ -3,8 +3,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
+import java.util.Collections;
 import java.util.List;
 
+import com.ning.http.client.Cookie;
 import com.ning.http.client.FluentCaseInsensitiveStringsMap;
 import com.ning.http.client.HttpResponseBodyPart;
 import com.ning.http.client.HttpResponseHeaders;
@@ -15,11 +17,11 @@
 public abstract class ResponseBase implements Response
 {
     protected final static String DEFAULT_CHARSET = "ISO-8859-1";
-    protected final static String HEADERS_NOT_COMPUTED = "Response's headers hasn't been computed by your AsyncHandler.";
 
     protected final List<HttpResponseBodyPart> bodyParts;
     protected final HttpResponseHeaders headers;
     protected final HttpResponseStatus status;
+    private List<Cookie> cookies;
 
     protected ResponseBase(HttpResponseStatus status,
             HttpResponseHeaders headers,
@@ -48,25 +50,22 @@ public final URI getUri() /*throws MalformedURLException*/ {
 
     /* @Override */
     public final String getContentType() {
-        return getHeader("Content-Type");
+        return headers != null? getHeader("Content-Type"): null;
     }
 
     /* @Override */
     public final String getHeader(String name) {
-        return getHeaders().getFirstValue(name);
+        return headers != null? getHeaders().getFirstValue(name): null;
     }
 
     /* @Override */
     public final List<String> getHeaders(String name) {
-        return getHeaders().get(name);
+        return headers != null? getHeaders().get(name): null;
     }
 
     /* @Override */
     public final FluentCaseInsensitiveStringsMap getHeaders() {
-        if (headers == null) {
-            throw new IllegalStateException(HEADERS_NOT_COMPUTED);
-        }
-        return headers.getHeaders();
+        return headers != null? headers.getHeaders(): new FluentCaseInsensitiveStringsMap();
     }
 
     /* @Override */
@@ -85,34 +84,48 @@ public String getResponseBody() throws IOException {
     }
 
     public String getResponseBody(String charset) throws IOException {
-        String contentType = getContentType();
-        if (contentType != null && charset == null) {
-            charset = AsyncHttpProviderUtils.parseCharset(contentType);
-        }
-
-        if (charset == null) {
-            charset = DEFAULT_CHARSET;
-        }
-
-        return AsyncHttpProviderUtils.contentToString(bodyParts, charset);
+        return AsyncHttpProviderUtils.contentToString(bodyParts, calculateCharset(charset));
     }
 
     /* @Override */
     public InputStream getResponseBodyAsStream() throws IOException {
         return AsyncHttpProviderUtils.contentAsStream(bodyParts);
     }
+    
+    protected abstract List<Cookie> buildCookies();
+    
+    public List<Cookie> getCookies() {
 
-    protected String calculateCharset() {
-        String charset = null;
-        String contentType = getContentType();
-        if (contentType != null) {
-            charset = AsyncHttpProviderUtils.parseCharset(contentType);
+        if (headers == null) {
+            return Collections.emptyList();
         }
 
+        if (cookies == null) {
+            cookies = buildCookies();
+        }
+        return cookies;
+
+    }
+
+    protected String calculateCharset(String charset) {
+        
         if (charset == null) {
-            charset = DEFAULT_CHARSET;
+        	String contentType = getContentType();
+        	if (contentType != null)
+        		charset = AsyncHttpProviderUtils.parseCharset(contentType); // parseCharset can return null
         }
-        return charset;
+        return charset != null? charset: DEFAULT_CHARSET;
     }
 
+    public boolean hasResponseStatus() {
+        return status != null;
+    }
+
+    public boolean hasResponseHeaders() {
+        return headers != null && !headers.getHeaders().isEmpty();
+    }
+
+    public boolean hasResponseBody() {
+        return bodyParts != null && !bodyParts.isEmpty();
+    }
 }
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java b/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
index e27375749..6bd46a78f 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
+++ b/api/src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
@@ -547,7 +547,9 @@ private void configure(URI uri, HttpURLConnection urlConnection, Request request
             } else if (config.getUserAgent() != null) {
                 urlConnection.setRequestProperty("User-Agent", config.getUserAgent());
             } else {
-                urlConnection.setRequestProperty("User-Agent", AsyncHttpProviderUtils.constructUserAgent(JDKAsyncHttpProvider.class));
+                urlConnection.setRequestProperty("User-Agent",
+                        AsyncHttpProviderUtils.constructUserAgent(JDKAsyncHttpProvider.class,
+                                                                  config));
             }
 
             if (request.getCookies() != null && !request.getCookies().isEmpty()) {
diff --git a/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java b/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java
index 3475b6184..56bc330e5 100644
--- a/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java
+++ b/api/src/main/java/com/ning/http/client/providers/jdk/JDKResponse.java
@@ -13,7 +13,6 @@
 package com.ning.http.client.providers.jdk;
 
 import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
 import com.ning.http.client.HttpResponseBodyPart;
 import com.ning.http.client.HttpResponseHeaders;
 import com.ning.http.client.HttpResponseStatus;
@@ -27,7 +26,6 @@
 import java.util.Map;
 
 public class JDKResponse extends ResponseBase {
-    private final List<Cookie> cookies = new ArrayList<Cookie>();
 
     public JDKResponse(HttpResponseStatus status,
                        HttpResponseHeaders headers,
@@ -48,46 +46,18 @@ public String getResponseBodyExcerpt(int maxLength, String charset) throws IOExc
     }
 
     /* @Override */
-    public List<Cookie> getCookies() {
-        if (headers == null) {
-            throw new IllegalStateException(HEADERS_NOT_COMPUTED);
-        }
-        if (cookies.isEmpty()) {
-            for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-                if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                    // TODO: ask for parsed header
-                    List<String> v = header.getValue();
-                    for (String value : v) {
-                        Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                        cookies.add(cookie);
-                    }
+    public List<Cookie> buildCookies() {
+    	List<Cookie> cookies = new ArrayList<Cookie>();
+        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
+                // TODO: ask for parsed header
+                List<String> v = header.getValue();
+                for (String value : v) {
+                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
+                    cookies.add(cookie);
                 }
             }
         }
         return Collections.unmodifiableList(cookies);
     }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseStatus() {
-        return (bodyParts != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseHeaders() {
-        return (headers != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseBody() {
-        return (bodyParts != null && bodyParts.size() > 0 ? true : false);
-    }
 }
diff --git a/api/src/main/java/com/ning/http/client/version.properties b/api/src/main/java/com/ning/http/client/version.properties
new file mode 100644
index 000000000..242abfd90
--- /dev/null
+++ b/api/src/main/java/com/ning/http/client/version.properties
@@ -0,0 +1 @@
+ahc.version=${pom.version}
\ No newline at end of file
diff --git a/api/src/main/java/com/ning/http/multipart/MultipartBody.java b/api/src/main/java/com/ning/http/multipart/MultipartBody.java
index 88ee5da2e..fe97ed8c1 100644
--- a/api/src/main/java/com/ning/http/multipart/MultipartBody.java
+++ b/api/src/main/java/com/ning/http/multipart/MultipartBody.java
@@ -25,10 +25,10 @@
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
+import java.nio.channels.*;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 public class MultipartBody implements RandomAccessBody {
 
@@ -435,11 +435,11 @@ private ByteArrayOutputStream generateFileStart(FilePart filePart)
     }
 
     private long handleFilePart(WritableByteChannel target, FilePart filePart) throws IOException {
-    	FilePartStallHandler handler = new FilePartStallHandler(
-    		filePart.getStalledTime(), filePart);
-    	
-    	handler.start();
-    	
+        FilePartStallHandler handler = new FilePartStallHandler(
+                filePart.getStalledTime(), filePart);
+
+        handler.start();
+
         if (FilePartSource.class.isAssignableFrom(filePart.getSource().getClass())) {
             int length = 0;
 
@@ -458,13 +458,13 @@ private long handleFilePart(WritableByteChannel target, FilePart filePart) throw
             long nWrite = 0;
             synchronized (fc) {
                 while (fileLength != l) {
-                	if(handler.isFailed()) {
-                		logger.debug("Stalled error");
+                    if (handler.isFailed()) {
+                        logger.debug("Stalled error");
                         throw new FileUploadStalledException();
-                	}
+                    }
                     try {
                         nWrite = fc.transferTo(fileLength, l, target);
-                       
+
                         if (nWrite == 0) {
                             logger.info("Waiting for writing...");
                             try {
@@ -472,9 +472,8 @@ private long handleFilePart(WritableByteChannel target, FilePart filePart) throw
                             } catch (InterruptedException e) {
                                 logger.trace(e.getMessage(), e);
                             }
-                        }
-                        else {
-                        	handler.writeHappened();
+                        } else {
+                            handler.writeHappened();
                         }
                     } catch (IOException ex) {
                         String message = ex.getMessage();
@@ -496,7 +495,7 @@ private long handleFilePart(WritableByteChannel target, FilePart filePart) throw
                 }
             }
             handler.completed();
-            
+
             fc.close();
 
             length += handleFileEnd(target, filePart);
@@ -556,7 +555,7 @@ private long handleMultiPart(WritableByteChannel target, Part currentPart) throw
             return handleStringPart(target, (StringPart) currentPart);
         } else if (currentPart.getClass().equals(FilePart.class)) {
             FilePart filePart = (FilePart) currentPart;
-            
+
             return handleFilePart(target, filePart);
         }
         return 0;
@@ -569,21 +568,46 @@ private long writeToTarget(WritableByteChannel target, ByteArrayOutputStream byt
         int maxSpin = 0;
         synchronized (byteWriter) {
             ByteBuffer message = ByteBuffer.wrap(byteWriter.toByteArray());
-            while ((target.isOpen()) && (written < byteWriter.size())) {
-                long nWrite = target.write(message);
-                written += nWrite;
-                if (nWrite == 0 && maxSpin++ < 10) {
-                    logger.info("Waiting for writing...");
-                    try {
-                        byteWriter.wait(1000);
-                    } catch (InterruptedException e) {
-                        logger.trace(e.getMessage(), e);
+
+            if (target instanceof SocketChannel) {
+                final Selector selector = Selector.open();
+                try {
+                    final SocketChannel channel = (SocketChannel) target;
+                    channel.register(selector, SelectionKey.OP_WRITE);
+
+                    while (written < byteWriter.size() && selector.select() != 0) {
+                        final Set<SelectionKey> selectedKeys = selector.selectedKeys();
+
+                        for (SelectionKey key : selectedKeys) {
+                            if (key.isWritable()) {
+                                written += target.write(message);
+                            }
+                        }
                     }
-                } else {
-                    if (maxSpin >= 10) {
+
+                    if (written < byteWriter.size()) {
                         throw new IOException("Unable to write on channel " + target);
                     }
-                    maxSpin = 0;
+                } finally {
+                    selector.close();
+                }
+            } else {
+                while ((target.isOpen()) && (written < byteWriter.size())) {
+                    long nWrite = target.write(message);
+                    written += nWrite;
+                    if (nWrite == 0 && maxSpin++ < 10) {
+                        logger.info("Waiting for writing...");
+                        try {
+                            byteWriter.wait(1000);
+                        } catch (InterruptedException e) {
+                            logger.trace(e.getMessage(), e);
+                        }
+                    } else {
+                        if (maxSpin >= 10) {
+                            throw new IOException("Unable to write on channel " + target);
+                        }
+                        maxSpin = 0;
+                    }
                 }
             }
         }
diff --git a/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java b/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
index 538c63da2..6d417cf93 100644
--- a/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
+++ b/api/src/main/java/com/ning/http/util/AsyncHttpProviderUtils.java
@@ -12,6 +12,7 @@
  */
 package com.ning.http.util;
 
+import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.AsyncHttpProvider;
 import com.ning.http.client.ByteArrayPart;
 import com.ning.http.client.Cookie;
@@ -466,10 +467,11 @@ private static void add(StringBuilder sb, String name, int val) {
         sb.append((char) SEMICOLON);
     }
 
-    public static String constructUserAgent(Class<? extends AsyncHttpProvider> httpProvider) {
-        StringBuffer b = new StringBuffer("AsyncHttpClient/1.0")
-                .append(" ")
-                .append("(")
+    public static String constructUserAgent(Class<? extends AsyncHttpProvider> httpProvider,
+                                            AsyncHttpClientConfig config) {
+        return new StringBuffer(config.getUserAgent())
+                .append(' ')
+                .append('(')
                 .append(httpProvider.getSimpleName())
                 .append(" - ")
                 .append(System.getProperty("os.name"))
@@ -479,8 +481,7 @@ public static String constructUserAgent(Class<? extends AsyncHttpProvider> httpP
                 .append(System.getProperty("java.version"))
                 .append(" - ")
                 .append(Runtime.getRuntime().availableProcessors())
-                .append(" core(s))");
-        return b.toString();
+                .append(" core(s))").toString();
     }
 
     public static String parseCharset(String contentType) {
@@ -504,7 +505,7 @@ public static String parseCharset(String contentType) {
 
     public static Cookie parseCookie(String value) {
         String[] fields = value.split(";\\s*");
-        String[] cookie = fields[0].split("=");
+        String[] cookie = fields[0].split("=", 2);
         String cookieName = cookie[0];
         String cookieValue = (cookie.length == 1) ? null : cookie[1];
 
@@ -556,12 +557,14 @@ public static Cookie parseCookie(String value) {
         return new Cookie(domain, cookieName, cookieValue, path, maxAge, secure);
     }
 
-    private static int convertExpireField(String timestring) throws Exception {
+    public static int convertExpireField(String timestring) throws Exception {
         Exception exception = null;
+        String trimmedTimeString = removeQuote(timestring.trim());
+        long now = System.currentTimeMillis();
         for (SimpleDateFormat sdf : simpleDateFormat.get()) {
             try {
-                long expire = sdf.parse(removeQuote(timestring.trim())).getTime();
-                return (int) ((expire - System.currentTimeMillis()) / 1000);
+                long expire = sdf.parse(trimmedTimeString).getTime();
+                return (int) ((expire - now) / 1000);
             } catch (ParseException e) {
                 exception = e;
             } catch (NumberFormatException e) {
diff --git a/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java b/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
index d909314e3..512153b28 100644
--- a/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
+++ b/api/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
@@ -29,6 +29,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
@@ -475,13 +476,20 @@ public Integer onCompleted() throws Exception {
     public void asyncOptionsTest() throws Throwable {
         final CountDownLatch l = new CountDownLatch(1);
         AsyncHttpClient c = getAsyncHttpClient(null);
+        final String[] expected = {
+            "GET","HEAD","OPTIONS","POST","TRACE"
+        };
         c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
             @Override
             public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
                 FluentCaseInsensitiveStringsMap h = content.getHeaders();
                 Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("Allow", ", "), "GET,HEAD,POST,OPTIONS,TRACE");
+                String[] values = h.get("Allow").get(0).split(",|, ");
+                Assert.assertNotNull(values);
+                Assert.assertEquals(values.length, expected.length);
+                Arrays.sort(values);
+                Assert.assertEquals(values, expected);
                 return STATE.ABORT;
             }
 
diff --git a/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java b/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java
index c0bb1f269..a207828ce 100644
--- a/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java
+++ b/api/src/test/java/com/ning/http/client/async/ProxyTunnellingTest.java
@@ -111,7 +111,7 @@ public Response onCompleted(Response response) throws Exception {
         });
         Response r = responseFuture.get();
         assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("server"), "Jetty(8.1.1.v20120215)");
+        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
 
         asyncHttpClient.close();
     }
@@ -142,7 +142,7 @@ public Response onCompleted(Response response) throws Exception {
         });
         Response r = responseFuture.get();
         assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("server"), "Jetty(8.1.1.v20120215)");
+        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
 
         asyncHttpClient.close();
     }
@@ -161,7 +161,7 @@ public void testSimpleAHCConfigProxy() throws IOException, InterruptedException,
         Response r = client.get().get();
 
         assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("server"), "Jetty(8.1.1.v20120215)");
+        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
 
         client.close();
     }
diff --git a/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java b/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java
new file mode 100644
index 000000000..e2bab0876
--- /dev/null
+++ b/api/src/test/java/com/ning/http/util/TestAsyncHttpProviderUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.util;
+
+import com.ning.http.client.Cookie;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class TestAsyncHttpProviderUtils
+{
+    @Test(groups="fast")
+    public void testCookieParsing()
+    {
+        String cookieValue = "ID=a3be7f468f2a528c:FF=0:TM=1397369269:LM=134759269:S=XZQK3o8HJ1mytzgz";
+        String testCookie = "PREF=" + cookieValue + "; expires=Thu, 11-Sep-2013 13:14:29 GMT; path=/; domain=.google.co.uk";
+        Cookie cookie = AsyncHttpProviderUtils.parseCookie(testCookie);
+        
+        Assert.assertEquals(cookie.getValue(), cookieValue);
+    }
+}
diff --git a/pom.xml b/pom.xml
index f37e330d9..c475b6ec2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -18,13 +18,13 @@
         applications to easily execute HTTP requests and
         asynchronously process the response.
     </description>
-    <url>http://github.com/sonatype/async-http-client</url>
+    <url>http://github.com/AsyncHttpClient/async-http-client</url>
     <scm>
-        <connection>scm:git:git@github.com:sonatype/async-http-client.git
+        <connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git
         </connection>
-        <url>https://github.com/sonatype/async-http-client</url>
+        <url>https://github.com/AsyncHttpClient/async-http-client</url>
         <developerConnection>
-            scm:git:git@github.com:sonatype/async-http-client.git
+            scm:git:git@github.com:AsyncHttpClient/async-http-client.git
         </developerConnection>
     </scm>
     <issueManagement>
@@ -89,6 +89,15 @@
         </license>
     </licenses>
     <build>
+        <resources>
+            <resource>
+                <filtering>true</filtering>
+                <directory>src/main/java/</directory>
+                <excludes>
+                    <exclude>**/*.java</exclude>
+                </excludes>
+            </resource>
+        </resources>
         <extensions>
             <!-- Enabling the use of SSH -->
             <extension>
@@ -571,8 +580,8 @@
         </distMgmtSnapshotsUrl>
         <surefire.redirectTestOutputToFile>true
         </surefire.redirectTestOutputToFile>
-        <source.property>1.5</source.property>
-        <target.property>1.5</target.property>
+        <source.property>1.6</source.property>
+        <target.property>1.6</target.property>
         <surefire.version>2.12</surefire.version>
     </properties>
 </project>
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java
index 399f3f256..2c11ab379 100644
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java
+++ b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheAsyncHttpProvider.java
@@ -377,7 +377,7 @@ private HttpMethodBase createMethod(HttpClient client, Request request) throws I
         } else if (config.getUserAgent() != null) {
             method.setRequestHeader("User-Agent", config.getUserAgent());
         } else {
-            method.setRequestHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(ApacheAsyncHttpProvider.class));
+            method.setRequestHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(ApacheAsyncHttpProvider.class, config));
         }
 
         if (config.isCompressionEnabled()) {
diff --git a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java
index 2589cbfff..43059dee7 100644
--- a/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java
+++ b/providers/apache/src/main/java/com/ning/http/client/providers/apache/ApacheResponse.java
@@ -26,11 +26,8 @@
 import java.util.Map;
 
 public class ApacheResponse extends ResponseBase {
-    private final static String HEADERS_NOT_COMPUTED = "Response's headers hasn't been computed by your AsyncHandler.";
 
-    private final List<Cookie> cookies = new ArrayList<Cookie>();
-
-    public ApacheResponse(HttpResponseStatus status,
+	public ApacheResponse(HttpResponseStatus status,
                           HttpResponseHeaders headers,
                           List<HttpResponseBodyPart> bodyParts) {
         super(status, headers, bodyParts);
@@ -45,60 +42,24 @@ public String getResponseBodyExcerpt(int maxLength) throws IOException {
     /* @Override */
 
     public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        String contentType = getContentType();
-        if (contentType != null && charset == null) {
-            charset = AsyncHttpProviderUtils.parseCharset(contentType);
-        }
-
-        if (charset == null) {
-            charset = DEFAULT_CHARSET;
-        }
-
+        charset = calculateCharset(charset);
         String response = AsyncHttpProviderUtils.contentToString(bodyParts, charset);
         return response.length() <= maxLength ? response : response.substring(0, maxLength);
     }
 
     /* @Override */
-    public List<Cookie> getCookies() {
-        if (headers == null) {
-            throw new IllegalStateException(HEADERS_NOT_COMPUTED);
-        }
-        if (cookies.isEmpty()) {
-            for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-                if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                    // TODO: ask for parsed header
-                    List<String> v = header.getValue();
-                    for (String value : v) {
-                        Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                        cookies.add(cookie);
-                    }
+    public List<Cookie> buildCookies() {
+    	List<Cookie> cookies = new ArrayList<Cookie>();
+        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
+                // TODO: ask for parsed header
+                List<String> v = header.getValue();
+                for (String value : v) {
+                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
+                    cookies.add(cookie);
                 }
             }
         }
         return Collections.unmodifiableList(cookies);
     }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseStatus() {
-        return (bodyParts != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseHeaders() {
-        return (headers != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseBody() {
-        return (bodyParts != null && bodyParts.size() > 0 ? true : false);
-    }
 }
diff --git a/providers/grizzly/pom.xml b/providers/grizzly/pom.xml
index 6929b9653..b46943723 100644
--- a/providers/grizzly/pom.xml
+++ b/providers/grizzly/pom.xml
@@ -20,7 +20,7 @@
         <dependency>
             <groupId>org.glassfish.grizzly</groupId>
             <artifactId>grizzly-websockets</artifactId>
-            <version>2.2.10</version>
+            <version>2.3-beta8</version>
         </dependency>
         <dependency>
                    <groupId>com.ning</groupId>
@@ -44,4 +44,4 @@
         </repository>
     </repositories>
 
-</project>
\ No newline at end of file
+</project>
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
index 4c659daf7..caa6629bc 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -101,6 +101,7 @@
 import org.glassfish.grizzly.websockets.DataFrame;
 import org.glassfish.grizzly.websockets.DefaultWebSocket;
 import org.glassfish.grizzly.websockets.HandShake;
+import org.glassfish.grizzly.websockets.HandshakeException;
 import org.glassfish.grizzly.websockets.ProtocolHandler;
 import org.glassfish.grizzly.websockets.Version;
 import org.glassfish.grizzly.websockets.WebSocketEngine;
@@ -134,6 +135,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
 import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
 
 /**
@@ -148,7 +150,7 @@
     private final static Logger LOGGER = LoggerFactory.getLogger(GrizzlyAsyncHttpProvider.class);
     private static final boolean SEND_FILE_SUPPORT;
     static {
-        SEND_FILE_SUPPORT = configSendFileSupport();
+        SEND_FILE_SUPPORT = /*configSendFileSupport();*/ false;
     }
     private final Attribute<HttpTransactionContext> REQUEST_STATE_ATTR =
             Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(HttpTransactionContext.class.getName());
@@ -318,6 +320,9 @@ protected void initializeTransport(final AsyncHttpClientConfig clientConfig) {
             int delay = 500;
             if (timeout < delay) {
                 delay = timeout - 10;
+                if (delay <= 0) {
+                    delay = timeout;
+                }
             }
             timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
             timeoutExecutor.start();
@@ -369,8 +374,14 @@ public void onTimeout(Connection connection) {
                         false);
         final SwitchingSSLFilter filter = new SwitchingSSLFilter(configurator, defaultSecState);
         fcb.add(filter);
-        final AsyncHttpClientEventFilter eventFilter = new
-                AsyncHttpClientEventFilter(this);
+        GrizzlyAsyncHttpProviderConfig providerConfig =
+                        (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
+        final AsyncHttpClientEventFilter eventFilter;
+        if (providerConfig != null) {
+            eventFilter = new AsyncHttpClientEventFilter(this, (Integer) providerConfig.getProperty(MAX_HTTP_PACKET_HEADER_SIZE));
+        } else {
+            eventFilter = new AsyncHttpClientEventFilter(this);
+        }
         final AsyncHttpClientFilter clientFilter =
                 new AsyncHttpClientFilter(clientConfig);
         ContentEncoding[] encodings = eventFilter.getContentEncodings();
@@ -388,8 +399,6 @@ public void onTimeout(Connection connection) {
         fcb.add(eventFilter);
         fcb.add(clientFilter);
         
-        GrizzlyAsyncHttpProviderConfig providerConfig =
-                (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
         if (providerConfig != null) {
             final TransportCustomizer customizer = (TransportCustomizer)
                     providerConfig.getProperty(TRANSPORT_CUSTOMIZER);
@@ -616,6 +625,7 @@ boolean handleStatus(final HttpResponsePacket httpResponse,
         HandShake handshake;
         ProtocolHandler protocolHandler;
         WebSocket webSocket;
+        boolean establishingTunnel;
 
 
         // -------------------------------------------------------- Constructors
@@ -674,6 +684,15 @@ void result(Object result) {
             }
         }
 
+        boolean isTunnelEstablished(final Connection c) {
+            return c.getAttributes().getAttribute("tunnel-established") != null;
+        }
+
+
+        void tunnelEstablished(final Connection c) {
+            c.getAttributes().setAttribute("tunnel-established", Boolean.TRUE);
+        }
+
 
     } // END HttpTransactionContext
 
@@ -825,7 +844,8 @@ private boolean sendAsGrizzlyRequest(final Request request,
             }
             final URI uri = AsyncHttpProviderUtils.createUri(httpCtx.requestUrl);
             final HttpRequestPacket.Builder builder = HttpRequestPacket.builder();
-            boolean secure = "https".equals(uri.getScheme());
+            final String scheme = uri.getScheme();
+            boolean secure = "https".equals(scheme) || "wss".equals(scheme);
             builder.method(request.getMethod());
             builder.protocol(Protocol.HTTP_1_1);
             String host = request.getVirtualHost();
@@ -841,7 +861,10 @@ private boolean sendAsGrizzlyRequest(final Request request,
             final ProxyServer proxy = getProxyServer(request);
             final boolean useProxy = (proxy != null);
             if (useProxy) {
-                if (secure) {
+                if ((secure || httpCtx.isWSRequest) && !httpCtx.isTunnelEstablished(ctx.getConnection())) {
+                    ctx.notifyDownstream(new SwitchingSSLFilter.SSLSwitchingEvent(false, ctx.getConnection()));
+                    secure = false;
+                    httpCtx.establishingTunnel = true;
                     builder.method(Method.CONNECT);
                     builder.uri(AsyncHttpProviderUtils.getAuthority(uri));
                 } else {
@@ -861,7 +884,7 @@ private boolean sendAsGrizzlyRequest(final Request request,
             }
 
             HttpRequestPacket requestPacket;
-            if (httpCtx.isWSRequest) {
+            if (httpCtx.isWSRequest && !httpCtx.establishingTunnel) {
                 try {
                     final URI wsURI = new URI(httpCtx.wsRequestURI);
                     httpCtx.protocolHandler = Version.DRAFT17.createHandler(true);
@@ -874,7 +897,10 @@ private boolean sendAsGrizzlyRequest(final Request request,
             } else {
                 requestPacket = builder.build();
             }
-            requestPacket.setSecure(true);
+            requestPacket.setSecure(secure);
+            if (secure) {
+                ctx.notifyDownstream(new SwitchingSSLFilter.SSLSwitchingEvent(true, ctx.getConnection()));
+            }
             if (!useProxy && !httpCtx.isWSRequest) {
                 addQueryString(request, requestPacket);
             }
@@ -906,7 +932,6 @@ private boolean sendAsGrizzlyRequest(final Request request,
 
         }
 
-
         private boolean isUpgradeRequest(final AsyncHandler handler) {
             return (handler instanceof UpgradeHandler);
         }
@@ -1055,7 +1080,14 @@ private void addQueryString(final Request request,
 
 
         AsyncHttpClientEventFilter(final GrizzlyAsyncHttpProvider provider) {
+            this(provider, DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
+        }
 
+
+        AsyncHttpClientEventFilter(final GrizzlyAsyncHttpProvider provider,
+                                   final int maxHeaderSize) {
+
+            super(maxHeaderSize);
             this.provider = provider;
             HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(),
                             AuthorizationHandler.INSTANCE);
@@ -1136,14 +1168,19 @@ protected void onInitialLineParsed(HttpHeader httpHeader,
             if (httpHeader.isSkipRemainder()) {
                 return;
             }
+            final Connection connection = ctx.getConnection();
             final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(ctx.getConnection());
+                    provider.getHttpTransactionContext(connection);
             final int status = ((HttpResponsePacket) httpHeader).getStatus();
+            if (context.establishingTunnel && HttpStatus.OK_200.statusMatches(status)) {
+                return;
+            }
             if (HttpStatus.CONINTUE_100.statusMatches(status)) {
                 ctx.notifyUpstream(new ContinueEvent(context));
                 return;
             }
 
+
             if (context.statusHandler != null && !context.statusHandler.handlesStatus(status)) {
                 context.statusHandler = null;
                 context.invocationStatus = StatusHandler.InvocationStatus.CONTINUE;
@@ -1190,6 +1227,10 @@ protected void onInitialLineParsed(HttpHeader httpHeader,
                     final AsyncHandler handler = context.handler;
                     if (handler != null) {
                         context.currentState = handler.onStatusReceived(responseStatus);
+                        if (context.isWSRequest && context.currentState == AsyncHandler.STATE.ABORT) {
+                            httpHeader.setSkipRemainder(true);
+                            context.abort(new HandshakeException("Upgrade failed"));
+                        }
                     }
                 } catch (Exception e) {
                     httpHeader.setSkipRemainder(true);
@@ -1224,11 +1265,12 @@ protected void onHttpHeadersParsed(HttpHeader httpHeader,
                     ConnectionManager.markConnectionAsDoNotCache(ctx.getConnection());
                 }
             }
-            if (httpHeader.isSkipRemainder()) {
+            final HttpTransactionContext context =
+                                provider.getHttpTransactionContext(ctx.getConnection());
+            if (httpHeader.isSkipRemainder() || context.establishingTunnel) {
                 return;
             }
-            final HttpTransactionContext context =
-                    provider.getHttpTransactionContext(ctx.getConnection());
+
             final AsyncHandler handler = context.handler;
             final List<ResponseFilter> filters = context.provider.clientConfig.getResponseFilters();
             final GrizzlyResponseHeaders responseHeaders = new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader,
@@ -1328,6 +1370,7 @@ protected void onHttpHeadersParsed(HttpHeader httpHeader,
 
         }
 
+        @SuppressWarnings("unchecked")
         @Override
         protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
 
@@ -1340,20 +1383,38 @@ protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext c
 
             result = super.onHttpPacketParsed(httpHeader, ctx);
 
-            final HttpTransactionContext context = cleanup(ctx, provider);
-
-            final AsyncHandler handler = context.handler;
-            if (handler != null) {
+            final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
+            if (context.establishingTunnel
+                    && HttpStatus.OK_200.statusMatches(
+                        ((HttpResponsePacket) httpHeader).getStatus())) {
+                context.establishingTunnel = false;
+                final Connection c = ctx.getConnection();
+                context.tunnelEstablished(c);
                 try {
-                    context.result(handler.onCompleted());
-                } catch (Exception e) {
+                    context.provider.execute(c,
+                            context.request,
+                            context.handler,
+                            context.future);
+                    return result;
+                } catch (IOException e) {
                     context.abort(e);
+                    return result;
                 }
             } else {
-                context.done(null);
-            }
+                cleanup(ctx, provider);
+                final AsyncHandler handler = context.handler;
+                if (handler != null) {
+                    try {
+                        context.result(handler.onCompleted());
+                    } catch (Exception e) {
+                        context.abort(e);
+                    }
+                } else {
+                    context.done(null);
+                }
 
-            return result;
+                return result;
+            }
         }
 
 
@@ -1382,7 +1443,7 @@ private static HttpTransactionContext cleanup(final FilterChainContext ctx,
                 context.abort(new IOException("Maximum pooled connections exceeded"));
             } else {
                 if (!context.provider.connectionManager.returnConnection(context.requestUrl, c)) {
-                    ctx.getConnection().close().markForRecycle(true);
+                    ctx.getConnection().close();
                 }
             }
 
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
index 70b742539..e79473859 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
+++ b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
@@ -14,6 +14,7 @@
 package com.ning.http.client.providers.grizzly;
 
 import com.ning.http.client.AsyncHttpProviderConfig;
+import org.glassfish.grizzly.http.HttpCodecFilter;
 import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
 
 import java.util.HashMap;
@@ -49,7 +50,14 @@
          *
          * @see TransportCustomizer
          */
-        TRANSPORT_CUSTOMIZER(TransportCustomizer.class);
+        TRANSPORT_CUSTOMIZER(TransportCustomizer.class),
+
+        /**
+         * Defines the maximum HTTP packet header size.
+         *
+         * @since 1.8
+         */
+        MAX_HTTP_PACKET_HEADER_SIZE(Integer.class, HttpCodecFilter.DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
         
         
         final Object defaultValue;
@@ -81,6 +89,7 @@ boolean hasDefaultValue() {
      * @throws IllegalArgumentException if the type of the specified value
      *  does not match the expected type of the specified {@link Property}.
      */
+    @SuppressWarnings("unchecked")
     @Override
     public AsyncHttpProviderConfig addProperty(Property name, Object value) {
         if (name == null) {
diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java
index a5cedaa24..6bf78717d 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java
+++ b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyResponse.java
@@ -45,9 +45,6 @@
 public class GrizzlyResponse extends ResponseBase {
     private final Buffer responseBody;
 
-    private List<Cookie> cookies;
-
-
     // ------------------------------------------------------------ Constructors
 
 
@@ -93,9 +90,7 @@ public InputStream getResponseBodyAsStream() throws IOException {
      * {@inheritDoc}
      */
     public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        if (charset == null) {
-            charset = calculateCharset();
-        }
+       charset = calculateCharset(charset);
         final int len = Math.min(responseBody.remaining(), maxLength);
         final int pos = responseBody.position();
         return responseBody.toStringContent(getCharset(charset), pos, len + pos);
@@ -148,55 +143,21 @@ public String getResponseBody() throws IOException {
     /**
      * {@inheritDoc}
      */
-    public List<Cookie> getCookies() {
-
-        if (headers == null) {
-            return Collections.emptyList();
-        }
-
-        if (cookies == null) {
-            List<String> values = headers.getHeaders().get("set-cookie");
-            if (values != null && !values.isEmpty()) {
-                CookiesBuilder.ServerCookiesBuilder builder =
-                    new CookiesBuilder.ServerCookiesBuilder(false);
-                for (String header : values) {
-                    builder.parse(header);
-                }
-                cookies = convertCookies(builder.build());
+    public List<Cookie> buildCookies() {
 
-            } else {
-                cookies = Collections.unmodifiableList(Collections.<Cookie>emptyList());
+        List<String> values = headers.getHeaders().get("set-cookie");
+        if (values != null && !values.isEmpty()) {
+            CookiesBuilder.ServerCookiesBuilder builder = new CookiesBuilder.ServerCookiesBuilder(false);
+            for (String header : values) {
+                builder.parse(header);
             }
-        }
-        return cookies;
-
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean hasResponseStatus() {
-        return (status != null);
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean hasResponseHeaders() {
-        return (headers != null && !headers.getHeaders().isEmpty());
-    }
+            return convertCookies(builder.build());
 
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean hasResponseBody() {
-        return (bodyParts != null && !bodyParts.isEmpty());
+        } else {
+        	return Collections.unmodifiableList(Collections.<Cookie>emptyList());
+        }
     }
 
-
     // --------------------------------------------------------- Private Methods
 
 
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
index 9ea1de660..102f6d84f 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/BodyChunkedInput.java
@@ -33,6 +33,8 @@
 
     private static final ByteBuffer EOF = ByteBuffer.allocate(0);
 
+    private boolean endOfInput = false;
+
     public BodyChunkedInput(Body body) {
         if (body == null) {
             throw new IllegalArgumentException("no body specified");
@@ -40,13 +42,21 @@ public BodyChunkedInput(Body body) {
         this.body = body;
     }
 
-    private ByteBuffer peekNextChuck()
+    private ByteBuffer peekNextChunk()
             throws IOException {
 
         if (nextChunk == null) {
             ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-            if (body.read(buffer) < 0) {
-                nextChunk = EOF;
+            long length = body.read(buffer);
+            if (length < 0) {
+                // Negative means this is finished
+                buffer.flip();
+                nextChunk = buffer;
+                endOfInput = true;
+            } else if (length == 0) {
+                // Zero means we didn't get anything this time, but may get next time
+                buffer.flip();
+                nextChunk = null;
             } else {
                 buffer.flip();
                 nextChunk = buffer;
@@ -55,28 +65,28 @@ private ByteBuffer peekNextChuck()
         return nextChunk;
     }
 
-    public boolean hasNextChunk()
-            throws Exception {
-        return !isEndOfInput();
+    /**
+     * Having no next chunk does not necessarily means end of input, other chunks may arrive later
+     */
+    public boolean hasNextChunk() throws Exception {
+        return peekNextChunk() != null;
     }
 
-    public Object nextChunk()
-            throws Exception {
-        ByteBuffer buffer = peekNextChuck();
-        if (buffer == EOF) {
+    public Object nextChunk() throws Exception {
+        ByteBuffer buffer = peekNextChunk();
+        if (buffer == null || buffer == EOF) {
             return null;
         }
         nextChunk = null;
+
         return ChannelBuffers.wrappedBuffer(buffer);
     }
 
-    public boolean isEndOfInput()
-            throws Exception {
-        return peekNextChuck() == EOF;
+    public boolean isEndOfInput() throws Exception {
+        return endOfInput;
     }
 
-    public void close()
-            throws Exception {
+    public void close() throws Exception {
         body.close();
     }
 
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java
new file mode 100644
index 000000000..36c4d6f90
--- /dev/null
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/FeedableBodyGenerator.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.netty;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+
+/**
+ * {@link BodyGenerator} which may return just part of the payload at the time
+ * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
+ * for finishing payload transferring asynchronously.
+ */
+public class FeedableBodyGenerator implements BodyGenerator {
+    private final static byte[] END_PADDING = "\r\n".getBytes();
+    private final static byte[] ZERO = "0".getBytes();
+    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
+    private final AtomicInteger queueSize = new AtomicInteger();
+    private FeedListener listener;
+
+    @Override
+    public Body createBody() throws IOException {
+        return new PushBody();
+    }
+
+    public void feed(final ByteBuffer buffer, final boolean isLast) throws IOException {
+        queue.offer(new BodyPart(buffer, isLast));
+        queueSize.incrementAndGet();
+        if (listener != null) {
+            listener.onContentAdded();
+        }
+    }
+
+    public static interface FeedListener {
+        public void onContentAdded();
+    }
+
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+
+    private final class PushBody implements Body {
+        private final int ONGOING = 0;
+        private final int CLOSING = 1;
+        private final int FINISHED = 2;
+
+        private int finishState = 0;
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+
+        @Override
+        public long read(final ByteBuffer buffer) throws IOException {
+            BodyPart nextPart = queue.peek();
+            if (nextPart == null) {
+                // Nothing in the queue
+                switch (finishState) {
+                case ONGOING:
+                    return 0;
+                case CLOSING:
+                    buffer.put(ZERO);
+                    buffer.put(END_PADDING);
+                    finishState = FINISHED;
+                    return buffer.position();
+                case FINISHED:
+                    buffer.put(END_PADDING);
+                    return -1;
+                }
+            }
+            int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
+            int size = Math.min(nextPart.buffer.remaining(), capacity);
+            buffer.put(Integer.toHexString(size).getBytes());
+            buffer.put(END_PADDING);
+            for (int i=0; i < size; i++) {
+              buffer.put(nextPart.buffer.get());
+            }
+            buffer.put(END_PADDING);
+            if (!nextPart.buffer.hasRemaining()) {
+                if (nextPart.isLast) {
+                    finishState = CLOSING;
+                }
+                queue.remove();
+            }
+            return size;
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+
+    }
+
+    private final static class BodyPart {
+        private final boolean isLast;
+        private final ByteBuffer buffer;
+
+        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
+            this.buffer = buffer;
+            this.isLast = isLast;
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index 4486e55f5..213c7d2b7 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -45,6 +45,7 @@
 import com.ning.http.client.listener.TransferCompletionHandler;
 import com.ning.http.client.ntlm.NTLMEngine;
 import com.ning.http.client.ntlm.NTLMEngineException;
+import com.ning.http.client.providers.netty.FeedableBodyGenerator.FeedListener;
 import com.ning.http.client.providers.netty.spnego.SpnegoEngine;
 import com.ning.http.client.websocket.WebSocketUpgradeHandler;
 import com.ning.http.multipart.MultipartBody;
@@ -145,7 +146,7 @@
 
     private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
     private final static Charset UTF8 = Charset.forName("UTF-8");
-    
+
     private final ClientBootstrap plainBootstrap;
     private final ClientBootstrap secureBootstrap;
     private final ClientBootstrap webSocketBootstrap;
@@ -488,6 +489,14 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
                             writeFuture = channel.write(bodyFileRegion);
                         } else {
                             BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
+                            BodyGenerator bg = future.getRequest().getBodyGenerator();
+                                if (bg instanceof FeedableBodyGenerator) {
+                                    ((FeedableBodyGenerator)bg).setListener(new FeedListener() {
+                                        @Override public void onContentAdded() {
+                                            channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                                        }
+                                    });
+                                }
                             writeFuture = channel.write(bodyChunkedInput);
                         }
 
@@ -645,8 +654,8 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
                     break;
                 case NTLM:
                     try {
-                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                                ntlmEngine.generateType1Msg("NTLM " + domain, authHost));
+                        String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
+                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
                     } catch (NTLMEngineException e) {
                         IOException ie = new IOException();
                         ie.initCause(e);
@@ -715,7 +724,9 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
         } else if (config.getUserAgent() != null) {
             nettyRequest.setHeader("User-Agent", config.getUserAgent());
         } else {
-            nettyRequest.setHeader("User-Agent", AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class));
+            nettyRequest.setHeader("User-Agent",
+                         AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class,
+                                                                   config));
         }
 
         if (!m.equals(HttpMethod.CONNECT)) {
@@ -1413,6 +1424,7 @@ protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future)
         }
 
         future.setState(NettyResponseFuture.STATE.RECONNECTED);
+        future.getAndSetStatusReceived(false);
 
         log.debug("Trying to recover request {}\n", future.getNettyRequest());
 
@@ -1985,7 +1997,7 @@ private boolean redirect(Request request,
                 String location = response.getHeader(HttpHeaders.Names.LOCATION);
                 URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
                 boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
-                if (!uri.toString().equalsIgnoreCase(future.getURI().toString())) {
+                if (!uri.toString().equals(future.getURI().toString())) {
                     final RequestBuilder nBuilder = stripQueryString ?
                             new RequestBuilder(future.getRequest()).setQueryParameters(null)
                             : new RequestBuilder(future.getRequest());
@@ -2069,7 +2081,7 @@ public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws
                     int statusCode = response.getStatus().getCode();
 
                     String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
-                    future.setKeepAlive(ka == null || ka.toLowerCase().equals("keep-alive"));
+                    future.setKeepAlive(ka == null || ! ka.toLowerCase().equals("close"));
 
                     List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
                     Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
@@ -2460,4 +2472,3 @@ private static boolean isSecure(URI uri) {
         return isSecure(uri.getScheme());
     }
 }
-
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
index 37ae4b67a..b09a22462 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyConnectionsPool.java
@@ -34,11 +34,13 @@
     private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
     private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
     private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
+    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
     private final AtomicBoolean isClosed = new AtomicBoolean(false);
     private final Timer idleConnectionDetector = new Timer(true);
     private final boolean sslConnectionPoolEnabled;
     private final int maxTotalConnections;
     private final int maxConnectionPerHost;
+    private final int maxConnectionLifeTimeInMs;
     private final long maxIdleTime;
 
     public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
@@ -46,6 +48,7 @@ public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
         this.maxConnectionPerHost = provider.getConfig().getMaxConnectionPerHost();
         this.sslConnectionPoolEnabled = provider.getConfig().isSslConnectionPoolEnabled();
         this.maxIdleTime = provider.getConfig().getIdleConnectionInPoolTimeoutInMs();
+        this.maxConnectionLifeTimeInMs = provider.getConfig().getMaxConnectionLifeTimeInMs();
         this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
     }
 
@@ -145,6 +148,15 @@ public boolean offer(String uri, Channel channel) {
             return false;
         }
 
+        Long createTime = channel2CreationDate.get(channel);
+        if (createTime == null){
+           channel2CreationDate.putIfAbsent(channel, System.currentTimeMillis());
+        }
+        else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < System.currentTimeMillis() ) {
+           log.debug("Channel {} expired", channel);
+           return false;
+        }
+
         log.debug("Adding uri: {} for channel {}", uri, channel);
         channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
 
@@ -222,6 +234,7 @@ private boolean remove(IdleChannel pooledChannel) {
      * {@inheritDoc}
      */
     public boolean removeAll(Channel channel) {
+        channel2CreationDate.remove(channel);
         return !isClosed.get() && remove(channel2IdleChannel.get(channel));
     }
 
@@ -251,11 +264,13 @@ public void destroy() {
         }
         connectionsPool.clear();
         channel2IdleChannel.clear();
+        channel2CreationDate.clear();
     }
 
     private void close(Channel channel) {
         try {
             channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel2CreationDate.remove(channel);
             channel.close();
         } catch (Throwable t) {
             // noop
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java
index 78528280c..dd2b2a0de 100644
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponse.java
@@ -32,7 +32,6 @@
  * Wrapper around the {@link com.ning.http.client.Response} API.
  */
 public class NettyResponse extends ResponseBase {
-    private final List<Cookie> cookies = new ArrayList<Cookie>();
 
     public NettyResponse(HttpResponseStatus status,
                          HttpResponseHeaders headers,
@@ -47,56 +46,23 @@ public String getResponseBodyExcerpt(int maxLength) throws IOException {
 
     public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
         // should be fine; except that it may split multi-byte chars (last char may become '?')
-        if (charset == null) {
-            charset = calculateCharset();
-        }
+        charset = calculateCharset(charset);
         byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
         return new String(b, charset);
     }
-
-    /* @Override */
-
-    public List<Cookie> getCookies() {
-        if (headers == null) {
-            throw new IllegalStateException(HEADERS_NOT_COMPUTED);
-        }
-        if (cookies.isEmpty()) {
-            for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
-                if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
-                    // TODO: ask for parsed header
-                    List<String> v = header.getValue();
-                    for (String value : v) {
-                        Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
-                        cookies.add(cookie);
-                    }
+    
+    protected List<Cookie> buildCookies() {
+    	List<Cookie> cookies = new ArrayList<Cookie>();
+        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+            if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
+                // TODO: ask for parsed header
+                List<String> v = header.getValue();
+                for (String value : v) {
+                    Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
+                    cookies.add(cookie);
                 }
             }
         }
         return Collections.unmodifiableList(cookies);
     }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseStatus() {
-        return (status != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseHeaders() {
-        return (headers != null ? true : false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    /* @Override */
-    public boolean hasResponseBody() {
-        return (bodyParts != null && bodyParts.size() > 0 ? true : false);
-    }
-
 }
diff --git a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
index bb58421dc..68dd5ed03 100755
--- a/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
+++ b/providers/netty/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
@@ -212,7 +212,13 @@ public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException,
 
             if (expired) {
                 isCancelled.set(true);
-                TimeoutException te = new TimeoutException(String.format("No response received after %s", l));
+                try {
+                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+                    channel.close();
+                } catch (Throwable t) {
+                    // Ignore
+                }
+                TimeoutException te = new TimeoutException(String.format("No response received after %s %s", l, tu.name().toLowerCase()));
                 if (!throwableCalled.getAndSet(true)) {
                     try {
                         asyncHandler.onThrowable(te);
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java
new file mode 100644
index 000000000..066990482
--- /dev/null
+++ b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyRequestThrottleTimeoutTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.netty;
+
+import com.ning.http.client.*;
+import com.ning.http.client.async.AbstractBasicTest;
+import com.ning.http.client.async.ProviderUtil;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.*;
+
+import static org.testng.Assert.*;
+import static org.testng.Assert.fail;
+
+public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
+    private static final String MSG = "Enough is enough.";
+    private static final int SLEEPTIME_MS = 1000;
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
+    }
+
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(SLEEPTIME_MS);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        log.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        log.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
+
+    @Test(groups = {"standalone", "netty_provider"})
+    public void testRequestTimeout() throws IOException {
+        final Semaphore requestThrottle = new Semaphore(1);
+
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
+                .setCompressionEnabled(true)
+                .setAllowPoolingConnection(true)
+                .setMaximumConnectionsTotal(1).build());
+
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
+        for(int i=0;i<2;i++) {
+            final int threadNumber = i;
+            new Thread(new Runnable() {
+
+                public void run() {
+                    try {
+                        requestThrottle.acquire();
+                        PerRequestConfig requestConfig = new PerRequestConfig();
+                        requestConfig.setRequestTimeoutInMs(SLEEPTIME_MS/2);
+                        Future<Response> responseFuture = null;
+                        try {
+                             responseFuture =
+                                    client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute(new AsyncCompletionHandler<Response>() {
+
+                                        @Override
+                                        public Response onCompleted(Response response) throws Exception {
+                                            requestThrottle.release();
+                                            return response;
+                                        }
+
+                                        @Override
+                                        public void onThrowable(Throwable t) {
+                                            requestThrottle.release();
+                                        }
+                                    });
+                        } catch(Exception e) {
+                            tooManyConnections.add(e);
+                        }
+
+                        if(responseFuture!=null)
+                            responseFuture.get();
+                    } catch (Exception e) {
+                    } finally {
+                        latch.countDown();
+                    }
+
+                }
+            }).start();
+
+
+        }
+
+        try {
+            latch.await(30,TimeUnit.SECONDS);
+        } catch (Exception e) {
+            fail("failed to wait for requests to complete");
+        }
+
+        assertTrue(tooManyConnections.size()==0,"Should not have any connection errors where too many connections have been attempted");
+
+        client.close();
+    }
+}
